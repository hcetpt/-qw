#!/bin/bash

# 保存函数，翻译完成后，将临时存储的内容存到原文件名_cn.后缀
create_cn_version() {
    # 检查是否提供了文件路径参数
    if [ "$#" -ne 1 ]; then
        echo "使用方法: create_cn_version <文件路径>"
        return 1
    fi

    local original_file="$1"
    # 获取文件的基本名称和扩展名
    local base_name=$(basename -- "$original_file")
    local extension="${base_name##*.}"
    local name_no_ext="${base_name%.*}"

    # 构建新文件名
    local new_file_name="${name_no_ext}_cn.${extension}"
    new_file_path=$(dirname "$original_file")"/"${new_file_name}

    # 创建新文件（这里只是touch创建空文件，根据需要可以写入内容）
    touch "$new_file_path"
    if [ $? -eq 0 ]; then
        echo "新文件已创建: $new_file_path"
    else
        echo "创建文件时发生错误。"
        return 1
    fi
}


# 如果没有提供路径参数,就会获取input/question中内容
if [ "$#" -ne 1 ]; then
    echo "传入默认文件input/question"
    python script/a.py input/question | jq -M -r '.choices[0].message.content'
    exit 1
fi

# 存储输入的路径
path="$1"

# 使用find命令查找所有文件（包括子目录中的），并将结果保存到数组中
mapfile -t files < <(find "$path" -type f)

# 检查是否找到文件
if [ ${#files[@]} -eq 0 ]; then
    echo "没有找到文件。"
else
    # 遍历文件数组，并将每个文件路径作为参数传递给qw脚本
    for file in "${files[@]}"; do
        #./qw "$file"
	create_cn_version "$file"
	python script/a.py "$file" | jq -M -r '.choices[0].message.content' > "$new_file_path"
    done
fi


# 示例使用
# 假设你要基于一个示例文件创建中文版
# create_cn_version "/path/to/your/original_file.txt"
