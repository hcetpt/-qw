SPDX 许可证标识符: GPL-2.0

===================================================
内核测试任何协议 (KTAP)，版本 1
===================================================

TAP，或测试任何协议，是一种用于指定测试结果的格式，被多个项目使用。它的网站和规范可以在这个 [链接](https://testanything.org/) 中找到。Linux 内核在很大程度上使用 TAP 输出来表示测试结果。然而，内核测试框架对测试结果有特殊需求，这些需求与原始 TAP 规范不一致。因此，规定了一种“内核 TAP”(KTAP) 格式来扩展和修改 TAP 以支持这些用例。本规范描述了当前内核中普遍接受的 KTAP 格式的使用情况。

KTAP 测试结果描述了一系列测试（可能嵌套：即，测试可以包含子测试），每个测试都可以包含诊断数据（例如，日志行）以及最终结果。测试结构和结果是机器可读的，而诊断数据是无结构的，它在那里是为了帮助人类调试。

KTAP 输出由四种不同类型的行构建：
- 版本行
- 计划行
- 测试用例结果行
- 诊断行

一般来说，有效的 KTAP 输出也应该构成有效的 TAP 输出，但某些信息，特别是嵌套的测试结果，可能会丢失。此外，请注意，对于 TAP14 存在一个停滞的草案规范，KTAP 在几个地方与之不同（尤其是“子测试”头），这些不同之处将在本文档后面的适当位置进行描述。
版本行
-------------

所有 KTAP 格式的测试结果都以“版本行”开始，该行指定了结果遵循的 (K)TAP 标准的版本。
例如：
- “KTAP version 1”
- “TAP version 13”
- “TAP version 14”

请注意，在 KTAP 中，子测试也以版本行开始，这标志着嵌套测试结果的开始。这与 TAP14 不同，TAP14 使用单独的“子测试”行。

虽然从今往后，符合规范的测试应使用“KTAP version 1”，但预计大多数解析器和其他工具为了与现有的测试和框架兼容，将接受这里列出的其他版本。
计划行
----------

测试计划提供了 KTAP 输出中的测试（或子测试）数量。
计划行必须遵循“1..N”的格式，其中 N 是测试或子测试的数量。
计划行跟随版本行之后，以指示嵌套测试的数量。
虽然存在一些情况下测试次数无法提前确定——在这种情况下可以省略测试计划——但强烈建议尽可能提供一个测试计划。
测试用例结果行
----------------------

测试用例结果行表示测试的最终状态。
这些行是必需的，必须遵循以下格式：

.. code-block:: none

	<result> <number> [<description>][ # [<directive>] [<诊断数据>]]

其中，结果可以是 "ok"，表示测试用例通过；
或者是 "not ok"，表示测试用例失败。
<number> 代表正在进行的测试编号。第一个测试必须编号为 1，并且对于同一级别嵌套下的每个附加子测试，编号需要递增 1。
描述是对测试的一般性描述，通常是测试名称，可以是任何字符（除了 # 或换行符）。描述虽然是可选的，但建议提供。
指令和任何诊断数据都是可选的。如果存在，它们必须跟在井号 (#) 后面。
指令是一个关键词，表明测试的结果不同于通过或失败。指令是可选的，由单个关键词构成，位于诊断数据之前。如果解析器遇到不支持的指令，则应回退到 "ok" / "not ok" 的结果。
目前接受的指令包括：

- "SKIP"，表示测试被跳过（注意：如果使用了 SKIP 指令，测试用例结果行的结果可以是 "ok" 或 "not ok"）
- "TODO"，表示当前预期该测试不会通过，例如因为正在测试的功能已知存在问题。尽管此指令继承自 TAP，但在内核中的使用并不推荐
- "XFAIL"，表示预期测试会失败。这与 "TODO" 类似，被某些 kselftest 测试所使用
- “TIMEOUT”，表示测试超时（注意：如果使用了 TIMEOUT 指令，测试用例结果行的结果应该是 “not ok”）
- “ERROR”，表示测试执行因特定错误而失败，具体错误包含在诊断数据中。（注意：如果使用了 ERROR 指令，测试用例结果行的结果应该是 “not ok”）

诊断数据是一个纯文本字段，包含导致产生此结果的任何额外信息。这通常是在 ERROR 或失败测试中的错误消息，或是 SKIP 结果中缺失依赖项的描述。
诊断数据字段是可选的，对于既没有指令也没有任何诊断数据的结果，不需要包含“#”字段分隔符。
示例结果行包括：

```
ok 1 test_case_name

```

测试 "test_case_name" 通过。

```
not ok 1 test_case_name

```

测试 "test_case_name" 失败。

```
ok 1 test # SKIP necessary dependency unavailable

```

测试 "test" 被跳过，诊断信息为 "必要的依赖项不可用"。

```
not ok 1 test # TIMEOUT 30 seconds

```

测试 "test" 超时，诊断数据为 "30 秒"。

```
ok 5 check return code # rcode=0

```

测试 "check return code" 通过，附加诊断数据为 “rcode=0”。

### 诊断行

如果测试希望输出更多信息，则应使用“诊断行”。诊断行是可选的、自由格式文本，通常用于更详细地描述正在测试的内容及任何中间结果，这些内容比最终结果和诊断数据行提供的信息更为丰富。诊断行的格式为 "# <诊断描述>"，其中描述可以是任何字符串。诊断行可以在测试输出中的任意位置。通常情况下，与特定测试相关的诊断行直接位于该测试结果行之前。
请注意，大多数工具会将未知行（见下文）视为诊断行，即使它们不以 "#" 开头：这是为了捕获任何可能有助于调试测试的其他有用的内核输出。尽管如此，仍然建议测试始终在任何诊断输出前加上 "#" 字符。

### 未知行

KTAP 输出中可能存在不符合上述四种行格式的行。这被允许，但这些行不会影响测试的状态。
这一点与 TAP 有重要区别。内核测试可能会向系统控制台或日志文件打印消息。这两个目的地都可能包含来自与测试无关的内核活动或由测试调用的非测试代码产生的内核消息。由测试调用的内核代码很可能并不知道正在进行测试，因此不能将其消息作为诊断消息来打印。
嵌套测试
------------

在KTAP中，测试可以被嵌套。这是通过让一个测试在其输出中包含一整套KTAP格式的结果来实现的。这可用于对相关测试进行分类和分组，或从同一个测试中拆分出不同的结果。"父"测试的结果应由其所有子测试的结果组成，从另一个KTAP版本行和测试计划开始，并以总体结果结束。如果其中一个子测试失败，例如，父测试也应失败。
此外，子测试中的所有行都应缩进。一级缩进是两个空格：“  ”。缩进应从版本行开始，并应在父测试的结果行之前结束。
“未知行”不被视为子测试中的行，因此允许缩进或不缩进。
一个带有两个嵌套子测试的测试示例：

::

    KTAP version 1
    1..1
      KTAP version 1
      1..2
      ok 1 test_1
      not ok 2 test_2
    # example failed
    not ok 1 example

具有多级嵌套测试的示例格式：

::

    KTAP version 1
    1..2
      KTAP version 1
      1..2
        KTAP version 1
        1..2
        not ok 1 test_1
        ok 2 test_2
      not ok 1 test_3
      ok 2 test_4 # SKIP
    not ok 1 example_test_1
    ok 2 example_test_2


TAP与KTAP的主要差异
--------------------------------------

==================================================   =========  ===============
特性                                                TAP        KTAP
==================================================   =========  ===============
诊断消息中的yaml和json                             允许       不推荐
TODO指令                                            允许       不识别
允许任意数量的测试嵌套                             不允许     允许
"未知行"属于"其他"类别                               是         否
"未知行"                                            错误       允许
==================================================   =========  ===============

TAP14规范确实允许嵌套测试，但不是使用另一个嵌套的版本行，而是使用形式为"Subtest: <name>"的行，其中<name>是父测试的名称。
KTAP输出示例
--------------------

::

    KTAP version 1
    1..1
      KTAP version 1
      1..3
        KTAP version 1
        1..1
        # test_1: initializing test_1
        ok 1 test_1
      ok 1 example_test_1
        KTAP version 1
        1..2
        ok 1 test_1 # SKIP test_1 skipped
        ok 2 test_2
      ok 2 example_test_2
        KTAP version 1
        1..3
        ok 1 test_1
        # test_2: FAIL
        not ok 2 test_2
        ok 3 test_3 # SKIP test_3 skipped
      not ok 3 example_test_3
    not ok 1 main_test

此输出定义了以下层次结构：

一个名为"main_test"的测试，它失败了，并且有三个子测试：
- "example_test_1"，通过了，并有一个子测试：

   - "test_1"，通过了，并输出诊断信息"test_1: initializing test_1"

- "example_test_2"，通过了，并有两个子测试：

   - "test_1"，被跳过，解释为"test_1 skipped"
   - "test_2"，通过了

- "example_test_3"，失败了，并有三个子测试

   - "test_1"，通过了
   - "test_2"，输出诊断信息"test_2: FAIL"，并失败
- "test_3"，被跳过，解释为"test_3 skipped"

请注意，具有相同名称的各个子测试不会发生冲突，因为它们位于不同的父测试中。此输出还展示了一些关于“冒泡”测试结果的合理规则：如果任何子测试失败，则测试失败。
被跳过的测试不影响父测试的结果（尽管通常情况下，如果一个测试的所有子测试都被跳过，则该测试被标记为跳过是有意义的）。

参考：
---------

- TAP规范：
  https://testanything.org/tap-version-13-specification.html
- （停滞不前的）TAP版本14规范：
  https://github.com/TestAnything/Specification/blob/tap-14-specification/specification.md
- kselftest文档：
  Documentation/dev-tools/kselftest.rst
- KUnit文档：
  Documentation/dev-tools/kunit/index.rst
