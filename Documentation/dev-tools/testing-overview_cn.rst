### SPDX 许可证标识符：GPL-2.0

====================
内核测试指南
====================

有许多不同的工具可以用来测试 Linux 内核，因此了解何时使用这些工具中的每一个可能会是一项挑战。本文件提供了它们之间差异的大致概述，以及它们如何相互配合。

编写和运行测试
=========================

大部分内核测试是使用 kselftest 或 KUnit 框架编写的。这两种框架都提供了基础设施来帮助简化测试及测试组的运行，并且提供了辅助功能以帮助编写新的测试。
如果你希望验证内核的行为——特别是内核的特定部分——那么你可能需要使用 KUnit 或 kselftest。

KUnit 与 kselftest 的区别
------------------------------------------

KUnit（文档/dev-tools/kunit/index.rst）是一个完全在内核内部的系统，用于“白盒”测试：因为测试代码是内核的一部分，它可以访问那些不向用户空间暴露的内部结构和函数。
因此，KUnit 测试最适合针对内核的小型、自包含的部分编写，这些部分可以在隔离环境下进行测试。这与“单元”测试的概念相吻合。
例如，一个 KUnit 测试可能会测试单个内核函数（甚至是函数中的单一代码路径，比如错误处理的情况），而不是整个特性。
这也使得 KUnit 测试非常快速地构建和运行，从而允许它们作为开发过程的一部分频繁地运行。
有一个 KUnit 测试风格指南，可以在文档/dev-tools/kunit/style.rst 中找到更多指导。

另一方面，kselftest（文档/dev-tools/kselftest.rst）主要在用户空间实现，测试是普通的用户空间脚本或程序。
这使得编写更复杂的测试变得更容易，或者编写需要更多操纵整个系统状态的测试（例如，启动进程等）。
然而，从 kselftest 中直接调用内核函数是不可能的。
这意味着只有某种方式暴露给用户空间的内核功能（例如通过系统调用、设备、文件系统等）才能使用kselftest进行测试。为了绕过这一限制，一些测试包括了一个辅助的内核模块来暴露更多的信息或功能。然而，如果一个测试主要或完全在内核中运行，KUnit可能是更合适的工具。因此，kselftest非常适合用于测试完整的特性，因为这些特性会向用户空间暴露接口，可以被测试，但不会暴露实现细节。这与“系统”或“端到端”的测试相一致。
例如，所有新的系统调用都应该伴随有kselftest测试。

代码覆盖率工具
=================

Linux内核支持两种不同的代码覆盖率测量工具。这些工具可用于验证测试是否执行了特定的功能或代码行。这对于确定多少内核代码被测试以及寻找未被适当测试覆盖的边缘情况非常有用。
`Documentation/dev-tools/gcov.rst` 是GCC的覆盖率测试工具，它可以与内核一起使用以获得全局或每个模块的覆盖率。与KCOV不同，它不记录每个任务的覆盖率。覆盖率数据可以从debugfs读取，并使用通常的gcov工具进行解析。
`Documentation/dev-tools/kcov.rst` 是一种可以构建到内核中的特性，允许捕捉每个任务级别的覆盖率。因此，它对于模糊测试和其他需要了解单个系统调用期间执行代码信息的情况非常有用。

动态分析工具
======================

内核还支持多种动态分析工具，这些工具试图在运行中的内核中检测出各种类型的问题。它们通常各自查找不同类别的错误，如无效内存访问、并发问题（例如数据竞争），或其他未定义的行为（例如整数溢出）。
以下列出了一些这类工具：

* `kmemleak` 检测可能的内存泄漏。详情参见 `Documentation/dev-tools/kmemleak.rst`
* `KASAN` 检测无效的内存访问，如越界和释放后使用错误。详情参见 `Documentation/dev-tools/kasan.rst`
* `UBSAN` 检测C标准未定义的行为，如整数溢出。详情参见 `Documentation/dev-tools/ubsan.rst`
* `KCSAN` 检测数据竞争。详情参见 `Documentation/dev-tools/kcsan.rst`
* `KFENCE` 是一个低开销的内存问题检测器，比KASAN快得多，并且可以在生产环境中使用。详情参见 `Documentation/dev-tools/kfence.rst`
* `lockdep` 是一个锁定正确性的验证器。详情参见 `Documentation/locking/lockdep-design.rst`
* `Runtime Verification (RV)` 支持为特定子系统检查特定行为。详情参见 `Documentation/trace/rv/runtime-verification.rst`
* 内核中有其他几种调试工具，许多可以在 `lib/Kconfig.debug` 中找到

这些工具倾向于整体测试内核，并不像kselftest或KUnit测试那样通过与否。它们可以通过在一个启用了这些工具的内核上运行测试与KUnit或kselftest结合使用：这样就可以确保在测试过程中没有发生这些错误。
其中一些工具与KUnit或kselftest集成，并会在检测到问题时自动使测试失败。

静态分析工具
=====================

除了测试正在运行的内核之外，还可以直接（**在编译时**）使用**静态分析**工具分析内核源代码。常用的内核工具允许您检查整个源代码树或仅其中的特定文件。它们使得在开发过程中更容易发现并修复问题。
Sparse可以帮助通过执行类型检查、锁检查、值范围检查，并在检查代码时报告各种错误和警告来测试内核。有关如何使用它的详细信息，请参阅文档/开发工具/sparse.rst 文档页面。

Smatch扩展了Sparse，并为诸如在switch语句中遗漏break、错误检查时未使用的返回值、忘记在错误路径的返回中设置错误码等编程逻辑错误提供了额外的检查。Smatch还包括针对更严重问题的测试，如整数溢出、空指针解引用和内存泄漏。详情请参见项目页面 http://smatch.sourceforge.net/

Coccinelle是我们可用的另一种静态分析器。Coccinelle通常用于辅助重构和源代码的伴随进化，但也能帮助避免某些出现在常见代码模式中的错误。可用的测试类型包括API测试、正确使用内核迭代器的测试、释放操作健全性的检查、锁定行为的分析，以及已知有助于保持内核使用一致性的其他测试。详情请参阅文档/开发工具/coccinelle.rst 文档页面。

但是请注意，静态分析工具存在**误报**的问题。
需要仔细评估错误和警告，在尝试修复它们之前。

何时使用Sparse和Smatch
-----------------------

Sparse进行类型检查，例如验证注释过的变量不会导致字节序错误，检测不当使用`__user`指针的地方，以及分析符号初始化器的兼容性。

Smatch进行流程分析，如果允许构建函数数据库，则还进行跨函数分析。Smatch试图回答类似这样的问题：这个缓冲区在哪里分配的？它有多大？这个索引可以被用户控制吗？这个变量比那个变量大吗？

通常来说，在Smatch中编写检查比在Sparse中更容易。尽管如此，Sparse和Smatch之间还是存在一些重叠的检查。

Smatch和Coccinelle的优点
----------------------

Coccinelle可能是编写检查最容易的工具。它在预处理器之前工作，因此使用Coccinelle更容易发现宏中的错误。

Coccinelle还会为您创建补丁，这是其他任何工具都无法做到的。
例如，使用Coccinelle您可以将大量“kmalloc(x * size, GFP_KERNEL)”转换为“kmalloc_array(x, size, GFP_KERNEL)”，这非常有用。如果您仅仅创建了一个Smatch警告，并试图将转换的工作推给维护者，他们可能会感到烦恼。您必须就每个警告是否真的可能溢出进行争论。
Coccinelle不对变量值进行分析，这是Smatch的一个优势。另一方面，Coccinelle让你能够以简单的方式完成简单的事情。
