... SPDX 许可证标识符: GPL-2.0

===========================
测试风格和命名规则
===========================

为了尽可能简化查找、编写和使用 KUnit 测试的过程，强烈建议根据以下指导原则来命名和编写它们。虽然可以编写不遵循这些规则的 KUnit 测试，但这样做可能会破坏某些工具、与其他测试产生冲突，并且可能不会被测试系统自动运行。
只有在以下情况下，才建议偏离这些指导原则：

1. 将已知名称的测试移植到 KUnit 中
2. 编写如果自动运行会导致严重问题的测试。例如，非确定性地产生假阳性和假阴性结果，或者运行时间过长
子系统、测试套件与测试
=============================

为了便于查找测试，我们将它们分组为测试套件和子系统。一个测试套件是一组用于测试内核相关区域的测试集合。子系统则是一组测试套件，用于测试内核子系统的不同部分或驱动程序。
子系统
----------

每个测试套件必须属于一个子系统。子系统是包含一个或多个 KUnit 测试套件的集合，用于测试相同的驱动程序或内核的部分。测试子系统应当对应于单个内核模块。如果被测试的代码无法编译为模块，在许多情况下，子系统应该对应源码树中的目录或“MAINTAINERS”文件中的条目。如果不确定，请参照类似领域内的测试所遵循的约定。
测试子系统的命名应与被测试的代码相对应，最好是模块名（如果可能的话），或者至少是被测试的目录或文件名。必要时，测试子系统的命名要避免歧义。
如果测试子系统的名称包含多个组成部分，它们应用下划线分隔。**不要**直接在子系统名称中包含“test”或“kunit”，除非我们实际上是在测试其他测试或 KUnit 框架本身。例如，子系统可以命名为：

``ext4``
  与模块和文件系统名称匹配
``apparmor``
  与模块名称和 LSM 名称匹配
``kasan``
  工具的通用名称，也是路径 `mm/kasan` 的显著部分
``snd_hda_codec_hdmi``
  包含多个组成部分（`snd`、`hda`、`codec`、`hdmi`），由下划线分隔。与模块名称匹配
避免采用以下示例所示的命名方式：

``linear-ranges``
  命名应使用下划线而不是短横线来分隔单词。更推荐使用 `linear_ranges`
```qos-kunit-test```
此名称应当使用下划线，并且不应以“kunit-test”作为后缀。“qos”作为子系统名称也存在歧义，因为内核的多个部分都有一个名为“qos”的子系统。`power_qos`会是一个更好的名称。
`pc_parallel_port`
对应的模块名称是`parport_pc`，因此该子系统也应命名为`parport_pc`。
.. note::
        KUnit API 和工具并不明确识别子系统。它们是一种对测试套件进行分类和为模块命名的方式，为人类提供了一种简单、一致的方法来查找和运行测试。这一点在未来可能会发生变化。
套件
------

KUnit 测试被组织成测试套件，这些套件覆盖了正在测试的具体功能区域。测试套件可以有共享的初始化和关闭代码，这些代码会在套件中的所有测试中运行。并非所有的子系统都需要拆分成多个测试套件（例如，简单的驱动程序）。
测试套件以它们所属的子系统的名称命名。如果一个子系统包含几个套件，则应在子系统名称后面加上具体测试的领域，中间用下划线分隔。
如果一个子系统内有多种类型的测试使用 KUnit（例如，既有单元测试又有集成测试），则应将它们放入不同的套件中，其中测试类型作为套件名称的最后一部分。除非这些测试确实存在，否则不要在套件名称中使用`_test`、`_unittest`或类似的后缀。
完整的测试套件名称（包括子系统名称）应指定为`kunit_suite`结构体的`.name`成员，并构成模块名称的基础。例如，测试套件可能包括：

`ext4_inode`
  属于`ext4`子系统，测试`inode`区域
`kunit_try_catch`
  属于`kunit`实现本身，测试`try_catch`区域
`apparmor_property_entry`
  属于`apparmor`子系统，测试`property_entry`区域
`kasan`
  `kasan`子系统只有一个套件，因此套件名称与子系统名称相同。
避免使用以下类型的名字，例如：

``ext4_ext4_inode``
   没有必要两次提及子系统名称。
``property_entry``
   如果没有子系统名称，测试套件的名称可能会引起混淆。
``kasan_integration_test``
   因为在``kasan``子系统中只有一个测试套件，因此该套件应该直接命名为``kasan``。不要重复添加
   ``integration_test``。它应该是一个独立的测试套件。例如，如果添加了单元测试，则该套件可以命名为``kasan_unittest``或类似名称。

测试案例
--------

单个测试由一个函数组成，用于测试特定的代码路径、属性或功能。在测试输出中，单个测试的结果将作为套件结果的子测试显示。
测试应以其所测试的内容命名。这通常是被测试函数的名称，加上对输入或被测试代码路径的描述。
由于测试是C语言中的函数，它们的命名和编写应遵循内核编码风格。
.. note::
        由于测试本身就是函数，它们的名称不能与内核中的其他C标识符冲突。这可能需要一些创意性的命名。将测试函数声明为`static`是个好主意，以避免污染全局命名空间。
示例测试名称包括：

``unpack_u32_with_null_name``
   测试当传入NULL名称时``unpack_u32``函数的行为。
``test_list_splice``
   测试``list_splice``宏。为了防止与宏本身产生命名冲突，其前缀为``test_``。
如果有必要在测试套件之外提及某个测试，测试的*全限定*名称应该是套件名称后跟测试名称，两者之间用冒号分隔（即``suite:test``）。
测试 Kconfig 项
====================

每个测试套件都应与一个 Kconfig 项关联。
这个 Kconfig 项必须：

* 命名为 `CONFIG_<name>_KUNIT_TEST`：其中 `<name>` 是测试套件的名称
* 列出在被测试的驱动程序/子系统的配置项旁边，或者位于 [内核黑客]->[内核测试和覆盖率] 下
* 依赖于 `CONFIG_KUNIT`
* 只有当 `CONFIG_KUNIT_ALL_TESTS` 没有启用时才可见
* 默认值为 `CONFIG_KUNIT_ALL_TESTS`
* 在帮助文本中简要介绍 KUnit

如果无法满足上述条件（例如，测试无法作为模块构建），则测试的 Kconfig 项应为三态。

例如，一个 Kconfig 项可能如下所示：

```plaintext
config FOO_KUNIT_TEST
	tristate "foo 的 KUnit 测试" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
		这将构建 foo 的单元测试
有关 KUnit 和一般单元测试的更多信息，
		请参阅文档目录下的 KUnit 文档：Documentation/dev-tools/kunit/
不确定时，请选择 N
```

这段文字描述了如何为 Linux 内核中的 KUnit 测试套件创建合适的 Kconfig 配置项，并提供了一个具体的例子。
测试文件和模块名称
==========================

KUnit 测试经常可以被编译为一个模块。这些模块应当以测试套件的名字来命名，后面加上 ``_test``。如果这样做可能会与非 KUnit 的测试产生冲突，也可以使用后缀 ``_kunit``。
最容易实现这一点的方法是将包含测试套件的文件命名为 ``<suite>_test.c``（或者如上所述，``<suite>_kunit.c``）。这个文件应该放在被测试代码的旁边。
如果套件名称包含了测试所属父目录的部分或全部名称，那么修改源文件名以减少冗余可能是有意义的。
例如，一个名为 ``foo_firmware`` 的测试套件可以位于 ``foo/firmware_test.c`` 文件中。
