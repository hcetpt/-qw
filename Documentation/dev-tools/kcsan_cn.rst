### SPDX 许可证标识符：GPL-2.0
### 版权所有 (C) 2019，Google LLC

#### 内核并发检查器（KCSAN）
====================================

内核并发检查器（KCSAN）是一个动态的数据竞争检测器，它依赖于编译时的插桩，并使用基于监视点的采样方法来检测数据竞争。KCSAN 的主要目的是检测 `数据竞争`_。

##### 使用

KCSAN 同时支持 GCC 和 Clang。对于 GCC，我们要求版本为 11 或更高；对于 Clang，也要求版本为 11 或更高。
要启用 KCSAN，请按如下配置内核：

    CONFIG_KCSAN = y

KCSAN 提供了其他几个配置选项以自定义行为（更多信息请参阅 `lib/Kconfig.kcsan` 中的相关帮助文本）。

##### 错误报告

一个典型的数据竞争报告如下所示：

    ==================================================================
    BUG: KCSAN: 数据竞争在 test_kernel_read / test_kernel_write

    由任务 487 在 cpu 0 上对 0xffffffffc009a628 地址写入 8 字节：
     test_kernel_write+0x1d/0x30
     access_thread+0x89/0xd0
     kthread+0x23e/0x260
     ret_from_fork+0x22/0x30

    由任务 488 在 cpu 6 上对 0xffffffffc009a628 地址读取 8 字节：
     test_kernel_read+0x10/0x20
     access_thread+0x89/0xd0
     kthread+0x23e/0x260
     ret_from_fork+0x22/0x30

    值改变：0x00000000000009a6 -> 0x00000000000009b2

    由内核并发检查器报告：
    CPU: 6 PID: 488 进程: access_thread 未被污染 5.12.0-rc2+ #1
    硬件名称: QEMU 标准 PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
    ==================================================================

报告头部提供了涉及数据竞争的函数的简短总结。接下来是两个线程的访问类型和堆栈跟踪。如果 KCSAN 观察到了值的变化，则会在“值改变”行显示观察到的旧值和新值。

另一种不太常见的数据竞争报告如下所示：

    ==================================================================
    BUG: KCSAN: 数据竞争在 test_kernel_rmw_array+0x71/0xd0

    在未知起源的竞争中，由任务 515 在 cpu 2 上对 0xffffffffc009bdb0 地址读取 8 字节：
     test_kernel_rmw_array+0x71/0xd0
     access_thread+0x89/0xd0
     kthread+0x23e/0x260
     ret_from_fork+0x22/0x30

    值改变：0x0000000000002328 -> 0x0000000000002329

    由内核并发检查器报告：
    CPU: 2 PID: 515 进程: access_thread 未被污染 5.12.0-rc2+ #1
    硬件名称: QEMU 标准 PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
    ==================================================================

这种报告是在无法确定另一个竞争线程的情况下生成的，但通过监视内存位置的数据值发生变化推断出存在竞争。这类报告总是会显示一条“值改变”的信息。这类报告的常见原因是竞争线程中缺少插桩，但也可能是由于 DMA 访问等原因。这些报告仅在 `CONFIG_KCSAN_REPORT_RACE_UNKNOWN_ORIGIN=y` 被启用时才会显示，这是默认设置。

##### 选择性分析

可能需要为特定的访问、函数、编译单元或整个子系统禁用数据竞争检测。对于静态黑名单，以下选项可用：

* KCSAN 支持 `data_race(expr)` 注释，这告诉 KCSAN 忽略 `expr` 中任何由于访问引起的数据竞争，并认为遇到数据竞争时的行为是安全的。更多信息请参见 `"标记共享内存访问" 在 LKMM`_。
* 类似于 `data_race(...)`，类型限定符 `__data_racy` 可用于记录所有对某个变量的访问导致的数据竞争都是有意的，且应被 KCSAN 忽略：

    ```c
    struct foo {
        ..
        int __data_racy stats_counter;
        ..
    };
    ```

* 为了整个函数禁用数据竞争检测，可以使用函数属性 `__no_kcsan`：

    ```c
    __no_kcsan
    void foo(void) {
        ..
    }
    ```
为了动态地限制为哪些函数生成报告，请参阅`DebugFS接口`_的黑名单/白名单功能。

* 要禁用特定编译单元的数据竞争检测，可在`Makefile`中添加如下内容：

    ```makefile
    KCSAN_SANITIZE_file.o := n
    ```

* 要禁用`Makefile`中列出的所有编译单元的数据竞争检测，可在相应的`Makefile`中添加如下内容：

    ```makefile
    KCSAN_SANITIZE := n
    ```

有关“标记共享内存访问”的更多信息，请参阅LKMM中的[文档](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/memory-model/Documentation/access-marking.txt)。

此外，可以根据个人偏好来告诉KCSAN显示或隐藏整个类别的数据竞争。这些可以通过以下Kconfig选项进行更改：

* `CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY`：如果启用，并且通过观察点观察到冲突写操作，但内存位置的数据值保持不变，则不报告该数据竞争。
* `CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC`：默认情况下假设对齐的简单写操作（最多到字大小）是原子性的。假设这样的写操作不会因不安全的编译器优化而引发数据竞争。此选项会导致KCSAN不报告仅涉及对齐写操作（最多到字大小）的冲突所导致的数据竞争。
* `CONFIG_KCSAN_PERMISSIVE`：启用额外的宽容规则以忽略某些常见的数据竞争类别。与上述选项不同的是，这些规则更为复杂，涉及到值变化模式、访问类型和地址。此选项依赖于`CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY=y`。详情请参阅`kernel/kcsan/permissive.h`。只关注特定子系统报告而不关心整个内核的测试者和维护者建议禁用此选项。
为了使用最严格的规则，可以选择`CONFIG_KCSAN_STRICT=y`，这将配置KCSAN尽可能接近遵循Linux内核内存一致性模型（LKMM）。

### DebugFS接口

文件`/sys/kernel/debug/kcsan`提供了以下接口：

* 读取`/sys/kernel/debug/kcsan`会返回各种运行时统计信息。
* 向`/sys/kernel/debug/kcsan`写入`on`或`off`可以分别打开或关闭KCSAN。
* 向`/sys/kernel/debug/kcsan`写入`!some_func_name`会将`some_func_name`添加到报告过滤列表中，默认情况下，该列表黑名单化了当栈顶帧之一是列表中的函数时的数据竞争报告。
* 向`/sys/kernel/debug/kcsan`写入`blacklist`或`whitelist`可以改变报告过滤行为。例如，黑名单功能可用于屏蔽频繁出现的数据竞争；白名单功能有助于重现和测试修复。

### 性能调优

影响KCSAN整体性能和缺陷检测能力的核心参数作为内核命令行参数暴露出来，其默认值也可以通过相应的Kconfig选项进行更改。
* ``kcsan.skip_watch`` (``CONFIG_KCSAN_SKIP_WATCH``): 在设置下一个监视点之前，每个CPU需要跳过的内存操作次数。更频繁地设置监视点会增加观察到竞态的可能性。此参数对整体系统性能和竞态检测能力有最显著的影响。
* ``kcsan.udelay_task`` (``CONFIG_KCSAN_UDELAY_TASK``): 对于任务而言，在设置监视点后执行停滞的微秒级延迟。较大的值会导致我们可能观察到竞态的时间窗口增加。
* ``kcsan.udelay_interrupt`` (``CONFIG_KCSAN_UDELAY_INTERRUPT``): 对于中断而言，在设置监视点后执行停滞的微秒级延迟。中断有更严格的延迟要求，其延迟通常应该小于为任务选择的延迟。
这些参数可以在运行时通过 `/sys/module/kcsan/parameters/` 进行调整。

### 数据竞态

在一个执行过程中，如果两个内存访问 *冲突*、它们在不同的线程中并发发生，并且至少有一个是 *普通访问*，则这两个内存访问形成一个 *数据竞态*；它们 *冲突* 如果两者都访问同一内存位置，并且至少有一个是写操作。对于更深入的讨论和定义，请参阅《LKMM中的“普通访问与数据竞态”》_。
.. _《LKMM中的“普通访问与数据竞态”》: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/memory-model/Documentation/explanation.txt#n1922

### 与Linux内核内存一致性模型（LKMM）的关系

LKMM定义了各种内存操作的传播和排序规则，这使得开发人员能够理解并发代码的行为。最终，这允许确定并发代码的可能执行情况，并判断该代码是否免于数据竞态。
KCSAN 知道 *标记的原子操作*（如 `READ_ONCE`、`WRITE_ONCE`、`atomic_*` 等），以及内存屏障隐含的一部分排序保证。使用 ``CONFIG_KCSAN_WEAK_MEMORY=y`` 时，KCSAN 模拟载入或存储缓冲，并能检测缺失的 `smp_mb()`、`smp_wmb()`、`smp_rmb()`、`smp_store_release()` 和所有具有等效隐含屏障的 `atomic_*` 操作。
需要注意的是，KCSAN 不会报告所有由于缺少内存排序而产生的数据竞态，特别是当需要内存屏障来禁止后续内存操作在屏障之前重新排序的情况。因此，开发人员应当仔细考虑那些未被检查的所需内存排序要求。
### 超越数据竞争的竞态检测

对于具有复杂并发设计的代码，竞态条件错误并不总是表现为数据竞争。当并发执行的操作导致系统出现意外行为时，就会发生竞态条件。另一方面，数据竞争是在C语言级别定义的。以下宏可用于检查并发代码的属性，在这些代码中，错误不会表现为数据竞争：
.. kernel-doc:: include/linux/kcsan-checks.h
    :functions: ASSERT_EXCLUSIVE_WRITER ASSERT_EXCLUSIVE_WRITER_SCOPED
                ASSERT_EXCLUSIVE_ACCESS ASSERT_EXCLUSIVE_ACCESS_SCOPED
                ASSERT_EXCLUSIVE_BITS

### 实现细节

KCSAN依赖于观察两个访问是否同时发生。关键的是，我们希望（a）增加观察到竞态的机会（特别是那些很少发生的竞态），以及（b）能够真正地观察到它们。我们可以通过注入各种延迟来实现（a），通过使用地址监视点（或断点）来实现（b）。如果我们故意延缓内存访问，并且已经为该地址设置了监视点，然后观察到监视点被触发，那么对同一地址的两次访问就发生了竞争。使用硬件监视点，这就是`DataCollider <http://usenix.org/legacy/events/osdi10/tech/full_papers/Erickson.pdf>`_采用的方法。
与DataCollider不同，KCSAN不使用硬件监视点，而是依赖于编译器插桩和“软监视点”。
在KCSAN中，监视点是使用一种高效编码实现的，这种编码将访问类型、大小和地址存储在一个长整型中；使用“软监视点”的好处是可移植性和更大的灵活性。KCSAN依赖于编译器对简单的访问进行插桩。对于每个插桩后的简单访问：

1. 检查是否存在匹配的监视点；如果存在，并且至少有一个访问是写操作，则我们遇到了竞态访问
2. 周期性地，如果没有匹配的监视点，则设置一个监视点并随机延迟一小段时间
3. 在延迟之前检查数据值，并在延迟之后重新检查数据值；如果这些值不匹配，我们推断出未知来源的竞争
为了检测简单访问和标记访问之间的数据竞争，KCSAN也注释了标记访问，但仅用于检查是否存在监视点；即KCSAN从不在标记访问上设置监视点。由于从不在标记操作上设置监视点，如果所有对某个变量的并发访问都被正确标记，KCSAN将永远不会触发监视点，因此也不会报告这些访问。

### 建模弱内存

KCSAN检测因缺少内存屏障而导致的数据竞争的方法是基于模拟访问重排序（使用``CONFIG_KCSAN_WEAK_MEMORY=y``）。
为每个设置监视点的简单内存访问也在其函数的作用域内被选中进行模拟重排序（最多一次在途访问）。
一旦选择了访问进行重排序模拟，该访问将沿着函数作用域内的所有其他访问检查直至结束。如果遇到合适的内存屏障，该访问将不再被视为模拟重排序的候选。
当内存操作的结果需要由屏障来排序时，KCSAN可以检测到仅因缺少屏障而产生的数据竞争。考虑以下示例：

    int x, flag;
    void T1(void)
    {
        x = 1;                  // 数据竞争!
        WRITE_ONCE(flag, 1);    // 正确：smp_store_release(&flag, 1)
    }
    void T2(void)
    {
        while (!READ_ONCE(flag));   // 正确：smp_load_acquire(&flag)
        ... = x;                    // 数据竞争!
    }

当启用弱内存模型时，KCSAN可以考虑在`T1`中的`x`进行模拟重排序。在写入`flag`之后，再次检查`x`是否存在并发访问：因为`T2`可以在写入`flag`后继续执行，因此会检测到数据竞争。如果有正确的屏障设置，在正确释放`flag`之后，`x`将不会被考虑进行重排序，并且不会检测到数据竞争。
有意权衡复杂性以及实际限制意味着只能检测到一部分由于缺少内存屏障导致的数据竞争。根据目前可用的编译器支持，实现仅限于模拟“缓冲”（延迟访问）的效果，因为运行时无法“预取”访问。此外，请记住只对简单的访问设置观察点，这也是KCSAN模拟重排序的唯一访问类型。这意味着标记访问的重排序没有被模拟。
上述情况的一个后果是获取操作不需要屏障的插入（没有预取）。此外，引入地址或控制依赖关系的标记访问不需要特殊处理（标记访问不能被重排序，后续依赖访问不能被预取）。

关键特性
~~~~~~~~~~

1. **内存开销：** 总体内存开销取决于配置，通常只有几兆字节。当前实现使用一个小的长整数数组来编码观察点信息，这几乎是微不足道的。
2. **性能开销：** KCSAN的运行时目标是最小化开销，通过高效的观察点编码实现在快速路径中无需获取任何共享锁。对于一个具有8个CPU的系统的内核启动：

   - 使用默认KCSAN配置时，速度降低5.0倍；
   - 仅从运行时快速路径开销来看，速度降低2.8倍（设置非常大的`KCSAN_SKIP_WATCH`值并取消设置`KCSAN_SKIP_WATCH_RANDOMIZE`）
3. **注释开销：** 在KCSAN运行时之外几乎不需要任何注释。因此，随着内核的发展，维护开销极低。
4. **检测设备的竞争写入：** 由于在设置观察点时检查数据值，还可以检测到来自设备的竞争写入。
5. **内存排序：** KCSAN只了解LKMM排序规则的一个子集；这可能导致遗漏数据竞争（假阴性）。
6. **分析准确性：** 对于已观察到的执行，由于采用了采样策略，分析是*不完整的*（可能存在假阴性），但旨在是完整的（无假阳性）。
### 考虑的替代方案
-----------------------

内核中另一种数据竞争检测方法可以在
`内核线程 sanitizer (KTSAN) <https://github.com/google/ktsan/wiki>`_
中找到。KTSAN 是一种发生-之前（happens-before）顺序的数据竞争检测器，它显式地建立了内存操作之间的发生-之前顺序，然后可以用来根据 `数据竞争`_ 的定义来确定数据竞争。为了构建正确的发生-之前关系，KTSAN 必须了解 LKMM 的所有排序规则和同步原语。不幸的是，任何遗漏都会导致大量误报，这对于内核尤其有害，因为内核包含大量的自定义同步机制。为了追踪发生-之前的关系，KTSAN 的实现需要为每个内存位置存储元数据（影子内存），对于每一页来说，这对应着 4 页的影子内存，并且在大型系统上可能会转化为数十吉字节（GiB）的开销。
