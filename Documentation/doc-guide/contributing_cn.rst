### SPDX 许可证标识符：GPL-2.0

如何帮助改进内核文档
==========================

文档是任何软件开发项目的重要组成部分。
优秀的文档有助于吸引新的开发者加入，并帮助已有的开发者更高效地工作。
如果没有高质量的文档，人们将浪费大量时间去逆向工程代码和犯一些可以避免的错误。
遗憾的是，当前内核的文档远远达不到支持这样一个规模和重要性的项目所需的水平。
本指南是为那些希望改善这种情况的贡献者准备的。
不同技能水平的开发者都可以参与到改进内核文档的工作中；这是一种相对容易的学习内核开发流程的方式，并在社区中找到自己的位置。
以下大部分内容是文档维护者的任务清单，列出了最迫切需要完成的任务。
文档待办事项清单
----------------------

有无数的任务需要执行以使我们的文档达到应有的水平。这个列表包含了一些重要的项目，但远非详尽无遗；如果你看到其他改进文档的方法，请不要犹豫！

处理警告信息
~~~~~~~~~~~~~~

当前文档构建过程中会产生大量的警告信息。当出现如此多的警告时，几乎就等于没有警告；人们会忽略它们，也不会注意到他们的工作引入了新的警告。因此，消除这些警告是文档待办事项列表中的最高优先级任务之一。这项任务本身相当直接，但要成功地完成它，必须采取正确的方法。

C语言代码编译器产生的警告有时可以被认为是误报，导致一些补丁仅仅是为了让编译器安静下来。而文档构建产生的警告几乎总是指向实际存在的问题；消除这些警告需要理解问题所在并从根源上解决它。因此，修复文档警告的补丁在更改日志标题中最好不要仅写“修复一个警告”；应该指出真正被修复的问题。

另一个重要点是，许多文档警告是由C代码中的kerneldoc注释问题引起的。虽然文档维护者感谢收到这些警告的修复通知，但通常情况下文档树并不是执行这些修复的正确地方；它们应该提交给相关子系统的维护者。

例如，在一次文档构建中我随机选取了一对警告：

```
./drivers/devfreq/devfreq.c:1818: 警告: 错误的行：
	- 资源管理的 devfreq_register_notifier()
./drivers/devfreq/devfreq.c:1854: 警告: 错误的行：
	- 资源管理的 devfreq_unregister_notifier()
```

（为了便于阅读，行内容进行了换行）
快速查看上述源文件发现了几处内核文档注释，其格式如下：

  /**
   * devm_devfreq_register_notifier()
	  - 资源管理的 devfreq_register_notifier()
   * @dev:	devfreq 用户设备。（devfreq 的父级）
   * @devfreq:	devfreq 对象
* @nb:	要注销的通知器块
* @list:	DEVFREQ_TRANSITION_NOTIFIER
*/

问题在于缺失的 "*"，这使得构建系统对 C 语言注释块的理解变得复杂。这个问题自2016年添加该注释以来一直存在——整整四年。修复它只需要加上缺失的星号。快速查看该文件的历史记录可以了解主题行通常的格式，而 `scripts/get_maintainer.pl` 告诉我应该将修复发送给谁（将补丁路径作为参数传递给 `scripts/get_maintainer.pl`）。最终的补丁如下所示：

  [PATCH] PM / devfreq: 修复两个格式不正确的内核文档注释

  在 devfreq.c 中有两个内核文档注释不符合所需格式，导致生成以下文档构建警告：

    ./drivers/devfreq/devfreq.c:1818: 警告: 不规范的行:
  	  - 资源管理的 devfreq_register_notifier()
    ./drivers/devfreq/devfreq.c:1854: 警告: 不规范的行:
	  - 资源管理的 devfreq_unregister_notifier()

  添加几个缺失的星号，使内核文档更加规范。
已审核通过: Jonathan Corbet <corbet@lwn.net>
  ---
   drivers/devfreq/devfreq.c | 4 ++--
   1 个文件被修改，新增加 2 行 (+)，删除 2 行 (-)

  diff --git a/drivers/devfreq/devfreq.c b/drivers/devfreq/devfreq.c
  index 57f6944d65a6..00c9b80b3d33 100644
  --- a/drivers/devfreq/devfreq.c
  +++ b/drivers/devfreq/devfreq.c
  @@ -1814,7 +1814,7 @@ static void devm_devfreq_notifier_release(struct device *dev, void *res)

   /**
    * devm_devfreq_register_notifier()
  -	- 资源管理的 devfreq_register_notifier()
  + *	- 资源管理的 devfreq_register_notifier()
    * @dev:	devfreq 用户设备。（devfreq 的父级）
    * @devfreq:	devfreq 对象
* @nb:	要注销的通知器块
@@ -1850,7 +1850,7 @@ EXPORT_SYMBOL(devm_devfreq_register_notifier);

   /**
    * devm_devfreq_unregister_notifier()
  -	- 资源管理的 devfreq_unregister_notifier()
  + *	- 资源管理的 devfreq_unregister_notifier()
    * @dev:	devfreq 用户设备。（devfreq 的父级）
    * @devfreq:	devfreq 对象
* @nb:	要注销的通知器块
--
  2.24.1

整个过程只花了几分钟。当然，我发现其他人已经在另一个分支中修复了这个问题，这也提醒我们另一课：在深入研究问题之前，一定要检查 `linux-next` 分支看问题是否已被修复。
其他修复可能需要更长时间，特别是对于缺少文档说明的结构成员或函数参数的情况。在这种情况下，需要弄清楚这些成员或参数的作用，并正确地描述它们。总的来说，这项工作有时会有些乏味，但它非常重要。如果我们能真正消除文档构建中的警告，那么就可以开始期望开发人员避免引入新的警告。
除了常规文档构建中的警告之外，您还可以运行 `make refcheckdocs` 来查找对不存在的文档文件的引用。

被忽视的 kerneldoc 注释
~~~~~~~~~~~~~~~~~~~~~~~~~~

鼓励开发者为他们的代码编写 kerneldoc 注释，但许多这些注释从未被纳入文档构建中。这使得这些信息更难以找到，并且例如，使 Sphinx 无法生成指向该文档的链接。在文档中添加 `kernel-doc` 指令以引入这些注释可以帮助社区充分利用创建它们所付出的努力。
`scripts/find-unused-docs.sh` 工具可用于查找这些被忽视的注释。
需要注意的是，最有价值的是将导出函数和数据结构的文档引入进来。许多子系统也有仅供内部使用的 kerneldoc 注释；除非它们被放置在一个专门针对相关子系统开发者的文档中，否则不应将其纳入文档构建中。

拼写错误修正
~~~~~~~~~~~~~~

修正文档中的拼写或格式错误是了解如何创建和发送补丁的一种快速方式，这是一种有用的服务。我总是愿意接受此类补丁。不过，在您修正了一些错误之后，请考虑转向更高级的任务，留一些拼写错误给下一位初学者去处理。
请注意，有些事情并不是拼写错误，不应该被“修正”：

- 在内核文档中允许使用美式英语和英式英语拼写。没有必要用一种拼写替换另一种来“修正”它。
- 是否应该在句号后跟一个或两个空格的问题不是内核文档上下文中需要讨论的话题。其他合理分歧的领域，如“牛津逗号”，在这里也是无关紧要的。
对于任何项目中的任何补丁，请考虑您的更改是否真正使事情变得更好。

陈旧的文档
~~~~~~~~~~~~~~~~~~

一些内核文档是当前的、维护良好的、有用的。而有些文档……则不然。过时、不准确的文档可能会误导读者，并对我们整体的文档产生怀疑。任何可以解决这些问题的做法都是受欢迎的。
每当您处理一份文档时，请考虑它是否是最新的，是否需要更新，或者是否应该完全移除。这里有一些警告标志可供您注意：

- 引用 2.x 内核的内容
- 指向 SourceForge 存储库的链接
- 近几年的历史记录中只有拼写错误修正
- 讨论 Git 出现之前的流程

当然，最好的做法是让文档保持最新状态，加入所有必要的信息。这种工作通常需要与熟悉相关子系统的开发者合作。当被礼貌地询问并听取他们的回答并采取行动时，开发者往往非常愿意与致力于改进文档的人合作。
有些文档已经毫无希望；我们偶尔会发现一些文档，它们提及的代码实际上早已从内核中删除。虽然出人意料地存在对删除过时文档的抵抗情绪，但我们仍应进行这项工作。在文档中保留这些无关紧要的内容对任何人都没有帮助。

如果严重过时的文档中还包含一些有用的信息，并且你无法更新它，最好的做法可能是在文档开头添加一个警告。推荐使用以下文本：

  .. warning ::
  	本文档已过时，需要更新。请谨慎使用其中的信息，并考虑提交补丁以更新文档。
这样至少可以提醒长期忍受问题的读者们，这些文档可能会引导他们走向错误的方向。

### 文档一致性

老一辈的人可能还记得20世纪90年代出现在书架上的Linux书籍。那些书基本上是从网络各个角落搜集来的文档文件的集合。自那以后，书籍的质量（大部分）有所提高，但内核的文档仍然沿用了那种模式。它由数千个几乎都是独立编写的文件组成。我们并没有一套连贯的内核文档集，而是有数千份独立的文档。

我们正试图通过创建一系列“书籍”来改善这种情况，这些书籍针对特定的读者群体进行了文档的整合。其中包括：

- Documentation/admin-guide/index.rst
- Documentation/core-api/index.rst
- Documentation/driver-api/index.rst
- Documentation/userspace-api/index.rst

以及关于文档本身的这本书。

将文档移入适当的书籍是一项重要的任务，需要持续进行。不过这项工作也伴随着一些挑战。移动文档文件会给处理这些文件的人带来短期的不便；他们对此类变动自然不太热心。通常情况下，我们可以为一次文档迁移找到合理的理由；但我们确实不想让这些文档频繁变动。

即使所有文档都放在了正确的位置，我们也只是将一大堆文档变成了若干个小堆。将所有这些文档整合成一个整体的工作尚未开始。如果你有关于如何推进这方面工作的想法，我们会非常乐意听取。

### 样式表改进

采用Sphinx后，我们的HTML输出比以前美观了许多。但仍有很大的改进空间；Donald Knuth和Edward Tufte可能不会留下深刻印象。这需要调整我们的样式表，以创建更符合排版规范、易于访问且易读的输出。

请注意：如果你承担这项任务，你将进入典型的“自行车棚”领域。即使是相对明显的改动，也可能引来许多意见和讨论。遗憾的是，这就是我们所处的世界的现状。
非LaTeX PDF构建
~~~~~~~~~~~~~~~~~~~

对于一个时间充裕且具备Python技能的人来说，这是一项相当复杂的任务。Sphinx工具链相对较小且结构清晰；很容易添加到开发系统中。但是构建PDF或EPUB输出需要安装LaTeX，而这绝不是一件简单或易于管理的事情。如果能消除这一点就好了。
最初的希望是使用rst2pdf工具（https://rst2pdf.org/）来生成PDF，但事实证明它无法胜任这项任务。
不过，最近看来，rst2pdf的开发工作似乎又有所恢复，这是一个令人鼓舞的迹象。如果有一个足够有动力的开发者能够与该项目合作，使rst2pdf能够适用于内核文档的构建，全世界都会对此表示感激。
编写更多文档
~~~~~~~~~~~~~~~~~~~~~~~~

自然而然地，内核中有大量的部分严重缺乏文档。如果你具备撰写特定内核子系统的知识，并且有意愿去做这件事，请不要犹豫，进行一些写作并将结果贡献给内核。无数的内核开发者和用户将会感谢你。
