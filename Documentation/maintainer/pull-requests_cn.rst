创建拉取请求
======================

本章描述了维护者如何向其他维护者创建并提交拉取请求。这对于将更改从一个维护者的分支转移到另一个维护者的分支非常有用。
本文档主要由Tobin C. Harding撰写（当时他并不是一位经验丰富的维护者），内容主要基于Greg Kroah-Hartman和Linus Torvalds在LKML上的评论。Jonathan Corbet和Mauro Carvalho Chehab提出了建议和修正。任何误解都是无意的，但不可避免，请将批评意见发送给Tobin C. Harding <me@tobin.cc>。
原始邮件线程：

	https://lore.kernel.org/r/20171114110500.GA21175@kroah.com

创建分支
-------------

首先，你需要将所有希望包含在拉取请求中的更改放在一个单独的分支上。通常情况下，这个分支会基于你打算发送拉取请求的目标开发者的分支。

为了创建拉取请求，你必须先标记刚刚创建的分支。建议选择一个有意义的标签名称，这样即使经过一段时间后，你和其他人也能理解。一个好的做法是在名称中包含子系统的来源和目标内核版本。

Greg提供了以下建议：一个针对drivers/char目录的杂项更改，应用于内核版本4.15-rc1的拉取请求可以命名为``char-misc-4.15-rc1``。如果这样的标签是从名为``char-misc-next``的分支生成的，则可以使用以下命令：

        git tag -s char-misc-4.15-rc1 char-misc-next

这将创建一个名为``char-misc-4.15-rc1``的签名标签，基于``char-misc-next``分支的最后一个提交，并用你的GPG密钥进行签名（参见Documentation/maintainer/configure-git.rst）。

Linus只会接受基于签名标签的拉取请求。其他维护者可能有所不同。

当你运行上述命令时，`git`会打开一个编辑器，要求你描述该标签。在这种情况下，你是在描述一个拉取请求，因此需要概述其中的内容、为什么应该合并它以及进行了哪些测试（如果有）。所有这些信息最终都会出现在标签本身中，并且如果/当维护者合并拉取请求时也会出现在合并提交中。所以请认真编写，因为这将成为内核树的一部分，永久保存。

正如Linus所说：

	无论如何，对我来说最重要的是*消息*。我需要理解我在拉取什么，以及为什么应该拉取它。我还希望将此消息作为合并的消息，因此它不仅对我有意义，还应作为历史记录有意义。
如果拉取请求中有任何奇怪之处，应该在解释中提及。如果你修改了你不负责维护的文件，请解释原因。无论如何我都能在diff统计中看到，如果你不提及，我会更加怀疑。当你在合并窗口之后（甚至在修复bug时，但看起来很吓人的bug修复），发送新内容时，不仅要解释它们做了什么以及为什么这样做，还要解释时间点。为什么会没有通过合并窗口。
我会同时考虑你在电子邮件拉取请求中以及签名标签中写的内容，因此根据你的工作流程，你可以在签名标签中描述你的工作（这也会自动成为拉取请求电子邮件的一部分），或者将签名标签仅作为一个占位符，没有任何有趣的内容，在实际发送拉取请求时再进行描述。
是的，我会编辑这条消息。部分原因是通常我只会做一些简单的格式调整（比如整体缩进和引用等），但另一部分原因是消息中的某些内容可能在我拉取时是有意义的（描述冲突和您当前发送时的个人问题），但在合并提交的消息中可能就没有意义了，因此我会尽量让所有内容都有意义。我也会修正任何我发现的拼写错误和语法错误，特别是对于非母语使用者（当然也包括母语使用者）。但我可能会漏掉一些，甚至增加一些错误。
Linus

Greg 给出了一个拉取请求的例子：

	Char/Misc 补丁集用于 4.15-rc1

	这是为 4.15-rc1 合并窗口准备的大规模 Char/Misc 补丁集。
	这些补丁集中包含了许多新功能，添加到了各种各样的驱动程序中，还包括以下全新的子系统：
		- time_travel_controller：终于有了针对最新时间旅行总线架构的一套驱动程序，该架构能够在 CPU 请求之前提供 I/O，从而实现不间断处理。
		- relativity_shifters：由于 time_travel_controllers 对整个系统的影响，需要一套新的相对论变换驱动程序来应对新形成的黑洞，这些黑洞可能会威胁到 CPU 的安全。此子系统以一种成功的方式解决了这些问题。
	有一个 Kconfig 选项可以在需要时强制启用这些功能，因此不会出现问题。
	所有这些补丁都在最新的 linux-next 发布版中进行了成功的测试，并且最初发现的问题都已经解决（对于任何住在堪培拉附近的人，由于早期版本的 linux-next 树创建时缺少 Kconfig 选项，表示歉意。）

	签署者: Your-name-here <your_email@domain>

标签消息的格式就像一个 Git 提交 ID。顶部一行用于“摘要主题”，并在底部签名。
现在你已经有了本地的已签名标签，你需要将其推送到可以获取的地方：

	git push origin char-misc-4.15-rc1

创建拉取请求
--------------

最后一步是创建拉取请求消息。`git` 可以通过 `git request-pull` 命令方便地为你完成这项工作，但它需要一些帮助来确定你想拉取的内容以及基于什么来进行拉取（以显示正确的更改和差异统计）。以下命令将生成一个拉取请求：

	git request-pull master git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc.git/ char-misc-4.15-rc1

引用 Greg 的话：

	这要求 git 比较从 ‘char-misc-4.15-rc1’ 标签位置到 ‘master’ 分支头部的差异（在我的情况下指向 Linus 树中我分叉的最后一个位置，通常是某个 -rc 版本），并使用 git:// 协议进行拉取。如果你希望使用 https://，这里也可以用，但请注意有些人由于防火墙的原因可能会遇到 https git 拉取的问题。
如果我在请求拉取的仓库中找不到 char-misc-4.15-rc1 标签，git 会抱怨说标签不存在，这是一个提醒你实际将其推送到公共位置的好方法。
`git request-pull` 的输出将包含 git 树的位置和要拉取的具体标签，以及该标签的完整文本描述（这就是为什么你需要在标签中提供好的信息）。它还会生成拉取请求的差异统计和单个提交的简短日志。
Linus 回应说他倾向于使用 `git://` 协议。其他维护者可能有不同的偏好。此外，请注意，如果你在没有已签名标签的情况下创建拉取请求，则 `https://` 可能是一个更好的选择。请参阅原始讨论线程以获得完整的讨论。

提交拉取请求
--------------

拉取请求的提交方式与普通补丁相同。将邮件作为内联邮件发送给维护者，并抄送 LKML 和任何特定子系统的列表（如果需要）。向 Linus 提交的拉取请求通常的标题行如下所示：

	[GIT PULL] <子系统> changes for v4.15-rc1
