SPDX 许可证标识符: GPL-2.0

====================
变基与合并
====================

作为子系统维护者，通常需要熟悉 Git 源代码管理系统。Git 是一个功能强大的工具；与这样的工具一样，使用这些功能有正确和错误的方式。本文特别关注变基（rebasing）和合并（merging）的使用。维护者在不正确使用这些工具时经常会遇到麻烦，但实际上避免这些问题并不难。

需要注意的一点是，与许多其他项目不同，内核社区对于在其开发历史中看到合并提交并不感到害怕。实际上，鉴于项目的规模，避免合并几乎是不可能的。一些维护者遇到的问题源于希望避免合并，而另一些问题则来自过于频繁地进行合并。

变基
========

“变基”是指更改仓库中一系列提交的历史记录。有两种操作被称作变基，因为都是通过 `git rebase` 命令完成的，但它们之间存在显著差异：

- 更改一系列补丁所基于的父（起始）提交。例如，变基操作可以将基于上一个内核版本构建的补丁集改为基于当前版本。在下面的讨论中，我们将这种操作称为“重新指定父提交”。

- 通过修复（或删除）损坏的提交、添加补丁、向提交变更日志添加标签或更改提交的应用顺序来修改一组补丁的历史记录。在下文中，这种类型的操作将被称为“历史修改”。

术语“变基”将用于指代以上两种操作。

正确使用变基可以产生更清晰和整洁的开发历史；错误使用则可能使历史变得模糊并引入错误。

以下是一些可以帮助开发者避免变基最严重风险的经验法则：

- 已经公开到你私有系统之外的历史记录通常不应被更改。其他人可能已经拉取了你的树并在此基础上进行了工作；更改你的树将会给他们带来痛苦。如果工作需要变基，这通常表明它还没有准备好被提交到公共仓库。

话虽如此，总是有例外情况。某些树（如 linux-next 是一个显著的例子）因其性质常常被变基，开发者知道不应该在它们的基础上进行工作。有时开发者会公开一个不稳定的分支供他人测试或自动化测试服务使用。如果你确实公开了一个可能不稳定的分支，请确保潜在用户知道不要在该分支上进行工作。

- 不要变基包含由其他人创建的历史记录的分支。如果你从另一位开发者的仓库中拉取了更改，那么你现在就是他们历史记录的保管人。你不应该更改它。除了少数例外情况外（例如，在这样的树中的一个损坏提交应明确回退而不是通过历史修改使其消失）。

- 没有充分理由不要重新指定树的父提交。仅仅基于更新的基础或避免与上游仓库合并通常不是一个好理由。

- 如果必须重新指定一个仓库的基础，不要随意选择某个内核提交作为新的基础。内核在发布点之间经常处于相对不稳定的状态；基于其中一个点进行开发增加了遇到意外错误的可能性。当一个补丁系列需要转移到新的基础上时，请选择一个稳定点（如 -rc 发布之一）进行转移。
意识到重新父化（reparenting）一个补丁系列（或进行重大历史修改）会改变其开发环境，并且很可能使之前所做的测试失效。通常情况下，重新父化后的补丁系列应被视为新代码并从头开始重新测试。

合并窗口期间常见的问题之一是林纳斯（Linus）收到的补丁系列明显经过了重新父化，通常是针对某个随机提交，在拉取请求发送前不久完成。这样的补丁系列经过充分测试的可能性相对较低，因此拉取请求被处理的可能性也很低。

相反，如果重基（rebasing）仅限于私有分支，提交基于一个众所周知的起始点，并且经过充分测试，则出现问题的可能性很低。

### 合并

合并是内核开发过程中常见的操作；在5.1版本的开发周期中，共有1,126次合并提交——占总提交量的近9%。内核工作积累在超过100个不同的子系统分支中，每个分支可能包含多个主题分支；每个分支通常是独立开发的。因此，任何一个特定分支要进入上游仓库，至少需要一次合并。

许多项目要求拉取请求中的分支基于当前主干，以避免历史中有合并提交。但内核项目不是这样；任何为了避免合并而进行的重基可能会导致麻烦。

子系统维护者需要进行两种类型的合并：从较低级别的子系统分支合并以及从其他分支（兄弟分支或主线）合并。这两种情况的最佳实践有所不同。

#### 从较低级别的分支合并

较大的子系统通常有多级维护者，较低级别的维护者向较高级别的维护者发送拉取请求。处理这种拉取请求几乎肯定会生成一个合并提交；这正是应该做的。实际上，子系统维护者可能希望使用`--no-ff`标志来强制添加合并提交，即使在少数不需要合并的情况下也是如此，以便记录合并的原因。对于任何类型的合并，合并日志都应该说明为什么进行这次合并。对于较低级别的分支，“为什么”通常是对此次拉取带来的变更的总结。

各级维护者在提交拉取请求时都应使用签名标签，并且上游维护者在拉取分支时应验证这些标签。不这样做会威胁整个开发过程的安全性。

根据上述规则，一旦你将他人的历史合并到你的分支中，你就不能再对该分支进行重基，即使在其他情况下你可以这样做。
从兄弟或上游树合并
--------------------------------------

虽然从下游合并很常见且不引人注意，但从其他树合并通常在向上游推送分支时会成为一个警示信号。这种合并需要仔细考虑并有充分的理由，否则后续的拉取请求可能会被拒绝。自然地，人们会想要将主分支合并到仓库中；这种合并通常被称为“反向合并”。反向合并有助于确保与平行开发没有冲突，并且通常给人一种保持最新状态的感觉。但这种诱惑几乎应该总是避免。

为什么呢？反向合并会混淆你分支的开发历史。它们会显著增加遇到社区其他地方错误的可能性，并使你难以保证所管理的工作稳定且适合向上游推送。频繁的合并还会掩盖你在树中开发过程中的问题；它们可能会隐藏与其他树之间的交互，而这些交互在一个管理良好的分支中不应该经常发生。

话虽如此，反向合并在某些情况下是必要的；当这种情况发生时，请务必在提交信息中记录为什么需要进行反向合并。始终要合并到一个众所周知的稳定点，而不是某个随机的提交。即便如此，你不应将树合并到你的直接上游树之上；如果确实需要更高层次的反向合并，则上游树应首先进行该合并。

与合并相关的最常见问题之一是在发送拉取请求之前，维护者为了解决合并冲突而与上游进行合并。再次，这种诱惑很容易理解，但绝对应避免。特别是对于最终的拉取请求：林纳斯坚决认为他宁愿看到合并冲突也不愿看到不必要的反向合并。看到冲突让他知道潜在的问题区域在哪里。他做了很多合并（在5.1开发周期中有382次），并且在解决冲突方面非常熟练——通常比相关开发者更好。

那么，当维护者的子系统分支与主线之间存在冲突时，他们应该怎么做？最重要的步骤是在拉取请求中警告林纳斯冲突会发生；即使这样做，也表明了对分支在整个项目中的位置有所了解。对于特别困难的冲突，创建并推送一个*独立*的分支来展示你是如何解决问题的。在拉取请求中提到那个分支，但拉取请求本身应该是针对未合并的分支。

即使在没有已知冲突的情况下，在发送拉取请求之前进行一次测试合并也是个好主意。它可能会提醒你一些你从linux-next中没有注意到的问题，并帮助你准确理解你要求上游做什么。

进行上游或其他子系统树合并的另一个原因是解决依赖关系。这些依赖问题有时确实会发生，有时跨树合并是最好的解决方法；在这种情况下，合并提交应该解释为什么进行了合并。花点时间做好这件事；人们会阅读这些更改日志。
通常，依赖问题表明需要改变方法。为了解决依赖而合并另一个子系统树可能会引入其他错误，因此几乎不应该这样做。如果该子系统树未能被上游拉取，那么它存在的任何问题也会阻碍你的树的合并。更可取的替代方案包括与维护者协商，在其中一个树中合并两套更改，或者创建一个专门用于先决提交的主题分支，以便将其合并到两个树中。如果依赖关系与主要的基础设施变更相关，正确的解决方案可能是将依赖提交推迟一个开发周期，以便这些变更有时间在主线中稳定下来。

最后

在开发周期开始时与主线合并以获取树中其他地方所做的更改和修复是相对常见的做法。一如既往，这样的合并应选择一个广为人知的发布点，而不是某个随机位置。如果你向上游推送的分支在合并窗口期间已完全并入主线，你可以使用如下命令将其前移：

```
git merge --ff-only v5.2-rc1
```

上述指导原则仅仅是建议。总会有一些情况需要不同的解决方案，这些指导原则不应阻止开发者在必要时采取正确的行动。但始终要思考是否真正有必要采取行动，并准备好解释为什么需要进行异常操作。
