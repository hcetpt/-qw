### SPDX 许可证标识符：GPL-2.0

====================
重构与合并
====================

作为子系统维护者，通常需要熟悉 Git 这一源代码管理系统。Git 是一个功能强大的工具，拥有众多特性；像这类工具一样，使用这些特性的方式有对也有错。本文档特别关注重构和合并的使用。当维护者错误使用这些工具时，往往会遇到麻烦，但实际上避免这些问题并不难。

一般来说，需要注意的一点是，与许多其他项目不同，内核社区并不害怕在开发历史中看到合并提交。实际上，鉴于项目的规模，避免合并几乎是不可能的。一些维护者遇到的问题源于试图避免合并，而另一些问题则来自过于频繁地进行合并。

重构
========

“重构”是指在一个仓库中改变一系列提交的历史记录的过程。有两种操作被统称为重构，因为它们都通过 `git rebase` 命令完成，但它们之间存在显著差异：

- 改变构建一系列补丁的基础（父）提交。例如，重构操作可以将基于前一个内核版本构建的补丁集改为基于当前版本。下文将这种操作称为“更改基点”。
- 改变一组补丁的历史记录，如修复（或删除）有问题的提交、添加补丁、在提交变更日志中添加标签或更改提交应用的顺序。在下面的文本中，这种类型的操作将被称为“历史修改”。

术语“重构”将用于指代上述两种操作。

正确使用重构可以产生更清晰、更干净的开发历史；如果使用不当，则可能使历史变得模糊并引入错误。

以下几点准则可以帮助开发者避免重构中最严重的风险：

- 已经公之于众的历史记录通常不应该被改变。其他人可能已经拉取了你的树并在此基础上进行了构建；修改你的树将给他们带来痛苦。如果工作需要重构，这通常是表明该工作尚未准备好提交到公共仓库的标志。
尽管如此，总有例外情况。某些树（如 linux-next 就是一个显著的例子）因其性质而经常被重构，并且开发者们知道不要在其上构建工作。有时开发者会公开一个不稳定的分支供他人测试或用于自动化测试服务。如果你确实公开了一个可能不稳定的分支，请确保潜在用户知道不要在其上构建工作。
- 不要重构包含由他人创建的历史记录的分支。如果你从另一个开发者的仓库中拉取了更改，那么你就是他们历史记录的保管人。你不应该改变它。除了少数例外（例如，在这种类型的树中出现的错误提交应该明确地回退，而不是通过历史修改消失）。
- 没有充分理由不要更改树的基础。仅仅基于更新的基础或者避免与上游仓库的合并通常不是一个好理由。
- 如果必须更改仓库的基础，请不要选择任意的内核提交作为新的基础。内核在发布点之间通常处于相对不稳定的状态；基于这些点之一进行开发增加了遇到意外错误的可能性。当补丁系列必须转移到新基础时，请选择一个稳定点（如 -rc 发布版本之一）作为转移的目标。
认识到重新父化一个补丁系列（或进行重大历史修改）会改变其开发环境，并且很可能使之前所做的大部分测试失效。通常来说，重新父化的补丁系列应该被视为新代码，并从头开始重新测试。

合并窗口出现问题的常见原因是当林纳斯收到一个明显已被重新父化的补丁系列时，这种情况往往发生在拉取请求发送前不久，有时甚至是为了随机提交。这样的补丁系列经过充分测试的可能性相对较低——同样，处理这类拉取请求的可能性也很小。

相反，如果将重构成限于私有仓库中进行，提交基于一个众所周知的起点，并且经过了良好的测试，那么出现问题的可能性就会很低。

### 合并

合并是内核开发过程中的常见操作；在5.1版本的开发周期中，包含了1,126个合并提交——占总提交量的近9%。内核工作积累在超过100个不同的子系统仓库中，每个仓库可能包含多个主题分支；每个分支通常是独立开发的。因此自然而然地，在任何给定分支被合并到上游仓库之前，至少需要进行一次合并。

许多项目要求拉取请求中的分支基于当前主线，以便历史记录中不出现合并提交。内核项目不是这样的；任何为了避免合并而进行的分支重构很可能导致问题。

子系统维护者发现自己需要做两种类型的合并：从较低级别的子系统仓库以及从其他仓库（无论是兄弟仓库还是主干）。在这两种情况下，最佳实践有所不同。

#### 从较低级别的子系统仓库合并

较大的子系统往往会有多层维护者，较低级别的维护者向较高级别的维护者发送拉取请求。处理这样的拉取请求几乎肯定会生成一个合并提交；这正是应该发生的。事实上，子系统维护者可能希望使用`--no-ff`标志来强制添加合并提交，即使在极少数情况下本不需要创建合并提交，以便可以记录合并的原因。对于任何形式的合并，合并日志都应该说明为什么进行这次合并。对于较低级别的仓库，"为什么"通常是与该拉取请求带来的更改摘要。

所有级别的维护者都应在他们的拉取请求中使用签名标签，并且上游维护者在拉取分支时应验证这些标签。不这样做会威胁整个开发过程的安全性。

根据上述规则，一旦你将他人的历史合并到了你的仓库中，你就不能对该分支进行重构，即使在其他情况下你可以这么做。
从兄弟分支或上游分支合并
--------------------------------------

虽然从下游分支进行合并很常见且没什么特别的，但从其他分支进行合并往往在向上游推送分支时成为一个警示信号。这类合并需要仔细考虑并充分说明理由，否则后续的拉取请求很可能被拒绝。自然地，人们会想要将主分支合并到自己的仓库中；这种类型的合并通常被称为“反向合并”。反向合并有助于确保与平行开发没有冲突，并且总体上给人一种保持更新的感觉。但这种诱惑几乎应该总是避免。

为什么呢？反向合并会混淆你分支自身的开发历史。它们会显著增加遇到社区其他地方出现的bug的概率，并且难以保证你管理的工作已经稳定并且准备好向上游提交。频繁的合并还可能掩盖你在分支中的开发过程存在的问题；它们可能会隐藏与其他分支之间的交互，而这些交互在管理良好的分支中不应该经常发生。

即便如此，反向合并偶尔还是必要的；当这种情况发生时，请务必在提交消息中记录为什么需要进行这样的合并。一如既往，应该合并到一个众所周知的稳定点，而不是某个随机的提交。

即使这样，也不应将你的直接上游分支之外的树进行反向合并；如果确实需要更高层次的反向合并，则应由上游分支首先执行此操作。

与合并相关的最常见问题之一是维护者在发送拉取请求之前与上游进行合并以解决合并冲突。同样，这种诱惑很容易理解，但绝对应该避免。特别是对于最终的拉取请求：林纳斯坚决认为他宁愿看到合并冲突，也不愿看到不必要的反向合并。看到冲突可以让他知道潜在的问题区域在哪里。他做了大量的合并工作（5.1开发周期中有382次合并），在解决冲突方面做得非常好——通常比参与的开发者更好。

那么当维护者的子系统分支与主线之间存在冲突时，他们应该怎么做？最重要的步骤是在拉取请求中警告林纳斯会发生冲突；至少，这表明了你对自己的分支在整个项目中的位置有所了解。对于特别困难的冲突，创建并推送一个*单独*的分支来展示你是如何解决问题的。在你的拉取请求中提及这个分支，但拉取请求本身应该是针对未合并的分支。

即使没有已知的冲突，在发送拉取请求之前做一个测试合并也是个好主意。它可能会提醒你注意一些你从linux-next中没有发现的问题，并帮助你确切地理解自己正在要求上游做什么。

进行上游分支或其他子系统分支合并的另一个原因是解决依赖关系。这些依赖问题确实时有发生，有时与其他分支进行交叉合并是最好的解决方式；在这种情况下，合并提交应该解释为什么进行了合并。花一点时间正确地完成它；人们会阅读这些变更日志。
通常情况下，依赖问题表明需要改变方法。通过合并另一个子系统树来解决依赖关系可能会引入其他错误，因此几乎不应该这样做。如果那个子系统树未能被上游拉取，它存在的任何问题也会阻碍你的树被合并。更可取的替代方案包括与维护者达成一致，在一个树中同时承载两组更改，或者创建一个专门用于必需提交的主题分支，该分支可以被合并到两个树中。如果依赖关系与主要的基础架构变更有关，则正确的解决方案可能是将依赖的提交保留一个开发周期，以便这些变更有时间在主线中稳定下来。

最后

在开发周期初期与主线合并以获取树中其他地方所做的更改和修复是很常见的做法。正如一贯所强调的那样，这种合并应选择一个广为人知的发布点而非随机的某个位置。如果你向上游推送的分支在合并窗口期间已完全融入主线，你可以使用如下命令将其向前推进：

```shell
git merge --ff-only v5.2-rc1
```

上述指导原则仅作为参考：它们只是指导原则。总会有一些情况需要采取不同的解决方案，这些指导原则不应阻止开发者在必要时做出正确的决策。但人们应当始终思考真正的需求是否已经出现，并准备好解释为什么需要执行异常操作。
