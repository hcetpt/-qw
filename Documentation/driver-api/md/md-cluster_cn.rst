===== MD 集群 =====

MD 集群是一种为集群设计的共享设备 RAID，它支持两种级别：raid1 和 raid10（有限支持）。

1. 磁盘格式
=============

每个集群节点都使用独立的写意图位图。
这些位图记录了可能在该节点上启动的所有写操作，并且可能尚未完成。磁盘布局如下：

  0                    4k                     8k                    12k
  -------------------------------------------------------------------
  | 空闲                | MD 超级块           | 位图超级块 [0] + 位   |
  | 位图位 [0, 续]      | 位图超级块 [1] + 位  | 位图位 [1, 续]        |
  | 位图超级块 [2] + 位 | 位图位 [2, 续]       | 位图超级块 [3] + 位   |
  | 位图位 [3, 续]      |                      |                       |

在“正常”运行时，我们假设文件系统确保一次只有一个节点写入任何给定的块，因此写请求将

- 设置相应的位（如果尚未设置）
- 将写入提交到所有镜像
- 在超时后安排清除位
读取操作以常规方式处理。由文件系统来确保一个节点不会从另一个节点（或同一节点）正在写入的位置读取数据。

2. 用于管理的 DLM 锁
======================

有三组锁用于管理设备：

2.1 位图锁资源 (bm_lockres)
---------------------------------

bm_lockres 保护单个节点的位图。它们以 bitmap000 的形式命名，用于节点 1，bitmap001 用于节点 2，依此类推。当节点加入集群时，它会以 PW 模式获取锁，并在整个节点是集群一部分的生命周期中保持该锁。锁资源编号基于 DLM 子系统返回的插槽编号。由于 DLM 从一开始计数，而位图插槽从零开始，因此从 DLM 插槽编号减去一得到位图插槽数。
特定节点的位图锁的锁值块 (LVB) 记录了正在被该节点重新同步的扇区范围。其他节点不得写入这些扇区。当新节点加入集群时会用到这一点。

2.2 消息传递锁
----------------------

每个节点在开始或结束重新同步以及元数据超级块更新时都需要与其他节点通信。这种通信通过三个锁进行管理：“令牌”、“消息”和“确认”，以及其中一个“消息”锁的锁值块 (LVB)。

2.3 新设备管理
------------------------

一个单一的锁：“no-new-dev”用于协调添加新设备 - 这必须在整个阵列中同步
通常所有节点都会对这个设备持有并发读取锁。

3. 通信
==============

消息可以广播到所有节点，并且发送者会在继续之前等待所有其他节点确认消息。一次只能处理一条消息。
3.1 消息类型
--------------

共有六种类型的消息被传递：

3.1.1 METADATA_UPDATED
^^^^^^^^^^^^^^^^^^^^^^

   告知其他节点元数据已更新，该节点必须重新读取md超级块。此操作是同步进行的。主要用于通知设备故障。

3.1.2 RESYNCING
^^^^^^^^^^^^^^^
  
   告知其他节点已发起或结束重新同步，以便每个节点可以暂停或恢复相应区域。每个RESYNCING消息都会标识发送节点即将重新同步的设备范围。这会覆盖来自同一节点的任何先前通知：每个节点一次只能重新同步一个范围。

3.1.3 NEWDISK
^^^^^^^^^^^^^

   告知其他节点有新设备将加入阵列。消息中包含该设备的标识符。更多详情请参见下文。

3.1.4 REMOVE
^^^^^^^^^^^^

   失败或备用设备正从阵列中移除。消息中包含了设备的槽位号。

3.1.5 RE_ADD:
   
   失败的设备正在被重新激活——假设它已被确定为可再次工作。

3.1.6 BITMAP_NEEDS_SYNC:

   如果某个节点本地停止运行但位图尚未清理，则需通知另一个节点接管重新同步的所有权。

3.2 通信机制
--------------

DLM LVB用于在集群内的节点之间通信。为此目的使用了三种资源：

3.2.1 令牌 (token)
^^^^^^^^^^^
  
   保护整个通信系统的资源。拥有令牌资源的节点被允许进行通信。

3.2.2 消息 (message)
^^^^^^^^^^^^^
  
   承载要通信的数据的锁资源。

3.2.3 确认 (ack)
^^^^^^^^^

   获取此资源表示消息已被集群中的所有节点确认。资源的BAST用于告知接收节点某节点想要进行通信。
通信算法如下：

1. 接收状态 - 所有节点对“ack”持有并发读锁：

   发送者                           接收者1                   接收者2
   "ack":CR                          "ack":CR                  "ack":CR

2. 发送者获取“token”的排他锁，
   发送者获取“message”的排他锁：

   发送者                           接收者1                   接收者2
   "token":EX                        "ack":CR                  "ack":CR
   "message":EX
   "ack":CR

   发送者检查是否仍需要发送消息。在等待“token”期间接收到的消息或其他事件可能导致此消息不再适用或冗余。
### 3. 发送者写入 LVB

    发送者将 "消息" 从 EX 下转换为 CW

    发送者尝试获取 "确认" 的 EX

    ::

      [ 等待直到所有接收者都处理了 "消息" ]

                                       [ 由 "确认" 的广播触发 ]
                                       接收者在 "消息" 上获得 CR
                                       接收者读取 LVB
                                       接收者处理消息
                                       [ 等待完成 ]
                                       接收者释放 "确认"
                                       接收者尝试在 "消息" 上获得 PR

     发送者                         接收者                  接收者
     "令牌":EX                     "消息":CR              "消息":CR
     "消息":CW
     "确认":EX

 4. 由 "确认" 的 EX 授予（表明所有接收者都已经处理了消息）触发

    发送者将 "确认" 从 EX 下转换为 CR

    发送者释放 "消息"

    发送者释放 "令牌"

    ::

                                 接收者将 "消息" 上的权限升级到 PR
                                 接收者获取 "确认" 的 CR
                                 接收者释放 "消息"

     发送者                      接收者                   接收者
     "确认":CR                    "确认":CR                 "确认":CR

### 4. 处理故障
#### 4.1 节点故障

 当一个节点发生故障时，DLM 将其槽号通知集群。该节点启动一个集群恢复线程。集群恢复线程执行以下操作：

	- 获取失败节点的 bitmap<number> 锁
	- 打开 bitmap
	- 读取失败节点的 bitmap
	- 将设置的 bitmap 复制到本地节点
	- 清理失败节点的 bitmap
	- 释放失败节点的 bitmap<number> 锁
	- 在当前节点上初始化 bitmap 的重新同步
	  在 recover_bitmaps 中调用 md_check_recovery，
	  然后 md_check_recovery -> metadata_update_start/finish，
	  使用 lock_comm 进行通信锁定
这意味着当一个节点正在重新同步时，它会阻止其他所有节点对数组进行写操作。
重新同步过程是常规的 md 重新同步。然而，在集群环境中执行重新同步时，需要告知其他节点被暂停的区域。在重新同步开始前，节点发送 RESYNCING 消息，包含需要被暂停的区域范围 (lo, hi)。每个节点维护一个 suspend_list，其中包含了当前被暂停的范围列表。接收到 RESYNCING 后，节点将该范围添加到 suspend_list 中。类似地，当执行重新同步的节点完成时，它向其他节点发送包含空范围的 RESYNCING，其他节点则从 suspend_list 中移除相应的条目。
辅助函数 ->area_resyncing() 可用于检查特定 I/O 范围是否应被暂停。

#### 4.2 设备故障

 设备故障通过元数据更新例程处理和通信。当一个节点检测到设备故障时，不允许对该设备进行进一步的写操作，直到其他所有节点确认了故障。

### 5. 添加新设备

 为了添加新设备，必须确保所有节点都能“看到”要添加的新设备。为此，采用以下算法：

   1.  节点 1 发出 mdadm --manage /dev/mdX --add /dev/sdYY 命令，这会发出 ioctl(ADD_NEW_DISK)，其中 disc.state 设置为 MD_DISK_CLUSTER_ADD
   2.  节点 1 发送包含 UUID 和槽号的 NEWDISK 消息
   3.  其他节点使用 UUID 和槽号发出 kobject_uevent_env （步骤 4 和 5 可能是一个 udev 规则）
   4.  在用户空间中，节点搜索磁盘，可能使用 blkid -t SUB_UUID=""
   5.  其他节点根据是否找到了磁盘，发出以下命令之一：
       ioctl(ADD_NEW_DISK)，其中 disc.state 设置为 MD_DISK_CANDIDATE 并且 disc.number 设置为槽号
       ioctl(CLUSTERED_DISK_NACK)
   6.  如果找到设备，其他节点释放 "no-new-devs" (CR) 锁
   7.  节点 1 尝试获取 "no-new-dev" 的 EX 锁
   8.  如果节点 1 获得了锁，则在取消标记磁盘为 SpareLocal 后发送 METADATA_UPDATED
   9.  如果没有获得 "no-new-dev" 锁，则操作失败并发送 METADATA_UPDATED
10. 其他节点通过以下 METADATA_UPDATED 获取磁盘是否被添加的信息

### 6. 模块接口

 有 17 个回调，md 核心可以调用集群模块。理解这些回调可以很好地概述整个过程。

#### 6.1 join(nodes) 和 leave()

 这些函数在带有集群化位图的阵列启动和停止时被调用。join() 确保集群可用并初始化各种资源。
只有集群中的前 'nodes' 个节点可以使用该阵列。
6.2 slot_number()
-----------------

报告集群基础设施建议的槽号。
范围是从 0 到 nodes-1。

6.3 resync_info_update()
------------------------

此函数更新存储在位图锁中的重同步范围。
随着重同步的进行，起始点会被更新。终点始终为数组的末尾。
它**不会**发送一个 RESYNCING 消息。

6.4 resync_start(), resync_finish()
-----------------------------------

这些函数在重同步/恢复/重塑开始或停止时被调用。
它们会更新位图锁中的重同步范围，并且还会发送一个 RESYNCING 消息。`resync_start` 报告整个数组正在重同步，而 `resync_finish` 报告没有部分正在重同步。
`resync_finish()` 还会发送一个 BITMAP_NEEDS_SYNC 消息，这允许其他某个节点接管。

6.5 metadata_update_start(), metadata_update_finish(), metadata_update_cancel()
--------------------------------------------------------------------------------

`metadata_update_start` 用于获取对元数据的独占访问权。如果在获得该访问权后仍然需要更改，则 `metadata_update_finish()` 将向所有其他节点发送一个 METADATA_UPDATE 消息；否则可以使用 `metadata_update_cancel()` 来释放锁。

6.6 area_resyncing()
--------------------

此功能结合了两项要素。
首先，它会检查在给定的扇区范围内是否有任何节点正在进行数据同步。如果发现有同步操作正在进行，那么调用方将避免在这个范围内进行写入或读取平衡。

其次，在节点恢复过程中，它会报告所有区域都在进行数据同步以处理读取请求。这样可以避免集群文件系统和集群RAID在处理节点故障时出现竞争条件。

6.7 `add_new_disk_start()`，`add_new_disk_finish()`，`new_disk_ack()`

这些函数用于管理上述描述的新磁盘协议。
当添加新设备时，在将其绑定到阵列之前会调用`add_new_disk_start()`；如果该操作成功，则会在设备完全加入后调用`add_new_disk_finish()`。
当设备是响应之前的请求而添加的，或者设备被声明为“不可用”时，会调用`new_disk_ack()`。

6.8 `remove_disk()`

当从阵列中移除备用或已故障的设备时会调用此函数。这会导致向其他节点发送一个REMOVE消息。

6.9 `gather_bitmaps()`

此函数会向所有其他节点发送一个RE_ADD消息，然后从所有位图中收集位图信息。这个合并后的位图随后会被用来恢复重新添加的设备。

6.10 `lock_all_bitmaps()` 和 `unlock_all_bitmaps()`

当需要改变位图状态为无时调用这两个函数。如果某个节点计划清除集群RAID的位图，它需要确保没有其他节点正在使用该RAID。这是通过锁定集群内的所有位图锁来实现的，并且相应的锁也需要被解锁。

7. 不支持的功能

集群MD目前不支持以下功能：
- 更改`array_sectors`
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
