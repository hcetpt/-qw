功率分配器管理器可调参数
=================================

临界点
-----------

该管理器在以下两个被动临界点下工作最优化：

1.  “启动”临界点：此温度以上，管理器控制回路开始运行。这是热区的第一个被动临界点。
2.  “期望温度”临界点：它应高于“启动”临界点。这是管理器所控制的目标温度。这是热区的最后一个被动临界点。
PID 控制器
--------------

功率分配器管理器实现了一个以温度作为控制输入、功率作为受控输出的比例-积分-微分控制器（PID 控制器）：

    P_max = k_p * e + k_i * err_integral + k_d * diff_err + 可持续功率

其中
   -  e = 期望温度 - 当前温度
   -  err_integral 是之前的误差之和
   -  diff_err = e - 前一次误差

它类似于下面所示的结构：

				       k_d
				       |
  当前温度                          |
       |                               v
       |              +----------+   +---+
       |       +----->| diff_err |-->| X |------+
       |       |      +----------+   +---+      |
       |       |                                          TDP因子
       |       |                      k_i       |       |  get_requested_power()
       |       |                       |        |       |        |     |
       |       |                       |        |       |        |     | ..
v       |                       v        v       v        v     v
     +---+     |      +-------+      +---+    +---+   +---+   +----------+
     | S |-----+----->| sum e |----->| X |--->| S |-->| S |-->|功率     |
     +---+     |      +-------+      +---+    +---+   +---+   |分配     |
       ^       |                                ^             +----------+
       |       |                                |                |     |
       |       |        +---+                   |                |     |
       |       +------->| X |-------------------+                v     v
       |                +---+                               授予性能
  期望温度              ^
			  |
			  |
		      k_po/k_pu

可持续功率
-----------------

在注册热区时应提供一个可持续耗散功率（毫瓦）的估计值。这估算了在期望的控制温度下可以持续耗散的功率。这是在期望的最大温度下的最大持续分配功率。实际持续功率可能因多种原因而有所不同。闭环控制器将处理诸如环境条件以及与硅片速度等级相关的某些因素等变化。因此，`可持续功率`只是一个估算值，并且可以根据需要调整以影响热坡度的激进程度。作为参考，4英寸手机的可持续功率通常为2000毫瓦，而10英寸平板电脑的可持续功率约为4500毫瓦（可能根据屏幕尺寸有所不同）。有可能将功率值表示为抽象尺度。持续功率应与相关冷却设备使用的尺度保持一致。

如果您使用设备树，请将其作为热区的属性添加。例如：

	thermal-zones {
		soc_thermal {
			polling-delay = <1000>;
			polling-delay-passive = <100>;
			sustainable-power = <2500>;
			..
相反，如果热区是从平台代码中注册的，则传递一个具有`sustainable_power`的`thermal_zone_params`。如果没有传递`thermal_zone_params`，则下面的内容就足够了：

	static const struct thermal_zone_params tz_params = {
		.sustainable_power = 3500,
	};

然后将`tz_params`作为第五个参数传递给`thermal_zone_device_register()`。

k_po 和 k_pu
-------------

在功率分配器热管理器中实现的PID控制器允许配置两个比例项常数：`k_po`和`k_pu`。`k_po`是在温度过冲期间（当前温度高于“期望温度”临界点）的比例项常数。相反地，`k_pu`是在温度欠冲期间（当前温度低于“期望温度”临界点）的比例项常数。

这些控制旨在作为配置系统允许的热“坡度”的主要机制。例如，较低的`k_pu`值会提供较慢的坡度，但代价是将可用容量限制在较低温度。另一方面，较高的`k_pu`值会导致管理器在温度较低时授予非常高的功率，并可能导致温度过冲。

`k_pu`的默认值为：

    2 * 可持续功率 / (期望温度 - 启动温度)

这意味着在`启动温度`时，控制器的比例项输出为2 * `可持续功率`。`k_po`的默认值为：

    可持续功率 / (期望温度 - 启动温度)

聚焦于PID控制器方程中的比例和前馈值，我们有：

    P_max = k_p * e + 可持续功率

比例项与期望温度和当前温度之间的差成正比。当当前温度等于期望温度时，比例部分为零，`P_max` = `可持续功率`。也就是说，在恒定负载下，系统应在热平衡状态下运行。`可持续功率`仅是一个估算值，这也是为什么需要此类闭环控制的原因。

扩展`k_pu`，我们得到：

    P_max = 2 * 可持续功率 * (T_set - T) / (T_set - T_on) + 可持续功率

其中：

    - T_set 是期望温度
    - T 是当前温度
    - T_on 是启动温度

当当前温度等于启动温度时，上述公式变为：

    P_max = 2 * 可持续功率 * (T_set - T_on) / (T_set - T_on) + 可持续功率 = 2 * 可持续功率 + 可持续功率 = 3 * 可持续功率

因此，仅比例项就使功率从3 * `可持续功率`线性下降到`可持续功率`，随着温度从启动温度上升到期望温度。

k_i 和 积分截止
-----------------------

`k_i`配置PID循环的积分项常数。这个项允许PID控制器补偿长期漂移以及输出控制的量化特性：冷却设备无法设置管理器请求的确切功率。当温度误差低于`积分截止`时，误差会在积分项中累积。然后将该项乘以`k_i`，并将结果加到控制器的输出上。通常，`k_i`设置得很低（1或2），而`积分截止`为0。
`k_d` 配置了PID循环中的导数项常数。建议保持其默认值：0。

冷却设备功率API
=================

受此管理器控制的冷却设备必须在它们的 `cooling_device_ops` 中提供额外的 "功率" API。它包含以下三个操作：

1. ::

    int get_requested_power(struct thermal_cooling_device *cdev,
			    struct thermal_zone_device *tz, u32 *power);

@cdev:
    指向 `struct thermal_cooling_device` 的指针
@tz:
    我们当前正在运行的热区
@power:
    用于存储计算出的功率的指针

`get_requested_power()` 计算设备请求的功率（以毫瓦为单位）并将其存储在 @power 中。成功时应返回 0，失败时返回 -E*。这目前被功率分配管理器用来计算分配给每个冷却设备的功率。
2. ::

	int state2power(struct thermal_cooling_device *cdev, struct
			thermal_zone_device *tz, unsigned long state,
			u32 *power);

@cdev:
    指向 `struct thermal_cooling_device` 的指针
@tz:
    我们当前正在运行的热区
@state:
    一个冷却设备状态
@power:
    用于存储等效功率的指针

将冷却设备状态 @state 转换为功率消耗（以毫瓦为单位）并将其存储在 @power 中。成功时应返回 0，失败时返回 -E*。这目前被热核心用来计算演员可以消耗的最大功率。
3. ::

	int power2state(struct thermal_cooling_device *cdev, u32 power,
			unsigned long *state);

@cdev:
    指向 `struct thermal_cooling_device` 的指针
@power:
    功率（以毫瓦为单位）
@state:
    用于存储结果状态的指针

计算一个冷却设备状态，使该设备消耗不超过 @power 毫瓦，并将其存储在 @state 中。成功时应返回 0，失败时返回 -E*。这目前被热核心用来将由功率分配管理器设置的特定功率转换为冷却设备可以设置的状态。这是一个函数，因为这种转换可能依赖于外部因素的变化，因此该函数应该根据“当前情况”给出最佳的转换。

冷却设备权重
--------------

权重是一种用来调整冷却设备之间分配的机制。它们表达了不同冷却设备之间的相对功率效率。更高的权重表示更高的功率效率。权重是相对的，如果每个冷却设备的权重都为一，则认为它们是相等的。这对于异构系统特别有用，在这些系统中，两个冷却设备可能执行相同类型的计算，但效率不同。例如，具有两种不同类型处理器的系统。

如果通过 `thermal_zone_device_register()` 注册热区（即平台代码），则权重作为热区的 `thermal_bind_parameters` 的一部分传递。

如果通过设备树注册平台，则它们作为 `cooling-maps` 节点中每个映射的 `contribution` 属性传递。

功率分配管理器的局限性
=======================

功率分配管理器的PID控制器在有周期性时钟的情况下工作得最好。如果你有一个驱动程序反复调用 `thermal_zone_device_update()`（或任何最终调用管理器的 `throttle()` 函数的操作），管理器响应不会很好。请注意，这并不特殊于这个管理器，step-wise 如果你调用其 throttle() 函数的速度比正常的热框架时钟快（比如由于中断），也会出现不正常行为，因为它会过度反应。

能源模型要求
==============

另一个重要的事情是冷却设备提供的功率值的一致比例。单个热区中的所有冷却设备的功率值应该要么以毫瓦为单位报告，要么缩放到相同的“抽象比例”。
