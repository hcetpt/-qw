### SPDX 许可证标识符: GPL-2.0

#### CPU空闲冷却

##### 情况：

在某些情况下，系统级芯片（SoC）可能会达到临界温度限制，并且无法围绕温度控制稳定温度。当SoC需要稳定温度时，内核可以通过作用于冷却设备来减少耗散的功率。当达到临界温度时，必须做出决定以降低温度，而这反过来会影响性能。
另一种情况是，在将动态泄漏减少到最低限度后，硅片温度仍然持续上升。这种失控现象可能由于静态泄漏而持续。唯一的解决办法是关闭组件电源，从而降低动态和静态泄漏，使组件得以冷却。
最后但同样重要的是，系统可能会要求特定的功耗预算，但由于OPP密度的原因，我们只能选择一个功耗低于请求值的OPP，从而导致CPU利用率不足，进而损失性能。换句话说，一个OPP的功耗小于请求的功耗预算，而下一个OPP则超过了功耗预算。如果存在一个中间的OPP，本可以被使用。

##### 解决方案：

如果我们能够在受控的时间段内消除静态和动态泄漏，SoC的温度将会下降。通过调节空闲状态的持续时间或空闲周期注入周期，我们可以调整功耗预算来缓解温度。
工作性能点（OPP）的密度对cpufreq的控制精度有很大影响，然而不同的供应商具有各种各样的OPP密度，一些供应商的OPP之间有较大的功耗差距，这会导致在热控制期间性能损失和其他场景下的功耗浪费。
在特定的OPP下，假设我们向属于同一集群的所有CPU注入空闲周期，其持续时间大于集群空闲状态的目标驻留时间，则这段时间内的静态和动态泄漏将几乎为零（除去进入该状态所需的能量）。因此，带有空闲周期的可持续功耗与OPP的可持续功耗呈线性关系，并可以用类似以下的系数计算：
```
Power(IdleCycle) = Coef x Power(OPP)
```

##### 空闲周期注入：

空闲周期注入的基本概念是强制CPU在每个控制周期中进入空闲状态指定的时间，它提供了一种除了cpufreq之外控制CPU功耗和热量的方法。理想情况下，如果属于同一集群的所有CPU同步地注入它们的空闲周期，集群可以以最小的功耗达到其功耗下降状态，并将静态泄漏降至接近于零。然而，这些空闲周期的注入会增加额外的延迟，因为CPU需要从深度睡眠状态唤醒。
我们使用固定的空闲周期注入持续时间，以确保可接受的性能损失和固定延迟。通过调节空闲周期注入的占空比，可以增加或减少缓解措施：
```
     ^
     |
     |
     |-------                         -------
     |_______|_______________________|_______|___________

     <------>
       idle  <---------------------->
                    running

      <----------------------------->
              duty cycle 25%
```

冷却设备实现基于占空比百分比确定状态的数量。当没有进行任何缓解时，冷却设备的状态为零，意味着占空比为0%。
当开始缓解时，根据管理器的策略选择起始状态。给定固定的空闲周期持续时间和占空比（即冷却设备的状态），可以计算运行持续时间。
管理器将改变冷却设备的状态，从而改变占空比，这种变化将调节冷却效果。
下面是提供的内容的中文翻译：

```
^
|
|
|-------                 -------
|_______|_______________|_______|___________

<------>
  idle  <-------------->
                running

<--------------------->
          duty cycle 33%


^
|
|
|-------         -------
|_______|_______|_______|___________

<------>
  idle  <------>
              running

<------------->
       duty cycle 50%
```

空闲注入持续时间值必须符合以下约束条件：

- 它小于或等于我们开始缓解时所能容忍的延迟。这个值取决于平台，并且将取决于用户体验、响应性和性能之间的权衡。此值应该被指定。
- 它大于我们需要达到热缓解的空闲状态的目标驻留时间，否则我们会消耗更多的能量。

### 功率考虑

当我们达到热阈值时，我们必须在特定温度下保持一定的功率，但此时我们消耗的功率为：
\[ \text{功率} = \text{电容} \times \text{电压}^2 \times \text{频率} \times \text{利用率} \]
这超过了可持续功率（或者系统设置有问题）。其中，“电容”和“利用率”是固定值，“电压”和“频率”人为固定，因为我们不想改变OPP（Operating Performance Point，运行性能点）。我们可以将“电容”和“利用率”组合成一个单一术语，即“动态功率系数(C_{\text{dyn}})”简化上述表达式，我们有：
\[ P_{\text{dyn}} = C_{\text{dyn}} \times \text{电压}^2 \times \text{频率} \]

功率分配器管理器会以某种方式要求我们降低功率，以达到设备树中定义的可持续功率。因此，通过空闲注入机制，我们希望获得平均功率(P_{\text{target}})，即在特定OPP上全功率运行一段时间，然后空闲另一段时间。这可以表示为等式：
\[ P(\text{opp})_{\text{target}} = \left(\frac{T_{\text{running}} \times P(\text{opp})_{\text{running}} + T_{\text{idle}} \times P(\text{opp})_{\text{idle}}}{T_{\text{running}} + T_{\text{idle}}}\right) \]

\[
T_{\text{idle}} = T_{\text{running}} \times \left(\frac{P(\text{opp})_{\text{running}}}{P(\text{opp})_{\text{target}}} - 1\right)
\]

此时，如果我们知道CPU的运行周期，那么就可以得到所需的空闲注入时间。反之，如果我们有空闲注入持续时间，我们可以计算出运行持续时间：
\[ T_{\text{running}} = \frac{T_{\text{idle}}}{\left(\frac{P(\text{opp})_{\text{running}}}{P(\text{opp})_{\text{target}}} - 1\right)} \]

实际上，如果运行功率小于目标功率，我们将得到一个负的时间值，因此显然该等式的使用仅限于功率减少的情况，从而需要更高的OPP来使运行功率大于目标功率。
然而，在本演示中，我们忽略了三个方面：

* 静态泄漏未在此定义，我们可以在等式中引入它，但由于很难从SoC供应商那里获取这些值，通常假设其值为零。

* 空闲状态唤醒延迟（或进入+退出延迟）未被考虑在内，必须将其添加到等式中以便严格地计算空闲注入。

* 注入的空闲时间必须大于空闲状态的目标驻留时间，否则我们会消耗更多能量，并可能逆转缓解效果。

因此，最终等式为：
\[ T_{\text{running}} = (T_{\text{idle}} - T_{\text{wakeup}}) \times \left(\frac{(P(\text{opp})_{\text{dyn}} + P(\text{opp})_{\text{static}}) - P(\text{opp})_{\text{target}}}{P(\text{opp})_{\text{target}}}\right) \]
