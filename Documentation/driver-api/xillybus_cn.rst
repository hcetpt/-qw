Xillybus 通用 FPGA 接口驱动程序

=============================

:作者: Eli Billauer, Xillybus 有限公司 (http://xillybus.com)
:电子邮件: eli.billauer@gmail.com 或如 Xillybus 网站上所宣传
.. 目录:

 - 引言
  -- 背景
  -- Xillybus 概览

 - 使用方法
  -- 用户界面
  -- 同步
  -- 可寻址管道

 - 内部结构
  -- 源代码组织
  -- 管道属性
  -- 主机从不从 FPGA 读取数据
  -- 通道、管道与消息通道
  -- 数据流传输
  -- 数据粒度
  -- 探测
  -- 缓冲区分配
  -- “非空”消息（支持 poll）

引言
====

背景
----

现场可编程门阵列（FPGA）是一种逻辑硬件，可以被编程以实现几乎任何通常作为专用芯片组的功能：例如，显示适配器、网络接口卡，甚至是一个带有其外设的处理器。FPGAs 是硬件中的乐高积木：基于某些构建模块，你可以按照自己的喜好制作自己的玩具。通常来说，重新实现市场上已经存在的芯片组是没有意义的，因此 FPGAs 主要用于需要一些特殊功能并且生产量相对较低的情况（因此不足以证明开发 ASIC 的合理性）。  
FPGA 的挑战在于所有事情都在非常低的级别实现，甚至比汇编语言还要低。为了使 FPGA 设计师能够专注于他们的特定项目，并避免一遍又一遍地重复发明轮子，经常使用预先设计的构建块——IP 核心。这些相当于 FPGA 中的库函数。IP 核心可以实现某些数学函数、一个功能单元（例如 USB 接口）、一个完整的处理器（例如 ARM）或任何可能有用的东西。可以把它们想象成一个构建块，两侧挂着电线以便与其他块连接。
在 FPGA 设计中的一项艰巨任务是与一个完整的操作系统（实际上，与运行它的处理器）进行通信：实现低级总线协议和与主机的稍微高级的接口（寄存器、中断、DMA 等）本身就是一项工程。当 FPGA 的功能是众所周知的（例如视频适配卡或网卡）时，可以专门为项目设计 FPGA 的接口逻辑。然后编写一个特殊的驱动程序来向内核和/或用户空间呈现 FPGA 为一个已知接口。在这种情况下，没有理由将 FPGA 视为与总线上的任何设备不同。
然而，通常所需的数据通信并不符合任何已知的外围设备功能。此外，为数据交换设计一个优雅的抽象层通常被认为是一项太大的工作。在这种情况下，会寻求一个更快但可能不太优雅的解决方案：驱动程序实际上作为一个用户空间程序编写，只留下内核空间部分负责基本的数据传输。这仍然需要为 FPGA 设计一些接口逻辑，并为内核编写一个简单的临时驱动程序。

Xillybus 概览
-------------

Xillybus 是一个 IP 核心和一个 Linux 驱动程序。它们共同形成了一套工具，用于在 FPGA 和主机之间提供基本的数据传输，提供具有简单用户界面的类似管道的数据流。它旨在作为一个低成本的解决方案，适用于那些有意义地将项目特定的部分放在用户空间程序中的混合 FPGA-主机项目。
由于从一个 FPGA 项目到另一个项目之间的通信需求可能会有很大差异（每个方向所需的管道数量及其属性），因此并没有一个特定的逻辑块是 Xillybus IP 核心。相反，IP 核心是根据最终用户提供的规范配置和构建的。
Xillybus 提供独立的数据流，对用户而言类似于管道或 TCP/IP 通信。在主机一侧，就像使用任何管道文件一样使用字符设备文件。在 FPGA 一侧，使用硬件 FIFO 来流式传输数据。这与通过固定大小缓冲区进行通信的常见方法不同（尽管 Xillybus 在后台确实使用了这样的缓冲区）。
在一个单一的 IP 核心中可能存在超过一百个这样的流，但也可能不超过一个，具体取决于配置。
为了简化Xillybus IP核心的部署，它包含了一个简单的数据结构，该结构完全定义了核心的配置。Linux驱动程序在初始化过程中获取这个数据结构，并据此设置DMA缓冲区和字符设备。因此，一个单一的驱动程序就可以即插即用地与任何Xillybus IP核心协同工作。
不应将上述提到的数据结构与PCI的配置空间或Flattened Device Tree混淆。

使用
=====

用户界面
--------------

在主机上，所有与Xillybus的接口都是通过`/dev/xillybus_*`设备文件完成的，这些文件会随着驱动程序加载而自动生成。这些文件的名称取决于FPGA中加载的IP核心（参见下面的探测）。要与FPGA通信，打开与你想要发送数据或接收数据的硬件FIFO对应的设备文件，并使用普通的`write()`或`read()`调用，就像处理常规管道一样。特别地，可以像这样操作：

	$ cat mydata > /dev/xillybus_thisfifo

	$ cat /dev/xillybus_thatfifo > hisdata

甚至可以在某个阶段按CTRL-C，尽管xillybus_*管道具有发送EOF的能力（但可能不会使用它）。
驱动程序和硬件设计为像管道一样行为合理，包括：

* 支持非阻塞I/O（通过在`open()`时设置O_NONBLOCK）
* 支持`poll()`和`select()`
* 在高负载下带宽效率高（使用DMA），同时也能处理小块数据的传输（类似TCP/IP），通过自动刷新实现
设备文件可以是只读、只写或双向的。双向设备文件被视为两个独立的管道（除了在实现代码中共享一个“通道”结构）。

同步
---------------

Xillybus管道在IP核心上被配置为同步或异步。对于同步管道，只有当一些数据被提交并由FPGA确认后，`write()`才会成功返回。这会减慢大量数据传输的速度，并且几乎不可能用于需要以恒定速率提供数据的流：在`write()`调用之间没有数据传送到FPGA，特别是在进程失去CPU控制的情况下。
当管道配置为异步时，如果缓冲区有足够的空间存储数据，则`write()`会返回。
对于从FPGA到主机的管道，异步管道允许只要相应的设备文件被打开，就立即开始从FPGA传输数据，无论是否通过`read()`请求了数据。对于同步管道，仅传输由`read()`请求的数据量。
总结来说，对于同步管道，主机与FPGA之间的数据仅为了满足当前由驱动程序处理的`read()`或`write()`调用而传输，并且这些调用会在返回前等待传输完成。
请注意，同步属性与`read()`或`write()`可能完成少于请求的字节数的可能性无关。有一个单独的配置标志（"allowpartial"）来决定是否允许这种部分完成的情况。
### 可寻址管道

同步管道可以配置为将流的位置暴露给FPGA上的用户逻辑。这样的管道在主机API上也是可寻址的。使用此功能，可以在FPGA一侧将内存或寄存器接口连接到可寻址的流。通过定位到所需的地址并按需调用`read()`或`write()`，可以读取或写入连接的内存中的特定地址。

### 内部结构

#### 源代码组织

Xillybus驱动程序由一个核心模块`xillybus_core.c`和依赖于特定总线接口的模块（例如`xillybus_of.c`和`xillybus_pcie.c`）组成。
当内核发现合适的设备时，会探测这些特定于总线的模块。由于DMA映射和同步函数本质上取决于总线，因此核心模块使用这些函数。在初始化时，向核心模块传递一个`xilly_endpoint_hardware`结构，其中包含指向执行总线上DMA相关操作的包装函数的指针。

#### 管道属性

每个管道都有一组在构建FPGA组件（IP核心）时设置的属性。这些属性通过`xillybus_core.c`中的`xilly_setupchannels()`从IDT（定义核心配置的数据结构，见下面的探测）获取如下：

- `is_writebuf`: 管道的方向。非零值表示它是一个FPGA到主机的管道（FPGA“写入”）。
- `channelnum`: 主机与FPGA通信中管道的标识号。
- `format`: 基础数据宽度。参见下面的数据粒度。
- `allowpartial`: 非零值表示`read()`或`write()`（根据情况）可能会返回少于请求的字节数。通常的选择是非零值，以匹配标准UNIX行为。
* 同步（synchronous）：非零值表示管道为同步模式。具体可参见上方的“同步”部分。
* 缓冲区大小（bufsize）：每个DMA缓冲区的大小。始终为2的幂次。
* 缓冲区数量（bufnum）：为此管道分配的缓冲区数量。始终为2的幂次。
* 独占打开（exclusive_open）：非零值强制独占打开关联的设备文件。如果设备文件是双向的，并且仅在一个方向上打开，则可以在相反的方向上打开一次。
* 可寻址（seekable）：非零值表示该管道支持寻址操作。具体可参见上方的“可寻址管道”部分。
* 支持非空状态（supports_nonempty）：非零值（这是常见的）表示硬件会发送必要的消息以支持此管道上的`select()`和`poll()`操作。

主机从不读取FPGA
------------------

尽管PCI Express通常支持热插拔，但典型的主板并不期望一张卡会突然消失。然而，由于PCIe卡基于可重新编程逻辑，因此在主机运行时意外重新编程FPGA导致其从总线上突然消失的情况是很可能发生的。实际上，在这种情况下立即不会发生任何事情。但如果主机试图从映射到PCI Express设备的地址中读取数据，这可能会导致某些主板系统立即冻结，即使PCIe标准要求系统能够优雅地恢复。

为了避免这些冻结情况的发生，Xillybus驱动程序完全避免从设备的寄存器空间进行读取操作。FPGA与主机之间的所有通信都是通过DMA完成的。特别地，中断服务例程不遵循常见做法，即在被调用时检查状态寄存器。相反，FPGA准备一个小缓冲区，其中包含简短的消息，用于告知主机中断的原因。

这一机制同样应用于非PCIe总线，以保持一致性。

通道、管道及消息通道
------------------------

对于用户可见的每一个（可能是双向的）管道，都会在FPGA和主机之间分配一个数据通道。只有因为通道0的存在，才需要区分通道和管道；通道0用于处理来自FPGA的中断相关消息，并没有对应的管道与其关联。
数据流传输
--------------

尽管对用户而言，两端呈现的都是非分段的数据流，但实现上依赖于为每个通道分配的一组DMA缓冲区。为了便于说明，我们以FPGA到主机的方向为例：当数据流进入FPGA中的相应通道接口时，Xillybus IP核心会将其写入一个DMA缓冲区中。当缓冲区满时，FPGA会通知主机（通过在通道0附加一个XILLYMSG_OPCODE_RELEASEBUF消息并必要时发送中断）。主机响应这一通知，通过字符设备使数据可供读取。当所有数据都被读取后，主机会写入FPGA的缓冲控制寄存器，允许覆盖该缓冲区。双方都存在流量控制机制以防止下溢和上溢。

但这还不足以创建出类似TCP/IP那样的数据流：如果数据流暂时停止在DMA缓冲区被填满之前，直观预期是缓冲区中的部分数据仍然应该到达，即使缓冲区未被完全填满。这通过在XILLYMSG_OPCODE_RELEASEBUF消息中添加一个字段来实现，该字段不仅指示提交了哪个缓冲区，还指示该缓冲区包含多少数据。
然而，FPGA仅在接收到主机的指令时才会提交未完全填满的缓冲区。这种情形发生在read()方法已经阻塞了XILLY_RX_TIMEOUT个滴答（目前为10毫秒）之后，此时主机命令FPGA尽快提交一个DMA缓冲区。这种超时机制在总线带宽效率（避免发送大量未完全填满的缓冲区）与数据尾部的延迟保持较低之间取得了平衡。

FPGA到主机方向也使用了类似的设置。对于部分填充的DMA缓冲区的处理略有不同。用户可以通过向驱动程序发出一个字节计数设置为零的write()命令来指示驱动程序将缓冲区中的所有数据提交给FPGA，这类似于刷新请求，但不会阻塞。此外还有一个自动刷新机制，在最后一次write()操作后的大约XILLY_RX_TIMEOUT个滴答后触发等效的刷新。

这使得用户可以不必关心底层的缓冲机制，同时仍能享受类似流的接口。
需要注意的是，对于设置了“同步”属性非零值的管道来说，部分缓冲区刷新的问题是无关紧要的，因为同步管道不允许数据在读取和写入之间停留在DMA缓冲区中。

数据粒度
----------------

数据以8位、16位或32位宽度的字的形式到达或发送至FPGA，具体取决于由“格式”属性配置的设置。只要可能，当管道以不同于其自然对齐的方式访问时，驱动程序会尝试隐藏这一点。

例如，从具有32位粒度的管道中读取单个字节没有任何问题。向具有16位或32位粒度的管道写入单个字节也将工作，但由于驱动程序不能向FPGA发送未完成的字，因此最多一个字的传输可能会被保留直到它完全被用户数据填充。

这在某种程度上使处理主机到FPGA的数据流变得复杂，因为在缓冲区被刷新时，可能存在高达3个字节未能形成FPGA中的一个完整的字，因此无法发送。为了避免数据丢失，这些剩余的字节需要移动到下一个缓冲区。xillybus_core.c中提到“剩余”的部分都与此复杂性有关。

探测
-------

如前所述，当驱动程序加载时创建的管道数量及其属性取决于FPGA中的Xillybus IP核心。在驱动程序初始化期间，一个包含配置信息的块——即接口描述表（IDT）——从FPGA发送到主机。引导过程分为三个阶段：

1. 获取IDT的长度，以便可以为此分配一个缓冲区。这是通过向设备发送静止命令来完成的，因为对该命令的确认包含了IDT缓冲区的长度。
### 获取IDT本身
### 根据IDT创建接口
#### 缓冲区分配

为了简化防止PCIe数据包非法越界的逻辑，采用以下规则：如果缓冲区小于4kB，则不允许跨越4kB边界。否则，必须以4kB对齐。`xilly_setupchannels()`函数通过向内核请求整个页面来分配这些缓冲区，并根据需要将它们划分为DMA缓冲区。由于所有缓冲区的大小都是2的幂次方，因此可以以最多浪费一个页面内存的方式打包任何这样的缓冲区集合。
所有缓冲区都在驱动程序加载时分配。这是必要的，因为有时会请求大的连续物理内存段，在系统刚刚启动时，这些内存段更有可能可用。
缓冲区内存的分配按照它们在IDT中出现的顺序进行。驱动程序依赖于一条规则，即管道在IDT中按照递减的缓冲区大小排序。如果请求的缓冲区大于或等于一页，那么就从内核请求所需的页数，并将这些页用于该缓冲区。如果请求的缓冲区小于一页，则从内核请求一页，并部分使用该页；
或者，如果已经有部分使用的页存在，则将缓冲区打包到那个页中。可以证明，从内核请求的所有页面（除了可能的最后一张外）都以这种方式100%被利用。

### “非空”消息（支持轮询）
为了支持“轮询”方法（从而支持`select()`），关于FPGA到主机方向有一个小问题：FPGA可能已经用一些数据填充了一个DMA缓冲区，但还没有提交这个缓冲区。如果主机等待FPGA提交缓冲区，那么可能会出现FPGA一侧已经发送了数据，但`select()`调用仍然阻塞的情况，因为主机没有收到关于这一点的通知。这个问题通过FPGA发送`XILLYMSG_OPCODE_NONEMPTY`消息解决，当通道从完全为空变为包含一些数据时就会发送这种消息。
这些消息仅用于支持`poll()`和`select()`。IP核心可以配置为不发送这些消息，以略微减少带宽消耗。
