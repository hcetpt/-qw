SPDX 许可证标识符: GPL-2.0
.. include:: <isonum.txt>

.. _driverapi_pm_devices:

==============================
设备电源管理基础
==============================

:版权所有: |copy| 2010-2011 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc
:版权所有: |copy| 2010 Alan Stern <stern@rowland.harvard.edu>
:版权所有: |copy| 2016 Intel Corporation

:作者: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

Linux中的大部分代码是设备驱动程序，因此Linux中的大部分电源管理（PM）代码也是特定于驱动程序的。大多数驱动程序将做很少的工作；而其他驱动程序，特别是针对小型电池平台（如手机）的驱动程序，将执行大量的工作。
本文档概述了驱动程序如何与系统范围内的电源管理目标进行交互，重点介绍了一切与驱动模型核心挂钩的模型和接口。阅读本文档作为处理任何特定驱动程序的具体领域工作的背景。

两种设备电源管理模式
======================================

驱动程序将使用这两种模式之一或两者来将设备置于低功耗状态：

    系统休眠模型：

	驱动程序可以作为进入系统级低功耗状态的一部分，如“挂起”（也称为“挂起到RAM”），或者（主要是对于具有磁盘的系统）“休眠”（也称为“挂起到磁盘”），进入低功耗状态。
这是设备、总线和类驱动程序通过实现各种特定角色的挂起和恢复方法来协同工作的内容，这些方法可以干净地关闭硬件和软件子系统，然后在不丢失数据的情况下重新激活它们。
一些驱动程序可以管理硬件唤醒事件，这些事件会使系统离开低功耗状态。此功能可以通过相关 :file:`/sys/devices/.../power/wakeup` 文件启用或禁用（对于以太网驱动程序，也可以使用ethtool使用的ioctl接口来实现此目的）；启用它可能会消耗一些电量，但可以让整个系统更频繁地进入低功耗状态。
运行时电源管理模型：

	设备也可以在系统运行时独立于其他电源管理活动被置于低功耗状态。
然而，设备通常不是相互独立的（例如，父设备无法挂起除非所有子设备都已挂起）。此外，根据设备所在的总线类型，可能需要对设备执行一些特定于总线的操作。在运行时置于低功耗状态的设备可能需要在系统级电源转换（挂起或休眠）期间进行特殊处理。
由于这些原因，不仅设备驱动程序本身，而且适当的子系统（总线类型、设备类型或设备类别）驱动程序以及PM核心都参与运行时电源管理。如同系统休眠电源管理情况一样，他们需要通过实现各种特定角色的挂起和恢复方法来协作，以便硬件可以被干净地关闭并重新激活，而不会丢失数据或服务。
关于那些低功耗状态并没有太多可以说的，除了它们非常特定于系统，并且通常也是特定于设备的。此外，如果足够多的设备（在运行时）已被置于低功耗状态，其效果可能与进入某些系统级低功耗状态（系统休眠）非常相似...并且存在协同效应，因此几个使用运行时PM的驱动程序可能会将系统置于可以利用更深的节能选项的状态。
大多数挂起的设备会静默所有的I/O操作：不再有DMA或IRQ（除了唤醒事件外），不再读写数据，并且不再接受上游驱动程序的请求。但是，特定的总线或平台可能有不同的要求。

硬件唤醒事件的例子包括实时时钟的警报、网络唤醒局域网的数据包、键盘或鼠标活动以及PCMCIA、MMC/SD、USB等介质的插入或移除。

进入系统睡眠状态的接口
========================

为子系统（总线类型、设备类型、设备类别）和设备驱动程序提供了编程接口，使它们能够参与其所关注设备的电源管理。这些接口涵盖了系统睡眠和运行时电源管理。

设备电源管理操作
------------------

设备电源管理操作，在子系统级别和设备驱动程序级别，是通过定义并填充在`:file:`include/linux/pm.h`中定义的`struct dev_pm_ops`类型的对象来实现的。接下来将解释其包含的方法的作用。现在，只需记住最后三个方法是专用于运行时电源管理的，而其余的方法则用于系统范围内的电源转换。

还有一个过时的“旧”或“遗留”电源管理操作接口至少对某些子系统可用。这种方法不使用`struct dev_pm_ops`对象，并且只适用于以有限的方式实现系统睡眠电源管理方法。因此，本文档中没有描述它，请直接参考源代码获取更多信息。

子系统级别的方法
------------------

核心的挂起和恢复设备的方法位于由`struct dev_pm_domain`中的`:c:member:`ops`成员或`struct bus_type`、`struct device_type`和`struct class`中的`:c:member:`pm`成员指向的`struct dev_pm_ops`结构体中。这些方法主要对编写平台和总线（如PCI或USB）基础设施的人感兴趣，也包括设备类型和设备类别的驱动程序编写者。对于那些其子系统（PM域、设备类型、设备类别和总线类型）没有提供所有电源管理方法的设备驱动程序编写者来说，它们也是相关的。

总线驱动程序根据硬件及其使用的驱动程序适当实现这些方法；PCI与USB的工作方式不同，等等。编写子系统级别的驱动程序的人不多；大多数驱动程序代码是一个“设备驱动程序”，它基于特定总线框架代码之上构建。

有关这些驱动程序调用的更多信息，请参阅后面的描述；这些调用按阶段针对每个设备进行，遵循驱动模型树中的父子顺序。

`:file:`/sys/devices/.../power/wakeup`文件
-------------------------------------------

驱动模型中的所有设备对象都包含控制处理系统唤醒事件（可以强制系统从睡眠状态退出的硬件信号）的字段。这些字段由总线或设备驱动程序代码使用在`:file:`include/linux/pm_wakeup.h`中定义的`:c:func:`device_set_wakeup_capable()`和`:c:func:`device_set_wakeup_enable()`初始化。

`:c:member:`power.can_wakeup`标志仅记录设备（及其驱动程序）是否物理上支持唤醒事件。`:c:func:`device_set_wakeup_capable()`例程影响此标志。`:c:member:`power.wakeup`字段是指向`struct wakeup_source`类型对象的指针，用于控制设备是否应使用其系统唤醒机制以及通知电源管理核心设备所发出的系统唤醒事件。此对象仅存在于可唤醒的设备（即设置了`:c:member:`can_wakeup`标志的设备）中，并由`:c:func:`device_set_wakeup_capable()`创建（或移除）。
是否一个设备能够发出唤醒事件，这是一个硬件层面的问题，并且内核负责跟踪这一能力。相反，一个具有唤醒能力的设备是否应该发出唤醒事件，则是一个策略决策问题，并通过一个 sysfs 属性由用户空间进行管理：即文件 :file:`power/wakeup`。用户空间可以通过向这个文件写入 "enabled" 或 "disabled" 来表示该设备是否应该发出系统唤醒信号。这个文件只有在给定设备存在 :c:member:`power.wakeup` 对象时才存在，并且会随着该对象一起被创建或移除，这通过调用 :c:func:`device_set_wakeup_capable()` 实现。从这个文件读取将返回相应的字符串。

在 :file:`power/wakeup` 文件中的初始值对于大多数设备是 "disabled"；主要例外是电源按钮、键盘以及已经使用 ethtool 设置了 WoL（网络唤醒）功能的以太网适配器。对于那些自身不生成唤醒请求而仅仅是将唤醒请求从一个总线转发到另一个总线的设备（例如 PCI Express 端口），默认应当设置为 "enabled"。

:c:func:`device_may_wakeup()` 函数仅在 :c:member:`power.wakeup` 对象存在并且对应的 :file:`power/wakeup` 文件包含 "enabled" 字符串时返回真。这个信息被子系统（如 PCI 总线类型代码）用来判断是否需要启用设备的唤醒机制。如果设备的唤醒机制直接由驱动程序启用或禁用，那么它们也应该使用 :c:func:`device_may_wakeup()` 来决定在系统休眠转换期间应该做什么。然而，在任何情况下，设备驱动程序都不应该直接调用 :c:func:`device_set_wakeup_enable()`。

需要注意的是，系统唤醒与运行时电源管理中使用的“远程唤醒”概念上是不同的，尽管它们可能由相同的物理机制支持。远程唤醒是一种特性，允许处于低功耗状态的设备触发特定中断来指示它们应该进入全功率状态的情况。这些中断可能被用来指示系统唤醒事件，也可能不会，这取决于硬件设计。在某些系统中，无法从系统休眠状态触发这些中断。无论如何，对于所有支持它的设备和驱动程序，远程唤醒都应该始终为运行时电源管理启用。

### :file:`/sys/devices/.../power/control` 文件

驱动模型中的每个设备都有一个标志来控制它是否受运行时电源管理的影响。这个标志 :c:member:`runtime_auto` 由总线类型（或通常子系统）代码使用 :c:func:`pm_runtime_allow()` 或 :c:func:`pm_runtime_forbid()` 初始化；默认是允许运行时电源管理。

用户空间可以通过向设备的 :file:`power/control` sysfs 文件写入 "on" 或 "auto" 来调整此设置。写入 "auto" 将调用 :c:func:`pm_runtime_allow()`，设置标志并允许驱动程序对设备进行运行时电源管理。写入 "on" 将调用 :c:func:`pm_runtime_forbid()`，清除标志，如果设备处于低功耗状态则将其恢复到全功率，并防止设备被运行时电源管理。用户空间可以通过读取该文件来检查当前的 :c:member:`runtime_auto` 标志值。

设备的 :c:member:`runtime_auto` 标志不影响整个系统的电源转换处理。特别是，即使其 :c:member:`runtime_auto` 标志被清除，设备仍然可以（并且在大多数情况下应该和将会）在系统进入休眠状态时进入低功耗状态。

有关运行时电源管理框架的更多信息，请参阅 `Documentation/power/runtime_pm.rst`。
### 调用驱动程序进入和退出系统休眠状态

当系统进入休眠状态时，每个设备的驱动程序会被要求将设备置于与目标系统状态兼容的挂起状态。这通常是某种版本的“关闭”状态，但具体细节取决于系统。此外，能够唤醒的设备通常会保持部分功能以便唤醒系统。
当系统离开这种低功耗状态时，设备的驱动程序会被要求通过恢复到全功率状态来重启它。挂起和恢复操作总是相伴出现，并且都是多阶段的操作。

对于简单的驱动程序，挂起可能使用类别代码使设备静止，然后在`suspend_noirq`期间尽可能地关闭其硬件。相应的恢复调用则会在重新激活其类I/O队列之前完全重新初始化硬件。
更注重能效的驱动程序可能会为触发系统唤醒事件准备设备。

#### 调用序列保证

为了确保在挂起或恢复设备时，桥接器和类似的需要与设备通信的链接可用，设备层级是按照从下至上的顺序进行挂起的。而使用从上至下的顺序来恢复这些设备。
设备层级的排序由设备注册的顺序定义：子设备永远不能在其父设备之前被注册、探测或恢复；也不能在其父设备之后被移除或挂起。
政策规定设备层级应该匹配硬件总线拓扑结构
【或者至少对于使用多个总线的设备来说，应该匹配控制总线。】
特别地，这意味着如果设备的父级正在挂起（即已被PM核心选为下一个要挂起的设备）或已经挂起，以及所有其他设备都已挂起之后，设备注册可能会失败。设备驱动程序必须准备好应对这种情况。

### 系统电源管理阶段

挂起或恢复系统的操作分为几个阶段。不同的阶段用于空闲挂起、浅层（待机）和深层（挂起到RAM）睡眠状态及休眠状态（挂起到磁盘）。每个阶段涉及在下一阶段开始前执行所有设备的回调函数。并非所有总线或类别都支持所有这些回调，也不是所有驱动程序都会使用所有回调。各个阶段总是在任务被冻结后且在它们解冻前运行。此外，`*_noirq`阶段在中断处理程序被禁用（除了那些带有IRQF_NO_SUSPEND标志的处理程序）的时候运行。
所有阶段都使用PM域、总线、类型、类别或驱动程序的回调（即，在`dev->pm_domain->ops`、`dev->bus->pm`、`dev->type->pm`、`dev->class->pm`或`dev->driver->pm`中定义的方法）。这些回调被视为PM核心中的互斥操作。而且，PM域的回调始终优先于所有其他回调，并且例如类型的回调优先于总线、类别和驱动程序的回调。确切地说，以下规则用于确定给定阶段中执行哪个回调：

    1. 如果存在`dev->pm_domain`，PM核心将选择由`dev->pm_domain->ops`提供的回调进行执行
2. 否则，如果 `dev->type` 和 `dev->type->pm` 都存在，则将选择由 `dev->type->pm` 提供的回调函数来执行。
3. 否则，如果 `dev->class` 和 `dev->class->pm` 都存在，则将选择由 `dev->class->pm` 提供的回调函数来执行。
4. 否则，如果 `dev->bus` 和 `dev->bus->pm` 都存在，则将选择由 `dev->bus->pm` 提供的回调函数来执行。

这允许电源管理（PM）域和设备类型在必要时覆盖总线类型或设备类提供的回调函数。PM 域、类型、类和总线的回调函数可以反过来调用存储在 `dev->driver->pm` 中的设备或驱动程序特定的方法，但并非必须这样做。

如果选定执行的子系统回调不存在，PM 核心将代替执行 `dev->driver->pm` 集合中的相应方法（如果有）。

进入系统挂起状态
-------------------

当系统进入冻结、待机或内存睡眠状态时，阶段如下：`prepare`、`suspend`、`suspend_late`、`suspend_noirq`。

1. `prepare` 阶段旨在通过阻止新设备注册以防止竞争条件的发生；如果可以随意注册新的子设备，PM 核心将永远无法知道一个设备的所有子设备都已挂起。[相比之下，从 PM 核心的角度来看，设备可能随时被注销。] 与其他与挂起相关的阶段不同，在 `prepare` 阶段期间，会自顶向下遍历设备层次结构。

在 `->prepare` 回调方法返回后，不再允许在此设备下注册新的子设备。此方法还可以以某种方式准备设备或驱动程序，使其为即将到来的系统电源转换做好准备，但不应将设备置于低功耗状态。此外，如果设备支持运行时电源管理，则 `->prepare` 回调方法不得更新其状态，以防稍后需要从运行时挂起状态恢复。

对于支持运行时电源管理的设备，可以通过 `prepare` 回调的返回值指示 PM 核心可以安全地让设备保持在运行时挂起状态（如果已经处于运行时挂起状态），前提是设备的所有后代也保持在运行时挂起状态。具体来说，如果 `prepare` 回调返回一个正数，并且该设备的所有后代也返回正数，并且它们（包括该设备本身）都处于运行时挂起状态，则 PM 核心将跳过 `suspend`、`suspend_late` 和 `suspend_noirq` 阶段以及这些设备后续恢复的所有相应阶段。在这种情况下，`->complete` 回调将是 `->prepare` 回调之后被调用的下一个回调，并且完全负责使设备处于适当的一致状态。
请注意，这种直接完成的流程即使在设备禁用了运行时电源管理(RT-PM)的情况下也适用；只有运行时电源管理的状态才是关键。由此可以推断，如果一个设备具有系统休眠回调函数但不支持运行时电源管理，则其准备(prepare)回调函数永远不应返回正值。这是因为所有此类设备最初都被设置为运行时暂停状态，并且禁用了运行时电源管理。

此特性也可以通过设备驱动程序使用 `DPM_FLAG_NO_DIRECT_COMPLETE` 和 `DPM_FLAG_SMART_PREPARE` 驱动电源管理标志进行控制。[通常，这些标志是在驱动程序针对特定设备探测时通过传递给 :c:func:`dev_pm_set_driver_flags` 辅助函数来设置的。] 如果设置了第一个标志，则电源管理核心将不会对指定设备及其任何祖先应用上述描述的直接完成流程。第二个标志被设置时，会告知中间层代码（总线类型、设备类型、PM域、类）应该考虑驱动程序提供的 `->prepare` 回调函数的返回值，并且只有当驱动程序的回调函数也返回正值时，它自己的 `->prepare` 回调函数才可返回正值。

2. `->suspend` 方法应使设备静止以停止其执行I/O操作。它们还可以保存设备寄存器并将其置于适当的低功耗状态，这取决于设备所在的总线类型，并可能启用唤醒事件。
然而，对于支持运行时电源管理的设备，由子系统（特别是总线类型和PM域）提供的 `->suspend` 方法必须遵循一条额外规则，即在调用其驱动程序的 `->suspend` 方法之前可以对设备执行哪些操作。
具体来说，如果有必要，它们可以通过调用 :c:func:`pm_runtime_resume` 来恢复设备从运行时暂停状态，但在那时不得以任何其他方式更新设备的状态（以防驱动程序需要在其 `->suspend` 方法中恢复设备从运行时暂停状态）。实际上，电源管理核心通过在发出 `->prepare` 回调前调用 :c:func:`pm_runtime_get_noresume` 并在发出 `->complete` 回调后调用 :c:func:`pm_runtime_put` 来阻止子系统或驱动程序在此期间将设备置于运行时暂停状态。

3. 对于许多设备而言，将挂起分为“使设备静止”和“保存设备状态”两个阶段更为方便，在这种情况下 `suspend_late` 被设计用于后者。它总是在为相关设备禁用运行时电源管理之后执行。

4. `suspend_noirq` 阶段发生在中断处理程序被禁用之后，这意味着在回调方法运行时驱动程序的中断处理程序不会被调用。 `->suspend_noirq` 方法应保存之前未保存的设备寄存器的值，并最终将设备置于适当的低功耗状态。
大多数子系统和设备驱动程序不需要实现此回调。但是，像PCI这样的允许设备共享中断向量的总线类型通常需要它；否则，在挂起阶段驱动程序可能会因为处理来自其他设备的共享中断而遇到错误，尽管它自己的设备已经被设置为低功耗状态。

在这些阶段结束时，驱动程序应已停止所有I/O事务（DMA、IRQ），保存了足够的状态以便重新初始化或恢复先前状态（如硬件所需），并将设备置于低功耗状态。在许多平台上，它们将关闭一个或多个时钟源；有时它们也会切断电源供应或降低电压。[支持运行时PM的驱动程序可能已经执行了其中的一些或全部步骤。]

如果 :c:func:`device_may_wakeup()` 返回 `true`，则设备应准备好生成硬件唤醒信号，以便在系统处于睡眠状态时触发系统唤醒事件。例如， :c:func:`enable_irq_wake()` 可能会标识与开关或其他外部硬件连接的GPIO信号，而 :c:func:`pci_enable_wake()` 对于PCI PME信号也做了类似的事情。
如果这些回调函数中的任何一个返回错误，系统将不会进入期望的低功耗状态。相反，电源管理（PM）核心会撤销其操作，通过恢复所有被挂起的设备。

离开系统挂起
------------

从冻结、待机或内存睡眠状态恢复时，各阶段依次为：“resume_noirq”、“resume_early”、“resume”以及“complete”。

1. `->resume_noirq` 回调方法应在驱动程序中断处理器被调用之前执行所需的操作。这通常意味着撤销`suspend_noirq`阶段的操作。如果总线类型允许设备共享中断向量（如PCI），则该方法应使设备及其驱动程序处于一种状态，使得驱动程序能够识别设备是否是任何传入中断的来源，并正确处理它们。
   例如，PCI总线类型的`->pm.resume_noirq()`将设备置于全功率状态（在PCI术语中称为D0），并恢复设备的标准配置寄存器。然后它调用设备驱动程序的`->pm.resume_noirq()`方法来执行特定于设备的操作。

2. `->resume_early` 方法应准备设备以执行恢复方法。这通常涉及撤销前一个`suspend_late`阶段的操作。

3. `->resume` 方法应使设备恢复到运行状态，以便能够进行正常的I/O操作。这通常涉及撤销`suspend`阶段的操作。

4. “complete”阶段应撤销`prepare`阶段的操作。
   为此，在“complete”阶段，与其它恢复相关的阶段不同，会自下而上遍历设备层次结构。
   
然而，请注意，新子设备可能在`->resume`回调发生后立即注册在设备下方；无需等待直到“complete”阶段运行。

此外，如果前一个`->prepare`回调返回了一个正数，则设备可能在整个系统挂起和恢复过程中一直处于运行时挂起状态（其`->suspend`、`->suspend_late`、`->suspend_noirq`、`->resume_noirq`、`->resume_early`和`->resume`回调可能被跳过）。在这种情况下，`->complete`回调完全负责在必要时使设备在系统挂起后处于一致状态（例如，可能需要为设备排队一个运行时恢复请求）。为了检查这种情况是否成立，`->complete`回调可以查看设备的`power.direct_complete`标志。如果在运行`->complete`回调时该标志被设置，则使用了直接完成机制，可能需要采取特殊操作以使设备之后正常工作。
在这些阶段结束时，驱动程序应像挂起前一样功能完备：可以使用DMA和IRQ进行I/O操作，并且相关的时钟被打开。然而，这里的细节可能再次取决于具体平台。例如，一些系统支持多种“运行”状态，而在恢复后的状态可能与挂起前的状态不同。这意味着某些时钟或电源供应的可用性发生了变化，这很容易影响驱动程序的工作方式。驱动程序需要能够处理硬件已被重置的情况，因为所有的挂起方法都被调用过，例如通过完全重新初始化。这部分可能是最难的，也是最受到NDA文档和芯片修正列表保护的部分。如果从执行挂起到现在硬件状态没有改变，情况会最简单，但这只有在目标系统的睡眠进入的是空闲挂起状态时才能得到保证。对于其他系统睡眠状态可能并非如此（并且通常对于ACPI定义的系统睡眠状态如S3状态来说确实不是这样）。驱动程序还必须准备好注意到设备在系统断电时被移除，只要物理上有可能发生这种情况。PCMCIA、MMC、USB、火线（Firewire）、SCSI乃至IDE都是常见Linux平台上可能发生此类移除的总线示例。目前，驱动程序如何注意到并处理这类移除的细节是特定于总线的，通常涉及一个单独的线程。这些回调函数可能会返回错误值，但PM核心会忽略这些错误，因为它除了将它们打印到系统日志中之外无法做任何事情。

进入休眠状态
--------------

让系统进入休眠状态比让它进入睡眠状态更为复杂，因为它涉及到创建和保存系统镜像。因此，休眠有更多阶段，以及一套不同的回调函数。这些阶段总是在任务冻结并且释放了足够的内存之后运行。休眠的一般过程是使所有设备静止不动（“冻结”），在一切稳定时创建系统内存的镜像，重新激活所有设备（“解冻”），将镜像写入永久存储，并最终关闭系统（“关机”）。为了实现这一过程，使用的阶段包括：“prepare”、“freeze”、“freeze_late”、“freeze_noirq”、“thaw_noirq”、“thaw_early”、“thaw”、“complete”、“prepare”、“poweroff”、“poweroff_late”、“poweroff_noirq”。
1. “准备”阶段在上面的“进入系统挂起”部分中进行了讨论。
2. “->freeze”方法应使设备静默，以避免其产生IRQ或DMA，并且可能需要保存设备寄存器的值。然而，设备不必置于低功耗状态，为了节省时间最好不这么做。此外，设备不应准备好生成唤醒事件。
3. “freeze_late”阶段类似于前面描述的“suspend_late”阶段，不同之处在于设备不应置于低功耗状态，并且不允许其生成唤醒事件。
4. “freeze_noirq”阶段类似于前面讨论的“suspend_noirq”阶段，不同之处同样是设备不应置于低功耗状态，并且不允许其生成唤醒事件。此时创建系统映像。所有设备都应处于非活动状态，在此过程中内存内容应保持不变，以便形成系统的原子快照。
5. “thaw_noirq”阶段类似于前面讨论的“resume_noirq”阶段。主要区别在于它的方法可以假设设备处于与“freeze_noirq”阶段结束时相同的状态。
6. “thaw_early”阶段类似于上面描述的“resume_early”阶段。其方法应撤销之前“freeze_late”的操作（如果必要的话）。
7. “thaw”阶段类似于前面讨论的“resume”阶段。其方法应使设备恢复到工作状态，以便必要时可用于保存映像。
8. “complete”阶段在上面的“离开系统挂起”部分中进行了讨论。
此时系统映像被保存，接下来需要为即将到来的系统关机做准备。这类似于在将系统置于空闲挂起、浅睡眠或深睡眠状态前对设备进行挂起处理，各个阶段类似。
9. 上文已讨论了“准备（prepare）”阶段。
10. “关闭电源（poweroff）”阶段类似于“挂起（suspend）”阶段。
11. “关闭电源晚期（poweroff_late）”阶段类似于“挂起晚期（suspend_late）”阶段。
12. “关闭电源无中断（poweroff_noirq）”阶段类似于“挂起无中断（suspend_noirq）”阶段。
对于`->poweroff`、`->poweroff_late`和`->poweroff_noirq`回调，它们应该基本上执行与`->suspend`、`->suspend_late`及`->suspend_noirq`回调相同的操作。一个显著的区别是，它们无需存储设备寄存器的值，因为这些值应该已经在“冻结（freeze）”、“冻结晚期（freeze_late）”或“冻结无中断（freeze_noirq）”阶段被存储。此外，在许多机器上，固件将使整个系统断电，因此回调无需将设备置于低功耗状态。

### 恢复休眠

恢复休眠比从保持主内存内容不变的睡眠状态中恢复更为复杂，因为它需要加载系统映像到内存中，并在传递控制给映像内核之前恢复休眠前的内存内容。
虽然理论上可以通过引导加载程序加载映像并恢复休眠前的内存内容，但在实践中这是无法实现的，因为引导加载程序不够智能，也没有既定的协议来传递必要的信息。因此，取而代之的是，引导加载程序将一个新的内核实例（称为“恢复内核”）加载到内存中，并以通常的方式传递控制权。然后，恢复内核读取系统映像，恢复休眠前的内存内容，并传递控制权给映像内核。因此，恢复休眠涉及两个不同的内核实例。实际上，恢复内核可能与映像内核完全不同：不同的配置甚至不同的版本。这对设备驱动程序及其子系统有重要影响。

为了能够将系统映像加载到内存中，恢复内核需要至少包含一个允许其访问包含映像的存储介质的设备驱动程序子集，尽管它不需要包含映像内核中的所有驱动程序。加载映像后，需要为传递控制给映像内核做准备，由恢复内核管理的设备。这与创建系统映像时最初的步骤非常相似，并且使用相同的方法完成，即使用“准备（prepare）”、“冻结（freeze）”和“冻结无中断（freeze_noirq）”阶段。但是，受这些阶段影响的设备仅限于恢复内核中存在的驱动程序；其他设备仍处于引导加载程序留下的状态。

如果恢复休眠前的内存内容失败，恢复内核会经历上述的“解冻（thaw）”过程，使用“解冻无中断（thaw_noirq）”、“解冻早期（thaw_early）”、“解冻（thaw）”和“完成（complete）”阶段，然后继续正常运行。这种情况很少发生。大多数情况下，休眠前的内存内容成功恢复，控制权传递给了映像内核，后者负责将系统恢复到工作状态。

为此，映像内核必须恢复设备休眠前的功能。这一操作类似于从保持内存内容不变的睡眠状态中唤醒，尽管它涉及不同的阶段：“恢复无中断（restore_noirq）”、“恢复早期（restore_early）”、“恢复（restore）”和“完成（complete）”。
1. `restore_noirq` 阶段与 `resume_noirq` 阶段类似。
2. `restore_early` 阶段与 `resume_early` 阶段类似。
3. `restore` 阶段与 `resume` 阶段类似。
4. `complete` 阶段已在上文讨论过。

与 `resume[_early|_noirq]` 的主要区别在于，`restore[_early|_noirq]` 必须假设设备已经被启动加载程序或恢复内核访问和重新配置。因此，设备的状态可能与在 `freeze`、`freeze_late` 和 `freeze_noirq` 阶段记录的状态不同。甚至可能需要重置设备并完全重新初始化。在许多情况下，这种差异并不重要，因此可以将 `->resume[_early|_noirq]` 和 `->restore[_early|_noirq]` 方法指针设置为相同的例程。然而，无论如何使用不同的回调指针，以防实际上确实存在这种情况。

### 电源管理通知器

有一些操作不能通过上述的电源管理回调来执行，因为这些回调发生得太晚或者太早。为了处理这些情况，子系统和设备驱动程序可以注册电源管理通知器，在任务被冻结之前和解冻之后调用。一般来说，PM通知器适用于执行那些需要用户空间可用的操作，或者至少不会干扰用户空间的操作。

详细信息请参阅 Documentation/driver-api/pm/notifiers.rst。

### 设备低功耗（挂起）状态

设备低功耗状态不是标准化的。一个设备可能只处理“开启”和“关闭”，而另一个设备可能支持多种版本的“开启”状态（有多少引擎处于活动状态？），以及一种能够比从完全“关闭”状态更快地回到“开启”的状态。

一些总线定义了关于不同挂起状态的意义规则。PCI是一个例子：在挂起序列完成后，非传统PCI设备不得执行DMA或发出IRQ，并且任何唤醒事件都应通过PME#总线信号发出。此外，还有几种PCI标准设备状态，其中一些是可选的。
相比之下，集成的片上系统（SoC）处理器通常将IRQ用作唤醒事件源（因此驱动程序会调用:c:func:`enable_irq_wake`），并且可能能够将DMA完成视为唤醒事件（有时DMA可以保持活动状态，只有CPU和某些外设进入睡眠状态）。这里的一些细节可能是特定于平台的。系统中可能有一些设备在某些睡眠状态下可以完全活跃，例如使用DMA刷新的LCD显示屏，当系统的大部分处于轻度睡眠状态时仍然工作……而且它的帧缓冲区甚至可以在Linux控制处理器保持空闲的同时被DSP或其他非Linux CPU更新。
此外，采取的具体措施可能取决于目标系统状态。一种目标系统状态可能允许某个设备非常活跃；而另一种可能要求该设备进行硬性关闭，并在恢复时重新初始化。
两个不同的目标系统可能会以不同的方式使用相同的设备；上述的LCD在一种产品的“待机”模式下可能是活跃的，但使用相同SOC的不同产品的工作方式可能不同。

### 设备电源管理域

有时候，设备共享参考时钟或其他电源资源。在这种情况下，通常不可能单独将设备置于低功耗状态。相反，可以通过关闭共享电源资源的方式，同时将一组共享电源资源的设备置于低功耗状态。当然，这些设备也需要通过开启共享电源资源的方式一起回到全功率状态。具有这种特性的设备组通常被称为一个电源域。电源域也可以嵌套在另一个电源域内。嵌套的域被称为父域的子域。
对电源域的支持是通过struct device中的:c:member:`pm_domain`字段提供的。这个字段指向一个struct dev_pm_domain类型的对象，定义在:file:`include/linux/pm.h`中，提供了一组类似于子系统级别和设备驱动回调的电源管理回调，用于在所有电源转换期间为给定设备执行操作，而不是执行相应的子系统级别的回调。具体来说，如果设备的:c:member:`pm_domain`指针不为NULL，则由它指向的对象的``->suspend()``回调将代替其子系统（如总线类型）的``->suspend()``回调被执行，并且对于其余的所有回调也是如此。换句话说，如果为给定设备定义了电源管理域回调，则这些回调总是优先于由设备的子系统（如总线类型）提供的回调。
设备电源管理域的支持仅与需要在多种不同的电源域配置中使用相同的设备驱动电源管理回调的平台相关，并希望避免将电源域的支持整合到子系统级别的回调中，例如通过修改平台的总线类型。其他平台无需实现或考虑这一点。
设备可以被定义为IRQ安全，这向PM核心表明它们的运行时PM回调可以在中断禁用的情况下被调用（更多信息请参见Documentation/power/runtime_pm.rst）。如果一个IRQ安全的设备属于一个电源域，则该域的运行时PM将被禁止，除非该域本身也被定义为IRQ安全。然而，只有当域内的所有设备都是IRQ安全的才有意义定义一个电源域为IRQ安全。此外，如果一个IRQ安全的域有一个父域，则父域的运行时PM只有在父域本身也是IRQ安全的情况下才被允许，额外限制是IRQ安全父域的所有子域也必须是IRQ安全的。

### 运行时电源管理

许多设备能够在系统运行时动态地降低功耗。对于不经常使用的设备，此功能很有用，并且可以在运行中的系统上提供显著的节能效果。这些设备通常支持一系列运行时电源状态，这些状态可能包括"关闭"、"睡眠"、"空闲"、"活动"等名称。这些状态在某些情况下（如PCI）可能会受到设备所使用的总线的部分约束，并且通常会包含在系统睡眠状态下也会用到的硬件状态。
在整个系统进行电源状态转换时，由于运行时电源管理，某些设备可能处于低功耗状态。系统的睡眠电源管理回调应能识别这种情况并作出适当的反应，但具体操作取决于子系统的特性。

在某些情况下，决策可能在子系统层面做出，而在其他情况下，则留给设备驱动程序来决定。在某些情况下，在整个系统进行电源状态转换时，可能希望让已挂起的设备保持其挂起状态，但在其他情况下，必须暂时将设备恢复到全功率状态，例如，以便禁用其唤醒系统的能力。这完全取决于硬件和特定子系统及设备驱动的设计。

如果在系统进入睡眠状态的整个系统转换过程中有必要从运行时挂起状态唤醒设备，可以通过在设备的驱动或其所属子系统（例如总线类型或电源管理域）的`->suspend`回调（或者与休眠相关的`->freeze`或`->poweroff`回调）中调用`:c:func:`pm_runtime_resume`来实现。
然而，在调用设备驱动程序的`->suspend`回调（或其他等效回调）*之前*，子系统不应通过它们的`->prepare`和`->suspend`回调（或其他等效回调）改变设备的运行时状态。

.. _smart_suspend_flag:

`DPM_FLAG_SMART_SUSPEND` 驱动标志
-----------------------------------

一些总线类型和电源管理域有策略在它们的`->suspend`回调中提前唤醒所有处于运行时挂起状态的设备，但如果设备的驱动能够处理处于运行时挂起状态的设备，这样做可能并不必要。驱动可以通过在探测阶段设置`:c:member:`power.driver_flags`中的`DPM_FLAG_SMART_SUSPEND`来表明这一点，可以使用`:c:func:`dev_pm_set_driver_flags`辅助函数帮助设置。

设置该标志会使电源管理核心和中间层代码（如总线类型、电源管理域等）跳过驱动提供的`->suspend_late`和`->suspend_noirq`回调，前提是设备在整个系统范围内的挂起过程中保持运行时挂起状态（对于系统休眠的“冻结”和“关闭电源”部分同样适用）。否则，同一个设备可能会连续两次执行相同的驱动回调，这通常来说是不合理的。如果为设备提供了中间层的系统范围内的电源管理回调，那么这些回调负责跳过这些驱动回调；如果没有，则由电源管理核心来跳过它们。子系统回调函数可以通过测试`:c:func:`dev_pm_skip_suspend`辅助函数的返回值来确定是否需要跳过驱动回调。

此外，当设置了`DPM_FLAG_SMART_SUSPEND`时，如果设备在整个之前的“冻结”转换过程中保持运行时挂起状态，则在休眠期间会跳过驱动的`->thaw_noirq`和`->thaw_early`回调。同样地，如果设备存在中间层回调，那么这些回调负责执行这一操作，否则由电源管理核心处理。

`DPM_FLAG_MAY_SKIP_RESUME` 驱动标志
--------------------------------------------

从睡眠状态进行整个系统的恢复时，最简单的方法是将设备置于全功率状态，这一点在文档Documentation/power/runtime_pm.rst中有解释。
关于此特定问题以及设备运行时电源管理框架的更多信息，请参阅该文档。然而，在系统转换到工作状态后，通常希望让设备保持在挂起状态，特别是在之前的系统范围内的挂起（或类似）转换之前这些设备已经处于运行时挂起状态的情况下。

为此，设备驱动程序可以使用`DPM_FLAG_MAY_SKIP_RESUME`标志来指示电源管理核心和中间层代码，允许它们的"noirq"和"early"恢复回调被跳过，如果设备可以在系统范围内的电源管理转换到工作状态后保持在挂起状态。这种情况是否发生通常取决于给定系统挂起-恢复周期前设备的状态以及正在进行的系统转换类型。

特别是，与休眠相关的"解冻"和"恢复"转换完全不受`DPM_FLAG_MAY_SKIP_RESUME`的影响。[所有回调都会在"恢复"过渡中根据标志设置情况发出，并且"解冻"过渡期间是否跳过任何驱动程序回调取决于`DPM_FLAG_SMART_SUSPEND`标志是否设置（见上文）。此外，如果设备的任何子设备将被恢复为全功率状态，则不允许该设备保持在运行时挂起状态。]

`DPM_FLAG_MAY_SKIP_RESUME`标志会与电源管理核心在挂起型转换的"挂起"阶段设置的`power.may_skip_resume`状态位结合考虑。如果驱动程序或中间层有理由阻止其"noirq"和"early"恢复回调在随后的系统恢复转换中被跳过，则应在它的`->suspend`、`->suspend_late`或`->suspend_noirq`回调中清除`power.may_skip_resume`。[请注意，设置了`DPM_FLAG_SMART_SUSPEND`的驱动程序需要在其`->suspend`回调中清除`power.may_skip_resume`，以防其他两个回调被跳过。]

设置`power.may_skip_resume`状态位和`DPM_FLAG_MAY_SKIP_RESUME`标志通常是必要的，但通常不足以使驱动程序的"noirq"和"early"恢复回调被跳过。是否应该跳过这些回调可以通过评估`dev_pm_skip_resume`辅助函数来确定。
如果该函数返回`true`，则应跳过驱动程序的"noirq"和"early"恢复回调，并且电源管理核心会将设备的运行时电源管理状态设置为"挂起"。否则，如果设备在之前的系统范围内挂起转换期间处于运行时挂起状态，并且其`DPM_FLAG_SMART_SUSPEND`已设置，则电源管理核心会将其运行时电源管理状态设置为"活动"。[因此，未设置`DPM_FLAG_SMART_SUSPEND`的驱动程序不应期望其设备的运行时电源管理状态在系统范围内恢复类型转换期间由电源管理核心从"挂起"更改为"活动"。]

如果设备没有设置`DPM_FLAG_MAY_SKIP_RESUME`标志，但设置了`DPM_FLAG_SMART_SUSPEND`，并且其"late"和"noirq"挂起回调被跳过，则其系统范围内的"noirq"和"early"恢复回调（如果存在）将像往常一样被调用，并且电源管理核心会在启用运行时电源管理之前将其运行时电源管理状态设置为"活动"。在这种情况下，驱动程序必须能够应对其系统范围恢复回调紧接着其`->runtime_suspend`回调（没有介入的`->runtime_resume`和系统范围挂起回调）被调用的情况，并且设备的最终状态必须反映"活动"运行时电源管理状态。[请注意，如果驱动程序的`->suspend_late`回调指针指向与其`->runtime_suspend`相同的函数，而其`->resume_early`回调指针指向与其`->runtime_resume`相同的函数，并且驱动程序没有其他系统范围挂起-恢复回调，则这根本不是问题。]

同样，如果设置了设备的`DPM_FLAG_MAY_SKIP_RESUME`标志，则其驱动程序的系统范围"noirq"和"early"恢复回调可能会被跳过，而其"late"和"noirq"挂起回调可能已经被执行（原则上，无论`DPM_FLAG_SMART_SUSPEND`是否设置）。在这种情况下，驱动程序需要能够应对其`->runtime_resume`回调紧接着其"late"和"noirq"挂起回调被调用的情况。[例如，如果驱动程序同时设置了`DPM_FLAG_SMART_SUSPEND`和`DPM_FLAG_MAY_SKIP_RESUME`，并为运行时电源管理和系统范围挂起/恢复使用同一对挂起/恢复回调函数，则这不是问题。]
