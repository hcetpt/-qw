### SPDX 许可证标识符：GPL-2.0

#### 遥控设备
##### 遥控核心
遥控核心实现了接收和发送遥控键盘按键和鼠标事件的基础架构。每当在遥控器上按下某个键时，都会产生一个扫描码。此外，在大多数硬件上，如果按住一个键超过几十毫秒，则会产生重复的按键事件。这与Linux中处理普通键盘或鼠标的内部方式大致相似[1]。因此，遥控核心是基于Linux输入/evdev接口实现的。
1. 

   主要的区别在于，对于键盘事件，键盘控制器会为按键按下和释放各生成一个事件。而对于基于红外线的遥控器，并没有按键释放事件。相反，会生成额外的代码来表示按键的重复。
然而，大多数遥控器使用红外线（IR）来传输信号。由于存在多种用于调制红外信号的协议，因此核心的一个重要部分专门用于调整驱动程序和核心系统以支持发射器所使用的红外协议。
红外传输通过闪烁红外发射器并使用载波完成。载波可以通过红外发射硬件进行开关控制。当载波开启时，称为*脉冲*；当载波关闭时，称为*空隙*。
换句话说，典型的红外传输可以视为一系列*脉冲*和*空隙*事件的序列，每个事件都有一定的持续时间。
载波参数（频率、占空比）以及*脉冲*和*空隙*事件的间隔取决于所使用的协议。
例如，NEC协议使用38kHz的载波频率，并且传输开始于一个9毫秒的*脉冲*和4.5毫秒的*空闲*时间。随后它发送16位扫描码，其中前8位为地址（通常对于特定遥控器来说是一个固定数值），后面跟着8位代码。一位“1”通过560微秒的*脉冲*后跟1690微秒的*空闲*来调制，而一位“0”则通过560微秒的*脉冲*后跟560微秒的*空闲*来调制。
在接收端，一个简单的低通滤波器可以用来将接收到的信号转换为一系列*脉冲/空闲*事件，滤除载波频率。因此，接收机并不关心实际的载波频率参数：它所需要做的就是测量接收到*脉冲/空闲*事件的时间量。
因此，一个简单的红外接收硬件只需向内核提供这些事件的一系列时间序列。此类接收硬件的驱动程序由 ``RC_DRIVER_IR_RAW`` 标识，如 :c:type:`rc_driver_type`\ [#f2]_ 中所定义。其他硬件内置了微控制器来解码*脉冲/空闲*序列并直接返回扫描码给内核。这类接收器由 ``RC_DRIVER_SCANCODE`` 标识。
.. [#f2]

   RC核心也支持仅具有红外发射器而没有接收器的设备。目前，所有此类设备仅工作在原始的TX模式下。这种类型的硬件被标识为 ``RC_DRIVER_IR_RAW_TX``。
当RC核心接收到由 ``RC_DRIVER_IR_RAW`` 类型的红外接收器产生的事件时，需要解码红外协议以获取相应的扫描码。RC核心支持的协议定义在枚举 :c:type:`rc_proto` 中。
当RC代码接收到扫描码（无论是直接通过类型为 ``RC_DRIVER_SCANCODE`` 的驱动程序，还是通过其红外解码器），需要将其转换为Linux输入事件代码。这是通过映射表完成的。
内核支持大多数媒体设备上的映射表。它还支持通过某些sysfs节点在运行时加载表格。更多细节请参见 :ref:`RC用户空间API <Remote_controllers_Intro>`。
遥控器数据结构和函数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. kernel-doc:: include/media/rc-core.h

.. kernel-doc:: include/media/rc-map.h
