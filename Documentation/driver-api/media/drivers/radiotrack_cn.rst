SPDX 许可证标识符: GPL-2.0

Radiotrack 收音机驱动程序
===========================

作者: Stephen M. Benoit <benoits@servicepro.com>

日期:  1996年12月14日

致谢
------------------

本文档基于1994年Gideon le Grange (legrang@active.co.za 或 legrang@cs.sun.ac.za)为Linux编写的'C'代码以及1996年Frans Brinkman (brinkman@esd.nl)的进一步改进。此处报告的结果来自作者在自己的设置上进行的实验，因此结果可能会有所不同... 我不对这些信息的适用性或有效性做出任何保证、声明或保证。作者没有获得AIMS实验室 (http://www.aimslab.com/) 的Radiotrack卡的其他文档。提供此文档希望对想要在非Microsoft Windows环境下使用Radiotrack卡的用户有所帮助。

为什么写这篇文档？
------------------

我有一张Radiotrack卡，是我在使用Microsoft Windows平台时留下的。转到Linux后，我发现Gideon le Grange提供的命令行软件来运行这张卡，并且发现它非常好用！Frans Brinkman制作了一个舒适的X窗口界面，并添加了扫描功能。出于技术探索的兴趣，我想看看调谐器是否可以超出常规FM广播频段进行调谐，以便接收北美电视广播频道中的音频载波，这些频道位于87.0-109.0 MHz范围之外。我没有取得太多成功，但我学到了如何在Linux下编程I/O端口，并对卡片使用的硬件设计有所了解。那么，不多说了，以下是细节。

物理描述
------------------

Radiotrack卡是一张ISA 8位FM收音机卡。射频（RF）输入只是一个天线引线，输出是一个通过微型电话插头可用的功率音频信号。其RF工作频率大致限制在87.0至109.0 MHz（商业FM广播频段）。尽管寄存器可以被编程以请求超出这些限制的频率，但实验结果并不理想。用于解调中频(IF)信号的可变频率振荡器(VFO)可能有一个较小的有效频率范围，在上述提到的极限之外可能会出现循环或削波现象。

通过I/O端口控制卡片
--------------------------------

Radiotrack (基地址) I/O端口可以配置为0x30c或0x20c。似乎只涉及一个I/O端口。I/O端口译码电路似乎非常简单，因为单个I/O端口位直接与收音机卡的具体功能(或块)相匹配。这样，一次写入I/O端口就可以并行改变许多功能。唯一可以通过I/O端口获取的反馈似乎是“立体声检测”位。

I/O端口的位排列如下：

.. code-block:: none

	MSb                                                         LSb
	+------+------+------+--------+--------+-------+---------+--------+
	| VolA | VolB | ???? | Stereo | Radio  | TuneA | TuneB   | Tune   |
	|  (+) |  (-) |      | Detect | Audio  | (bit) | (latch) | Update |
	|      |      |      | Enable | Enable |       |         | Enable |
	+------+------+------+--------+--------+-------+---------+--------+

====  ====  =================================
VolA  VolB  描述
====  ====  =================================
0	 0  音量静音
0	 1  增加音量    (需要一些延迟)
1	 0  减少音量    (需要一些延迟)
1	 1  保持当前音量
====  ====  =================================

====================	===========
Stereo Detect Enable	描述
====================	===========
0			不检测
1			检测
====================	===========

在最后一次端口写入后超过60毫秒读取端口获取结果
0xff ==> 没有检测到立体声,  0xfd ==> 检测到立体声
=============================	=============================
Radio to Audio (路径) Enable	描述
=============================	=============================
0				禁用路径 (静音)
1				启用路径  (产生声音)
=============================	=============================

=====  =====  ==================
TuneA  TuneB  描述
=====  =====  ==================
0	0     "零"位相位1
0	1     "零"位相位2
1	0     "一"位相位1
1	1     "一"位相位2
=====  =====  ==================

24位代码，其中bits = (freq*40) + 10486188
最显著的11位必须为1010 xxxx 0x0才能有效。
最低有效位(LSB)首先进行移位。

=====	======================================
调谐更新使能	描述
=====	======================================
0		调谐器保持不变
1		正在进行调谐器更新
=====	======================================

编程示例
--------------

.. code-block:: none

  默认:        BASE <-- 0xc8  (当前音量，无立体声检测，
				 开启收音，禁用调谐调整)

  卡关闭:	BASE <-- 0x00  (静音，无立体声检测，
				 关闭收音，禁用调谐调整)

  卡开启:	BASE <-- 0x00  (参见“卡关闭”，清除任何未完成的操作)
			BASE <-- 0xc8  (参见“默认”)

  音量减小:    BASE <-- 0x48  (音量减小，无立体声检测，
				 开启收音，禁用调谐调整)
			等待 10 毫秒
			BASE <-- 0xc8  (参见“默认”)

  音量增大:      BASE <-- 0x88  (音量增大，无立体声检测，
				 开启收音，禁用调谐调整)
			等待 10 毫秒
			BASE <-- 0xc8  (参见“默认”)

  检测立体声:   BASE <-- 0xd8  (当前音量，立体声检测，
				 开启收音，禁用调谐调整)
			等待 100 毫秒
			x <-- BASE     (读取 I/O 端口)
			BASE <-- 0xc8  (参见“默认”)

			x=0xff ==> “非立体声”， x=0xfd ==> “检测到立体声”

  设置频率:  code = (freq*40) + 10486188
			对于 code 中的 24 位中的每一位，
			（从最低有效位到最高有效位）：
			要写入一个“零”位，
			BASE <-- 0x01  (静音，无立体声检测，关闭收音，
				 “零”位第一阶段，调谐调整)
			BASE <-- 0x03  (静音，无立体声检测，关闭收音，
				 “零”位第二阶段，调谐调整)
			要写入一个“一”位，
			BASE <-- 0x05  (静音，无立体声检测，关闭收音，
				 “一”位第一阶段，调谐调整)
			BASE <-- 0x07  (静音，无立体声检测，关闭收音，
				 “一”位第二阶段，调谐调整)
