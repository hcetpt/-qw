... SPDX 许可证标识符: GPL-2.0

bttv 驱动程序
=============

bttv 及声音简易指南
----------------------

有许多不同类型的基于 bt848/849/878/879 的板卡可用。
让视频工作通常不是什么大问题，因为这完全由 bt8xx 芯片处理，该芯片在所有板卡上都是通用的。但是，
每张板卡的声音处理方式略有不同。
为了正确地处理采集卡，bttv-cards.c 中有一个 tvcards[] 数组，用于保存每张板卡所需的信息。
只有使用正确的条目，声音才会正常工作（对于视频来说，这往往没有区别）。bttv 驱动程序会向内核日志打印一行信息，指示所使用的卡类型。例如：

    bttv0: 模型: BT848(Hauppauge 旧版) [自动检测]

你应该验证这个信息是否正确。如果不正确，你需要通过 insmod 参数传递正确的板卡类型，例如 `insmod bttv card=2`。
文件 Documentation/admin-guide/media/bttv-cardlist.rst 包含了 card 参数的有效值列表。
如果你的卡未列在此处，你可以检查源代码中是否有新的条目尚未被列出。如果没有适合你卡的条目，你可以尝试现有的某些条目是否适用（仅仅是试错法...）
一些板卡具有额外的处理器用于声音解码和其他功能。例如，Hauppauge 使用了 msp34xx 系列芯片。如果您的板卡有这类芯片，您可能需要加载一个辅助模块如 `msp3400` 才能让声音工作。如果没有适用于你的板卡上的芯片的模块：运气不佳。开始编写一个新的吧。当然，在此之前，你可能想要先查看 video4linux 邮件列表存档...
当然，除非你的扬声器直接连接到采集卡上，否则你需要确保声卡已正确安装。提示：也要检查混音器设置。例如，ALSA 默认情况下会将所有设备静音。
声音的工作原理详解
~~~~~~~~~~~~~~~~~~~~~~~~~

仍然不起作用？看起来需要进行一些驱动程序修改了。
下面是一个 DIY 的描述供你参考。
bt8xx 芯片有 32 个通用引脚，以及控制这些引脚的寄存器。其中一个寄存器是输出使能寄存器 (`BT848_GPIO_OUT_EN`)，它指出了哪些引脚是由 bt848 芯片主动驱动的。另一个是数据寄存器 (`BT848_GPIO_DATA`)，你可以从这里获取/设置这些引脚的状态。它们可以用于输入和输出。
大多数抓卡板供应商使用这些引脚来控制一个外部芯片，该芯片负责音频路由。但每块板都有些不同。
这些引脚也被一些公司用来驱动遥控接收芯片。有些板则使用I2C总线而不是GPIO引脚来连接多路复用芯片。
如上所述，存在一个数组，用于存储已知每块板所需的信息。你基本上需要为你的板创建一个新的条目。重要的字段是这两个：

```cpp
struct tvcard
{
    [...]
    u32 gpiomask;
    u32 audiomux[6]; /* 调谐器, 广播, 外部, 内部, 静音, 立体声 */
};
```

`gpiomask`指定了哪些引脚被用来控制音频多路复用芯片。
输出使能寄存器（`BT848_GPIO_OUT_EN`）中对应的位将被设置，因为这些引脚必须由bt848芯片驱动。
`audiomux[]`数组保存了不同输入的数据值（即调谐器/静音等状态下哪些引脚应为高电平/低电平）。这将被写入数据寄存器（`BT848_GPIO_DATA`），以切换音频多路复用器。
你需要做的是确定`gpiomask`和`audiomux`数组的正确值。如果你有Windows系统，并且已经安装了你的卡的驱动程序，你可以尝试读取Windows驱动程序使用的这些寄存器值。有一个工具可以从http://btwincap.sourceforge.net/download.html下载，可以实现这一功能。
你也可以在Windows应用程序的`*.ini`文件中查找线索。
你可以查看板上的情况，看看哪些GPIO引脚实际上被连接，并开始尝试错误的方法...
从版本0.7.41开始，bttv提供了一些insmod选项，以简化GPIO调试：

| 选项        | 描述                                                         |
|-------------|--------------------------------------------------------------|
| bttv_gpio=0/1 | 开启/关闭GPIO调试信息                                       |
| gpiomask=n   | 设置gpiomask值                                               |
| audiomux=i,j,... | 设置audiomux数组的值                                         |
| audioall=a   | 设置audiomux数组的所有元素的值（单个值对所有数组元素有效，有助于测试特定值的效果） |

使用`bttv_gpio=1`打印的消息如下所示：

```
bttv0: gpio: en=00000027, out=00000024 in=00ffffd8 [audio: off]
```

- `en` = 输出使能寄存器（`BT848_GPIO_OUT_EN`）
- `out` = 数据寄存器（`BT848_GPIO_DATA`）的输出位，即`BT848_GPIO_DATA & BT848_GPIO_OUT_EN`
- `in` = 数据寄存器的输入位，即`BT848_GPIO_DATA & ~BT848_GPIO_OUT_EN`
