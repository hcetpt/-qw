版权所有 2001 Matthew Wilcox

本文档是自由软件；你可以按照由自由软件基金会发布的GNU通用公共许可证的条款重新发布或修改它；无论是第2版许可证，还是（随你选择）任何更新版本。

===============================
独立于总线的设备访问
===============================

:作者: Matthew Wilcox
:作者: Alan Cox

简介
============

Linux提供了一个API，该API抽象了跨所有总线和设备执行I/O的操作，使得设备驱动程序可以独立于总线类型编写。
内存映射I/O
================

获取对设备的访问权
----------------------------

最广泛支持的I/O形式是内存映射I/O。也就是说，CPU地址空间的一部分被解释为不是对内存的访问，而是对设备的访问。一些架构将设备定义在固定的地址上，但大多数架构都有一些发现设备的方法。PCI总线遍历就是一个这样的例子。本文档不涵盖如何接收此类地址，而是假设您已经拥有一个地址。物理地址的类型为unsigned long。

不应直接使用此地址。相反，为了获得适合传递给下面描述的访问函数的地址，您应该调用ioremap()。一个适合访问设备的地址将返回给您。
在您完成使用设备后（例如，在模块的退出例程中），请调用iounmap()以将地址空间返回给内核。大多数架构在每次调用ioremap()时都会分配新的地址空间，并且如果不调用iounmap()，这些地址空间可能会耗尽。
访问设备
--------------------

驱动程序最常使用的接口部分是对设备上内存映射寄存器进行读写操作。Linux提供了读取和写入8位、16位、32位及64位数据量的接口。由于历史原因，这些被称为字节、单词、长整数和四字节访问。
同时支持读取和写入访问；目前没有预取支持。
这些函数分别命名为readb()、readw()、readl()、readq()、readb_relaxed()、readw_relaxed()、readl_relaxed()、readq_relaxed()、writeb()、writew()、writel()和writeq()。
某些设备（如帧缓冲区）希望使用大于8字节的数据传输。对于这类设备，提供了memcpy_toio()、memcpy_fromio()和memset_io()函数。不要在I/O地址上使用memset或memcpy；它们不能保证按顺序复制数据。
读写函数被定义为有序的。也就是说，编译器不允许重新排序I/O序列。当排序可以被编译器优化时，您可以使用`__readb()`及其相关函数来表明较为宽松的排序要求。请谨慎使用。

虽然基本函数在彼此之间被定义为同步且有序的，但设备所在的总线本身可能具有异步性。特别是许多作者被PCI总线异步写入特性所困扰。驱动程序作者必须从同一设备发出读取操作以确保写入操作已经发生，在作者关心的特定情况下。这种属性无法通过API隐藏于驱动程序编写者。在某些情况下，用于刷新设备的读取操作可能会预期失败（例如，如果卡片正在重置）。在这种情况下，应从配置空间进行读取操作，如果卡片没有响应，则该操作将保证软性失败。

下面是一个确保写入操作的效果可见之后再继续执行的例子：

    static inline void
    qla1280_disable_intrs(struct scsi_qla_host *ha)
    {
        struct device_reg *reg;

        reg = ha->iobase;
        /* 禁用RISC和主机中断 */
        WRT_REG_WORD(&reg->ictrl, 0);
        /*
         * 下面的读取操作将确保上面的写入操作
         * 已经被设备接收，在我们退出此函数之前
         */
        RD_REG_WORD(&reg->ictrl);
        ha->flags.ints_enabled = 0;
    }

PCI排序规则也保证了PIO读取响应会在来自同一总线的任何未完成DMA写入之后到达，因为对于某些设备来说，`readb()`调用的结果可能向驱动程序指示DMA事务已完成。然而，在许多情况下，驱动程序可能希望表明下一个`readb()`调用与设备之前执行的任何DMA写入无关。对于这些情况，驱动程序可以使用`readb_relaxed()`，尽管只有部分平台会遵循较宽松的语义。使用宽松读取函数将在支持它的平台上提供显著的性能优势。`qla2xxx`驱动程序提供了如何使用`readX_relaxed()`的示例。在许多情况下，大多数`readX()`调用可以安全地转换为`readX_relaxed()`调用，因为只有少数调用指示或依赖DMA完成。

端口空间访问
=============

端口空间解释
--------------

另一种常见的支持形式是端口空间。这是一个与常规内存地址空间分离的地址范围。访问这些地址通常不如访问内存映射地址那么快，并且它也可能有一个较小的地址空间。

与内存映射I/O不同，无需准备即可访问端口空间。

访问端口空间
-------------

对这个空间的访问是通过一系列允许8位、16位和32位访问的函数提供的；也称为字节、字和长整数。这些函数是`inb()`、`inw()`、`inl()`、`outb()`、`outw()`和`outl()`。

为这些函数提供了一些变体。一些设备要求对其端口的访问速度要减慢。这个功能是通过在函数末尾添加一个`_p`来实现的。

还有一些等同于`memcpy`的函数。`ins()`和`outs()`函数将字节、字或长整数复制到给定的端口。

__iomem指针标记
=================

MMIO地址的数据类型是一个带有`__iomem`限定符的指针，如`void __iomem *reg`。在大多数架构上，它是一个指向虚拟内存地址的常规指针，并可以偏移或解引用，但在可移植代码中，它只能传递给明确操作`__iomem`标记的函数，特别是`ioremap()`和`readl()/writel()`函数。可以使用“稀疏”语义代码检查器来验证这一点是否正确完成。
在大多数架构上，`ioremap()` 为指向物理 MMIO 地址的未缓存虚拟地址创建一个页表项，但有些架构需要为 MMIO 使用特殊指令，而 `__iomem` 指针仅编码物理地址或可偏移的标记，该标记由 `readl()`/`writel()` 解释。
I/O 访问函数之间的差异
=============================

`readq()`、`readl()`、`readw()`、`readb()`、`writeq()`、`writel()`、`writew()`、`writeb()`

  这些是最通用的访问器，提供了对其他 MMIO 访问和 DMA 访问的序列化以及用于访问小端序 PCI 设备和片上外设的固定字节顺序。可移植设备驱动程序通常应使用这些函数来访问 `__iomem` 指针。
请注意，发布写入操作并非严格按自旋锁顺序执行，详情请参阅 `Documentation/driver-api/io_ordering.rst`
`readq_relaxed()`、`readl_relaxed()`、`readw_relaxed()`、`readb_relaxed()`、`writeq_relaxed()`、`writel_relaxed()`、`writew_relaxed()`、`writeb_relaxed()`

  对于需要昂贵屏障来序列化 DMA 的架构，这些“宽松”版本的 MMIO 访问器只彼此间进行序列化，但包含成本较低的屏障操作。设备驱动程序可以在特别关注性能的快速路径中使用这些函数，并附带注释解释为什么特定位置的使用无需额外屏障是安全的。
请参阅 `memory-barriers.txt`，以获取关于非宽松版和宽松版确切排序保证的更详细讨论。
`ioread64()`、`ioread32()`、`ioread16()`、`ioread8()`、`iowrite64()`、`iowrite32()`、`iowrite16()`、`iowrite8()`

  这些是 `readl()`/`writel()` 函数的替代方案，行为几乎相同，但它们也可以对通过 `pci_iomap()` 或 `ioport_map()` 映射 PCI I/O 空间返回的 `__iomem` 标记进行操作。对于需要特殊指令来访问 I/O 端口的架构，这会增加一个小开销，即在 `lib/iomap.c` 中实现的间接函数调用；而对于其他架构，它们仅仅是别名。
`ioread64be()`、`ioread32be()`、`ioread16be()`、`iowrite64be()`、`iowrite32be()`、`iowrite16be()`

  这些函数的行为与 `ioread32()`/`iowrite32()` 家族相同，但是字节顺序相反，用于访问具有大端序 MMIO 寄存器的设备。
可以同时处理大端序和小端序寄存器的设备驱动程序可能需要实现一个自定义包装函数，根据发现的设备选择其中之一。
注意：在某些架构上，传统的 `readl()`/`writel()` 函数假设设备与 CPU 具有相同的字节序，而在运行大端序内核时在 PCI 总线上使用硬件字节反转。
以这种方式使用 `readl()`/`writel()` 的驱动程序通常不具备可移植性，但往往局限于特定的 SoC（系统级芯片）。
以下是一些函数和概念的翻译：

### 函数翻译

`hi_lo_readq()`, `lo_hi_readq()`, `hi_lo_readq_relaxed()`, `lo_hi_readq_relaxed()`,
`ioread64_lo_hi()`, `ioread64_hi_lo()`, `ioread64be_lo_hi()`, `ioread64be_hi_lo()`,
`hi_lo_writeq()`, `lo_hi_writeq()`, `hi_lo_writeq_relaxed()`, `lo_hi_writeq_relaxed()`,
`iowrite64_lo_hi()`, `iowrite64_hi_lo()`, `iowrite64be_lo_hi()`, `iowrite64be_hi_lo()`

一些设备驱动程序包含无法在32位架构上原子访问的64位寄存器，但允许连续两次32位访问。由于特定设备需要先访问哪一半取决于该设备本身，因此为每种64位访问器组合提供了辅助函数以支持低位/高位或高位/低位字序。设备驱动程序必须包含 `<linux/io-64-nonatomic-lo-hi.h>` 或 `<linux/io-64-nonatomic-hi-lo.h>` 文件来获取这些函数定义以及将常规 `readq()` / `writeq()` 重定向到它们的辅助函数，在不提供原生64位访问的架构上。

`__raw_readq()`, `__raw_readl()`, `__raw_readw()`, `__raw_readb()`,
`__raw_writeq()`, `__raw_writel()`, `__raw_writew()`, `__raw_writeb()`

这些是低级别的内存映射I/O访问器，没有屏障或字节顺序变化，并且具有架构特定的行为。通常情况下，访问是原子的，例如，四字节的 `__raw_readl()` 不会被拆分成单个字节读取，但是多个连续的访问可以在总线上合并。在可移植代码中，仅使用这些函数来访问设备总线后面的内存是安全的，而不是MMIO寄存器，因为没有关于其他MMIO访问或自旋锁的排序保证。字节顺序通常与普通内存相同，因此与其它函数不同，这些函数可用于在内核内存和设备内存之间复制数据。

`inl()`, `inw()`, `inb()`, `outl()`, `outw()`, `outb()`

PCI I/O端口资源传统上需要单独的辅助函数，因为在x86架构中它们是使用特殊指令实现的。在大多数其他架构上，这些函数内部被映射为 `readl()` / `writel()` 风格的访问器，通常指向虚拟内存中的固定区域。地址是一个32位整数令牌，用于标识一个端口号。PCI要求I/O端口访问是非发布式的，这意味着 `outb()` 必须在后续代码执行前完成，而正常的 `writeb()` 可能仍在进行中。在正确实现了这一点的架构上，I/O端口访问因此对自旋锁进行了排序。然而许多非x86 PCI主机桥接器实现和CPU架构未能实现在PCI上的非发布式I/O空间，因此它们在这种硬件上可能会被发布。

在某些架构中，I/O端口号空间与 `__iomem` 指针具有一对一的映射关系，但这不建议这样做，设备驱动程序不应依赖于这一点以保持可移植性。同样，PCI基址寄存器中描述的I/O端口号可能与设备驱动程序看到的端口号不符。可移植驱动程序需要从内核提供的资源中读取端口号。

没有直接的64位I/O端口访问器，但可以使用 `pci_iomap()` 结合 `ioread64` / `iowrite64` 来代替。

`inl_p()`, `inw_p()`, `inb_p()`, `outl_p()`, `outw_p()`, `outb_p()`

对于那些需要特定定时的ISA设备，I/O访问器的 `_p` 版本添加了一个小延迟。在没有ISA总线的架构上，这些是正常 `inb` / `outb` 辅助函数的别名。

`readsq`, `readsl`, `readsw`, `readsb`
`writesq`, `writels`, `writesw`, `writesb`
`ioread64_rep`, `ioread32_rep`, `ioread16_rep`, `ioread8_rep`
`iowrite64_rep`, `iowrite32_rep`, `iowrite16_rep`, `iowrite8_rep`
`insl`, `insw`, `insb`, `outsl`, `outsw`, `outsb`

这些是多次访问同一地址的辅助函数，通常用于在内核内存字节流和FIFO缓冲区之间复制数据。与常规的MMIO访问器不同，这些函数在大端模式内核上不会进行字节交换，因此FIFO寄存器中的第一个字节对应于内存缓冲区中的第一个字节，无论架构如何。

### 设备内存映射模式

一些架构支持多种设备内存映射模式。`ioremap_*()` 变体为这些架构特定的模式提供了一个通用抽象层，共享一组语义。
`ioremap()`是最常见的映射类型，适用于典型的设备内存（例如I/O寄存器）。其他模式如果得到架构的支持，则可以提供较弱或较强的保证。从最常见的到最不常见，它们如下：

`ioremap()`
-----------
这是默认模式，适用于大多数内存映射设备，如控制寄存器。使用`ioremap()`映射的内存具有以下特性：

* 非缓存 - 绕过CPU侧的缓存，所有读写操作都直接由设备处理
* 没有推测性操作 - 除非已经执行了相应的指令，否则CPU不会对这部分内存发起读写操作
* 没有重排序 - CPU不得改变对这部分内存映射的访问顺序。在某些架构上，这依赖于`readl_relaxed()`和`writel_relaxed()`中的屏障
* 没有重复 - CPU不得为单个程序指令发出多次读写操作
* 没有写合并 - 每个I/O操作都会导致一次单独的读或写被发送给设备，并且多个写操作不会被合并成更大的写操作。当使用`__raw` I/O访问器或指针解引用时，这一点可能并不总是被强制执行
* 不可执行 - CPU不允许从这部分内存推测执行指令（这可能不用说，但你也不允许跳转到设备内存中执行）

在许多平台和总线上（例如PCI），通过`ioremap()`映射发出的写操作是异步的，这意味着CPU不会等待写操作实际到达目标设备就释放写指令。

在许多平台上，I/O访问必须与访问大小对齐；如果不这样做，可能会导致异常或不可预测的结果。

`ioremap_wc()`
--------------
将I/O内存映射为带有写合并的常规内存。与`ioremap()`不同，

* CPU可能会发起程序实际上未执行的来自设备的读取操作，基本上可以选择读取它想要的任何内容
* 只要结果从程序的角度看是一致的，CPU可以重新排序操作
* 即使程序只发出了一个写操作，CPU也可能多次写入同一位置
* CPU 可能会将多个写操作合并为一个较大的写操作。
这种模式通常用于视频帧缓冲区，可以提高写操作的性能。它也可以用于设备中的其他内存块（例如缓冲区或共享内存），但需要注意的是，在没有显式屏障的情况下，访问并不保证与正常的 `ioremap()` MMIO 寄存器访问有序。
在 PCI 总线上，通常可以在标记为“IORESOURCE_PREFETCH”的 MMIO 区域上安全地使用 `ioremap_wc()`，但在没有该标志的区域上则不可以使用。对于片上设备，没有相应的标志，但是驱动程序可以在已知是安全的设备上使用 `ioremap_wc()`。
`ioremap_wt()`
--------------

以写透缓存的方式将 I/O 内存映射为常规内存。类似于 `ioremap_wc()`，但还具有以下特点：

* CPU 可能会缓存发往设备的写操作和从设备读取的数据，并从该缓存中提供读服务。
这种模式有时用于视频帧缓冲区，其中驱动程序仍期望写操作能及时到达设备（而不是滞留在 CPU 缓存中），但为了效率可以从缓存中提供读服务。然而，如今这种模式很少有用，因为帧缓冲区驱动程序通常只执行写操作，此时使用 `ioremap_wc()` 更高效（因为它不会无谓地污染缓存）。大多数驱动程序不应该使用此模式。
`ioremap_np()`
--------------

类似于 `ioremap()`，但明确请求非发布写语义。在某些架构和总线上，`ioremap()` 映射具有发布写语义，这意味着从 CPU 的角度来看，写操作可能看起来已经“完成”，而实际写入的数据还未到达目标设备。写操作与其他来自同一设备的写操作和读操作之间仍然保持顺序，但由于发布写语义，这并不适用于其他设备。`ioremap_np()` 明确请求非发布语义，这意味着写指令直到设备接收到（并在某种程度上根据平台特性确认）写入数据后才会被视为完成。

这种映射模式主要存在是为了满足那些需要特定映射模式才能正常工作的平台需求。这些平台会在需要 `ioremap_np()` 语义的资源上设置 “IORESOURCE_MEM_NONPOSTED” 标志，可移植驱动程序应使用一种自动在适当情况下选择它的抽象（请参阅下面的“高级 ioremap 抽象”部分）。
裸 `ioremap_np()` 只在某些架构上可用；在其他架构上，它总是返回 NULL。除非驱动程序是特定于平台的，或者从中受益并支持非发布写操作，且在不支持时可以回退到 `ioremap()`，否则驱动程序通常不应使用它。确保发布写完成的通用方法是在写操作后进行一次虚拟读操作，如“访问设备”部分所述，这与所有平台上的 `ioremap()` 都兼容。
`ioremap_np()` 绝对不应用于 PCI 驱动程序。即使在其他方面实现了 `ioremap_np()` 的架构上，PCI 内存空间写操作也始终是发布的。
使用 ioremap_np() 对 PCI BAR 进行映射，在最佳情况下会导致写入延迟的语义，在最坏的情况下则可能导致完全崩溃。
请注意，非延迟写入的语义与 CPU 侧的排序保证是正交的。CPU 可能仍然选择在非延迟写入指令完成前发出其他读取或写入操作。关于 CPU 侧的具体细节，请参阅上一节关于 MMIO 访问函数的内容。
ioremap_uc()
--------------

ioremap_uc() 仅对带有 PAT 扩展的旧版 x86-32 系统和具有略显非常规 ioremap() 行为的 ia64 系统有意义，在其他所有系统中，ioremap_uc() 默认返回 NULL。
可移植驱动应避免使用 ioremap_uc()，而应使用 ioremap() 代替。
ioremap_cache()
------------------

ioremap_cache() 实际上将 I/O 内存映射为常规 RAM。可以使用 CPU 的写回缓存，并且 CPU 可以自由地像处理内存块一样处理设备。这绝不应用于任何有副作用的设备内存，或者不能在读取时返回之前写入数据的设备内存。
它也不应用于实际的 RAM，因为返回的指针是一个 `__iomem` 标记。memremap() 可用于将线性内核内存区域外的常规 RAM 映射到普通指针。
可移植驱动应避免使用 ioremap_cache()。
架构示例
------------------

以下是上述模式如何映射到 ARM64 架构上的内存属性设置：

+------------------------+--------------------------------------------+
| API                    | 内存区域类型和缓存能力                     |
+------------------------+--------------------------------------------+
| ioremap_np()           | Device-nGnRnE                              |
+------------------------+--------------------------------------------+
| ioremap()              | Device-nGnRE                               |
+------------------------+--------------------------------------------+
| ioremap_uc()           | (未实现)                                   |
+------------------------+--------------------------------------------+
| ioremap_wc()           | Normal-Non Cacheable                       |
+------------------------+--------------------------------------------+
| ioremap_wt()           | (未实现；回退到 ioremap)                  |
+------------------------+--------------------------------------------+
| ioremap_cache()        | Normal-Write-Back Cacheable                |
+------------------------+--------------------------------------------+

高级 ioremap 抽象
==================

鼓励驱动程序使用更高级别的 ioremap() 抽象，而不是使用上述原始的 ioremap() 模式。这些 API 可能在特定平台上实施逻辑来自动选择适当的 ioremap 模式，从而允许平台无关的驱动程序在没有特殊案例的情况下工作。在撰写本文时，以下 ioremap() 包装器具有这样的逻辑：

devm_ioremap_resource()

  如果在 `struct resource` 上设置了 `IORESOURCE_MEM_NONPOSTED` 标志，则可以根据平台要求自动选择 ioremap_np() 而不是 ioremap()。当驱动程序的 probe() 函数失败或设备从其驱动程序解绑时，使用 devres 自动取消映射资源。
在 `Documentation/driver-api/driver-model/devres.rst` 中进行了文档说明。

of_address_to_resource()

  对于需要某些总线上进行非延迟写入的平台（参见 device tree 属性 nonposted-mmio 和 posted-mmio），自动设置 `IORESOURCE_MEM_NONPOSTED` 标志。
这些函数用于将设备树中的资源映射到内存中，执行所有必要的转换。`of_iomap()` 自动根据平台需求选择 `ioremap_np()`。

`pci_ioremap_bar()` 和 `pci_ioremap_wc_bar()` 用于映射 PCI 基地址资源描述而无需先提取物理地址。

`pci_iomap()` 和 `pci_iomap_wc()` 类似于 `pci_ioremap_bar()` 和 `pci_ioremap_bar()`，但当与 `ioread32()`、`iowrite32()` 等访问器一起使用时也适用于 I/O 空间。

`pcim_iomap()` 与 `pci_iomap()` 类似，但它使用 devres 在驱动程序的 `probe()` 函数失败或设备从其驱动程序解绑时自动取消映射资源。

这些文档可以在 `Documentation/driver-api/driver-model/devres.rst` 中找到。不使用这些封装可能会导致在对映射 I/O 内存有更严格规定的平台上无法使用驱动程序。

### 系统和 I/O 内存通用访问概述

相关内核文档位于：`include/linux/iosys-map.h`

### 公共函数提供

内部实现细节位于：`arch/x86/include/asm/io.h`
