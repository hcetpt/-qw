### SPDX 许可证标识符：GPL-2.0

=================
控制台驱动程序
=================

Linux 内核有两种通用的控制台驱动程序。第一种类型由内核在启动过程中分配给所有虚拟控制台。这种类型被称为“系统驱动程序”，并且只允许存在一个系统驱动程序。系统驱动程序是持久性的，永远不能卸载，尽管它可能会变得不活跃。
第二种类型必须显式地加载和卸载。本文件中将称之为“模块化驱动程序”。多个模块化驱动程序可以同时共存，每个驱动程序与包括系统驱动程序在内的其他驱动程序共享控制台。然而，模块化驱动程序不能接管已被另一个模块化驱动程序占用的控制台。（例外：调用 do_take_over_console() 的驱动程序无论当前控制台被哪种类型的驱动程序占用，都将成功接管。）它们只能接管被系统驱动程序占用的控制台。同样地，如果模块化驱动程序从控制台释放，系统驱动程序将接管。

从程序员的角度来看，模块化驱动程序必须调用：

- do_take_over_console() - 加载并绑定驱动程序到控制台层
- give_up_console() - 卸载驱动程序；只有当驱动程序完全解绑时此操作才有效

在较新的内核版本中，以下函数也可用：

- do_register_con_driver()
- do_unregister_con_driver()

如果启用了 sysfs，可以检查 /sys/class/vtconsole 的内容。这显示了当前由系统注册的控制台后端，这些后端以 vtcon<n> 的形式命名，其中 <n> 是从 0 到 15 的整数。因此：

```
       ls /sys/class/vtconsole
       .  ..  vtcon0  vtcon1
```

/sys/class/vtconsole 中的每个目录有三个文件：

```
     ls /sys/class/vtconsole/vtcon0
     .  ..  bind  name  uevent
```

这些文件代表什么意思？

1. bind - 这是一个读写文件。读取时显示驱动程序的状态，写入时用于绑定或解绑驱动程序到虚拟控制台。可能的值为：
   
   0
     - 表示驱动程序未绑定，如果通过 echo 操作，将命令驱动程序解绑
   
   1
     - 表示驱动程序已绑定，如果通过 echo 操作，将命令驱动程序绑定

2. name - 只读文件。以如下格式显示驱动程序的名称：

```
	  cat /sys/class/vtconsole/vtcon0/name
	  (S) VGA+
```
   
   其中 '(S)' 代表 (S)ystem 驱动程序，即不能直接命令其绑定或解绑
   
   'VGA+' 是驱动程序的名称

```
	  cat /sys/class/vtconsole/vtcon1/name
	  (M) frame buffer device
```
   
   在这种情况下，'(M)' 代表 (M)odular 驱动程序，可以直接命令其绑定或解绑

3. uevent - 忽略这个文件

当解绑时，首先会解除模块化驱动程序，然后系统驱动程序接管被该驱动程序释放的控制台。而绑定操作则将驱动程序绑定到当前被系统驱动程序占用的控制台上。

**注意 1**：
  绑定和解绑功能必须在 Kconfig 中选择。路径如下：

```
    设备驱动程序 ->
	字符设备 ->
		支持绑定和解绑控制台驱动程序
```

**注意 2**：
  如果任何虚拟控制台处于 KD_GRAPHICS 模式，则绑定或解绑不会成功。设置控制台为 KD_GRAPHICS 模式的应用示例是 X 服务器。

这项功能有多有用？对于控制台驱动程序开发者来说，这是非常有用的。通过从控制台层解绑驱动程序，可以卸载驱动程序、进行修改、重新编译、重新加载并重新绑定驱动程序，而无需重启内核。对于想要在帧缓冲控制台和 VGA 控制台之间切换的普通用户而言，这项功能也使这成为可能。（请注意：有关更多详细信息，请参阅 Documentation/fb 下的 fbcon.txt 文件。）

### 开发者注意事项

do_take_over_console() 现已拆分为：

- do_register_con_driver()
- do_bind_con_driver() - 私有函数

give_up_console() 是 do_unregister_con_driver() 的包装器，且驱动程序必须完全解绑才能使此调用成功。con_is_bound() 将检查驱动程序是否已绑定。

### 控制台驱动程序编写指南

为了使绑定和解绑控制台正确工作，控制台驱动程序必须遵循以下准则：

1. 所有驱动程序（除了系统驱动程序）都必须调用 do_register_con_driver() 或 do_take_over_console()。do_register_con_driver() 仅将驱动程序添加到控制台内部列表中，不会接管控制台。do_take_over_console() 如其名称所示，也会接管（或绑定到）控制台。
2. 在 con->con_init() 中分配的所有资源必须在 con->con_deinit() 中释放。
3. 在 `con->con_startup()` 中分配的所有资源必须在先前绑定的驱动程序变为未绑定时释放。控制台层没有与 `con->con_startup()` 相对应的调用，因此需要由驱动程序自行判断何时可以安全地释放这些资源。在 `con->con_deinit()` 中调用 `con_is_bound()` 会有帮助。如果该调用返回 `false`，则说明可以安全地释放资源。这种平衡是必要的，因为当有重新将驱动程序绑定到控制台的请求时，可能会再次调用 `con->con_startup()`。

4. 当驱动程序退出时，请确保该驱动程序完全解除绑定。如果满足此条件，则驱动程序必须调用 `do_unregister_con_driver()` 或者 `give_up_console()`。

5. 当某些条件使得驱动程序无法处理控制台请求时，也可以调用 `do_unregister_con_driver()`。例如，带有帧缓冲区的控制台突然失去了所有驱动程序的情况下就可能发生这种情况。

当前版本的控制台驱动程序应该仍然能够正常工作，但是它们的绑定和解绑可能会导致问题。通过进行最小限度的修复，可以使这些驱动程序正确运行。

Antonino Daplas <adaplas@pol.net>
