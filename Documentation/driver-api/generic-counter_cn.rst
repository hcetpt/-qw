### SPDX 许可证标识符：GPL-2.0

=========================
通用计数器接口
=========================

#### 引言

计数设备在各种行业中普遍存在。这些设备的普遍性要求有一个共同的接口和交互标准。这个驱动程序API试图解决现有计数设备驱动程序中重复代码的问题，通过引入一个通用计数器接口来实现。通用计数器接口使驱动程序能够支持并公开计数设备中存在的常用组件和功能。

#### 理论

尽管计数设备的设计差异很大，但无论是四相编码计数器还是总计数器，所有的计数设备都包含一组核心组件。这一组所有计数设备共有的核心组件构成了通用计数器接口的本质。计数器有三个核心组成部分：

* **信号**：
  要被计数器评估的数据流。
* **突触**：
  将一个信号及其评估触发器与计数值关联起来。
* **计数**：
  连接的突触效果的累积。
**信号**
---
信号代表一个数据流。这是由计数器评估以确定计数数据的输入数据；例如，旋转编码器的四相信号输出线。并非所有计数设备都为用户提供访问信号数据的功能，因此对于驱动程序来说，提供信号数据是可选的。
当信号数据可供用户访问时，通用计数器接口提供了以下可用的信号值：

* **SIGNAL_LOW**：
  信号线处于低电平状态。
* **SIGNAL_HIGH**：
  信号线处于高电平状态。
一个信号可以与一个或多个计数值相关联。
### 突触 (SYNAPSE)

突触表示信号与计数值之间的关联。信号数据会影响相应的计数值数据，而突触则代表这种关系。

**突触的操作模式** 指定了触发相应计数值计算更新的信号数据条件。通用计数器接口提供了以下可用的操作模式：

* **无操作**：
  - 信号不会触发计数函数。在脉冲方向计数函数模式下，该信号被视为方向信号。
* **上升沿**：
  - 从低状态转换到高状态。
* **下降沿**：
  - 从高状态转换到低状态。
* **双沿**：
  - 任何状态转换。

一个计数器定义为一组输入信号与通过评估相关输入信号状态来生成的计数值数据的集合，这些评估由各自的计数函数定义。在通用计数器接口的上下文中，一个计数器由若干计数值构成，每个计数值都与一组信号相关联，它们各自的突触实例表示了与这些计数值相关的计数函数更新条件。

一个突触关联了一个信号和一个计数值。

### 计数值 (COUNT)

计数值表示连接的突触效果的累积；即一组信号的计数值数据。通用计数器接口将计数值表示为自然数。

计数值有一个计数函数模式，表示计数值更新的行为。通用计数器接口提供了以下可用的计数函数模式：

* **增加**：
  - 累积计数被递增。
* **减少**：
  - 累积计数被递减。
* 脉冲方向：
  当信号A出现上升沿时更新相应的计数。信号B的输入电平决定了方向。
* 正交编码：
  通过评估一对正交编码信号来确定位置和方向。以下提供了几种正交模式：

  - x1 A：
    如果方向为正向，那么在正交对信号A上的上升沿会更新相应的计数；如果方向为反向，则在正交对信号A上的下降沿会更新相应的计数。正交编码确定了方向。
  - x1 B：
    如果方向为正向，那么在正交对信号B上的上升沿会更新相应的计数；如果方向为反向，则在正交对信号B上的下降沿会更新相应的计数。正交编码确定了方向。
  - x2 A：
    在正交对信号A上的任何状态转换都会更新相应的计数。正交编码确定了方向。
  - x2 B：
    在正交对信号B上的任何状态转换都会更新相应的计数。正交编码确定了方向。
  - x4：
    在任一正交对信号上的任何状态转换都会更新相应的计数。正交编码确定了方向。
一个计数（Count）可以关联一组或多个突触（Synapses）。

### 概念模型

最简单的计数设备可以通过一个计数（Count）与一个信号（Signal）通过一个突触（Synapse）关联来表示。例如，考虑一个仅仅累计源输入线上上升沿次数的计数设备： 

```
                计数                突触           信号
                -----                -------        ------
        +---------------------+
        | 数据: 计数         |    上升沿      ________
        | 功能: 增加          |  <-------------  / 源 \
        |                     |                  ____________
        +---------------------+
```

在这个例子中，信号是一条带有脉冲电压的源输入线，而计数是一个持续累加的计数值，它被反复递增。信号通过一个突触与相应的计数关联。增加功能由突触指定的信号数据条件触发——在这个案例中是在电压输入线上的上升沿条件。简而言之，计数设备的存在及其行为准确地由相应的计数、信号以及突触组件表示：一个上升沿条件触发了一个累加计数数据的增加功能。
一个计数器设备并不局限于单一的信号；实际上，理论上，即使是单个计数也可能与多个信号相关联。例如，一个正交编码器计数器设备可以根据两条输入线的状态跟踪位置：

                   计数                 突触     信号
                   -----                 -------     ------
        +-------------------------+
        | 数据: 位置             |    双边沿     ___
        | 功能: 正交x4           |  <------------   / A \
        |                         |                 _______
        |                         |
        |                         |    双边沿     ___
        |                         |  <------------   / B \
        |                         |                 _______
        +-------------------------+

在这个例子中，两个信号（正交编码器线路A和B）与单个计数相关联：无论是A还是B的上升沿或下降沿都会触发“正交x4”功能，该功能确定移动方向并更新相应的位置数据。“正交x4”功能很可能是在正交编码器计数器设备的硬件中实现的；计数、信号和突触仅仅代表了这种硬件行为和功能。

与同一计数相关的信号可以有不同的突触动作模式条件。例如，在非正交脉冲-方向模式下运行的正交编码器计数器设备可能有一个输入线路专用于运动，另一个输入线路专用于方向：

                   计数                   突触      信号
                   -----                   -------      ------
        +---------------------------+
        | 数据: 位置               |    上升沿     ___
        | 功能: 脉冲-方向         |  <-------------   / A \ （运动）
        |                           |                  _______
        |                           |
        |                           |       无         ___
        |                           |  <-------------   / B \ （方向）
        |                           |                  _______
        +---------------------------+

只有信号A触发“脉冲-方向”更新功能，但为了确定方向以便正确更新位置数据，信号B的瞬时状态仍然是必需的。最终，两个信号都通过两个各自的突触与相同的计数相关联，但只有一个突触具有活动的动作模式条件，触发相应的计数功能，而另一个则保留为“无”条件动作模式，以表明其相应的信号可供状态评估，尽管它不触发任何操作。

请注意，信号、突触和计数是抽象表示，并不需要与它们各自的物理来源紧密相关。这允许计数器用户摆脱物理组件的细节（例如输入线路是否为差分或单端），而是专注于数据和过程所代表的核心概念（例如从正交编码数据解释出的位置）。

驱动API
========

驱动程序作者可以通过包含`include/linux/counter.h`头文件在其代码中利用通用计数器接口。此头文件提供了几个核心的数据结构、函数原型和宏来定义计数器设备。

.. kernel-doc:: include/linux/counter.h
   :internal:

.. kernel-doc:: drivers/counter/counter-core.c
   :export:

.. kernel-doc:: drivers/counter/counter-chrdev.c
   :export:

驱动实现
========

为了支持一个计数器设备，驱动程序必须首先通过`counter_signal`结构分配可用的计数器信号。这些信号应存储为数组，并在计数器注册到系统之前设置为已分配的`counter_device`结构的`signals`数组成员。
计数器计数可通过`counter_count`结构进行分配，相应的计数器信号关联（突触）可通过`counter_synapse`结构建立。相关的`counter_synapse`结构存储为数组，并设置为相应`counter_count`结构的`synapses`数组成员。这些`counter_count`结构在计数器注册到系统之前设置为已分配的`counter_device`结构的`counts`数组成员。
为了与设备通信，驱动程序回调必须提供给`counter_device`结构：读取和写入各种信号和计数，以及为各种突触和计数分别设置和获取“动作模式”和“功能模式”。

使用`counter_alloc()`分配`counter_device`结构，然后通过将它传递给`counter_add()`函数将其注册到系统，通过传递给`counter_unregister`函数将其注销。存在设备管理变体的这些函数：`devm_counter_alloc()`和`devm_counter_add()`。
`struct counter_comp`结构用于定义信号、突触和计数的计数器扩展。
“type”成员指定了由这个扩展处理的高级数据类型（例如BOOL、COUNT_DIRECTION等）。然后，“`*_read`”和“`*_write`”成员可由计数器设备驱动程序通过回调设置，以使用本机C数据类型（即u8、u64等）处理这些数据。
提供了诸如 `COUNTER_COMP_COUNT_U64` 这样的便捷宏供驱动程序作者使用。特别是，驱动程序作者被期望使用提供的宏来处理标准的计数器子系统属性，以保持用户空间的一致接口。例如，一个计数器设备驱动程序可以这样定义几个标准属性：

        struct counter_comp count_ext[] = {
                COUNTER_COMP_DIRECTION(count_direction_read),
                COUNTER_COMP_ENABLE(count_enable_read, count_enable_write),
                COUNTER_COMP_CEILING(count_ceiling_read, count_ceiling_write),
        };

这使得查看、添加和修改此驱动程序支持的属性（如“方向”、“启用”和“上限”）变得简单，并且在维护这段代码时不会迷失在结构体的大括号之中。回调函数必须匹配相应组件或扩展所预期的函数类型。这些函数类型定义在 `struct counter_comp` 结构体中作为 “`*_read`” 和 “`*_write`” 的联合成员。
上述例子中提到的扩展的对应回调原型如下：

        int count_direction_read(struct counter_device *counter,
                                 struct counter_count *count,
                                 enum counter_count_direction *direction);
        int count_enable_read(struct counter_device *counter,
                              struct counter_count *count, u8 *enable);
        int count_enable_write(struct counter_device *counter,
                               struct counter_count *count, u8 enable);
        int count_ceiling_read(struct counter_device *counter,
                               struct counter_count *count, u64 *ceiling);
        int count_ceiling_write(struct counter_device *counter,
                                struct counter_count *count, u64 ceiling);

确定要创建哪种类型的扩展取决于范围：
* **信号扩展** 是暴露特定于信号的信息/控制的属性。这些类型的属性将存在于信号目录下的 sysfs 中。
例如，如果你有一个信号的反转功能，你可以有一个名为“invert”的信号扩展来切换该功能：
  /sys/bus/counter/devices/counterX/signalY/invert
* **计数扩展** 是暴露特定于计数的信息/控制的属性。这些类型的属性将存在于计数目录下的 sysfs 中。
例如，如果你想暂停/恢复更新计数，你可以有一个名为“enable”的计数扩展来切换这种行为：
  /sys/bus/counter/devices/counterX/countY/enable
* **设备扩展** 是暴露非特定于特定计数或信号的信息/控制的属性。这是你放置全局特性或其他杂项功能的地方。
例如，如果你的设备有一个过温传感器，你可以通过名为“error_overtemp”的设备扩展来报告芯片过热：
  /sys/bus/counter/devices/counterX/error_overtemp

子系统架构
===========

计数器驱动程序以原生数据类型（如 `u8`、`u64` 等）传递和接收数据，而共享的计数器模块负责处理与 sysfs 接口之间的转换。这保证了所有计数器驱动程序的标准用户空间接口，并通过通用的设备驱动程序 ABI 启用了通用计数器字符设备接口。
一个计数值如何从计数器驱动程序传递下来的高度概述如下所示。首先，驱动程序回调被注册到计数器核心组件，以便由计数器用户空间接口组件使用：

        驱动程序回调注册：
        ~~~~~~~~~~~~~~~~~~~~~
                        +----------------------------+
                        | 计数器设备驱动程序      |
                        +----------------------------+
                        | 处理来自设备的数据 |
                        +----------------------------+
                                |
                         -------------------
                        / 驱动程序回调 /
                        -------------------
                                |
                                V
                        +----------------------+
                        | 计数器核心         |
                        +----------------------+
                        | 将设备驱动程序路由 |
                        | 回调到用户空间接口 |
                        +----------------------+
                                |
                         -------------------
                        / 驱动程序回调 /
                        -------------------
                                |
                +---------------+---------------+
                |                               |
                V                               V
        +--------------------+          +---------------------+
        | 计数器 sysfs      |          | 计数器 chrdev      |
        +--------------------+          +---------------------+
        | 转换为标准计数器   |          | 转换为标准计数器   |
        | sysfs 输出       |          | 字符设备           |
        +--------------------+          +---------------------+

之后，数据可以直接在计数器设备驱动程序和计数器用户空间接口之间传输：

        计数数据请求：
        ~~~~~~~~~~~~~~~
                         ----------------------
                        / 计数器设备       \
                        +----------------------+
                        | 计数寄存器: 0x28 |
                        +----------------------+
                                |
                         -----------------
                        / 原始计数数据 /
                        -----------------
                                |
                                V
                        +----------------------------+
                        | 计数器设备驱动程序      |
                        +----------------------------+
                        | 处理来自设备的数据 |
                        |-----------------------|
                        | 类型: u64              |
                        | 值: 42                  |
                        +----------------------------+
                                |
                         ----------
                        / u64     /
                        ----------
                                |
                +---------------+---------------+
                |                               |
                V                               V
        +--------------------+          +---------------------+
        | 计数器 sysfs      |          | 计数器 chrdev      |
        +--------------------+          +---------------------+
        | 转换为标准计数器   |          | 转换为标准计数器   |
        | sysfs 输出       |          | 字符设备           |
        |--------------------|          |---------------------|
        | 类型: const char * |          | 类型: u64           |
        | 值: "42"        |          | 值: 42              |
        +--------------------+          +---------------------+
                |                               |
         ---------------                 -----------------------
        / const char * /                / struct counter_event /
        ---------------                 -----------------------
                |                               |
                |                               V
                |                       +-----------+
                |                       | 读取      |
                |                       +-----------+
                |                       \ 计数: 42 /
                |                        -----------
                |
                V
        +--------------------------------------------------+
        | `/sys/bus/counter/devices/counterX/countY/count` |
        +--------------------------------------------------+
        \ 计数: "42"                                      /
         --------------------------------------------------

涉及的主要组件有四个：

计数器设备驱动程序
---------------------
与硬件设备通信以读写数据；例如用于四分之一编码器、定时器等的计数器驱动程序。
计数器核心
------------
将计数器设备驱动程序注册到系统中，以便在用户空间交互期间调用相应的回调函数。
计数器 sysfs
-------------
将计数器数据转换为标准的计数器 sysfs 接口格式及反向转换。
请参阅 `Documentation/ABI/testing/sysfs-bus-counter` 文件，
获取可用的通用计数器接口 sysfs 属性的详细信息。
计数器字符设备
--------------
将计数器事件转换为标准计数器字符设备；数据通过标准字符设备读取调用传输，而计数器事件则通过 ioctl 调用配置。
sysfs 接口
===========
通用计数器接口会生成多个 sysfs 属性，这些属性位于 `/sys/bus/counter/devices/counterX` 目录下，其中 `X` 是相应的计数器设备 ID。请参阅 `Documentation/ABI/testing/sysfs-bus-counter` 获取每个通用计数器接口 sysfs 属性的详细信息。
通过这些 sysfs 属性，程序和脚本可以与相应计数器设备的通用计数器范例中的计数、信号和突触进行交互。
计数器字符设备
===============
计数器字符设备节点在 `/dev` 目录下创建为 `counterX`，其中 `X` 是相应的计数器设备 ID。
标准计数器数据类型的定义通过用户空间文件 `include/uapi/linux/counter.h` 暴露。
计数器事件
-----------
计数器设备驱动程序可以通过使用 `counter_push_event` 函数来支持计数器事件：
```c
void counter_push_event(struct counter_device *const counter, const u8 event,
                                const u8 channel);
```
事件 ID 由参数 `event` 指定；事件通道 ID 由参数 `channel` 指定。当此函数被调用时，将收集与该事件相关的计数器数据，并为每个数据生成一个 `struct counter_event` 并推送到用户空间。
用户可以通过配置计数器事件来报告感兴趣的多种计数器数据。这可以理解为一系列要执行的计数器组件读取调用列表。例如：

| COUNTER_EVENT_OVERFLOW | COUNTER_EVENT_INDEX |
|------------------------|---------------------|
| Channel 0              | Channel 0           |
| * Count 0              | * Signal 0          |
| * Count 1              | * Signal 0 Extension 0 |
| * Signal 3             | * Extension 4       |
| * Count 4 Extension 2  |                     |
| * Signal 5 Extension 0 | Channel 1           |
|                        | * Signal 4          |
|                        | * Signal 4 Extension 0 |
|                        | * Count 7           |

例如，当调用 `counter_push_event(counter, COUNTER_EVENT_INDEX, 1)` 时，它会遍历 `COUNTER_EVENT_INDEX` 事件通道 1 的列表，并执行 Signal 4、Signal 4 Extension 0 和 Count 7 的读取回调——返回的每个数据作为 `struct counter_event` 被推送到 kfifo 中，用户空间可以通过对相应的字符设备节点进行标准读取操作来检索这些数据。
用户空间
--------
用户空间应用程序可以通过 ioctl 操作在计数器字符设备节点上配置计数器事件。以下 ioctl 代码得到 `linux/counter.h` 用户空间头文件的支持：

* :c:macro:`COUNTER_ADD_WATCH_IOCTL`

* :c:macro:`COUNTER_ENABLE_EVENTS_IOCTL`

* :c:macro:`COUNTER_DISABLE_EVENTS_IOCTL`

为了配置事件以收集计数器数据，用户首先需要填充一个 `struct counter_watch` 结构体，其中包含相关事件 ID、事件通道 ID 以及要从中读取所需计数器组件的信息，然后通过 `COUNTER_ADD_WATCH_IOCTL` ioctl 命令传递它。
请注意，即使不收集计数器数据也可以监视事件，只需将 `component.type` 成员设置为 `COUNTER_COMPONENT_NONE`。在这种配置下，计数器字符设备只会为相应的 `struct counter_event` 元素填充事件时间戳，并忽略组件值。
`COUNTER_ADD_WATCH_IOCTL`命令将会缓存这些计数器监视。当准备就绪后，可以使用`COUNTER_ENABLE_EVENTS_IOCTL` ioctl命令来激活这些计数器监视。
用户空间的应用程序随后可以对计数器字符设备节点执行`read`操作（可选地先调用`poll`），以获取包含所需数据的`struct counter_event`元素。
