默认情况下，驱动程序核心仅强制执行设备层次结构中基于父/子关系的设备之间的依赖关系：在挂起、恢复或关闭系统时，根据这种关系对设备进行排序，即子设备总是在其父设备之前被挂起，而父设备总是在其子设备之前恢复。有时需要表示超出纯粹父子关系的设备依赖关系（例如，在兄弟设备之间），并让驱动程序核心自动处理这些依赖关系。
其次，默认情况下，驱动程序核心不强制执行任何驱动程序存在依赖关系，即一个设备必须绑定到驱动程序之后另一个设备才能探测或正常工作。
这两种依赖类型经常同时出现，因此一个设备既依赖于另一个设备的驱动程序存在，也依赖于挂起/恢复和关机顺序。
设备链接允许在驱动程序核心中表示此类依赖关系。在其标准形式或*管理*形式下，设备链接结合了*两种*依赖类型：它保证了“供应商”设备与其“消费者”设备之间的正确挂起/恢复和关机顺序，并且保证了供应商上的驱动程序存在。消费者设备在供应商绑定到驱动程序之前不会被探测，并且在供应商解绑之前先解绑。
当供应商上的驱动程序存在无关紧要，只需要正确的挂起/恢复和关机顺序时，可以简单地使用``DL_FLAG_STATELESS``标志设置设备链接。换句话说，强制执行供应商上的驱动程序存在是可选的。
另一个可选功能是运行时电源管理（PM）集成：通过在添加设备链接时设置``DL_FLAG_PM_RUNTIME``标志，指示PM核心在消费者运行时恢复期间唤醒供应商并保持其活动状态。
使用
=====

可以添加设备链接的最早时间点是在调用供应商的 :c:func:`device_add()` 和消费者的 :c:func:`device_initialize()` 之后。
可以在稍后的时间点合法地添加它们，但必须注意系统保持一致状态：例如，不能在挂起/恢复转换过程中添加设备链接，因此可以通过 :c:func:`lock_system_sleep()` 阻止此类转换的开始，或者从确保不会与挂起/恢复转换并行运行的函数（如设备 ``->probe`` 回调或启动时PCI异常）中添加设备链接。
另一个不一致状态的例子是，表示驱动程序存在依赖关系的设备链接，在供应商尚未开始探测时从消费者的 `->probe` 回调中添加：如果驱动程序核心更早知道该设备链接，它根本就不会探测消费者。因此，责任在于消费者在添加链接后检查供应商是否存在，并在不存在的情况下推迟探测。【注意，在供应商仍在探测时从消费者的 `->probe` 回调创建链接是有效的，但消费者必须知道在链接创建时供应商已经是功能性的（例如，如果消费者刚刚获取了一些资源，而这些资源如果没有供应商的功能性则无法获得）。】

如果带有 `DL_FLAG_STATELESS` 标志（即无状态设备链接）的设备链接在供应商或消费者驱动程序的 `->probe` 回调中添加，通常会在其 `->remove` 回调中删除以保持对称性。这样，如果驱动程序被编译为模块，则在加载模块时会添加设备链接，并在卸载时有序地删除。适用于设备链接添加的限制（例如排除并行挂起/恢复转换）同样适用于删除。由驱动程序核心管理的设备链接将自动由其删除。

在设备链接添加时可以指定多个标志，其中两个已在上面提到：`DL_FLAG_STATELESS` 表示不需要驱动程序存在依赖关系（但仅需要正确的挂起/恢复和关机顺序），`DL_FLAG_PM_RUNTIME` 表示希望集成运行时电源管理。

另外两个标志特别针对在消费者的 `->probe` 回调中添加设备链接的情况：`DL_FLAG_RPM_ACTIVE` 可以指定来运行时恢复供应商并在消费者运行时挂起前阻止供应商挂起。`DL_FLAG_AUTOREMOVE_CONSUMER` 会在消费者探测失败或稍后解除绑定时自动清除设备链接。

类似地，当设备链接在供应商的 `->probe` 回调中添加时，`DL_FLAG_AUTOREMOVE_SUPPLIER` 会在供应商探测失败或稍后解除绑定时自动清除设备链接。

如果既没有设置 `DL_FLAG_AUTOREMOVE_CONSUMER` 也没有设置 `DL_FLAG_AUTOREMOVE_SUPPLIER`，可以使用 `DL_FLAG_AUTOPROBE_CONSUMER` 请求驱动程序核心在供应商设备已绑定驱动程序后自动探测链接上的消费者驱动程序的驱动程序。

但是，请注意任何 `DL_FLAG_AUTOREMOVE_CONSUMER`、`DL_FLAG_AUTOREMOVE_SUPPLIER` 或 `DL_FLAG_AUTOPROBE_CONSUMER` 与 `DL_FLAG_STATELESS` 的组合都是无效的且不能使用。

### 限制

驱动程序作者应意识到对于受管理的设备链接（即在添加链接时不指定 `DL_FLAG_STATELESS`）的驱动程序存在依赖关系可能会无限期地推迟消费者的探测。这可能成为问题，如果要求消费者在达到某个初始化回调级别之前完成探测。更糟的是，如果供应商驱动程序被禁用或缺失，消费者将永远不会被探测。

此外，无法直接删除受管理的设备链接。它们由驱动程序核心根据 `DL_FLAG_AUTOREMOVE_CONSUMER` 和 `DL_FLAG_AUTOREMOVE_SUPPLIER` 标志在不再必要时删除。然而，无状态设备链接（即设置了 `DL_FLAG_STATELESS` 的设备链接）预期由调用 `device_link_add()` 添加它们的实体通过 `device_link_del()` 或 `device_link_remove()` 删除。

向 `device_link_add()` 传递 `DL_FLAG_RPM_ACTIVE` 和 `DL_FLAG_STATELESS` 可能会导致在后续调用 `device_link_del()` 或 `device_link_remove()` 删除由其返回的设备链接之后，供应商设备的 PM 运行时使用计数器保持非零。这发生在连续两次调用 `device_link_add()` 对于相同的消费者-供应商对但未在这两次调用之间删除链接的情况下，此时允许供应商的 PM 运行时使用计数器下降尝试删除链接可能导致它在消费者仍处于 PM 运行时活动状态时被挂起，这种情况需要避免。【要解决此限制，只需让消费者至少运行时挂起一次，或在禁用 PM 运行时的情况下为它调用 `pm_runtime_set_suspended()`，在 `device_link_add()` 和 `device_link_del()` 或 `device_link_remove()` 调用之间即可。】

有时驱动程序依赖于可选资源。当这些资源不存在时，它们能够以降级模式（减少的功能集或性能）运行。一个例子是一个 SPI 控制器，它可以使用 DMA 引擎或工作在 PIO 模式下。控制器可以在探测时确定可选资源的存在，但在不存在的情况下，没有办法知道这些资源是否会在不久的将来（由于供应商驱动程序的探测）变得可用或永远不可用。因此，无法确定是否应该推迟探测。有可能在探测后通知驱动程序可选资源变得可用，但这对驱动程序来说成本很高，因为基于此类资源的可用性在运行时切换操作模式要比基于探测推迟机制复杂得多。无论如何，可选资源超出了设备链接的范围。
### 示例

* 一个内存管理单元（MMU）设备与一个总线主控器设备并存，两者位于同一电源域中。MMU 实现了针对总线主控器设备的直接内存访问（DMA）地址转换，并且应当在总线主控器设备处于活动状态时始终运行并保持活跃。总线主控器设备的驱动程序不应在 MMU 绑定之前绑定。为了实现这一点，从总线主控器设备（消费者）到 MMU 设备（供应商）添加了一个带有运行时电源管理集成的设备链接。就运行时电源管理而言，这与 MMU 是主控设备的父设备的效果相同。由于这两个设备共享同一个电源域，通常会建议使用 `struct dev_pm_domain` 或 `struct generic_pm_domain`，但这些并不是偶然共享一个电源开关的独立设备，而是 MMU 设备为总线主控器服务，在没有总线主控器的情况下它是无用的。设备链接在设备之间创建了一个合成的层次关系，因此更适合这种情况。
* 雷电主机控制器包含多个 PCIe 热插拔端口和一个 NHI 设备来管理 PCIe 开关。从系统睡眠恢复时，NHI 设备需要重新建立到已连接设备的 PCI 隧道，然后热插拔端口才能恢复。如果热插拔端口是 NHI 的子设备，这种恢复顺序将自动由电源管理核心强制执行，但不幸的是它们是同级设备。解决方法是在热插拔端口（消费者）与 NHI 设备（供应商）之间添加设备链接。在这种情况下，不需要驱动程序存在依赖性。
* 在混合图形笔记本电脑中的独立 GPU 经常配备一个 HDA 控制器用于 HDMI/DP 音频。在设备层次结构中，HDA 控制器是 VGA 设备的同级，然而它们共享同一个电源域，并且 HDA 控制器仅在 HDMI/DP 显示器连接到 VGA 设备时才需要。从 HDA 控制器（消费者）到 VGA 设备（供应商）的设备链接恰当地表示了这种关系。
* ACPI 允许通过 _DEP 对象定义设备启动顺序。一个典型的例子是当一个设备上的 ACPI 电源管理方法通过 I²C 访问实现，并且需要特定的 I²C 控制器存在并且正常工作，以使该设备的电源管理能够正常运作。
* 在某些片上系统（SoC）中，显示、视频编解码器和视频处理 IP 核心对透明内存访问 IP 核心存在功能依赖，后者负责处理突发访问和压缩/解压缩。

### 替代方案

* 可以使用 `struct dev_pm_domain` 来覆盖总线、类或设备类型的回调函数。它适用于共享单个开/关开关的设备，但是它不保证特定的挂起/恢复顺序，这需要单独实现。它本身也不能跟踪涉及设备的运行时电源管理状态，并且只有在所有设备都处于运行时挂起状态时才关闭电源开关。此外，它不能用来强制执行特定的关机顺序或驱动程序存在依赖性。
* `struct generic_pm_domain` 比设备链接更复杂，也不允许进行关机排序或驱动程序存在依赖性。它也不能在 ACPI 系统上使用。
### 实现
设备层次结构，顾名思义是一棵树，在添加了设备链接后变成了一个有向无环图。这些设备在挂起/恢复时的顺序由`dpm_list`确定；在关机时则由`devices_kset`确定。如果没有设备链接存在，这两个列表就是设备树的一个扁平化、一维表示，使得每个设备都位于其所有祖先之后。这是通过从上到下遍历ACPI命名空间或OpenFirmware设备树，并在发现设备时将它们添加到列表中来实现的。
一旦添加了设备链接，列表需要满足额外的约束条件：一个设备必须位于其所有供应商（递归地）之后。为了确保这一点，在添加设备链接时，消费者及其整个子图（消费者的全部子级和下游消费者）被移动到列表的末尾。（从`device_link_add()`调用`device_reorder_to_tail()`函数。）

为了防止在图中引入依赖循环，在添加设备链接时会验证供应商不依赖于消费者或消费者的任何子级或下游消费者（从`device_link_add()`调用`device_is_dependent()`函数）。如果违反了这个约束条件，`device_link_add()`函数将返回`NULL`，并记录一条`WARNING`警告。
值得注意的是，这也阻止了从父设备到子设备的设备链接的添加。但是相反方向是允许的，即从子设备到父设备的设备链接。由于驱动程序核心已经保证了父设备与子设备之间正确的挂起/恢复和关机顺序，因此只有当需要在基础上添加驱动程序存在依赖时，这种设备链接才有意义。在这种情况下，驱动程序作者应该仔细权衡是否设备链接是解决问题的最佳工具。可能更合适的方法是简单地使用延迟探测或者添加一个设备标志，使父驱动程序在子驱动程序之前进行探测。
### 状态机

```plaintext
.. kernel-doc:: include/linux/device.h
   :functions: device_link_state

                 .=============================
|                             |
                 v                             |
 DORMANT <=> AVAILABLE <=> CONSUMER_PROBE => ACTIVE
    ^                                          |
    |                                          |
    '============ SUPPLIER_UNBIND <============'
```

* 设备链接的初始状态由`device_link_add()`根据供应商和消费者上的驱动程序存在情况自动确定。如果在任何设备被探测之前创建链接，则设置为`DL_STATE_DORMANT`。
* 当供应商设备绑定到驱动程序时，其与消费者的链接进入`DL_STATE_AVAILABLE`状态。
* 在探测消费者设备之前，会通过检查消费者设备不在`wait_for_suppliers`列表中以及检查与供应商的连接处于`DL_STATE_AVAILABLE`状态来验证供应商驱动程序的存在。
  * 将连接的状态更新为`DL_STATE_CONSUMER_PROBE`（从`really_probe()`调用`device_links_check_suppliers()`。）
    * 这可以防止供应商解绑定（从`device_links_unbind_consumers()`调用`wait_for_device_probe()`。）

* 如果探测失败，与供应商的连接将恢复到`DL_STATE_AVAILABLE`状态（从`really_probe()`调用`device_links_no_driver()`。）

* 如果探测成功，与供应商的连接将进展到`DL_STATE_ACTIVE`状态（从`driver_bound()`调用`device_links_driver_bound()`。）

* 当消费者的驱动程序稍后被移除时，与供应商的连接将恢复到`DL_STATE_AVAILABLE`状态（从`device_links_driver_cleanup()`调用`__device_links_no_driver()`，而`device_links_driver_cleanup()`又由`__device_release_driver()`调用。）

* 在移除供应商的驱动程序之前，与未绑定驱动程序的消费者的连接将更新为`DL_STATE_SUPPLIER_UNBIND`状态（从`__device_release_driver()`调用`device_links_busy()`。）
  * 这可以防止消费者绑定（从`really_probe()`调用`device_links_check_suppliers()`。）
  * 已绑定的消费者将从其驱动程序中释放；正在探测的消费者将等待直到完成探测（从`__device_release_driver()`调用`device_links_unbind_consumers()`。）
  * 一旦所有与消费者的连接都处于`DL_STATE_SUPPLIER_UNBIND`状态，供应商驱动程序将被释放，并且连接将恢复到`DL_STATE_DORMANT`状态（从`__device_release_driver()`调用`device_links_driver_cleanup()`。）

API
===
请参阅`device_link_add()`、`device_link_del()`和`device_link_remove()`。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
