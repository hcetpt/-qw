================
介绍
================

RapidIO 标准是一种基于数据包的结构化互连标准，专为嵌入式系统设计。RapidIO 标准的开发由 RapidIO 贸易协会 (RTA) 主导。当前版本的 RapidIO 规范可从 RTA 网站[1]上公开下载。本文档描述了 Linux 中 RapidIO 子系统的基础知识，并提供了其主要组件的信息。
1 概览
==========

由于 RapidIO 子系统遵循 Linux 设备模型，因此它通过定义特定于 RapidIO 的设备和总线类型并在设备模型中注册这些类型来与内核集成。
Linux 中的 RapidIO 子系统是架构无关的，因此定义了特定于架构的接口以支持通用的 RapidIO 子系统操作。
2 核心组件
==================

一个典型的 RapidIO 网络是由终端节点和交换机组成的组合。这些组件在子系统中都由相应的数据结构表示。RapidIO 子系统的逻辑核心组件定义在 `include/linux/rio.h` 文件中。
2.1 主端口
---------------

主端口（或简称 mport）是本地于运行 Linux 代码的处理器的 RapidIO 接口控制器。主端口生成并接收 RapidIO 数据包（即交易）。在 RapidIO 子系统中，每个主端口由 `rio_mport` 数据结构表示。此结构包含了主端口特有的资源，如邮箱和门铃。`rio_mport` 还包含了一个唯一的主机设备ID，在配置为主机枚举器时该ID有效。
RapidIO 主端口由子系统特定的 mport 设备驱动程序服务，这些驱动程序提供了为该子系统定义的功能。为了提供一个与硬件无关的 RapidIO 子系统操作接口，`rio_mport` 结构包含 `rio_ops` 数据结构，其中包含指向特定于硬件实现的 RapidIO 函数的指针。
2.2 设备
----------

RapidIO 设备是指网络中的任何终端节点（除 mport 外）或交换机。所有设备都在 RapidIO 子系统中由对应的 `rio_dev` 数据结构表示。设备形成一个全局设备列表和每个网络的设备列表（这取决于可用 mport 和网络的数量）。
### 2.3 交换机
----------

RapidIO 交换机是一种特殊类别的设备，用于在其端口之间路由数据包以到达最终目的地。在交换机内部，数据包的目的端口由内部路由表定义。在RapidIO子系统中，通过扩展了额外的`rio_switch`数据结构的`rio_dev`数据结构来表示一个交换机，其中`rio_switch`数据结构包含了与交换机相关的特定信息，例如路由表的副本和指向交换机特定功能的指针。
RapidIO 子系统定义了子系统特定的交换机驱动程序的格式和初始化方法，这些驱动程序旨在为常见的交换机管理例程提供硬件特定的实现。

### 2.4 网络
-----------

RapidIO 网络是由相互连接的终端和交换机设备组成的组合。系统中已知的每个RapidIO网络都由相应的`rio_net`数据结构表示。这个结构包括构成同一网络的所有设备和本地主端口的列表。它还包含指向默认主端口的指针，该端口用于与网络内的设备通信。

### 2.5 设备驱动程序
------------------

RapidIO 特定设备的驱动程序遵循Linux内核驱动模型，并旨在支持连接到RapidIO网络的具体RapidIO设备。

### 2.6 子系统接口
------------------------

RapidIO 互连规范定义了一些特性，可以用来为所有参与的RapidIO设备提供一个或多个通用的服务层。这些通用服务可以独立于设备特定的驱动程序运行，也可以被设备特定的驱动程序使用。例如，RIONET 驱动程序实现了Ethernet-over-RapidIO接口。因为对于一个设备只能注册一个驱动程序，所以所有的通用RapidIO服务都必须作为子系统接口进行注册。这允许有多个通用服务附加到同一个设备上，而不会阻止设备特定驱动程序的附加。

### 3. 子系统的初始化
===========================

为了初始化RapidIO子系统，平台必须至少在一个RapidIO网络中初始化并注册一个主端口。在子系统控制器驱动程序的初始化代码中，对于每个可用的主端口调用`rio_register_mport()`函数来注册主端口。
在所有活动的主端口都注册到RapidIO子系统之后，枚举和/或发现例程可以自动调用或者通过用户空间命令调用。
RapidIO 子系统可以配置为内核的静态链接组件或模块化组件（详细内容见下文）。

### 4. 枚举和发现
============================

#### 4.1 概览
-------------

RapidIO 子系统的配置选项允许用户将枚举和发现方法构建为静态链接组件或可加载模块。
枚举/发现方法的实现及可用输入参数定义了如何将任何给定的方法连接到可用的RapidIO端口：可以简单地连接到所有可用端口，或者单独连接到指定的端口设备。根据所选的枚举/发现构建配置，有几种方法可以启动枚举和/或发现过程：

  (a) 静态链接的枚举和发现过程可以在内核初始化时使用相应的模块参数自动启动。这是自从引入RapidIO子系统以来最初使用的方法。现在这种方法依赖于枚举器模块参数，即对于现有的基本枚举/发现方法是`rio-scan.scan`。当自动启动枚举/发现时，用户必须确保所有待发现的终端都在枚举终端开始之前启动，并等待枚举完成。
配置选项`CONFIG_RAPIDIO_DISC_TIMEOUT`定义了待发现终端等待枚举完成的时间。如果指定的超时时间到期，则发现过程将在未获取RapidIO网络信息的情况下终止。注意：超时的发现过程稍后可以使用用户空间命令重新启动（前提是该终端已成功枚举）。

(b) 静态链接的枚举和发现过程可以通过用户空间中的命令启动。与上述选项(a)相比，此启动方式为系统启动提供了更大的灵活性。在所有参与的终端成功启动之后，应首先通过用户空间命令启动枚举过程，在枚举完成后，可以在所有剩余的终端上启动发现过程。

(c) 模块化的枚举和发现过程可以通过用户空间中的命令启动。加载枚举/发现模块后，可以通过用户空间命令启动网络扫描过程。与上述选项(b)类似，必须先启动枚举器。

(d) 模块化的枚举和发现过程可以通过模块初始化例程启动。在这种情况下，应首先加载枚举模块。
当启动网络扫描过程时，它会根据主端口配置的角色（主机或代理）调用枚举或发现例程。
如果主端口被配置为主机端口并分配一个大于等于零的主机目标ID，则由其执行枚举。主机目标ID可以根据RapidIO子系统的构建配置使用不同的方法分配给主端口：

  (a) 对于静态链接的RapidIO子系统核心，可以使用命令行参数“rapidio.hdid=”来分配目标ID，按照mport设备注册顺序列出目标ID分配。例如，在具有两个RapidIO控制器的系统中，命令行参数“rapidio.hdid=-1,7”将导致第二个RapidIO控制器的目标ID=7被分配，而第一个控制器将被分配目标ID=-1。
(b) 如果 RapidIO 子系统核心被构建为可加载模块，除了上述方法之外，还可以使用传统的传递模块参数 "hdid=" 的方式来指定主机目标 ID：

  - 从命令行：`modprobe rapidio hdid=-1,7`，或者
  - 从 modprobe 配置文件中使用配置命令 "options"，例如：`options rapidio hdid=-1,7`。下面提供了一个 modprobe 配置文件的例子。
注：
  (i) 如果省略了 "hdid=" 参数，则所有可用的 mport 将被分配目标 ID = -1；

  (ii) 在具有多个 mport 的系统中，“hdid=” 参数可以省略目标 ID 分配到列表末尾（默认 = -1）
如果特定主端口的主机设备 ID 设置为 -1，则将为其执行发现过程。
枚举和发现例程使用 RapidIO 维护事务来访问设备的配置空间。
注：如果 RapidIO 交换机专用设备驱动程序被构建为可加载模块，它们必须在枚举/发现过程开始之前加载。
这一要求是因为枚举/发现方法在早期阶段会调用厂商特定的回调函数。
4.2 自动启动枚举和发现
--------------------------------

自动启动枚举和发现的方法仅适用于内置的 RapidIO 枚举/发现配置选择。要通过现有的基本枚举器方法启用自动启动枚举和发现，请设置引导命令行参数 "rio-scan.scan=1"。

此配置需要同步启动构成网络的所有 RapidIO 端点，该网络将被枚举/发现。为了确保所有 RapidIO 控制器都已初始化并准备好被发现，在枚举开始之前必须启动发现端点。配置参数 `CONFIG_RAPIDIO_DISC_TIMEOUT` 定义了发现端点等待枚举完成的时间（以秒为单位）。

当选择了自动启动枚举和发现时，基本方法的初始化例程会调用 `rio_init_mports()` 来对所有已知的 mport 设备进行枚举或发现。

根据 RapidIO 网络的大小和配置，由于需要同步启动所有端点，这种自动启动枚举和发现的方法可能难以使用。
### 4.3 用户空间枚举与发现启动
-------------------------------------------------

用户空间枚举和发现启动可用于内置和模块化构建配置。对于用户空间控制的启动，RapidIO子系统创建了一个只写属性文件`/sys/bus/rapidio/scan`。为了在特定mport设备上启动枚举或发现过程，用户需要将mport_ID（而非RapidIO目标ID）写入该文件中。mport_ID是在mport设备注册期间分配的一个顺序编号（0...RIO_MAX_MPORTS）。例如，在具有单个RapidIO控制器的机器上，该控制器的mport_ID始终为0。
要对所有可用的mport进行RapidIO枚举/发现，用户可以将`-1`（或RIO_MPORT_ANY）写入扫描属性文件。

### 4.4 基本枚举方法
----------------------------

这是自RapidIO子系统代码首次发布以来就可用的原始枚举/发现方法。枚举过程是根据RapidIO互连规范：附录I [1] 中概述的枚举算法实现的。
此方法可配置为静态链接或可加载模块。
方法的唯一参数“scan”允许从模块初始化例程触发枚举/发现过程。
此枚举/发现方法只能启动一次，并且如果构建为模块则不支持卸载。
枚举过程使用递归深度优先算法遍历网络。当发现新设备时，枚举器通过写入主机设备ID锁CSR来获取对该设备的所有权。这样做是为了确保枚举器拥有对该设备进行枚举的独家权利。如果成功获取设备所有权，枚举器会分配一个新的rio_dev结构并根据设备能力对其进行初始化。
如果设备是一个终端节点，则为其分配一个唯一的设备ID，并将其值写入设备的Base Device ID CSR。
如果设备是一个交换机，枚举器会分配一个额外的rio_switch结构来存储交换机特定信息。然后查询交换机的供应商ID和设备ID与已知RapidIO交换机表进行比对。每个交换机表项包含指向交换机特定初始化例程的指针，该例程初始化其余的交换机特定操作指针，并在必要时执行硬件初始化。RapidIO交换机没有唯一的设备ID；它依赖于跳数和路由来确定所连接终端节点的设备ID，如果需要访问其配置寄存器的话。如果一个交换机（或交换机链）没有任何终端节点（除枚举器外）连接到它，那么将分配一个虚拟的设备ID以配置通往该交换机的路径。
在没有终端节点的交换机链的情况下，使用一个虚拟的设备ID来配置整个链的路径，而交换机则通过它们的跳数值进行区分。
对于端点和交换机，枚举器都会在设备的组件标签CSR中写入一个唯一的组件标签。这个唯一值被错误管理通知机制用来标识报告错误管理事件的设备。
对交换机之后的枚举通过遍历该交换机每个活动的出口端口来完成。对于每个活动链路，会临时将通往默认设备ID（对于8位系统为0xFF，对于16位系统为0xFFFF）的路径写入路由表。算法通过递归调用自身实现，其中hopcount+1和默认设备ID用于访问活动端口上的设备。
主机完成整个网络的枚举后，通过清除设备ID锁（调用rio_clear_locks()函数）来释放设备。对于系统中的每个端点，它会在端口通用控制CSR中设置已发现位，以表明枚举已完成，并允许代理执行被动发现网络的操作。
发现过程由代理执行，类似于上述枚举过程。然而，发现过程是在不改变现有路由的情况下进行的，因为代理只收集关于RapidIO网络结构的信息，并构建内部已发现设备的地图。这样每个基于Linux的RapidIO子系统的组件都有网络的完整视图。多个代理可以同时执行发现过程。每个代理初始化其RapidIO主端口后，会等待配置的等待时间直到主机完成枚举。如果在等待时间内枚举未完成，则代理跳过RapidIO发现并继续剩余的内核初始化工作。

### 4.5 添加新的枚举/发现方法
--------------------------------------

RapidIO子系统的代码组织允许作为新配置选项添加新的枚举/发现方法，而不会对核心RapidIO代码产生重大影响。
一个新的枚举/发现方法必须在启动枚举/发现过程之前与一个或多个mport设备关联。通常，方法的模块初始化例程调用rio_register_scan()来将枚举器附加到指定的mport设备（或设备）。基本枚举器实现展示了这一过程。

### 4.6 使用可加载的RapidIO交换机驱动程序
----------------------------------------------

当RapidIO交换机驱动程序作为可加载模块构建时，用户必须确保它们在开始枚举/发现之前被加载。
此过程可以通过在特定于RapidIO的modprobe配置文件中指定预加载或后加载依赖关系来自动化，如下面的例子所示：
文件 /etc/modprobe.d/rapidio.conf:

  ```
  # 配置RapidIO子系统模块

  # 设置枚举器主机目标ID（覆盖内核命令行选项）
  options rapidio hdid=-1,2

  # 在加载RapidIO核心模块后立即加载RapidIO交换机驱动程序
  softdep rapidio post: idt_gen2 idtcps tsi57x

  # 或者：

  # 在加载rio-scan枚举器模块之前加载RapidIO交换机驱动程序
  softdep rio-scan pre: idt_gen2 idtcps tsi57x
  ```

**注意：**
在上面的例子中，必须删除或注释掉其中一个"softdep"命令，以保持所需的模块加载顺序。

### 5. 参考资料
===============

[1] RapidIO贸易协会. RapidIO互连规范
[2] Rapidio技术分析. 技术对比
http://www.rapidio.org/education/technology_comparisons/

[3] Linux下的RapidIO支持
https://lwn.net/Articles/139118/

[4] Matt Porter. Linux下的RapidIO. 奥塔瓦Linux研讨会, 2005
    https://www.kernel.org/doc/ols/2005/ols2005v2-pages-43-56.pdf
