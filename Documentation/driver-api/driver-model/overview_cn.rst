=============================
Linux 内核设备模型
=============================

Patrick Mochel	<mochel@digitalimplant.org>

初稿日期：2002年8月26日
更新日期：2006年1月31日


概述
~~~~~~~~

Linux 内核驱动模型是对内核中先前使用的各种驱动模型的统一。它的目的是通过将一组数据和操作整合到可全局访问的数据结构中，来增强针对桥接器和设备的总线特定驱动程序。
传统的驱动模型实现了一种类似树形的结构（有时仅仅是一个列表），用于表示它们所控制的设备。不同总线类型之间并没有任何一致性。
当前的驱动模型为描述一个总线及其下可能出现的设备提供了一个共同且统一的数据模型。统一的总线模型包括所有总线携带的一组通用属性，以及一组通用回调函数，如在总线探测期间发现设备、总线关闭、总线电源管理等。
通用设备和桥接器接口反映了现代计算机的目标：即实现无缝的设备“即插即用”功能、电源管理和热插拔能力。特别是，由Intel和Microsoft制定的ACPI确保了几乎在任何x86兼容系统上的几乎每个总线上的设备都可以在这个范式下工作。当然，并非每个总线都能支持所有这些操作，尽管大多数总线支持大部分这样的操作。
下游访问
~~~~~~~~~~~~~~~~~

为了实现这一目标，一些公共数据字段已从各个总线层移动到了一个通用的数据结构中。这些字段仍然需要被总线层访问，有时也需要被特定设备的驱动程序访问。
鼓励其他总线层像PCI层那样操作：
现在的 `struct pci_dev` 看起来是这样的：

  struct pci_dev {
	..
    struct device dev;     /* 通用设备接口 */
	..
};

首先需要注意的是，在 `struct pci_dev` 中的 `struct device dev` 是静态分配的。这意味着在设备发现时只需要进行一次分配。
另外需要注意的是，`struct device dev` 并不一定定义在 `pci_dev` 结构体的开头。这样做是为了让人们在切换总线驱动和全局驱动时思考自己的行为，并阻止毫无意义和错误的类型转换。
PCI总线层可以自由访问`struct device`中的字段。它了解`struct pci_dev`的结构，也应当了解`struct device`的结构。已转换为当前驱动模型的各个PCI设备驱动程序通常不应该、也不应直接操作`struct device`中的字段，除非有充分的理由这么做。

上述抽象在转换阶段避免了不必要的麻烦。
如果不这样实现，那么每当一个字段被重命名或移除时，下游的所有驱动程序都会受到影响。另一方面，如果只有总线层（而不是设备层）访问`struct device`，那么需要更改的就只有总线层。

### 用户界面

由于具有系统中所有设备的完整层次视图，因此向用户空间导出一个完整的层次视图变得相对容易。这是通过实现一个特殊目的的虚拟文件系统——称为sysfs来完成的。

几乎所有主流Linux发行版都会自动挂载这个文件系统；你可以在"mount"命令的输出中看到类似以下内容：

```
$ mount
..
none on /sys type sysfs (rw,noexec,nosuid,nodev)
..
$
```

通常通过在/etc/fstab文件中的类似条目来实现sysfs的自动挂载：

```
none     	/sys	sysfs    defaults	  	0 0
```

或者，在基于Debian的系统中的/lib/init/fstab文件中有一个类似的条目：

```
none            /sys    sysfs    nodev,noexec,nosuid    0 0
```

如果没有自动挂载sysfs，你可以手动进行挂载：

```
# mount -t sysfs sysfs /sys
```

每当一个设备被插入到树中，就会为它创建一个目录。
这个目录可以在每一层发现过程中填充——全局层、总线层或设备层。
目前，全局层会创建两个文件——'name'和'power'。前者仅报告设备的名称。后者报告设备的当前电源状态，并且也将用于设置当前电源状态。
总线层也可以为在其探测总线时找到的设备创建文件。例如，PCI层目前为每个PCI设备创建'irq'和'resource'文件。
特定于设备的驱动程序还可以在其目录中导出文件，以暴露特定于设备的数据或可调接口。
关于`sysfs`目录布局的更多信息可以在本目录中的其他文档以及`Documentation/filesystems/sysfs.rst`文件中找到。
