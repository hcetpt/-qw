==========================
NAND 错误校正码
==========================

简介
============

在研究了 Linux mtd/nand 中的汉明软件错误校正（ECC）引擎驱动程序后，我认为它还有优化的空间。我花了几个小时对代码进行了改进，采用了一些技巧，比如表查找和删除冗余代码等。
经过这些改进之后，速度提高了 35%-40%。但即便如此，我还是觉得可以进一步优化——这让我着迷了。
我决定在这个文件中记录我的改进过程。也许这对别人有用，或者有人能从中学到些什么。
问题描述
===========

NAND 闪存（至少是单层单元 SLC 的）通常包含 256 字节的扇区。然而，NAND 闪存并不是极其可靠的，因此需要一些错误检测（有时还包括错误纠正）机制。
这是通过汉明码来实现的。我将尝试用通俗易懂的方式解释一下（如果我没有使用正确的术语，请各位专业人士见谅，我上次接触编码理论已经是近 30 年前的事了，而且我必须承认那不是我最喜欢的课程之一）。
如前所述，ECC 计算是在 256 字节的扇区上进行的。这是通过对行和列计算多个奇偶校验位来完成的。所使用的奇偶校验为偶校验，这意味着当计算奇偶校验的数据位为 1 时，奇偶校验位也等于 1；而当计算奇偶校验的数据位为 0 时，奇偶校验位等于 0。这样，计算奇偶校验的数据位加上奇偶校验位的总数为偶数。（如果你不明白这一点，可以参考维基百科）
奇偶校验通常是通过异或操作来计算的，有时也被称为 XOR。在 C 语言中，异或运算符是 ^。

回到 ECC 上来。
让我们给出一个小图示：

=========  ==== ==== ==== ==== ==== ==== ==== ====   === === === === ====
字节   0:  位7 位6 位5 位4 位3 位2 位1 位0   rp0 rp2 rp4 ... rp14
字节   1:  位7 位6 位5 位4 位3 位2 位1 位0   rp1 rp2 rp4 ... rp14
字节   2:  位7 位6 位5 位4 位3 位2 位1 位0   rp0 rp3 rp4 ... rp14
字节   3:  位7 位6 位5 位4 位3 位2 位1 位0   rp1 rp3 rp4 ... rp14
字节   4:  位7 位6 位5 位4 位3 位2 位1 位0   rp0 rp2 rp5 ... rp14
..
字节 254:  位7 位6 位5 位4 位3 位2 位1 位0   rp0 rp3 rp5 ... rp15
字节 255:  位7 位6 位5 位4 位3 位2 位1 位0   rp1 rp3 rp5 ... rp15
           cp1  cp0  cp1  cp0  cp1  cp0  cp1  cp0
           cp3  cp3  cp2  cp2  cp3  cp3  cp2  cp2
           cp5  cp5  cp5  cp5  cp4  cp4  cp4  cp4
=========  ==== ==== ==== ==== ==== ==== ==== ====   === === === === ====

这个图示代表一个256字节的扇区。
cp是我对列校验的简称，rp是对行校验的简称。
我们先解释列校验：
- cp0 是所有位0、位2、位4和位6的校验值，
因此所有位0、位2、位4、位6的值与cp0本身的和为偶数。
同样地，cp1是所有位1、位3、位5和位7的和。
- cp2 是位0、位1、位4和位5的校验值。
- cp3 是位2、位3、位6和位7的校验值。
- cp4 是位0、位1、位2和位3的校验值。
- cp5 是位4、位5、位6和位7的校验值。
请注意，cp0 到 cp5 每一项正好是一个比特位。
行奇偶校验实际上工作原理几乎相同：
- rp0 是所有偶数字节（0、2、4、6、... 252、254）的奇偶校验位
- rp1 是所有奇数字节（1、3、5、7、... 253、255）的奇偶校验位
- rp2 是所有字节 0、1、4、5、8、9 等的奇偶校验位
（处理两个字节，然后跳过两个字节）
- rp3 覆盖 rp2 未覆盖的部分（字节 2、3、6、7、10、11 等）
- 对于 rp4 的规则是：覆盖四个字节，跳过四个字节，再覆盖四个字节，跳过四个字节等等
因此 rp4 计算字节 0、1、2、3、8、9、10、11、16 等的奇偶校验位
- 而 rp5 覆盖另一半，即字节 4、5、6、7、12、13、14、15、20 等
现在的故事变得相当乏味。我想你已经明白了
- rp6 覆盖八个字节，然后跳过八个等等
- rp7 跳过八个字节，然后覆盖八个等等
- rp8 覆盖十六个字节，然后跳过十六个等等
- rp9 跳过十六个字节，然后覆盖十六个等等
- rp10 覆盖三十二个字节，然后跳过三十二个等等
- rp11 跳过三十二个字节，然后覆盖三十二个等等
- rp12 覆盖六十四字节，然后跳过六十四等等
- rp13 跳过六十四字节，然后覆盖六十四等等
- rp14 覆盖一百二十八个字节，然后跳过一百二十八
- rp15 跳过一百二十八个字节，然后覆盖一百二十八

最后，奇偶校验位按以下方式分组为三个字节：

=====  ===== ===== ===== ===== ===== ===== ===== =====
ECC    Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0
=====  ===== ===== ===== ===== ===== ===== ===== =====
ECC 0   rp07  rp06  rp05  rp04  rp03  rp02  rp01  rp00
ECC 1   rp15  rp14  rp13  rp12  rp11  rp10  rp09  rp08
ECC 2   cp5   cp4   cp3   cp2   cp1   cp0      1     1
=====  ===== ===== ===== ===== ===== ===== ===== =====

我写完这些后发现 ST 应用笔记 AN1823
（http://www.st.com/stonline/）给出了一个更漂亮的图表。（但他们使用行奇偶校验这个术语，而我使用的是行奇偶校验）
哦好吧，我在图形方面能力有限，所以请忍受一下吧 :-)

无论如何我都不能重用 ST 的图片因为版权原因。

尝试 0
========

实现奇偶校验计算非常简单
在 C 伪代码中：

```plaintext
for (i = 0; i < 256; i++) {
  if (i & 0x01)
     rp1 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp1;
  else
     rp0 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp0;
  if (i & 0x02)
     rp3 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp3;
  else
     rp2 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp2;
  if (i & 0x04)
    rp5 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp5;
  else
    rp4 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp4;
  if (i & 0x08)
    rp7 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp7;
  else
    rp6 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp6;
  if (i & 0x10)
    rp9 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp9;
  else
    rp8 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp8;
  if (i & 0x20)
    rp11 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp11;
  else
    rp10 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp10;
  if (i & 0x40)
    rp13 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp13;
  else
    rp12 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp12;
  if (i & 0x80)
    rp15 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp15;
  else
    rp14 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp14;
  cp0 = bit6 ^ bit4 ^ bit2 ^ bit0 ^ cp0;
  cp1 = bit7 ^ bit5 ^ bit3 ^ bit1 ^ cp1;
  cp2 = bit5 ^ bit4 ^ bit1 ^ bit0 ^ cp2;
  cp3 = bit7 ^ bit6 ^ bit3 ^ bit2 ^ cp3;
  cp4 = bit3 ^ bit2 ^ bit1 ^ bit0 ^ cp4;
  cp5 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ cp5;
}
```

分析 0
==========

C 语言确实有位运算符，但没有真正高效执行上述操作的运算符（大多数硬件也没有这样的指令）。
因此，即使没有实现它也很清楚，上述代码并不会给我带来诺贝尔奖 :-)

幸运的是，异或操作是可交换的，所以我们可以在任何顺序下组合值。因此，我们不必单独计算所有位，而是尝试重新组织数据。
对于列校验和来说，这是很容易的。我们可以直接对字节进行异或操作，并在最后筛选出相关的位。这非常好，因为它可以把所有的校验位计算移出for循环之外。
同样地，我们可以先为不同的行异或字节。

这导致了：

第一次尝试
===========

```c
const char parity[256] = {
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    // 省略其他值...
};

void ecc1(const unsigned char *buf, unsigned char *code)
{
    int i;
    const unsigned char *bp = buf;
    unsigned char cur;
    unsigned char rp0, rp1, rp2, rp3, rp4, rp5, rp6, rp7;
    unsigned char rp8, rp9, rp10, rp11, rp12, rp13, rp14, rp15;
    unsigned char par;

    par = 0;
    rp0 = 0; rp1 = 0; rp2 = 0; rp3 = 0;
    rp4 = 0; rp5 = 0; rp6 = 0; rp7 = 0;
    rp8 = 0; rp9 = 0; rp10 = 0; rp11 = 0;
    rp12 = 0; rp13 = 0; rp14 = 0; rp15 = 0;

    for (i = 0; i < 256; i++)
    {
        cur = *bp++;
        par ^= cur;
        if (i & 0x01) rp1 ^= cur; else rp0 ^= cur;
        if (i & 0x02) rp3 ^= cur; else rp2 ^= cur;
        if (i & 0x04) rp5 ^= cur; else rp4 ^= cur;
        if (i & 0x08) rp7 ^= cur; else rp6 ^= cur;
        if (i & 0x10) rp9 ^= cur; else rp8 ^= cur;
        if (i & 0x20) rp11 ^= cur; else rp10 ^= cur;
        if (i & 0x40) rp13 ^= cur; else rp12 ^= cur;
        if (i & 0x80) rp15 ^= cur; else rp14 ^= cur;
    }
    code[0] =
        (parity[rp7] << 7) |
        (parity[rp6] << 6) |
        (parity[rp5] << 5) |
        (parity[rp4] << 4) |
        (parity[rp3] << 3) |
        (parity[rp2] << 2) |
        (parity[rp1] << 1) |
        (parity[rp0]);
    code[1] =
        (parity[rp15] << 7) |
        (parity[rp14] << 6) |
        (parity[rp13] << 5) |
        (parity[rp12] << 4) |
        (parity[rp11] << 3) |
        (parity[rp10] << 2) |
        (parity[rp9]  << 1) |
        (parity[rp8]);
    code[2] =
        (parity[par & 0xf0] << 7) |
        (parity[par & 0x0f] << 6) |
        (parity[par & 0xcc] << 5) |
        (parity[par & 0x33] << 4) |
        (parity[par & 0xaa] << 3) |
        (parity[par & 0x55] << 2);
    code[0] = ~code[0];
    code[1] = ~code[1];
    code[2] = ~code[2];
}
```

仍然非常简单直观。最后三个取反语句是为了让空闪存区产生一个校验和 `0xff 0xff 0xff`。在空闪存中，所有数据都是 `0xff`，所以校验和与之匹配。
我还引入了校验查找表。我预计这是计算校验的最快方式，但我会稍后探讨其他替代方案。
分析 1
======

这段代码工作正常，但效率并不高。在我的系统上，它的运行时间几乎是Linux驱动程序代码的四倍。但是，如果真的这么容易的话，早就有人做过了。
不经历风雨怎么见彩虹。
幸运的是，还有许多可以改进的地方。
在第一步中，我们从按位计算转移到了按字节计算。
然而，在C语言中我们也可以使用`unsigned long`数据类型，并且几乎每款现代微处理器都支持32位运算，所以我们为什么不尝试以一种方式编写代码，使得我们可以按32位块处理数据呢？
当然，这意味着需要做一些修改，因为行奇偶校验是按字节进行的。快速分析如下：
对于列奇偶校验，我们使用 `par` 变量。当我们扩展到 32 位时，最终可以很容易地从它计算出 `rp0` 和 `rp1`
（因为现在 `par` 包含了 4 个字节，分别贡献给 `rp1`、`rp0`、`rp1`、`rp0`，从最高有效位到最低有效位）
同样，`rp2` 和 `rp3` 也可以很容易地从 `par` 中获取，因为 `rp3` 覆盖前两个最高有效位，而 `rp2` 覆盖最后两个最低有效位。
需要注意的是，现在循环只执行 64 次（256/4）。
并且需要注意字节顺序。长整型中的字节顺序取决于机器，可能会影响我们。
无论如何，如果存在问题：这段代码是在 x86 上开发的（具体来说：一台带有 D920 英特尔 CPU 的戴尔 PC）。

当然，性能可能会受到对齐的影响，但我预计 NAND 驱动程序中的 I/O 缓冲区已经正确对齐（否则应该进行修正以获得最佳性能）。
让我们尝试一下...
尝试 2
=======

```
extern const char parity[256];

void ecc2(const unsigned char *buf, unsigned char *code)
{
    int i;
    const unsigned long *bp = (unsigned long *)buf;
    unsigned long cur;
    unsigned long rp0, rp1, rp2, rp3, rp4, rp5, rp6, rp7;
    unsigned long rp8, rp9, rp10, rp11, rp12, rp13, rp14, rp15;
    unsigned long par;

    par = 0;
    rp0 = 0; rp1 = 0; rp2 = 0; rp3 = 0;
    rp4 = 0; rp5 = 0; rp6 = 0; rp7 = 0;
    rp8 = 0; rp9 = 0; rp10 = 0; rp11 = 0;
    rp12 = 0; rp13 = 0; rp14 = 0; rp15 = 0;

    for (i = 0; i < 64; i++)
    {
        cur = *bp++;
        par ^= cur;
        if (i & 0x01) rp5 ^= cur; else rp4 ^= cur;
        if (i & 0x02) rp7 ^= cur; else rp6 ^= cur;
        if (i & 0x04) rp9 ^= cur; else rp8 ^= cur;
        if (i & 0x08) rp11 ^= cur; else rp10 ^= cur;
        if (i & 0x10) rp13 ^= cur; else rp12 ^= cur;
        if (i & 0x20) rp15 ^= cur; else rp14 ^= cur;
    }
    /*
       我们需要调整生成校验码的代码，因为现在 rp 变量是长整型；同时列奇偶校验的计算也需要改变
我们将把 rp4 到 rp15 通过移位和异或操作还原为单字节实体
    */
    rp4 ^= (rp4 >> 16); rp4 ^= (rp4 >> 8); rp4 &= 0xff;
    rp5 ^= (rp5 >> 16); rp5 ^= (rp5 >> 8); rp5 &= 0xff;
    rp6 ^= (rp6 >> 16); rp6 ^= (rp6 >> 8); rp6 &= 0xff;
    rp7 ^= (rp7 >> 16); rp7 ^= (rp7 >> 8); rp7 &= 0xff;
    rp8 ^= (rp8 >> 16); rp8 ^= (rp8 >> 8); rp8 &= 0xff;
    rp9 ^= (rp9 >> 16); rp9 ^= (rp9 >> 8); rp9 &= 0xff;
    rp10 ^= (rp10 >> 16); rp10 ^= (rp10 >> 8); rp10 &= 0xff;
    rp11 ^= (rp11 >> 16); rp11 ^= (rp11 >> 8); rp11 &= 0xff;
    rp12 ^= (rp12 >> 16); rp12 ^= (rp12 >> 8); rp12 &= 0xff;
    rp13 ^= (rp13 >> 16); rp13 ^= (rp13 >> 8); rp13 &= 0xff;
    rp14 ^= (rp14 >> 16); rp14 ^= (rp14 >> 8); rp14 &= 0xff;
    rp15 ^= (rp15 >> 16); rp15 ^= (rp15 >> 8); rp15 &= 0xff;
    rp3 = (par >> 16); rp3 ^= (rp3 >> 8); rp3 &= 0xff;
    rp2 = par & 0xffff; rp2 ^= (rp2 >> 8); rp2 &= 0xff;
    par ^= (par >> 16);
    rp1 = (par >> 8); rp1 &= 0xff;
    rp0 = (par & 0xff);
    par ^= (par >> 8); par &= 0xff;

    code[0] =
        (parity[rp7] << 7) |
        (parity[rp6] << 6) |
        (parity[rp5] << 5) |
        (parity[rp4] << 4) |
        (parity[rp3] << 3) |
        (parity[rp2] << 2) |
        (parity[rp1] << 1) |
        (parity[rp0]);
    code[1] =
        (parity[rp15] << 7) |
        (parity[rp14] << 6) |
        (parity[rp13] << 5) |
        (parity[rp12] << 4) |
        (parity[rp11] << 3) |
        (parity[rp10] << 2) |
        (parity[rp9]  << 1) |
        (parity[rp8]);
    code[2] =
        (parity[par & 0xf0] << 7) |
        (parity[par & 0x0f] << 6) |
        (parity[par & 0xcc] << 5) |
        (parity[par & 0x33] << 4) |
        (parity[par & 0xaa] << 3) |
        (parity[par & 0x55] << 2);
    code[0] = ~code[0];
    code[1] = ~code[1];
    code[2] = ~code[2];
}

```

奇偶校验数组没有再显示出来。注意，在这些示例中，我稍微偏离了常规编程风格，允许一行有多条语句，不在只有一个语句的 `then` 和 `else` 块中使用 `{}`，并使用如 `^=` 这样的运算符。

分析 2
=======

这段代码（当然）可以工作，并且可喜的是：我们比 Linux 驱动程序代码稍快一些（大约 15%）。但是等一下，不要太快欢呼。
还有更多的性能可以挖掘。
如果我们观察 `rp14` 和 `rp15`，我们会发现我们要么将数据与 `rp14` 异或，要么与 `rp15` 异或。然而我们还有 `par`，它覆盖所有数据。
这意味着无需单独计算`rp14`，因为它可以从`rp15`通过`rp14 = par ^ rp15`计算得出，因为`par = rp14 ^ rp15`；（如果需要，我们也可以避免计算`rp15`，而从`rp14`计算它）。这就是为什么有些地方会提到逆向奇偶校验。当然，同样的规则也适用于`rp4/5`、`rp6/7`、`rp8/9`、`rp10/11`和`rp12/13`。
实际上，这意味着我们可以从if语句中删除else子句。此外，我们还可以通过先将数据类型从long转换为byte来稍微优化最后的计算过程。实际上，我们甚至可以避免查找表的操作。

第三次尝试
=========

替换原有的代码为：

          如果 (i & 0x01) rp5 ^= cur; 否则 rp4 ^= cur;
          如果 (i & 0x02) rp7 ^= cur; 否则 rp6 ^= cur;
          如果 (i & 0x04) rp9 ^= cur; 否则 rp8 ^= cur;
          如果 (i & 0x08) rp11 ^= cur; 否则 rp10 ^= cur;
          如果 (i & 0x10) rp13 ^= cur; 否则 rp12 ^= cur;
          如果 (i & 0x20) rp15 ^= cur; 否则 rp14 ^= cur;

替换为：

          如果 (i & 0x01) rp5 ^= cur;
          如果 (i & 0x02) rp7 ^= cur;
          如果 (i & 0x04) rp9 ^= cur;
          如果 (i & 0x08) rp11 ^= cur;
          如果 (i & 0x10) rp13 ^= cur;
          如果 (i & 0x20) rp15 ^= cur;

并在循环之外添加了：

          rp4  = par ^ rp5;
          rp6  = par ^ rp7;
          rp8  = par ^ rp9;
          rp10  = par ^ rp11;
          rp12  = par ^ rp13;
          rp14  = par ^ rp15;

之后，虽然语句数量减少了，但是代码执行时间大约增加了30%。这也反映在汇编代码中。

第三次分析
==========

非常奇怪的现象。猜测这可能与缓存或指令并行性有关。我也在一个eeePC（赛扬处理器，时钟频率为900MHz）上进行了测试。有趣的是，根据time命令的结果，它的执行速度仅比我3GHz的D920处理器慢30%。
正如预期的那样，这并不容易，也许我们应该换一条思路：让我们回到第二次尝试的代码，并进行循环展开。这将消除一些if语句。我将尝试不同的展开量来看哪种效果最好。

第四次尝试
=========

我将循环展开了1倍、2倍、3倍和4倍。
对于4倍展开，代码开始如下：

    对于 (i = 0; i < 4; i++)
    {
        cur = *bp++;
        par ^= cur;
        rp4 ^= cur;
        rp6 ^= cur;
        rp8 ^= cur;
        rp10 ^= cur;
        如果 (i & 0x1) rp13 ^= cur; 否则 rp12 ^= cur;
        如果 (i & 0x2) rp15 ^= cur; 否则 rp14 ^= cur;
        cur = *bp++;
        par ^= cur;
        rp5 ^= cur;
        rp6 ^= cur;
        ..
第四次分析
==========

一次展开获得了约15%的性能提升。

两次展开保持了大约15%的性能提升。

三次展开相比第二次尝试时获得了30%的性能提升。
四次展开相比于三次展开仅有微小的改进。
我决定继续使用四次展开的循环。直觉告诉我，在接下来的步骤中，我可以从中获得额外的收益。
下一步的触发点在于 `par` 包含所有字节的异或结果，而 `rp4` 和 `rp5` 每个包含一半字节的异或结果。因此，实际上 `par = rp4 ^ rp5`。但由于异或是可交换的，我们也可以表示为 `rp5 = par ^ rp4`。因此，没有必要同时保留 `rp4` 和 `rp5`。我们可以删除 `rp5`（或者 `rp4`，但我已经预见到了另一个优化）。
同样的情况适用于 `rp6` 和 `rp7`、`rp8` 和 `rp9`、`rp10` 和 `rp11`、`rp12` 和 `rp13` 以及 `rp14` 和 `rp15`。

尝试 5
======

实际上，循环中所有的奇数位 `rp` 赋值都被去除了，这包括了 `if` 语句中的 `else` 子句。
当然，在循环结束后我们需要通过添加如下的代码来修正：

    rp5 = par ^ rp4;

此外，初始赋值（例如 `rp5 = 0;` 等）也可以被移除。
在此过程中，我还去除了 `rp0`、`rp1`、`rp2` 和 `rp3` 的初始化。

分析 5
======

测量结果显示这是一个很好的改进。与尝试 4 中四倍展开相比，运行时间大约减少了一半，并且我们只需要当前 Linux 内核中代码所需处理时间的大约三分之一。
然而，我仍然认为还有提升空间。我不喜欢所有的 `if` 语句。为什么不保持一个累加的奇偶校验，并只保留最后一个 `if` 语句呢？是时候进行又一次改进了！

尝试 6
======

在 `for` 循环内的代码被改变为：

    for (i = 0; i < 4; i++)
    {
        cur = *bp++; tmppar  = cur; rp4 ^= cur;
        cur = *bp++; tmppar ^= cur; rp6 ^= tmppar;
        cur = *bp++; tmppar ^= cur; rp4 ^= cur;
        cur = *bp++; tmppar ^= cur; rp8 ^= tmppar;

        cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur;
        cur = *bp++; tmppar ^= cur; rp6 ^= cur;
        cur = *bp++; tmppar ^= cur; rp4 ^= cur;
        cur = *bp++; tmppar ^= cur; rp10 ^= tmppar;

        cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur; rp8 ^= cur;
        cur = *bp++; tmppar ^= cur; rp6 ^= cur; rp8 ^= cur;
        cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp8 ^= cur;
        cur = *bp++; tmppar ^= cur; rp8 ^= cur;

        cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur;
        cur = *bp++; tmppar ^= cur; rp6 ^= cur;
        cur = *bp++; tmppar ^= cur; rp4 ^= cur;
        cur = *bp++; tmppar ^= cur;

        par ^= tmppar;
        if ((i & 0x1) == 0) rp12 ^= tmppar;
        if ((i & 0x2) == 0) rp14 ^= tmppar;
    }

如你所见，`tmppar` 用于在一个 `for` 迭代中累积奇偶校验。在最后三个语句中，它被加入到 `par` 中，如果需要的话，也会加入到 `rp12` 和 `rp14` 中。
在做这些更改时，我还发现可以利用 `tmppar` 在此迭代中包含的累积奇偶校验。因此，我没有使用：
rp4 ^= cur; rp6 ^= cur;
而是移除了 `rp6 ^= cur;` 语句，并在下一个语句中做了 `rp6 ^= tmppar;`。对 `rp8` 和 `rp10` 也进行了类似的更改。

分析 6
======

再次测量这段代码显示了巨大的提升。在我的系统上执行原始 Linux 代码 100 万次大约需要 1 秒。
使用时间来衡量性能。经过这次迭代后，我回到了0.075秒。实际上，为了不损失过多的准确性，我不得不决定开始对超过一千万次的迭代进行测量。这似乎确实是一个突破！

不过，仍有改进的空间。有三处包含这样的语句：

```c
rp4 ^= cur; rp6 ^= cur;
```

看起来在`while`循环中同时维护一个变量`rp4_6`会更高效；这样每轮循环可以减少3条语句。当然，在循环结束后我们需要进行修正，添加如下代码：

```c
rp4 ^= rp4_6;
rp6 ^= rp4_6
```

此外还有连续四次对`rp8`的赋值。这可以通过在四行之前保存`tmppar`并在之后执行`rp8 = rp8 ^ tmppar ^ notrp8;`（其中`notrp8`是这四行之前的`rp8`值）的方式稍微更高效地编码。
再次利用了异或运算的交换律。是时候进行新的测试了！


尝试7
=====

新代码现在看起来像这样：

```c
for (i = 0; i < 4; i++)
{
    cur = *bp++; tmppar  = cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= tmppar;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp8 ^= tmppar;

    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp10 ^= tmppar;

    notrp8 = tmppar;
    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;
    rp8 = rp8 ^ tmppar ^ notrp8;

    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;

    par ^= tmppar;
    if ((i & 0x1) == 0) rp12 ^= tmppar;
    if ((i & 0x2) == 0) rp14 ^= tmppar;
}
rp4 ^= rp4_6;
rp6 ^= rp4_6;
```

变化不大，但积少成多嘛 :-)


分析7
=====

实际上这样做反而让情况变得更糟。虽然不是很多，但我不想往错误的方向走。也许以后可以再研究这个问题。可能是与缓存有关的问题。
猜测这就是可以在循环内部优化的极限了。或许再展开一次循环会有帮助。我暂时保留尝试7中的优化。
尝试8
=====

再次展开了循环。
分析8
=====

这反而使情况变得更糟。我们还是保留尝试6的结果，并从那里继续吧。
虽然看起来循环内的代码已经无法进一步优化了，但在生成ECC码时仍然有优化空间。
我们可以简单地计算总奇偶校验。如果结果为0，则`rp4 = rp5`等。如果奇偶校验为1，则`rp4 = !rp5`。

但如果`rp4 = rp5`，则不需要`rp5`等。我们可以直接将偶数位写入结果字节，然后做类似下面的操作：

```c
code[0] |= (code[0] << 1);
```

让我们测试一下。
尝试9
=====

修改了代码，但这略微降低了性能。尝试了各种其他的方法，比如使用专用的奇偶校验数组以避免`parity[rp7] << 7;`后的移位操作。没有收益。
改变使用奇偶校验数组的方式，通过移位操作（例如
将 parity[rp7] << 7 替换为:

    rp7 ^= (rp7 << 4);
    rp7 ^= (rp7 << 2);
    rp7 ^= (rp7 << 1);
    rp7 &= 0x80;

没有获得明显的好处。
唯一稍有变化的是反转了校验位，因此我们可以移除最后三个反转语句。
唉，可惜这种方法并没有带来更多的改进。不过，使用 Linux 驱动程序代码进行一千万次迭代需要 13 到 13.5 秒，而我的代码现在只需要大约 0.73 秒就能完成这些迭代。因此，我在我自己的系统上将性能提高了大约 18 倍。这还不算太差。当然，在不同的硬件上会得到不同的结果。对此不作任何保证！

但是天下没有免费的午餐。代码大小几乎增加了三倍（从 562 字节增加到 1434 字节）。但另一方面，增加也不是特别多。

**纠正错误**

为了纠正错误，我再次以 ST 的应用说明作为起点，同时也参考了现有的代码。
算法本身非常简单直接。只需对给定的 ECC 和计算出的 ECC 进行异或操作。如果所有字节都为 0，则没有问题。如果有 11 个比特位为 1，我们有一个可纠正的单比特错误。如果只有一个比特位为 1，那么在给定的 ECC 码中存在错误。
事实证明，通过查找表来实现最快。当需要进行修复时，这种方法在我的系统上带来的性能提升大约是两倍；而在不需要修复的情况下，性能提升了大约 1%。
对于这个函数，代码大小从 330 字节增加到了 686 字节（gcc 4.2，-O3）。

**结论**

在计算 ECC 时所获得的收益是巨大的。在我的开发硬件上，ECC 计算速度提高了 18 倍。在一个采用 MIPS 核心的嵌入式系统测试中，获得了 7 倍的速度提升。
在 Linksys NSLU2（ARMv5TE 处理器）上的测试显示，速度提高了 5 倍（大端模式，gcc 4.1.2，-O3）。

对于纠错，并没有获得太多收益（因为位翻转很少发生）。但另一方面，在这里花费的周期也相对较少。
看起来在这个方面已经没有太多可以优化的空间了，至少在使用 C 语言编程的情况下是如此。当然，也许可以通过汇编程序来进一步优化，但由于流水线行为等原因，这对 Intel 硬件来说是非常棘手的。
作者：弗朗斯·梅伦布鲁克斯

版权所有 © 2008 皇家飞利浦电子有限公司
