SoundWire中的音频流
=========================

音频流是在以下几者之间建立的一种逻辑或虚拟连接：

  (1) 系统内存缓冲区与Codec之间

  (2) DSP内存缓冲区与Codec之间

  (3) FIFO与Codec之间

  (4) Codec与Codec之间

这种连接通常由DMA通道通过数据链路驱动。一个音频流包含一个或多个数据通道。流内的所有通道必须具有相同的采样率和相同的样本大小。
假设使用SoundWire接口打开了一个包含两个通道（左声道和右声道）的流。以下是SoundWire中表示流的一些方式：
内存中的流样本（系统内存、DSP内存或FIFO）:: 

	-------------------------
	| 左 | 右 | 左 | 右 | 左 | 右 |
	-------------------------

示例1：立体声流，包含左右两个声道，从主设备传输到从设备。主设备和从设备都使用单一端口。:: 

	+---------------+                    时钟信号  +---------------+
	|    主设备     +----------------------------------+    从设备     |
	|   接口        |                                  |   接口        |
	|               |                                  |       1       |
	|               |                     数据信号    |               |
	|    左 + 右    +----------------------------------+    左 + 右    |
	|     (数据)    |     数据方向                      |     (数据)    |
	+---------------+  +----------------------->       +---------------+


示例2：立体声流，包含左右两个声道，从从设备捕获到主设备。主设备和从设备都使用单一端口。:: 

	+---------------+                    时钟信号  +---------------+
	|    主设备     +----------------------------------+    从设备     |
	|   接口        |                                  |   接口        |
	|               |                                  |       1       |
	|               |                     数据信号    |               |
	|    左 + 右    +----------------------------------+    左 + 右    |
	|     (数据)    |     数据方向                      |     (数据)    |
	+---------------+  <-----------------------+       +---------------+


示例3：立体声流，包含左右两个声道，由主设备渲染。每个左右声道分别被两个不同的从设备接收。主设备和两个从设备都使用单一端口。:: 

	+---------------+                    时钟信号  +---------------+
	|    主设备     +---------+------------------------+    从设备     |
	|   接口        |         |                        |   接口        |
	|               |         |                        |       1       |
	|               |         |           数据信号    |               |
	|    左 + 右    +---+------------------------------+       左       |
	|     (数据)    |   |     |    数据方向            |     (数据)    |
	+---------------+   |     |   +------------->      +---------------+
	                    |     |
	                    |     |
	                    |     |                        +---------------+
	                    |     +----------------------> |     从设备     |
	                    |                              |   接口        |
	                    |                              |       2       |
	                    |                              |               |
	                    +----------------------------> |       右       |
	                                                   |     (数据)    |
	                                                   +---------------+

示例4：立体声流，包含左右两个声道，由主设备渲染。左右两个声道分别被两个不同的从设备接收。主设备和两个从设备都使用单一端口处理左加右。每个从设备本地处理左加右数据，通常基于静态配置或动态方向，并可能驱动一个或多个扬声器。:: 

	+---------------+                    时钟信号  +---------------+
	|    主设备     +---------+------------------------+    从设备     |
	|   接口        |         |                        |   接口        |
	|               |         |                        |       1       |
	|               |         |           数据信号    |               |
	|    左 + 右    +---+------------------------------+    左 + 右    |
	|     (数据)    |   |     |    数据方向            |     (数据)    |
	+---------------+   |     |   +------------->      +---------------+
	                    |     |
	                    |     |
	                    |     |                        +---------------+
	                    |     +----------------------> |     从设备     |
	                    |                              |   接口        |
	                    |                              |       2       |
	                    |                              |               |
	                    +----------------------------> |    左 + 右    |
	                                                   |     (数据)    |
	                                                   +---------------+

示例5：立体声流，包含左右两个声道，由主设备的两个不同端口渲染，并仅由从设备接口的一个端口接收。:: 

	+--------------------+
	|                    |
	|     +--------------+                             +----------------+
	|     |             ||                             |                |
	|     |  数据端口  ||  左声道                      |                |
	|     |      1      |------------+                 |                |
	|     |  左声道     ||           |                 +-----+----+     |
	|     |   (数据)    ||           |   左 + 右声道  ||    数据 |     |
	| 主设备  +----------+           | +---+---------> ||    端口 |     |
	| 接口          |           |                 ||     1   |     |
	|     +--------------+           |                 ||         |     |
	|     |             ||           |                 +----------+     |
	|     |  数据端口  |------------+                 |                |
	|     |      2      ||  右声道                      |     从设备      |
	|     |  右声道     ||                             |   接口        |
	|     |   (数据)    ||                             |       1        |
	|     +--------------+         时钟信号           |    左 + 右    |
	|                    +---------------------------> |     (数据)    |
	+--------------------+                             |                |
							   +----------------+

示例6：立体声流，包含左右两个声道，由两个不同的主设备渲染，每个渲染一个声道，并由两个不同的从设备接收，每个接收一个声道。两个主设备和两个从设备都使用单一端口。:: 

	+---------------+                    时钟信号  +---------------+
	|    主设备     +----------------------------------+    从设备     |
	|   接口        |                                  |   接口        |
	|       1       |                                  |       1       |
	|               |                     数据信号    |               |
	|       左      +----------------------------------+       左      |
	|     (数据)    |     数据方向                      |     (数据)    |
	+---------------+  +----------------------->       +---------------+

	+---------------+                    时钟信号  +---------------+
	|    主设备     +----------------------------------+    从设备     |
	|   接口        |                                  |   接口        |
	|       2       |                                  |       2       |
	|               |                     数据信号    |               |
	|       右      +----------------------------------+       右      |
	|     (数据)    |     数据方向                      |     (数据)    |
	+---------------+  +----------------------->       +---------------+

示例7：立体声流，包含左右两个声道，由两个主设备渲染，每个渲染左右两个声道。每个从设备接收左加右。这与示例4相同的应用，只是从设备位于单独的链路上。:: 

	+---------------+                    时钟信号  +---------------+
	|    主设备     +----------------------------------+    从设备     |
	|   接口        |                                  |   接口        |
	|       1       |                                  |       1       |
	|               |                     数据信号    |               |
	|     左 + 右   +----------------------------------+     左 + 右   |
	|     (数据)    |     数据方向                      |     (数据)    |
	+---------------+  +----------------------->       +---------------+

	+---------------+                    时钟信号  +---------------+
	|    主设备     +----------------------------------+    从设备     |
	|   接口        |                                  |   接口        |
	|       2       |                                  |       2       |
	|               |                     数据信号    |               |
	|     左 + 右   +----------------------------------+     左 + 右   |
	|     (数据)    |     数据方向                      |     (数据)    |
	+---------------+  +----------------------->       +---------------+

示例8：四声道流，由两个主设备渲染，每个渲染两个声道。每个从设备接收两个声道。:: 

	+---------------+                    时钟信号  +---------------+
	|    主设备     +----------------------------------+    从设备     |
	|   接口        |                                  |   接口        |
	|       1       |                                  |       1       |
	|               |                     数据信号    |               |
	|    左1 + 右1  +----------------------------------+    左1 + 右1  |
	|     (数据)    |     数据方向                      |     (数据)    |
	+---------------+  +----------------------->       +---------------+

	+---------------+                    时钟信号  +---------------+
	|    主设备     +----------------------------------+    从设备     |
	|   接口        |                                  |   接口        |
	|       2       |                                  |       2       |
	|               |                     数据信号    |               |
	|     左2 + 右2 +----------------------------------+    左2 + 右2  |
	|     (数据)    |     数据方向                      |     (数据)    |
	+---------------+  +----------------------->       +---------------+

注1：在多链路情况下，如上所述，要锁定，需要获取全局锁，然后锁定总线实例。但是，在这种情况下，调用框架（ASoC DPCM）保证了对卡上的流操作总是序列化的。因此，没有竞争条件，也不需要全局锁。
注2：从设备可以配置为接收给定流上的链接传输的所有通道（示例4），或者只接收一部分数据（示例3）。从设备的配置不由SoundWire子系统API处理，而是由snd_soc_dai_set_tdm_slot() API处理。平台或机器驱动程序通常会配置使用的插槽。对于示例4，所有设备将使用相同的插槽，而对于示例3，从设备1将使用例如插槽0，而从设备2将使用插槽1。
注3：多个Sink端口可以从SoundWire帧中的同一bitSlots提取相同的信息，但多个Source端口应配置不同的bitSlot配置。这是与I2S/PCM TDM使用情况相同的限制。
SoundWire流管理流程
=======================

流定义
------------------

  (1) 当前流：这是指需要进行操作的流，如准备、启用、禁用、解除准备等。
(2) 活动流：这是指除了当前流之外已经在总线上活跃的流。总线上可以有多个活动流。
SoundWire总线管理总线上渲染或捕获的每个流的流操作。本节解释了总线为分配或释放总线上的每个流所执行的操作。下面是总线为每个音频流维护的流状态。

SoundWire流状态
-----------------------

下面显示了SoundWire流状态及其状态转换图。::

	+-----------+     +------------+     +----------+     +----------+
	| 分配状态 +---->| 配置状态 +---->| 准备状态 +---->| 启用状态  |
	|   状态   |     |    状态   |     |  状态   |     |  状态   |
	+-----------+     +------------+     +---+--+---+     +----+-----+
	                                         ^  ^              ^
				                 |  |              |
				               __|  |___________   |
				              |                 |  |
	                                      v                 |  v
	         +----------+           +-----+------+        +-+--+-----+
	         | 释放状态 |<----------+ 解除准备 |<-------+ 禁用状态 |
	         |   状态   |           |   状态    |        |  状态   |
	         +----------+           +------------+        +----------+

注意：`SDW_STREAM_ENABLED`和`SDW_STREAM_DISABLED`之间的状态转换仅在ALSA/ASoC级别支持INFO_PAUSE标志时相关。同样，`SDW_DISABLED_STATE`和`SDW_PREPARED_STATE`之间的转换取决于INFO_RESUME标志。
注意2：框架实现了基本的状态转换检查，但例如不会检查从DISABLED到ENABLED的转换是否在特定平台上有效。此类测试需要在ALSA/ASoC级别添加。
### 流状态操作

以下部分解释了总线在主设备（Master）和从设备（Slave）上执行的操作，这些操作是流状态转换的一部分。

#### SDW_STREAM_ALLOCATED

这是流的分配状态。这是流的初始状态。进入此状态之前执行的操作如下：

1. 为流分配一个运行时。该流运行时将作为对流执行的所有操作的参考。
2. 分配并初始化用于保存流运行时信息所需的资源。这些资源保存所有与流相关的信息，例如流类型（PCM/PDM）及其参数、与流关联的主设备和从设备接口、流的状态等。

当上述所有操作成功后，设置流的状态为`SDW_STREAM_ALLOCATED`。

总线实现了以下API来分配一个流，该API需要为每个流调用一次。从ASoC DPCM框架的角度来看，此流状态可能与`.startup()`操作相关联。
```c
int sdw_alloc_stream(char * stream_name);
```

SoundWire核心提供了一个`sdw_startup_stream()`辅助函数，通常在dailink `.startup()`回调中调用，它执行流分配并为与流连接的所有DAI设置流指针。

#### SDW_STREAM_CONFIGURED

这是流的配置状态。进入此状态之前执行的操作如下：

1. 更新在`SDW_STREAM_ALLOCATED`状态下为流信息分配的资源。这包括流参数、当前流关联的主设备和从设备的运行时信息。
2. 与当前流关联的所有主设备和从设备向总线提供端口信息，包括主设备和从设备为当前流分配的端口号及其通道掩码。

当上述所有操作成功后，设置流的状态为`SDW_STREAM_CONFIGURED`。

总线实现了以下API以实现CONFIG状态，这些API需要由与流关联的相应主设备和从设备调用。这些API只能由相应的主设备和从设备各调用一次。从ASoC DPCM框架的角度来看，此流状态与`.hw_params()`操作相关联。
```c
int sdw_stream_add_master(struct sdw_bus *bus,
		struct sdw_stream_config *stream_config,
		const struct sdw_ports_config *ports_config,
		struct sdw_stream_runtime *stream);

int sdw_stream_add_slave(struct sdw_slave *slave,
		struct sdw_stream_config *stream_config,
		const struct sdw_ports_config *ports_config,
		struct sdw_stream_runtime *stream);
```

### SDW_STREAM_PREPARED
#### 准备流的状态。进入此状态前执行的操作包括：

  - (0) 在恢复操作中省略步骤1和2，因为此时已知总线带宽。
  - (1) 根据当前流以及总线上已激活的流来计算总线参数（如带宽、帧形状、时钟频率）。需要重新计算以适应总线上的当前流。
  - (2) 计算所有主设备(Master)和从设备(Slave)端口的传输和端口参数，这些参数基于步骤1中计算出的帧形状和时钟频率。
  - (3) 将计算出的总线和传输参数编程到主设备和从设备寄存器中。对备用寄存器组进行编程（即当前未使用的寄存器组）。在备用寄存器组（当前未使用的）中为已激活的流启用端口，这样不会影响已激活的流。
  - (4) 当所有值都编程完成后，总线发起切换到备用寄存器组，在那里所有新编程的值开始生效。
  - (5) 通过编程PrepareCtrl寄存器为当前流准备主设备和从设备的端口。

当上述所有操作成功后，将流的状态设置为 `SDW_STREAM_PREPARED`。总线实现了以下API来处理“准备”状态，每个流需要调用一次。从ASoC DPCM框架来看，这个流状态与`.prepare()`操作相关联。由于`.trigger()`操作可能不紧随`.prepare()`之后，因此允许直接从 `SDW_STREAM_PREPARED` 到 `SDW_STREAM_DEPREPARED` 的转换。

```c
int sdw_prepare_stream(struct sdw_stream_runtime *stream);
```

### SDW_STREAM_ENABLED
#### 启用流的状态。在此状态下数据端口被启用。
进入此状态前执行的操作：

1. 在`SDW_STREAM_PREPARED`状态下计算的所有值都被编程到备用银行（当前未使用的银行）。这包括已经激活的流也同样被编程。
2. 当前流的所有主端口(Master)和从端口(Slave)在备用银行（当前未使用的银行）上通过编程ChannelEn寄存器被启用。
3. 编程所有值后，总线发起切换到备用银行，在那里所有新编程的值生效，并且与当前流相关的端口被启用。

完成上述所有操作后，流的状态设置为`SDW_STREAM_ENABLED`。

总线为ENABLE状态实现了以下API，该API需要针对每个流调用一次。从ASoC DPCM框架来看，这个流状态与`.trigger()`启动操作关联。
```c
int sdw_enable_stream(struct sdw_stream_runtime *stream);
```

`SDW_STREAM_DISABLED`
~~~~~~~~~~~~~~~~~~~~

流的禁用状态。退出此状态时，数据端口被禁用。

进入此状态前执行的操作：

1. 当前流的所有主端口(Master)和从端口(Slave)在备用银行（当前未使用的银行）上通过编程ChannelEn寄存器被禁用。
2. 总线和已激活流的所有当前配置被编程到备用银行（当前未使用的银行）。
3. 编程所有值后，总线发起切换到备用银行，在那里所有新编程的值生效，并且与当前流相关的端口被禁用。

完成上述所有操作后，流的状态设置为`SDW_STREAM_DISABLED`。
以下是提供的API和状态描述的中文翻译：

### SDW_STREAM_DISABLED 状态
总线实现了以下API以支持 DISABLED 状态，该API需要为每个流调用一次。从 ASoC DPCM 框架的角度来看，这个流状态与 `.trigger()` 的停止操作相关联。
当支持 `INFO_PAUSE` 标志时，可以直接从 `DISABLED` 状态转换到 `SDW_STREAM_ENABLED` 状态。
对于恢复操作（ASoC 将使用 `.prepare()` 回调函数），流可以从 `SDW_STREAM_DISABLED` 状态转换到 `SDW_STREAM_PREPARED` 状态，所有必需的设置都已恢复，但不更新带宽和位分配。

```c
int sdw_disable_stream(struct sdw_stream_runtime *stream);
```

### SDW_STREAM_DEPREPARED 状态
这是流的去准备状态。在进入此状态之前执行的操作如下：

1. 对于当前流中的所有主设备和从设备端口，通过编程 PrepareCtrl 寄存器进行去准备。
2. 减少当前流的有效载荷带宽，从总带宽需求中减去，并通过执行银行切换等操作计算新的参数并应用。

完成上述所有操作后，流的状态被设置为 `SDW_STREAM_DEPREPARED`。
总线实现了以下API来支持 DEPREPARED 状态，该API需要为每个流调用一次。ALSA/ASoC 没有“去准备”这一概念，因此从这个流状态到 ALSA/ASoC 操作的映射可能是实现特定的。
当支持 `INFO_PAUSE` 标志时，流状态与 `.hw_free()` 操作关联 —— 在 `TRIGGER_STOP` 时不执行去准备操作。
其他实现在 `TRIGGER_STOP` 时可能会过渡到 `SDW_STREAM_DEPREPARED` 状态，如果他们需要经过 `SDW_STREAM_PREPARED` 状态的话。

```c
int sdw_deprepare_stream(struct sdw_stream_runtime *stream);
```

### SDW_STREAM_RELEASED 状态
这是流的释放状态。在进入此状态之前执行的操作如下：

1. 释放所有与当前流相关的主设备和从设备端口资源。
(2) 释放与当前流关联的主控器(Master)和从属设备(Slave)的运行时资源。
(3) 释放与当前流关联的流运行时资源。
在上述所有操作成功后，流的状态被设置为 `SDW_STREAM_RELEASED`。

总线(Bus)实现了以下适用于`RELEASE`状态的API，这些API需要被与该流关联的所有主控器和从属设备调用。从ASoC DPCM框架的角度来看，这个流状态与`.hw_free()`操作相关联。
.. code-block:: c

  int sdw_stream_remove_master(struct sdw_bus *bus,
		struct sdw_stream_runtime *stream);
  int sdw_stream_remove_slave(struct sdw_slave *slave,
		struct sdw_stream_runtime *stream);

`.shutdown()` ASoC DPCM操作会调用下面的总线API来释放作为`ALLOCATED`状态一部分分配给流的资源。
在`.shutdown()`中，维护流状态的数据结构会被释放。
.. code-block:: c

  void sdw_release_stream(struct sdw_stream_runtime *stream);

SoundWire核心提供了一个`sdw_shutdown_stream()`辅助函数，通常在dailink的`.shutdown()`回调中调用，它清除与流相连的所有DAIS上的流指针，并释放为该流分配的内存。
不支持的功能
===============

1. 不支持单个端口具有多个通道并同时用于两个或多个流之间或跨流使用。例如，一个具有4个通道的端口不能用来处理2个独立的立体声流，即使理论上在SoundWire中这是可行的。
