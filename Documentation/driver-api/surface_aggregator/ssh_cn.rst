### SPDX 许可证标识符: GPL-2.0+

### 定义替换:
.. |u8| replace:: :c:type:`u8 <u8>`
.. |u16| replace:: :c:type:`u16 <u16>`
.. |TYPE| replace:: ``TYPE``
.. |LEN| replace:: ``LEN``
.. |SEQ| replace:: ``SEQ``
.. |SYN| replace:: ``SYN``
.. |NAK| replace:: ``NAK``
.. |ACK| replace:: ``ACK``
.. |DATA| replace:: ``DATA``
.. |DATA_SEQ| replace:: ``DATA_SEQ``
.. |DATA_NSQ| replace:: ``DATA_NSQ``
.. |TC| replace:: ``TC``
.. |TID| replace:: ``TID``
.. |SID| replace:: ``SID``
.. |IID| replace:: ``IID``
.. |RQID| replace:: ``RQID``
.. |CID| replace:: ``CID``

===========================
Surface 串行集线器协议
===========================

Surface 串行集线器（SSH）是新型 Surface 系列设备中嵌入式 Surface 集合模块控制器（SAM 或 EC）的中心通信接口。我们将此协议和接口称为 SAM-over-SSH，与旧版本的 SAM-over-HID 相区别。在使用 SAM-over-SSH 的 Surface 设备上，SAM 通过 UART 连接到主机，并在 ACPI 中定义为具有 ID `MSHW0084` 的设备。在这些设备上，SAM 提供了大量功能，包括访问电池和电源信息及事件、温度读数和事件等。对于 Surface 笔记本电脑，键盘输入通过 SAM 处理；在 Surface 笔记本电脑 3 和 Surface Book 3 上，这也包括触摸板输入。

请注意，本子系统的一般免责声明同样适用于本文档：所有这些都是逆向工程的结果，因此可能存在错误和/或不完整。

所有下面提到的 CRC 值都是使用两字节的 `crc_itu_t(0xffff, ...)`。
所有多字节值采用小端格式，值之间没有隐含的填充。

SSH 数据包协议：定义
======================

SSH 协议的基本通信单元是帧（:c:type:`struct ssh_frame <ssh_frame>`）。一个帧由以下字段组成，这些字段按顺序紧密排列：

.. flat-table:: SSH 帧
   :widths: 1 1 4
   :header-rows: 1

   * - 字段
     - 类型
     - 描述

   * - |TYPE|
     - |u8|
     - 帧类型标识符
   * - |LEN|
     - |u16|
     - 与该帧关联的有效载荷长度
   * - |SEQ|
     - |u8|
     - 序列ID（见下文解释）

每个帧结构后面都跟着一个覆盖该结构的 CRC 值。覆盖帧结构（|TYPE|、|LEN| 和 |SEQ| 字段）的 CRC 值直接位于帧结构之后，在有效载荷之前。有效载荷后面跟着它自己的 CRC 值（覆盖所有有效载荷字节）。如果有效载荷不存在（即帧的 `LEN=0`），有效载荷的 CRC 值仍然存在，并且其值为 `0xffff`。|LEN| 字段不包括任何 CRC 值，它等于帧的 CRC 到有效载荷的 CRC 之间的字节数。
此外，以下固定的两字节序列被使用：

.. flat-table:: SSH 字节序列
   :widths: 1 1 4
   :header-rows: 1

   * - 名称
     - 值
     - 描述

   * - |SYN|
     - ``[0xAA, 0x55]``
     - 同步字节

一条消息由 |SYN| 开始，接着是帧（|TYPE|, |LEN|, |SEQ| 和
CRC）以及如果帧中指定了长度（即 ``LEN > 0``），则有负载字节，
最后无论是否有负载都包含负载的CRC。与一个交换相关的消息部分地通过具有相同的序列ID（|SEQ|）来识别，
该序列ID存储在帧内（更多细节将在下一节中说明）。序列ID是一个循环计数器。
帧可以有以下类型
(:c:type:`enum ssh_frame_type <ssh_frame_type>`):

.. flat-table:: SSH 帧类型
   :widths: 1 1 4
   :header-rows: 1

   * - 名称
     - 值
     - 简要描述

   * - |NAK|
     - ``0x04``
     - 在接收到的消息出错时发送
* - |ACK|
     - ``0x40``
     - 用于确认接收 |DATA| 帧
* - |DATA_SEQ|
     - ``0x80``
     - 用于传输数据。有序
* - |DATA_NSQ|
     - ``0x00``
     - 与 |DATA_SEQ| 相同，但不需要被确认（ACK）

|NAK|-和|ACK|-类型的帧用于控制消息流，因此不携带负载。而|DATA_SEQ|-和|DATA_NSQ|-类型的帧必须携带负载。不同帧类型之间的流程序列和交互将在下一节中更详细地描述。

SSH 数据包协议：流程序列
=============================

每次交换以 |SYN| 开始，接着是一个 |DATA_SEQ|-或|DATA_NSQ|-类型的帧，随后是帧CRC、负载和负载CRC。如果是|DATA_NSQ|-类型的帧，则交换结束。如果是|DATA_SEQ|-类型的帧，则接收方必须通过带有与|DATA|帧相同序列ID的|ACK|-类型帧的消息来确认帧的接收。换句话说，|ACK|帧的序列ID指明了要确认的|DATA|帧。在出现错误的情况下，例如无效的CRC，接收方将通过包含|NAK|-类型帧的消息作出响应。由于无法依赖|NAK|帧所指示的前一数据帧的序列ID，|NAK|帧的序列ID不应被使用并设置为零。接收到|NAK|帧后，发送方应重新发送所有未被确认的消息。
序列ID在双方之间不是同步的，这意味着它们各自独立管理。因此，确定单次交换中的相关消息依赖于序列ID、消息类型及上下文。具体来说，序列ID用于将“ACK”与相应的“|DATA_SEQ|”类型帧关联起来，但不用于将“|DATA_SEQ|”-或“|DATA_NSQ|”-类型帧与其他“DATA”类型帧关联起来。

一次示例交换可能如下所示：

::

    发送: -- SYN FRAME(D) CRC(F) PAYLOAD CRC(P) -----------------------------
    接收: ------------------------------------- SYN FRAME(A) CRC(F) CRC(P) --

其中两个帧具有相同的序列ID（``SEQ``）。这里，“FRAME(D)”表示|DATA_SEQ|-类型的帧，“FRAME(A)”表示“ACK”类型的帧，“CRC(F)”表示对前一帧的CRC，“CRC(P)”表示对前一负载的CRC。在发生错误的情况下，交换可能如下所示：

::

    发送: -- SYN FRAME(D) CRC(F) PAYLOAD CRC(P) -----------------------------
    接收: ------------------------------------- SYN FRAME(N) CRC(F) CRC(P) --

之后发送方应该重发该消息。“FRAME(N)”表示|NAK|-类型的帧。需要注意的是，|NAK|-类型帧的序列ID固定为零。对于|DATA_NSQ|-类型的帧，这两种交换情况是一样的：

::

    发送: -- SYN FRAME(DATA_NSQ) CRC(F) PAYLOAD CRC(P) ----------------------
    接收: -------------------------------------------------------------------

这里，可以检测到错误，但不能纠正或向发送方指示这些错误。这些交换是对称的，即交换“接收”和“发送”的位置仍然会产生有效的交换。目前未知是否存在更长的交换。
命令：请求、响应与事件
=========================================

命令作为数据帧的有效载荷发送。目前，这是已知的 |DATA| 帧的唯一有效载荷类型，具有值为 ``0x80`` 的有效载荷类型（:c:type:`SSH_PLD_TYPE_CMD <ssh_payload_type>`）。
命令类型的有效载荷（:c:type:`struct ssh_command <ssh_command>`）由一个八字节的命令结构组成，其后跟着可选的和可变长度的命令数据。这个可选数据的长度来源于相应帧中给出的帧有效载荷长度，即 ``frame.len - sizeof(struct ssh_command)``。命令结构包含以下字段，这些字段被组合在一起且顺序排列：

.. flat-table:: SSH 命令
   :widths: 1 1 4
   :header-rows: 1

   * - 字段
     - 类型
     - 描述

   * - |TYPE|
     - |u8|
     - 有效载荷的类型。对于命令始终为 ``0x80``
* - |TC|
     - |u8|
     - 目标类别
* - |TID|
     - |u8|
     - 命令/消息的目标ID
* - |SID|
     - |u8|
     - 命令/消息的源ID
* - |IID|
     - |u8|
     - 实例ID
* - |RQID|
     - |u16|
     - 请求ID
* - |CID|
     - |u8|
     - 命令ID
通常情况下，命令结构和数据不包含任何故障检测机制（例如CRC校验），这完全是在帧级别完成的。
命令类型的有效载荷被主机用来向EC发送命令和请求，同时也被EC用来向主机发送响应和事件。
我们区分了请求（由主机发送）、响应（由EC在收到请求后发送）和事件（由EC在未收到请求的情况下发送）。
命令和事件通过其目标类别（“TC”）和命令ID（“CID”）唯一标识。目标类别指定了命令的一般类别（例如，系统总体、电池与交流电、温度等），而命令ID则指定了该类别中的具体命令。只有|TC| + |CID|的组合是唯一的。此外，命令有一个实例ID（“IID”），用于区分不同的子设备。例如，“TC=3” “CID=1”是一个获取热传感器温度的请求，其中|IID|指定了具体的传感器。如果未使用实例ID，则应将其设置为零。如果使用了实例ID，它们通常从一个值开始，而零可用于不依赖实例的查询（如适用）。对请求的响应应该具有相同的目标类别、命令ID和实例ID。
响应与其对应的请求通过请求ID（“RQID”）字段匹配。这是一个16位循环计数器，类似于帧中的序列ID。需要注意的是，对于请求-响应对而言，帧的序列ID并不匹配。仅需请求ID匹配即可。从协议角度来看，这些是两个独立的交换过程，并且甚至可以被分隔开，例如，在请求之后但响应之前发送事件。并非所有命令都会产生响应，而这无法仅通过|TC| + |CID|来检测。发出命令的一方有责任等待响应（或向通信框架发出信号，就像在SAN/ACPI中通过“SNC”标志那样）。
事件通过唯一且保留的请求ID进行标识。这些ID不应由主机在发送新请求时使用。它们首先用于在主机上检测事件，其次用于将事件与已注册的事件处理程序匹配。事件的请求ID由主机选择，并在设置和启用事件源（通过启用事件源请求）时指向EC。然后，EC使用指定的请求ID来发送来自相应源的事件。需要注意的是，事件仍然应通过其目标类别、命令ID以及（如适用）实例ID进行标识，因为单个事件源可以发送多种不同类型的事件。然而，一般来说，单一的目标类别应映射到单一的保留事件请求ID。
此外，请求、响应和事件都有关联的目标ID（“TID”）和源ID（“SID”）。这两个字段指示消息的来源（“SID”）以及消息预期的目标（“TID”）。需要注意的是，对特定请求的响应相比原始请求，其源和目标ID互换了（即，请求的目标是响应的源，而请求的源是响应的目标）。
请参阅（:c:type:`enum ssh_request_id <ssh_request_id>`）以了解这两者的可能值。
需要注意的是，尽管请求和事件仅通过目标类别和命令ID就能唯一识别，但EC可能需要特定的目标ID和实例ID才能接受命令。例如，对于“TID=1”可接受的命令可能对于“TID=2”不被接受，反之亦然。虽然这在现实中并不总是成立，但你可以认为不同的目标/源ID表示不同的物理EC，它们可能具有不同的功能集。

### 限制和观察

理论上，该协议可以并行处理最多`U8_MAX`个帧，并且可以处理最多`U16_MAX`个挂起的请求（忽略为事件预留的请求ID）。然而，在实践中这一限制更为严格。根据我们的测试（尽管是通过Python用户空间程序进行的），EC似乎可以在特定时间内可靠地并行处理最多四个请求。当五个或更多请求同时进行时，已经观察到一致地丢弃命令的情况（确认帧但没有命令响应）。对于五个同时的命令，这可重现地导致一个命令被丢弃，而其余四个命令被处理。
然而，也有人指出，即使有三个请求同时进行，
偶尔仍会出现帧丢失的情况。除此之外，在待处理请求限制为三个的情况下，
没有观察到丢弃命令的情况（即：命令被丢弃但携带该命令的帧被确认）。无论如何，如果超过了特定的超时时间，主机应当重新发送帧（以及可能的命令）。对于帧而言，EC 会在一秒的超时后执行重发操作，最多尝试两次重发（即总共传输三次）。重试次数的限制同样适用于接收到的否定确认（NAK），在最坏的情况下，可能导致整条消息被丢弃。
虽然这似乎对等待中的数据帧也能正常工作，只要不发生传输失败，但其实现和处理似乎依赖于只有一个未被确认的数据帧的假设。
特别是，重复帧的检测依赖于最后的序列号。这意味着，如果一个已被 EC 成功接收的帧再次被发送，例如由于主机未收到确认（ACK），那么 EC 只有在其具有 EC 收到的最后一个帧的序列 ID 的情况下才能检测到这一点。举个例子：发送两个帧，序列号分别为“SEQ=0”和“SEQ=1”，然后重复发送“SEQ=0”，将无法检测到第二个“SEQ=0”帧，因此会每次接收到该帧时都执行其中的命令，即在这个例子中执行两次。而发送“SEQ=0”、“SEQ=1”，然后重复发送“SEQ=1”，则可以检测到第二个“SEQ=1”是第一个的重复，并忽略它，从而只执行一次其中的命令。
综上所述，这表明最多只能有一个待处理的未被确认的帧（每方，实际上导致关于帧的同步通信）和最多三个待处理的命令。对于同步帧传输的限制似乎与在 Windows 上观察到的行为一致。
