SPDX 许可证标识符: GPL-2.0+

.. |__u16| replace:: :c:type:`__u16 <__u16>`
.. |sdtx_event| replace:: :c:type:`struct sdtx_event <sdtx_event>`
.. |sdtx_event_code| replace:: :c:type:`enum sdtx_event_code <sdtx_event_code>`
.. |sdtx_base_info| replace:: :c:type:`struct sdtx_base_info <sdtx_base_info>`
.. |sdtx_device_mode| replace:: :c:type:`struct sdtx_device_mode <sdtx_device_mode>`

======================================================
用户空间 DTX（剪贴板脱离系统）接口
======================================================

`surface_dtx` 驱动负责正确处理剪贴板的脱离和重新连接。为此，它提供了 `/dev/surface/dtx` 设备文件，通过该文件可以与用户空间守护进程进行交互。这个守护进程最终负责确定并采取必要的行动，例如卸载连接到基座上的设备、卸载/重新加载图形驱动程序、用户通知等。
在本驱动中有两种基本通信原则：命令（在文档的其他部分有时也称为请求）和事件。命令发送给EC，并且在不同上下文中可能有不同的含义。当EC内部状态发生变化时，会发送事件。命令总是由驱动程序发起，而事件则总是由EC发起。
.. contents::

术语
============

* **剪贴板：**
  Surface Book 的可拆卸上半部分，其中安装了屏幕和CPU。
* **基座：**
  Surface Book 的下半部分，从其中可以拆卸剪贴板；根据型号的不同，可能还装有独立显卡（dGPU）。
* **锁扣：**
  在正常运行时将剪贴板固定在基座上的机制，并允许在请求时拆卸。
* **静默忽略的命令：**
  命令被EC接受为有效命令并得到确认（遵循标准通信协议），但EC不会对其采取任何行动，即忽略它。

脱离过程
==================

警告: 本部分文档基于逆向工程和测试，因此可能存在错误或不完整。
锁扣状态
------------

锁扣机构有两种主要状态：*打开* 和 *关闭*。在 *关闭* 状态（默认），剪贴板被固定在基座上，而在 *打开* 状态下，用户可以移除剪贴板。
锁扣还可以锁定和解锁，这可能会影响脱离过程。具体来说，这种锁定机制旨在防止位于设备基座中的dGPU在使用中热拔插。更多细节可以在下面的脱离过程文档中找到。默认情况下，锁扣是解锁的。
脱离过程
--------------------

需要注意的是，脱离过程完全由EC控制。`surface_dtx` 驱动仅将EC的事件转发给用户空间并将用户空间的命令转发给EC，也就是说，它并不影响这一过程。
脱离过程开始于用户按下设备基座上的 *脱离* 按钮或执行 `SDTX_IOCTL_LATCH_REQUEST` IOCTL。
按照以下步骤进行：

1. EC（嵌入式控制器）会打开拆卸按钮上的指示灯 LED，并发送一个*拆卸请求*事件（`SDTX_EVENT_REQUEST`），然后等待进一步的指令/命令。如果锁扣处于解锁状态，LED 将闪烁绿色；如果锁扣已被锁定，则 LED 将显示稳定的红色。

2. 该事件通过 `surface_dtx` 驱动程序传递到用户空间，在那里适当的用户空间守护进程可以处理该事件，并通过此驱动程序提供的 IOCTLs 向 EC 发送指令。
3. EC 等待来自用户空间的指令，并根据这些指令采取行动。如果在给定的时间内 EC 没有收到任何指令，它将超时并继续如下操作：

   - 如果锁扣处于解锁状态，EC 将打开锁扣，从而使剪贴板可以从底座上拆卸下来。这与没有使用此驱动程序或任何用户空间守护进程时的行为相同。有关 EC 后续行为的更多详细信息，请参见下面的 `SDTX_IOCTL_LATCH_CONFIRM` 描述。
   - 如果锁扣被锁定，EC *不会* 打开锁扣，这意味着剪贴板不能从底座上拆卸下来。此外，EC 会发送一个取消事件（`SDTX_EVENT_CANCEL`），其中包含取消原因 `SDTX_DETACH_TIMEDOUT` 的详细信息（请参阅 :ref:`events` 获取详细信息）。

对于拆卸请求事件，用户空间守护进程的有效响应包括：

- 执行 `SDTX_IOCTL_LATCH_REQUEST`。这将立即终止拆卸过程。此外，EC 将发送一个拆卸请求事件，类似于用户按下拆卸按钮来取消这个过程（参见下文）。
- 执行 `SDTX_IOCTL_LATCH_CONFIRM`。这将导致 EC 打开锁扣，之后用户可以分离剪贴板和底座。
由于这会改变锁扣的状态，一旦锁扣成功打开后会发送一个 *锁扣状态* 事件（`SDTX_EVENT_LATCH_STATUS`）。如果 EC 无法打开锁扣，例如因为硬件故障或电池电量低，将会发送一个锁扣取消事件（`SDTX_EVENT_CANCEL`），其中取消原因会表明具体的失败原因。
如果当前锁扣是锁定状态，锁扣会在打开前自动解锁。
- 执行 `SDTX_IOCTL_LATCH_HEARTBEAT`。这将重置内部超时时间。
除此之外没有其他动作执行，即拆卸过程既不会完成也不会取消，EC 仍将等待进一步的响应。
执行 ``SDTX_IOCTL_LATCH_CANCEL``。这将中止脱离过程，类似于上面描述的 ``SDTX_IOCTL_LATCH_REQUEST`` 或下面描述的按钮按下操作。作为对此的响应，会发送一个 *通用请求* 事件（``SDTX_EVENT_REQUEST``）。然而，与那些不同的是，此命令在没有正在进行的脱离过程时不会触发新的脱离过程。
- 不执行任何操作。脱离过程最终会如第 3 点所述超时。
有关这些响应的更多详细信息，请参阅 :ref:`ioctls`
值得注意的是，如果用户在脱离操作进行中的任何时候按下脱离按钮（即，在EC发送初始 *脱离请求* 事件（``SDTX_EVENT_REQUEST``）之后且收到结束该过程的相应响应之前），EC 层面将取消脱离过程，并发送一个相同的事件。因此，一个 *脱离请求* 事件本身并不表示脱离过程的开始。
由于硬件故障或剪贴板电池电量低，EC 可能进一步取消脱离过程。这是通过带有相应取消原因的取消事件（``SDTX_EVENT_CANCEL``）完成的。

用户空间接口文档
==================

错误代码和状态值
------------------

错误和状态代码被分为不同的类别，可以用来确定状态代码是否为错误，如果是，则确定错误的严重性和类型。当前的类别包括：

.. flat-table:: 状态/错误类别的概览
:widths: 2 1 3
   :header-rows: 1

   * - 名称
     - 值
     - 简短描述

   * - ``STATUS``
     - ``0x0000``
     - 非错误状态代码
* - ``RUNTIME_ERROR``
     - ``0x1000``
     - 非关键运行时错误
* - ``HARDWARE_ERROR``
     - ``0x2000``
     - 关键硬件故障
* - ``UNKNOWN``
     - ``0xF000``
     - 未知错误代码
其他类别保留供将来使用。可以通过使用 ``SDTX_CATEGORY()`` 宏来确定任何状态值的类别。可以通过使用 ``SDTX_SUCCESS()`` 宏来检查状态值是否为成功值（``SDTX_CATEGORY_STATUS``）或其是否指示失败。由EC发送的未知状态或错误代码被驱动程序分配到 ``UNKNOWN`` 类别，并且将来可能通过它们自己的代码实现。
当前使用的错误代码如下：

.. 平面表格 :: 错误代码概览
:宽度: 2 1 1 3
   :表头行: 1

   * - 名称
     - 类别
     - 值
     - 简短描述

   * - ``SDTX_DETACH_NOT_FEASIBLE``
     - ``运行时``
     - ``0x1001``
     - 由于剪贴板电池电量低，无法实现分离
* - ``SDTX_DETACH_TIMEDOUT``
     - ``运行时``
     - ``0x1002``
     - 在锁定销子时分离过程超时
* - ``SDTX_ERR_FAILED_TO_OPEN``
     - ``硬件``
     - ``0x2001``
     - 打开销子失败
* - ``SDTX_ERR_FAILED_TO_REMAIN_OPEN``
     - ``硬件``
     - ``0x2002``
     - 保持销子打开失败
* - ``SDTX_ERR_FAILED_TO_CLOSE``
     - ``硬件``
     - ``0x2003``
     - 关闭销子失败
其他错误代码保留供将来使用。非错误的状态代码可能会重叠，并且通常只在其使用场景内是唯一的。

.. 平面表格 :: 销子状态代码
```plaintext
:widths: 2 1 1 3
:header-rows: 1

* - 名称
  - 类别
  - 值
  - 简短描述

* - ``SDTX_LATCH_CLOSED``
  - ``状态``
  - ``0x0000``
  - 锁定装置已关闭/已被关闭
* - ``SDTX_LATCH_OPENED``
  - ``状态``
  - ``0x0001``
  - 锁定装置已打开/已被打开
.. flat-table:: 基本状态代码
:widths: 2 1 1 3
:header-rows: 1

* - 名称
  - 类别
  - 值
  - 简短描述

* - ``SDTX_BASE_DETACHED``
  - ``状态``
  - ``0x0000``
  - 基座已分离/不存在
* - ``SDTX_BASE_ATTACHED``
  - ``状态``
  - ``0x0001``
  - 基座已连接/存在
其他代码为将来使用预留。
.. _事件:

事件
------

可以通过从设备文件中读取来接收事件。默认情况下，事件是禁用的，并且必须通过执行``SDTX_IOCTL_EVENTS_ENABLE``来启用。所有事件都遵循|sdtx_event|规定的布局。特定的事件类型可以通过它们在|sdtx_event_code|中描述的事件代码来识别。请注意，其他事件代码为将来使用预留，因此事件解析器必须能够优雅地处理任何未知/不受支持的事件类型，依赖于事件头中给出的有效载荷长度。
当前提供的事件类型包括：

.. flat-table:: DTX事件概览
:widths: 2 1 1 3
:header-rows: 1

* - 名称
  - 代码
  - 有效载荷
  - 简短描述

* - ``SDTX_EVENT_REQUEST``
  - ``1``
  - ``0`` 字节
  - 分离过程已启动/中止
* - ``SDTX_EVENT_CANCEL``
  - ``2``
  - ``2`` 字节
  - EC 取消了分离过程
```
* - ``SDTX_EVENT_BASE_CONNECTION``
     - ``3``
     - ``4`` 字节
     - 基础连接状态改变
* - ``SDTX_EVENT_LATCH_STATUS``
     - ``4``
     - ``2`` 字节
     - 锁扣状态改变
* - ``SDTX_EVENT_DEVICE_MODE``
     - ``5``
     - ``2`` 字节
     - 设备模式改变
详细说明各个事件：

``SDTX_EVENT_REQUEST``
^^^^^^^^^^^^^^^^^^^^^^

当开始或正在进行分离过程时发送，如果用户通过按下分离按钮或从用户空间发送分离请求（``SDTX_IOCTL_LATCH_REQUEST``）来中止分离过程时也会发送。此事件没有负载。

``SDTX_EVENT_CANCEL``
^^^^^^^^^^^^^^^^^^^^^

当分离过程因未满足的前置条件（例如剪贴板电池电量过低无法分离）或硬件故障被EC取消时发送。取消的原因会在下面详细描述的事件负载中给出，可能是以下几种情况之一：

* ``SDTX_DETACH_TIMEDOUT``: 在锁扣锁定状态下分离超时；锁扣既没有打开也没有解锁。
* ``SDTX_DETACH_NOT_FEASIBLE``: 因剪贴板电池电量过低无法实现分离。
* ``SDTX_ERR_FAILED_TO_OPEN``: 无法打开锁扣（硬件故障）。
* ``SDTX_ERR_FAILED_TO_REMAIN_OPEN``: 无法保持锁扣处于打开状态（硬件故障）。
* ``SDTX_ERR_FAILED_TO_CLOSE``: 无法关闭卡扣（硬件故障）
在此上下文中的其他错误代码保留供将来使用。
这些代码可以通过``SDTX_CATEGORY()`` 宏进行分类，以区分
关键硬件错误（``SDTX_CATEGORY_HARDWARE_ERROR``）或
运行时错误（``SDTX_CATEGORY_RUNTIME_ERROR``），后者可能
在正常操作期间发生，如果未满足某些分离的先决条件的话。

.. 平面表格:: 分离取消事件负载
   :宽度: 1 1 4
   :表头行: 1

   * - 字段
     - 类型
     - 描述

   * - ``reason``
     - |__u16|
     - 取消的原因
``SDTX_EVENT_BASE_CONNECTION``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

当基础连接状态发生变化时发送，例如当底座已连接、断开连接，或者由于剪贴板电量低导致分离变得不可行。新的状态以及如果连接了底座，则提供类型为 |sdtx_base_info| 的负载中的底座ID，其布局如下：

.. 平面表格:: 基础连接变化事件负载
   :宽度: 1 1 4
   :表头行: 1

   * - 字段
     - 类型
     - 描述

   * - ``state``
     - |__u16|
     - 基础连接状态
* - ``base_id``
     - |__u16|
     - 连接的底座类型（如果没有连接则为零）
对于 ``state`` 的可能值有：

* ``SDTX_BASE_DETACHED``,
* ``SDTX_BASE_ATTACHED``, 和
* ``SDTX_DETACH_NOT_FEASIBLE``
其他值保留供将来使用
``SDTX_EVENT_LATCH_STATUS``
^^^^^^^^^^^^^^^^^^^^^^^^^^^

当卡扣状态发生变化时发送，例如当卡扣打开、关闭，或者发生错误。当前的状态作为负载提供：

.. 平面表格:: 卡扣状态变化事件负载
   :宽度: 1 1 4
   :表头行: 1

   * - 字段
     - 类型
     - 描述

   * - ``status``
     - |__u16|
     - 卡扣状态
对于 ``status`` 的可能值有：

* ``SDTX_LATCH_CLOSED``,
* ``SDTX_LATCH_OPENED``,
* ``SDTX_ERR_FAILED_TO_OPEN``,
* ``SDTX_ERR_FAILED_TO_REMAIN_OPEN``, 和
* ``SDTX_ERR_FAILED_TO_CLOSE``
其他值保留供将来使用。

``SDTX_EVENT_DEVICE_MODE``
^^^^^^^^^^^^^^^^^^^^^^^^^^

当设备模式发生变化时发送。新的设备模式作为负载提供：

.. flat-table:: 设备模式变更事件负载
   :widths: 1 1 4
   :header-rows: 1

   * - 字段
     - 类型
     - 描述

   * - ``mode``
     - |__u16|
     - 设备操作模式
对于 ``mode`` 的可能值有：

* ``SDTX_DEVICE_MODE_TABLET``,
* ``SDTX_DEVICE_MODE_LAPTOP``, 和
* ``SDTX_DEVICE_MODE_STUDIO``
其他值保留供将来使用。

.. _ioctls:

IOCTLs
------

提供的 IOCTL 如下：

.. flat-table:: DTX IOCTL 概览
   :widths: 1 1 1 1 4
   :header-rows: 1

   * - 类型
     - 编号
     - 方向
     - 名称
     - 描述

   * - ``0xA5``
     - ``0x21``
     - ``-``
     - ``EVENTS_ENABLE``
     - 为当前文件描述符启用事件
* - ``0xA5``
     - ``0x22``
     - ``-``
     - ``EVENTS_DISABLE``
     - 禁用当前文件描述符的事件
* - ``0xA5``
     - ``0x23``
     - ``-``
     - ``LATCH_LOCK``
     - 锁定搭扣
* - ``0xA5``
     - ``0x24``
     - ``-``
     - ``LATCH_UNLOCK``
     - 解锁搭扣
* - ``0xA5``
     - ``0x25``
     - ``-``
     - ``LATCH_REQUEST``
     - 请求剪贴板分离
* - ``0xA5``
     - ``0x26``
     - ``-``
     - ``LATCH_CONFIRM``
     - 确认剪贴板分离请求
* - ``0xA5``
     - ``0x27``
     - ``-``
     - ``LATCH_HEARTBEAT``
     - 向EC发送心跳信号
* - ``0xA5``
     - ``0x28``
     - ``-``
     - ``LATCH_CANCEL``
     - 取消分离过程
* - ``0xA5``
     - ``0x29``
     - ``R``
     - ``GET_BASE_INFO``
     - 获取当前的基础/连接信息
* - ``0xA5``
     - ``0x2A``
     - ``R``
     - ``GET_DEVICE_MODE``
     - 获取当前设备操作模式
* - ``0xA5``
     - ``0x2B``
     - ``R``
     - ``GET_LATCH_STATUS``
     - 获取当前设备锁扣状态
``SDTX_IOCTL_EVENTS_ENABLE``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IO(0xA5, 0x22)``
为当前文件描述符启用事件。如果已启用，可以通过从设备读取来获取事件。默认情况下事件是禁用的。
``SDTX_IOCTL_EVENTS_DISABLE``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IO(0xA5, 0x22)``
为当前文件描述符禁用事件。如果已启用，可以通过从设备读取来获取事件。默认情况下事件是禁用的。
``SDTX_IOCTL_LATCH_LOCK``
^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IO(0xA5, 0x23)``
锁定闩锁，导致分离过程在不打开闩锁的情况下中止。默认情况下，闩锁是解锁状态。如果闩锁已经锁定，此命令将被静默忽略。
``SDTX_IOCTL_LATCH_LOCK``
^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IO(0xA5, 0x24)``
解锁闩锁，导致分离过程在超时情况下打开闩锁。默认情况下，闩锁是解锁状态。当此命令在正在进行的分离过程中发送时，它不会打开闩锁。如果闩锁已经解锁，此命令将被静默忽略。
``SDTX_IOCTL_LATCH_UNLOCK``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IO(0xA5, 0x25)``
通用闩锁请求。行为取决于上下文：如果没有活动的分离过程，则请求进行分离。否则，当前活动的分离过程将被中止。
如果通过此操作取消了分离过程，则会发送一个通用分离请求事件（``SDTX_EVENT_REQUEST``）。
这本质上与按下分离按钮的行为相同。
``SDTX_IOCTL_LATCH_REQUEST``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IO(0xA5, 0x26)``
确认闩锁请求。如果在正在进行的分离过程中发送此命令，则立即打开闩锁。
即使闩锁已被锁定，也会打开闩锁。在这种情况下，闩锁的锁定状态会被重置为解锁状态。
``SDTX_IOCTL_LATCH_CONFIRM``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IO(0xA5, 0x26)``
此命令在当前没有正在进行的脱离过程时将被静默忽略。
``SDTX_IOCTL_LATCH_HEARTBEAT``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IO(0xA5, 0x27)``
发送心跳信号，实质上重置了脱离超时。此命令可以在为了使脱离成功所需的工作仍在进行时保持脱离过程的活性。
此命令在当前没有正在进行的脱离过程时将被静默忽略。
``SDTX_IOCTL_LATCH_CANCEL``
^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IO(0xA5, 0x28)``
取消正在进行中的脱离（如果有的话）。如果一个脱离过程被此操作取消，将会发送一个通用的脱离请求事件（``SDTX_EVENT_REQUEST``）。
此命令在当前没有正在进行的脱离过程时将被静默忽略。
``SDTX_IOCTL_GET_BASE_INFO``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IOR(0xA5, 0x29, struct sdtx_base_info)``
获取当前基础连接状态（即已连接/未连接）和与剪贴板相连的基础类型。此命令实质上提供了一种查询由基础连接变化事件（``SDTX_EVENT_BASE_CONNECTION``）提供的信息的方式。
``struct sdtx_base_info.state`` 的可能值包括：

* ``SDTX_BASE_DETACHED``,
* ``SDTX_BASE_ATTACHED``, 和
* ``SDTX_DETACH_NOT_FEASIBLE``
其他值保留供将来使用。

``SDTX_IOCTL_GET_DEVICE_MODE``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IOR(0xA5, 0x2A, __u16)``
返回设备的操作模式，指示底座是否以及如何连接到剪贴板。此命令本质上提供了一种方式来查询由设备模式更改事件（``SDTX_EVENT_DEVICE_MODE``）提供的信息。
返回的值包括：

* ``SDTX_DEVICE_MODE_LAPTOP``
* ``SDTX_DEVICE_MODE_TABLET``
* ``SDTX_DEVICE_MODE_STUDIO``

详情请参见 |sdtx_device_mode|。其他值保留供将来使用。

``SDTX_IOCTL_GET_LATCH_STATUS``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

定义为 ``_IOR(0xA5, 0x2B, __u16)``
获取当前的扣锁状态或（假设）尝试打开/关闭扣锁时遇到的最后一个错误。此命令本质上提供了一种方式来查询由扣锁状态更改事件（``SDTX_EVENT_LATCH_STATUS``）提供的信息。
返回的值包括：

* ``SDTX_LATCH_CLOSED``,
* ``SDTX_LATCH_OPENED``,
* ``SDTX_ERR_FAILED_TO_OPEN``,
* ``SDTX_ERR_FAILED_TO_REMAIN_OPEN``, 和
* ``SDTX_ERR_FAILED_TO_CLOSE``
其他值保留供将来使用。

关于底座ID的说明
------------------

通过 ``SDTX_EVENT_BASE_CONNECTION`` 或 ``SDTX_IOCTL_GET_BASE_INFO`` 提供的底座类型/ID直接从前端的EC（嵌入式控制器）转发，在组合的 |__u16| 值的低字节中，而驱动程序在高字节中存储了此ID来源的EC类型（如果没有这样做，不同类型的EC上的底座ID可能会重叠）。
可以使用 ``SDTX_DEVICE_TYPE()`` 宏来确定EC设备类型。这可以是以下之一：

* ``SDTX_DEVICE_TYPE_HID``，对于通过HID（人类接口设备）的Surface聚合模块，
* ``SDTX_DEVICE_TYPE_SSH``，对于通过Surface串行集线器的Surface聚合模块。
请注意，目前仅支持类型为``SSH``的EC更新，但是``HID``类型已被预留以供将来使用。

结构体与枚举类型
-------------------

.. kernel-doc:: include/uapi/linux/surface_aggregator/dtx.h

API使用者
==========

一个利用此API的用户空间守护进程可以在以下位置找到：
https://github.com/linux-surface/surface-dtx-daemon
