==============================
PXA/MMP - DMA 从属控制器
==============================

约束条件
===========

a) 热队列传输
提交并发出传输的驱动程序应当能够确保该传输即使在DMA通道运行时也能被排队。
这意味着队列操作不会等待前一个传输结束，并且描述符链不仅在由传输结束触发的中断/任务代码中完成。
提交并在物理层（phy）上发出的传输不会等待物理层停止和重新启动，而是提交在一个“运行中的通道”上。其他驱动程序，特别是mmp_pdma，在重新启动新传输之前会等待物理层停止。
b) 请求确认的所有传输都应被标记
任何带有DMA_PREP_INTERRUPT标志的已发出传输都应触发回调调用。
这意味着即使中断/任务是由tx1的结束触发的，但在中断/任务发生时tx2已经完成，tx1->complete() 和 tx2->complete() 都应该被调用。
c) 通道运行状态
驱动程序应当能够查询通道是否处于运行状态。对于多媒体应用，如视频捕获，如果提交了一个传输，然后检查DMA通道报告的是“已停止通道”，则不应发出该传输，直到下一个“帧开始中断”，因此需要知道通道是处于运行状态还是停止状态。
d) 带宽保证
PXA架构有四个级别的DMA优先级：高、正常、低。
高级别优先级的带宽是正常级别的两倍，而正常级别又是低级别的两倍。
驱动程序应当能够请求一个优先级，特别是实时类型的应用，比如pxa_camera，具有较高的吞吐量。

设计
======
a) 虚拟通道
与sa11x0驱动程序中的概念相同，即为驱动程序分配一个“虚拟通道”，该通道与请求线相关联，并且当发出传输时动态分配物理DMA通道。
b) 散集传输的解剖结构

:: 

   +------------+-----+---------------+----------------+-----------------+
   | desc-sg[0] | ... | desc-sg[last] | 状态更新器 | 完成器/链接器 |
   +------------+-----+---------------+----------------+-----------------+

此结构由 dma->sg_cpu 指向。
描述符的使用如下：

    - desc-sg[i]: 第 i 个描述符，将第 i 个散集元素传输到视频缓冲区的散集区域。

    - 状态更新器
      将一个单个的 u32 传输到一个已知的 DMA 相干内存中，以留下这个传输已完成的痕迹。这个“已知”地址对于每个物理通道是唯一的，这意味着读取这个值可以知道在该时刻最后一个完成的传输是什么。
      
    - 完成器: 具有 ddadr=DADDR_STOP, dcmd=ENDIRQEN

    - 链接器: 具有 ddadr= 下一个传输的 desc-sg[0], dcmd=0

c) 热链传输
假设运行中的链是：

:: 

   缓冲区 1              缓冲区 2
   +---------+----+---+  +----+----+----+---+
   | d0 | .. | dN | 链 |  | d0 | .. | dN | 完 |
   +---------+----+-|-+  ^----+----+----+---+
                    |    |
                    +----+

在调用 dmaengine_submit(b3) 后，链看起来像：

:: 

   缓冲区 1              缓冲区 2              缓冲区 3
   +---------+----+---+  +----+----+----+---+  +----+----+----+---+
   | d0 | .. | dN | 链 |  | d0 | .. | dN | 链 |  | d0 | .. | dN | 完 |
   +---------+----+-|-+  ^----+----+----+-|-+  ^----+----+----+---+
                    |    |                |    |
                    +----+                +----+
                                         新链

如果在创建新链时 DMA 通道停止，则不会重新启动它。热链传输不会打破需要使用 dma_async_issue_pending() 来确保实际开始传输这一假设。
例外情况为：

- 如果缓冲区1和缓冲区2的所有地址都是8字节对齐的

- 并且如果缓冲区3至少有一个地址不是4字节对齐的

- 则无法进行热链传输，因为通道必须停止，设置“对齐位”，并重新启动通道。因此，此类传输将在提交队列上排队，并且在这种特殊情况下，如果 DMA 已经以对齐模式运行。

d) 传输完成状态更新器
每当一个通道上的传输完成时，可能会或可能不会生成中断，这取决于客户的要求。但在每种情况下，传输的最后一个描述符（即“状态更新器”）都会将最新完成的传输写入物理通道的完成标记。
这对于大型传输（如包含大约 6K 个描述符或更多的视频缓冲区）的残留计算加速很有帮助。这也允许在没有任何锁的情况下确定正在进行的 DMA 链中最新的完成传输是什么。
e) 传输完成、中断与任务
当一个被标记为“DMA_PREP_INTERRUPT”的传输完成时，会触发 DMA 中断。当这个中断发生时，会为物理通道安排一个任务。
任务负责：

- 读取物理通道的最后更新标记

- 根据该标记以及每个传输的标志来调用所有已完成传输的回调函数
如果在处理过程中又有传输完成，则会再次触发 DMA 中断，并且任务将被重新安排，具有一个新的更新标记。
f) 残留
残留的粒度将以描述符为基础。已经发出但未完成的传输将针对当前正在运行的描述符进行扫描。
最复杂的驱动程序传输队列案例
最棘手的情况是：

- 没有“确认”的传输（tx0）

- 驱动程序提交了一个对齐的tx1，但没有进行链接

- 驱动程序提交了一个对齐的tx2 => tx2冷链接到tx1

- 驱动程序发出tx1+tx2 => 信道以对齐模式运行

- 驱动程序提交了一个对齐的tx3 => tx3热链接

- 驱动程序提交了一个未对齐的tx4 => tx4被放入已提交队列中，不进行链接

- 驱动程序发出tx4 => tx4被放入已发出队列中，不进行链接

- 驱动程序提交了一个对齐的tx5 => tx5被放入已提交队列中，不进行链接

- 驱动程序提交了一个对齐的tx6 => tx6被放入已提交队列中，冷链接到tx5

这转换为（在tx4发出后）：

- 已发出队列

```
+-----+ +-----+ +-----+ +-----+
| tx1 | | tx2 | | tx3 | | tx4 |
+---|-+ ^---|-+ ^-----+ +-----+
    |   |   |   |
    +---+   +---+
  - 已提交队列
+-----+ +-----+
| tx5 | | tx6 |
+---|-+ ^-----+
    |   |
    +---+
```

- 已完成队列：空

- 已分配队列：tx0

需要注意的是，在tx3完成后，信道会停止，并以“未对齐模式”重启来处理tx4。
作者：Robert Jarzmik <robert.jarzmik@free.fr>
