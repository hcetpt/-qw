DMA引擎控制器文档
==================

硬件介绍
========

大多数从属DMA控制器具有相同的基本操作原理。
它们具有用于DMA传输的特定数量的通道，以及特定数量的请求线。
请求和通道几乎是正交的。一个通道可以服务于任何多个请求。简单来说，通道是执行复制的实体，而请求则指出了涉及的端点。
请求线实际上对应于从符合条件的DMA设备到控制器本身的物理线路。每当设备想要开始一次传输时，它会通过断言该请求线来发出DMA请求（DRQ）。
一个非常简单的DMA控制器只会考虑一个参数：传输大小。在每个时钟周期中，它会将一个字节的数据从一个缓冲区传送到另一个缓冲区，直到达到传输大小为止。
这在现实世界中行不通，因为从属设备可能要求在一个时钟周期内传输特定数量的位。例如，在进行简单的内存复制操作时，我们可能希望尽可能多地传输数据以最大化性能，但我们的音频设备可能有一个较窄的FIFO（先进先出存储器），需要每次写入确切的16或24位数据。这就是为什么大多数（如果不是全部的话）DMA控制器可以调整这一点，使用一个叫做传输宽度的参数。
此外，一些DMA控制器，当RAM被用作源或目的地时，可以在内存中将读取或写入分组到一个缓冲区里，这样就不会有许多小规模的内存访问，而是有几个较大规模的传输，因为较小的内存访问效率不高。这是通过一个叫做突发大小的参数来实现的，该参数定义了控制器在将传输分割为更小的子传输之前允许执行多少单个读取/写入操作。
我们的理论上的DMA控制器只能处理涉及单一连续数据块的传输。然而，我们通常遇到的一些传输并不是这样的，而是需要从非连续缓冲区复制数据到连续缓冲区，这种操作被称为分散-聚集。
对于mem2dev传输，DMAEngine至少要求支持分散-聚集。因此，这里存在两种情况：要么我们有一个相当简单的DMA控制器，不支持分散-聚集功能，我们需要在软件中实现它；要么我们有一个更高级的DMA控制器，其在硬件层面实现了分散-聚集功能。
后一种通常是通过一系列要传输的数据块来编程的，并且一旦开始传输，控制器就会遍历这个系列，按照我们预先编程的方式进行操作。
此集合通常是一个表或链接列表。接下来，您需要将表的地址及其元素数量（如果是表的话），或者列表的第一个项目推送到DMA控制器的一个通道中。每当DRQ被激活时，它会遍历该集合以确定从何处获取数据。

无论哪种方式，此集合的格式完全取决于您的硬件。每个DMA控制器都需要不同的结构，但所有控制器对于每个数据块至少需要源地址和目标地址、是否应递增这些地址以及我们之前提到的三个参数：突发大小、传输宽度和传输大小。

最后一点是，通常情况下，从设备默认不会发出DRQ信号，您必须首先在从设备驱动程序中启用它，以便使用DMA。

以上只是关于内存到内存（也称为mem2mem）或内存到设备（mem2dev）这类传输的一般情况。大多数设备往往支持其他类型的传输或内存操作，dmaengine支持这些，并将在本文档稍后详细说明。

Linux中的DMA支持
==================

历史上，DMA控制器驱动程序使用异步TX API实现，用于卸载如内存复制、异或、加密等操作，基本上任何内存到内存的操作。
随着时间的推移，产生了内存到设备传输的需求，因此扩展了dmaengine。如今，异步TX API是在dmaengine之上编写的一个层，并作为客户端。尽管如此，在某些情况下，dmaengine仍然兼容该API，并作出了一些设计选择以确保其兼容性。
有关异步TX API的更多信息，请参阅相关文档文件Documentation/crypto/async-tx-api.rst。

DMAEngine API
=============

`struct dma_device` 初始化
-----------------------------

和其他内核框架一样，整个DMAEngine注册依赖于驱动程序填充一个结构体并针对框架进行注册。在我们的案例中，这个结构体是`dma_device`。
在驱动程序中，您首先需要分配这个结构体。您可以使用任何常规的内存分配器，但还需要初始化其中的一些字段：

- `channels`：应该使用例如INIT_LIST_HEAD宏初始化为一个列表

- `src_addr_widths`：应该包含支持的源传输宽度的位掩码

- `dst_addr_widths`：应该包含支持的目标传输宽度的位掩码

- `directions`：应该包含支持的从设备方向（即排除mem2mem传输）的位掩码

- `residue_granularity`：报告给`dma_set_residue`的传输残余的粒度
这可以是：

  - 描述符：您的设备不支持任何形式的残余报告。框架仅知道特定的事务描述符已完成
### 分段：
您的设备能够报告已传输的分段。

### 突发：
您的设备能够报告已传输的突发数据。

- `dev`：应持有指向与当前驱动实例相关的`struct device`结构的指针。

### 支持的交易类型
---------------------------

接下来需要做的是设置您的设备（和驱动程序）支持哪些交易类型。
我们的`dma_device`结构中有一个名为`cap_mask`的字段，用于保存各种支持的交易类型，您需要使用`dma_cap_set`函数来修改这个掩码，并根据支持的交易类型传递不同的标志。
所有这些能力都定义在`dma_transaction_type`枚举中，位于`include/linux/dmaengine.h`文件中。

目前可用的类型包括：

- **DMA_MEMCPY**
  
  - 设备能够执行内存到内存的复制。
  
  - 不论源和目标分段的总大小是多少，仅会传输两者中较小的那个的字节数。这意味着两个列表中的散列聚集缓冲区的数量和大小不必相同，并且该操作在功能上等同于一个`strncpy`调用，其中`count`参数等于两个散列聚集列表缓冲区中的较小总大小。
- 通常用于在主机内存和现代PCI视频显卡上的内存映射GPU设备内存之间复制像素数据。最直接的例子是OpenGL API函数`glReadPixels()`，它可能需要从本地设备内存到主机内存进行大量帧缓冲区的逐字节复制。
- **DMA_XOR**
  
  - 设备能够在内存区域上执行XOR运算。
  
  - 用于加速需要大量XOR运算的任务，如RAID5。
- **DMA_XOR_VAL**
  
  - 设备能够使用XOR算法针对内存缓冲区执行奇偶校验检查。
- **DMA_PQ**
  
  - 设备能够执行RAID6的P+Q计算，其中P是一个简单的XOR，而Q是一个里德-所罗门算法。
- **DMA_PQ_VAL**
  
  - 设备能够使用RAID6的P+Q算法针对内存缓冲区执行奇偶校验检查。
- **DMA_MEMSET**
  
  - 设备能够用提供的模式填充内存。
  
  - 模式被视为一个单字节有符号值。
- **DMA_INTERRUPT**
  
  - 设备能够触发一个虚拟传输，从而产生周期性中断。
  
  - 由客户端驱动程序用来注册一个回调函数，该函数将通过DMA控制器中断定期被调用。
- **DMA_PRIVATE**
  
  - 设备只支持从属传输，因此不适用于异步传输。
- DMA_ASYNC_TX

  - 设备不应设置此标志，框架会在需要时设置它。

  - 待办事项：这是什么含义？

- DMA_SLAVE

  - 设备能够处理设备到内存的传输，包括分散-集中传输。
  - 在内存到内存的情况下，我们有两种不同的类型来处理单一的数据块复制或一组数据块的复制；而在这里，我们只有一种交易类型，用来同时处理这两种情况。
  - 如果你想传输一个连续的内存缓冲区，只需构建一个只包含一个元素的分散列表即可。

- DMA_CYCLIC

  - 设备能够处理循环传输。
  - 循环传输是指数据块集合会自行循环，其中最后一个项目指向第一个项目。
  - 它通常用于音频传输，你希望在一个用音频数据填充的单个循环缓冲区上进行操作。

- DMA_INTERLEAVE

  - 设备支持交错传输。
  - 这种传输可以从非连续缓冲区向另一个非连续缓冲区传输数据，与DMA_SLAVE不同的是，DMA_SLAVE可以从非连续数据集向连续的目标缓冲区传输数据。
  - 它通常用于二维内容传输，在这种情况下，你希望直接将未压缩数据的一部分传送到显示设备进行显示。

- DMA_COMPLETION_NO_ORDER

  - 设备不支持有序完成。
  - 如果设备设置了这个功能，驱动程序应在设备传输状态返回DMA_OUT_OF_ORDER。
- 如果设备提供了此功能，则所有与Cookie跟踪和检查相关的API都应被视为无效。
- 目前，这与dmatest的轮询选项不兼容。
- 如果设置了此功能，则建议用户为发送到DMA设备的每个描述符提供一个唯一标识符，以便正确追踪完成情况。
- DMA_REPEAT

  - 设备支持重复传输。通过DMA_PREP_REPEAT传输标志指示的重复传输类似于循环传输，即在结束时会自动重复，但还可以被客户端替换。
- 此功能仅限于交错传输，因此如果未设置DMA_INTERLEAVE标志，则不应设置此标志。这一限制基于当前DMA客户端的需求；如果将来出现需求，将增加对其他传输类型的支持。
- DMA_LOAD_EOT

  - 设备支持在传输结束时（EOT）替换重复传输，即通过设置DMA_PREP_LOAD_EOT标志来排队一个新的传输。
- 根据DMA客户端的需求，在将来可能会增加支持在其他点（例如传输突发结束而非整个传输结束）替换正在运行的传输。
这些不同的类型也会影响源地址和目标地址随时间的变化方式。
指向RAM的地址通常会在每次传输后递增（或递减）。对于环形缓冲区的情况，它们可能会循环（DMA_CYCLIC）。指向设备寄存器（如FIFO）的地址通常是固定的。
描述符元数据支持
--------------------
一些数据移动架构（DMA控制器和外设）使用与事务关联的元数据。DMA控制器的作用是同时传输有效负载和元数据。
元数据本身不会被DMA引擎直接使用，但它包含了外设或来自外设的参数、密钥、向量等信息。
DMA引擎框架提供了一种通用的方法来方便地处理描述符中的元数据。根据不同的架构，DMA驱动程序可以实现以下方法中的一种或两种，而选择使用哪一种则取决于客户端驱动程序：
- DESC_METADATA_CLIENT

  元数据缓冲区由客户端驱动程序分配/提供，并通过`dmaengine_desc_attach_metadata()`辅助函数附加到描述符上。
  对于DMA驱动程序而言，在这种模式下有以下要求：

  - DMA_MEM_TO_DEV / DEV_MEM_TO_MEM

    应该准备好从提供的元数据缓冲区中的数据，以便DMA控制器能够与有效负载数据一同发送。这可以通过复制到硬件描述符或者高度耦合的数据包中来完成。
- DMA_DEV_TO_MEM

    在传输完成后，DMA驱动程序必须将元数据复制到客户端提供的元数据缓冲区中，然后再通知客户端完成情况。
    传输完成后，DMA驱动程序不得再触碰客户端提供的元数据缓冲区。
- DESC_METADATA_ENGINE

  元数据缓冲区由DMA驱动程序分配/管理。客户端驱动程序可以请求获取元数据指针、最大大小和当前使用的大小，并可以直接更新或读取它。提供了`dmaengine_desc_get_metadata_ptr()`和`dmaengine_desc_set_metadata_len()`作为辅助函数。
  对于DMA驱动程序而言，在这种模式下有以下要求：

  - get_metadata_ptr()

    应该返回元数据缓冲区的指针、元数据缓冲区的最大大小以及缓冲区中当前使用/有效的字节数（如果有）。
  - set_metadata_len()

    客户端在放置元数据到缓冲区后会调用此函数，以告知DMA驱动程序提供的有效字节数。
注：由于客户端将在完成回调中请求元数据指针（在DMA_DEV_TO_MEM情况下），因此DMA驱动程序必须确保在回调被调用之前不释放描述符。
设备操作
------------

我们之前描述了能够执行的操作，现在我们的 `dma_device` 结构体也需要几个函数指针来实现实际的逻辑。
我们需要填充并实现的函数显然取决于你报告的支持的事务类型。

- `device_alloc_chan_resources`

- `device_free_chan_resources`

  - 这些函数会在驱动首次或最后一次通过 `dma_request_channel` 或 `dma_release_channel` 请求或释放与该驱动关联的通道时被调用。
- 它们负责分配/释放所有必需的资源，以便该通道对你的驱动来说是有用的。
- 这些函数可以睡眠。
- `device_prep_dma_*`

  - 这些函数与你之前注册的能力相匹配。
- 这些函数都接收与待准备传输相关的缓冲区或分散列表，并应从中创建硬件描述符或硬件描述符列表。

  - 这些函数可能在中断上下文中被调用。

  - 任何你可能需要进行的分配都应该使用 GFP_NOWAIT 标志，以避免潜在地睡眠，但同时也不耗尽紧急内存池。
- 驱动程序应在探测阶段尝试预分配它们在传输设置期间可能需要的任何内存，以避免给无等待分配器带来过多压力。
- 它应该返回一个 `dma_async_tx_descriptor` 结构体的唯一实例，该实例进一步代表这次特定的传输。
- 可以使用 `dma_async_tx_descriptor_init` 函数初始化这个结构体。
- 您还需要设置该结构中的两个字段：

    - flags:
      待办事项：这些标志是否可以由驱动程序本身修改，或者
      是否应该始终使用传递给参数的标志。

    - tx_submit: 指向您需要实现的一个函数的指针，
      该函数应该将当前的事务描述符推送到一个等待队列中，
      等待调用 `issue_pending`。

- 在此结构中，可以初始化函数指针 `callback_result` 以便通知提交者事务已完成。在之前的代码中已经使用了函数指针 `callback`。然而它并没有提供任何关于事务状态的信息，并且将会被弃用。传递给 `callback_result` 的结果结构定义为 `dmaengine_result`，它包含两个字段：

    - result: 提供由 `dmaengine_tx_result` 定义的传输结果。可能是成功或某种错误情况。
    
    - residue: 对于支持残留功能的情况，提供传输的残留字节数。

- `device_issue_pending`

  - 取出待处理队列中的第一个事务描述符并开始传输。每当完成一次传输时，应该继续处理列表中的下一个事务。

  - 此函数可以在中断上下文中被调用。

- `device_tx_status`

  - 应报告给定通道上剩余要传输的字节数。

  - 只需关注作为参数传递的事务描述符，而不是给定通道上当前活跃的那个。

  - 参数 `tx_state` 可能为 NULL。

  - 应使用 `dma_set_residue` 来报告结果。

  - 在循环传输的情况下，它只应考虑循环缓冲区的总大小。

  - 如果设备不支持顺序完成并且正在以非顺序方式完成操作，则应返回 `DMA_OUT_OF_ORDER`。

  - 此函数可以在中断上下文中被调用。

- `device_config`

  - 使用作为参数给出的配置重新配置通道。

  - 该命令不应同步执行，也不应作用于当前排队中的任何传输，而只能作用于后续的传输。

  - 在这种情况下，函数将接收一个指向 `dma_slave_config` 结构的指针作为参数，该指针会详细说明要使用的配置。

  - 尽管该结构包含一个方向字段，但这个字段已被弃用，取而代之的是传递给 `prep_*` 函数的方向参数。

  - 此调用仅对从设备操作是强制性的。对于内存复制操作，不应该设置或期望设置此调用。

  - 如果驱动程序同时支持这两种操作，那么它应该只为从设备操作使用此调用，而不用于内存复制操作。
- device_pause
  - 在信道上暂停传输。
  - 此命令应在信道上同步执行，立即暂停给定信道的工作。

- device_resume
  - 在信道上恢复传输。
  - 此命令应在信道上同步执行，立即恢复给定信道的工作。

- device_terminate_all
  - 终止信道上所有待处理和正在进行中的传输。
  - 对于已终止的传输，不应调用完成回调。
  - 可以从原子上下文或描述符的完成回调中调用。不应睡眠。驱动程序必须能够正确处理此操作。
  - 终止可能是异步的。驱动程序不必等待当前活动传输完全停止，请参阅`device_synchronize`。

- device_synchronize
  - 必须在当前上下文中同步信道的终止。
  - 必须确保之前提交的描述符的内存不再被DMA控制器访问。
  - 必须确保之前提交的所有描述符的完成回调已经完成运行且未安排运行任何回调。
  - 可以睡眠。

杂项说明
==========
（应该记录下来但不知道放在哪里的内容）

`dma_run_dependencies`

- 应在异步TX传输结束时调用，并且在从属传输的情况下可以忽略。
- 确保依赖操作在标记为完成前运行。

dma_cookie_t

- 这是一个随时间递增的DMA事务ID。
自从引入了`virt-dma`，它将这些特性抽象化后，这些内容就不再那么相关了。

DMA_CTRL_ACK

- 如果未被清除，则提供者在客户端确认接收之前不能重用描述符，即客户端有机会建立任何依赖链。
- 可以通过调用`async_tx_ack()`来确认接收。
- 即使设置了该标志，也不意味着描述符可以被重用。

DMA_CTRL_REUSE

- 如果设置了该标志，则描述符完成之后可以被重用。如果设置了此标志，则提供者不应释放描述符。
- 应通过调用`dmaengine_desc_set_reuse()`来为重用准备描述符，这将设置DMA_CTRL_REUSE标志。
- `dmaengine_desc_set_reuse()`只有在通道支持可重用描述符时才能成功，这一点可通过其能力体现出来。
- 因此，如果设备驱动程序想要跳过两次传输之间的`dma_map_sg()`和`dma_unmap_sg()`（因为DMA的数据没有被使用），则可以在传输完成后立即重新提交传输。
- 描述符可以通过几种方式被释放：

  - 通过调用`dmaengine_desc_clear_reuse()`清除DMA_CTRL_REUSE标志，并提交最后一次交易。
  
  - 明确地调用`dmaengine_desc_free()`；这只有在DMA_CTRL_REUSE已经设置的情况下才能成功。
  
  - 终止通道。

DMA_PREP_CMD

- 如果设置了该标志，则客户端驱动程序告诉DMA控制器，通过DMA API传递的数据是命令数据。
- 命令数据的解释取决于具体的DMA控制器。它可以用于向其他外设发出命令、寄存器读取或写入等操作，对于这些操作，描述符应采用与普通数据描述符不同的格式。

DMA_PREP_REPEAT

- 如果设置了该标志，则当传输结束时会自动重复传输，直到在同一通道上排队的新传输带有DMA_PREP_LOAD_EOT标志为止。
- 如果下一个要排队的通道传输没有设置DMA_PREP_LOAD_EOT标志，则当前传输将继续重复，直到客户端终止所有传输。
- 此标志仅在通道报告了DMA_REPEAT能力时才支持。

DMA_PREP_LOAD_EOT

- 如果设置了该标志，则传输将在传输结束时替换当前正在执行的传输。
### 默认行为说明
- 这是对于非重复传输的默认行为，因此对于非重复传输指定 `DMA_PREP_LOAD_EOT` 标志将不会产生任何影响。
- 在使用重复传输时，DMA 客户端通常需要在所有传输中设置 `DMA_PREP_LOAD_EOT` 标志，否则通道会持续重复最后一次重复传输，并忽略正在排队的新传输。未设置 `DMA_PREP_LOAD_EOT` 将表现为通道似乎卡在了前一次传输上。
- 此标志仅在通道报告支持 `DMA_LOAD_EOT` 能力时才被支持。

### 通用设计注意事项
====
大多数 DMA 引擎驱动程序都基于一种类似的设计，该设计在中断处理程序中处理传输结束中断，但将大部分工作推迟到任务项（tasklet），包括每当上一次传输结束时启动新传输。
这是一种相对低效的设计，因为两次传输之间的延迟不仅包括中断延迟，还包括任务项的调度延迟，这会导致通道在两次传输之间处于空闲状态，从而降低整体传输速率。
你应该避免这种做法，不要在你的任务项中选择新的传输，而是将这部分移到中断处理程序中以缩短空闲窗口（这部分实际上无法完全避免）。

### 术语表
====
- **突发（Burst）**：可以排队到缓冲区的一系列连续读或写操作，在将其刷新到内存之前。
- **块（Chunk）**：一系列连续的突发集合。
- **传输（Transfer）**：块的集合（无论是连续还是不连续）。
