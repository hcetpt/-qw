NTB 驱动程序
===========

NTB（非透明桥接）是一种类型的 PCI-Express 桥接芯片，它将两台或多台计算机的独立内存系统连接到同一个 PCI-Express 架构上。现有的 NTB 硬件支持一组通用特性：门铃寄存器和内存翻译窗口，以及一些非通用特性，如暂存区寄存器和消息寄存器。暂存区寄存器是可读写的寄存器，从设备的任一侧都可访问，因此对等端可以交换固定地址处的小量信息。消息寄存器可用于相同的目的。此外，它们还提供了特殊的状态位以确保信息不会被另一个对等端重写。门铃寄存器为对等端提供了一种发送中断事件的方式。内存窗口允许对对等端内存进行翻译后的读取和写入访问。

NTB 核心驱动 (ntb)
==================

NTB 核心驱动定义了一个 API，封装了通用特性集，并允许对 NTB 特性感兴趣的客户端发现由硬件驱动支持的 NTB 设备。这里的“客户端”是指使用 NTB API 的上层组件。“驱动”或“硬件驱动”在这里是指特定供应商和型号的 NTB 硬件的驱动。

NTB 客户端驱动
==============

NTB 客户端驱动应向 NTB 核心驱动注册。注册后，在插入和移除 NTB 硬件或硬件驱动时，会适当调用客户端的探测和移除函数。注册使用的是 Linux 设备框架，因此对于编写过 PCI 驱动的人来说应该很熟悉。

NTB 典型客户端驱动实现
----------------------

NTB 的主要目的是至少在两个系统之间共享一部分内存。因此，NTB 设备特性如暂存区/消息寄存器主要用于适当的内存窗口初始化。通常，NTB API 支持两种类型的内存窗口接口：一种是在本地 NTB 端口配置的入站翻译，另一种是由对等端在其 NTB 端口配置的出站翻译。第一种类型如下图所示：

入站翻译：

```
内存:               本地 NTB 端口:      对等 NTB 端口:      对等 MMIO:
 _____________
| dma-mapped |—ntb_mw_set_trans(addr)  |
| 内存       |       _v____________    |   ______________
| (addr)     |<=====| MW xlat addr |<====| MW base addr |<== 内存映射 IO
|-------------|      |--------------|  |  |--------------|
```

所以第一种类型内存窗口初始化的典型场景如下：
1) 分配内存区域，
2) 将翻译后的地址设置到 NTB 配置中，
3) 以某种方式通知对等设备完成的初始化，
4) 对等设备映射相应的出站内存窗口以便访问共享内存区域。

第二种类型的接口意味着共享窗口由对等设备初始化，如下图所示：

出站翻译：

```
内存:          本地 NTB 端口:    对等 NTB 端口:      对等 MMIO:
 ____________                     ______________
| dma-mapped |                   |   | MW base addr |<== 内存映射 IO
| 内存       |                   |   |--------------|
| (addr)     |<===================|   | MW xlat addr |<-ntb_peer_mw_set_trans(addr)
|-------------|                   |   |--------------|
```

第二种类型接口初始化的典型场景如下：
1) 分配内存区域，
2) 以某种方式将翻译后的地址传递给对等设备，
3) 对等设备将翻译后的地址设置到 NTB 配置中，
4) 对等设备映射出站内存窗口以便访问共享内存区域。

可以看出，所描述的场景可以组合成一个便携算法。
本地设备：
  1) 为共享窗口分配内存
  2) 使用分配区域的翻译地址初始化内存窗口（如果本地内存窗口初始化不被支持，则可能会失败）
  3) 向对等设备发送翻译后的地址和内存窗口索引

对等设备：
  1) 使用从另一设备获取的地址初始化内存窗口（如果对等内存窗口初始化不被支持，则可能会失败）
  2) 映射出站内存窗口

根据此场景，NTB 内存窗口 API 可以这样使用：

本地设备：
  1) ntb_mw_count(pidx) - 获取可以为指定端口索引的本地设备与对等设备之间分配的内存窗口数量
  2) ntb_get_align(pidx, midx) - 获取限制共享内存区域对齐方式和大小的参数。然后按照这些限制正确地分配内存
  3) 按照步骤 2) 中获取的限制分配物理连续的内存区域
### NTB 内存窗口设置和地址传递

4) `ntb_mw_set_trans(pidx, midx)` - 尝试为指定索引的内存窗口设置转换地址，针对已定义的对等设备（如果本地不支持地址转换，则可能失败）。
5) 使用例如 scratchpad 或消息寄存器等方式将转换后的基址（通常与内存窗口编号一起）发送给对等设备。

### 对等设备：

1) `ntb_peer_mw_set_trans(pidx, midx)` - 尝试为特定内存窗口设置从其他设备（与 `pidx` 相关）接收到的转换地址。如果获取的地址超出最大可能值或未正确对齐，则可能失败。
2) `ntb_peer_mw_get_addr(widx)` - 获取用于映射内存窗口的 MMIO 地址，以便访问共享内存。

值得注意的是，方法 `ntb_mw_count(pidx)` 应返回与对等设备上 `ntb_peer_mw_count()` 方法相同的值，其中对等设备端口索引为 `pidx`。

### NTB 传输客户端 (ntb_transport) 和 NTB 网络设备 (ntb_netdev)

NTB 的主要客户端是传输客户端，它与 NTB 网络设备配合使用。这些驱动程序共同创建一个逻辑连接，通过 NTB 在对等设备之间交换网络数据包。传输客户端建立到对等设备的逻辑连接，并创建队列对以交换消息和数据。NTB 网络设备随后使用传输队列对创建一个以太网设备。网络数据在套接字缓冲区和传输队列对缓冲区之间复制。传输客户端除了网络设备之外还可以用于其他用途，但目前尚未编写其他应用程序。

### NTB Ping Pong 测试客户端 (ntb_pingpong)

Ping Pong 测试客户端作为演示案例来测试 NTB 硬件的门铃和 scratchpad 寄存器，同时也作为一个简单的 NTB 客户端示例。Ping Pong 在启动时使链路启用，等待 NTB 链路建立，然后读取和写入门铃 scratchpad 寄存器。

对等设备使用一个门铃位掩码相互中断，该掩码在每轮中向右移一位，以此来测试多个门铃位和中断向量的行为。Ping Pong 驱动程序还在每轮写入对等门铃寄存器之前读取第一个本地 scratchpad 并将该值加一后写入第一个对等 scratchpad。

#### 模块参数：

- `unsafe`：某些硬件存在与 scratchpad 和门铃寄存器相关的问题。默认情况下，Ping Pong 不会尝试测试此类硬件。您可以通过设置 `unsafe=1` 来覆盖这种行为，但风险自负。
- `delay_ms`：指定接收门铃中断事件和设置下一个轮次的对等门铃寄存器之间的延迟时间（毫秒）。
* `init_db` - 指定门铃位以启动新的一轮序列。当所有的门铃位都移出范围后，新的一轮开始。
* `dyndbg` - 建议在加载此模块时指定 `dyndbg=+p`，然后在控制台上观察调试输出。

NTB 工具测试客户端（`ntb_tool`）
--------------------------------

该工具测试客户端主要用于调试 NTB 硬件和驱动程序。该工具通过 `debugfs` 提供读取、设置和清除 NTB 门铃以及读写暂存区的访问接口。目前，该工具没有模块参数。

`debugfs` 文件：

* `debugfs/ntb_tool/hw/`
    - 对于每个被工具探测到的 NTB 设备，在 `debugfs` 中都会创建一个目录。为了简化说明，以下将该目录简称为 `hw`。
* `hw/db`
    - 此文件用于读取、设置和清除本地门铃。并非所有硬件都支持所有操作。要读取门铃状态，请读取该文件；要设置门铃，请写入 `s` 后跟需要设置的位（例如：`echo 's 0x0101' > db`）；要清除门铃，请写入 `c` 后跟需要清除的位。
* `hw/mask`
    - 此文件用于读取、设置和清除本地门铃掩码。详情参见 `db`。
* `hw/peer_db`
    - 此文件用于读取、设置和清除对端门铃。
查看 *db* 以获取详细信息。
* *hw*/peer_mask
此文件用于读取、设置和清除对等方门铃掩码。请参阅 *db* 获取详细信息。
* *hw*/spad
此文件用于读取和写入本地暂存区。要读取所有暂存区的值，请读取此文件。要写入值，可以写入一系列暂存区编号与值的对（例如：`echo '4 0x123 7 0xabc' > spad` # 将暂存区 `4` 和 `7` 分别设置为 `0x123` 和 `0xabc`）。
* *hw*/peer_spad
此文件用于读取和写入对等方暂存区。详情参见 *spad*。

NTB MSI 测试客户端（ntb_msi_test）
------------------------------------

MSI 测试客户端用于测试和调试 MSI 库，该库允许通过 NTB 内存窗口传递 MSI 中断。可以通过 debugfs 文件系统与测试客户端进行交互：
* *debugfs*/ntb_msi_test/*hw*
对于每个被 msi 测试探测到的 NTB 设备，在 debugfs 中都会创建一个目录。以下将此目录简称为 *hw*。
* *hw*/port
此文件描述了本地端口号。
* *hw*/irq*_occurrences
每个中断都存在一个触发次数文件，当读取时，会返回该中断被触发的次数。
* *hw*/peer*/port
此文件描述了每个对等方的端口号。
* *hw*/peer*/count
此文件描述了可以在每个对等方上触发的中断数量。
* *hw*/peer*/trigger
写入一个中断编号（任何小于在 count 中指定的值的数字），将会在指定的对等方上触发该中断。该对等方的中断触发次数文件应该会被递增。

NTB 硬件驱动程序
====================

NTB 硬件驱动程序应该向 NTB 核心驱动程序注册设备。注册后，客户端的探测和移除功能将会被调用。

NTB Intel 硬件驱动程序（ntb_hw_intel）
------------------------------------------

Intel 硬件驱动程序支持在 Xeon 和 Atom CPU 上使用 NTB。

模块参数：

* b2b_mw_idx
如果需要通过内存窗口访问对等方 ntb，则使用此内存窗口来访问对等方 ntb。正值或零从第一个 mw idx 开始，负值则从最后一个 mw idx 开始。双方必须在此处设置相同的值！默认值是 `-1`。
* b2b_mw_share
如果需要通过内存窗口访问对等节点ntb，并且该内存窗口足够大，仍然允许客户端使用内存窗口的后半部分来进行到对等节点的地址转换。

* xeon_b2b_usd_bar2_addr64
如果在Xeon硬件上使用B2B拓扑结构，则使用此64位地址作为NTB设备间总线上的地址，在链路的上游侧BAR2窗口中使用。

* xeon_b2b_usd_bar4_addr64 - 参见 *xeon_b2b_bar2_addr64*
* xeon_b2b_usd_bar4_addr32 - 参见 *xeon_b2b_bar2_addr64*
* xeon_b2b_usd_bar5_addr32 - 参见 *xeon_b2b_bar2_addr64*
* xeon_b2b_dsd_bar2_addr64 - 参见 *xeon_b2b_bar2_addr64*
* xeon_b2b_dsd_bar4_addr64 - 参见 *xeon_b2b_bar2_addr64*
* xeon_b2b_dsd_bar4_addr32 - 参见 *xeon_b2b_bar2_addr64*
* xeon_b2b_dsd_bar5_addr32 - 参见 *xeon_b2b_bar2_addr64*
