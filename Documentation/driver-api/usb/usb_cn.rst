... _usb-hostside-api:

===========================
Linux-USB 主机端 API
===========================

Linux 上的 USB 简介
============================

通用串行总线 (USB) 用于将主机（如个人电脑或工作站）与一系列外围设备连接。USB 使用树状结构，其中主机作为根节点（系统的主控器），集线器作为中间节点，而外围设备作为叶节点（从属设备）。现代个人电脑支持多个这样的 USB 设备树，通常包括几个 USB 3.0（5 GBit/s）或 USB 3.1（10 GBit/s）以及一些遗留的 USB 2.0（480 MBit/s）总线以备不时之需。
这种主/从不对称设计出于多种原因，其中一个原因是便于使用。在物理上不可能将上游和下游弄错（对于 Type-C 插头而言，这并不重要，或者它们被内置到外围设备中）。此外，主机软件无需处理分布式自动配置，因为预指定的主节点管理所有这些配置。
内核开发人员在 2.2 内核系列早期就为 Linux 添加了 USB 支持，并自那以后一直在进一步发展它。除了支持每一代新的 USB 外，各种主机控制器获得了支持，添加了新的外围设备驱动程序，并引入了用于测量延迟和改进电源管理的高级功能。
Linux 可以在 USB 设备内部运行，也可以在控制这些设备的主机上运行。但是，在这些外围设备内部运行的 USB 设备驱动程序所做的工作与在主机内部运行的不同，因此它们被称为“gadget 驱动程序”。本文档不涵盖 gadget 驱动程序。
USB 主机端 API 模型
=======================

针对 USB 设备的主机端驱动程序通过 "usbcore" API 进行通信。有两种类型。一种是为 *通用* 驱动程序设计的（通过驱动框架暴露），另一种则是为 *核心* 的一部分设计的。这类核心驱动程序包括 *集线器* 驱动程序（用于管理 USB 设备树）和几种不同的 *主机控制器* 驱动程序，它们控制单个总线。
USB 驱动程序看到的设备模型相对复杂：
-  USB 支持四种数据传输类型（控制、批量、中断和等时）。其中两种（控制和批量）利用可用带宽，而另外两种（中断和等时）则通过调度提供保证的带宽。
-  设备描述模型包括每个设备的一个或多个 “配置”，其中只有一个配置是活动的。设备应该能够在低于其最高速度的情况下工作，并且可以提供一个 BOS 描述符来显示它们保持完全功能的最低速度。
-  从 USB 3.0 开始，配置有一个或多个 “功能”，它们提供共同的功能，并且为了电源管理的目的被分组在一起。
-  配置或功能有一个或多个 “接口”，每个接口可能有 “替代设置”。接口可以通过 USB “类” 规范标准化，或者特定于供应商或设备。
USB设备驱动程序实际上绑定到接口，而不是设备。可以将它们视为“接口驱动程序”，尽管你可能不会在很多设备上看到这种区别很重要。*大多数USB设备都很简单，只有一个功能、一个配置、一个接口和一个备选设置。*

- 接口有一个或多个“端点”，每个端点支持一种类型和方向的数据传输，例如“批量输出”或“中断输入”。整个配置在每个方向上最多可以有十六个端点，根据需要在所有接口之间分配。
- 在USB上的数据传输是分组的；每个端点都有一个最大包大小。驱动程序通常需要意识到一些约定，比如使用“短”（包括零长度）包来标记批量传输的结束。
- Linux USB API支持控制和批量消息的同步调用。它还支持所有类型数据传输的异步调用，使用称为“URB”（USB请求块）的请求结构。
因此，对设备驱动程序暴露的USB核心API覆盖了很多内容。你可能需要参考USB 3.0规范，该规范可从www.usb.org免费在线获取，以及类或设备规格。
唯一真正触及硬件（读写寄存器、处理IRQ等）的主机侧驱动程序是HCD。理论上，所有HCD都通过相同的API提供相同的功能。但实际上，这一点越来越真实，但仍存在一些差异，尤其是在不太常见的控制器的故障处理中出现差异。
不同的控制器不一定报告失败的相同方面，并且从故障（包括软件引起的故障，如解除URB链接）中恢复尚不完全一致。设备驱动程序作者应特别注意使用每个不同的主机控制器驱动程序进行断开连接测试（当设备处于活动状态时），以确保驱动程序本身没有错误，同时也确保它们不依赖于某些特定于HCD的行为。
.. _usb_chapter9:

USB标准类型
=============

在``include/uapi/linux/usb/ch9.h``中定义了USB规范第9章中的USB数据类型。这些数据类型在整个USB中使用，并在包括此主机侧API、gadget API、USB字符设备和debugfs接口在内的API中使用。该文件本身由``include/linux/usb/ch9.h``包含，该文件还包含了一些用于操作这些数据类型的实用程序例程的声明；实现在``drivers/usb/common/common.c``中。
.. kernel-doc:: drivers/usb/common/common.c
   :export:

此外，在``drivers/usb/common/debug.c``中定义了一些用于创建调试输出的有用函数。
.. _usb_header:

主机侧数据类型和宏
=====================

主机侧API向驱动程序暴露了几层，其中一些比另一些更必要。这些支持主机侧驱动程序和设备的生命周期模型，并支持通过usbcore传递缓冲区到执行设备驱动程序I/O的某个HCD。
.. kernel-doc:: include/linux/usb.h
   :internal:

USB核心API
===========

USB API中有两种基本的I/O模型。最基本的是异步模型：驱动程序以URB的形式提交请求，而URB的完成回调处理下一步。所有USB传输类型都支持该模型，尽管对于控制URB（始终具有设置和状态阶段，但可能没有数据阶段）和等时URB（允许大包并包括每个包的故障报告）有一些特殊情况。在此基础上构建的是同步API支持，其中驱动程序调用一个例程，该例程分配一个或多个URB，提交它们，并等待它们完成。对于单缓冲控制和批量传输（在某些驱动程序断开连接的情况下使用起来很尴尬）以及基于散列列表的流式I/O（批量或中断）有同步包装器。
USB驱动程序需要提供可用于直接内存访问（DMA）的缓冲区，尽管它们不一定需要自行提供DMA映射。在分配DMA缓冲区时有API可供使用，这可以在某些系统上避免使用中转缓冲区。在某些情况下，驱动程序可能依赖于64位DMA来消除另一种类型的中转缓冲区。

:: 

   drivers/usb/core/urb.c
   drivers/usb/core/message.c
   drivers/usb/core/file.c
   drivers/usb/core/driver.c
   drivers/usb/core/usb.c
   drivers/usb/core/hub.c

主机控制器API
=============

这些API仅用于主机控制器驱动程序，其中大多数实现了诸如XHCI、EHCI、OHCI或UHCI等标准寄存器接口。UHCI是最早的接口之一，由Intel设计，并且也被VIA使用；它在硬件中的功能并不强大。OHCI后来被设计出来，目的是让硬件承担更多工作（更大的传输量、跟踪协议状态等）。EHCI是随着USB 2.0设计的；它的设计结合了OHCI的特点（硬件承担更多工作）和UHCI的特点（ISO支持的一部分、TD列表处理）。XHCI则是为USB 3.0设计的。它继续将功能支持转移到硬件中。
除了“三大”主机控制器之外，还有一些其他的主机控制器，尽管大多数基于PCI的控制器（以及一些非基于PCI的控制器）使用的是上述接口之一。并非所有的主机控制器都使用DMA；有些使用PIO，并且还有一个模拟器和一个虚拟主机控制器，用于通过网络传输USB数据。所有这些控制器的驱动程序都可以使用相同的API基础。
由于历史原因，这些API分为两层：`struct usb_bus <usb_bus>`是一个相对简单的层，在2.2内核版本中变得可用，而`struct usb_hcd <usb_hcd>`则是一个更具有功能性的层，使HCD能够共享通用代码，从而减小驱动程序的大小并显著减少HCD特定的行为。

::
   
   drivers/usb/core/hcd.c
   drivers/usb/core/hcd-pci.c
   drivers/usb/core/buffer.c

USB字符设备节点
=================

本章介绍Linux的字符设备节点。您可能更愿意避免为您的USB驱动程序编写新的内核代码。用户模式设备驱动程序通常被封装为应用程序或库，并且可以通过某些编程库来使用字符设备。
这样的库包括：

-  `libusb <http://libusb.sourceforge.net>`__ 用于C/C++，以及
-  `jUSB <http://jUSB.sourceforge.net>`__ 用于Java

关于它的旧信息可以在USB指南的“USB设备文件系统”部分找到。最新的USB指南副本可以在http://www.linux-usb.org/ 找到。

.. note:: 

  - 它们以前是通过*usbfs*实现的，但这不是sysfs调试接口的一部分。
  - 这个特定文档是不完整的，特别是在异步模式方面。截至内核2.5.66，代码和这个（新的）文档需要进行交叉审查。

"devtmpfs"中有哪些文件？
------------------------------

通常挂载在`/dev/bus/usb/`，usbfs的特性包括：

-  `/dev/bus/usb/BBB/DDD`... 魔法文件，暴露每个设备的配置描述符，并支持一系列ioctl来进行设备请求，包括对设备的I/O。（纯粹供程序访问。）

每个总线都有一个编号(``BBB``)，根据其枚举的时间确定；在每个总线上，每个设备也有一个类似的编号(``DDD``)。这些``BBB/DDD``路径并不是“稳定”的标识符；即使你总是将设备插在同一集线器端口上，也预期它们会发生变化。*不要考虑在应用程序配置文件中保存这些路径*。对于希望使用稳定ID的用户模式应用来说，稳定的标识符是可以获取的。HID和网络设备暴露这些稳定ID，因此例如你可以确保你告诉正确的UPS关闭其第二台服务器。请注意，它尚未公开这些ID。
```/dev/bus/usb/BBB/DDD```
------------------------

以以下基本方式使用这些文件：

- **它们可以被读取，** 首先产生设备描述符（18字节），然后是当前配置的描述符。关于这些二进制数据格式的详细信息，请参阅USB 2.0规范。您需要将大多数多字节值从小端格式转换为您主机的本机字节顺序，尽管设备描述符中的一些字段（BCD编码的两个字段以及供应商和产品ID）会被为您字节交换。请注意，配置描述符包括接口、替代设置、端点的描述符，也许还有额外的类描述符。
- **执行USB操作** 使用 *ioctl()* 请求来发出端点I/O请求（同步或异步）或管理设备。这些请求需要 `CAP_SYS_RAWIO` 权限，以及对文件系统的访问权限。一次只能在一个设备文件上进行一个ioctl请求。这意味着如果您正在从一个线程同步地读取一个端点，则在读取完成之前无法从另一个线程写入不同的端点。这对于 *半双工* 协议有效，但其他情况下您将使用异步I/O请求。

每个连接的USB设备都有一个文件。 `BBB` 表示总线号。 `DDD` 表示该总线上的设备地址。这两个数字都是按序分配的，并且可以重复使用，因此不能依赖它们来稳定访问设备。例如，设备在连接状态下重新枚举是很常见的（可能有人晃动了其电源供应器、集线器或USB电缆），所以一个设备第一次连接时可能是 `002/027` ，而稍后某个时刻可能变为 `002/048` 。

这些文件可以作为二进制数据读取。二进制数据首先包含设备描述符，接着是设备每个配置的描述符。设备描述符中的多字节字段由内核转换为主机字节序。配置描述符采用总线字节序格式！配置描述符相隔 wTotalLength 字节。如果设备返回的配置描述符数据少于 wTotalLength 指示的数据量，那么文件中会为缺失的字节留下空洞。这些信息也以文本形式显示在后面的 `/sys/kernel/debug/usb/devices` 文件中。

这些文件也可以用于编写USB设备的用户级驱动程序。您将打开 `/dev/bus/usb/BBB/DDD` 文件进行读写，读取其描述符以确保它是您期望的设备，然后通过ioctl调用来绑定到一个接口（或者可能几个）。您将向设备发出更多的ioctl以使用控制、批量或其他类型的USB传输与之通信。这些IOCTL列在 `<linux/usbdevice_fs.h>` 文件中，目前源代码 (`linux/drivers/usb/core/devio.c`) 是如何通过这些文件访问设备的主要参考。

需要注意的是，默认情况下这些 `BBB/DDD` 文件仅对root可写，因此只有root可以编写此类用户模式驱动程序。您可以使用 `chmod` 选择性地授予其他用户读写权限。此外，诸如 `devmode=0666` 的usbfs挂载选项可能会有所帮助。

用户模式驱动程序生命周期
-------------------------------

这样的驱动程序首先需要找到一个它知道如何处理的设备文件。也许是由于 `/sbin/hotplug` 事件处理代理选择了该驱动程序来处理新设备。或者也许它是一个扫描所有 `/dev/bus/usb` 设备文件的应用程序，并忽略大多数设备。在这两种情况下，它都应该使用 :c:func:`read()` 从设备文件读取所有描述符，并根据它知道如何处理的内容检查它们。它可能只拒绝除特定供应商和产品ID之外的所有内容，或者需要更复杂的策略。

永远不要假设系统上一次只有一个这样的设备！如果您的代码不能同时处理多个设备，至少检测到存在多个设备，并让用户选择要使用的设备。

一旦您的用户模式驱动程序确定了要使用的设备，它将以两种风格之一与其交互。简单的方式是仅发出控制请求；某些设备不需要比这更复杂的交互（一个例子可能是使用供应商特定的控制请求进行一些初始化或配置任务，其余部分则由内核驱动程序处理）。

更有可能的是，您需要一个更复杂的驱动程序样式：使用非控制端点，读取或写入数据并声明对一个接口的独占使用。 *批量* 转移最容易使用，但只有它们的兄弟 *中断* 转移可以在低速设备上工作。中断和 *等时* 转移都提供服务保证，因为它们的带宽被保留。这类“周期性”转移通过usbfs使用起来很笨拙，除非您正在使用异步调用。然而，中断转移也可以同步地以“一次性”方式进行使用。
您的用户模式驱动程序在设备断开连接时通常无需担心清理请求状态，尽管它应在开始遇到`ENODEV`错误时关闭其打开的文件描述符。

`ioctl()` 请求
--------------------

要使用这些`ioctl()`请求，您需要在用户空间程序中包含以下头文件：

```c
#include <linux/usb.h>
#include <linux/usbdevice_fs.h>
#include <asm/byteorder.h>
```

根据USB 2.0规范的“第9章”中的标准USB设备模型请求会自动从`<linux/usb/ch9.h>`头文件中引入。
除非另有说明，这里描述的所有`ioctl`请求都会更新它们所应用的usbfs文件的修改时间（除非这些请求失败）。
返回零表示成功；否则，将返回一个标准的USB错误代码（这些错误代码在:ref:`usb-error-codes`中有文档说明）。
每个这样的文件都对多个I/O流进行了多路复用，每个端点对应一个流。每个设备都有一个控制端点（端点零），该端点支持有限的RPC风格访问。
设备由hub_wq（内核中）配置，设置一个影响诸如功耗和基本功能的全局*配置*。端点是USB*接口*的一部分，可能有*备用设置*影响可用的端点等。许多设备只有一个配置和接口，因此为它们编写的驱动程序会忽略配置和备用设置。

管理/状态请求
~~~~~~~~~~~~~~~~~~~~~~~~~~

一些usbfs请求并不直接与设备I/O有关，它们主要与设备管理和状态相关。这些都是同步请求。

`USBDEVFS_CLAIMINTERFACE`
    此请求用于强制usbfs声明一个特定的接口，该接口之前未被usbfs或任何其他内核驱动程序声明过。`ioctl`参数是一个整数，表示接口编号（来自描述符的`bInterfaceNumber`）。
请注意，如果您的驱动程序在尝试使用某个端点之前没有声明其接口，并且没有其他驱动程序绑定到该接口，则该接口将被usbfs自动声明。
此声明可以通过`RELEASEINTERFACE` `ioctl`请求或关闭文件描述符来释放。此请求不会更新文件修改时间。

`USBDEVFS_CONNECTINFO`
    用来判断设备是否为低速设备。`ioctl`参数指向如下结构体：

```c
struct usbdevfs_connectinfo {
    unsigned int   devnum;
    unsigned char  slow;
};
```

此请求不会更新文件修改时间。
*你无法判断一个“非慢速”设备是以高速（480 MBit/秒）还是仅全速（12 MBit/秒）连接。* 你应该已经知道`devnum`值，它是设备文件名中的DDD值。
`USBDEVFS_GET_SPEED`
    返回设备的速度。速度以数值形式返回，符合`enum usb_device_speed`的定义。

    此请求不会更新文件的修改时间。
`USBDEVFS_GETDRIVER`
    返回与给定接口绑定的内核驱动程序名称（字符串）。参数是指向以下结构体的指针，该结构体会被修改：

    ```c
    struct usbdevfs_getdriver {
        unsigned int  interface;
        char          driver[USBDEVFS_MAXDRIVERNAME + 1];
    };
    ```

    此请求不会更新文件的修改时间。
`USBDEVFS_IOCTL`
    从用户空间向注册了ioctl入口的内核驱动程序传递请求：

    ```c
    struct usbdevfs_ioctl {
        int     ifno;
        int     ioctl_code;
        void    *data;
    };
    ```

    *用户模式调用看起来像这样：*
    *`request`成为驱动程序的ioctl()函数的`code`参数*
    *`param`的大小被编码在`request`中，并且这些数据被复制到或从驱动程序的ioctl()函数的`buf`参数*

    ```c
    static int
    usbdev_ioctl (int fd, int ifno, unsigned request, void *param)
    {
        struct usbdevfs_ioctl   wrapper;

        wrapper.ifno = ifno;
        wrapper.ioctl_code = request;
        wrapper.data = param;

        return ioctl (fd, USBDEVFS_IOCTL, &wrapper);
    }
    ```

    此请求不会更新文件的修改时间。
此请求允许内核驱动程序通过文件系统操作与用户模式代码通信，即使它们没有创建字符或块特殊设备。它也被用于询问设备应该使用哪个设备特殊文件。两个预定义的ioctl用于断开和重新连接内核驱动程序，以便用户模式代码可以完全管理设备的绑定和配置。
`USBDEVFS_RELEASEINTERFACE`
    用于释放usbfs对接口的声明，无论是隐式声明还是因为`USBDEVFS_CLAIMINTERFACE`调用，在文件描述符关闭前释放。ioctl参数是一个整数，表示接口的编号（来自描述符的bInterfaceNumber）；此请求不会更新文件的修改时间。
.. warning::
    *未进行安全检查来确保做出声明的任务是释放声明的那个任务。这意味着用户模式驱动程序可能会干扰其他驱动程序。*

`USBDEVFS_RESETEP`
    将端点（批量或中断）的数据切换值重置为DATA0。ioctl参数是一个整数端点编号（1到15，如端点描述符中所标识），如果设备的端点向主机发送数据，则加上`USB_DIR_IN`。
警告：

*尽量避免使用此请求。该请求可能应该被移除。* 使用它通常意味着设备和驱动程序将失去切换同步。如果你真的失去了同步，你可能需要完全与设备握手，使用如CLEAR_HALT或SET_INTERFACE这样的请求。
USBDEVFS_DROP_PRIVILEGES
    此选项用于放弃在usbfs文件描述符上执行某些被视为特权操作的能力。这包括声明任意接口、重置当前有其他用户声明的接口的设备，以及发出USBDEVFS_IOCTL调用。ioctl参数是一个32位掩码，表示用户在此文件描述符上允许声明的接口。
你可以多次发出此ioctl以进一步缩小所述掩码。
同步I/O支持
~~~~~~~~~~~~~~~~~~~~~~~

同步请求涉及内核阻止直到用户模式请求完成，无论是成功完成还是报告错误。在大多数情况下，这是使用usbfs最简单的方式，尽管如上所述，它确实阻止了同时对多个端点进行I/O操作。
USBDEVFS_BULK
    向设备发出批量读取或写入请求。ioctl参数是指向以下结构的指针：

```c
    struct usbdevfs_bulktransfer {
        unsigned int  ep;
        unsigned int  len;
        unsigned int  timeout; /* 毫秒 */
        void          *data;
    };
```

    `ep`值标识一个批量端点编号（1到15，根据端点描述符识别），当引用从设备向主机发送数据的端点时，与USB_DIR_IN进行掩码操作。数据缓冲区的长度由`len`标识；最近的内核支持最多约128K字节的请求。*FIXME说明如何返回读取长度，以及如何处理短读取。*
USBDEVFS_CLEAR_HALT
    清除端点停止（阻塞）并重置端点切换。这对于批量或中断端点才有意义。ioctl参数是一个整数端点编号（1到15，根据端点描述符识别），当引用从设备向主机发送数据的端点时，与USB_DIR_IN进行掩码操作。
在遇到阻塞的批量或中断端点时使用，这些端点会向数据传输请求返回`-EPIPE`状态。不要直接发出控制请求，因为这可能会使主机的数据切换记录失效。
USBDEVFS_CONTROL
    向设备发出控制请求。ioctl参数指向类似以下结构的指针：

```c
    struct usbdevfs_ctrltransfer {
        __u8   bRequestType;
        __u8   bRequest;
        __u16  wValue;
        __u16  wIndex;
        __u16  wLength;
        __u32  timeout;  /* 毫秒 */
        void   *data;
    };
```

    此结构的前八个字节是将要发送给设备的SETUP包的内容；请参阅USB 2.0规范以获取详细信息。bRequestType值是由组合`USB_TYPE_*`值、`USB_DIR_*`值和`USB_RECIP_*`值（来自`linux/usb.h`）构成的。如果wLength非零，则描述了数据缓冲区的长度，该缓冲区要么写入设备（USB_DIR_OUT），要么从设备读取（USB_DIR_IN）。
撰写本文时，你无法向设备传输超过4 K字节的数据；usbfs有一个限制，而一些主机控制器驱动程序也有一个限制。（这通常不是问题。）*此外*，没有方法可以说明不允许从设备获得短读取结果。
### USBDEVFS_RESET
执行USB级别的设备重置。ioctl参数被忽略。重置后，这会重新绑定所有设备接口。此请求不会更新文件修改时间。

**警告：**

*避免使用此调用*，直到某些usbcore的bug得到修复，因为它不能完全同步设备、接口和驱动（不仅仅是usbfs）的状态。

### USBDEVFS_SETINTERFACE
为接口设置备用设置。ioctl参数是指向类似以下结构的指针：

```c
struct usbdevfs_setinterface {
    unsigned int  interface;
    unsigned int  altsetting;
};
```

此请求不会更新文件修改时间。

这些结构成员来自适用于当前配置的一些接口描述符。接口号是`bInterfaceNumber`值，而备用设置号是`bAlternateSetting`值。（这会重置接口中的每个端点。）

### USBDEVFS_SETCONFIGURATION
为设备发出`usb_set_configuration()`调用。参数是一个整数，持有配置的编号（来自描述符的`bConfigurationValue`）。此请求不会更新文件修改时间。

**警告：**

*避免使用此调用*，直到某些usbcore的bug得到修复，因为它不能完全同步设备、接口和驱动（不仅仅是usbfs）的状态。

### 异步I/O支持

如上所述，在某些情况下，可能需要从用户模式代码中启动并发操作。这对于周期性传输（中断和等时）尤为重要，但也可用于其他类型的USB请求。在这种情况下，下面描述的异步请求是必不可少的。与提交一个请求并让内核阻塞直到完成不同，这里的阻塞是分离的。

这些请求被封装在一个类似于内核设备驱动程序使用的URB结构中。（这里没有POSIX异步I/O支持，抱歉。）它标识了端点类型（`USBDEVFS_URB_TYPE_*`）、端点（编号，根据情况与USB_DIR_IN进行掩码）、缓冲区和长度，以及一个用户“上下文”值来唯一标识每个请求（通常是指向每请求数据的指针）。标志可以修改请求（不像内核驱动程序支持的那么多）。

每个请求可以指定一个实时信号编号（介于SIGRTMIN和SIGRTMAX之间，包括这两个值），以请求在请求完成时发送信号。

当usbfs返回这些URB时，状态值会被更新，缓冲区可能已经被修改。除了等时传输外，`actual_length`会被更新以指示传输了多少字节；如果设置了`USBDEVFS_URB_DISABLE_SPD`标志（“短包不可接受”），如果读取的字节数少于请求的字节数，则会报告错误：

```c
struct usbdevfs_iso_packet_desc {
    unsigned int                     length;
    unsigned int                     actual_length;
    unsigned int                     status;
};

struct usbdevfs_urb {
    unsigned char                    type;
    unsigned char                    endpoint;
    int                              status;
    unsigned int                     flags;
    void                             *buffer;
    int                              buffer_length;
    int                              actual_length;
    int                              start_frame;
    int                              number_of_packets;
    int                              error_count;
    unsigned int                     signr;
    void                             *usercontext;
    struct usbdevfs_iso_packet_desc  iso_frame_desc[];
};
```

对于这些异步请求，文件修改时间反映了请求发起的时间。这与它们用于同步请求的情况形成对比，在那种情况下，它反映了请求完成的时间。
### USBDEVFS_DISCARDURB
*待办* 此请求不会更新文件的修改时间。

### USBDEVFS_DISCSIGNAL
*待办* 此请求不会更新文件的修改时间。

### USBDEVFS_REAPURB
*待办* 此请求不会更新文件的修改时间。

### USBDEVFS_REAPURBNDELAY
*待办* 此请求不会更新文件的修改时间。

### USBDEVFS_SUBMITURB
*待办*

#### USB 设备

USB 设备现在通过 debugfs 导出：

-  `/sys/kernel/debug/usb/devices` ... 一个文本文件，显示内核所知悉的每个 USB 设备及其配置描述符。
你也可以通过 `poll()` 来监控这个文件以获取新设备的信息。
##### /sys/kernel/debug/usb/devices

此文件对于用户模式下的状态查看工具非常有用，这些工具可以扫描文本格式并忽略大部分内容。更详细的设备状态（包括类和供应商状态）可以从特定设备的文件中获得。有关此文件当前格式的信息，请参阅下方说明。

结合 `poll()` 系统调用，此文件也可以用来检测设备的添加或移除：
```c
int fd;
struct pollfd pfd;

fd = open("/sys/kernel/debug/usb/devices", O_RDONLY);
pfd = { fd, POLLIN, 0 };
for (;;) {
    /* 第一次执行时，此调用将立即返回。 */
    poll(&pfd, 1, -1);

    /* 要查看发生了哪些变化，可以比较文件之前和当前的内容，
       或者扫描文件系统。（扫描更精确。） */
}
```

请注意，这种行为旨在用于信息性和调试目的。如果要初始化设备或启动用户模式辅助程序，使用 udev 或 HAL 这样的程序会更加合适。

在此文件中，每个设备的输出有多行 ASCII 格式的输出。
我特意将其设置为 ASCII 格式而非二进制格式，以便在无需使用辅助程序的情况下也能从中获取一些有用的数据。然而，借助辅助程序，每行 `T:` （拓扑信息：层级、父级、端口、计数）中的前四列数字可以用来构建 USB 拓扑图。
每行都用一个字符的ID来标记该行：

T = 拓扑（等等）
B = 带宽（仅适用于USB主机控制器，这些控制器被虚拟化为根集线器）
D = 设备描述符信息
P = 产品ID信息（来自设备描述符，但它们无法在同一行上一起显示）
S = 字符串描述符
C = 配置描述符信息（* = 当前配置）
I = 接口描述符信息
E = 端点描述符信息
/sys/kernel/debug/usb/devices 输出格式
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

图例：
d = 十进制数字（可能有前导空格或0）
x = 十六进制数字（可能有前导空格或0）
s = 字符串

拓扑信息
^^^^^^^^^^^^^

```
T:  Bus=dd Lev=dd Prnt=dd Port=dd Cnt=dd Dev#=ddd Spd=dddd MxCh=dd
    |   |      |      |       |       |      |        |        |__最大子节点数
    |   |      |      |       |       |      |        |__设备速度（Mbps）
    |   |      |      |       |       |      |__设备编号
    |   |      |      |       |__父设备上的连接器/端口用于此设备
    |   |      |      |__父设备编号
    |   |      |__此总线在拓扑中的层级
    |   |__总线编号
    |__拓扑信息标签
```

速度可能是：

| 数值 | 描述 |
| --- | --- |
| 1.5 | 低速USB的速度为Mbit/s |
| 12 | 全速USB的速度为Mbit/s |
| 480 | 高速USB（USB 2.0新增）的速度为Mbit/s |
| 5000 | 超高速USB（USB 3.0新增）的速度为Mbit/s |

由于一些原因，在时间的迷雾中丢失了，端口号总是少1。例如，插入第4端口的设备将会以`Port=03`的形式出现。
带宽信息
^^^^^^^^^^^^^^

```
B:  Alloc=ddd/ddd us (xx%), #Int=ddd, #Iso=ddd
    |   |                       |         |__等时请求的数量
    |   |                       |__中断请求的数量
    |   |__分配给此总线的总带宽
    |__带宽信息标签
```

带宽分配是大约多少帧（毫秒）正在使用中的估计。它只反映周期性传输，因为只有这些传输预留了带宽。控制和批量传输使用所有其他带宽，包括未用于传输的预留带宽（如短数据包）。百分比表示通过这些传输所调度的“预留”带宽的比例。对于低速或全速总线（大致为“USB 1.1”），总线带宽的90%被预留。对于高速总线（大致为“USB 2.0”），80%被预留。
设备描述符信息及产品ID信息
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

```
D:  Ver=x.xx Cls=xx(s) Sub=xx Prot=xx MxPS=dd #Cfgs=dd
P:  Vendor=xxxx ProdID=xxxx Rev=xx.xx
```

其中：
```
D:  Ver=x.xx Cls=xx(sssss) Sub=xx Prot=xx MxPS=dd #Cfgs=dd
    |   |        |             |      |       |       |__配置数量
    |   |        |             |      |       |__默认端点的最大数据包大小
    |   |        |             |      |__设备协议
    |   |        |             |__设备子类
    |   |        |__设备类
    |   |__设备的USB版本
    |__设备信息标签#1
```

其中：
```
P:  Vendor=xxxx ProdID=xxxx Rev=xx.xx
    |   |           |           |__产品修订号
    |   |           |__产品ID代码
    |   |__供应商ID代码
    |__设备信息标签#2
```

字符串描述符信息
^^^^^^^^^^^^^^^^^^^^^^
```
S:  Manufacturer=ssss
    |   |__从设备读取的此设备制造商信息
         对于USB主机控制器驱动程序（虚拟根集线器），这可能会被省略，或者（对于较新驱动程序）会标识内核版本以及提供此集线器仿真功能的驱动程序
|__字符串信息标签

S:  Product=ssss
    |   |__从设备读取的此设备的产品描述
```
对于较旧的USB主机控制器驱动程序（虚拟根集线器），这指示了驱动程序；而对于较新的驱动程序，这是产品（及供应商）描述，通常来自内核的PCI ID数据库。
___字符串信息标签

S:  SerialNumber=ssss
|   |__此设备从设备读取的序列号
|      对于USB主机控制器驱动程序（虚拟根集线器），这是某个唯一ID，通常是总线ID（地址或插槽名称），不能与任何其他设备共享
___字符串信息标签



配置描述符信息
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
::

C:* #Ifs=dd Cfg#=dd Atr=xx MPwr=dddmA
| | |       |       |      |__最大功率（毫安）
| | |       |       |__属性
| | |       |__配置编号
| | |__接口数量
| |__ "*" 表示活动配置（其余的是 " "）
|__配置信息标签

USB设备可能有多个配置，每个配置的行为大不相同。例如，通过总线供电的配置可能远不如自供电配置强大。一次只能激活一个设备配置；大多数设备只有一个配置。
每个配置由一个或多个接口组成。每个接口提供一个独特的“功能”，通常绑定到不同的USB设备驱动程序。一个常见的例子是USB音箱，它有一个用于播放的音频接口和一个用于软件音量控制的HID接口。
接口描述符信息（每个配置可以有多个）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
::

I:* If#=dd Alt=dd #EPs=dd Cls=xx(sssss) Sub=xx Prot=xx Driver=ssss
| | |      |      |       |             |      |       |__驱动程序名称
| | |      |      |       |             |      |          或 "(none)"
| | |      |      |       |             |__接口协议
| | |      |      |       |__接口子类
| | |      |      |__端点数量
| | |      |__交替设置编号
| | |__接口编号
| |__ "*" 表示活动交替设置（其余的是 " ")
|__接口信息标签

给定的接口可能有一个或多个“交替”设置。例如，默认设置可能不会使用超过一小部分周期性带宽。为了使用显著比例的总线带宽，驱动程序必须选择一个非默认交替设置。一次只能激活一个接口设置，并且一次只能有一个驱动程序绑定到一个接口。大多数设备每个接口只有一个交替设置。
端点描述符信息（每个接口可以有多个）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

E:  Ad=xx(s) Atr=xx(ssss) MxPS=dddd Ivl=dddss
|   |        |            |         |__传输间隔（最大值）
|   |        |            |__端点最大包大小
|   |        |__属性（端点类型）
|   |__端点地址（I=输入，O=输出）
|__端点信息标签

对于所有周期性（中断或等时）端点，间隔是非零的。对于高速端点，传输间隔可能以微秒而不是毫秒为单位进行测量。
对于高速周期性端点，“端点最大包大小”反映了每微帧的数据传输大小。对于“高带宽”端点，这可以反映两个或三个包（最多每125微秒3千字节）每个端点。
通过 Linux-USB 栈，周期性带宽预留使用 URB 提供的传输间隔和大小，这些可能小于端点描述符中的值。
使用示例
~~~~~~~~

如果用户或脚本只对拓扑信息感兴趣，例如，可以使用类似 `grep ^T: /sys/kernel/debug/usb/devices` 的命令来获取仅包含拓扑行的信息。一个如 `grep -i ^[tdp]: /sys/kernel/debug/usb/devices` 这样的命令可用于列出以方括号内的字符开头的行，其中有效的字符为 TDPCIE。通过稍微高级一点的脚本，它可以显示任何选定的行（例如，仅显示 T、D 和 P 行）并更改其输出格式。（Perl 脚本 `procusb` 是这一想法的起点。它将列出从 TBDPSCIE 中选择的行或 `/sys/kernel/debug/usb/devices` 中的“所有”行。）

拓扑行可用于生成系统根集线器上 USB 设备的图形表示。（有关如何做到这一点，请参阅下面的更多内容。）

接口行可用于确定每个设备使用的驱动程序以及激活的备用设置。
配置行可用于列出系统的 USB 设备使用的最大功率（以毫安为单位）
例如，`grep ^C: /sys/kernel/debug/usb/devices`
以下是一个示例，来自一个具有 UHCI 根集线器、连接到根集线器的外部集线器以及连接到外部集线器的鼠标和串行转换器的系统：
::

	T:  Bus=00 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=12   MxCh= 2
	B:  Alloc= 28/900 us ( 3%), #Int=  2, #Iso=  0
	D:  Ver= 1.00 Cls=09(hub  ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
	P:  Vendor=0000 ProdID=0000 Rev= 0.00
	S:  Product=USB UHCI Root Hub
	S:  SerialNumber=dce0
	C:* #Ifs= 1 Cfg#= 1 Atr=40 MxPwr=  0mA
	I:  If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
	E:  Ad=81(I) Atr=03(Int.) MxPS=   8 Ivl=255ms

	T:  Bus=00 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=12   MxCh= 4
	D:  Ver= 1.00 Cls=09(hub  ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
	P:  Vendor=0451 ProdID=1446 Rev= 1.00
	C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=100mA
	I:  If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
	E:  Ad=81(I) Atr=03(Int.) MxPS=   1 Ivl=255ms

	T:  Bus=00 Lev=02 Prnt=02 Port=00 Cnt=01 Dev#=  3 Spd=1.5  MxCh= 0
	D:  Ver= 1.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
	P:  Vendor=04b4 ProdID=0001 Rev= 0.00
	C:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr=100mA
	I:  If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=mouse
	E:  Ad=81(I) Atr=03(Int.) MxPS=   3 Ivl= 10ms

	T:  Bus=00 Lev=02 Prnt=02 Port=02 Cnt=02 Dev#=  4 Spd=12   MxCh= 0
	D:  Ver= 1.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
	P:  Vendor=0565 ProdID=0001 Rev= 1.08
	S:  Manufacturer=Peracom Networks, Inc
	S:  Product=Peracom USB to Serial Converter
	C:* #Ifs= 1 Cfg#= 1 Atr=a0 MxPwr=100mA
	I:  If#= 0 Alt= 0 #EPs= 3 Cls=00(>ifc ) Sub=00 Prot=00 Driver=serial
	E:  Ad=81(I) Atr=02(Bulk) MxPS=  64 Ivl= 16ms
	E:  Ad=01(O) Atr=02(Bulk) MxPS=  16 Ivl= 16ms
	E:  Ad=82(I) Atr=03(Int.) MxPS=   8 Ivl=  8ms

仅选择这些行中的 `T:` 和 `I:` 行（例如，使用 `procusb ti`），我们有
::

	T:  Bus=00 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=12   MxCh= 2
	T:  Bus=00 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=12   MxCh= 4
	I:  If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
	T:  Bus=00 Lev=02 Prnt=02 Port=00 Cnt=01 Dev#=  3 Spd=1.5  MxCh= 0
	I:  If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=mouse
	T:  Bus=00 Lev=02 Prnt=02 Port=02 Cnt=02 Dev#=  4 Spd=12   MxCh= 0
	I:  If#= 0 Alt= 0 #EPs= 3 Cls=00(>ifc ) Sub=00 Prot=00 Driver=serial

物理上，这看起来像（或者可以转换为）:
::

                      +------------------+
                      |  PC/root_hub (12)|   Dev# = 1
                      +------------------+   (nn) 是 Mbps
Level 0           |  CN.0   |  CN.1  |   [CN = 连接器/端口 #]
                      +------------------+
                          /
                         /
            +-----------------------+
  Level 1   | Dev#2: 4-port hub (12)|
            +-----------------------+
            |CN.0 |CN.1 |CN.2 |CN.3 |
            +-----------------------+
                \           \____________________
                 \_____                          \
                       \                          \
               +--------------------+      +--------------------+
  Level 2      | Dev# 3: mouse (1.5)|      | Dev# 4: serial (12)|
               +--------------------+      +--------------------+


或者，以更像树形结构的形式（没有连接的端口 [连接器] 可以省略）:
::

	PC:  Dev# 1, 根集线器, 2 端口, 12 Mbps
	|_ CN.0:  Dev# 2, 集线器, 4 端口, 12 Mbps
	     |_ CN.0:  Dev #3, 鼠标, 1.5 Mbps
	     |_ CN.1:
	     |_ CN.2:  Dev #4, 串行, 12 Mbps
	     |_ CN.3:
	|_ CN.1:
