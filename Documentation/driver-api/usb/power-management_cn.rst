### USB电源管理

#### 电源管理
电源管理（PM）是指通过在部件未使用时将其挂起以节省能源的做法。当一个组件处于“挂起”状态时，它处于非工作、低功耗状态；有时甚至可能完全关闭。当内核需要使用该组件时，可以将其“恢复”到功能齐全的全功率状态。（还存在其他形式的PM，其中组件被置于功能较弱但仍可用的状态而非被挂起，例如降低CPU的时钟速率。本文档不会讨论这些其他形式。）

当被挂起的部分包括CPU和系统的大部分时，我们称之为“系统挂起”。当特定设备被关闭而整个系统保持运行时，我们称其为“动态挂起”（也称为“运行时挂起”或“选择性挂起”）。本文档主要关注USB子系统中动态PM的实现方式，尽管也一定程度上涵盖了系统PM的内容（有关系统PM的更多信息，请参阅`Documentation/power/*.rst`）。如果内核启用了`CONFIG_SUSPEND`或`CONFIG_HIBERNATION`，则会支持系统PM。USB的动态PM支持在内核启用`CONFIG_PM`时始终存在。
[历史上，USB的动态PM支持仅在内核启用了`CONFIG_USB_SUSPEND`（依赖于`CONFIG_PM_RUNTIME`）时才存在。从3.10版本开始，只要内核启用了`CONFIG_PM_RUNTIME`，就存在USB的动态PM支持。`CONFIG_USB_SUSPEND`选项已被移除。]

#### 远程唤醒
当设备被挂起后，通常要等到计算机指示它恢复时才会恢复。同样地，如果整个计算机被挂起，则通常要等到用户按下电源按钮或打开盖子等操作来指示计算机恢复。然而，一些设备具有自行恢复、请求内核恢复它们，甚至指示整个计算机恢复的能力。这种能力有多种名称，如“网络唤醒”；我们将统称为“远程唤醒”。当一个设备启用了远程唤醒并被挂起时，它可能会根据外部事件自行恢复（或发送恢复请求），例如，当按键被按下时，挂起的键盘会恢复，或者当设备插入时，挂起的USB集线器会恢复。

#### USB设备何时处于空闲状态
当内核认为设备没有忙于任何重要的事情时，即为处于空闲状态，因此成为可以被挂起的候选对象。确切的定义取决于设备的驱动程序；驱动程序可以声明设备即使没有任何实际通信发生也不处于空闲状态。（例如，除非所有连接到该集线器的设备已经被挂起，否则集线器不被认为是空闲的。）此外，只要程序保持其usbfs文件打开，无论是否正在进行I/O操作，设备都不会被视为空闲。
如果USB设备没有驱动程序、其usbfs文件未打开，并且未通过sysfs访问，则肯定处于空闲状态。

#### 动态PM的形式
动态挂起发生在内核决定挂起空闲设备的时候。这简称为“自动挂起”（autosuspend）。通常，除非设备已经空闲了一定的最短时间（所谓的空闲延迟时间），否则不会进行自动挂起。
当然，内核主动采取的任何措施都不应妨碍计算机及其设备正常工作。如果设备已被自动挂起，而程序尝试使用它，内核将自动恢复该设备（autoresume）。出于同样的原因，如果设备支持远程唤醒，通常会对自动挂起的设备启用远程唤醒。
值得一提的是，许多USB驱动程序并不支持自动挂起。事实上，在撰写本文时（Linux 2.6.23），唯一支持它的驱动程序是集线器驱动、kaweth、asix、usblp、usblcd和usb-skeleton（后者不算在内）。如果一个不支持自动挂起的驱动程序绑定到设备上，那么该设备将不会被自动挂起。实际上，内核假定该设备从未处于空闲状态。
我们可以将电源管理事件大致分为两类：外部和内部。外部事件是由USB堆栈之外的某些代理触发的，例如系统挂起/恢复（由用户空间触发）、手动动态恢复（同样由用户空间触发），以及远程唤醒（由设备触发）。内部事件是指在USB堆栈内部触发的事件，如自动挂起和自动恢复。需要注意的是所有动态挂起事件都是内部的；不允许外部代理发出动态挂起。

### 动态电源管理的用户界面

控制动态电源管理的用户界面位于每个USB设备的sysfs目录中的`power/`子目录中，即在`/sys/bus/usb/devices/.../power/`，其中"..."是设备的ID。相关的属性文件包括：wakeup、control 和 `autosuspend_delay_ms`。（也可能存在一个名为`level`的文件；此文件自2.6.35内核开始已废弃，并被`control`文件取代。在2.6.38中，`autosuspend`文件将被废弃并被`autosuspend_delay_ms`文件取代。两者的唯一区别在于较新的文件以毫秒表示延迟，而较旧的文件使用秒。令人困惑的是，在2.6.37中这两个文件都存在，但只有`autosuspend`有效。）

- `power/wakeup`

    如果设备不支持远程唤醒，则此文件为空。否则，该文件包含单词`enabled`或`disabled`，并且您可以将这些词写入文件。设置决定了当设备下次被挂起时是否启用远程唤醒。（如果在设备处于挂起状态时更改了设置，则更改不会立即生效，直到下一次挂起。）

- `power/control`

    此文件包含两个词之一：“on”或“auto”，您可以将这些词写入文件以更改设备的设置。
    - `on`意味着应恢复设备，并且不允许自动挂起。（当然，系统挂起仍然允许。）
    - `auto`是正常状态，在这种状态下内核允许自动挂起和自动恢复设备。（在2.6.32及更早版本的内核中，还可以指定`suspend`，这意味着设备应保持挂起状态，并且不允许自动恢复。此设置不再受支持。）

- `power/autosuspend_delay_ms`

    此文件包含一个整数值，表示设备应在内核自动将其挂起之前保持空闲的时间（以毫秒为单位）。默认值为2000。0表示一旦设备变得空闲就立即自动挂起，负数则意味着从不自动挂起。您可以将数字写入文件来改变自动挂起的空闲延迟时间。
    将`-1`写入`power/autosuspend_delay_ms`和将`on`写入`power/control`基本上做了相同的事情——它们都阻止设备被自动挂起。是的，这是API中的冗余。
    （在2.6.21中，将`0`写入`power/autosuspend`会阻止设备被自动挂起；在2.6.22中行为发生了变化。`power/autosuspend`属性在2.6.21之前不存在，`power/level`属性在2.6.22之前也不存在。`power/control`是在2.6.34中添加的，而`power/autosuspend_delay_ms`是在2.6.37中添加的，但在2.6.38中才变得可用。）

### 改变默认空闲延迟时间

默认的自动挂起空闲延迟时间（以秒为单位）由usbcore模块的一个参数控制。您可以在加载usbcore时指定其值。例如，要将其设置为5秒而不是2秒，可以这样做：
```shell
modprobe usbcore autosuspend=5
```
或者，您可以在/etc/modprobe.d中的配置文件中添加一行：
```shell
options usbcore autosuspend=5
```
一些发行版在引导过程中非常早地加载usbcore模块，通过从initramfs映像运行的程序或脚本实现。为了更改参数值，您需要重建该映像。
如果usbcore被编译到内核中而不是作为可加载模块构建，您可以在内核的启动命令行中添加：
```shell
usbcore.autosuspend=5
```
最后，可以在系统运行时更改参数值。如果您执行以下操作：
```shell
echo 5 >/sys/module/usbcore/parameters/autosuspend
```
那么每个新USB设备的自动挂起空闲延迟都将初始化为5秒。（现有设备的空闲延迟值不会受到影响。）

将初始默认空闲延迟设置为-1将防止任何USB设备的自动挂起。这样做的好处是可以让您随后为选定的设备启用自动挂起。

### 警告

USB规范规定所有USB设备必须支持电源管理。然而，不幸的事实是许多设备并不很好地支持它。您可以正确地挂起它们，但当您尝试恢复它们时，它们会自行断开与USB总线的连接或完全停止工作。这种情况似乎特别普遍存在于打印机和扫描仪中，但其他类型的设备也有同样的缺点。
因此，默认情况下内核禁用了自动挂起功能（`power/control` 属性被初始化为 `on`），除了集线器以外的所有设备。至少，集线器在这方面表现得相当合理。
（在 2.6.21 和 2.6.22 版本中情况并非如此。那时几乎所有的 USB 设备默认都启用了自动挂起功能。许多人因此遇到了问题。）

这意味着非集线器设备除非用户或某个程序明确启用，否则不会自动挂起。到目前为止，并没有广泛使用的程序能够执行这项操作；我们希望在不久的将来，像 HAL 这样的设备管理器将承担起这一额外的责任。在此期间，你可以手动执行必要的操作，或者将它们添加到 udev 脚本中。你也可以更改空闲延迟时间；2 秒对于所有设备来说并不是最佳选择。
如果驱动程序知道其设备支持恰当的挂起/恢复操作，它可以自行启用自动挂起功能。例如，笔记本电脑网络摄像头的视频驱动可能会这样做（在较新的内核版本中确实如此），因为这些设备很少使用，因此通常应该自动挂起。
有时即使设备与自动挂起功能配合良好，仍然会存在问题。例如，usbhid 驱动（用于管理键盘和鼠标）支持自动挂起。对多款键盘进行的测试表明，在已挂起的键盘上打字虽然能正常触发远程唤醒，但经常会导致按键丢失。对鼠标进行的测试显示，某些鼠标仅在按下按钮时发出远程唤醒请求，而不在移动时发出，还有一些鼠标在这两种情况下都不发出唤醒请求。
内核不会阻止你在无法处理自动挂起的设备上启用该功能。理论上甚至有可能因在不适当的时间挂起设备而导致设备损坏。（虽然可能性极小，但并非不可能。）请小心行事。
电源管理的驱动接口
----------------------

USB 驱动支持外部电源管理的要求相当简单；驱动只需在其 `usb_driver` 结构体中定义如下方法：

- `suspend`
- `resume`
- `reset_resume`

其中 `reset_resume` 方法是可选的。这些方法的任务非常简单：

- `suspend` 方法会在设备即将被挂起之前被调用以警告驱动程序。如果驱动返回负的错误代码，则挂起操作会被终止。通常情况下，驱动会返回 0，此时它必须取消所有正在进行的 URB（使用 `usb_kill_urb` 函数）且不再提交新的 URB。
- `resume` 方法会在设备已被恢复并允许驱动程序恢复正常运行时被调用。此时可以重新提交 URB。
- `reset_resume` 方法会在设备恢复并且同时被重置时被调用。驱动程序应重新进行必要的设备初始化工作，因为设备可能已经丢失了大部分或全部状态（尽管接口仍处于挂起前相同的交替设置状态）。

如果设备在挂起状态下断开连接或断电，将调用 `disconnect` 方法而不是 `resume` 或 `reset_resume` 方法。当从休眠中唤醒时，这也极有可能发生，因为许多系统在休眠期间不会向 USB 主控制器维持挂起电流。（可以通过使用 USB 持久化设施来解决休眠导致断开连接的问题。）

`reset_resume` 方法被 USB 持久化设施（参见 `usb-persist`）所使用，并且在未启用 `CONFIG_USB_PERSIST` 的情况下也可以在某些特定条件下使用。目前，如果设备在恢复过程中被重置且驱动没有提供 `reset_resume` 方法，那么驱动将不会收到任何关于恢复的通知。在之后的内核版本中将调用驱动的 `disconnect` 方法；但在 2.6.23 中并未实现这一点。
USB驱动程序绑定到接口上，因此它们的“挂起”和“恢复”方法会在接口被挂起或恢复时被调用。原则上，人们可能希望在不挂起设备上的其他接口的情况下挂起某些接口（即，强制这些接口的驱动程序停止所有活动）。但是USB核心不允许这样做；当设备本身被挂起时，所有接口都会被挂起，并且当设备恢复时，所有接口都会被恢复。不可能只挂起或恢复设备的部分接口而不是全部。最接近的做法是解除绑定接口的驱动程序。

### 自动挂起和自动恢复的驱动接口

为了支持自动挂起和自动恢复，一个驱动程序应该实现上面列出的所有三种方法。此外，驱动程序通过设置其`usb_driver`结构中的`supports_autosuspend`标志来表示它支持自动挂起。然后，它负责在接口变得繁忙或空闲时通知USB核心。驱动程序通过调用以下六个函数来实现这一点：

```c
int  usb_autopm_get_interface(struct usb_interface *intf);
void usb_autopm_put_interface(struct usb_interface *intf);
int  usb_autopm_get_interface_async(struct usb_interface *intf);
void usb_autopm_put_interface_async(struct usb_interface *intf);
void usb_autopm_get_interface_no_resume(struct usb_interface *intf);
void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);
```

这些函数通过维护`usb_interface`的嵌入式设备结构中的使用计数器来工作。当计数器大于0时，则认为接口是繁忙的，内核不会自动挂起该接口的设备。当使用计数器等于0时，则认为接口处于空闲状态，内核可能会自动挂起该设备。

驱动程序必须小心地平衡对使用计数器的整体更改。不平衡的"获取"操作在驱动程序与其接口解除绑定后仍然有效，这会阻止设备进入运行时挂起状态，即使接口再次被另一个驱动程序绑定也是如此。另一方面，允许驱动程序在返回了`disconnect`例程之后（例如，在工作队列例程中）调用`usb_autopm_*`函数来达到这种平衡，前提是它们保留了对接口的有效引用（通过`usb_get_intf`和`usb_put_intf`）。

使用异步例程的驱动程序需要负责自己的同步和互斥。

- `usb_autopm_get_interface`增加使用计数器，并在设备被挂起时尝试自动恢复。如果自动恢复失败，计数器将被递减回去。
- `usb_autopm_put_interface`减少使用计数器，并在新值等于0时尝试自动挂起。
- `usb_autopm_get_interface_async`和`usb_autopm_put_interface_async`几乎与它们的非异步对应函数做同样的事情。主要区别在于它们使用工作队列来执行恢复或挂起部分的工作。因此，它们可以在原子上下文中调用，比如URB的完成处理器中，但当它们返回时，设备通常还没有处于期望的状态。
- `usb_autopm_get_interface_no_resume`和`usb_autopm_put_interface_no_suspend`仅仅增加或减少使用计数器；它们不尝试执行自动恢复或自动挂起。因此它们可以在原子上下文中调用。

最简单的使用模式是在驱动程序的打开例程中调用`usb_autopm_get_interface`，并在关闭或释放例程中调用`usb_autopm_put_interface`。但也存在其他可能的模式。

上述提到的自动挂起尝试常常会因为某种原因而失败。例如，“power/control”属性可能被设置为“on”，或者同一设备中的另一个接口可能不是空闲状态。这是完全正常的。如果失败的原因是因为设备还没有空闲足够长的时间，那么将安排一个定时器，在自动挂起空闲延迟到期时自动执行该操作。
自动恢复尝试也可能失败，尽管失败意味着设备已不再存在或无法正常运行。与自动挂起不同的是，自动恢复没有空闲延迟。
驱动程序接口的其他部分
------------------------------

驱动程序可以通过调用以下函数来为其设备启用自动挂起：

	usb_enable_autosuspend(struct usb_device *udev);

在他们的:c:func:`probe`例程中，如果他们知道设备能够正确地挂起和恢复。这等同于向设备的`power/control`属性写入`auto`。同样地，驱动程序可以通过调用以下函数来禁用自动挂起：

	usb_disable_autosuspend(struct usb_device *udev);

这与向`power/control`属性写入`on`完全相同。有时驱动程序需要确保在自动挂起期间远程唤醒功能被启用。例如，如果用户不能通过敲击键盘来触发远程唤醒，那么对键盘进行自动挂起就没有多大意义。如果驱动程序将`intf->needs_remote_wakeup`设置为1，内核只有在远程唤醒可用时才会自动挂起该设备。（但如果设备已经自动挂起，则设置此标志不会导致内核自动恢复它。通常驱动程序会在其`probe`方法中设置此标志，在这时设备保证没有被自动挂起。）

如果驱动程序在中断上下文中异步执行I/O操作，它应该在开始输出之前调用:c:func:`usb_autopm_get_interface_async`，并在输出队列排空时调用:c:func:`usb_autopm_put_interface_async`。当它接收到输入事件时，应在事件处理器中调用：

	usb_mark_last_busy(struct usb_device *udev);

这告诉电源管理核心，设备刚刚处于忙碌状态，因此下一个自动挂起的空闲延迟应被推迟。许多usb_autopm_*例程也会进行这样的调用，因此驱动程序只需关注中断驱动的输入到达的情况。
异步操作总是容易出现竞态条件。例如，驱动程序可能在内核刚刚决定设备已经足够长时间空闲但还没有来得及调用驱动程序的`suspend`方法的时候调用:c:func:`usb_autopm_get_interface_async`例程。`suspend`方法必须负责与I/O请求例程和URB完成处理程序同步；如果驱动程序需要使用该设备，它应该使自动挂起以-EBUSY失败。
外部挂起调用不应以这种方式失败，只有自动挂起调用可以。驱动程序可以通过将:c:func:`PMSG_IS_AUTO`宏应用于`suspend`方法的消息参数来区分它们；对于内部PM事件（自动挂起）它将返回真，而对于外部PM事件则返回假。
互斥
--------------

对于外部事件——但不一定对于自动挂起或自动恢复——在调用`suspend`或`resume`方法时会持有设备信号量（udev->dev.sem）。这意味着外部挂起/恢复事件与`probe`、`disconnect`、`pre_reset`和`post_reset`调用是互斥的；USB核心保证这对于自动挂起/自动恢复事件也成立。
如果驱动程序希望在某个关键代码段期间阻止所有挂起/恢复调用，最好的方法是锁定设备并调用:c:func:`usb_autopm_get_interface`（并在关键代码段结束时做相反的操作）。持有设备信号量将阻止所有外部PM调用，而:c:func:`usb_autopm_get_interface`将防止任何内部PM调用，即使它失败了。（思考题：为什么？）

动态PM与系统PM之间的交互
--------------------------------------------

动态电源管理和系统电源管理可以在几种方式下相互作用。

首先，当系统挂起发生时，设备可能已经被自动挂起了。由于系统挂起应该尽可能透明，因此在系统恢复后设备应保持挂起状态。但这一理论在实践中可能并不理想；随着时间推移，内核在这方面的行为已经发生变化。截至2.6.37版本，策略是在系统恢复期间恢复所有设备，并让它们之后自行处理运行时挂起。

其次，在系统挂起过程中可能会发生动态电源管理事件。这个窗口很短，因为系统挂起时间不长（通常几秒钟），但它确实可能发生。

例如，挂起的设备可能在系统挂起过程中发送一个远程唤醒信号。远程唤醒可能成功，这将导致系统挂起被取消。如果远程唤醒不成功，它仍可能保持活跃状态，从而导致系统一完成挂起就立即恢复。或者远程唤醒可能失败并丢失。哪种结果出现取决于时机以及硬件和固件设计。
xHCI 硬件链接电源管理
---------------------

xHCI 主控制器为 USB 2.0（xHCI 1.0 特性）和 USB 3.0 设备提供硬件链接电源管理，这些设备支持链接电源管理 (LPM)。通过启用硬件 LPM，主机可以自动将设备置于较低功耗状态（对于 USB 2.0 设备是 L1 状态，对于 USB 3.0 设备是 U1 或 U2 状态），在这种状态下，设备能够快速进入和恢复。
控制硬件 LPM 的用户界面位于每个 USB 设备的 sysfs 目录的 `power/` 子目录中，即在 `/sys/bus/usb/devices/.../power/` 中，其中 "..." 是设备的 ID。相关的属性文件为 `usb2_hardware_lpm` 和 `usb3_hardware_lpm`。

`power/usb2_hardware_lpm`

	当一个支持 LPM 的 USB 2.0 设备连接到支持软件 LPM 的 xHCI 主机根集线器时，主机将对该设备进行软件 LPM 测试；如果设备成功进入 L1 状态并恢复，并且主机支持 USB 2.0 硬件 LPM，则此文件将出现，驱动程序将为该设备启用硬件 LPM。您可以通过向文件写入 y/Y/1 或 n/N/0 来手动启用或禁用 USB 2.0 硬件 LPM。这主要用于测试目的。

`power/usb3_hardware_lpm_u1`
`power/usb3_hardware_lpm_u2`

	当一个支持 LPM 的 USB 3.0 设备插入支持链接 PM 的 xHCI 主机时，它会检查 BOS 描述符中是否设置了 U1 和 U2 退出延迟；如果检查通过并且主机支持 USB 3.0 硬件 LPM，则将为该设备启用 USB 3.0 硬件 LPM，并创建这些文件。这些文件包含一个字符串值（启用或禁用），表示 USB 3.0 硬件 LPM U1 或 U2 是否已为设备启用。

USB 端口电源控制
----------------------

除了暂停端点设备和启用硬件控制的链接电源管理外，USB 子系统还能够在某些条件下关闭端口电源。电源通过向集线器发送“设置/清除端口特性(PORT_POWER)”请求来控制。
对于根集线器或平台内部集线器的情况，主控制器驱动程序将 “PORT_POWER” 请求转换为对平台固件 (ACPI) 方法调用来设置端口电源状态。更多背景信息，请参阅 Linux Plumbers Conference 2012 的幻灯片 [#f1]_ 和视频 [#f2]_：

接收到 “清除端口特性(PORT_POWER)” 请求后，USB 端口将逻辑上关闭，并可能触发实际的 VBUS 电源丢失到端口 [#f3]_。在多个端口被组合在一起共享同一电源的情况下，即使只有一个端口处于开启状态，也可能维持 VBUS 电源直到所有端口都被关闭。此外，配置为充电应用的集线器端口也可能维持 VBUS 电源。无论哪种情况，逻辑上关闭的端口将失去与设备的连接，不会响应热插拔事件，也不会响应远程唤醒事件。
.. 警告::

   关闭端口可能会导致无法热添加设备

请参见“端口电源控制的用户界面”了解详细信息。
关于对设备本身的影响，它类似于系统挂起期间设备所经历的情况，即电源会话丢失。任何在系统挂起时表现异常的 USB 设备或驱动程序也会受到端口电源循环事件的类似影响。因此，实现共享了与集线器系统恢复路径相同的设备恢复路径（并遵循相同的特殊处理）。

.. [#f1] 
  http://dl.dropbox.com/u/96820575/sarah-sharp-lpt-port-power-off2-mini.pdf

.. [#f2]
  http://linuxplumbers.ubicast.tv/videos/usb-port-power-off-kerneluserspace-api/

.. [#f3]
  USB 3.1 第 10.12 节

  唤醒说明：如果设备被配置为发送唤醒事件，则端口电源控制实现将阻止对该端口的电源关闭尝试。

端口电源控制的用户界面
------------------------------

端口电源控制机制使用 PM 运行时系统。通过清除端口设备的 `power/pm_qos_no_power_off` 标志来请求电源关闭（默认值为 1）。如果端口未连接，则会立即向其发送 `ClearPortFeature(PORT_POWER)` 请求。否则，它将遵守 PM 运行时规则，并要求连接的子设备及其所有后代设备处于挂起状态。此机制依赖于集线器在其集线器描述符中宣传端口电源切换功能（wHubCharacteristics 字段中的逻辑电源切换模式）。
需要注意的是，一些接口设备/驱动程序不支持自动挂起。用户空间可能需要在 `usb_device` 挂起之前解除绑定这些接口驱动程序。解除绑定的接口设备默认处于挂起状态。解除绑定时，请小心不要解除父级 USB 设备的驱动程序绑定。同时，保留集线器接口驱动程序的绑定。如果解绑了 USB 设备（而非接口）的驱动程序，则内核将无法再恢复该设备。如果解绑了集线器接口驱动程序，则会失去对其子端口的控制，所有连接的子设备都将断开连接。一个很好的经验法则是，如果设备的“驱动/模块”链接指向 `/sys/module/usbcore`，那么解绑它将干扰端口电源控制。

以下是与端口电源控制相关的文件示例。请注意，在这个例子中，这些文件是相对于 USB 集线器设备的（前缀）：

     prefix=/sys/devices/pci0000:00/0000:00:14.0/usb3/3-1

                      连接的子设备 +  
                  集线器端口设备 +         |
     集线器接口设备 +       |         |
                          v       v         v
                  $prefix/3-1:1.0/3-1-port1/device

     $prefix/3-1:1.0/3-1-port1/power/pm_qos_no_power_off
     $prefix/3-1:1.0/3-1-port1/device/power/control
     $prefix/3-1:1.0/3-1-port1/device/3-1.1:<intf0>/driver/unbind
     $prefix/3-1:1.0/3-1-port1/device/3-1.1:<intf1>/driver/unbind
     ..
$prefix/3-1:1.0/3-1-port1/device/3-1.1:<intfN>/driver/unbind

除了这些文件外，某些端口还可能有一个指向另一个集线器上端口的“peer”链接。预期是所有超高速端口都有一个高速同伴：

  $prefix/3-1:1.0/3-1-port1/peer -> ../../../../usb2/2-1/2-1:1.0/2-1-port1
  ../../../../usb2/2-1/2-1:1.0/2-1-port1/peer -> ../../../../usb3/3-1/3-1:1.0/3-1-port1

不同于“companion 端口”或“ehci/xhci 共享切换端口”，同伴端口只是高速和超高速接口引脚组合成单个 USB3 连接器。同伴端口共享同一个祖先 XHCI 设备。

当超高速端口被关闭时，设备可能会降级其连接并尝试连接到高速引脚。实现采取了以下步骤来防止这种情况：

1. 端口挂起被顺序化以保证高速端口在它们的超高速同伴被允许关闭之前被关闭。这意味着将 `pm_qos_no_power_off` 设置为零可能不会导致超高速端口立即关闭，直到其高速同伴进入运行时挂起状态。用户空间必须注意挂起顺序，以确保超高速端口能够关闭。
2. 端口恢复被顺序化以强制超高速端口在高速同伴之前开启。
3. 端口恢复总是触发连接的子设备恢复。在电源会话丢失后，设备可能已被移除或需要重置。当父端口重新获得电源时恢复子设备解决了这些状态问题，并将最大端口电源循环频率限制在子设备可以挂起（自动挂起延迟）和恢复（重置-恢复延迟）的速度范围内。
与端口电源控制相关的sysfs文件：

``<hubdev-portX>/power/pm_qos_no_power_off``：
    这个可写标志控制空闲端口的状态。
一旦所有子设备及其后代都已挂起，
如果 `pm_qos_no_power_off` 的值为 `'0'`，则允许端口挂起/关闭电源。如果 `pm_qos_no_power_off` 的值为 `'1'`，
无论后代的状态如何，该端口将保持活动/供电状态。默认值为 1。

``<hubdev-portX>/power/runtime_status``：
    此文件反映了端口是处于“活动”（电源开启）还是“挂起”（逻辑上关闭）状态。
没有指示用户空间 VBUS 是否仍然供电。

``<hubdev-portX>/connect_type``：
    这是一个只读的指示性标志，用于向用户空间指示端口的位置和连接类型。
它返回四个值之一：“hotplug”、“hardwired”、“not used”和“unknown”。除了“unknown”之外的所有值都由平台固件设置。

``hotplug`` 表示平台上的一个外部可连接/可见端口。
通常情况下，用户空间会选择保持此类端口的供电状态以处理新的设备连接事件。

``hardwired`` 指的是不可见但可连接的端口。
例如，内部USB蓝牙端口可以通过外部开关断开连接，或者是一个内置有USB摄像头的端口。
在确保 `pm_qos_no_power_off` 与任何开关协调的情况下，让这些端口挂起被认为是安全的。
用户空间必须在端口关闭电源之前安排好设备连接，或者在通过开关启用连接前激活端口。

``not used`` 指的是预期永远不会有任何设备连接的内部端口。
这些可能是空的内部端口或平台上物理上未暴露的端口。始终认为可以安全地关闭电源。

``unknown`` 表示平台固件未为此端口提供信息。
最常见的指外部集线器端口，在策略决策中应视为“hotplug”。

.. note::
   
   - 由于我们依赖BIOS来获取正确的ACPI信息，因此USB端口描述可能会缺失或错误。
   - 在清除 `pm_qos_no_power_off` 时要小心。一旦电源关闭，此端口将不会响应新的连接事件。
一旦子设备连接上，会在允许端口关闭电源之前施加额外的限制：
``<child>/power/control``:
    必须设置为`auto`，并且端口不会关闭电源直到`<child>/power/runtime_status`反映出'suspended'状态。默认值由子设备驱动程序控制。
``<child>/power/persist``:
    对于大多数设备，默认值为`1`，表示内核是否可以在失去电源会话（挂起/端口电源事件）的情况下保留设备配置。当此值为`0`（特例设备），端口关闭电源功能被禁用。
``<child>/driver/unbind``:
    支持唤醒的设备会阻止端口关闭电源。目前唯一清除接口设备内部唤醒能力的方法是卸载其驱动程序。

关于与端口设备相关的关闭电源前提设置的总结：

```
echo 0 > power/pm_qos_no_power_off
echo 0 > peer/power/pm_qos_no_power_off # 如果存在的话
echo auto > power/control # 这是默认值
echo auto > <child>/power/control
echo 1 > <child>/power/persist # 这是默认值
```

建议用户空间端口电源策略
------------------------------

如上所述，用户空间需要谨慎并有意识地决定哪些端口可以关闭电源。
默认配置是所有端口都以`power/pm_qos_no_power_off`设置为`1`开始，这使得端口始终处于活动状态。
如果对平台固件描述的端口（端口的ACPI _PLD记录填充了'connect_type'）有信心，用户空间可以清除所有“未使用”端口的pm_qos_no_power_off。对于“硬连线”端口也可以这样做，前提是关闭电源与任何端口连接开关协调一致。
一个更为激进的用户空间策略是在某些外部因素表明用户已停止与系统交互时，为所有端口启用USB端口电源关闭（设置`<hubdev-portX>/power/pm_qos_no_power_off`为`0`）。例如，一个发行版可能希望在屏幕变暗时启用所有USB端口的电源关闭，并在屏幕激活时重新供电。智能手机和平板电脑可能希望在用户按下电源按钮时关闭USB端口的电源。
