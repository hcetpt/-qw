========================
Linux 的 USB Gadget API
========================

:作者: David Brownell
:日期:   2004年8月20日

简介
============

本文档介绍了一个用于嵌入式Linux的USB“Gadget”内核模式API，适用于在嵌入式Linux中的外设和其他USB设备中使用。它概述了API结构，并展示了如何将其应用于系统开发项目。这是首次在Linux上发布的此类API，旨在解决多个重要问题，包括：

- 支持USB 2.0，使得高速设备能够以每秒数十兆字节的速度传输数据。
- 能够处理具有数十个端点的设备，就像处理只有两个固定功能端点的设备一样。Gadget驱动程序可以编写得易于移植到新硬件。
- 具有足够的灵活性来暴露更复杂的USB设备能力，如多种配置、多个接口、复合设备以及备用接口设置。
- 支持USB“On-The-Go”（OTG），并配合对Linux-USB主机侧的更新。
- 与Linux-USB主机侧API共享数据结构和API模型。这有助于OTG支持，并展望未来更加对称的框架（其中同一I/O模型被主机侧和设备侧驱动程序同时使用）。
- 极简主义设计，以便更容易支持新的设备控制器硬件。I/O处理不需要大量内存或CPU资源。
大多数Linux开发者将无法使用此API，因为他们拥有PC、工作站或服务器中的USB“主机”硬件。而拥有嵌入式系统的Linux用户更有可能拥有USB外设硬件。为了区分在这些硬件内部运行的驱动程序与更为熟悉的Linux“USB设备驱动程序”（它们是主机侧代表实际USB设备的代理），我们使用不同的术语：在这些外设内部的驱动程序称为“USB Gadget驱动程序”。在USB协议交互中，设备驱动程序是主控方（或“客户端驱动程序”），而Gadget驱动程序是从属方（或“功能驱动程序”）。
Gadget API类似于主机侧的Linux-USB API，因为两者都使用请求对象队列来封装I/O缓冲区，并且这些请求可以提交或取消。它们共同定义了标准USB *第9章*消息、结构和常量。此外，两种API都可以绑定和解绑驱动程序与设备。尽管在细节上存在差异（主机侧当前的URB框架暴露了一些不适合Gadget API的实现细节和假设），但控制传输和配置管理的模型必须有所不同（一方是硬件无关的主控方，另一方是硬件感知的从属方）。但是，这里使用的端点I/O API也适用于一个减少开销的主机侧API。
Gadget驱动程序的结构
===========================

在USB外设中运行的系统通常在内核中有至少三层来处理USB协议处理，可能还有额外的层位于用户空间代码中。`gadget` API由中间层使用，以与最低层（直接处理硬件）进行交互。
在 Linux 中，从底层到高层，这些层分别是：

*USB 控制器驱动*
    这是最低级别的软件层。它是唯一与硬件通过寄存器、FIFO、DMA、IRQ 等进行通信的层。`<linux/usb/gadget.h>` API 抽象了外设控制器端点硬件。该硬件通过端点对象暴露出来，这些对象接受 IN/OUT 缓冲区流，并通过回调与小工具驱动程序交互。由于普通的 USB 设备只有一个上游端口，因此它们只有一个这样的驱动程序。控制器驱动程序可以支持任何数量的不同小工具驱动程序，但一次只能使用其中一个。
此类控制器硬件的例子包括基于 PCI 的 NetChip 2280 USB 2.0 高速控制器、SA-11x0 或 PXA-25x UDC（在许多 PDA 中发现）以及各种其他产品。
*小工具驱动*
    此驱动程序的较低边界实现了硬件中立的 USB 功能，通过调用控制器驱动程序来实现。由于此类硬件在能力和限制方面差异很大，并且用于空间有限的嵌入式环境中，因此小工具驱动程序通常在编译时配置以与特定控制器支持的端点一起工作。小工具驱动程序可能使用条件编译便携到几种不同的控制器。（最近的内核通过为许多面向块的驱动程序自动配置端点大大简化了支持新硬件的工作量。）小工具驱动程序的责任包括：

    - 处理设置请求（ep0 协议响应），可能包括特定于类的功能。

    - 返回配置和字符串描述符。

    - （重）设置配置和接口 altsettings，包括启用和配置端点。

    - 处理生命周期事件，如管理与硬件的绑定、USB 暂停/恢复、远程唤醒和与 USB 主机断开连接。
- 管理所有当前已启用端点上的 IN 和 OUT 转发。

    此类驱动程序可能是专有代码的模块，尽管这种方法在 Linux 社区中并不鼓励。
*上层*
    大多数小工具驱动程序都有一个上界，连接到 Linux 中的某些 Linux 驱动程序或框架。通过这个边界流动的是小工具驱动程序通过 USB 上的协议转发产生的和/或消费的数据。例子包括：

    - 用户模式代码，使用通用（gadgetfs）或应用程序特定的 `/dev` 目录中的文件。

    - 网络子系统（对于网络小工具，如 CDC 以太网模型小工具驱动程序）。

    - 数据捕获驱动程序，可能是视频4Linux 或扫描仪驱动程序；或者测试和测量硬件。
- 输入子系统（对于 HID 小工具）。

    - 声音子系统（对于音频小工具）。

    - 文件系统（对于 PTP 小工具）。

    - 块 I/O 子系统（对于 usb-storage 小工具）。

    - 以及更多。
*附加层*
    可能存在其他层。这些可能包括内核层，例如网络协议栈，以及基于标准 POSIX 系统调用 API（如 `open()`、`close()`、`read()` 和 `write()`）构建的用户模式应用程序。在较新的系统上，POSIX 异步 I/O 调用可能是一个选项。此类用户模式代码不一定受 GNU 通用公共许可证（GPL）约束。
具备 OTG 功能的系统还将需要包含标准 Linux-USB 主机侧堆栈，其中包括 `usbcore`、一个或多个 *主机控制器驱动*（HCD）、*USB 设备驱动* 来支持 OTG "目标外围设备列表" 等等。还将有一个 *OTG 控制器驱动*，它仅间接对小工具和设备驱动程序开发人员可见。
这有助于主机和设备侧 USB 控制器实现两种新的 OTG 协议（HNP 和 SRP）。角色切换（主机到外围设备，反之亦然）使用 HNP 在 USB 暂停处理期间进行，而 SRP 可以被视为一种更省电的设备唤醒协议。
随着时间的推移，可重用实用程序正在发展，以帮助简化一些小工具驱动任务。例如，从配置接口和端点的描述符向量构建配置描述符现在是自动化的，并且许多驱动程序现在使用自动配置来选择硬件端点并初始化其描述符。一个特别感兴趣的潜在例子是实现了 HID、网络、存储或音频类的标准 USB-IF 协议的代码。一些开发人员对 KDB 或 KGDB 钩子感兴趣，以便能够远程调试目标硬件。大多数此类 USB 协议代码不需要针对特定硬件，就像 X11、HTTP 或 NFS 等网络协议一样。此类小工具侧接口驱动程序最终应该被组合起来，以实现复合设备。
内核模式小工具 API
====================

小工具驱动程序通过 `struct usb_gadget_driver` 宣告自身，它负责结构体 `usb_gadget` 的大部分枚举部分。对 `set_configuration` 的响应通常涉及启用由小工具暴露的一个或多个 `struct usb_ep` 对象，并提交一个或多个 `struct usb_request` 缓冲区以传输数据。理解这四种数据类型及其操作，您将理解此 API 的工作原理。
请注意：

    除了“第9章”中的数据类型之外，大多数重要的数据类型和函数都在这里进行了描述。
然而，你正在阅读的内容中可能遗漏了一些相关信息。一个这样的信息示例是端点自动配置。为了完全理解API，你需要阅读头文件，并参考示例源代码（例如"Gadget Zero"的代码）。
实现一些基本驱动功能的API部分特定于所使用的Linux内核版本。2.6及更高版本的内核包含了一个没有在早期内核中出现的*驱动模型*框架；因此，gadget API的这些部分不是完全可移植的。（它们在2.4内核上实现，但方式不同。）驱动模型的状态是此API的另一部分，kerneldoc工具并未涉及这部分内容。
核心API并没有暴露所有可能的硬件特性，只包括最广泛可用的特性。存在一些重要的硬件特性，例如设备到设备的DMA（无需临时存储在内存缓冲区中），这类特性需要通过特定硬件的API来添加。
此API允许驱动程序使用条件编译来处理不同硬件的端点能力问题，但这并非强制性的要求。硬件往往具有与传输类型、寻址、数据包大小、缓冲和可用性相关的任意限制。通常而言，这些差异只对处理设备配置和管理的“端点零”逻辑产生影响。API通过端点命名约定支持有限的运行时能力检测。
许多驱动程序至少可以部分地自动配置自己。特别是，驱动程序初始化部分通常会包含端点自动配置逻辑，该逻辑扫描硬件端点列表以查找符合驱动程序需求的端点（依赖于这些约定），从而消除条件编译的一些最常见原因。
如同Linux-USB主机侧API一样，此API也暴露了USB消息的“块状”特性：I/O请求是以一个或多个“数据包”的形式进行的，且数据包边界对于驱动程序来说是可见的。与RS-232串行协议相比，USB更类似于HDLC等同步协议（每帧N字节，多点寻址，主机作为主站而设备作为从站）而非异步协议（如tty风格：每帧8个数据位，无奇偶校验，一个停止位）。因此，例如控制器驱动程序不会将两个单字节写入操作缓冲成一个双字节USB IN数据包，尽管当数据包边界（以及“短数据包”）不重要的情况下gadget驱动程序可能会这样做。
驱动程序生命周期
-----------------

gadget驱动程序向硬件发起端点I/O请求时不需要了解很多硬件细节，但驱动程序设置/配置代码需要处理一些差异。按照以下方式使用API：

1. 为特定的设备侧USB控制器硬件注册一个驱动程序，例如PCI上的net2280（USB 2.0）、sa11x0或pxa25x（常见于Linux PDA中）等。此时设备逻辑上处于USB第9章规定的初始状态（`已连接`），不消耗电力且不可用（因为它尚未支持枚举）。任何主机都不应该看到该设备，因为它尚未激活用于主机检测设备的数据线拉高电阻，即使VBUS电源可用。
2. 注册一个实现某种较高层级设备功能的gadget驱动程序。然后它将会绑定到一个:c:type:`usb_gadget`，在检测到VBUS后激活数据线拉高电阻。
3. 现在硬件驱动程序可以开始枚举。它处理的步骤包括接受USB `电源` 和 `设置地址` 请求。其他步骤由设备驱动程序处理。如果在主机开始枚举之前卸载了设备驱动程序模块，则会跳过第7步之前的步骤。
4. 设备驱动程序的 `setup()` 调用根据总线接口硬件提供的信息和所实现的功能返回USB描述符。这可能涉及交替设置或配置，除非硬件阻止此类操作。对于OTG设备，每个配置描述符都包含一个OTG描述符。
5. 设备驱动程序处理枚举的最后一部，即当USB主机发出 `设置配置` 调用时。它启用该配置中使用的所有端点，并将所有接口置于其默认设置中。这涉及到使用硬件端点列表，根据其描述符启用每个端点。还可能涉及使用 `usb_gadget_vbus_draw` 来允许从VBUS抽取更多电力，前提是该配置允许这样做。对于OTG设备，设置配置还可能涉及通过用户界面报告HNP能力。
6. 进行实际工作并执行数据传输，可能涉及接口设置的变化或切换到新的配置，直到设备从主机 `断开连接()`。向每个端点排队任意数量的传输请求。在被断开连接之前，它可能会暂停和恢复多次。断开连接后，驱动程序返回到步骤3（上面所述）。
7. 当卸载设备驱动程序模块时，会发出驱动程序的 `解绑()` 回调。这使得控制器驱动程序也可以被卸载。
驱动程序通常会被安排得这样：仅仅加载设备驱动程序模块（或者静态链接到Linux内核中）就可以让外围设备进行枚举，但是一些驱动程序会延迟枚举直到某个高级组件（如用户模式守护进程）启用它。请注意，在这个最低层，除了必须遵守USB规范外，没有关于如何实现ep0配置逻辑的策略。这些问题属于设备驱动程序的领域，包括了解某些USB控制器施加的实施限制，或者理解复合设备可能是通过集成可重用组件构建而成的。

请注意，上述生命周期对于OTG设备可能略有不同。除了在每个配置中提供额外的OTG描述符外，与HNP相关的差异对驱动代码来说特别明显。这些差异涉及在 `设置配置` 请求期间的报告要求，以及在某些挂起回调中触发HNP的选项。
另外，SRP稍微改变了 `usb_gadget_wakeup` 的语义。
USB 2.0 第9章 类型与常量
-----------------------------

Gadget驱动程序依赖于在`:ref:`linux/usb/ch9.h <usb_chapter9>`头文件中定义的通用USB结构和常量，该文件是Linux 2.6+内核的标准配置。这些类型和常量与主机端驱动程序（及usbcore）使用的相同。
核心对象和方法
----------------------

这些在`<linux/usb/gadget.h>`中声明，并由gadget驱动程序用于与USB外围控制器驱动程序交互。
.. kernel-doc:: include/linux/usb/gadget.h
   :internal:

可选工具
------------------

核心API足以编写一个USB Gadget驱动程序，但提供了一些可选工具来简化常见任务。这些工具包括端点自动配置。
.. kernel-doc:: drivers/usb/gadget/usbstring.c
   :export:

.. kernel-doc:: drivers/usb/gadget/config.c
   :export:

复合设备框架
--------------------------

核心API足以编写用于复合USB设备（在一个给定配置中有多个功能）以及多配置设备（同样具有多个功能，但不一定共享一个配置）的驱动程序。然而，有一个可选的框架可以更方便地重用和组合功能。
使用此框架的设备提供了一个struct usb_composite_driver，进而提供了一个或多个struct usb_configuration实例。每个这样的配置至少包含一个struct :c:type:`usb_function`，它封装了用户可见的角色，如“网络链接”或“大容量存储设备”。还可能存在管理功能，例如“设备固件升级”。
.. kernel-doc:: include/linux/usb/composite.h
   :internal:

.. kernel-doc:: drivers/usb/gadget/composite.c
   :export:

复合设备功能
--------------------------

目前，一些现有的gadget驱动程序已经被转换为此框架。近期计划包括将它们全部转换，除了`gadgetfs`之外。
外围控制器驱动程序
=============================

支持此API的第一个硬件是NetChip 2280控制器，它支持USB 2.0高速并基于PCI。这是`net2280`驱动模块。该驱动支持Linux内核版本2.4和2.6；有关开发板和产品信息，请联系NetChip Technologies。
在此框架下工作的其他硬件包括：Intel的PXA 25x和IXP42x系列处理器（`pxa2xx_udc`），Toshiba TC86c001 “Goku-S”（`goku_udc`），Renesas SH7705/7727（`sh_udc`），MediaQ 11xx（`mq11xx_udc`），Hynix HMS30C7202（`h7202_udc`），National 9303/4（`n9604_udc`），Texas Instruments OMAP（`omap_udc`），Sharp LH7A40x（`lh7a40x_udc`），以及其他更多。其中大多数是全速控制器。
目前，有人正在为此框架下的其他几个USB设备控制器开发驱动程序，并计划使其中许多广泛可用。
部分USB模拟器`dummy_hcd`驱动程序可用。它可以像net2280、pxa25x或sa11x0那样工作，在可用端点和设备速度方面；并且它模拟控制、批量以及某种程度上的中断传输。这使得您可以在普通PC上开发gadget驱动程序的部分内容，无需任何特殊硬件，并且可能借助于与User Mode Linux一起运行的GDB等工具的帮助。至少有一人表达了对此方法的兴趣，将其连接到微控制器模拟器上。此类模拟器可以帮助调试运行时硬件对软件开发不友好或尚未可用的子系统。
随着时间的推移，随着这个驱动程序框架的不断发展和完善，预计会开发并贡献对其他控制器的支持。
Gadget 驱动程序
===============

除了主要用于测试和与 USB 控制器硬件驱动程序进行开发的 *Gadget Zero* 之外，还存在其他的 gadget 驱动程序。例如有一个 `ethernet` gadget 驱动程序，它实现了最实用的 *通信设备类别*（CDC）模型之一。某些电缆调制解调器互操作性的标准甚至指定了使用这种以太网模型作为两种强制选项之一。使用该代码的 gadgets 对 USB 主机来说看起来就像一个以太网适配器。它为网络提供了一个环境，在这个环境中，gadget 的 CPU 是一个主机，它可以轻松地实现桥接、路由或防火墙功能以访问其他网络。由于某些硬件无法完全实现 CDC 以太网的要求，因此该驱动程序还实现了 CDC 以太网的一个“只包含好的部分”的子集。（该子集不会自我宣传为 CDC 以太网，以免造成问题。）

对微软的 `RNDIS` 协议的支持是由 Pengutronix 和 Auerswald GmbH 贡献的。这类似于 CDC 以太网，但它可以在稍微不同的 USB 硬件上运行（但比 CDC 子集少）。然而，它的主要特点是能够直接连接到最近版本的 Windows，使用微软捆绑和支持的驱动程序，这使得与 Windows 进行网络通信变得更加简单。

此外，也支持用户模式 gadget 驱动程序，通过使用 `gadgetfs` 实现。这提供了一个 *用户模式 API*，将每个端点呈现为单个文件描述符。I/O 操作通过正常的 `read()` 和 `write()` 调用完成。熟悉的工具如 GDB 和 pthreads 可用于开发和调试用户模式驱动程序，因此一旦有了稳健的控制器驱动程序，许多应用程序就不需要新的内核模式软件了。Linux 2.6 的 *异步 I/O (AIO)* 支持可用，这意味着用户模式软件可以以仅略高于内核驱动程序的开销来流式传输数据。

还有一个 USB 大容量存储类驱动程序，它为与 MS-Windows 和 MacOS 等系统实现互操作性提供了另一种解决方案。该 *大容量存储* 驱动程序使用文件或块设备作为磁盘的后端存储，类似于 `loop` 驱动程序。USB 主机使用 BBB、CB 或 CBI 版本的大容量存储类规范，使用透明的 SCSI 命令从后端存储中获取数据。

还有一个“串行线路”驱动程序，适用于通过 USB 进行 TTY 样式的操作。该驱动程序的最新版本支持类似 USB 调制解调器的 CDC ACM 操作方式，并且在大多数硬件上可以轻松与 MS-Windows 互操作。该驱动程序的一个有趣用途是在引导固件（如 BIOS）中，有时可以在没有真正串行线的小型系统上使用这种模型。
对于其他类型的设备的支持预计会随着时间的推移而发展和完善，随着这一驱动框架的演进，会有更多的贡献出现。

USB 即插即用 (OTG)
==================

在 Linux 2.6 中对 USB OTG 的支持最初是由德州仪器为 `OMAP <http://www.omap.com>`__ 16xx 和 17xx 系列处理器开发的。其他的 OTG 系统应该以类似的方式工作，但硬件层面的细节可能会大相径庭。
要实现 OTG 功能，系统需要专门的硬件支持，尤其是需要一个特殊的 *Mini-AB* 接口和相关的收发器来支持 *双角色* 操作：它们既可以作为主机使用标准的 Linux-USB 主机侧驱动栈，也可以作为外设使用这个“gadget”框架。为了做到这一点，系统软件依赖于这些编程接口的一些小改动，并且依赖一个新的内部组件（这里称为“OTG 控制器”），该组件决定了哪个驱动栈连接到 OTG 端口。在每种角色下，系统都可以复用现有的硬件中立驱动程序，这些驱动程序构建在控制器驱动接口之上（如 :c:type:`usb_bus` 或 :c:type:`usb_gadget`）。
这样的驱动程序最多只需要进行微小的修改，而且大多数新增的调用也能让非 OTG 产品受益。
-  Gadget 驱动程序会检测 “is_otg” 标志，并根据它来决定是否在每个配置中包含 OTG 描述符。
-  Gadget 驱动程序可能需要进行更改以支持两种新的 OTG 协议，这些协议通过新的 gadget 属性（例如 “b_hnp_enable” 标志）暴露出来。HNP 支持应通过用户界面报告（两个 LED 就足够了），并且在某些情况下当主机挂起外设时被触发。SRP 支持可以像远程唤醒一样由用户发起，可能通过按同一个按钮实现。
-  在主机一侧，USB 设备驱动程序需要学会在适当的时候触发 HNP，使用 `usb_suspend_device()`。这对非 OTG 配置也是有益的，因为它可以节省电池电量。
-  同样在主机一侧，一个驱动程序必须支持 OTG “目标外设列表”。这只是一个白名单，用于拒绝与特定 Linux OTG 主机不兼容的外设。*这个白名单是产品特有的；每个产品都必须修改* `otg_whitelist.h` *以符合其互操作性规范。*

对于非 OTG 的 Linux 主机（如个人电脑和工作站），通常有一些解决方案来添加驱动程序，这样未被识别的外设最终可以获得支持。但对于可能永远不会更新固件的消费类产品来说，这种方法是不合理的，在这种情况下，通常无法期望传统的 PC/工作站/服务器支持模式能奏效。例如，一旦产品分发出去后，往往很难改变设备的固件，因此如果在发货后发现了驱动程序的错误，通常无法修复。
除了那些硬件中立的 :c:type:`usb_bus` 和 :c:type:`usb_gadget` 驱动接口之外，还需要进行额外的改动；这里不会详细讨论这些改动。这些改动影响了每个 USB 主机或外设控制器的硬件特定代码，以及 HCD 如何初始化（因为 OTG 只能在单个端口上激活）。它们还涉及所谓的 *OTG 控制器驱动程序*，该驱动程序管理 OTG 收发器、OTG 状态机逻辑以及 OTG 端口的大部分根集线器行为。
OTG 控制器驱动程序需要根据相关设备的角色激活和停用 USB 控制器。为此，usbcore 内部也需要进行一些相关改动，以便它可以识别 OTG 能力的设备，并适当地响应 HNP 或 SRP 协议。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
