USB 热插拔
==========

对于像 USB（和 Cardbus PCI）这样的热插拔总线，最终用户会在系统通电的情况下将设备插入。在大多数情况下，用户希望这些设备能够立即变得可用。这意味着系统需要执行许多操作，包括：

    - 找到一个可以处理该设备的驱动程序。这可能涉及加载内核模块；较新的驱动程序可以使用模块初始化工具来向用户空间实用程序发布它们支持的设备（和类别）信息。
- 将一个驱动程序绑定到该设备上。总线框架通过调用设备驱动程序中的 `probe()` 函数来实现这一点。
- 告诉其他子系统配置新设备。打印队列可能需要被启用、网络需要被启动、磁盘分区需要被挂载等。在某些情况下，这些将是特定于驱动程序的操作。
这涉及内核态和用户态混合的操作。为了让设备立即可用，任何用户态的操作都不能等待管理员去执行：内核必须触发这些操作，无论是被动地（触发某个监控守护进程来调用辅助程序）还是主动地（直接调用用户态辅助程序）。
这些被触发的动作必须支持系统的管理策略；这里称这类程序为“策略代理”。通常它们涉及 shell 脚本，这些脚本会分发给更熟悉的管理工具来执行。
由于一些这些动作依赖于有关驱动程序的信息（元数据），而这些信息只有当驱动程序动态链接时才可用，因此当你配置一个高度模块化的系统时，你会获得最佳的热插拔性能。

内核热插拔助手 (`/sbin/hotplug`)
===================================

有一个内核参数：`/proc/sys/kernel/hotplug`，它通常包含路径名 `/sbin/hotplug`。这个参数指定了一个程序，内核可以在不同时间点调用它。
/sbin/hotplug 程序可以从任何子系统作为其对配置更改的响应中由该子系统中的线程调用。
只需要一个参数：通知某内核事件的子系统的名称。该名称被用作进一步事件分发的第一个键；任何其他的参数和环境参数都由发出调用的子系统指定。
热插拔软件和其他资源可在以下位置找到：

	http://linux-hotplug.sourceforge.net

邮件列表信息也在该网站上提供。
USB 策略代理
================

当前 USB 子系统在添加或移除 USB 设备时会调用 `/sbin/hotplug`。此调用由内核的集线器工作队列 [hub_wq] 执行，或者作为根集线器初始化的一部分（由 init、modprobe、kapmd 等完成）。其唯一的命令行参数是字符串 "usb"，并且它传递以下环境变量：

========== ============================================
ACTION     `add`、`remove`
PRODUCT    USB 厂商、产品和版本码（十六进制）
TYPE       设备类别码（十进制）
INTERFACE  接口 0 类别码（十进制）
========== ============================================

如果配置了 "usbdevfs"，则还会传递 DEVICE 和 DEVFS。DEVICE 是设备的路径名，并且对于具有多个和/或可选接口的设备来说很有用，这些设备会使得驱动程序的选择变得复杂。USB 热插拔的设计独立于 `usbdevfs`：你可以在不使用该文件系统的情况下完成大多数基本的 USB 设备设置，并且无需运行用户模式守护进程来检测系统配置的变化。

目前可用的策略代理实现可以加载模块的驱动程序，并且可以调用特定于驱动程序的设置脚本。最新的代理利用了 USB 模块初始化工具的支持。未来的代理可能支持卸载驱动程序。

USB Modutils 支持
====================

当前版本的模块初始化工具将创建一个 `modules.usbmap` 文件，其中包含每个驱动程序的 `MODULE_DEVICE_TABLE` 中的条目。这样的文件可以被各种用户模式策略代理使用，以确保所有正确的驱动程序模块都在启动时或之后被加载。

参见 `linux/usb.h` 获取有关此类表条目的完整信息；或者查看现有的驱动程序。每个表条目描述了一个或多个用于匹配驱动程序与设备或一类设备的标准。具体的标准通过 "match_flags" 中设置的位与字段值配对标识。你可以直接构建这些标准，或者使用以下宏，并使用 driver_info 来存储更多信息：

    USB_DEVICE (vendorId, productId)
        ... 匹配具有指定厂商 ID 和产品 ID 的设备
    USB_DEVICE_VER (vendorId, productId, lo, hi)
        ... 类似于 USB_DEVICE，但要求 lo <= 产品版本号 <= hi
    USB_INTERFACE_INFO (class, subclass, protocol)
        ... 匹配指定的接口类信息
    USB_DEVICE_INFO (class, subclass, protocol)
        ... 匹配指定的设备类信息

下面是一个简短的例子，对于一个支持几个具体的 USB 设备及其特性的驱动程序，它的 `MODULE_DEVICE_TABLE` 可能如下所示：

    static const struct usb_device_id mydriver_id_table[] = {
        { USB_DEVICE (0x9999, 0xaaaa), .driver_info = QUIRK_X },
        { USB_DEVICE (0xbbbb, 0x8888), .driver_info = QUIRK_Y | QUIRK_Z },
        ..
        { } /* 以全零条目结束 */
    };
    MODULE_DEVICE_TABLE(usb, mydriver_id_table);

大多数 USB 设备驱动程序都应该将这些表同时传递给 USB 子系统以及模块管理子系统。不过并非所有的都需要这样做：一些驱动程序框架使用构建在 USB 上的接口进行连接，因此它们不需要 `struct usb_driver`。

直接连接到 USB 子系统的驱动程序应该声明如下：

    static struct usb_driver mydriver = {
        .name         = "mydriver",
        .id_table     = mydriver_id_table,
        .probe        = my_probe,
        .disconnect   = my_disconnect,

        /*
         * 如果使用 usb 字符设备框架：
         *     .minor      = MY_USB_MINOR_START,
         *     .fops       = my_file_ops,
         * 如果通过 usbdevfs 暴露任何操作：
         *     .ioctl      = my_ioctl,
         */
    };

当 USB 子系统了解驱动程序的设备 ID 表时，它会在选择要探测的驱动程序时使用该表。处理新设备的线程会检查驱动程序的设备 ID 条目（来自 `MODULE_DEVICE_TABLE`）与设备的接口和设备描述符。只有在找到匹配项时才会调用 `probe()`，并且 `probe()` 的第三个参数将是匹配的条目。

如果你没有为你的驱动程序提供 `id_table`，那么你的驱动程序可能会针对每个新设备进行探测；`probe()` 的第三个参数将是 `NULL`。
