USB核心回调
~~~~~~~~~~~~~

USBcore会执行哪些回调？
========================

USBcore将通过驱动程序结构中定义的回调以及驱动程序提交的URB（Urban Removal Box，此处应为USB Request Block，USB请求块）的完成处理器来调用驱动程序。本文档仅涵盖前者。这两种类型的回调是完全独立的。有关完成回调的信息，请参阅 :ref:`usb-urb`。
在驱动程序结构中定义的回调包括：

1. 热插拔回调：

   - `@probe`：
     被调用来查看驱动程序是否愿意管理设备上的特定接口
   - `@disconnect`：
     当接口不再可访问时被调用，通常是因为其设备已被（或正在被）断开连接，或者驱动程序模块正在卸载

2. 通过usbfs的特殊后门：

   - `@ioctl`：
     用于那些希望与用户空间通过“usbfs”文件系统通信的驱动程序。这允许设备提供向用户空间暴露信息的方式，无论它们在文件系统的其他地方出现与否

3. 电源管理（PM）回调：

   - `@suspend`：
     当设备即将被挂起时被调用
   - `@resume`：
     当设备正在恢复时被调用
   - `@reset_resume`：
     当已挂起的设备被重置而不是恢复时被调用

4. 设备级别的操作：

   - `@pre_reset`：
     当设备即将被重置时被调用
   - `@post_reset`：
     在设备已经被重置之后被调用

ioctl接口（2）只应在有充分理由的情况下使用。现在更倾向于使用sysfs。电源管理回调在 :ref:`usb-power-management` 中单独覆盖。
### 调用约定

所有回调函数都是互斥的。无需对其他USB回调进行锁定。所有回调函数都在任务上下文中被调用。您可以休眠，但是重要的是所有的休眠时间必须有一个较小的固定上限。特别地，您不得调用用户空间并等待结果。

### 热插拔回调

这些回调函数旨在将驱动程序与接口关联和解除关联。一个驱动程序与接口之间的绑定是排他的。

#### `probe()` 回调

```c
int (*probe) (struct usb_interface *intf,
             const struct usb_device_id *id);
```

接受或拒绝一个接口。如果您接受该设备，请返回0；否则返回 `-ENODEV` 或 `-ENXIO`。只有在初始化过程中发生真正错误，导致驱动无法接受本应可以接受的设备时，才应当使用其他错误代码。
强烈建议您利用usbcore提供的功能 `usb_set_intfdata()`，将数据结构与接口相关联，以便知道特定接口与内部状态及标识之间的关联。在此阶段，设备不会被挂起，并且您可以对该接口以及设备的端点0进行输入/输出操作。快速完成设备初始化是一个好主意。

#### `disconnect()` 回调

```c
void (*disconnect) (struct usb_interface *intf);
```

此回调函数是一个信号，用于中断与接口的任何连接。
从这个回调返回后，您不允许对设备执行任何输入/输出操作。您也不得执行可能干扰另一个绑定到该接口的驱动程序的操作（例如电源管理操作）。在返回此回调之前，必须完成或中止设备上所有未完成的操作。
如果由于物理断开连接而被调用，您的所有URB都将由usbcore杀死。请注意，在这种情况下，`disconnect` 将在物理断开连接一段时间后被调用。因此，您的驱动程序必须准备好处理在回调前的失败输入/输出操作。

### 设备级别的回调

#### `pre_reset`

```c
int (*pre_reset)(struct usb_interface *intf);
```

驱动程序或用户空间正在触发对包含作为参数传递的接口的设备进行重置。停止输入/输出操作，等待所有未完成的URB完成，并保存需要恢复的任何设备状态。直到调用 `post_reset` 方法之前，不能再提交新的URB。
如果您需要在这里分配内存，请使用 `GFP_NOIO` 或 `GFP_ATOMIC`（如果您处于原子上下文）。

#### `post_reset`

```c
int (*post_reset)(struct usb_interface *intf);
```

重置已完成。恢复任何保存的设备状态，并开始再次使用该设备。
如果你需要在这里分配内存，请使用GFP_NOIO或GFP_ATOMIC，如果你处于原子上下文中的话。

调用序列
==============

对于未绑定到你的驱动程序的接口，除了probe之外不会调用其他任何回调函数。
对于已绑定到驱动程序的接口，永远不会调用probe。
因此，在成功执行probe之后，会在对同一接口进行下一次probe之前调用disconnect。
一旦你的驱动程序绑定到一个接口，可以在任何时候调用disconnect，除非在pre_reset和post_reset之间。
pre_reset总是会被post_reset跟随，即使重置失败或设备已被拔出。
suspend总是被以下之一跟随：resume、reset_resume 或 disconnect。
