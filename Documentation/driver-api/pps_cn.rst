... SPDX 许可证标识符: GPL-2.0

======================
PPS - 每秒脉冲数
======================

版权所有 (C) 2007 罗多尔福·乔梅蒂 <giometti@enneenne.com>

本程序是自由软件；您可以根据自由软件基金会发布的 GNU 通用公共许可证的条款重新分发它和/或修改它；无论是许可证的第2版，还是（由您选择）任何以后的版本。
本程序以期望它会是有用的而发布，
但是没有任何保证；甚至没有对适销性或适合某一特定目的的默示保证。详情请参阅 GNU 通用公共许可证。
概述
--------

LinuxPPS 提供了一个编程接口（API），用于在系统中定义多个 PPS 源。
PPS 的意思是“每秒脉冲数”，一个 PPS 源就是一个设备，它可以提供每秒钟一次的高精度信号，以便应用程序可以使用它来调整系统时钟时间。
一个 PPS 源可以连接到串行端口（通常连接到数据载波检测针脚）或并行端口（ACK 针脚）或特殊 CPU 的 GPIO（这是嵌入式系统中的常见情况）。但在每种情况下，当一个新的脉冲到达时，系统必须对其应用时间戳，并为用户空间记录下来。
常见的用途是将用户空间程序 NTPD 与作为 PPS 源的 GPS 接收器结合使用，以获得与 UTC 同步的毫秒级精度的实时时间。
RFC 考虑
------------------

在实现 RFC 2783 定义的 PPS API 并使用嵌入式 CPU 的 GPIO 引脚作为物理信号链接的过程中，我遇到了一个更深层次的问题：

   在启动时，需要将文件描述符作为 `time_pps_create()` 函数的参数。
这意味着源必须有一个 `/dev/...` 入口。对于串行和并行端口来说，这个假设是可以接受的，因为除了收集时间戳（这是 PPS API 的核心任务）之外，你还可以做一些有用的事情。但对于单一用途的 GPIO 线路来说，这个假设并不适用。在这种情况下，即使是基本的文件相关功能（如读取和写入）都没有意义，也不应该成为使用 PPS API 的先决条件。
这个问题可以通过考虑 PPS 源不一定总是与 GPS 数据源相连来简单解决。
因此，您的程序应该检查 GPS 数据源（例如，串行端口）是否也是一个 PPS 源，如果不是，则应提供打开另一个设备作为 PPS 源的可能性。
在 LinuxPPS 中，PPS 源通常只是字符设备，并映射到诸如 `/dev/pps0`、`/dev/pps1` 等文件中。

通过 USB 到串行设备获取 PPS

可以通过 USB 到串行设备来捕获 PPS。然而，你应该考虑到 USB 栈引入的延迟和抖动。用户报告说，当通过 USB 同步 PPS 时，时钟不稳定可能在 ±1ms 左右。使用 USB 2.0，抖动可能会降低到大约 125 微秒的级别。
这可能适用于与 NTP 进行的时间服务器同步，因为 NTP 的欠采样和算法可以处理这种级别的抖动。
如果你的设备不报告 PPS，你可以检查驱动程序是否支持该功能。大多数情况下，你只需在检查 DCD 状态后添加一个调用 `usb_serial_handle_dcd_change`（参见 ch341 和 pl2303 示例）。

编码示例

要将 PPS 源注册到内核中，你需要定义一个 `struct pps_source_info` 结构体，如下所示：

    static struct pps_source_info pps_ktimer_info = {
	    .name         = "ktimer",
	    .path         = "",
	    .mode         = PPS_CAPTUREASSERT | PPS_OFFSETASSERT |
			    PPS_ECHOASSERT |
			    PPS_CANWAIT | PPS_TSFMT_TSPEC,
	    .echo         = pps_ktimer_echo,
	    .owner        = THIS_MODULE,
    };

然后，在你的初始化例程中调用函数 `pps_register_source()` 如下：

    source = pps_register_source(&pps_ktimer_info,
			PPS_CAPTUREASSERT | PPS_OFFSETASSERT);

`pps_register_source()` 函数原型如下：

  int pps_register_source(struct pps_source_info *info, int default_params)

其中 "info" 是指向描述特定 PPS 源结构的指针，“default_params” 告诉系统设备的初始默认参数应该是什么（显然这些参数必须是结构 `pps_source_info` 中定义的能力的一个子集）
一旦你向系统注册了一个新的 PPS 源，你就可以在中断处理程序例程中使用以下代码来发出一个事件：

    pps_event(source, &ts, PPS_CAPTUREASSERT, ptr)

其中 "ts" 是事件的时间戳
如果用户要求的话，相同的函数也可以运行定义好的回显函数（如 `pps_ktimer_echo()`，传递 "ptr" 指针给它）等。
请参阅文件 `drivers/pps/clients/pps-ktimer.c` 获取示例代码。

SYSFS 支持

如果内核启用了 SYSFS 文件系统，则会提供一个新的类：

   $ ls /sys/class/pps/
   pps0/  pps1/  pps2/

每个目录都是系统中定义的 PPS 源的 ID，内部包含多个文件：

   $ ls -F /sys/class/pps/pps0/
   assert     dev        mode       path       subsystem@
   clear      echo       name       power/     uevent

在每个 "assert" 和 "clear" 文件内部，你可以找到时间戳和序列号：

   $ cat /sys/class/pps/pps0/assert
   1170026870.983207967#8

其中 "#" 之前的是以秒为单位的时间戳；之后的是序列号。其他文件包括：

 * echo：报告 PPS 源是否有回显功能；
 
 * mode：报告可用的 PPS 功能模式；
 
 * name：报告 PPS 源的名字；
 
 * path：报告 PPS 源的设备路径，即 PPS 源连接的设备（如果存在）。

测试 PPS 支持

即使没有专用硬件，你也可以使用 pps-ktimer 驱动（参见 PPS 配置菜单中的客户端子部分）以及发行版中的 pps-tools 包、http://linuxpps.org 或 https://github.com/redlab-i/pps-tools 中的用户空间工具来测试 PPS 支持。
一旦你启用了 pps-ktimer 的编译，只需加载该模块（如果不是静态编译的话）：

   # modprobe pps-ktimer

然后运行 ppstest，如下所示：

   $ ./ppstest /dev/pps1
   尝试 PPS 源 "/dev/pps1"
   找到 PPS 源 "/dev/pps1"
   好的，找到 1 个源，现在开始获取数据...
源 0 - 断言 1186592699.388832443, 序列: 364 - 清除  0.000000000, 序列: 0
   源 0 - 断言 1186592700.388931295, 序列: 365 - 清除  0.000000000, 序列: 0
   源 0 - 断言 1186592701.389032765, 序列: 366 - 清除  0.000000000, 序列: 0

请注意，要编译用户空间程序，你需要文件 timepps.h。
这个文件可以在上面提到的 pps-tools 存储库中找到。
生成器
------

有时候，我们不仅需要捕捉 PPS 信号，还需要产生这些信号。例如，在进行分布式模拟时，可能需要计算机的时钟非常精确地同步。
并行端口生成器
------------------

一种方法是设计一些复杂的硬件解决方案，但这既不必要也不经济实惠。更简单的方法是在其中一台计算机（主控机）上加载一个 PPS 生成器，并在其他计算机（从属机）上加载 PPS 客户端，使用简单的电缆通过并行端口传输信号。例如：
并行端口电缆的引脚定义如下：

| 引脚 | 名称 | 主控机 | 从属机 |
| ---- | ---- | ------ | ------ |
| 1    | STROBE | *------ | *      |
| 2    | D0 | *     | *     |
| 3    | D1 | *     | *     |
| 4    | D2 | *     | *     |
| 5    | D3 | *     | *     |
| 6    | D4 | *     | *     |
| 7    | D5 | *     | *     |
| 8    | D6 | *     | *     |
| 9    | D7 | *     | *     |
| 10   | ACK | *     | ------* |
| 11   | BUSY | *     |        |
| 12   | PE | *     |        |
| 13   | SEL | *     |        |
| 14   | AUTOFD | *     |        |
| 15   | ERROR | *     |        |
| 16   | INIT | *     |        |
| 17   | SELIN | *     |        |
| 18-25 | GND | *-----------* |

请注意，只有当高电平变为低电平时才会触发并行端口中断，因此它被用于 PPS 断言边沿。PPS 清除边沿只能通过中断处理程序中的轮询来确定，这实际上可以做得更精确，因为中断处理延迟可能会相当大且随机。因此，当前的并行端口 PPS 生成器实现（pps_gen_parport 模块）主要利用清除边沿来进行时间同步。
清除边沿的轮询是在禁用中断的情况下进行的，因此最好尽可能减小断言和清除边沿之间的延迟，以减少系统延迟。但如果这个延迟太短，则从属机将无法捕获清除边沿的变化。默认的 30 微秒在大多数情况下应该是足够的。
可以通过 'delay' pps_gen_parport 模块参数来选择这个延迟。
