基于 ioctl 的接口
======================

ioctl() 是应用程序与设备驱动程序交互最常用的方式。它具有灵活性并且通过添加新命令很容易扩展，可以通过字符设备、块设备以及套接字和其他特殊文件描述符传递。
然而，也很容易错误地定义 ioctl 命令，并且在不破坏现有应用程序的情况下很难修复这些错误，因此本文档试图帮助开发人员正确地处理这些问题。

命令编号定义
==========================

命令编号或请求编号是传递给 ioctl 系统调用的第二个参数。虽然这可以是任何唯一标识特定驱动程序操作的32位数字，但在定义它们时存在一些约定。
`include/uapi/asm-generic/ioctl.h` 提供了四个遵循现代约定用于定义 ioctl 命令的宏：`_IO`、`_IOR`、`_IOW` 和 `_IOWR`。这些宏应当用于所有新的命令，使用正确的参数：

_IO/_IOR/_IOW/_IOWR
   宏名指定了参数将如何使用。它可以是一个指向要传递给内核的数据（_IOW）、从内核传出的数据（_IOR），或者两者皆有（_IOWR）的指针。_IO 可以表示没有参数的命令或传递整数值而不是指针的命令。
建议仅使用 _IO 来表示没有参数的命令，并使用指针来传递数据。
类型
   一个8位数字，通常是特定于子系统或驱动程序的字符常量，在Documentation/userspace-api/ioctl/ioctl-number.rst中列出。

nr
  一个8位数字，为给定的 '类型' 值标识具体的命令。

数据类型
  参数所指向的数据类型的名称，命令编号在13位或14位整数中编码 `sizeof(data_type)` 的值，导致参数最大大小限制为8191字节。
注意：不要将 `sizeof(data_type)` 类型传入 _IOR/_IOW/_IOWR 中，因为这会导致编码 `sizeof(sizeof(data_type))`，即 `sizeof(size_t)`。
_IO 不包含数据类型参数。

接口版本
==================

某些子系统在数据结构中使用版本号来对命令参数的不同解释进行重载。
这通常不是一个好主意，因为对现有命令的更改往往会破坏现有的应用程序。
一种更好的方法是添加一个带有新编号的新 ioctl 命令。为了保持兼容性，旧命令仍然需要在内核中实现，但这可以是一个围绕新实现的包装器。
返回码
======

ioctl 命令可以返回如 errno(3) 文档中所述的负错误码；这些错误码在用户空间中会转换为 errno 值。成功时，返回码应为零。也可以返回正的 'long' 值，但不推荐这样做。
当 ioctl 回调函数被调用时使用未知命令号，处理程序应返回 -ENOTTY 或 -ENOIOCTLCMD，这也导致系统调用返回 -ENOTTY。出于历史原因，一些子系统在这里返回 -ENOSYS 或 -EINVAL，但这是错误的。
在 Linux 5.5 之前，兼容 ioctl 处理程序必须返回 -ENOIOCTLCMD 才能使用回退转换为原生命令。由于现在所有子系统都负责自己处理兼容模式，这已不再需要，但在将 bug 修复移植到较旧内核版本时可能需要考虑这一点。
时间戳
======

传统上，时间戳和超时值通过 `struct timespec` 或 `struct timeval` 传递，但由于这些结构在用户空间中向 64 位 time_t 迁移后定义不一致，因此存在问题。
可以使用 `struct __kernel_timespec` 类型嵌入到其他数据结构中（当需要单独的秒/纳秒值时），或者直接传递给用户空间。然而，这仍然不是理想的解决方案，因为该结构既不符合内核的 timespec64，也不符合用户空间的 timespec。可以使用 get_timespec64() 和 put_timespec64() 辅助函数来确保布局与用户空间保持兼容，并正确处理填充。
由于从秒转换为纳秒较为简单，而反向转换则需要昂贵的 64 位除法，因此简单的 __u64 纳秒值可能更简单、更高效。
理想情况下，超时值和时间戳应该使用 ktime_get_ns() 或 ktime_get_ts64() 返回的 CLOCK_MONOTONIC 时间。这使得时间戳不受闰秒调整和 clock_settime() 调用导致的时间跳跃影响，与 CLOCK_REALTIME 不同。
对于需要跨重启或在多台机器间持久化的 CLOCK_REALTIME 时间戳，可以使用 ktime_get_real_ns()。
32 位兼容模式
==============

为了支持 32 位用户空间在 64 位机器上运行，每个实现 ioctl 回调处理程序的子系统或驱动程序也必须实现对应的 compat_ioctl 处理程序。
只要遵循所有数据结构的规则，这就像将 `.compat_ioctl` 指针设置为辅助函数一样简单，例如 `compat_ptr_ioctl()` 或 `blkdev_compat_ptr_ioctl()`。

### compat_ptr()
--------------

在 s390 架构上，31 位用户空间对数据指针有模糊的表现形式，其中高位被忽略。当以兼容模式运行此类进程时，必须使用 `compat_ptr()` 辅助函数来清除 `compat_uptr_t` 的高位，并将其转换为有效的 64 位指针。在其他架构上，此宏仅执行转换为 `void __user *` 指针的操作。
在 `compat_ioctl()` 回调中，最后一个参数是 `unsigned long` 类型，它可以被解释为指针或标量，具体取决于命令。如果它是标量，则不应使用 `compat_ptr()`，以确保对于设置了高位的参数，64 位内核的行为与 32 位内核相同。
`compat_ptr_ioctl()` 辅助函数可以用于替代自定义的 `compat_ioctl` 文件操作，对于那些只接受指向兼容数据结构的指针作为参数的驱动程序来说尤其如此。

### 结构布局
------------------

兼容的数据结构在所有架构上具有相同的布局，避免了所有有问题的成员：

* `long` 和 `unsigned long` 的大小等于寄存器的大小，因此它们可能是 32 位或 64 位宽，不能用于可移植的数据结构。固定的长度替代方案是 `__s32`、`__u32`、`__s64` 和 `__u64`。
* 指针存在同样的问题，此外还需要使用 `compat_ptr()`。最好的解决办法是用 `__u64` 替换指针，这需要在用户空间进行转换为 `uintptr_t` 的类型转换，在内核中使用 `u64_to_user_ptr()` 将其转换回用户指针。
* 在 x86-32（i386）架构上，64 位变量的对齐方式仅为 32 位，但在包括 x86-64 在内的大多数其他架构上，它们是自然对齐的。这意味着如下所示的结构： 

```c
struct foo {
    __u32 a;
    __u64 b;
    __u32 c;
};
```

在 x86-64 上，`a` 和 `b` 之间有四个字节的填充，末尾还有四个字节的填充，但在 i386 上没有填充，它需要一个 `compat_ioctl` 转换处理程序来在两种格式之间进行转换。
为了避免这个问题，所有结构都应该使其成员自然对齐，或者明确添加保留字段来代替隐式填充。`pahole` 工具可用于检查对齐情况。
* 在 ARM OABI 用户空间中，结构体按 32 位的倍数进行填充，使得一些结构体如果不以 32 位结束，则与现代 EABI 内核不兼容。
* 在 m68k 架构上，结构成员不一定具有大于 16 位的对齐方式，当依赖于隐式填充时，这会成为一个问题。
* 位字段和枚举类型通常按预期工作，但它们的一些特性依赖于具体实现，因此最好完全避免在 ioctl 接口中使用它们。
* `char` 类型成员可能是有符号的也可能是无符号的，这取决于架构，因此对于 8 位整数值应使用 __u8 和 __s8 类型，尽管对于固定长度字符串，字符数组更清晰易懂。

信息泄露
========

未初始化的数据不得复制到用户空间，因为这可能会导致信息泄露，进而可能被用于攻击内核地址空间布局随机化 (KASLR)，从而协助进行攻击。
为此（以及为了兼容性支持），最好避免在数据结构中使用任何隐式填充。如果现有结构中有隐式填充，内核驱动程序必须小心地在将结构实例复制到用户空间之前将其完全初始化。这通常通过在给各个成员赋值前调用 memset() 来完成。

子系统抽象
==========

虽然有些设备驱动程序实现了自己的 ioctl 函数，但大多数子系统为多个驱动程序实现了相同的命令。理想情况下，子系统有一个 .ioctl() 处理器，它从用户空间复制参数，并通过常规内核指针传递给特定于子系统的回调函数。
这样做有助于：

* 对于同一子系统中的不同驱动程序，如果用户空间 ABI 没有细微差异，应用程序更有可能对其他驱动程序也有效。
* 用户空间访问和数据结构布局的复杂性在一个地方完成，减少了潜在的实现错误。
* 当 ioctl 在多个驱动程序间共享时，比仅在一个驱动程序中使用时更有可能被经验丰富的开发者审查，从而发现接口问题。

ioctl 的替代方案
==============

有许多情况下 ioctl 并不是解决问题的最佳选择。替代方案包括：

* 系统调用更适合那些不与物理设备绑定或不受字符设备节点文件系统权限约束的系统级功能。
* netlink 是通过套接字配置任何网络相关对象的首选方式。
* debugfs 用于调试功能的即兴接口，这些功能不需要作为稳定接口暴露给应用程序。
* `sysfs` 是一种很好的方式来暴露内核对象的状态，这种对象并不与文件描述符绑定。
* `configfs` 可以用于比 `sysfs` 更复杂的配置。
* 自定义文件系统可以通过简单的用户界面提供额外的灵活性，但会给实现增加很多复杂性。
