=================
固件缓存
=================

当 Linux 从挂起状态恢复时，某些设备驱动程序需要进行固件查找以重新初始化设备。在恢复过程中可能存在一个时间段，在此期间无法执行固件查找，导致这段时间内的固件请求失败。然而，时间至关重要，延迟驱动程序等待根文件系统中的固件会延迟用户对设备功能的体验。为了支持这些需求，固件基础设施为大多数 API 调用实现了针对设备驱动程序的固件缓存，自动地在后台完成。
固件缓存使得在设备驱动程序的挂起和恢复回调中使用某些固件 API 调用变得安全。使用这些 API 调用的用户无需自己缓存固件来处理系统恢复期间可能出现的固件丢失问题。
固件缓存通过在挂起之前请求固件并在内存中缓存它来工作。恢复后，使用固件 API 的设备驱动程序可以立即访问固件，无需等待根文件系统的挂载或处理挂载过程中可能存在的查找竞争问题。
关于固件缓存设置的一些实现细节：

* 固件缓存是通过为每个使用所有同步调用（除了 `request_firmware_into_buf` 函数）的设备添加一个 devres 条目来设置的。
* 如果使用异步调用，则只有当 `request_firmware_nowait()` 的第二个参数（uevent）为真时，固件缓存才会为该设备设置。当 uevent 为真时，表示请求通过 sysfs 备用机制向用户空间发送一个 kobject uevent，如果未找到固件文件的话。
* 如果根据上述两个标准确定需要固件缓存，则通过为请求固件的设备添加一个 devres 条目来设置固件缓存。
* 固件 devres 条目在整个设备生命周期中都保持有效。这意味着即使你调用 `release_firmware()`，从挂起恢复时仍会使用固件缓存。
* 在设置固件缓存期间，备用机制的超时时间暂时减少到 10 秒，配置完成后会恢复到原来设定的时间值。
* 挂起时，任何待处理的非 uevent 固件请求将被终止以避免内核阻塞，这通过 `kill_requests_without_uevent()` 完成。因此，需要非 uevent 的内核调用必须实现自己的固件缓存机制，并且在挂起时不得使用固件 API。
