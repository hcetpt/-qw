### SPDX 许可证标识符：GPL-2.0

============================
PCI 对等DMA支持
============================

PCI 总线对于在总线上的两个设备之间进行DMA传输有着相当不错的支持。这种类型的交易从现在起被称为对等（或P2P）。然而，有一些问题使得以完全安全的方式执行P2P交易变得棘手。其中最大的问题是PCI并不强制要求在不同的层次域之间转发交易，在PCIe中，每个根端口定义了一个独立的层次域。更糟糕的是，没有简单的方法来确定给定的根复合体是否支持这一点（参见PCIe r4.0, sec 1.3.1）。因此，截至本文档撰写时，内核仅支持在同一PCI桥之后的所有参与节点间执行P2P，因为这些设备都在同一个PCI层次域内，规范保证了层次内的所有交易都是可路由的，但并没有要求跨层次的路由。

第二个问题是，为了利用Linux现有的接口，用于P2P交易的内存需要由`struct page`结构支持。然而，PCI BAR通常不是缓存一致的，因此在使用这些页面时存在一些特殊情况需要注意，开发者需要小心处理它们。

### 驱动编写指南
=====================

在一个特定的P2P实现中，可能存在三种或更多不同类型的内核驱动程序：

* 提供者 - 提供或发布P2P资源（如内存或门铃寄存器）给其他驱动程序的驱动。
* 客户端 - 通过设置到或从资源的DMA交易来利用资源的驱动。
* 协调者 - 协调客户端和提供者之间的数据流的驱动。

在很多情况下，这三类之间可能存在重叠（例如，一个驱动可能同时作为提供者和客户端）。

例如，在NVMe目标复制卸载实现中：

* NVMe PCI驱动既是客户端、提供者也是协调者，因为它将任何CMB（控制器内存缓冲区）暴露为P2P内存资源（提供者），它接受P2P内存页作为请求中的缓冲区直接使用（客户端），并且还可以利用CMB作为提交队列条目（协调者）。
* RDMA驱动在这种安排中是客户端，以便RNIC可以直接DMA到由NVMe设备暴露的内存。
* NVMe Target 驱动（nvmet）可以协调来自 RNIC 的数据到点对点内存（CMB），然后再传输到 NVMe 设备（反之亦然）。
这目前是内核支持的唯一配置，但可以想象对这种配置进行细微调整以实现相同的功能。例如，如果特定的 RNIC 添加了一个带有一些内存支持的基址寄存器（BAR），其驱动程序可以添加作为点对点提供者的支持，这样 NVMe Target 就可以在所使用的 NVMe 卡不支持 CMB 的情况下使用 RNIC 的内存。

提供者驱动程序
---------------

提供者只需通过调用 `pci_p2pdma_add_resource()` 函数注册一个基址寄存器（或基址寄存器的一部分）作为点对点 DMA 资源即可。这将为所有指定的内存注册结构化页面。之后，它可以可选地通过调用 `pci_p2pmem_publish()` 函数将其所有资源发布为点对点内存。这允许任何编排驱动程序找到并使用这些内存。当以这种方式标记时，该资源必须是常规内存且无副作用。目前这还比较基础，所有的资源通常都会是点对点内存。未来的工作可能会扩展这一点，包括其他类型的资源，如门铃。

客户端驱动程序
--------------

客户端驱动程序只需像往常一样使用 `dma_map_sg()` 和 `dma_unmap_sg()` 映射 API 函数，实现会自动为点对点兼容的内存做正确的事情。

编排驱动程序
--------------

编排驱动程序首先需要做的任务是编制一份参与给定交易的所有客户端设备的列表。例如，NVMe Target 驱动创建了一个包含命名空间块设备和使用的 RNIC 的列表。如果编排器可以访问特定的点对点提供者来使用它，可以使用 `pci_p2pdma_distance()` 函数检查兼容性；否则，它可能使用 `pci_p2pmem_find()` 函数找到与所有客户端兼容的内存提供者。如果有多个提供者被支持，会选择离所有客户端最近的一个。如果有多个提供者距离相等，则返回的选择将是随机的（不是任意选择而是真正随机）。此函数返回用于提供者的 PCI 设备，并持有引用，因此在不再需要时应通过 pci_dev_put() 返回。
选定提供者后，编排器可以使用 `pci_alloc_p2pmem()` 和 `pci_free_p2pmem()` 从提供者分配点对点内存。`pci_p2pmem_alloc_sgl()` 和 `pci_p2pmem_free_sgl()` 是用于分配带有点对点内存的散聚列表的便捷函数。
结构 Page 警告
-------------------

驱动程序编写者在将这些特殊的 `struct page` 传递给未为此做好准备的代码时应非常小心。目前，内核接口没有进行任何检查以确保这一点。这显然排除了将这些页面传递给用户空间的情况。
P2P 内存在技术上也是 I/O 内存，但不应有任何副作用。因此，读写顺序并不重要，也就没有必要使用 ioreadX()、iowriteX() 等函数。
P2P DMA 支持库
=======================

.. kernel-doc:: drivers/pci/p2pdma.c
   :export: 
（注：最后一段中的 ".. kernel-doc::" 和 ":export:" 是 Sphinx 文档生成器中的指令，并非需要翻译的内容。）
