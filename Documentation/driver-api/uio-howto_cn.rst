用户空间 I/O 使用教程
=======================

:作者: Hans-Jürgen Koch Linux 开发者，Linutronix
:日期:   2006-12-11

关于本文档
====================

翻译
------------

如果您知道任何对本文档的翻译版本，或者您有兴趣进行翻译，请给我发送邮件 hjk@hansjkoch.de
前言
-------

对于许多类型的设备来说，创建一个 Linux 内核驱动程序有些过度设计。实际上所需要的只是一种处理中断和提供对设备内存空间访问的方法。控制设备的逻辑不一定必须在内核中，因为设备并不需要利用内核提供的其他任何资源。工业 I/O 卡就是这种类型的常见设备之一。
为了解决这种情况，设计了用户空间 I/O 系统（UIO）。对于典型的工业 I/O 卡而言，只需要一个非常小的内核模块。驱动程序的主要部分将在用户空间运行。这简化了开发并降低了内核模块中出现严重错误的风险。
请注意，UIO 并不是一个通用的驱动接口。那些已经被其他内核子系统（如网络、串行或 USB）很好地处理的设备并不是 UIO 驱动程序的候选对象。最适合使用 UIO 驱动程序的硬件应该满足以下所有条件：

-  设备具有可映射的内存。通过写入该内存可以完全控制设备。
-  设备通常会产生中断。
-  设备不适合归类于标准内核子系统之一。
致谢
---------------

我要感谢 Linutronix 的 Thomas Gleixner 和 Benedikt Spranger，他们不仅编写了大部分 UIO 代码，而且还提供了各种背景信息，极大地帮助我编写这个教程。
反馈
--------

如果发现本文档有任何错误（或者有什么好的地方）？我很乐意听到您的意见。请给我发送邮件至 hjk@hansjkoch.de
关于 UIO
=========

如果你为你的卡片驱动程序使用 UIO，你将获得以下好处：

- 只需编写和维护一个小型内核模块。
- 在用户空间中开发驱动程序的主要部分，利用你熟悉的工具和库。
- 驱动程序中的错误不会导致内核崩溃。
- 更新驱动程序无需重新编译内核。

UIO 的工作原理
--------------

每个 UIO 设备通过一个设备文件和几个 sysfs 属性文件进行访问。第一个设备的设备文件将被称为 `/dev/uio0`，而后续设备则分别为 `/dev/uio1`、`/dev/uio2` 等等。
`/dev/uioX` 用于访问卡片的地址空间。只需使用 `mmap()` 函数即可访问卡片的寄存器或 RAM 地址。
中断通过从 `/dev/uioX` 进行读取来处理。当发生中断时，对 `/dev/uioX` 的阻塞 `read()` 将立即返回。您也可以在 `/dev/uioX` 上使用 `select()` 来等待中断。从 `/dev/uioX` 读取的整数值代表总的中断计数。您可以利用这个数字来判断是否错过了某些中断。
对于某些具有多个内部中断源但没有单独的 IRQ 遮罩和状态寄存器的硬件，可能会出现用户空间无法确定中断源的情况，如果内核处理器通过写入芯片的 IRQ 寄存器禁用它们的话。在这种情况下，内核必须完全禁用中断以保持芯片寄存器不变。现在用户空间部分可以确定中断的原因，但它不能重新启用中断。另一个特殊情况是那些重新启用中断需要对组合的 IRQ 状态/确认寄存器进行读-修改-写操作的芯片。如果新的中断同时发生，这将是竞争性的。
为了解决这些问题，UIO 还实现了一个 `write()` 函数。通常不需要使用它，并且对于只有单一中断源或有单独 IRQ 遮罩和状态寄存器的硬件可以忽略。但是，如果您需要它，写入 `/dev/uioX` 将调用由驱动程序实现的 `irqcontrol()` 函数。您需要写入一个通常是 0 或 1 的 32 位值来禁用或启用中断。如果驱动程序没有实现 `irqcontrol()`，`write()` 将带着 `-ENOSYS` 返回。
为了正确处理中断，您的自定义内核模块可以提供自己的中断处理器。它将自动被内置的处理器调用。
对于那些不产生中断但需要轮询的卡，可以设置一个定时器，在可配置的时间间隔触发中断处理程序。这种中断模拟是通过从定时器的事件处理程序中调用 :c:func:`uio_event_notify()` 来实现的。
每个驱动程序都提供了一些用于读取或写入变量的属性。这些属性可以通过 sysfs 文件访问。自定义内核驱动模块可以向由 uio 驱动拥有的设备添加自己的属性，但目前这些属性并未直接添加到 UIO 设备本身。
未来可能会有所改变，如果这样做被发现是有用的话。
UIO 框架提供了以下标准属性：

-  `name`: 您设备的名称。建议使用您的内核模块名称作为此名称。
-  `version`: 由您的驱动程序定义的版本字符串。这允许用户空间部分的驱动程序处理不同版本的内核模块。
-  `event`: 自上次读取设备节点以来，由驱动程序处理的中断总数。
这些属性出现在 `/sys/class/uio/uioX` 目录下。
请注意，这个目录可能是一个符号链接而不是实际的目录。任何访问它的用户空间代码必须能够处理这种情况。
每个 UIO 设备都可以为内存映射提供一个或多个内存区域。这是必要的，因为某些工业 I/O 卡要求在驱动程序中访问多个 PCI 内存区域。
每个映射在其 sysfs 中都有自己的目录，第一个映射出现在 `/sys/class/uio/uioX/maps/map0/`。后续映射创建 `map1/`, `map2/` 等目录。这些目录仅在映射大小非零时才会出现。
每个`mapX/`目录包含四个只读文件，这些文件展示了内存的属性：

- `name`: 为这个映射提供一个字符串标识。这是可选的，该字符串可以为空。驱动程序可以设置它以便用户空间更容易找到正确的映射。
- `addr`: 可以被映射的内存地址。
- `size`: 由`addr`指向的内存大小（以字节为单位）。
- `offset`: 需要加到`mmap()`函数返回的指针上的偏移量（以字节为单位），以到达实际的设备内存。如果设备的内存没有对齐到页，则这一点非常重要。
请记住，`mmap()`函数返回的指针总是对齐到页的，因此添加此偏移量始终是一个好的做法。

从用户空间来看，不同的映射是通过调整`mmap()`调用中的`offset`参数来区分的。为了映射第N个映射的内存，你需要使用N倍的页大小作为你的偏移量：

    offset = N * getpagesize();

有时会遇到无法使用上述技术进行映射的类似内存的硬件区域，但仍有一些方法可以从用户空间访问它们。最常见的例子是x86 io端口。在x86系统中，用户空间可以使用`ioperm()`、`iopl()`、`inb()`、`outb()`以及类似的函数访问这些io端口。
由于这些io端口区域无法被映射，因此它们不会像上面描述的正常内存那样出现在`/sys/class/uio/uioX/maps/`下。
如果没有关于硬件提供的端口区域的信息，对于驱动程序的用户空间部分来说，确定哪些端口属于哪个UIO设备变得很困难。

为了解决这种情况，新增了一个目录`/sys/class/uio/uioX/portio/`。只有当驱动程序希望向用户空间传递一个或多个端口区域的信息时，该目录才会存在。
如果确实如此，那么名为 `port0`、`port1` 等的子目录将出现在 `/sys/class/uio/uioX/portio/` 下。
每个 `portX/` 目录包含四个只读文件，这些文件显示端口区域的名称、起始地址、大小和类型：

-  `name`: 该端口区域的字符串标识符。这个字符串是可选的，可以为空。驱动程序可以设置它以便用户空间更容易找到特定的端口区域。
-  `start`: 这个区域的第一个端口。
-  `size`: 这个区域中的端口数量。
-  `porttype`: 描述端口类型的字符串。

编写自己的内核模块
====================

请参考 `uio_cif.c` 作为示例。以下段落解释了此文件的不同部分。

`struct uio_info`
-----------------

这个结构体告诉框架有关您的驱动程序的详细信息，其中一些成员是必需的，而其他一些则是可选的。
-  `const char *name`: 必需。在 sysfs 中显示的驱动程序名称。我建议使用您的模块名称。
-  `const char *version`: 必需。这个字符串会出现在 `/sys/class/uio/uioX/version` 中。
-  `struct uio_mem mem[ MAX_UIO_MAPS ]`: 如果您有可以通过 `mmap()` 映射的内存，则为必需。对于每个映射，您需要填写一个 `uio_mem` 结构体。详情参见下面的描述。
- `struct uio_port port[MAX_UIO_PORTS_REGIONS]`: 如果你需要向用户空间传递有关 I/O 端口的信息，则需要此结构。对于每个端口区域，你需要填充一个 `uio_port` 结构体。详细信息请参见下面的描述。
- `long irq`: 必需。如果你的硬件产生中断，你的模块在初始化期间需要确定中断号。如果你没有硬件产生的中断但想通过其他方式触发中断处理程序，请将 `irq` 设置为 `UIO_IRQ_CUSTOM`。如果你完全没有中断，可以将 `irq` 设置为 `UIO_IRQ_NONE`，但这很少有意义。
- `unsigned long irq_flags`: 如果你已将 `irq` 设置为硬件中断号，则此字段是必需的。这里给出的标志将在调用函数 `request_irq()` 时使用。
- `int (*mmap)(struct uio_info *info, struct vm_area_struct *vma)`：可选。如果你需要一个特殊的 `mmap()` 函数，可以在这里设置。如果此指针非 NULL，则你的 `mmap()` 将被调用而不是内置的那个。
- `int (*open)(struct uio_info *info, struct inode *inode)`：可选。你可能希望有自己的 `open()` 函数，例如仅当实际使用设备时才启用中断。
- `int (*release)(struct uio_info *info, struct inode *inode)`：可选。如果你定义了自己的 `open()` 函数，你可能也需要一个自定义的 `release()` 函数。
- `int (*irqcontrol)(struct uio_info *info, s32 irq_on)`：可选。如果你需要能够从用户空间通过写入 `/dev/uioX` 来启用或禁用中断，你可以实现这个函数。参数 `irq_on` 在禁用中断时为 0，在启用中断时为 1。

通常，你的设备会有一个或多个可以映射到用户空间的内存区域。对于每个区域，你都需要在 `mem[]` 数组中设置一个 `struct uio_mem`。以下是 `struct uio_mem` 的字段说明：

- `const char *name`：可选。设置此值以帮助识别内存区域，它将在对应的 sysfs 节点中显示。
- `int memtype`：如果使用该映射，则此字段是必需的。如果你的卡上有要映射的物理内存，请将其设置为 `UIO_MEM_PHYS`。对于逻辑内存（例如使用 `__get_free_pages()` 分配但不是通过 `kmalloc()` 分配的），使用 `UIO_MEM_LOGICAL`。还有一种 `UIO_MEM_VIRTUAL` 用于虚拟内存。
- `phys_addr_t addr`：如果使用了映射，则必须填写。填写你的内存块的地址。这个地址就是出现在sysfs中的那个。
- `resource_size_t size`：填写`addr`所指向的内存块的大小。如果`size`为零，则认为该映射未被使用。请注意，你*必须*将所有未使用的映射的`size`初始化为零。
- `void *internal_addr`：如果你需要从自己的内核模块内部访问这块内存区域，你可能希望使用类似:c:func:`ioremap()`这样的函数来内部映射它。由该函数返回的地址不能映射到用户空间，因此你不应该将其存储在`addr`中。相反，请使用`internal_addr`来记住这样一个地址。

请不要修改`struct uio_mem`中的`map`元素！它是由UIO框架用来为此映射设置sysfs文件的。请保持其不变。

有时，你的设备可能有一个或多个无法映射到用户空间的端口区域。但如果用户空间有其他方式可以访问这些端口，则提供关于这些端口的信息是有意义的。对于每个区域，你需要在`port[]`数组中设置一个`struct uio_port`。下面是`struct uio_port`字段的描述：

- `char *porttype`：必需。将其设置为预定义常量之一。对于x86架构中的io端口，请使用`UIO_PORT_X86`。
- `unsigned long start`：如果使用了端口区域，则必须填写。填写该区域的第一个端口号。
- `unsigned long size`：填写此区域中的端口数量。
如果`size`为零，则认为该区域未被使用。请注意，你*必须*将所有未使用的区域的`size`初始化为零。

请不要修改`struct uio_port`中的`portio`元素！它是由UIO框架内部用来为此区域设置sysfs文件的。请保持其不变。

添加中断处理程序
-------------------

你在中断处理程序中需要做什么取决于你的硬件以及你如何打算处理它。你应该尽量减少内核中断处理程序中的代码量。如果你的硬件不需要在每次中断后执行任何操作，那么你的处理程序可以为空。
如果另一方面，你的硬件*需要*在每次中断后执行某些操作，那么你*必须*在内核模块中实现它。请注意，你不能依赖于驱动程序的用户空间部分。你的用户空间程序可能随时终止，可能会使你的硬件处于仍然需要正确处理中断的状态。
也可能存在这样的应用场景：你想在每次中断时从硬件读取数据，并将其缓冲到为此目的分配的一段内核内存中。通过这种技术，即使你的用户空间程序错过了中断，也能避免数据丢失。

关于共享中断的说明：只要可能，你的驱动程序应该支持中断共享。这仅当你的驱动程序能够检测出是你的硬件触发了中断还是其他设备触发了中断时才可行。这通常是通过查看中断状态寄存器来完成的。如果驱动程序看到IRQ位确实被设置了，则执行相应的操作，并返回`IRQ_HANDLED`。如果驱动程序检测到不是由你的硬件引起的中断，则不做任何操作并返回`IRQ_NONE`，允许内核调用下一个可能的中断处理器。

如果你决定不支持共享中断，你的设备将无法在没有空闲中断的计算机上工作。这种情况在PC平台上经常发生，因此支持中断共享可以为你省去很多麻烦。

使用`uio_pdrv`处理平台设备
-------------------------------

在许多情况下，平台设备的UIO驱动程序可以通过通用的方式处理。在同一位置定义`struct platform_device`时，只需同时实现你的中断处理器并填充`struct uio_info`。指向这个`struct uio_info`的指针将作为`platform_data`用于你的平台设备。

你还需要设置一个`struct resource`数组，其中包含你的内存映射的地址和大小。这些信息通过`struct platform_device`中的`.resource`和`.num_resources`元素传递给驱动程序。

现在，你需要将`struct platform_device`的`.name`元素设置为`"uio_pdrv"`以使用通用的UIO平台设备驱动程序。该驱动程序会根据提供的资源填充`mem[]`数组，并注册设备。

这种方法的优点是你只需要编辑你本来就需要编辑的文件，无需创建额外的驱动程序。

使用`uio_pdrv_genirq`处理平台设备
--------------------------------------

特别是在嵌入式设备中，经常会发现芯片的IRQ引脚连接到其自身的专用中断线上。在这种情况下，当你确信中断不会被共享时，我们可以进一步采用`uio_pdrv`的概念并使用通用的中断处理器。这就是`uio_pdrv_genirq`的作用。

对于此驱动程序的设置与上面描述的`uio_pdrv`相同，只是不需要实现中断处理器。`struct uio_info`中的`.handler`元素必须保持为`NULL`。`.irq_flags`元素不得包含`IRQF_SHARED`。
将 `struct platform_device` 中的 `.name` 元素设置为 `"uio_pdrv_genirq"` 来使用此驱动程序。
`uio_pdrv_genirq` 的通用中断处理程序会简单地使用 `disable_irq_nosync()` 函数禁用中断线。在完成其工作后，用户空间可以通过向 UIO 设备文件写入 0x00000001 来重新启用中断。驱动程序已经实现了一个 `irq_control()` 函数来实现这一点，你不必自己实现。

使用 `uio_pdrv_genirq` 不仅节省了几行中断处理代码。你也不需要了解芯片内部寄存器的任何信息来创建驱动程序的内核部分。你需要知道的只是芯片连接引脚的中断号。

当在支持设备树的系统中使用时，驱动程序需要通过设置 `"of_id"` 模块参数为要处理节点的 `"compatible"` 字符串来探测。默认情况下，节点的名称（不包括单元地址）作为 UIO 设备在用户空间中的名称暴露出来。为了设置自定义名称，可以在设备树节点中指定一个名为 `"linux,uio-name"` 的属性。

对于平台设备使用 uio_dmem_genirq
--------------------------------------

除了静态分配的内存范围外，还可能希望在用户空间驱动程序中使用动态分配的区域。特别是能够访问通过 dma-mapping API 提供的内存可能会特别有用。`uio_dmem_genirq` 驱动程序提供了一种实现这一目标的方法。

该驱动程序在中断配置和处理方面与 `"uio_pdrv_genirq"` 驱动程序类似。
将 `struct platform_device` 中的 `.name` 元素设置为 `"uio_dmem_genirq"` 来使用此驱动程序。

使用此驱动程序时，请填充 `struct platform_device` 中的 `.platform_data` 元素，该元素类型为 `struct uio_dmem_genirq_pdata`，其中包含以下元素：

-  `struct uio_info uioinfo`：与 `uio_pdrv_genirq` 平台数据中使用的相同的结构

-  `unsigned int *dynamic_region_sizes`：指向要在用户空间映射的动态内存区域大小列表的指针
-  `unsigned int num_dynamic_regions`：`dynamic_region_sizes` 数组中的元素数量

平台数据中定义的动态区域将被追加到 `mem[]` 数组之后，位于平台设备资源之后，这意味着静态和动态内存区域的总数不能超过 `MAX_UIO_MAPS`。
动态内存区域将在UIO设备文件`/dev/uioX`被打开时分配。与静态内存资源类似，动态区域的内存信息随后可通过sysfs在`/sys/class/uio/uioX/maps/mapY/*`中查看。当UIO设备文件关闭时，动态内存区域将被释放。当没有进程持有设备文件打开时，返回给用户空间的地址为~0。

编写用户空间驱动程序
==============================

一旦你为你的硬件编写了一个可用的内核模块，你就可以编写用户空间部分的驱动程序了。你不需要任何特殊的库，你的驱动程序可以用任何合理的语言编写，并且可以使用浮点数等。简而言之，你可以使用所有通常用于编写用户空间应用程序的工具和库。

获取UIO设备的信息
-----------------------------------------

所有UIO设备的信息都可在sysfs中找到。在你的驱动程序中首先应该做的就是检查`name`和`version`以确保你正在与正确的设备通信，并且其内核驱动程序具有你期望的版本。
你也应该确保所需的内存映射存在并且具有预期的大小。

有一个名为`lsuio`的工具，它可以列出UIO设备及其属性。这个工具可以从以下链接获取：

http://www.osadl.org/projects/downloads/UIO/user/

通过`lsuio`，你可以快速检查你的内核模块是否已加载以及它导出了哪些属性。请参阅manpage以了解详细信息。
`lsuio`的源代码可以作为获取UIO设备信息的一个示例。文件`uio_helper.c`包含了许多你可以在用户空间驱动程序代码中使用的函数。

mmap() 设备内存
--------------------

确认你已经选择了正确的带有所需内存映射的设备之后，你只需调用:c:func:`mmap()`来将设备的内存映射到用户空间即可。
:c:func:`mmap()`调用中的参数`offset`对于UIO设备有特殊含义：它用于选择你要映射的设备映射。要映射第N个映射的内存，你需要使用N倍的页大小作为你的偏移量：

        `offset = N * getpagesize();`

N从零开始计数，因此如果你只有一个需要映射的内存范围，则设置`offset = 0`。这种方法的一个缺点是内存总是从其起始地址开始映射。

等待中断
----------------------

成功映射你的设备内存后，你可以像访问普通数组一样访问它。通常，你会执行一些初始化操作。
之后，你的硬件开始工作，并会在完成工作、有数据可用或因为发生错误需要你的注意时生成一个中断。
``/dev/uioX``是一个只读文件。调用:c:func:`read()`总会阻塞直到发生中断。对于:c:func:`read()`的参数``count``，只有一个合法的值，那就是一个有符号32位整数的大小（4）。其他任何值都会导致:c:func:`read()`失败。所读取的有符号32位整数是设备的中断计数。如果该值比上次读取的值多1，则一切正常。如果差值大于1，则说明你错过了某些中断。
还可以在``/dev/uioX``上使用:c:func:`select()`。

通用PCI UIO驱动
=================

通用驱动是一个名为uio_pci_generic的内核模块。它可以与符合PCI 2.3（大约2002年）标准及所有符合PCI Express标准的设备一起工作。使用这个驱动，你只需编写用户空间驱动程序，而无需编写特定于硬件的内核模块。

让驱动识别设备
----------------------

由于驱动未声明任何设备ID，因此它不会自动加载，也不会自动绑定到任何设备，你必须自己加载驱动并分配ID。例如：

     modprobe uio_pci_generic
     echo "8086 10f5" > /sys/bus/pci/drivers/uio_pci_generic/new_id

如果你的设备已经有专用的硬件驱动程序，那么通用驱动仍然不会绑定到它。在这种情况下，如果你想使用通用驱动（为什么你要这样做？），你必须手动解除专用驱动的绑定，并绑定通用驱动，如下所示：

        echo -n 0000:00:19.0 > /sys/bus/pci/drivers/e1000e/unbind
        echo -n 0000:00:19.0 > /sys/bus/pci/drivers/uio_pci_generic/bind

你可以通过查看sysfs来验证设备是否已绑定到驱动程序，例如：

        ls -l /sys/bus/pci/devices/0000:00:19.0/driver

如果成功，应该打印出如下内容：

      .../0000:00:19.0/driver -> ../../../bus/pci/drivers/uio_pci_generic

请注意，通用驱动不会绑定到旧的PCI 2.2设备。如果绑定设备失败，请运行以下命令：

      dmesg

并在输出中查找失败原因。

关于uio_pci_generic要知道的事情
------------------------------------

中断处理使用PCI命令寄存器中的中断禁用位和PCI状态寄存器中的中断状态位。所有符合PCI 2.3（大约2002年）标准和所有符合PCI Express标准的设备都应该支持这些位。uio_pci_generic会检测这些支持，并且不会绑定到不支持命令寄存器中的中断禁用位的设备。

在每次中断时，uio_pci_generic会设置中断禁用位。这会阻止设备生成进一步的中断，直到该位被清除。用户空间驱动程序应在阻塞和等待更多中断之前清除该位。

使用uio_pci_generic编写用户空间驱动
-------------------------------------------------

用户空间驱动程序可以使用pci sysfs接口，或者使用封装它的libpci库来与设备通信，并通过写入命令寄存器来重新启用中断。

使用uio_pci_generic的示例代码
----------------------------------

这里有一些使用uio_pci_generic的示例用户空间驱动代码：

    #include <stdlib.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <errno.h>

    int main()
    {
        int uiofd;
        int configfd;
        int err;
        int i;
        unsigned icount;
        unsigned char command_high;

        uiofd = open("/dev/uio0", O_RDONLY);
        if (uiofd < 0) {
            perror("uio open:");
            return errno;
        }
        configfd = open("/sys/class/uio/uio0/device/config", O_RDWR);
        if (configfd < 0) {
            perror("config open:");
            return errno;
        }

        /* 读取并缓存命令值 */
        err = pread(configfd, &command_high, 1, 5);
        if (err != 1) {
            perror("command config read:");
            return errno;
        }
        command_high &= ~0x4;

        for(i = 0;; ++i) {
            /* 打印一条消息，用于调试。 */
            if (i == 0)
                fprintf(stderr, "Started uio test driver.\n");
            else
                fprintf(stderr, "Interrupts: %d\n", icount);

            /****************************************/
            /* 这里我们从设备接收到一个中断。
               对其执行一些操作。 */
            /****************************************/

            /* 重新启用中断。 */
            err = pwrite(configfd, &command_high, 1, 5);
            if (err != 1) {
                perror("config write:");
                break;
            }

            /* 等待下一个中断。 */
            err = read(uiofd, &icount, 4);
            if (err != 4) {
                perror("uio read:");
                break;
            }

        }
        return errno;
    }

通用Hyper-V UIO驱动
==========================

通用驱动是一个名为uio_hv_generic的内核模块。它支持Hyper-V VMBus上的设备，类似于uio_pci_generic在PCI总线上的支持。
使驱动程序识别设备
----------------------

由于驱动程序未声明任何设备GUID，因此它不会自动加载，也不会自动绑定到任何设备上，您必须手动加载并为驱动程序分配ID。例如，要使用网络设备类的GUID，请执行以下操作：

     modprobe uio_hv_generic
     echo "f8615163-df3e-46c5-913f-f2d2f965ed0e" > /sys/bus/vmbus/drivers/uio_hv_generic/new_id

如果设备已经有一个特定硬件的内核驱动程序，通用驱动程序仍然不会与之绑定。在这种情况下，如果您想使用通用驱动程序来支持用户空间库，您需要手动解除特定硬件驱动程序的绑定，并绑定通用驱动程序，使用特定于设备的GUID，如下所示：

          echo -n ed963694-e847-4b2a-85af-bc9cfc11d6f3 > /sys/bus/vmbus/drivers/hv_netvsc/unbind
          echo -n ed963694-e847-4b2a-85af-bc9cfc11d6f3 > /sys/bus/vmbus/drivers/uio_hv_generic/bind

您可以通过查看sysfs中的设备来验证该设备已绑定到驱动程序，例如：

        ls -l /sys/bus/vmbus/devices/ed963694-e847-4b2a-85af-bc9cfc11d6f3/driver

如果成功，将显示如下内容：

      .../ed963694-e847-4b2a-85af-bc9cfc11d6f3/driver -> ../../../bus/vmbus/drivers/uio_hv_generic

关于uio_hv_generic的要点
----------------------

每当发生中断时，uio_hv_generic都会设置中断禁用位。这会阻止设备生成进一步的中断，直到清除该位。用户空间驱动程序应在阻塞并等待更多中断之前清除此位。
当主机撤回一个设备时，中断文件描述符会被标记为失效，对中断文件描述符的任何读取都会返回-EIO。这类似于关闭的套接字或断开连接的串行设备。
vmbus设备区域被映射到uio设备资源中：
    0) 客户端到主机和主机到客户端的通道环形缓冲区
    1) 客户端到主机的中断信号页面
    2) 客户端到主机的监控页面
    3) 网络接收缓冲区区域
    4) 网络发送缓冲区区域

如果通过向主机发出请求创建了子通道，则uio_hv_generic设备驱动程序将为每个通道的环形缓冲区创建一个sysfs二进制文件。
例如：

	/sys/bus/vmbus/devices/3811fe4d-0fa0-4b62-981a-74fc1084c757/channels/21/ring

更多信息
=============

-  `OSADL主页. <http://www.osadl.org>`_

-  `Linutronix主页. <http://www.linutronix.de>`_
