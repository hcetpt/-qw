=============================
BTT - 块翻译表
=============================


1. 引言
===============

基于持久内存的存储能够以字节（或者更准确地说，缓存行）粒度执行I/O操作。然而，我们通常希望将此类存储暴露为传统的块设备。持久内存的块驱动程序正是这样做的。但是，它们并不提供任何原子性保证。传统的SSD通常在硬件层面上通过电容器中储存的能量来完成飞行中的块写入，从而对撕裂扇区提供保护，或者可能是在固件层面上实现这一点。对于持久内存而言，我们没有这种奢侈——如果一个写入操作正在进行，并且我们遇到了电源故障，那么这个块将包含旧数据和新数据的混合体。应用程序可能没有准备好处理这种情况。
块翻译表（BTT）为持久内存设备提供了原子扇区更新语义，以便依赖于扇区写入不被撕裂的应用程序可以继续这样做。BTT表现为一个堆叠的块设备，并为它的元数据预留了底层存储的一部分。其核心是一个间接表，该表重新映射卷上的所有块。可以将其视为一个极其简单的文件系统，它只提供原子扇区更新。

2. 静态布局
================

可以为BTT布局的基础存储没有任何限制。
然而，BTT将可用空间分割成最多512GiB的块，称为“Arena”。
每个Arena对其元数据遵循相同的布局，且Arena内的所有引用都是内部的（除了指向下一个Arena的一个字段）。下图描绘了“磁盘上”的元数据布局：

```
基础存储     +------->  Arena
  +---------------+   |   +------------------+
  |               |   |   | Arena信息块 |
  |    Arena 0    +---+   |       4K         |
  |     512G      |       +------------------+
  |               |       |                  |
  +---------------+       |                  |
  |               |       |                  |
  |    Arena 1    |       |   数据块    |
  |     512G      |       |                  |
  |               |       |                  |
  +---------------+       |                  |
  |       .       |       |                  |
  |       .       |       |                  |
  |       .       |       |                  |
  |               |       |                  |
  |               |       |                  |
  +---------------+       +------------------+
                          |                  |
                          |     BTT Map      |
                          |                  |
                          |                  |
                          +------------------+
                          |                  |
                          |     BTT 日志     |
                          |                  |
                          +------------------+
                          | 信息块副本  |
                          |       4K         |
                          +------------------+
```


3. 工作原理
======================


a. BTT Map
--------------

Map是一个简单的查找/间接表，用于将LBA映射到内部块。每个Map条目是32位。最高两位是特殊的标志位，其余部分则表示内部块号。
======== =============================================================
Bit      描述
======== =============================================================
31 - 30	 错误和零标志 - 使用方式如下所示：

	   == ==  ====================================================
	   31 30  描述
	   == ==  ====================================================
	   0  0	  初始状态。读取返回零；预映射 = 后映射
	   0  1	  零状态：读取返回零
	   1  0	  错误状态：读取失败；写入清除'E'位
	   1  1	  正常块 – 具有有效的后映射
	   == ==  ====================================================

29 - 0	 映射到内部的“后映射”块
======== =============================================================


下面是一些后续将使用的术语：

============	================================================================
外部LBA	LBA，如上层所见
ABA		Arena块地址 - Arena内的块偏移/编号
预映射ABA	通过对外部LBA进行范围检查确定的Arena中的块偏移
后映射ABA	从Map中间接获得的“数据块”区域中的块号
nfree		任何给定时刻维护的空闲块数
这是可以同时发生到Arena的写入数量
============	================================================================


例如，在添加BTT之后，我们提供了一个1024G的磁盘。我们接收到对外部LBA位于768G处的读取请求。这落在第二个Arena中，在该Arena提供的512G的块中，这个块位于256G处。因此，预映射ABA为256G。我们现在参照Map，发现块'X'（256G）的映射指向块'Y'，假设为'64'。因此，后映射ABA为64。
b. BTT Flog
---------------

BTT 通过将每一次写操作变为“分配式写入”来提供扇区原子性，也就是说，每次写操作都指向一个“空闲”块。维护了一个空闲块的运行列表，形式为 BTT 的 flog（free log 的组合词）。flog 包含 `nfree` 个条目，每个条目包含：

========  =====================================================================
lba       正在写入的预映射 ABA
old_map   完成本次写操作后的旧后映射 ABA —— 之后这将成为一个空闲块
new_map   新的后映射 ABA。映射将更新以反映此 lba->后映射_aba 映射，但我们也在此记录以防需要恢复
seq      序列号，用于标记此 flog 条目的两个部分中哪个是有效的/最新的。正常运行时，它会在 01->10->11->01（二进制）之间循环，其中 00 表示未初始化状态
lba'     备选 lba 入口
old_map'  备选旧后映射入口
new_map'  备选新后映射入口
seq'     备选序列号
========  =====================================================================

上述每个字段都是 32 位，因此一个条目占 32 字节。条目还填充至 64 字节以避免缓存行共享或别名问题。对 flog 的更新操作确保对于任何正在写的条目，做到：
a. 根据序列号覆盖条目中的“旧”部分
b. 写入“新”部分，确保序列号最后写入
c. 车道的概念
-----------------------

虽然 `nfree` 描述了每个区域能同时处理的并发 I/O 数量，`nlanes` 则表示整个 BTT 设备能同时处理的 I/O 数量：

    nlanes = min(nfree, num_cpus)

在任何 I/O 开始时获取车道编号，并在整个 I/O 过程中用于索引所有磁盘上和内存中的数据结构。如果 CPU 数量多于最大可用车道数，则使用自旋锁保护车道。
d. 内存数据结构：读取跟踪表 (RTT)
------------------------------------------------------

考虑这样一个情况，我们有两个线程，一个进行读取，另一个进行写入。可能会出现一种情况，即写入线程抓取一个空闲块以进行新的 I/O 操作，但（慢速）读取线程仍在从该块读取数据。换句话说，读取者查询了映射条目并开始读取相应的块。写入者开始写入相同的外部 LBA 并完成了写入，更新了该外部 LBA 的映射，指向其新的后映射 ABA。此时，读取者仍在读取的内部、后映射块已经被加入到空闲块列表中。如果针对同一个 LBA 的另一个写入请求到来，它可以抓取这个空闲块并开始写入，从而导致读取者读取到错误的数据。为了避免这种情况，我们引入了 RTT。
RTT 是一个简单的每区域表，包含 `nfree` 个条目。每个读取者在 `rtt[车道编号]` 中插入其正在读取的后映射 ABA，并在读取完成后将其清空。每个写入线程，在抓取一个空闲块后，检查 RTT 中是否存在该后映射空闲块。如果后映射空闲块在 RTT 中，它会等待直到读取者清空 RTT 条目，然后才开始写入。
e. 内存数据结构：映射锁
--------------------------------------

考虑两个写入线程正写入相同的 LBA 的情况。可能会出现以下步骤的竞争条件：

```
free[车道] = map[预映射_aba]
map[预映射_aba] = 后映射_aba
```

两个线程都可以用相同的旧、已释放的后映射 ABA 更新它们各自的 `free[车道]`。这使得布局变得不一致，丢失了一个空闲条目，同时为两个车道重复了另一个空闲条目。

为了解决这个问题，我们可以为每个区域设置一个单一的映射锁，在执行上述序列之前必须获取该锁，但我们担心这可能会引起过多的争用。
### f. 从Flog重建

启动时，我们分析BTT Flog来创建我们的空闲块列表。遍历所有条目，并对于每条车道，在两个可能的“section”中，我们仅查看最新的那一个（基于序列号）。重建规则/步骤很简单：

- 读取`map[log_entry.lba]`
- 如果`log_entry.new`与映射项匹配，则`log_entry.old`是空闲的
- 如果`log_entry.new`不匹配映射项，则`log_entry.new`是空闲的
- （这种情况只能由断电或不安全关机引起）

### g. 总结 —— 读写流程

#### 读取：

1. 将外部LBA转换为区域编号+预映射ABA
2. 获取一条车道（并锁定车道）
3. 读取映射表以获取该预映射ABA的条目
4. 将后映射ABA写入RTT[lane]
5. 如果映射中的TRIM标志被设置，则返回零值，并结束I/O操作（跳转到步骤8）
6. 如果映射中的ERROR标志被设置，则以EIO错误结束I/O操作（跳转到步骤8）
7. 从此块读取数据
8. 从RTT[lane]中删除后映射ABA条目
9. 释放车道（及车道锁）

#### 写入：

1. 将外部LBA转换为区域编号+预映射ABA
2. 获取一条车道（并锁定车道）
3. 使用车道索引内存中的空闲列表，并获取一个新的块、下一个Flog索引和下一个序列号
4. 扫描RTT检查空闲块是否已存在，如果存在则自旋/等待
5. 将数据写入这个空闲块
6. 读取映射表以获取此预映射ABA的现有后映射ABA条目
7. 写入Flog条目：`[premap_aba / old postmap_aba / new postmap_aba / seq_num]`
8. 将新的后映射ABA写入映射表
9. 将旧的后映射条目写入空闲列表
10. 计算下一个序列号，并写入空闲列表条目
11. 释放车道（及车道锁）

### 4. 错误处理

如果任何元数据因bug或介质错误而不可恢复地损坏，区域将处于错误状态。以下条件指示存在错误：

- 信息块校验和不匹配（并且从副本恢复也失败）
- 所有内部可用块没有被映射块和Flog中的空闲块唯一且完整地覆盖
- 从Flog重建空闲列表时发现缺失/重复/不可能的条目
- 映射表条目超出边界

如果遇到上述任一错误条件，使用信息块中的标志将区域置于只读状态。

### 5. 使用方法

BTT可以设置在libnvdimm子系统暴露的任何磁盘（命名空间）上（pmem或块模式）。最简单的方法是使用`ndctl`工具[1]来设置这样的命名空间：

例如，使用ndctl命令行设置一个具有4k扇区大小的BTT如下：

```
ndctl create-namespace -f -e namespace0.0 -m sector -l 4k
```

更多信息选项，请参阅`ndctl create-namespace --help`

[1]: https://github.com/pmem/ndctl
