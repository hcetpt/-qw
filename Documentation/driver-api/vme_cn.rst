VME 设备驱动程序
==================

驱动程序注册
-------------------

与 Linux 内核中的其他子系统一样，VME 设备驱动程序需要向 VME 子系统注册，通常是在设备的初始化例程中调用。这是通过调用 :c:func:`vme_register_driver` 实现的。必须向注册函数提供一个类型为 :c:type:`struct vme_driver <vme_driver>` 的结构体指针。此外，还需指定驱动程序能够支持的最大设备数量。
至少，应正确设置 :c:type:`struct vme_driver <vme_driver>` 中的 '.name', '.match' 和 '.probe' 成员。'.name' 是指向字符串的指针，该字符串包含设备驱动程序的名称。
'.match' 函数允许控制哪些 VME 设备应与驱动程序注册。如果应当探测某个设备，则匹配函数应返回 1；否则返回 0。下面是从 `vme_user.c` 中摘取的一个示例匹配函数，它将探测的设备数量限制为一个：

.. code-block:: c

	#define USER_BUS_MAX	1
	..
	static int vme_user_match(struct vme_dev *vdev)
	{
		if (vdev->id.num >= USER_BUS_MAX)
			return 0;
		return 1;
	}

'.probe' 成员应当包含指向探测例程的指针。探测例程将接收到一个 :c:type:`struct vme_dev <vme_dev>` 类型的指针作为参数。
这里，'num' 字段指的是针对特定驱动程序的顺序设备ID。可以通过 `dev->bridge->num` 访问桥接器编号（或总线编号）。
还提供了一个函数 :c:func:`vme_unregister_driver` 来从 VME 核心注销驱动程序，通常应该在设备驱动程序的退出例程中调用。

资源管理
-------------------

一旦驱动程序向 VME 核心注册，所提供的匹配例程将被调用注册时指定的次数。如果匹配成功，应返回非零值。零值表示失败。对于所有成功的匹配，将调用相应驱动程序的探测例程。探测例程将传递设备的设备结构体的指针。应当保存这个指针，因为请求 VME 资源时需要用到它。
驱动程序可以请求一个或多个主窗口的所有权 (:c:func:`vme_master_request`)、从属窗口 (:c:func:`vme_slave_request`) 和/或 DMA 通道 (:c:func:`vme_dma_request`)。而不是允许设备驱动程序请求特定的窗口或 DMA 通道（这些可能已被其他驱动程序使用），API 允许根据驱动程序所需属性来分配资源。对于从属窗口，这些属性分为需要访问的 VME 地址空间 'aspace' 和所需的 VME 总线周期类型 'cycle'。主窗口添加了一组额外的属性 'width'，指定了所需的数据传输宽度。这些属性定义为位掩码，因此可以为单个窗口请求任何组合的属性。核心将分配满足要求的窗口，并返回类型为 vme_resource 的指针，当使用已分配资源时应使用此指针进行标识。对于 DMA 控制器，请求函数需要提供任何传输的潜在方向作为路由属性。这通常是 VME 到 MEM 和/或 MEM 到 VME，尽管某些硬件还可以支持 VME 到 VME 和 MEM 到 MEM 的传输以及测试模式生成。如果找不到符合要求的未分配窗口，则返回 NULL 指针。
还提供了在不再需要窗口分配时释放它们的函数。这些函数（:c:func:`vme_master_free`，:c:func:`vme_slave_free` 和 :c:func:`vme_dma_free`）应当传递在资源分配期间提供的资源指针。
### 主窗口
---

主窗口提供了从本地处理器访问VME总线的途径。
可用窗口的数量以及可使用的访问模式取决于底层芯片组。在使用前必须先配置好一个窗口。

#### 主窗口配置
~~~~~~~~~~~~~~~~~~~~~~~~~~~

一旦分配了一个主窗口，就可以使用函数 :c:func:`vme_master_set` 来配置它，并使用 :c:func:`vme_master_get` 来获取当前设置。地址空间、传输宽度和周期类型与资源管理中描述的一致，但是某些选项是互斥的。
例如，只能指定一个地址空间。

#### 主窗口访问
~~~~~~~~~~~~~~~~~~~~

可以使用函数 :c:func:`vme_master_read` 从配置好的主窗口读取数据，使用 :c:func:`vme_master_write` 向其写入数据。
除了简单的读写操作外，还提供 :c:func:`vme_master_rmw` 来执行读-改-写事务。VME窗口的部分也可以通过 :c:func:`vme_master_mmap` 映射到用户空间内存中。

### 从属窗口
-------------

从属窗口允许VME总线上的设备访问本地内存中的映射部分。可用窗口的数量以及可以使用的访问模式取决于底层芯片组。在使用之前必须先配置好一个窗口。

#### 从属窗口配置
~~~~~~~~~~~~~~~~~~~~~~~~~~

一旦分配了一个从属窗口，就可以使用函数 :c:func:`vme_slave_set` 来配置它，并使用 :c:func:`vme_slave_get` 来获取当前设置。
地址空间、传输宽度和周期类型与资源管理中描述的一致，但是某些选项是互斥的。
例如，只能指定一个地址空间。
### 从窗口缓冲分配
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

提供了函数允许用户分配（:c:func:`vme_alloc_consistent`）和释放（:c:func:`vme_free_consistent`）
连续的缓冲区，这些缓冲区可以被VME桥接器访问。虽然不必使用这些函数，但其他方法也可以用来分配缓冲区，
不过需要注意确保它们是连续的并且可以被VME桥接器访问。

### 从窗口访问
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

从窗口将本地内存映射到VME总线上，应使用标准的方法来访问内存。

### DMA通道
---------------------------------

VME DMA传输提供了执行链表DMA传输的能力。API引入了DMA列表的概念。
每个DMA列表是一个链表，可以传递给DMA控制器。可以创建、扩展、执行、重复使用和销毁多个列表。

#### 列表管理
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

提供了函数 :c:func:`vme_new_dma_list` 来创建和 :c:func:`vme_dma_list_free` 来销毁DMA列表。
执行一个列表不会自动销毁该列表，因此使列表能够用于重复任务。

#### 列表填充
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

可以使用 :c:func:`vme_dma_list_add` 将项添加到列表中（在调用此函数之前需要创建源和目标属性，这在“传输属性”部分进行介绍）。
.. note:: 

    在将条目添加到DMA列表之前，不会检查传输源和目的地的具体属性，请求DMA通道仅会检查控制器预期的数据传输方向。
    因此，此调用可能返回错误，例如如果源或目的地处于不支持的VME地址空间。

#### 传输属性
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

源和目的地的属性与向列表添加项分开处理。这是因为每种类型的源和目的地都需要不同的属性。
有为PCI、VME和模式源及目的地创建属性的函数（适当情况下）：

- PCI源或目的地：:c:func:`vme_dma_pci_attribute`
- VME源或目的地：:c:func:`vme_dma_vme_attribute`
- 模式源：:c:func:`vme_dma_pattern_attribute`

应使用函数 :c:func:`vme_dma_free_attribute` 来释放属性。

#### 列表执行
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

函数 :c:func:`vme_dma_list_exec` 将列表排队执行，并在列表执行完成后返回。

### 中断
---------------------------------

VME API提供了函数以将回调附加到特定的VME级别和状态ID组合以及生成具有特定VME级别和状态ID的VME中断。

#### 附加中断处理器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

可以使用函数 :c:func:`vme_irq_request` 来附加和 :c:func:`vme_irq_free` 来释放特定的VME级别和状态ID组合。
任何给定的组合只能分配一个回调函数。提供了一个空指针参数，其值将传递给回调函数，该指针的用途由用户自定义。回调函数的参数如下。编写回调函数时必须小心，因为回调函数是在中断上下文中运行的：

.. code-block:: c

    void callback(int level, int statid, void *priv);

中断生成
~~~~~~~~

函数 :c:func:`vme_irq_generate` 可用于在给定的 VME 级别和 VME 状态 ID 生成 VME 中断。

位置监控器
-----------

VME API 提供了以下功能来配置位置监控器：
位置监控器管理
~~~~~~~~~~~~~~~~

提供了函数 :c:func:`vme_lm_request` 来请求使用一组位置监控器，并且 :c:func:`vme_lm_free` 用于在不再需要时释放它们。每个组可以提供多个位置监控器，用于监控相邻的位置。函数 :c:func:`vme_lm_count` 可用于确定提供了多少个位置。
位置监控器配置
~~~~~~~~~~~~~~~~

分配了一组位置监控器后，提供了函数 :c:func:`vme_lm_set` 来配置位置监控器的位置和模式。函数 :c:func:`vme_lm_get` 可用于检索现有设置。
位置监控器使用
~~~~~~~~~~~~~~

函数 :c:func:`vme_lm_attach` 允许为每个位置监控器位置附加一个回调，而 :c:func:`vme_lm_detach` 允许从每个位置监控器位置分离回调。每个位置监控器可以监控多个相邻的位置。回调函数声明如下：

.. code-block:: c

    void callback(void *data);

插槽检测
--------

函数 :c:func:`vme_slot_num` 返回提供的桥接器的插槽 ID。

总线检测
--------

函数 :c:func:`vme_bus_num` 返回提供的桥接器的总线 ID。

VME API
-------

.. kernel-doc:: drivers/staging/vme_user/vme.h
   :internal:

.. kernel-doc:: drivers/staging/vme_user/vme.c
   :export:
