### 内核加密API架构

#### 加密算法类型

内核加密API为以下类型的加密提供了不同的API调用：

- 对称加密
- 带认证的加密（AEAD）
- 消息摘要，包括带密钥的消息摘要
- 随机数生成
- 用户空间接口

#### 密码算法与模板

内核加密API提供了单块加密和消息摘要的实现。此外，内核加密API还提供了一系列“模板”，这些模板可以与单块加密和消息摘要一起使用。模板包括所有类型的块链模式、HMAC机制等。
单块加密和消息摘要既可以被直接调用，也可以与模板一起调用来形成多块加密或带密钥的消息摘要。
一个单块加密甚至可以与多个模板一起调用，但是模板不能脱离单个密码算法而单独使用。
参见 `/proc/crypto` 并搜索“name”。例如：

- `aes`
- `ecb(aes)`
- `cmac(aes)`
- `ccm(aes)`
- `rfc4106(gcm(aes))`
- `sha1`
- `hmac(sha1)`
- `authenc(hmac(sha1),cbc(aes))`

在这些例子中，“aes”和“sha1”是密码算法，其余都是模板。

#### 同步与异步操作

内核加密API提供了同步和异步的操作方式。
当使用同步API操作时，调用者会调用一个由内核加密API同步执行的密码操作。这意味着调用者需要等待直到密码操作完成。
因此，内核加密API调用工作起来就像普通的函数调用一样。
对于同步操作，API调用集较小，并且从概念上讲与其他任何加密库相似。
异步操作由内核加密API提供，这意味着调用加密操作几乎可以瞬间完成。该调用触发了加密操作但并不标志着其完成。在调用加密操作之前，调用者必须提供一个回调函数，以便内核加密API能够调用它来指示加密操作的完成。此外，调用者还必须确保可以通过对其数据应用适当的锁定来处理此类异步事件。内核加密API不会执行任何特殊的序列化操作来保护调用者的数据完整性。

### 加密API的密钥引用和优先级

密钥通过调用者使用的一个字符串进行引用。该字符串具有以下语义：

```
模板(单块密钥)
```

其中“模板”和“单块密钥”分别是上述提到的模板和单块密钥。如果适用，其他模板可以嵌套在该模板内，例如：

```
模板1(模板2(单块密钥))
```

内核加密API可能为模板或单块密钥提供多个实现。例如，Intel较新硬件上的AES有以下实现：AES-NI、汇编器实现或纯C语言实现。现在，当使用字符串“aes”与内核加密API一起时，会使用哪个密钥实现？这个问题的答案是每个密钥实现由内核加密API分配的优先级数字。当调用者使用字符串来引用初始化密钥句柄期间的密钥时，内核加密API会查找所有提供该名称实现的实现，并选择具有最高优先级的实现。

现在，调用者可能需要引用特定的密钥实现，因此不希望依赖基于优先级的选择。为了适应这种场景，内核加密API允许密钥实现除了通用名称之外注册一个唯一名称。当使用这个唯一名称时，调用者总是确定引用的是预期的密钥实现。

可用的密钥列表在/proc/crypto中给出。然而，该列表并没有指定所有可能的模板和密钥组合。/proc/crypto中列出的每个块可能包含以下信息——如果下列列出的组件之一不适用于某个密钥，则不会显示：

- 名称：密钥的通用名称，受基于优先级的选择的影响——此名称可用于密钥分配API调用（上面列出的所有名称都是此类通用名称的例子）

- 驱动：密钥的唯一名称——此名称可用于密钥分配API调用

- 模块：提供密钥实现的内核模块（或对于静态链接的密钥为“kernel”）

- 优先级：密钥实现的优先级值

- 引用计数：相应密钥的引用计数（即当前使用此密钥的消费者数量）

- 自检：指定密钥的自检是否通过

- 类型：

  - skcipher 对于对称密钥密钥

  - cipher 对于可与其他模板一起使用的单块密钥

  - shash 同步消息摘要

  - ahash 异步消息摘要

  - aead AEAD密钥类型

  - 压缩 压缩类型转换

  - rng 随机数生成器

  - kpp 密钥协议原语(KPP)密钥，如ECDH或DH实现

- 块大小：密钥的块大小（以字节为单位）

- 密钥大小：密钥大小（以字节为单位）

- IV大小：初始化向量大小（以字节为单位）

- 种子大小：随机数生成器所需的种子数据大小

- 摘要大小：消息摘要的输出大小

- 生成IV：IV生成器（过时）

### 密钥大小

在分配密钥句柄时，调用者仅指定密钥类型。然而，对称密钥通常支持多种密钥大小（例如AES-128与AES-192与AES-256）。这些密钥大小由提供的密钥长度决定。因此，内核加密API没有提供单独的方式来选择特定的对称密钥大小。

### 密钥分配类型和掩码

不同的密钥句柄分配函数允许指定类型和掩码标志。这两个参数具有以下含义（因此不在后续部分中涵盖）。
类型标志指定了密钥算法的类型。调用者通常提供0作为参数，如果调用者想要默认处理。
否则，调用者可以提供以下选项，这些选项匹配前面提到的密钥类型：

-  CRYPTO_ALG_TYPE_CIPHER 单块密钥

-  CRYPTO_ALG_TYPE_COMPRESS 压缩

-  CRYPTO_ALG_TYPE_AEAD 带相关数据的身份验证加密(MAC)

-  CRYPTO_ALG_TYPE_KPP 密钥协议原语(KPP)，如ECDH或DH实现

-  CRYPTO_ALG_TYPE_HASH 原始消息摘要

-  CRYPTO_ALG_TYPE_SHASH 同步多块哈希

-  CRYPTO_ALG_TYPE_AHASH 异步多块哈希

-  CRYPTO_ALG_TYPE_RNG 随机数生成

-  CRYPTO_ALG_TYPE_AKCIPHER 非对称密钥

-  CRYPTO_ALG_TYPE_PCOMPRESS 增强版的CRYPTO_ALG_TYPE_COMPRESS，允许分段压缩/解压缩而不是仅在一个片段上执行操作。CRYPTO_ALG_TYPE_PCOMPRESS旨在取代CRYPTO_ALG_TYPE_COMPRESS，一旦现有消费者被转换。

掩码标志限制了密钥的类型。唯一允许的标志是CRYPTO_ALG_ASYNC，用于将密钥查找函数限制为异步密钥。通常，调用者为掩码标志提供0。
当调用者提供了掩码和类型规范时，调用者限制了内核加密API可以为给定的密钥名称搜索合适的密钥实现的能力。这意味着即使调用者在初始化调用中使用了一个存在的密钥名称，内核加密API也可能不会选择它，这是由于所使用的类型和掩码字段。

### 内核加密API的内部结构

内核加密API具有内部结构，其中密钥实现可能会使用许多层和间接方式。本节旨在帮助理解内核加密API如何使用各种组件来实现完整的密钥。
以下小节根据现有密码实现解释了内部结构。首先讨论的是最复杂的情况，其他所有情况都是其逻辑子集：通用AEAD密码结构。

~~~  
通用AEAD密码结构
~~~

以下ASCII艺术图展示了使用带有自动IV生成的AEAD密码时内核密码API层的分解。所展示的例子被IPSEC层使用。
对于AEAD密码的其他用途，此ASCII艺术图同样适用，但是调用者可能不会使用带有单独IV生成器的AEAD密码。在这种情况下，调用者必须自行生成IV。
所示的例子基于GCM(AES)的AEAD密码，并依据通用C实现（gcm.c、aes-generic.c、ctr.c、ghash-generic.c、seqiv.c）进行分解。这些通用实现作为一个例子，展示了内核密码API的完整逻辑。
某些优化过的密码实现（如AES-NI）可能会将一些方面合并在一起，在内核密码API看来这些方面无法进一步分解为层次结构。例如在AES-NI实现中，CTR模式、GHASH实现和AES密码都被合并到一个注册到内核密码API的密码实现中。在这种情况下，下面的ASCII艺术图描述的概念仍然适用，但内核密码API不再将GCM分解为各个子组件。
下图中的每个块代表从内核密码API获取的一个独立密码实例。每个块通过内核密码API为该类型密码实现定义的API函数被调用者或其他块访问。
下图中的块指示了密码类型以及该密码实现的具体逻辑。
ASCII艺术图还表示了调用结构，即谁调用了哪个组件。箭头指向被调用的块，其中调用者使用适用于该块指定密码类型的API。
::

    内核密码API                                |   IPSEC层
                                                   |
    +-----------+                                    |
    |           |            (1)
    |   AEAD    | <-----------------------------------  esp_output
    |  (SEQIV)  | ---+
    +-----------+    |
                                                   | (2)
    +-----------+    |
    |           | <--+                (2)
    |   AEAD    | <-----------------------------------  esp_input
    |   (GCM)   | ------------+
    +-----------+             |
          | (3)               | (5)
          v                   v
    +-----------+       +-----------+
    |           |       |           |
    |  SCIPHER  |       |   AHASH   |
    |   (CTR)   | ---+  |  (GHASH)  |
    +-----------+    |  +-----------+
                                                   |
    +-----------+    | (4)
    |           | <--+
    |   CIPHER  |
    |   (AES)   |
    +-----------+

当IPSEC层通过esp_output函数触发加密操作时，以下的调用序列适用。在配置过程中，管理员设置了使用seqiv(rfc4106(gcm(aes)))作为ESP的密码。现在，如下图所示的调用序列为：

1. esp_output()调用crypto_aead_encrypt()以触发带有IV生成器的AEAD密码的加密操作。
SEQIV生成IV。
2. 现在，SEQIV 使用 AEAD API 函数调用来调用相关的 AEAD 加密算法。在我们的案例中，在 SEQIV 初始化时，提供了 GCM 的加密句柄给 SEQIV。这意味着 SEQIV 会使用 GCM 的加密句柄来调用 AEAD 加密操作。
在初始化 GCM 句柄时，同时初始化了 CTR(AES) 和 GHASH 加密算法。CTR(AES) 和 GHASH 的加密句柄会被保留以供后续使用。
GCM 实现负责以正确的方式调用 CTR 模式的 AES 和 GHASH 加密算法，以实现 GCM 规范的要求。
3. GCM AEAD 加密类型实现现在使用已初始化的 CTR(AES) 加密句柄来调用 SKCIPHER API。
在初始化 CTR(AES) 加密算法时，AES 的 CIPHER 类型实现也被初始化。AES 的加密句柄被保留下来。
这意味着 CTR(AES) 的 SKCIPHER 实现仅实现了 CTR 块链模式。执行块链操作后，会调用 AES 的 CIPHER 实现。
4. CTR(AES) 的 SKCIPHER 现在通过 AES 加密句柄调用 CIPHER API 来加密一个块。
5. GCM AEAD 实现还通过 AHASH API 调用 GHASH 加密实现。
当 IPSEC 层触发 esp_input() 函数时，遵循相同的调用序列，唯一的区别是操作从步骤 (2) 开始。
通用块加密结构
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

通用块加密遵循上图所示的 ASCII 图像所描绘的概念。
例如，CBC(AES)是通过`cbc.c`和`aes-generic.c`实现的。上述ASCII艺术图同样适用，不同之处在于仅使用步骤(4)，且SKCIPHER块链模式为CBC。
### 泛型密钥消息摘要结构
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

密钥消息摘要的实现遵循与上述ASCII艺术图所示相同的概念。
例如，HMAC(SHA256)是通过`hmac.c`和`sha256_generic.c`实现的。下面的ASCII艺术图展示了其实现：

:::


    内核加密API            |       调用者
                                 |
    +-----------+         (1)    |
    |           | <------------------  某个函数
    |   ahash   |
    |   (hmac)  | ---+
    +-----------+    |
                     | (2)
    +-----------+    |
    |           | <--+
    |   shash   |
    |  (sha256) |
    +-----------+



当调用方触发一个HMAC操作时，会应用以下调用序列：

1. 调用方调用了AHASH API函数。HMAC实现按需执行其操作。
在初始化HMAC密码时，实例化了SHA256的SHASH密码类型。保留SHA256实例的密码句柄。
在某一时刻，HMAC实现需要进行SHA256操作，此时使用SHA256密码句柄。
2. 现在HMAC实例通过SHA256密码句柄调用SHASH API来计算消息摘要。
