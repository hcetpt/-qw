SPDX 许可证标识符: GPL-2.0
.. include:: <isonum.txt>

===========================================
快速且可移植的 DES 加密与解密
===========================================

.. note::

   下面是从 descore.shar 包中转换为 ReST 格式的原始 README 文件
   --------------------------------------------------------------------------------

des — 快速且可移植的 DES 加密与解密
版权所有 |copy| 1992  Dana L. How

本程序是自由软件；您可以根据由自由软件基金会发布的 GNU 库通用公共许可证的条款重新发布和/或修改它；
无论是许可证的第 2 版，还是（按您的选择）任何后续版本。
本程序是希望对用户有所帮助而分发的，
但没有任何保证——甚至没有关于适销性或适合特定目的的默示保证。有关详情请参阅 GNU 库通用公共许可证。
您应该已经随同本程序收到了一份 GNU 库通用公共许可证的副本；如果没有，请写信给自由软件基金会，Inc.，
地址：675 Mass Ave, Cambridge, MA 02139, USA
作者地址: how@isl.stanford.edu

.. README,v 1.15 1992/05/20 00:25:32 how E

==>> 解压或解开后进行编译，只需运行 `make` <<==

本包的设计目标如下：

1. 最高的加密/解密 性能
2. 可移植到任何具有 32 位无符号 C 类型的字节可寻址主机
3. 作为 KERBEROS 的低级例程的插件兼容替代品
第二次发布包含了许多针对寄存器资源匮乏机器的性能改进。
我与 Richard Outerbridge (71755.204@compuserve.com) 的讨论启发了这些改进。
为了更快地理解本包中的代码，请先检查 desSmallFips.i （通过输入 `make` 创建）
然后再着手处理 desCode.h。后者以参数化的方式设置，
以便易于被追求最后一微秒速度的黑客修改。您可能会发现查看一个具体的实现更为有益，
然后带着这个实现去理解通用的抽象骨架。

在 SPARCStation 1 上（cc -O4, gcc -O2 编译）与其他可用的 DES 代码相比，此代码的性能如下：

此代码（字节顺序独立）:

  - 每次加密 30 微秒（选项: 64k 表格，不使用 IP/FP）
  - 每次加密 33 微秒（选项: 64k 表格，FIPS 标准位顺序）
  - 每次加密 45 微秒（选项: 2k 表格，不使用 IP/FP）
  - 每次加密 48 微秒（选项: 2k 表格，FIPS 标准位顺序）
  - 设置新密钥需要 275 微秒（使用 1k 密钥表格）

这是我见过的最快的加密/解密例程。
由于我对快速 DES 过滤器而非 crypt(3) 和密码破解更感兴趣，所以我还没有真正去优化密钥设置程序。此外，我对重新实现 MIT Kerberos DES 库中的其他冗余功能没有兴趣，因此我只是为我的程序提供了小型的接口，以便它们可以作为 MIT 代码或以下任何与 MIT 兼容包的直接替代品。（请注意，上面的前两个计时结果因缓存效应而有很大变化。）
来自澳大利亚的 Kerberos DES 替代方案（版本 1.95）：

  - 每次加密耗时 53 微秒（使用 2K 的表格）
  - 设置新密钥耗时 96 微秒（使用 2.25K 的密钥表格）

尽管作者采纳了我建议的一些性能改进，但此包在 Sparc 和 68000 上的加密/解密速度仍然较慢；具体而言，在 68020 上慢 19%-40%，在 Sparc 上慢 11%-35%，这取决于编译器；详细情况如下（ALT_ECB 是一个 libdes 变体）：

===============	==============	===============	=================
编译器   	机器		desCore		libdes	ALT_ECB	慢了多少
===============	==============	===============	=================
gcc 2.1 -O2	Sun 3/110	304  μs	369.5μs	461.8μs	 22%
cc      -O1	Sun 3/110	336  μs	436.6μs	399.3μs	 19%
cc      -O2	Sun 3/110	360  μs	532.4μs	505.1μs	 40%
cc      -O4	Sun 3/110	365  μs	532.3μs	505.3μs	 38%
gcc 2.1 -O2	Sun 4/50	 48  μs	 53.4μs	 57.5μs	 11%
cc      -O2	Sun 4/50	 48  μs	 64.6μs	 64.7μs	 35%
cc      -O4	Sun 4/50	 48  μs	 64.7μs	 64.9μs	 35%
===============	==============	===============	=================

（我的时间测量不如他那么精确）
我在发布 1.92 版本的 desCore 时的注释：

   - 每次加密耗时 68 微秒（使用 2K 的表格）
   - 设置新密钥耗时 96 微秒（使用 2.25K 的密钥表格）

这是一个非常好的包，实现了我在加密程序中最重要的优化。
它在一些常见的低级优化方面稍显不足，因此它慢了 39%-106%。因为他对快速 crypt(3) 和密码破解应用感兴趣，他还利用相同的想法来加速密钥设置程序并取得了令人印象深刻的效果（在某个时候，我可能会在我的包中也这样做）。他还实现了 MIT DES 库的其余部分
（代码来自 eay@psych.psy.uq.oz.au 经由 comp.sources.misc）

来自丹麦的快速 crypt(3) 包：

此处的 DES 程序被嵌入到执行 crypt 函数的循环中，我没有觉得有必要将其拆出来进行性能测量。他的代码计算一次 DES 迭代需要 26 条 Sparc 指令；上述 Quick（64K）需要 21 条指令，Small（2K）则需要 37 条指令
他声称使用了 280K 的表格，但迭代计算似乎只使用了 128K。他的表格和代码是机器独立的
（代码来自 glad@daimi.aau.dk 经由 alt.sources 或 comp.sources.misc）

瑞典重新实现的 Kerberos DES 库

  - 每次加密耗时 108 微秒（使用相当于 34K 的表格）
  - 设置新密钥耗时 134 微秒（使用 32K 的密钥表格以达到这个速度！）

所使用的表格似乎是机器独立的；
他似乎包含了许多特殊情况代码，例如，在机器架构允许的情况下，可以用“long”加载代替 4 个“char”加载
（从 chalmers.se:pub/des 获取的代码）

来自英格兰的 crack 3.3c 包：

与上述 crypt 类似，DES 程序被埋在一个循环中。它也被大量修改用于 crypt。他的迭代代码使用了 16K 的表格，并且看起来运行速度较慢。
通过alt.sources或comp.sources.misc从aem@aber.ac.uk获得的优化程度高且微调过的Kerberos/Athena代码（字节顺序依赖）：

- 加密每执行一次需要165微秒（使用了6千字节的表）
- 设置新密钥需要478微秒（使用了不到1千字节的密钥表）

尽管此代码中的注释表明，可能同时实现了更快的代码和更小的表，并使表格与机器无关。

从prep.ai.mit.edu获得的加州大学伯克利分校代码（依赖于机器的末尾性）：
- 每次加密需要226微秒
- 设置新密钥需要10848微秒

表格大小不清楚，但看起来并不很小。

动机与历史
-----------

很久以前，我想要一些DES函数，而SUN的手册中所描述的函数要么不存在，要么会导致程序崩溃。我知道Kerberos使用了DES，因此我决定使用其函数。但是，当我获取并查看代码时，这触发了很多我的恼火点：代码过于复杂，编写时没有利用操作如IP、E和FP的规律结构，作者在编码前没有坐下来思考；代码运行缓慢，作者试图通过添加更多语句来使数据移动更“一致”，而不是简化实现并减少所有数据移动（特别是他对L1、R1、L2、R2的使用），并且充斥着特定机器上的愚蠢“微调”，这些微调并未带来显著的速度提升，但却使代码变得混淆不清。我使用了他的验证程序的数据，并在一段时间后重写了其他一切。后来，我偶然遇到了上面提到的出色的crypt(3)包。他计算每次查找表时使用两个S盒子而不是一个，并使用了一个更大的表，这使我有勇气也这样做。他没有意识到你不需要将工作数据以两种形式保持，一种用于容易使用一半的S盒子进行索引，另一种用于容易使用另一半；相反，你可以保持为前半部分的形式，并使用简单的旋转来获取另一半。这意味着我（几乎）减少了数据操作的一半和一半的表大小。就公平而言，他可能在他的表中编码了一些特定于crypt(3)的东西 - 我没有检查。我很高兴我以这种方式实现了它，因为这个C版本是可移植的（ifdefs是性能增强），它比手工编写的sparc汇编语言版本更快！

移植注意事项
--------------

我不想做的第一件事就是编写一个庞大的混乱代码，依赖于字节顺序和其他机器特性，以及不同机器产生不同代码和不同查找表。请参阅Kerberos代码，了解我所不希望做的事情；他们所有的特定于机器的“优化”使代码变得混淆不清，并最终比更简单、基于机器的独立方法慢。然而，总是有一些某种类型的可移植性考虑，我已经包括了一些针对不同寄存器变量数量的不同选项。也许有些人仍然会认为结果是一个混乱！
1）我假设一切都是字节对齐的，虽然我实际上并不依赖字节顺序，并且字节是8位。我假设可以自由地将字节指针转换为char指针。请注意，99%的C程序都做出了这样的假设。如果高位可能会被设置，我总是使用unsigned char。
2）typedef "word"表示32位无符号整型类型。
如果`unsigned long`不是32位，请更改desCore.h中的typedef。我假设`word`的大小始终为4。如果不针对端性进行优化，我在密钥迭代周围的数据加载和存储代码中所付出的成本最多只有12%。此外，还有一个额外的好处是输入和输出的工作区不需要对齐到字边界。

可选性能优化
--------------

1. 您应该定义一个与您机器能力最接近的选项，例如`i386`, `vax`, `mc68000`或`sparc`。查看desCode.h的开头以了解此选择意味着什么。请注意，如果您选择了错误的选项，DES代码仍然可以运行；这只是性能微调。
   
2. 对于具有功能性的`asm`关键字的用户：如果您的机器有旋转指令，您应该将ROR和ROL宏更改为使用这些机器旋转指令。这将节省每用2条指令和一个临时变量，相当于每加密/解密操作节省大约32到40条指令。请注意，gcc足够智能，可以直接将ROL/R宏转换为机器旋转！

所有这些优化都相当挑剔，但是有了它们，您可以获得与汇编编码相当的性能，除了：

1. 缺少C语言中的位旋转运算符，因此需要通过位移来合成旋转。因此，如果您的机器具有旋转（如上文第3点所述），使用`asm`可以加快速度。如果不是使用gcc，则不一定需要此功能。
   
2. 如果您的机器的32位寄存器少于12个，我怀疑您的编译器可能无法生成良好的代码。
``i386``试图仅通过声明3个寄存器来为386配置代码（看起来gcc可以使用ebx、esi和edi来保存寄存器变量）。然而，如果你喜欢汇编编程，386确实有7个32位寄存器，并且如果你使用全部这些寄存器，使用带有偏移的“按8缩放”地址模式和其他技巧，你可以为DesQuickCore...编写大约每段250条指令的合理例程。对于DesSmall...，重新排列des_keymap会有帮助，也就是说，现在S盒编号是索引的高位部分，而6位数据是低位部分；交换这些会有帮助。
因为我没有方便的方法来测试它，所以我没有提供我硬塞进去的386版本。请注意，在这个版本的desCore中，gcc能够将所有内容放入寄存器中（！），并且为DesQuickCore...的例程生成每段约370条指令！

编码说明
=========

加密和解密例程各自使用6个必需的寄存器变量，在内部迭代过程中同时使用4个活动寄存器变量。如果你没有4个寄存器变量，请获取新机器。在某些配置中，最多使用额外8个寄存器来保存常量。我假设使用常量比使用寄存器更昂贵：

a) 此外，我尝试将较大的常量放入寄存器中。寄存器分配优先级如下：

    - 大于12位的任何值（对RISC和CISC都不利）
    - 值大于127（不能在CISC上使用movq或字节立即数）
    - 9-127（可能无法使用CISC移位立即数或快速加/减）
    - 1-8从未被寄存，因为它们是最便宜的常量
b) 编译器可能过于愚蠢，无法意识到table和table+256应该分配给不同的常量寄存器，而是反复进行算术运算，因此如果可能且有用的话，我将这些分配给显式的“m”寄存器变量
我假设索引比自动递增/递减更便宜或等效，其中索引为7位无符号或更小。
对于68k和VAX，这一假设是相反的。
我假设地址可以从两个寄存器廉价地形成，
或者从一个寄存器和一个小常数形成
对于68000，"两个寄存器和小偏移"的形式被很少使用
所有的索引缩放都是显式完成的 —— 没有隐含的通过log2(sizeof)进行的移位
代码编写的方式使得即使是笨拙的编译器
也不应该需要多于一个隐式的临时变量，
这样增加了所有内容都能放入寄存器的可能性
如果你重写任何东西，请记住这个更为微妙的要点
（实际上，现在有一些代码片段确实需要两个临时变量，
但修复它要么会破坏宏的结构，要么
需要声明另一个临时变量）
特殊高效的数据格式
==============================

大多数时候以这种方式操作比特（S7 S5 S3 S1）：

	003130292827xxxx242322212019xxxx161514131211xxxx080706050403xxxx

（x比特仍然在那里，我只是强调S盒的位置）
在计算S6 S4 S2 S0时将比特向左旋转4位：

	282726252423xxxx201918171615xxxx121110090807xxxx040302010031xxxx

最右边的两位通常被清零以便低位字节可以用作S盒映射表的索引。接下来的两个被标记为x的比特被设置为不同的值以访问表的不同部分
如何使用这些例程

数据类型：
	指向8字节DesData类型的区域的指针
	用于保存密钥和DES的输入/输出块
指向128字节DesKeys类型的区域的指针
	用于保存完整的768位密钥
必须是长整型对齐的。

`DesQuickInit()`
在使用任何其他名称中带有“Quick”的函数之前调用此函数。
它会生成这些函数所需的特殊64K表格。

`DesQuickDone()`
释放这个表格。

`DesMethod(m, k)`
m指向一个128字节的数据块，k指向一个8字节的DES密钥，
该密钥必须具有奇数校验位（否则返回-1），并且不能是(半)弱密钥（否则返回-2）。
通常情况下`DesMethod()`返回0。
从k填充m，使得当下面的任何一个函数被调用时传入m，
该函数将像标准的DES加密/解密一样运行，使用密钥k。如果你使用`DesMethod`，
你提供的是一个标准的56位密钥；然而，如果你自己填充m，
你将会得到一个768位的密钥——但这将不再是标准格式。之所以是768位而不是1024位是因为每个字节的最低两位不被使用。
需要注意的是，这两个位将被设置为一些魔法常数，这在某些机器上可以加快加密/解密的速度。
而且是的，每个字节控制着特定迭代中的特定S盒。
你不应该直接使用768位格式；我应该
提供一个函数来将128个6位字节（按照S盒映射顺序指定或类似方式）转换为你需要的正确格式。
这将涉及到一些字节拼接和旋转操作。

`Des{Small|Quick}{Fips|Core}{Encrypt|Decrypt}(d, m, s)`
对位于`s`(d,s: char *)处的8字节执行DES加密/解密，并将结果存放在`d`处的8字节中。
使用上面解释的作为768位密钥的m。
加密|解密的选择是显而易见的。
Fips|Core 确定是否执行完全标准的 FIPS 初始和最终置换；如果不执行，则数据将以非标准的位顺序加载和存储（FIPS 无 IP/FP）
使用 Fips 会使 Quick 模式速度降低 10%，Small 模式降低 9%。
Small|Quick 确定你是使用常规程序还是使用疯狂的快速模式，后者会额外占用 64K 的内存。
Small 模式比 Quick 模式慢 50%，但 Quick 模式需要的内存是 Small 模式的 32 倍。Quick 模式适用于仅执行 DES 加密的程序，例如加密过滤器等。

在你的机器上编译
==================

代码中没有与机器相关的依赖性（参见移植部分），除了可能存在的 desTest.c 中的 ``now()`` 宏。
所有生成的表都是与机器无关的。
你应该编辑 Makefile 文件，并添加适合你编译器的优化标志（最大优化）。

加快 Kerberos（及其 DES 库）的速度
====================================

请注意，我已经在 desUtil.c 中包含了与 Kerberos 兼容的接口，通过函数 des_key_sched() 和 des_ecb_encrypt() 实现。
要在 Kerberos 或与其兼容的代码中使用这些函数，请确保在链接器命令行中将 desCore.a 放在与 Kerberos 兼容的库之前。
你不需要包含 `desCore.h`；只需包含与 Kerberos 库一起提供的头文件。
其他用途
========

`desCode.h` 中的宏对于在更复杂的加密程序中内联 DES 函数非常有用。
