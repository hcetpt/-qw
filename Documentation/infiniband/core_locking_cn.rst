InfiniBand 中间层锁定
===========================

本指南旨在明确阐述 InfiniBand 中间层所做的锁定假设。它描述了位于中间层之下的低级驱动程序和使用中间层的上层协议的要求。
睡眠与中断上下文
==============================

除了以下例外，所有在 `struct ib_device` 中的方法的低级驱动程序实现都可以睡眠。例外是以下列表中的任何方法：

    - create_ah
    - modify_ah
    - query_ah
    - destroy_ah
    - post_send
    - post_recv
    - poll_cq
    - req_notify_cq

这些方法不得睡眠，并且必须能够从任何上下文调用。
因此，向高层协议消费者导出的相应函数：

    - rdma_create_ah
    - rdma_modify_ah
    - rdma_query_ah
    - rdma_destroy_ah
    - ib_post_send
    - ib_post_recv
    - ib_req_notify_cq

可以安全地从任何上下文调用。
此外，用于通过中间层分发异步事件的低级驱动程序函数：

    - ib_dispatch_event

同样可以从任何上下文安全调用。
可重入性
----------

由低级驱动程序导出的所有 `struct ib_device` 方法必须完全可重入。低级驱动程序需要执行所有必要的同步以维持一致性，即使使用同一对象的多个函数调用同时运行。
IB 中间层不会对函数调用进行任何序列化。
因为低级驱动程序是可重入的，所以不需要上层协议消费者执行任何序列化。然而，在某些情况下可能需要一些序列化才能获得合理的结果。例如，消费者可以在多个CPU上同时安全地调用 `ib_poll_cq()` 。然而，不同 `ib_poll_cq()` 调用之间的完成工作信息的顺序未定义。
回调
---------

低级驱动程序不得直接从 `ib_device` 方法调用的相同调用链中执行回调。例如，不允许低级驱动程序直接从其 `post_send` 方法调用消费者的完成事件处理器。相反，低级驱动程序应通过调度一个tasklet来延迟此回调，以执行回调。
低级驱动程序负责确保对于同一CQ的多个完成事件处理器不会同时被调用。驱动程序必须保证任何时候只有一个给定CQ的CQ事件处理器正在运行。换句话说，以下情况是不允许的：

          CPU1                                    CPU2

    低级驱动程序 ->
      消费者CQ事件回调：
        /* ... */
        ib_req_notify_cq(cq, ...);
                                          低级驱动程序 ->
        /* ... */                           消费者CQ事件回调：
                                              /* ... */
        从CQ事件处理器返回

完成事件和异步事件回调运行的上下文未定义。根据低级驱动程序，可能是进程上下文、软中断上下文或中断上下文。
上层协议消费者在回调中不得睡眠。
热插拔（Hot-plug）

当一个低级驱动程序调用`ib_register_device()`时，它会向消费者宣布设备已准备好使用。在调用此函数之前，所有的初始化工作必须完成。设备必须保持可用状态，直到驱动程序的`ib_unregister_device()`调用返回。

一个低级驱动程序必须从进程上下文调用`ib_register_device()`和`ib_unregister_device()`。它不应持有任何可能因消费者在这两个调用之间回调到驱动程序而导致死锁的信号量。

上层协议消费者可以在其struct ib_client的add方法被调用于该设备后立即开始使用IB设备。消费者必须在其remove方法返回前完成所有清理工作并释放与设备相关的所有资源。

允许消费者在其add和remove方法中进行睡眠操作。

热插拔特性描述了InfiniBand (IB) 设备的注册、使用和注销过程。驱动程序需要正确地通知系统设备的状态变化，而上层协议消费者则需根据设备状态适时地使用或停止使用设备。在此过程中，为了防止死锁，驱动程序在注册和注销设备时不能持有特定类型的锁。同时，上层协议消费者在处理设备的添加和移除时，可以执行阻塞操作（如睡眠）。
