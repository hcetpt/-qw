===========================
InfiniBand 中间层锁定
===========================

  本指南试图明确说明 InfiniBand 中间层所做的锁定假设。它描述了位于中间层之下的低级驱动程序以及使用中间层的上层协议的要求。
睡眠和中断上下文
==============================

  除了以下例外情况，所有在 `struct ib_device` 中定义的方法的低级驱动程序实现都可以进入睡眠状态。不允许进入睡眠状态并且必须能够在任何上下文中调用的方法包括：

    - create_ah
    - modify_ah
    - query_ah
    - destroy_ah
    - post_send
    - post_recv
    - poll_cq
    - req_notify_cq

  因此，对于上层协议消费者所使用的相应函数：

    - rdma_create_ah
    - rdma_modify_ah
    - rdma_query_ah
    - rdma_destroy_ah
    - ib_post_send
    - ib_post_recv
    - ib_req_notify_cq

  它们因此可以从任何上下文中安全地调用。
此外，用于由低级驱动程序通过中间层分发异步事件的函数

    - ib_dispatch_event

  也可以从任何上下文中安全调用。
可重入性
----------

  由低级驱动程序导出的所有 `struct ib_device` 中的方法都必须是完全可重入的。低级驱动程序需要执行所有必要的同步操作以保持一致性，即使多个使用相同对象的函数调用同时运行也是如此。
InfiniBand 中间层不执行任何函数调用的序列化操作。
由于低级驱动程序是可重入的，上层协议消费者不需要执行任何序列化。然而，在某些情况下可能需要进行一些序列化以获得合理的结果。例如，消费者可以在多个CPU上同时安全地调用 `ib_poll_cq()`。但是，不同 `ib_poll_cq()` 调用之间的完成工作信息的顺序是未定义的。
回调
---------

  低级驱动程序不得直接在同一调用链中从 `ib_device` 方法调用执行回调。例如，不允许低级驱动程序直接从其 `post_send` 方法调用消费者的完成事件处理器。相反，低级驱动程序应通过调度一个任务来延迟该回调。
低级驱动程序负责确保对同一完成队列 (CQ) 的多个完成事件处理器不会同时被调用。驱动程序必须保证给定 CQ 的仅有一个事件处理器正在运行。换句话说，以下情况是不允许的：

          CPU1                                    CPU2

    低级驱动程序 ->
      消费者 CQ 事件回调:
        /* ... */
        ib_req_notify_cq(cq, ...);
                                          低级驱动程序 ->
        /* ... */                           消费者 CQ 事件回调:
                                              /* ... */
        退出 CQ 事件处理器

  完成事件和异步事件回调运行的上下文是未定义的。根据不同的低级驱动程序，它可能是进程上下文、软中断上下文或中断上下文。
上层协议消费者在回调中不得进入睡眠状态。
热插拔

一个低级别驱动通过调用 `ib_register_device()` 来宣布设备已准备好供使用者使用，在这次调用之前必须完成所有初始化。该设备必须保持可用状态，直到驱动程序的 `ib_unregister_device()` 调用返回。

一个低级别驱动必须在进程上下文中调用 `ib_register_device()` 和 `ib_unregister_device()`。它不应该持有任何可能导致死锁的信号量，如果使用者在这次调用期间回调到驱动中。

上层协议使用者可以在其 `struct ib_client` 的添加方法为该设备调用时开始使用 IB 设备。使用者必须在其移除方法返回前完成所有清理工作并释放与该设备相关的所有资源。

允许使用者在其添加和移除方法中睡眠。
