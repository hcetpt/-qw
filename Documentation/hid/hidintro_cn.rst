SPDX 许可证标识符: GPL-2.0

======================================
HID报告描述符简介
======================================

本章旨在全面介绍HID报告描述符是什么，以及非内核程序员如何处理与Linux兼容性不佳的HID设备。
.. contents::
    :local:
    :depth: 2

.. toctree::
   :maxdepth: 2

   hidreport-parsing


引言
============

HID代表人机接口设备，它可以是任何用于与计算机交互的设备，例如鼠标、触摸板、平板电脑或麦克风等。
许多HID设备可以即插即用，即使它们的硬件各不相同。
例如，鼠标可以有任意数量的按钮；可能带有滚轮；不同型号之间的移动灵敏度也有所不同。然而，在大多数情况下，一切都可以正常工作，并不需要为自1970年以来开发的每一款鼠标模型编写专门的内核代码。
这是因为现代HID设备会通过*HID报告描述符*来宣传其功能，这是一组固定的字节，精确地描述了设备和主机之间可以发送哪些*HID报告*，以及这些报告中每个单独位的意义。例如，一个HID报告描述符可能会指定“在ID为3的报告中，第8到15位表示鼠标的X坐标增量”。
HID报告本身只携带实际的数据值，没有任何额外的元信息。需要注意的是，HID报告可以从设备发送（“输入报告”，即输入事件），向设备发送（“输出报告”，例如改变LED状态），或者用于设备配置（“特性报告”）。设备可能支持一种或多种HID报告。
HID子系统负责解析HID报告描述符，并将HID事件转换为标准输入设备接口（参见Documentation/hid/hid-transport.rst）。设备可能出现问题是因为提供的HID报告描述符有误，或者需要以特殊方式处理，或者某些特殊设备或交互模式没有被默认代码所处理。
HID报告描述符的格式由两个文档定义，这两个文档可以从`USB Implementers Forum <https://www.usb.org/>`_ 的 `HID网页 <https://www.usb.org/hid>`_ 获取：

 * `HID USB设备类定义 <https://www.usb.org/document-library/device-class-definition-hid-111>`_（以下称为HID规范）
 * `HID用途表 <https://usb.org/document-library/hid-usage-tables-14>`_ （以下称为HUT）

HID子系统可以处理不同的传输驱动（USB、I2C、蓝牙等）。更多信息请参阅Documentation/hid/hid-transport.rst。

解析HID报告描述符
==============================

当前HID设备列表可以在``/sys/bus/hid/devices/``找到。
对于每个设备，例如``/sys/bus/hid/devices/0003\:093A\:2510.0002/``，可以读取相应的报告描述符：

  $ hexdump -C /sys/bus/hid/devices/0003\:093A\:2510.0002/report_descriptor
  00000000  05 01 09 02 a1 01 09 01  a1 00 05 09 19 01 29 03  |..............).|
  00000010  15 00 25 01 75 01 95 03  81 02 75 05 95 01 81 01  |..%.u.....u.....|
  00000020  05 01 09 30 09 31 09 38  15 81 25 7f 75 08 95 03  |...0.1.8..%.u...|
  00000030  81 06 c0 c0                                       |....|
  00000034

可选：也可以通过直接访问hidraw驱动程序来读取HID报告描述符 [#hidraw]_。
HID报告描述符的基本结构在HID规范中定义，而HUT“定义了可以被应用程序解释的常量，以识别HID报告中数据字段的目的和含义”。每个条目至少由两个字节定义，其中第一个字节定义了接下来是什么类型的值，并在HID规范中有描述；而第二个字节携带实际的值，并在HUT中有描述。
原则上，HID报告描述符可以通过逐字节的方式手动解析，关于如何做到这一点，在文档`Documentation/hid/hidreport-parsing.rst`中有一个简短的介绍；你只需要理解它，如果你需要修改HID报告描述符的话。
实际上你不应该手动解析HID报告描述符；相反，你应该使用现有的解析器。在所有可用的解析器中，

  * 在线的`USB Descriptor and Request Parser
    <http://eleccelerator.com/usbdescreqparser/>`_;
  * `hidrdd <https://github.com/abend0c1/hidrdd>`_，
    它提供了非常详细且稍微冗长的描述
    （冗长可能在你不熟悉HID报告描述符时有用）；
  * `hid-tools <https://gitlab.freedesktop.org/libevdev/hid-tools>`_，
    这是一套完整的工具集，允许记录和重放原始HID报告以及调试和重放HID设备。
    它正由Linux HID子系统的维护者积极开发。

使用`hid-tools <https://gitlab.freedesktop.org/libevdev/hid-tools>`_解析鼠标HID报告描述符得到（解释穿插）如下：

```bash
$ ./hid-decode /sys/bus/hid/devices/0003\:093A\:2510.0002/report_descriptor
# 设备 0:0
# 0x05, 0x01,		 // 使用页面 (通用桌面)	    0
# 0x09, 0x02,		 // 使用 (鼠标)			    2
# 0xa1, 0x01,		 // 集合 (应用)	    4
# 0x09, 0x01,		 // 使用 (指针)		    	    6
# 0xa1, 0x00,		 // 集合 (物理)  	    	    8
# 0x05, 0x09,		 //	使用页面 (按钮)		   10

接下来是按钮 ::

# 0x19, 0x01,		 //	使用最小值 (1)		   12
# 0x29, 0x03,		 //	使用最大值 (3)		   14

第一个按钮为按钮编号1，最后一个按钮为按钮编号3 ::

# 0x15, 0x00,		 //	逻辑最小值 (0)		   16
# 0x25, 0x01,		 //	逻辑最大值 (1)		   18

每个按钮可以发送从0到1的值
（即它们是二进制按钮） ::

# 0x75, 0x01,		 //	报告大小 (1) 		   20

每个按钮正好用一个比特表示 ::

# 0x95, 0x03,		 //	报告计数 (3)		   22

并且有三个这样的比特（与三个按钮对应） ::

# 0x81, 0x02,		 // 输入 (数据,变,绝对)		   24

它是实际的数据（不是常量填充），代表
单一变量（变），其值是绝对的（不是相对的）；
参见HID规范第6.2.2.5节 "输入、输出和特性项" ::

# 0x75, 0x05,		 //	报告大小 (5) 		   26

五个额外的填充比特，为了达到一个字节 ::

# 0x95, 0x01,		 //	报告计数 (1)		   28

这五个比特只重复一次 ::

# 0x81, 0x01,		 // 输入 (常,阵,绝对)		   30

这些比特取常量（常）值，即可以忽略。 ::

# 0x05, 0x01,		 // 使用页面 (通用桌面)       32
# 0x09, 0x30,		 // 使用 (X)			   34
# 0x09, 0x31,		 // 使用 (Y)			   36
# 0x09, 0x38,		 // 使用 (滚轮) 		    	   38

鼠标还有两个物理位置（使用 (X)，使用 (Y)）
和一个滚轮（使用 (滚轮)) ::

# 0x15, 0x81,		 //	逻辑最小值 (-127)  	   40
# 0x25, 0x7f,		 //	逻辑最大值 (127)		   42

它们可以发送从-127到127的值 ::

# 0x75, 0x08,		 //	报告大小 (8) 		   44

通过八个比特来表示 ::

# 0x95, 0x03,		 //	报告计数 (3)		   46

并且有三个这样的八个比特，分别对应X、Y和滚轮。 ::

# 0x81, 0x06,		 // 输入 (数据,变,相对)  	    	   48

这次数据值是相对的（相对），即它们代表
与之前发送的报告（事件）的变化 ::

# 0xc0,			 // 结束集合 		    	   50
# 0xc0,			 // 结束集合  		   51
#
R: 52 05 01 09 02 a1 01 09 01 a1 00 05 09 19 01 29 03 15 00 25 01 75 01 95 03 81 02 75 05 95 01 81 01 05 01 09 30 09 31 09 38 15 81 25 7f 75 08 95 03 81 06 c0 c0
N: 设备 0:0
I: 3 0001 0001


这个报告描述符告诉我们，鼠标输入将使用四个字节传输：第一个字节用于按钮（使用了三个比特，五个用于填充），最后三个字节分别用于鼠标X、Y和滚轮的变化。
事实上，对于任何事件，鼠标都会发送一个四字节的*报告*。
我们可以通过例如使用`hid-recorder`工具（来自`hid-tools <https://gitlab.freedesktop.org/libevdev/hid-tools>`_）来检查发送的值：
点击然后释放按钮1，接着按钮2，最后按钮3时发送的字节序列如下：

```bash
$ sudo ./hid-recorder /dev/hidraw1

...
hid-decode 的输出
...
# 按钮: 1  0  0 | # | X:	 0 | Y:    0 | 滚轮:	 0
  E: 000000.000000 4 01 00 00 00
  # 按钮: 0  0  0 | # | X:	 0 | Y:    0 | 滚轮:	 0
  E: 000000.183949 4 00 00 00 00
  # 按钮: 0  1  0 | # | X:	 0 | Y:    0 | 滚轮:	 0
  E: 000001.959698 4 02 00 00 00
  # 按钮: 0  0  0 | # | X:	 0 | Y:    0 | 滚轮:	 0
  E: 000002.103899 4 00 00 00 00
  # 按钮: 0  0  1 | # | X:	 0 | Y:    0 | 滚轮:	 0
  E: 000004.855799 4 04 00 00 00
  # 按钮: 0  0  0 | # | X:    0 | Y:    0 | 滚轮:    0
  E: 000005.103864 4 00 00 00 00

这个例子显示，当按下按钮2时，
发送的字节是``02 00 00 00``，而紧随其后的
事件（``00 00 00 00``）是释放按钮2（没有按钮被按下，记住数据值是*绝对*的）。
如果相反，先按下并保持按钮 1，然后按下并保持按钮 2，释放按钮 1，最后释放按钮 2，报告如下：

  # 按钮: 1  0  0 | # | X:    0 | Y:    0 | 轮:    0
  E: 000044.175830 4 01 00 00 00
  # 按钮: 1  1  0 | # | X:    0 | Y:    0 | 轮:    0
  E: 000045.975997 4 03 00 00 00
  # 按钮: 0  1  0 | # | X:    0 | Y:    0 | 轮:    0
  E: 000047.407930 4 02 00 00 00
  # 按钮: 0  0  0 | # | X:    0 | Y:    0 | 轮:    0
  E: 000049.199919 4 00 00 00 00

其中 `03 00 00 00` 表示两个按钮都被按下，随后的 `02 00 00 00` 表示按钮 1 已释放而按钮 2 仍然处于活动状态。

输出、输入和特性报告
-----------------------

HID 设备可以有输入报告，就像在鼠标示例中那样，输出报告以及特性报告。“输出”意味着信息被发送到设备。例如，具有力反馈的操纵杆将有一些输出；键盘的LED也需要输出。“输入”意味着数据来自设备。“特性”并不是供最终用户使用的，而是定义了设备的配置选项。它们可以从主机查询；当声明为*易失性*时，应该由主机改变。

集合、报告ID和Evdev事件
======================

单一设备可以在逻辑上将数据分成不同的独立集，称为“集合”。集合可以嵌套，并且有不同的集合类型（参见HID规范 6.2.2.6 “集合，结束集合项”以了解详细信息）。
通过不同的*报告ID*字段来识别不同的报告，即标识接下来报告结构的一个数字。
每当需要报告ID时，它会被作为任何报告的第一个字节传输。仅支持一个HID报告的设备（如上面的鼠标示例）可以省略报告ID。

考虑以下HID报告描述符：

  05 01 09 02 A1 01 85 01 05 09 19 01 29 05 15 00
  25 01 95 05 75 01 81 02 95 01 75 03 81 01 05 01
  09 30 09 31 16 00 F8 26 FF 07 75 0C 95 02 81 06
  09 38 15 80 25 7F 75 08 95 01 81 06 05 0C 0A 38
  02 15 80 25 7F 75 08 95 01 81 06 C0 05 01 09 02
  A1 01 85 02 05 09 19 01 29 05 15 00 25 01 95 05
  75 01 81 02 95 01 75 03 81 01 05 01 09 30 09 31
  16 00 F8 26 FF 07 75 0C 95 02 81 06 09 38 15 80
  25 7F 75 08 95 01 81 06 05 0C 0A 38 02 15 80 25
  7F 75 08 95 01 81 06 C0 05 01 09 07 A1 01 85 05
  05 07 15 00 25 01 09 29 09 3E 09 4B 09 4E 09 E3
  09 E8 09 E8 09 E8 75 01 95 08 81 02 95 00 81 01
  C0 05 0C 09 01 A1 01 85 06 15 00 25 01 75 01 95
  01 09 3F 81 06 09 3F 81 06 09 3F 81 06 09 3F 81
  06 09 3F 81 06 09 3F 81 06 09 3F 81 06 09 3F 81
  06 C0 05 0C 09 01 A1 01 85 03 09 05 15 00 26 FF
  00 75 08 95 02 B1 02 C0

解析之后（尝试使用建议的工具自行解析！），可以看到该设备有两个“鼠标”应用集合（报告分别由报告ID 1和2标识），一个“小键盘”应用集合（其报告由报告ID 5标识），以及两个“消费者控制”应用集合（分别由报告ID 6和3标识）。然而，请注意，设备对于相同的应用集合可以有不同的报告ID。

发送的数据将以报告ID字节开始，并随之是相应的信息。例如，最后一个消费者控制的数据：

  0x05, 0x0C,        // 使用页面 (消费者)
  0x09, 0x01,        // 使用 (消费者控制)
  0xA1, 0x01,        // 集合 (应用)
  0x85, 0x03,        //   报告ID (3)
  0x09, 0x05,        //   使用 (耳机)
  0x15, 0x00,        //   逻辑最小值 (0)
  0x26, 0xFF, 0x00,  //   逻辑最大值 (255)
  0x75, 0x08,        //   报告大小 (8)
  0x95, 0x02,        //   报告计数 (2)
  0xB1, 0x02,        //   特性 (数据,变,绝对,无包裹,线性,首选状态,无零位置,非易失性)
  0xC0,              // 结束集合

将为三个字节：第一个为报告ID（3），接下来两个为耳机，每个有两个字节（`报告计数 (2)`）（`报告大小 (8)`），范围从 0 （`逻辑最小值 (0)`） 到 255 （`逻辑最大值 (255)`）。

设备发送的所有输入数据都应转换为相应的Evdev事件，以便堆栈的其余部分能够知道发生了什么，例如，第一个按钮的位会转换为 `EV_KEY/BTN_LEFT` 的Evdev事件，相对X移动会转换为 `EV_REL/REL_X` 的Evdev事件。
事件
======

在 Linux 中，每个“应用集合(Application Collection)”都会创建一个对应的 ``/dev/input/event*``。回到鼠标示例，重复以下序列：按下并保持左键(按钮1)，然后按下并保持右键(按钮2)，释放左键，最后释放右键，你将看到如下输出：

  $ sudo libinput record /dev/input/event1
  # libinput record
  版本: 1
  设备数: 1
  libinput:
    版本: "1.23.0"
    git: "未知"
  系统:
    操作系统: "opensuse-tumbleweed:20230619"
    内核: "6.3.7-1-default"
    DMI: "dmi:bvnHP:bvrU77Ver.01.05.00:bd03/24/2022:br5.0:efr20.29:svnHP:pnHPEliteBook64514inchG9NotebookPC:pvr:rvnHP:rn89D2:rvrKBCVersion14.1D.00:cvnHP:ct10:cvr:sku5Y3J1EA#ABZ:"
  设备:
  - 节点: /dev/input/event1
    evdev:
      # 名称: PixArt HP USB 光学鼠标
      # ID: 总线 0x3 厂商 0x3f0 产品 0x94a 版本 0x111
      # 支持的事件:
      # 事件类型 0 (EV_SYN)
      # 事件类型 1 (EV_KEY)
      #   事件代码 272 (BTN_LEFT)
      #   事件代码 273 (BTN_RIGHT)
      #   事件代码 274 (BTN_MIDDLE)
      # 事件类型 2 (EV_REL)
      #   事件代码 0 (REL_X)
      #   事件代码 1 (REL_Y)
      #   事件代码 8 (REL_WHEEL)
      #   事件代码 11 (REL_WHEEL_HI_RES)
      # 事件类型 4 (EV_MSC)
      #   事件代码 4 (MSC_SCAN)
      # 属性:
      名称: "PixArt HP USB 光学鼠标"
      ID: [3, 1008, 2378, 273]
      代码:
  	0: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] # EV_SYN
  	1: [272, 273, 274] # EV_KEY
  	2: [0, 1, 8, 11] # EV_REL
  	4: [4] # EV_MSC
      属性: []
    HID: [
      0x05, 0x01, 0x09, 0x02, 0xa1, 0x01, 0x09, 0x01, 0xa1, 0x00, 0x05, 0x09, 0x19, 0x01, 0x29, 0x03,
      0x15, 0x00, 0x25, 0x01, 0x95, 0x08, 0x75, 0x01, 0x81, 0x02, 0x05, 0x01, 0x09, 0x30, 0x09, 0x31,
      0x09, 0x38, 0x15, 0x81, 0x25, 0x7f, 0x75, 0x08, 0x95, 0x03, 0x81, 0x06, 0xc0, 0xc0
    ]
    udev:
      属性:
      - ID_INPUT=1
      - ID_INPUT_MOUSE=1
      - LIBINPUT_DEVICE_GROUP=3/3f0/94a:usb-0000:05:00.3-2
    特性:
    事件:
    # 当前时间是 12:31:56
    - evdev:
      - [  0,	   0,	4,   4,      30] # EV_MSC / MSC_SCAN		     30 (已混淆)
      - [  0,	   0,	1, 272,       1] # EV_KEY / BTN_LEFT		      1
      - [  0,	   0,	0,   0,       0] # ------------ SYN_REPORT (0) ---------- +0ms
    - evdev:
      - [  1, 207892,	4,   4,      30] # EV_MSC / MSC_SCAN		     30 (已混淆)
      - [  1, 207892,	1, 273,       1] # EV_KEY / BTN_RIGHT		      1
      - [  1, 207892,	0,   0,       0] # ------------ SYN_REPORT (0) ---------- +1207ms
    - evdev:
      - [  2, 367823,	4,   4,      30] # EV_MSC / MSC_SCAN		     30 (已混淆)
      - [  2, 367823,	1, 272,       0] # EV_KEY / BTN_LEFT		      0
      - [  2, 367823,	0,   0,       0] # ------------ SYN_REPORT (0) ---------- +1160ms
    # 当前时间是 12:32:00
    - evdev:
      - [  3, 247617,	4,   4,      30] # EV_MSC / MSC_SCAN		     30 (已混淆)
      - [  3, 247617,	1, 273,       0] # EV_KEY / BTN_RIGHT		      0
      - [  3, 247617,   0,   0,       0] # ------------ SYN_REPORT (0) ---------- +880ms

注意: 如果你的系统上没有 ``libinput record`` 命令，可以尝试使用 ``evemu-record``。
当出现问题时
============================

设备不能正常工作的原因可能有多种。例如，

* HID 设备提供的 HID 报告描述符可能是错误的，因为例如：
* 它不符合标准，因此内核无法正确解析 HID 报告描述符；
* HID 报告描述符与设备实际发送的数据不匹配（这可以通过读取原始 HID 数据来验证）；
* HID 报告描述符可能需要一些“特性”（见下文）。

结果可能是为每个“应用集合”创建的 ``/dev/input/event*`` 文件可能不存在，或者其中的事件可能与你的预期不符。
特性
------

有些 HID 设备具有一些已知的特殊性，内核知道如何解决这些问题——这些称为 HID 特性，并且可以在 `include/linux/hid.h` 中找到此类特性的列表。
如果确实需要添加特定 HID 设备所需的特性，则通常只需在内核中加入所需的特性即可。这可以在文件 `drivers/hid/hid-quirks.c` 中完成。具体实现方法在查看该文件后应该相对直观。
当前定义的特性列表，来自 `include/linux/hid.h` ，是

.. kernel-doc:: include/linux/hid.h
   :doc: HID 特性

USB 设备的特性可以在加载 usbhid 模块时指定，参见 ``modinfo usbhid``。然而，正确的修复应该提交到 hid-quirks.c 并**向上游提交**。
有关如何提交补丁的指南，请参阅 Documentation/process/submitting-patches.rst。其他总线的特性需要添加到 hid-quirks.c 中。
修复 HID 报告描述符
---------------------------

如果你需要修改 HID 报告描述符，最简单的方法是使用 eBPF，具体方法请参考 Documentation/hid/hid-bpf.rst。
基本上，你可以更改原始 HID 报告描述符中的任何字节。samples/hid 目录下的示例应该是编写代码的良好起点，例如参见 `samples/hid/hid_mouse.bpf.c`：

  SEC("fmod_ret/hid_bpf_rdesc_fixup")
  int BPF_PROG(hid_rdesc_fixup, struct hid_bpf_ctx *hctx)
  {
    ...
```c
data[39] = 0x31;     // 将 data 数组的第 39 个元素设置为十六进制值 0x31
data[41] = 0x30;     // 将 data 数组的第 41 个元素设置为十六进制值 0x30
return 0;            // 函数返回 0
```

当然，这些也可以在内核源代码中完成，例如可以参考 `drivers/hid/hid-aureal.c` 或者 `drivers/hid/hid-samsung.c` 文件，它们提供了更复杂的示例。
如果你需要帮助理解HID手册以及HID报告描述符中的十六进制数字的确切含义，请查阅 `Documentation/hid/hidreport-parsing.rst`。

无论你采用哪种解决方案，请**将你的修复提交给HID维护者**，以便它可以被直接集成到内核中，从而使该特定的HID设备能够为所有人正常工作。关于如何进行提交，请参阅 `Documentation/process/submitting-patches.rst` 中的指南。

### 在传输过程中修改数据

使用eBPF，还可以修改与设备交换的数据。请再次参考 `samples/hid` 中的示例。
同样，请**分享你的修复方案**，以便它可以被集成到内核中！

### 编写专用驱动程序

这应该是最后的选择。
---
### 脚注

.. [#hidraw] 阅读 hidraw: 可以参考 `Documentation/hid/hidraw.rst` 和文件 `samples/hidraw/hid-example.c` 示例
`hid-example` 的输出对于同样的鼠标是这样的：

```bash
$ sudo ./hid-example
Report Descriptor Size: 52
Report Descriptor:
5 1 9 2 a1 1 9 1 a1 0 5 9 19 1 29 3 15 0 25 1 75 1 95 3 81 2 75 5 95 1 81 1 5 1 9 30 9 31 9 38 15 81 25 7f 75 8 95 3 81 6 c0 c0

Raw Name: PixArt USB Optical Mouse
Raw Phys: usb-0000:05:00.4-2.3/input0
Raw Info:
        bustype: 3 (USB)
        vendor: 0x093a
        product: 0x2510
```
