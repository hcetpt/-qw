SPDX 许可声明标识符: GPL-2.0

======================================
HID 报告描述符简介
======================================

本章旨在概述 HID 报告描述符是什么，以及非内核程序员如何处理与 Linux 不兼容的 HID 设备。
.. contents::
    :local:
    :depth: 2

.. toctree::
   :maxdepth: 2

   hidreport-parsing


简介
============

HID 代表人机接口设备，可以是任何你用来与计算机交互的设备，比如鼠标、触摸板、平板电脑、麦克风等。许多 HID 设备开箱即用，即使它们的硬件不同。例如，鼠标可以有任意数量的按钮；它们可能有一个滚轮；不同型号的移动灵敏度各不相同。然而，大多数情况下一切都能正常工作，无需为自 1970 年以来开发的每个鼠标模型编写专门的内核代码。

这是因为现代 HID 设备通过 *HID 报告描述符* 宣告其功能，这是一个固定字节集，详细描述了设备和主机之间可能发送的 *HID 报告* 及这些报告中每个位的意义。例如，一个 HID 报告描述符可能会指定“在 ID 为 3 的报告中，从第 8 位到第 15 位是鼠标的 X 轴偏移量”。

HID 报告本身只携带实际的数据值而不包含额外的元信息。需要注意的是，HID 报告可以从设备发送（“输入报告”，即输入事件），也可以发送到设备（“输出报告”以改变 LED 状态）或用于设备配置（“特征报告”）。一个设备可能支持一种或多种 HID 报告。

HID 子系统负责解析 HID 报告描述符，并将 HID 事件转换为普通的输入设备接口（参见 Documentation/hid/hid-transport.rst）。设备可能表现异常是因为设备提供的 HID 报告描述符有误，或者需要特殊处理，或者某些特殊设备或交互模式未被默认代码处理。

HID 报告描述符的格式由两个文档描述，可以在 USB 实施者论坛 (`USB Implementers Forum <https://www.usb.org/>`) 的 `HID 网页 <https://www.usb.org/hid>`_ 上找到：

* 《HID USB 设备类定义》 `<https://www.usb.org/document-library/device-class-definition-hid-111>`_ （以下简称 HID 规范）
* 《HID 用途表》 `<https://usb.org/document-library/hid-usage-tables-14>`_ （以下简称 HUT）

HID 子系统可以处理不同的传输驱动程序（USB、I2C、蓝牙等）。参见 Documentation/hid/hid-transport.rst

解析 HID 报告描述符
==============================

当前的 HID 设备列表可以在 `/sys/bus/hid/devices/` 找到。对于每个设备，例如 `/sys/bus/hid/devices/0003:093A:2510.0002/`，可以读取相应的报告描述符：
```
$ hexdump -C /sys/bus/hid/devices/0003:093A:2510.0002/report_descriptor
00000000  05 01 09 02 a1 01 09 01  a1 00 05 09 19 01 29 03  |..............).|
00000010  15 00 25 01 75 01 95 03  81 02 75 05 95 01 81 01  |..%.u.....u.....|
00000020  05 01 09 30 09 31 09 38  15 81 25 7f 75 08 95 03  |...0.1.8..%.u...|
00000030  81 06 c0 c0                                       |....|
00000034
```

可选：HID 报告描述符也可以通过直接访问 hidraw 驱动程序来读取 [#hidraw]_。
HID报告描述符的基本结构在HID规范中定义，而HUT“定义了可以被应用程序解释的常量，以识别HID报告中数据字段的目的和含义”。每个条目至少由两个字节定义，其中第一个字节定义了接下来是什么类型的值，并在HID规范中有描述；第二个字节则携带实际的值，并在HUT中有描述。

原则上，HID报告描述符可以通过逐字节地手动解析。关于如何做到这一点，在`Documentation/hid/hidreport-parsing.rst`中有一个简短的介绍；你只有在需要修改HID报告描述符时才需要理解它。

实际上你不应该手动解析HID报告描述符；相反，你应该使用现有的解析器。其中一些可用的解析器包括：

- 在线的`USB Descriptor and Request Parser <http://eleccelerator.com/usbdescreqparser/>`_
- `hidrdd <https://github.com/abend0c1/hidrdd>`_，提供非常详细且略显冗长的描述（如果你不熟悉HID报告描述符，冗长的描述可能是有用的）
- `hid-tools <https://gitlab.freedesktop.org/libevdev/hid-tools>`_，一个完整的工具集，可以记录和重放原始HID报告以及调试和重放HID设备。它正在由Linux HID子系统的维护者积极开发。

使用`hid-tools <https://gitlab.freedesktop.org/libevdev/hid-tools>`_ 解析鼠标HID报告描述符如下所示（解释穿插其中）：

```bash
$ ./hid-decode /sys/bus/hid/devices/0003:093A:2510.0002/report_descriptor
# 设备 0:0
# 0x05, 0x01,			// 使用页面 (通用桌面)		0
# 0x09, 0x02,			// 使用 (鼠标)				2
# 0xa1, 0x01,			// 收集 (应用)				4
# 0x09, 0x01,			// 使用 (指针)				6
# 0xa1, 0x00,			// 收集 (物理)				8
# 0x05, 0x09,			// 使用页面 (按钮)			10

接下来是一个按钮 ::

# 0x19, 0x01,			// 使用最小值 (1)			12
# 0x29, 0x03,			// 使用最大值 (3)			14

第一个按钮是按钮号1，最后一个按钮是按钮号3 ::

# 0x15, 0x00,			// 逻辑最小值 (0)			16
# 0x25, 0x01,			// 逻辑最大值 (1)			18

每个按钮可以发送从0到1的值
（即它们是二进制按钮） ::

# 0x75, 0x01,			// 报告大小 (1)			20

每个按钮发送正好一个位 ::

# 0x95, 0x03,			// 报告计数 (3)			22

有三个这样的位（对应三个按钮） ::

# 0x81, 0x02,			// 输入 (数据, 变量, 绝对)		24

这是实际的数据（不是常量填充），它们代表一个单一变量（变量）并且它们的值是绝对的（不是相对的）；
参见HID规范第6.2.2.5节 “输入、输出和特征项” ::

# 0x75, 0x05,			// 报告大小 (5)			26

五个额外的填充位，用于达到一个字节 ::

# 0x95, 0x01,			// 报告计数 (1)			28

这五个位只重复一次 ::

# 0x81, 0x01,			// 输入 (常量, 数组, 绝对)		30

这些位取常量（常量）值，即可以忽略。 ::

# 0x05, 0x01,			// 使用页面 (通用桌面)		32
# 0x09, 0x30,			// 使用 (X)				34
# 0x09, 0x31,			// 使用 (Y)				36
# 0x09, 0x38,			// 使用 (滚轮)			38

鼠标还有两个物理位置（使用 (X)，使用 (Y)）和一个滚轮（使用 (滚轮)) ::

# 0x15, 0x81,			// 逻辑最小值 (-127)		40
# 0x25, 0x7f,			// 逻辑最大值 (127)		42

它们每个可以发送从-127到127的值 ::

# 0x75, 0x08,			// 报告大小 (8)			44

用八个位表示 ::

# 0x95, 0x03,			// 报告计数 (3)			46

有三个这样的八位，对应X、Y和滚轮。 ::

# 0x81, 0x06,			// 输入 (数据, 变量, 相对)		48

这次数据值是相对的（相对），即它们代表相对于之前发送的报告（事件）的变化 ::

# 0xc0,				// 结束收集			50
# 0xc0,				// 结束收集			51

#
R: 52 05 01 09 02 a1 01 09 01 a1 00 05 09 19 01 29 03 15 00 25 01 75 01 95 03 81 02 75 05 95 01 81 01 05 01 09 30 09 31 09 38 15 81 25 7f 75 08 95 03 81 06 c0 c0
N: 设备 0:0
I: 3 0001 0001

这个报告描述符告诉我们，鼠标输入将使用四个字节进行传输：第一个字节用于按钮（三个位用于，五个位用于填充），最后三个字节分别用于鼠标X、Y和滚轮的变化。
事实上，对于任何事件，鼠标都会发送一个四字节的*报告*。
我们可以使用例如来自`hid-tools <https://gitlab.freedesktop.org/libevdev/hid-tools>`_的`hid-recorder`工具来检查发送的值：
点击并释放按钮1，然后是按钮2，最后是按钮3所发送的字节序列如下所示：

```bash
$ sudo ./hid-recorder /dev/hidraw1

...
hid-decode 的输出
...
# 按钮: 1  0  0 | # | X: 0 | Y: 0 | 滚轮: 0
E: 000000.000000 4 01 00 00 00
# 按钮: 0  0  0 | # | X: 0 | Y: 0 | 滚轮: 0
E: 000000.183949 4 00 00 00 00
# 按钮: 0  1  0 | # | X: 0 | Y: 0 | 滚轮: 0
E: 000001.959698 4 02 00 00 00
# 按钮: 0  0  0 | # | X: 0 | Y: 0 | 滚轮: 0
E: 000002.103899 4 00 00 00 00
# 按钮: 0  0  1 | # | X: 0 | Y: 0 | 滚轮: 0
E: 000004.855799 4 04 00 00 00
# 按钮: 0  0  0 | # | X: 0 | Y: 0 | 滚轮: 0
E: 000005.103864 4 00 00 00 00

这个示例表明，当点击按钮2时，
会发送字节 ``02 00 00 00``，紧接着的事件（``00 00 00 00``）是释放按钮2（没有按钮被按下，记住数据值是*绝对*的）。
如果相反地，先按下并保持按钮1，然后按下并保持按钮2，释放按钮1，最后释放按钮2，报告如下：

  # 按钮: 1 0 0 | # | X: 0 | Y: 0 | 滚轮: 0
  E: 000044.175830 4 01 00 00 00
  # 按钮: 1 1 0 | # | X: 0 | Y: 0 | 滚轮: 0
  E: 000045.975997 4 03 00 00 00
  # 按钮: 0 1 0 | # | X: 0 | Y: 0 | 滚轮: 0
  E: 000047.407930 4 02 00 00 00
  # 按钮: 0 0 0 | # | X: 0 | Y: 0 | 滚轮: 0
  E: 000049.199919 4 00 00 00 00

其中，“03 00 00 00”表示两个按钮都被按下，而随后的“02 00 00 00”表示按钮1被释放，但按钮2仍然处于活动状态。

输出、输入和特征报告
----------------------

HID设备可以有输入报告（如鼠标示例），输出报告和特征报告。“输出”意味着信息被发送到设备。例如，带有力反馈的手柄将有一些输出；键盘上的LED也需要输出。“输入”意味着数据来自设备。“特征”并不打算供最终用户使用，而是定义设备的配置选项。它们可以从主机查询；当声明为“易失性”时，它们应由主机更改。

集合、报告ID和Evdev事件
=======================

单个设备可以逻辑上将数据分组为不同的独立集合，称为“集合”。集合可以嵌套，并且有不同的集合类型（详见HID规范6.2.2.6“集合，结束集合项”的细节）。

不同的报告通过不同的“报告ID”字段来识别，即标识后续报告结构的一个数字。

每当需要报告ID时，它会作为任何报告的第一个字节传输。只有一个支持HID报告的设备（如上面的鼠标示例）可以省略报告ID。

考虑以下HID报告描述符：

  05 01 09 02 A1 01 85 01 05 09 19 01 29 05 15 00
  25 01 95 05 75 01 81 02 95 01 75 03 81 01 05 01
  09 30 09 31 16 00 F8 26 FF 07 75 0C 95 02 81 06
  09 38 15 80 25 7F 75 08 95 01 81 06 05 0C 0A 38
  02 15 80 25 7F 75 08 95 01 81 06 C0 05 01 09 02
  A1 01 85 02 05 09 19 01 29 05 15 00 25 01 95 05
  75 01 81 02 95 01 75 03 81 01 05 01 09 30 09 31
  16 00 F8 26 FF 07 75 0C 95 02 81 06 09 38 15 80
  25 7F 75 08 95 01 81 06 05 0C 0A 38 02 15 80 25
  7F 75 08 95 01 81 06 C0 05 01 09 07 A1 01 85 05
  05 07 15 00 25 01 09 29 09 3E 09 4B 09 4E 09 E3
  09 E8 09 E8 09 E8 75 01 95 08 81 02 95 00 81 01
  C0 05 0C 09 01 A1 01 85 06 15 00 25 01 75 01 95
  01 09 3F 81 06 09 3F 81 06 09 3F 81 06 09 3F 81
  06 09 3F 81 06 09 3F 81 06 09 3F 81 06 09 3F 81
  06 C0 05 0C 09 01 A1 01 85 03 09 05 15 00 26 FF
  00 75 08 95 02 B1 02 C0

解析后（尝试使用建议的工具自行解析！）可以看到设备有两个“鼠标”应用集合（报告分别由报告ID 1和2标识），一个“小键盘”应用集合（其报告由报告ID 5标识）以及两个“消费者控制”应用集合（报告分别由报告ID 6和3标识）。然而需要注意的是，设备可以为相同的应用集合具有不同的报告ID。

发送的数据将以报告ID字节开始，并跟随相应的信息。例如，最后一个消费者控制的信息：

  0x05, 0x0C,        // 使用页 (消费者)
  0x09, 0x01,        // 使用 (消费者控制)
  0xA1, 0x01,        // 集合 (应用)
  0x85, 0x03,        // 报告ID (3)
  0x09, 0x05,        // 使用 (耳机)
  0x15, 0x00,        // 逻辑最小值 (0)
  0x26, 0xFF, 0x00,  // 逻辑最大值 (255)
  0x75, 0x08,        // 报告大小 (8)
  0x95, 0x02,        // 报告计数 (2)
  0xB1, 0x02,        // 特征 (数据, 变量, 绝对值, 不循环, 线性, 偏好状态, 无空位置, 非易失性)
  0xC0,              // 结束集合

将为三个字节：第一个字节用于报告ID (3)，接下来两个字节用于耳机，每个字节有两个（“报告计数 (2)”）字节（“报告大小 (8)”），每个字节的范围从0（“逻辑最小值 (0)”）到255（“逻辑最大值 (255)”）。

设备发送的所有输入数据都应转换为相应的Evdev事件，以便堆栈的其余部分能够知道发生了什么，例如，第一个按钮的位将转换为“EV_KEY/BTN_LEFT” Evdev事件，相对X移动将转换为“EV_REL/REL_X” Evdev事件。
事件
======

在 Linux 中，每个 `Application Collection` 都会创建一个 `/dev/input/event*`。回到鼠标示例中，重复点击并按住按钮 1，然后点击并按住按钮 2，释放按钮 1，最后释放按钮 2 的序列，你会得到以下输出：

  $ sudo libinput record /dev/input/event1
  # libinput record
  版本: 1
  设备数量: 1
  libinput:
    版本: "1.23.0"
    Git: "unknown"
  系统:
    操作系统: "opensuse-tumbleweed:20230619"
    内核: "6.3.7-1-default"
    DMI: "dmi:bvnHP:bvrU77Ver.01.05.00:bd03/24/2022:br5.0:efr20.29:svnHP:pnHPEliteBook64514inchG9NotebookPC:pvr:rvnHP:rn89D2:rvrKBCVersion14.1D.00:cvnHP:ct10:cvr:sku5Y3J1EA#ABZ:"
  设备:
  - 节点: /dev/input/event1
    evdev:
      # 名称: PixArt HP USB 光学鼠标
      # ID: bus 0x3 vendor 0x3f0 product 0x94a version 0x111
      # 支持的事件:
      # 事件类型 0 (EV_SYN)
      # 事件类型 1 (EV_KEY)
      #   事件代码 272 (BTN_LEFT)
      #   事件代码 273 (BTN_RIGHT)
      #   事件代码 274 (BTN_MIDDLE)
      # 事件类型 2 (EV_REL)
      #   事件代码 0 (REL_X)
      #   事件代码 1 (REL_Y)
      #   事件代码 8 (REL_WHEEL)
      #   事件代码 11 (REL_WHEEL_HI_RES)
      # 事件类型 4 (EV_MSC)
      #   事件代码 4 (MSC_SCAN)
      # 属性:
      名称: "PixArt HP USB 光学鼠标"
      ID: [3, 1008, 2378, 273]
      代码:
        0: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] # EV_SYN
        1: [272, 273, 274] # EV_KEY
        2: [0, 1, 8, 11] # EV_REL
        4: [4] # EV_MSC
      属性: []
    hid: [
      0x05, 0x01, 0x09, 0x02, 0xa1, 0x01, 0x09, 0x01, 0xa1, 0x00, 0x05, 0x09, 0x19, 0x01, 0x29, 0x03,
      0x15, 0x00, 0x25, 0x01, 0x95, 0x08, 0x75, 0x01, 0x81, 0x02, 0x05, 0x01, 0x09, 0x30, 0x09, 0x31,
      0x09, 0x38, 0x15, 0x81, 0x25, 0x7f, 0x75, 0x08, 0x95, 0x03, 0x81, 0x06, 0xc0, 0xc0
    ]
    udev:
      属性:
      - ID_INPUT=1
      - ID_INPUT_MOUSE=1
      - LIBINPUT_DEVICE_GROUP=3/3f0/94a:usb-0000:05:00.3-2
    异常:
    事件:
    # 当前时间是 12:31:56
    - evdev:
      - [  0,	   0,	4,   4,      30] # EV_MSC / MSC_SCAN 30 (已混淆)
      - [  0,	   0,	1, 272,       1] # EV_KEY / BTN_LEFT 1
      - [  0,	   0,	0,   0,       0] # ------------ SYN_REPORT (0) ---------- +0ms
    - evdev:
      - [  1, 207892,	4,   4,      30] # EV_MSC / MSC_SCAN 30 (已混淆)
      - [  1, 207892,	1, 273,       1] # EV_KEY / BTN_RIGHT 1
      - [  1, 207892,	0,   0,       0] # ------------ SYN_REPORT (0) ---------- +1207ms
    - evdev:
      - [  2, 367823,	4,   4,      30] # EV_MSC / MSC_SCAN 30 (已混淆)
      - [  2, 367823,	1, 272,       0] # EV_KEY / BTN_LEFT 0
      - [  2, 367823,	0,   0,       0] # ------------ SYN_REPORT (0) ---------- +1160ms
    # 当前时间是 12:32:00
    - evdev:
      - [  3, 247617,	4,   4,      30] # EV_MSC / MSC_SCAN 30 (已混淆)
      - [  3, 247617,	1, 273,       0] # EV_KEY / BTN_RIGHT 0
      - [  3, 247617,   0,   0,       0] # ------------ SYN_REPORT (0) ---------- +880ms

注意：如果 `libinput record` 在你的系统上不可用，请尝试使用 `evemu-record`

当某些功能不工作时
============================

设备行为不正确可能有多种原因。例如：

* 提供的 HID 报告描述符可能是错误的，例如：
  * 它不符合标准，因此内核无法理解 HID 报告描述符；
  * HID 报告描述符与设备实际发送的内容**不符**（可以通过读取原始 HID 数据来验证）；
* HID 报告描述符可能需要一些“异常”处理（见下文）。
  
因此，每个 `Application Collection` 可能不会创建 `/dev/input/event*` 文件，或者事件可能不符合预期。

异常
------

有一些 HID 设备已知的问题，内核知道如何修复——这些被称为 HID 异常，可以在 `include/linux/hid.h` 中找到这些异常的列表。
如果出现这种情况，只需在内核中为当前的 HID 设备添加所需的异常即可。这可以在文件 `drivers/hid/hid-quirks.c` 中完成。查看该文件后应该可以相对容易地实现这一操作。

目前定义的异常列表如下：

.. kernel-doc:: include/linux/hid.h
   :doc: HID 异常

USB 设备的异常可以在加载 usbhid 模块时指定，参见 `modinfo usbhid`。虽然正确的修复方法应该是提交到 `hid-quirks.c` 并**向上游提交**。
提交补丁的指南请参见 `Documentation/process/submitting-patches.rst`。其他总线的异常需要放入 `hid-quirks.c` 中。

修复 HID 报告描述符
----------------------

如果你需要修补 HID 报告描述符，最简单的方法是使用 eBPF，具体描述见 `Documentation/hid/hid-bpf.rst`。
基本上，你可以修改原始 HID 报告描述符中的任何字节。`samples/hid` 目录下的示例代码是一个很好的起点，例如 `samples/hid/hid_mouse.bpf.c`：

  SEC("fmod_ret/hid_bpf_rdesc_fixup")
  int BPF_PROG(hid_rdesc_fixup, struct hid_bpf_ctx *hctx)
  {
    ...
```c
data[39] = 0x31;
data[41] = 0x30;
return 0;
```

当然，这也可以在内核源代码中完成，例如参见 `drivers/hid/hid-aureal.c` 或 `drivers/hid/hid-samsung.c` 文件中的稍微复杂一点的示例。
如果需要帮助理解HID手册以及HID报告描述符的十六进制数字的确切含义，请查阅 `Documentation/hid/hidreport-parsing.rst`。

无论你提出什么解决方案，请记得**将修复提交给HID维护者**，以便它可以被直接集成到内核中，并使该特定HID设备对其他人也能正常工作。关于如何提交补丁，请参阅 `Documentation/process/submitting-patches.rst` 中的指南。

即时修改传输的数据
------------------------

使用eBPF也可以修改与设备交换的数据。再次参见 `samples/hid` 中的示例。
同样，请**发布你的修复方案**，以便它可以被集成到内核中！

编写专用驱动程序
--------------------

这应该是你的最后手段。
.. rubric:: 脚注

.. [#hidraw] 读取hidraw：参见 `Documentation/hid/hidraw.rst` 和文件 `samples/hidraw/hid-example.c` 的示例
对于同一款鼠标，`hid-example` 的输出如下：

```
$ sudo ./hid-example
Report Descriptor Size: 52
Report Descriptor:
5 1 9 2 a1 1 9 1 a1 0 5 9 19 1 29 3 15 0 25 1 75 1 95 3 81 2 75 5 95 1 81 1 5 1 9 30 9 31 9 38 15 81 25 7f 75 8 95 3 81 6 c0 c0

Raw Name: PixArt USB Optical Mouse
Raw Phys: usb-0000:05:00.4-2.3/input0
Raw Info:
        bustype: 3 (USB)
        vendor: 0x093a
        product: 0x2510
```
