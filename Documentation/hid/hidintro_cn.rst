SPDX 许可证标识符: GPL-2.0

======================================
HID报告描述符简介
======================================

本章旨在全面概述HID报告描述符是什么，以及非内核的普通程序员如何处理与Linux配合不佳的HID设备。
.. contents::
    :local:
    :depth: 2

.. toctree::
   :maxdepth: 2

   hidreport-parsing


引言
============

HID代表人机界面设备，可以是任何你用来与计算机交互的设备，无论是鼠标、触控板、平板电脑、麦克风等。
许多HID设备开箱即用，即使它们的硬件不同。
例如，鼠标可以有任意数量的按钮；它们可能有一个滚轮；运动灵敏度在不同型号之间有所不同，等等。然而，大多数情况下，一切都能正常工作，无需为自1970年以来开发的每一款鼠标模型在内核中编写专门代码。
这是因为现代HID设备确实通过*HID报告描述符*宣传了它们的能力，这是一组固定的字节，精确地描述了设备和主机之间可能发送的*HID报告*，以及这些报告中每个单独位的意义。例如，一个HID报告描述符可能会指定“在一个ID为3的报告中，从第8位到第15位是鼠标的x坐标增量”。
HID报告本身仅携带实际数据值而无额外的元信息。需要注意的是，HID报告可以从设备发送（“输入报告”，即输入事件），向设备发送（“输出报告”以改变LED等），或用于设备配置（“特性报告”）。一个设备可能支持一个或多个HID报告。
HID子系统负责解析HID报告描述符，并将HID事件转换为标准的输入设备接口（参见Documentation/hid/hid-transport.rst）。设备可能表现异常是因为由设备提供的HID报告描述符错误，或者因为它需要以特殊方式处理，或者因为某些特殊设备或交互模式未被默认代码处理。
HID报告描述符的格式由两个文档描述，可以从`USB实施者论坛 <https://www.usb.org/>`_ 的`HID网页 <https://www.usb.org/hid>`_地址找到：

 * `HID USB设备类定义 <https://www.usb.org/document-library/device-class-definition-hid-111>`_ （以下称为HID规范）
 * `HID使用表 <https://usb.org/document-library/hid-usage-tables-14>`_ （以下称为HUT）

HID子系统可以处理不同的传输驱动程序（USB、I2C、蓝牙等）。请参阅Documentation/hid/hid-transport.rst
解析HID报告描述符
==============================

当前HID设备列表可以在``/sys/bus/hid/devices/``找到
对于每个设备，比如``/sys/bus/hid/devices/0003\:093A\:2510.0002/``，
可以读取相应的报告描述符::

  $ hexdump -C /sys/bus/hid/devices/0003\:093A\:2510.0002/report_descriptor
  00000000  05 01 09 02 a1 01 09 01  a1 00 05 09 19 01 29 03  |..............).|
  00000010  15 00 25 01 75 01 95 03  81 02 75 05 95 01 81 01  |..%.u.....u.....|
  00000020  05 01 09 30 09 31 09 38  15 81 25 7f 75 08 95 03  |...0.1.8..%.u...|
  00000030  81 06 c0 c0                                       |....|
  00000034

可选：HID报告描述符也可以通过直接访问hidraw驱动程序来读取 [#hidraw]_

注释部分（如：.. contents:: 和 .. toctree::）通常用于文档生成工具（如Sphinx），在实际文档中不会显示。它们用于控制目录结构和内容的组织。
HID报告描述符的基本结构在HID规范中定义，而HUT“定义了可以被应用程序解释的常量，以识别HID报告中数据字段的目的和意义”。每个条目至少由两个字节定义，其中第一个字节定义了接下来的值类型，并在HID规范中描述；而第二个字节携带实际的值，并在HUT中描述。
原则上，HID报告描述符可以通过手工逐字节地仔细解析。关于如何进行这种解析的简短介绍可以在Documentation/hid/hidreport-parsing.rst中找到；你只需要理解它，如果你需要修改HID报告描述符的话。
实际上，你不应该手动解析HID报告描述符；相反，你应该使用现有的解析器。在所有可用的解析器中，

  * 网上的`USB Descriptor and Request Parser <http://eleccelerator.com/usbdescreqparser/>`_；
  * `hidrdd <https://github.com/abend0c1/hidrdd>`_，它提供了非常详细且略显冗长的描述（冗长可能在你不熟悉HID报告描述符时有用）；
  * `hid-tools <https://gitlab.freedesktop.org/libevdev/hid-tools>`_，一个完整的工具集，允许记录和重放原始HID报告，以及调试和重放HID设备，它正由Linux HID子系统维护者积极开发。

使用`hid-tools <https://gitlab.freedesktop.org/libevdev/hid-tools>`_解析鼠标HID报告描述符会得到以下结果（解释穿插其中）：

```
$ ./hid-decode /sys/bus/hid/devices/0003:093A:2510.0002/report_descriptor
# 设备 0:0
# 0x05, 0x01,    // 使用页 (通用桌面)          0
# 0x09, 0x02,    // 使用 (鼠标)                  2
# 0xa1, 0x01,    // 集合 (应用)                 4
# 0x09, 0x01,    // 使用 (指针)                 6
# 0xa1, 0x00,    // 集合 (物理)                 8
# 0x05, 0x09,    //   使用页 (按钮)             10

接下来是一个按钮 ::

# 0x19, 0x01,    //   使用最小值 (1)            12
# 0x29, 0x03,    //   使用最大值 (3)            14

第一个按钮是按钮号1，最后一个按钮是按钮号3 ::

# 0x15, 0x00,    //   逻辑最小值 (0)            16
# 0x25, 0x01,    //   逻辑最大值 (1)            18

每个按钮可以发送从0到1的值
(即它们是二进制按钮) ::

# 0x75, 0x01,    //   报告大小 (1)              20

每个按钮正好发送一个位 ::

# 0x95, 0x03,    //   报告计数 (3)              22

有三个这样的位（与三个按钮相匹配） ::

# 0x81, 0x02,    // 输入 (数据，变，绝对)        24

它是实际的数据（不是常量填充），它们代表
单个变量（变），并且其值是绝对的（不是相对的）；
参见HID规范第6.2.2.5节“输入、输出和特性项” ::

# 0x75, 0x05,    //   报告大小 (5)              26

五个额外的填充位，用于达到一个字节 ::

# 0x95, 0x01,    //   报告计数 (1)              28

这五个位只重复一次 ::

# 0x81, 0x01,    // 输入 (常量，数组，绝对)      30

它们取常量（常量）值，即可以忽略。 ::

# 0x05, 0x01,    // 使用页 (通用桌面)           32
# 0x09, 0x30,    // 使用 (X)                    34
# 0x09, 0x31,    // 使用 (Y)                    36
# 0x09, 0x38,    // 使用 (滚轮)                 38

鼠标还有两个物理位置（使用 (X)，使用 (Y))
和一个滚轮（使用 (滚轮)) ::

# 0x15, 0x81,    //   逻辑最小值 (-127)         40
# 0x25, 0x7f,    //   逻辑最大值 (127)          42

它们可以发送从-127到包括127的值 ::

# 0x75, 0x08,    //   报告大小 (8)              44

由八个位表示 ::

# 0x95, 0x03,    //   报告计数 (3)              46

有三个这样的八位，对应于X、Y和滚轮。 ::

# 0x81, 0x06,    // 输入 (数据，变，相对)       48

这次数据值是相对的（相对），即它们代表
与之前发送的报告（事件）的变化 ::

# 0xc0,           // 结束集合                 50
# 0xc0,           // 结束集合                 51
#
R: 52 05 01 09 02 a1 01 09 01 a1 00 05 09 19 01 29 03 15 00 25 01 75 01 95 03 81 02 75 05 95 01 81 01 05 01 09 30 09 31 09 38 15 81 25 7f 75 08 95 03 81 06 c0 c0
N: 设备 0:0
I: 3 0001 0001


这个报告描述符告诉我们，鼠标输入将使用四个字节：第一个字节用于按钮（使用三个位，五个用于填充），最后三个字节分别用于鼠标X、Y和滚轮变化。
事实上，对于任何事件，鼠标都会发送一个四个字节的*报告*
我们可以通过例如使用`hid-recorder`工具来检查发送的值，该工具来自`hid-tools <https://gitlab.freedesktop.org/libevdev/hid-tools>`_：
点击然后释放按钮1，接着按钮2，再接着按钮3所发送的字节序列是：

```
$ sudo ./hid-recorder /dev/hidraw1

...
hid-decode 的输出
...
# 按钮: 1  0  0 | # | X:  0 | Y:    0 | 滚轮: 0
E: 000000.000000 4 01 00 00 00
# 按钮: 0  0  0 | # | X:  0 | Y:    0 | 滚轮: 0
E: 000000.183949 4 00 00 00 00
# 按钮: 0  1  0 | # | X:  0 | Y:    0 | 滚轮: 0
E: 000001.959698 4 02 00 00 00
# 按钮: 0  0  0 | # | X:  0 | Y:    0 | 滚轮: 0
E: 000002.103899 4 00 00 00 00
# 按钮: 0  0  1 | # | X:  0 | Y:    0 | 滚轮: 0
E: 000004.855799 4 04 00 00 00
# 按钮: 0  0  0 | # | X:    0 | Y:    0 | 滚轮:    0
E: 000005.103864 4 00 00 00 00

这个例子表明，当按钮2被点击时，
发送的字节是``02 00 00 00``，而立即随后的
事件（``00 00 00 00``）是按钮2的释放（没有按钮被按下，记住数据值是*绝对的*）。
如果相反，先按下并保持按钮 1，然后按下并保持按钮 2，释放按钮 1，最后释放按钮 2，报告如下：

  # 按钮: 1  0  0 | # | X:    0 | Y:    0 | 轮:    0
  E: 000044.175830 4 01 00 00 00
  # 按钮: 1  1  0 | # | X:    0 | Y:    0 | 轮:    0
  E: 000045.975997 4 03 00 00 00
  # 按钮: 0  1  0 | # | X:    0 | Y:    0 | 轮:    0
  E: 000047.407930 4 02 00 00 00
  # 按钮: 0  0  0 | # | X:    0 | Y:    0 | 轮:    0
  E: 000049.199919 4 00 00 00 00

其中 `03 00 00 00` 表示两个按钮都被按下，随后的 `02 00 00 00` 表示按钮 1 已释放而按钮 2 仍然处于活动状态。

输出、输入和特性报告
-----------------------

HID 设备可以有输入报告，就像在鼠标示例中那样，输出报告以及特性报告。“输出”意味着信息被发送到设备。例如，具有力反馈的操纵杆将有一些输出；键盘的LED也需要输出。“输入”意味着数据来自设备。“特性”并不是供最终用户使用的，而是定义了设备的配置选项。它们可以从主机查询；当声明为*易失性*时，应该由主机更改。

集合、报告ID和Evdev事件
======================

单一设备可以在逻辑上将数据分成不同的独立集，称为“集合”。集合可以嵌套，并且存在不同类型的集合（参见HID规范6.2.2.6“集合，结束集合项”以了解详细信息）。
通过不同的*报告ID*字段来标识不同的报告，即一个数字用来识别紧随其后的报告结构。
每当需要报告ID时，它都会作为任何报告的第一个字节传输。只有一个支持的HID报告的设备（如上面的鼠标示例）可以省略报告ID。
考虑以下HID报告描述符：

  05 01 09 02 A1 01 85 01 05 09 19 01 29 05 15 00
  25 01 95 05 75 01 81 02 95 01 75 03 81 01 05 01
  09 30 09 31 16 00 F8 26 FF 07 75 0C 95 02 81 06
  09 38 15 80 25 7F 75 08 95 01 81 06 05 0C 0A 38
  02 15 80 25 7F 75 08 95 01 81 06 C0 05 01 09 02
  A1 01 85 02 05 09 19 01 29 05 15 00 25 01 95 05
  75 01 81 02 95 01 75 03 81 01 05 01 09 30 09 31
  16 00 F8 26 FF 07 75 0C 95 02 81 06 09 38 15 80
  25 7F 75 08 95 01 81 06 05 0C 0A 38 02 15 80 25
  7F 75 08 95 01 81 06 C0 05 01 09 07 A1 01 85 05
  05 07 15 00 25 01 09 29 09 3E 09 4B 09 4E 09 E3
  09 E8 09 E8 09 E8 75 01 95 08 81 02 95 00 81 01
  C0 05 0C 09 01 A1 01 85 06 15 00 25 01 75 01 95
  01 09 3F 81 06 09 3F 81 06 09 3F 81 06 09 3F 81
  06 09 3F 81 06 09 3F 81 06 09 3F 81 06 09 3F 81
  06 C0 05 0C 09 01 A1 01 85 03 09 05 15 00 26 FF
  00 75 08 95 02 B1 02 C0

解析之后（尝试使用建议的工具自行解析！），可以看到该设备提供了两个“鼠标”应用集合（报告分别由报告ID 1和2标识），一个“键盘”应用集合（其报告由报告ID 5标识）以及两个“消费者控制”应用集合（报告ID分别为6和3）。然而需要注意的是，设备可能对相同的应用集合有不同的报告ID。
发送的数据将以报告ID字节开始，并后跟相应信息。例如，最后一个消费者控制的信息：

  0x05, 0x0C,        // 使用页面 (消费者)
  0x09, 0x01,        // 使用 (消费者控制)
  0xA1, 0x01,        // 集合 (应用)
  0x85, 0x03,        //   报告ID (3)
  0x09, 0x05,        //   使用 (耳机)
  0x15, 0x00,        //   逻辑最小值 (0)
  0x26, 0xFF, 0x00,  //   逻辑最大值 (255)
  0x75, 0x08,        //   报告大小 (8)
  0x95, 0x02,        //   报告计数 (2)
  0xB1, 0x02,        //   特性 (数据,变,绝对,无环绕,线性,首选状态,无零位置,非易失性)
  0xC0,              // 结束集合

将会是三个字节：第一个用于报告ID（3），接下来两个用于耳机，每个有两个字节（“报告计数 (2)”）（“报告大小 (8)”），范围从 0 （“逻辑最小值 (0)”） 到 255 （“逻辑最大值 (255)”）。
设备发送的所有输入数据应转换为相应的Evdev事件，以便堆栈的其余部分能够知道发生了什么，例如，第一个按钮的位对应于Evdev事件 `EV_KEY/BTN_LEFT`，相对X移动则对应于Evdev事件 `EV_REL/REL_X`。
事件
======

在 Linux 中，每个“应用集合(Application Collection)”都会创建一个对应的 ``/dev/input/event*``。回到鼠标示例，重复以下序列：按下并持续按住按钮 1，然后按下并持续按住按钮 2，释放按钮 1，最后释放按钮 2，会得到如下结果：

  $ sudo libinput record /dev/input/event1
  # libinput record
  版本: 1
  设备数量: 1
  libinput:
    版本: "1.23.0"
    Git: "未知"
  系统:
    操作系统: "opensuse-tumbleweed:20230619"
    内核: "6.3.7-1-default"
    DMI: "dmi:bvnHP:bvrU77Ver.01.05.00:bd03/24/2022:br5.0:efr20.29:svnHP:pnHPEliteBook64514inchG9NotebookPC:pvr:rvnHP:rn89D2:rvrKBCVersion14.1D.00:cvnHP:ct10:cvr:sku5Y3J1EA#ABZ:"
  设备:
  - 节点: /dev/input/event1
    evdev:
      # 名称: PixArt HP USB 光学鼠标
      # ID: 总线 0x3 厂商 0x3f0 产品 0x94a 版本 0x111
      # 支持的事件:
      # 事件类型 0 (EV_SYN)
      # 事件类型 1 (EV_KEY)
      #   事件代码 272 (BTN_LEFT)
      #   事件代码 273 (BTN_RIGHT)
      #   事件代码 274 (BTN_MIDDLE)
      # 事件类型 2 (EV_REL)
      #   事件代码 0 (REL_X)
      #   事件代码 1 (REL_Y)
      #   事件代码 8 (REL_WHEEL)
      #   事件代码 11 (REL_WHEEL_HI_RES)
      # 事件类型 4 (EV_MSC)
      #   事件代码 4 (MSC_SCAN)
      # 属性：
      名称: "PixArt HP USB 光学鼠标"
      ID: [3, 1008, 2378, 273]
      代码:
  	0: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] # EV_SYN
  	1: [272, 273, 274] # EV_KEY
  	2: [0, 1, 8, 11] # EV_REL
  	4: [4] # EV_MSC
      属性: []
    HID: [
      0x05, 0x01, 0x09, 0x02, 0xa1, 0x01, 0x09, 0x01, 0xa1, 0x00, 0x05, 0x09, 0x19, 0x01, 0x29, 0x03,
      0x15, 0x00, 0x25, 0x01, 0x95, 0x08, 0x75, 0x01, 0x81, 0x02, 0x05, 0x01, 0x09, 0x30, 0x09, 0x31,
      0x09, 0x38, 0x15, 0x81, 0x25, 0x7f, 0x75, 0x08, 0x95, 0x03, 0x81, 0x06, 0xc0, 0xc0
    ]
    udev:
      属性:
      - ID_INPUT=1
      - ID_INPUT_MOUSE=1
      - LIBINPUT_DEVICE_GROUP=3/3f0/94a:usb-0000:05:00.3-2
    异常特性(quirks):
    事件:
    # 当前时间是 12:31:56
    - evdev:
      - [  0,	   0,	4,   4,      30] # EV_MSC / MSC_SCAN		     30 (已模糊处理)
      - [  0,	   0,	1, 272,       1] # EV_KEY / BTN_LEFT		      1
      - [  0,	   0,	0,   0,       0] # ------------ SYN_REPORT (0) ---------- +0ms
    - evdev:
      - [  1, 207892,	4,   4,      30] # EV_MSC / MSC_SCAN		     30 (已模糊处理)
      - [  1, 207892,	1, 273,       1] # EV_KEY / BTN_RIGHT		      1
      - [  1, 207892,	0,   0,       0] # ------------ SYN_REPORT (0) ---------- +1207ms
    - evdev:
      - [  2, 367823,	4,   4,      30] # EV_MSC / MSC_SCAN		     30 (已模糊处理)
      - [  2, 367823,	1, 272,       0] # EV_KEY / BTN_LEFT		      0
      - [  2, 367823,	0,   0,       0] # ------------ SYN_REPORT (0) ---------- +1160ms
    # 当前时间是 12:32:00
    - evdev:
      - [  3, 247617,	4,   4,      30] # EV_MSC / MSC_SCAN		     30 (已模糊处理)
      - [  3, 247617,	1, 273,       0] # EV_KEY / BTN_RIGHT		      0
      - [  3, 247617,   0,   0,       0] # ------------ SYN_REPORT (0) ---------- +880ms

注意：如果您的系统上没有 ``libinput record``，可以尝试使用 ``evemu-record``。

当某些功能不正常时
============================

设备表现不正确可能有多种原因。例如，

* HID 设备提供的 HID 报告描述符可能错误，因为例如：
* 它不符合标准，因此内核无法理解 HID 报告描述符；
* HID 报告描述符与设备实际发送的数据**不匹配**（这可以通过读取原始 HID 数据来验证）；
* HID 报告描述符可能需要一些“异常特性(quirks)”（见下文）
作为结果，可能不会为每个“应用集合”创建一个 ``/dev/input/event*``，或者其中的事件可能与您预期的不同。
异常特性(quirks)
------------------

有一些 HID 设备的已知特殊性，内核知道如何修复——这些被称为 HID 异常特性，并且在 `include/linux/hid.h` 中有一份列表。
如果是这种情况，只需在内核中为手头的 HID 设备添加所需的异常特性即可。这可以在文件 `drivers/hid/hid-quirks.c` 中完成。查看此文件后，如何操作应该相对直接。
从 `include/linux/hid.h` 获取的当前定义的异常特性列表如下：

.. kernel-doc:: include/linux/hid.h
   :doc: HID 异常特性

USB 设备的异常特性可以在加载 usbhid 模块时指定，参见 ``modinfo usbhid``，尽管正确的修复应放入 hid-quirks.c 并**提交上游**
参阅 Documentation/process/submitting-patches.rst 了解如何提交补丁的指南。其他总线的异常特性需要进入 hid-quirks.c
修复 HID 报告描述符
-----------------------------

如果您需要修补 HID 报告描述符，最简单的方法是使用 eBPF，如 Documentation/hid/hid-bpf.rst 所述。
基本上，您可以更改原始 HID 报告描述符中的任何字节。samples/hid 中的例子应该是您编写代码的一个很好的起点，例如 `samples/hid/hid_mouse.bpf.c`:

  SEC("fmod_ret/hid_bpf_rdesc_fixup")
  int BPF_PROG(hid_rdesc_fixup, struct hid_bpf_ctx *hctx)
  {
    ...
```cpp
// 将data数组的第39个元素设置为0x31
data[39] = 0x31;
// 将data数组的第41个元素设置为0x30
data[41] = 0x30;
// 函数返回值为0，表示成功或无错误
return 0;
```

当然，这也可以在内核源代码中完成，例如可以参考`drivers/hid/hid-aureal.c` 或者 `drivers/hid/hid-samsung.c` 文件，它们处理的是稍微复杂一点的情况。
如果你需要帮助理解HID手册以及HID报告描述符十六进制数字的确切含义，请查阅`Documentation/hid/hidreport-parsing.rst`。

无论你提出什么解决方案，请记住**将修复提交给HID维护者**，这样就可以直接将其集成到内核中，让那个特定的HID设备对其他人也能正常工作。关于如何进行提交，请参阅`Documentation/process/submitting-patches.rst`中的指导原则。

实时修改传输数据
------------------

使用eBPF也可以实现在与设备交换数据时修改数据。同样地，可以参考`samples/hid`中的示例。
再次强调，**请分享你的修复方案**，以便它可以被整合入内核！

编写专门的驱动程序
-------------------

这应该是你最后的选择

.. rubric:: 脚注

.. [#hidraw] 阅读hidraw: 参见`Documentation/hid/hidraw.rst`和示例文件`samples/hidraw/hid-example.c`
对于同一款鼠标，`hid-example`的输出结果如下所示：

```
$ sudo ./hid-example
Report Descriptor Size: 52
Report Descriptor:
5 1 9 2 a1 1 9 1 a1 0 5 9 19 1 29 3 15 0 25 1 75 1 95 3 81 2 75 5 95 1 81 1 5 1 9 30 9 31 9 38 15 81 25 7f 75 8 95 3 81 6 c0 c0

Raw Name: PixArt USB Optical Mouse
Raw Phys: usb-0000:05:00.4-2.3/input0
Raw Info:
        bustype: 3 (USB)
        vendor: 0x093a
        product: 0x2510
```
```
