HID I/O传输驱动程序
=========================

HID子系统独立于底层的传输驱动程序。起初，仅支持USB，但其他规范采纳了HID设计并提供了新的传输驱动程序。内核至少包括对USB、蓝牙、I2C和用户空间I/O驱动程序的支持。
1) HID总线
==========

HID子系统被设计为一个总线。任何I/O子系统都可以提供HID设备，并将其注册到HID总线上。然后，HID核心会在其上加载通用设备驱动程序。传输驱动程序负责原始数据传输和设备设置/管理。HID核心负责报告解析、报告解释和用户空间API。根据特性的不同，设备特性和特殊处理由所有层处理。

```
+-----------+  +-----------+            +-----------+  +-----------+
| 设备#1   |  | 设备#i   |            | 设备#j   |  | 设备#k   |
+-----------+  +-----------+            +-----------+  +-----------+
         \\      //                              \\      //
       +------------+                          +------------+
       | I/O 驱动程序 |                          | I/O 驱动程序 |
       +------------+                          +------------+
            ||                                      ||
    +------------------+                    +------------------+
    | 传输驱动程序  |                    | 传输驱动程序  |
    +------------------+                    +------------------+
                        \___                ___/
                            \              /
                           +----------------+
                           |    HID 核心    |
                           +----------------+
                            /  |        |  \
                           /   |        |   \
             ____________/    |        |    \_________________
            /                 |        |                      \
           /                  |        |                       \
+----------------+  +-----------+  +------------------+  +------------------+
| 通用驱动程序 |  | MT 驱动程序 |  | 自定义驱动程序#1 |  | 自定义驱动程序#2 |
+----------------+  +-----------+  +------------------+  +------------------+
```

示例驱动程序：

- I/O：USB、I2C、蓝牙-l2cap
- 传输：USB-HID、I2C-HID、BT-HIDP

此图表中"HID核心"以下的所有内容都进行了简化，因为这仅与HID设备驱动程序相关。传输驱动程序无需知道具体细节。
1.1) 设备设置
-----------------

I/O驱动程序通常向传输驱动程序提供热插拔检测或设备枚举API。传输驱动程序使用这些来查找任何合适的HID设备。他们分配HID设备对象并将其注册到HID核心。传输驱动程序不需要向HID核心注册自己。HID核心永远不会意识到哪些传输驱动程序可用，也不对此感兴趣。它只对设备感兴趣。

传输驱动程序将一个常量"struct hid_ll_driver"对象与每个设备关联。一旦设备注册到HID核心，通过此结构提供的回调将由HID核心用于与设备通信。

传输驱动程序负责检测设备故障和拔出。只要设备已注册，无论发生任何设备故障，HID核心都会继续操作设备。一旦传输驱动程序检测到拔出或故障事件，它们必须从HID核心注销设备，HID核心将停止使用提供的回调。
1.2) 传输驱动程序要求
----------------------------------

本文档中的术语"异步"和"同步"描述了关于确认的传输行为。异步通道不得执行任何同步操作，如等待确认或验证。通常，HID在异步通道上的调用必须在原子上下文中运行。

另一方面，同步通道可以由传输驱动程序以任何方式实现。它们可能与异步通道相同，但它们也可以以阻塞方式提供确认报告、自动重传失败等功能。如果需要在异步通道上实现此类功能，传输驱动程序必须通过其自己的工作线程实现。
HID核心要求传输驱动遵循特定的设计。每个HID设备，传输驱动必须提供两个双向I/O通道。这些通道并不一定需要在硬件本身上是双向的。一个传输驱动可能仅仅提供四个单向通道，或者将所有四个通道复用在单一物理通道上。然而，在本文档中，我们将它们描述为两个双向通道，因为它们有许多共同的特性：

- 中断通道（intr）：中断通道用于异步数据报告。在这个通道上不发送任何管理命令或数据确认。任何未请求的进出数据报告必须通过这个通道发送，并且永远不会被远程端确认。设备通常通过这个通道发送它们的输入事件。除了需要高吞吐量的情况外，输出事件一般不会通过中断通道发送。
- 控制通道（ctrl）：控制通道用于同步请求和设备管理。未请求的数据输入事件不应该通过这个通道发送，通常会被忽略。相反，设备只在这个通道上发送管理事件或对主机请求的响应。
控制通道用于直接对设备进行阻塞查询，独立于中断通道上的任何事件。
输出报告通常通过同步的SET_REPORT请求在控制通道上发送。

设备与HID核心之间的通信主要通过HID报告进行。报告可以是以下三种类型之一：

- 输入报告：输入报告从设备向主机提供数据。这些数据可能包括按钮事件、轴事件、电池状态等。这些数据由设备生成，无论是否需要明确请求，都会发送到主机。设备可以选择连续发送数据或仅在数据变化时发送。
- 输出报告：输出报告改变设备状态。它们从主机发送到设备，可能包括LED请求、震动请求等。输出报告永远不会从设备发送到主机，但主机可以检索它们的当前状态。
主机可以选择连续发送输出报告或仅在数据变化时发送。
- 特性报告：特性报告用于访问特定的静态设备特性，从不自发报告。主机可以读取和/或写入它们以访问如电池状态或设备设置等数据。
特性报告永远不会在没有请求的情况下发送。主机必须显式地设置或检索一个特性报告。这也意味着，特性报告永远不会在中断通道上发送，因为该通道是异步的。
输入（INPUT）和输出（OUTPUT）报告可以作为纯数据报告通过中断（intr）通道发送。对于输入报告，这是常规的操作模式。但对于输出报告，很少这样做，因为输出报告通常很少发生。但设备可以自由地过度使用异步输出报告（例如，自定义HID音频扬声器大量使用这种方式）。
不过，纯报告不得通过控制（ctrl）通道发送。相反，控制通道提供了同步的GET/SET_REPORT请求。纯报告仅允许在中断通道上发送，并且是该通道上唯一的数据传输方式。
- GET_REPORT: GET_REPORT请求包含一个报告ID作为负载，并从主机发送到设备。设备必须通过控制通道以一个数据报告作为同步确认来响应请求的报告ID。
每个设备只能有一个待处理的GET_REPORT请求。此限制由HID核心强制执行，因为许多传输驱动程序不允许多个同时的GET_REPORT请求。
需要注意的是，作为对GET_REPORT请求响应而发送的数据报告不会被当作通用设备事件处理。也就是说，如果设备不处于连续数据报告模式，那么GET_REPORT的响应并不会在状态改变时替代中断通道上的原始数据报告。
GET_REPORT主要用于自定义HID设备驱动程序查询设备状态。通常情况下，HID核心会缓存任何设备状态，因此除非在设备初始化期间为了获取当前状态，否则这种请求通常是不必要的。
GET_REPORT请求可以针对三种报告类型中的任意一种发送，并应返回设备当前的报告状态。但是，如果规范不允许，则底层传输驱动程序可能会阻止以输出报告作为负载。
- SET_REPORT: SET_REPORT请求包含一个报告ID和数据作为负载。它从主机发送到设备，并且设备必须根据提供的数据更新其当前报告状态。三种报告类型中的任何一种都可以使用。但是，如果规范不允许，则底层传输驱动程序可能会阻止以输入报告作为负载。
设备必须以同步确认进行响应。然而，HID核心并不要求传输驱动程序将此确认转发给HID核心。

与GET_REPORT相同，一次只能有一个待处理的SET_REPORT。这一限制由HID核心执行，因为某些传输驱动程序不支持多个同步SET_REPORT请求。
其他控制信道请求在USB-HID中得到支持，但在大多数其他传输级别的规范中不可用（或已废弃）：

- GET/SET_IDLE：仅被USB-HID和I2C-HID使用
- GET/SET_PROTOCOL：HID核心未使用
- RESET：I2C-HID使用，但HID核心未连接
- SET_POWER：I2C-HID使用，但HID核心未连接
2) HID API
==========

2.1) 初始化
--------------

传输驱动程序通常采用以下过程来向HID核心注册新设备：

```c
struct hid_device *hid;
int ret;

hid = hid_allocate_device();
if (IS_ERR(hid)) {
    ret = PTR_ERR(hid);
    goto err_<...>;
}

strscpy(hid->name, <device-name-src>, sizeof(hid->name));
strscpy(hid->phys, <device-phys-src>, sizeof(hid->phys));
strscpy(hid->uniq, <device-uniq-src>, sizeof(hid->uniq));

hid->ll_driver = &custom_ll_driver;
hid->bus = <device-bus>;
hid->vendor = <device-vendor>;
hid->product = <device-product>;
hid->version = <device-version>;
hid->country = <device-country>;
hid->dev.parent = <pointer-to-parent-device>;
hid->driver_data = <transport-driver-data-field>;

ret = hid_add_device(hid);
if (ret)
    goto err_<...>;
```

一旦hid_add_device()被调用，HID核心可能会使用“custom_ll_driver”中提供的回调。请注意，像“country”这样的字段如果不受支持，则可以被底层传输驱动程序忽略。
要注销设备，请使用：

```c
hid_destroy_device(hid);
```

hid_destroy_device()返回后，HID核心将不再使用任何驱动回调。
2.2) hid_ll_driver操作
-----------------------------

可用的HID回调如下：

```c
int (*start) (struct hid_device *hdev)
```

当HID设备驱动程序想要使用设备时调用。传输驱动程序可以选择在此回调中设置其设备。然而，通常在传输驱动程序向HID核心注册它们之前，设备就已经设置好了，因此这主要被USB-HID使用。
```c
void (*stop) (struct hid_device *hdev)
```

当HID设备驱动程序完成对设备的使用时调用。传输驱动程序可以释放任何缓冲区并初始化设备。但是请注意，如果另一个HID设备驱动程序在设备上加载，->start()可能会再次被调用。
以下是给定英文文本的中文翻译：

运输驱动程序可以自由地忽略它，并在通过hid_destroy_device()销毁设备后对其进行去初始化。

:: 

      int (*open) (struct hid_device *hdev)

当HID设备驱动程序对其数据报告感兴趣时，将从它们调用此函数。
通常，在用户空间未打开任何输入API等的情况下，设备驱动程序对设备数据不感兴趣，运输驱动程序可以让设备进入睡眠状态。
然而，一旦调用了->open()，运输驱动程序必须为I/O做好准备。
->open()调用对于每个打开HID设备的客户端都是嵌套的。

:: 

      void (*close) (struct hid_device *hdev)

当->open()被调用，但HID设备驱动程序不再对设备报告感兴趣时（通常是在用户空间关闭了驱动程序的任何输入设备之后），将从HID设备驱动程序中调用此函数。
如果所有->open()调用都已由一个->close()调用跟随，运输驱动程序可以让设备进入睡眠状态并终止所有I/O。
但是，如果设备驱动程序再次对输入报告感兴趣，可能再次调用->start()。

:: 

      int (*parse) (struct hid_device *hdev)

在设备设置过程中仅调用一次，位于->start()调用之后。运输驱动程序必须从设备读取HID报告描述符，并通过hid_parse_report()告诉HID核心。

:: 

      int (*power) (struct hid_device *hdev, int level)

由HID核心调用，以向运输驱动程序提供PM提示。这通常类似于->open()和->close()的提示，且是冗余的。

:: 

      void (*request) (struct hid_device *hdev, struct hid_report *report,
		       int reqtype)

在ctrl通道上发送HID请求。“report”包含要发送的报告，“reqtype”是请求类型。请求类型可以是HID_REQ_SET_REPORT或HID_REQ_GET_REPORT。
此回调是可选的。如果没有提供，HID 核心将根据 HID 规范组装原始报告并通过 `->raw_request()` 回调发送。
传输驱动程序可以异步实现此功能。

```
int (*wait)(struct hid_device *hdev);
```

在再次调用 `->request()` 前由 HID 核心使用。如果一次只允许一个请求，传输驱动程序可以使用它来等待任何待处理的请求完成。

```
int (*raw_request)(struct hid_device *hdev, unsigned char reportnum,
                   __u8 *buf, size_t count, unsigned char rtype,
                   int reqtype);
```

与 `->request()` 相同，但以原始缓冲区形式提供报告。此请求应为同步。传输驱动程序不得使用 `->wait()` 来完成此类请求。此请求是强制性的，如果缺少，HID 核心将拒绝设备。

```
int (*output_report)(struct hid_device *hdev, __u8 *buf, size_t len);
```

通过中断通道发送原始输出报告。被某些需要高吞吐量用于中断通道上发出请求的 HID 设备驱动程序使用。这不得引起 SET_REPORT 调用！必须作为中断通道上的异步输出报告实现！

```
int (*idle)(struct hid_device *hdev, int report, int idle, int reqtype);
```

执行 SET/GET_IDLE 请求。仅由 USB-HID 使用，不要实现！

### 2.3 数据路径

传输驱动程序负责从 I/O 设备读取数据。它们必须自行处理所有与 I/O 相关的状态跟踪。HID 核心不实现协议握手或其他可能由给定的 HID 传输规范要求的管理命令。
从设备读取的每个原始数据包都必须通过 `hid_input_report()` 提供给 HID 核心。你必须指定通道类型（中断或控制）和报告类型（输入/输出/特性）。在正常情况下，只有输入报告通过此 API 提供。
对通过 `->request()` 的 GET_REPORT 请求的响应也必须通过此 API 提供。对 `->raw_request()` 的响应是同步的，并且必须由传输驱动程序拦截，而不是传递给 `hid_input_report()`。
对 SET_REPORT 请求的确认对 HID 核心没有兴趣。

---
撰写于 2013 年，作者：David Herrmann <dh.herrmann@gmail.com>
