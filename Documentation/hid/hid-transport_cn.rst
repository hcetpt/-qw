=========================
HID I/O传输驱动程序
=========================

HID子系统独立于底层传输驱动程序。最初，只支持USB，但其他规范采用了HID设计并提供了新的传输驱动程序。内核至少支持USB、蓝牙、I2C和用户空间I/O驱动程序。
1) HID总线
==========

HID子系统被设计为一个总线。任何I/O子系统都可以提供HID设备并将其注册到HID总线上。HID核心随后在其上加载通用设备驱动程序。传输驱动程序负责原始数据传输和设备设置/管理。HID核心负责报告解析、报告解释和用户空间API。设备特性和异常由各层根据具体情况处理。

```
+-----------+  +-----------+            +-----------+  +-----------+
| 设备#1    |  | 设备#i    |            | 设备#j    |  | 设备#k    |
+-----------+  +-----------+            +-----------+  +-----------+
          \\      //                              \\      //
        +------------+                          +------------+
        | I/O驱动程序 |                          | I/O驱动程序 |
        +------------+                          +------------+
              ||                                      ||
     +------------------+                    +------------------+
     | 传输驱动程序     |                    | 传输驱动程序     |
     +------------------+                    +------------------+
                       \___                ___/
                           \              /
                          +----------------+
                          |    HID核心     |
                          +----------------+
                           /  |        |  \
                          /   |        |   \
             ____________/    |        |    \_________________
            /                 |        |                      \
           /                  |        |                       \
 +----------------+  +-----------+  +------------------+  +------------------+
 | 通用驱动程序   |  | 多点触摸驱动 |  | 自定义驱动程序#1 |  | 自定义驱动程序#2 |
 +----------------+  +-----------+  +------------------+  +------------------+
```

示例驱动程序：

- I/O：USB、I2C、蓝牙-l2cap
- 传输：USB-HID、I2C-HID、BT-HIDP

图表中“HID核心”以下的部分进行了简化，因为这部分内容仅对HID设备驱动程序感兴趣。传输驱动程序不需要知道具体细节。

1.1) 设备设置
-----------------

I/O驱动程序通常向传输驱动程序提供热插拔检测或设备枚举API。传输驱动程序使用这些API来查找任何合适的HID设备。它们分配HID设备对象并将其注册到HID核心。传输驱动程序不需要注册自己到HID核心。HID核心从不关心哪些传输驱动程序可用，并且对此不感兴趣，它只关心设备。

传输驱动程序为每个设备附加一个常量的`struct hid_ll_driver`对象。一旦设备注册到HID核心，通过该结构提供的回调函数将用于HID核心与设备通信。

传输驱动程序负责检测设备故障并拔除设备。只要设备已注册，无论设备是否发生故障，HID核心都会继续操作该设备。一旦传输驱动程序检测到拔除或故障事件，它们必须从HID核心注销该设备，HID核心将停止使用提供的回调函数。

1.2) 传输驱动程序要求
----------------------------------

本文档中的“异步”和“同步”术语描述了与确认相关的传输行为。异步通道不应执行任何同步操作，如等待确认或验证。一般来说，HID在异步通道上的调用必须能够在原子上下文中运行。

另一方面，同步通道可以由传输驱动程序以任何方式实现。它们可能与异步通道相同，但也可能提供确认报告、自动重传等功能。如果需要在异步通道上实现这样的功能，传输驱动程序必须通过自己的工作线程来实现。
HID 核心要求传输驱动程序遵循特定的设计。每个 HID 设备的传输驱动程序必须提供两个双向 I/O 通道。这些通道不一定需要在硬件本身上是双向的。一个传输驱动程序可能只提供四个单向通道，或者将所有四个通道复用到一个物理通道上。然而，在本文档中，我们将描述它们为两个双向通道，因为它们具有许多共同特性。

- 中断通道（intr）：中断通道用于异步数据报告。在此通道上不发送管理命令或数据确认。任何未请求的传入或传出数据报告必须通过此通道发送，并且从不被远端确认。设备通常会通过此通道发送其输入事件。除非需要高吞吐量，否则传出事件通常不会通过中断通道发送。
- 控制通道（ctrl）：控制通道用于同步请求和设备管理。未请求的数据输入事件不应通过此通道发送，并且通常会被忽略。相反，设备仅在此通道上发送管理事件或对主机请求的回答。
控制通道用于直接阻塞查询设备，与中断通道上的任何事件无关。
传出报告通常通过同步的 SET_REPORT 请求通过控制通道发送。

设备与 HID 核心之间的通信主要通过 HID 报告完成。报告可以是以下三种类型之一：

- 输入报告（INPUT Report）：输入报告提供从设备到主机的数据。这些数据可能包括按钮事件、轴事件、电池状态等。这些数据由设备生成并发送给主机，无论是否需要显式请求。设备可以选择连续发送数据或仅在变化时发送。
- 输出报告（OUTPUT Report）：输出报告改变设备状态。它们从主机发送到设备，可能包括 LED 请求、振动请求等。输出报告从未从设备发送到主机，但主机可以检索其当前状态。
主机可以选择连续发送输出报告或仅在变化时发送。
- 特性报告（FEATURE Report）：特性报告用于特定的静态设备特性，从不自发报告。主机可以读取和/或写入它们以访问诸如电池状态或设备设置等数据。
特性报告从不无请求地发送。主机必须明确设置或检索一个特性报告。这也意味着特性报告从不在中断通道上发送，因为该通道是异步的。
输入和输出报告可以通过内部通道作为纯数据报告发送。对于输入报告，这是通常的操作模式。但对于输出报告，这种情况很少发生，因为输出报告通常非常稀少。然而，设备可以大量使用异步输出报告（例如，自定义的HID音频扬声器就经常使用这种方式）。

纯报告不得通过控制通道发送。相反，控制通道提供同步的GET/SET_REPORT请求。纯报告仅允许在内部通道发送，并且是该通道上的唯一数据传输方式。

- GET_REPORT：GET_REPORT请求包含一个报告ID作为负载，并从主机发送到设备。设备必须在控制通道上以同步确认的方式用对应报告ID的数据报告来回应。
每个设备只能有一个待处理的GET_REPORT请求。这一限制由HID核心强制执行，因为许多传输驱动程序不允许同时存在多个GET_REPORT请求。
需要注意的是，作为对GET_REPORT请求回应的数据报告不会被当作通用设备事件处理。也就是说，如果设备不处于连续数据报告模式，那么GET_REPORT请求的回应不会在状态改变时替代内部通道上的原始数据报告。
GET_REPORT主要用于自定义HID设备驱动程序查询设备状态。通常情况下，HID核心会缓存任何设备状态，因此除了在设备初始化期间获取当前状态外，这个请求通常是不必要的。
GET_REPORT请求可以针对三种报告类型中的任意一种发送，并应返回设备当前的报告状态。但是，如果规范不允许，则底层传输驱动程序可能会阻止输出报告作为负载。

- SET_REPORT：SET_REPORT请求包含一个报告ID加上数据作为负载。它从主机发送到设备，设备必须根据提供的数据更新其当前报告状态。可以使用三种报告类型中的任意一种。但是，如果规范不允许，则底层传输驱动程序可能会阻止输入报告作为负载。
### 2) HID API
#### 2.1) 初始化
传输驱动程序通常使用以下过程来向HID核心注册一个新设备：

```c
struct hid_device *hid;
int ret;

hid = hid_allocate_device();
if (IS_ERR(hid)) {
    ret = PTR_ERR(hid);
    goto err_<...>;
}

strscpy(hid->name, <device-name-src>, sizeof(hid->name));
strscpy(hid->phys, <device-phys-src>, sizeof(hid->phys));
strscpy(hid->uniq, <device-uniq-src>, sizeof(hid->uniq));

hid->ll_driver = &custom_ll_driver;
hid->bus = <device-bus>;
hid->vendor = <device-vendor>;
hid->product = <device-product>;
hid->version = <device-version>;
hid->country = <device-country>;
hid->dev.parent = <pointer-to-parent-device>;
hid->driver_data = <transport-driver-data-field>;

ret = hid_add_device(hid);
if (ret)
    goto err_<...>;
```

一旦调用`hid_add_device()`，HID核心可能会使用在`custom_ll_driver`中提供的回调函数。请注意，“country”等字段如果不受支持，则底层传输驱动程序可以忽略它们。

要注销一个设备，请使用：

```c
hid_destroy_device(hid);
```

一旦`hid_destroy_device()`返回，HID核心将不再使用任何驱动回调函数。

#### 2.2) hid_ll_driver 操作
可用的HID回调函数如下：

```c
int (*start)(struct hid_device *hdev)
```

当HID设备驱动程序想要使用设备时调用。传输驱动程序可以选择在此回调函数中设置其设备。然而，通常设备在传输驱动程序向HID核心注册之前就已经设置好了，因此这主要由USB-HID使用。

```c
void (*stop)(struct hid_device *hdev)
```

当HID设备驱动程序完成对设备的使用时调用。传输驱动程序可以释放任何缓冲区并初始化设备。但请注意，如果另一个HID设备驱动程序加载到该设备上，`->start()`可能会再次被调用。

### 其他信息
- 设备必须以同步确认的方式作出回应。但是，HID核心不要求传输驱动程序将此确认转发给HID核心。
- 对于`GET_REPORT`，一次只能有一个`SET_REPORT`请求待处理。这一限制由HID核心强制执行，因为某些传输驱动程序不支持多个同步的`SET_REPORT`请求。
- 其他控制信道请求虽然由USB-HID支持，但在大多数其他传输级别的规范中不可用或已弃用：
  - `GET/SET_IDLE`：仅用于USB-HID和I2C-HID。
  - `GET/SET_PROTOCOL`：不用于HID核心。
  - `RESET`：用于I2C-HID，在HID核心中未连接。
  - `SET_POWER`：用于I2C-HID，在HID核心中未连接。
### 翻译

#### 1. 运输驱动程序可以忽略这一点，并在通过 `hid_destroy_device()` 销毁设备后解除初始化设备。

```
int (*open) (struct hid_device *hdev)
```

HID 设备驱动程序在其对数据报告感兴趣时调用。通常，在用户空间没有打开任何输入 API 等时，设备驱动程序不对设备数据感兴趣，运输驱动程序可以让设备进入休眠状态。然而，一旦 `->open()` 被调用，运输驱动程序必须准备好进行 I/O 操作。对于每个打开 HID 设备的客户端，`->open()` 调用是嵌套的。

```
void (*close) (struct hid_device *hdev)
```

HID 设备驱动程序在其调用了 `->open()` 但不再对设备报告感兴趣时调用（通常是在用户空间关闭了任何输入设备时）。如果所有 `->open()` 调用都由 `->close()` 调用跟随，则运输驱动程序可以让设备进入休眠状态并终止所有 I/O。然而，如果设备驱动程序再次对输入报告感兴趣，`->start()` 可能会被再次调用。

```
int (*parse) (struct hid_device *hdev)
```

在设备设置过程中调用一次，即 `->start()` 被调用之后。运输驱动程序必须从设备读取 HID 报告描述符并通过 `hid_parse_report()` 告知 HID 核心。

```
int (*power) (struct hid_device *hdev, int level)
```

由 HID 核心调用，向运输驱动程序提供电源管理提示。通常这类似于 `->open()` 和 `->close()` 的提示，且是冗余的。

```
void (*request) (struct hid_device *hdev, struct hid_report *report, int reqtype)
```

在控制信道上发送一个 HID 请求。“report” 包含要发送的报告，“reqtype” 是请求类型。请求类型可以是 `HID_REQ_SET_REPORT` 或 `HID_REQ_GET_REPORT`。
### 2.3 数据路径

#### 回调函数是可选的。如果没有提供，HID 核心将根据 HID 规范组装一个原始报告并通过 `->raw_request()` 回调发送。

传输驱动程序可以异步实现此功能：

```c
int (*wait)(struct hid_device *hdev);
```

HID 核心在再次调用 `->request()` 之前使用此回调。如果一次只允许一个请求，则传输驱动程序可以使用它来等待任何待处理请求完成：

```c
int (*raw_request)(struct hid_device *hdev, unsigned char reportnum,
                   __u8 *buf, size_t count, unsigned char rtype,
                   int reqtype);
```

与 `->request()` 相同，但提供原始缓冲区形式的报告。此请求必须是同步的。传输驱动程序不得使用 `->wait()` 来完成此类请求。此请求是强制性的，如果缺少则 HID 核心会拒绝该设备：

```c
int (*output_report)(struct hid_device *hdev, __u8 *buf, size_t len);
```

通过中断通道发送原始输出报告。某些需要高吞吐量的 HID 设备驱动程序会在中断通道上使用此功能。这不应导致 SET_REPORT 调用！必须将其实现为中断通道上的异步输出报告！

```c
int (*idle)(struct hid_device *hdev, int report, int idle, int reqtype);
```

执行 SET/GET_IDLE 请求。仅用于 USB-HID，不要实现！

### 2.3 数据路径

传输驱动程序负责从 I/O 设备读取数据。它们必须自行处理任何与 I/O 相关的状态跟踪。HID 核心不实现协议握手或其他可能由给定 HID 传输规范要求的管理命令。
从设备读取的每个原始数据包都必须通过 `hid_input_report()` 提供给 HID 核心。您必须指定通道类型（中断或控制）和报告类型（输入/输出/特征）。在正常情况下，此 API 只提供输入报告。
通过 `->request()` 对 GET_REPORT 请求的响应也必须通过此 API 提供。对 `->raw_request()` 的响应是同步的，必须由传输驱动程序拦截，而不是传递给 `hid_input_report()`。
对 SET_REPORT 请求的确认对 HID 核心没有兴趣。

---
编写于 2013 年，David Herrmann <dh.herrmann@gmail.com>
