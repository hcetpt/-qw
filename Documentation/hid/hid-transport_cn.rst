HID I/O 传输驱动程序
=========================

HID 子系统独立于底层的传输驱动程序。最初，仅支持 USB，但其他规范采用了 HID 设计并提供了新的传输驱动程序。内核至少支持 USB、蓝牙、I2C 和用户空间 I/O 驱动程序。
1) HID 总线
===========

HID 子系统被设计为一个总线。任何 I/O 子系统都可以提供 HID 设备并将其注册到 HID 总线上。HID 核心随后在其上加载通用设备驱动程序。传输驱动程序负责原始数据传输和设备设置/管理。HID 核心负责报告解析、报告解释和用户空间 API。根据特性，设备特性和异常由所有层处理。

```
+-----------+  +-----------+            +-----------+  +-----------+
| 设备 #1   |  | 设备 #i   |            | 设备 #j   |  | 设备 #k   |
+-----------+  +-----------+            +-----------+  +-----------+
          \\      //                              \\      //
        +------------+                          +------------+
        | I/O 驱动程序 |                          | I/O 驱动程序 |
        +------------+                          +------------+
              ||                                      ||
     +------------------+                    +------------------+
     | 传输驱动程序   |                    | 传输驱动程序   |
     +------------------+                    +------------------+
                       \___                ___/
                           \              /
                          +----------------+
                          |    HID 核心    |
                          +----------------+
                           /  |        |  \
                          /   |        |   \
             ____________/    |        |    \_________________
            /                 |        |                      \
           /                  |        |                       \
 +----------------+  +-----------+  +------------------+  +------------------+
 | 通用驱动程序  |  | MT 驱动程序 |  | 自定义驱动程序 #1 |  | 自定义驱动程序 #2 |
 +----------------+  +-----------+  +------------------+  +------------------+
```

示例驱动程序：

- I/O：USB、I2C、蓝牙-l2cap
- 传输：USB-HID、I2C-HID、BT-HIDP

此图中，“HID 核心”以下的内容被简化了，因为它只对 HID 设备驱动程序感兴趣。传输驱动程序不需要知道具体细节。
1.1) 设备设置
---------------

I/O 驱动程序通常为传输驱动程序提供热插拔检测或设备枚举 API。传输驱动程序使用这些 API 来查找任何合适的 HID 设备。它们分配 HID 设备对象并将其注册到 HID 核心。传输驱动程序无需向 HID 核心注册自身。HID 核心永远不会意识到有哪些传输驱动程序可用，并对此不感兴趣。它只对设备感兴趣。

传输驱动程序为每个设备附加一个常量 “struct hid_ll_driver” 对象。一旦设备注册到 HID 核心，通过该结构提供的回调函数将用于 HID 核心与设备之间的通信。

传输驱动程序负责检测设备故障和拔除。只要设备注册在 HID 核心中，无论设备是否出现故障，HID 核心都会继续操作该设备。一旦传输驱动程序检测到拔除或故障事件，它们必须从 HID 核心中注销该设备，HID 核心将停止使用所提供的回调函数。
1.2) 传输驱动程序要求
-----------------------

本文档中的“异步”和“同步”术语描述了关于确认的行为。异步通道不得执行任何同步操作，如等待确认或验证。通常，在异步通道上运行的 HID 调用必须能够在原子上下文中正常运行。

另一方面，同步通道可以由传输驱动程序以任何方式实现。它们可能与异步通道相同，但也可能提供确认报告、自动重传失败等功能，并以阻塞方式实现。如果在异步通道上需要此类功能，则传输驱动程序必须通过其自己的工作线程来实现这一点。
HID 核心要求传输驱动遵循特定的设计。一个传输驱动必须为每个 HID 设备提供两个双向 I/O 通道。这些通道并不一定需要在硬件本身上就是双向的。一个传输驱动可能仅提供四个单向通道，或者它可能将这四个通道复用到单一物理通道上。然而，在本文档中，我们将描述它们为两个双向通道，因为它们有许多共同的特性。

- **中断通道（intr）**：中断通道用于异步数据报告。在这个通道上不发送任何管理命令或数据确认。任何未请求的传入或传出的数据报告都必须通过这个通道发送，并且永远不会被远程端确认。设备通常会通过这个通道发送其输入事件。除了需要高吞吐量的情况外，输出事件一般不会通过中断通道发送。
- **控制通道（ctrl）**：控制通道用于同步请求和设备管理。未请求的数据输入事件不应通过此通道发送，通常会被忽略。相反，设备只通过此通道发送管理事件或对主机请求的响应。
控制通道用于直接阻塞查询设备，与中断通道上的任何事件无关。
输出报告通常是通过同步的 `SET_REPORT` 请求经由控制通道发送。

设备与 HID 核心之间的通信主要通过 HID 报告完成。一个报告可以是以下三种类型之一：

- **输入报告（INPUT Report）**：输入报告从设备向主机提供数据。这些数据可能包括按钮事件、轴事件、电池状态等。这些数据由设备生成并发送给主机，无论是否需要显式请求。设备可以选择连续发送数据或仅在发生变化时发送。
- **输出报告（OUTPUT Report）**：输出报告用于改变设备状态。它们从主机发送至设备，可能包括 LED 请求、震动请求等。输出报告永远不会从设备发送给主机，但主机可以检索其当前状态。
主机可以选择连续发送输出报告或仅在发生变化时发送。
- **特征报告（FEATURE Report）**：特征报告用于表示设备的特定静态特性，且不会自发报告。主机可以通过读取或写入特征报告来访问诸如电池状态或设备设置等数据。
特征报告永远不会在没有请求的情况下发送。主机必须明确地设置或检索特征报告。这也意味着，特征报告永远不会通过中断通道发送，因为该通道是异步的。
输入（INPUT）和输出（OUTPUT）报告可以作为纯数据报告通过中断（intr）通道发送。对于输入报告，这是常规的操作模式。但对于输出报告，这种情况很少见，因为输出报告通常非常稀少。不过，设备可以大量使用异步输出报告（例如，自定义HID音频扬声器就大量使用这种方式）。

但是，纯报告不得通过控制（ctrl）通道发送。相反，控制通道提供了同步的GET/SET_REPORT请求。纯报告仅允许在中断通道上发送，并且是该通道上唯一的数据传输方式。

- GET_REPORT：GET_REPORT请求包含一个报告ID作为负载，并从主机发送到设备。设备必须通过控制通道以同步确认的方式回应所请求报告ID的数据报告。
每个设备只能有一个待处理的GET_REPORT请求。此限制由HID核心强制执行，因为许多传输驱动程序不允许同时存在多个GET_REPORT请求。
需要注意的是，作为对GET_REPORT请求响应而发送的数据报告不会被当作通用设备事件处理。也就是说，如果设备不处于连续数据报告模式，则GET_REPORT的响应不会在状态改变时替代中断通道上的原始数据报告。
GET_REPORT仅由自定义HID设备驱动程序用于查询设备状态。通常情况下，HID核心会缓存任何设备状态，因此除了在设备初始化期间获取当前状态外，这种请求通常是不必要的。
GET_REPORT请求可以针对三种报告类型中的任意一种发送，并应回应设备当前的报告状态。但是，如果规范不允许的话，底层传输驱动程序可能会阻止将输出报告作为负载。

- SET_REPORT：SET_REPORT请求包含一个报告ID加上数据作为负载。它从主机发送到设备，设备必须根据提供的数据更新其当前的报告状态。可以使用三种报告类型中的任意一种。但是，如果规范不允许的话，底层传输驱动程序可能会阻止将输入报告作为负载。
一个设备必须以同步确认的方式作出响应。然而，HID核心并不要求传输驱动程序将此确认转发给HID核心。

与GET_REPORT相同，一次只能有一个待处理的SET_REPORT请求。这一限制是由HID核心实施的，因为一些传输驱动程序不支持多个同步SET_REPORT请求。
其他USB-HID支持的控制信道请求但在大多数其他传输级别的规范中并不提供（或已废弃）：

- GET/SET_IDLE：仅被USB-HID和I2C-HID使用
- GET/SET_PROTOCOL：HID核心未使用
- RESET：I2C-HID使用，但HID核心未连接
- SET_POWER：I2C-HID使用，但HID核心未连接

2) HID API
==========

2.1) 初始化
-------------------

传输驱动程序通常采用以下步骤来向HID核心注册一个新的设备：

```c
struct hid_device *hid;
int ret;

hid = hid_allocate_device();
if (IS_ERR(hid)) {
    ret = PTR_ERR(hid);
    goto err_<...>;
}

strscpy(hid->name, <device-name-src>, sizeof(hid->name));
strscpy(hid->phys, <device-phys-src>, sizeof(hid->phys));
strscpy(hid->uniq, <device-uniq-src>, sizeof(hid->uniq));

hid->ll_driver = &custom_ll_driver;
hid->bus = <device-bus>;
hid->vendor = <device-vendor>;
hid->product = <device-product>;
hid->version = <device-version>;
hid->country = <device-country>;
hid->dev.parent = <pointer-to-parent-device>;
hid->driver_data = <transport-driver-data-field>;

ret = hid_add_device(hid);
if (ret)
    goto err_<...>;
```

一旦调用hid_add_device()，HID核心可能会使用"custom_ll_driver"中提供的回调函数。请注意，像"country"这样的字段如果不受支持，则可以被底层传输驱动程序忽略。
要注销一个设备，请使用：

```c
hid_destroy_device(hid);
```

hid_destroy_device()返回后，HID核心将不再使用任何驱动程序的回调函数。

2.2) hid_ll_driver 操作
-----------------------------

可用的HID回调函数包括：

```c
int (*start) (struct hid_device *hdev)
```

当希望使用设备时由HID设备驱动程序调用。传输驱动程序可以选择在此回调中设置其设备。但是，通常在传输驱动程序向HID核心注册前设备就已经被设置好，因此这主要由USB-HID使用。

```c
void (*stop) (struct hid_device *hdev)
```

当完成对设备的使用时由HID设备驱动程序调用。传输驱动程序可以释放任何缓冲区并使设备初始化。但需要注意的是，如果另一个HID设备驱动程序加载到该设备上，->start()可能会再次被调用。
运输驱动程序可以自由地忽略这些并使用 `hid_destroy_device()` 销毁设备后进行去初始化。

```c
int (*open) (struct hid_device *hdev)
```

此函数由 HID 设备驱动程序调用，当它们对数据报告感兴趣时。通常，在用户空间未打开任何输入 API 等的情况下，设备驱动程序对设备数据不感兴趣，因此运输驱动程序可以让设备进入休眠状态。
然而，一旦 `->open()` 被调用，运输驱动程序必须准备好进行 I/O 操作。`->open()` 调用对于每个打开 HID 设备的客户端都是嵌套的。

```c
void (*close) (struct hid_device *hdev)
```

此函数由 HID 设备驱动程序调用，在 `->open()` 被调用之后，但它们不再对设备报告感兴趣时（通常是在用户空间关闭了驱动程序的任何输入设备）。如果所有 `->open()` 的调用都已由 `->close()` 调用跟随，则运输驱动程序可以让设备进入休眠状态并终止所有 I/O 操作。然而，如果设备驱动程序再次对输入报告感兴趣，`->start()` 可能会被再次调用。

```c
int (*parse) (struct hid_device *hdev)
```

在设备设置过程中，在 `->start()` 被调用之后调用一次。运输驱动程序必须从设备读取 HID 报告描述符，并通过 `hid_parse_report()` 告知 HID 核心。

```c
int (*power) (struct hid_device *hdev, int level)
```

由 HID 核心调用，为运输驱动程序提供电源管理提示。这通常类似于 `->open()` 和 `->close()` 的提示，并且是冗余的。

```c
void (*request) (struct hid_device *hdev, struct hid_report *report, int reqtype)
```

在控制信道上发送一个 HID 请求。“report” 包含要发送的报告，“reqtype” 是请求类型。请求类型可以是 `HID_REQ_SET_REPORT` 或 `HID_REQ_GET_REPORT`。
此回调函数是可选的。如果没有提供，HID 核心将根据 HID 规范组装原始报告并通过 `->raw_request()` 回调发送它。

传输驱动程序可以异步实现此功能：

``` 
int (*wait)(struct hid_device *hdev);
```

在再次调用 `->request()` 之前由 HID 核心使用。如果仅允许一次一个请求，则传输驱动程序可以使用它来等待任何待处理请求完成。

```
int (*raw_request)(struct hid_device *hdev, unsigned char reportnum,
                   __u8 *buf, size_t count, unsigned char rtype,
                   int reqtype);
```

与 `->request()` 相同，但以原始缓冲区形式提供报告。此请求必须是同步的。传输驱动程序不得使用 `->wait()` 来完成此类请求。此请求是强制性的，如果缺少此请求，HID 核心将拒绝该设备。

```
int (*output_report)(struct hid_device *hdev, __u8 *buf, size_t len);
```

通过中断通道发送原始输出报告。被一些需要高吞吐量用于中断通道外发请求的 HID 设备驱动程序使用。这不得导致 SET_REPORT 调用！这必须实现在中断通道上的异步输出报告！

```
int (*idle)(struct hid_device *hdev, int report, int idle, int reqtype);
```

执行 SET/GET_IDLE 请求。仅由 USB-HID 使用，不要实现！

### 2.3 数据路径

传输驱动程序负责从 I/O 设备读取数据。它们必须自行处理所有与 I/O 相关的状态跟踪。HID 核心不实现协议握手或其他可能由给定 HID 传输规范要求的管理命令。
从设备读取的每个原始数据包都必须通过 `hid_input_report()` 提供给 HID 核心。你必须指定通道类型（中断或控制）和报告类型（输入/输出/特性）。在正常情况下，仅通过此 API 提供输入报告。
通过 `->request()` 对 GET_REPORT 请求的响应也必须通过此 API 提供。对 `->raw_request()` 的响应是同步的，必须由传输驱动程序拦截，而不是传递给 `hid_input_report()`。
SET_REPORT 请求的确认对 HID 核心不感兴趣。

---
编写于 2013 年，作者：David Herrmann <dh.herrmann@gmail.com>
