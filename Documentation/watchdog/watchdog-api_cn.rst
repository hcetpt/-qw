=============================
Linux 监视器驱动程序 API
=============================

最后审阅：2007年10月5日


版权所有 2002 年 Christer Weingel <wingel@nano-system.com>

本文件的部分内容直接引用自 sbc60xxwdt 驱动程序，该驱动程序的版权属于 2000 年 Jakob Oestergaard <jakob@ostenfeld.dk>

本文档描述了 Linux 2.4.18 内核的状态。
============

监视器定时器（WDT）是一种硬件电路，在软件出现故障时可以重置计算机系统。你可能已经知道这一点。
通常，用户空间守护进程会通过特殊设备文件 /dev/watchdog 定期通知内核监视器驱动程序用户空间仍然活跃。当发生此类通知时，驱动程序通常会告诉硬件监视器一切正常，并且监视器应该等待一段时间再重置系统。如果用户空间失败（RAM 错误、内核bug等），这些通知将不再发生，硬件监视器将在超时后重置系统（导致重启）。
Linux 监视器 API 是一个相当临时性的构建，不同的驱动程序实现了不同的、有时不兼容的部分。
此文件试图记录现有的使用情况，并允许未来的驱动程序编写者将其作为参考。
最简单的 API
================

所有驱动程序都支持最基本的运行模式，其中监视器在打开 /dev/watchdog 后激活，并且除非在一定时间内被ping回，否则将重新启动。这段时间称为超时或边际。ping监视器的最简单方法是向设备写入一些数据。因此，一个非常简单的监视器守护进程可能看起来像这样的源文件：请参阅 samples/watchdog/watchdog-simple.c。

更高级的驱动程序可能会在执行写调用来ping监视器之前检查HTTP服务器是否仍在响应。
当设备关闭时，除非支持“魔法关闭”功能（见下文），否则监视器将被禁用。这并不总是个好主意，因为如果监视器守护进程中有bug并且它使系统崩溃，则系统不会重启。正因为如此，一些驱动程序支持配置选项“在关闭时禁用监视器关机”，CONFIG_WATCHDOG_NOWAYOUT。如果在编译内核时将其设置为 Y，则一旦启动就无法禁用监视器。所以，如果监视器守护进程崩溃，系统将在超时后重启。监视器设备还通常支持 nowayout 模块参数，以便可以在运行时控制此选项。
魔法关闭功能
===================

如果驱动程序支持“魔法关闭”，则除非在关闭文件前向 /dev/watchdog 发送特定的魔法字符 'V'，否则驱动程序不会禁用监视器。如果用户空间守护进程在没有发送这个特殊字符的情况下关闭文件，驱动程序将假设守护进程（和用户空间一般）已死亡，并且会在不首先禁用监视器的情况下停止ping监视器。这将导致重启，除非监视器在足够的时间内被重新打开。
ioctl API
=============

所有符合标准的驱动程序也支持 ioctl API
使用 ioctl ping 监视器：

所有具有 ioctl 接口的驱动程序至少支持一个 ioctl，即 KEEPALIVE。此 ioctl 与向监视器设备写入操作完全相同，因此上述程序中的主循环可以用以下代码替换：

```c
while (1) {
    ioctl(fd, WDIOC_KEEPALIVE, 0);
    sleep(10);
}
```

ioctl 的参数被忽略。
设置和获取超时时间
===============================

对于某些驱动程序，可以使用 SETTIMEOUT ioctl 动态修改看门狗的超时时间，这些驱动程序在其选项字段中设置了 WDIOF_SETTIMEOUT 标志。参数是一个整数，表示以秒为单位的超时时间。驱动程序在同一个变量中返回实际使用的超时时间，该时间可能由于硬件限制而与请求的时间不同：

    int timeout = 45;
    ioctl(fd, WDIOC_SETTIMEOUT, &timeout);
    printf("超时时间设置为 %d 秒\n", timeout);

这个例子实际上可能会打印 "超时时间设置为 60 秒"，如果设备的超时时间是以分钟为单位的话。
从 Linux 2.4.18 内核开始，可以使用 GETTIMEOUT ioctl 查询当前的超时时间：

    ioctl(fd, WDIOC_GETTIMEOUT, &timeout);
    printf("当前超时时间是 %d 秒\n", timeout);

预超时
===========

一些看门狗计时器可以设置在实际系统复位之前触发（如通过非屏蔽中断、中断或其他机制）。这允许 Linux 在复位之前记录有用的信息（比如 panic 信息和内核 core dump）：

    int pretimeout = 10;
    ioctl(fd, WDIOC_SETPRETIMEOUT, &pretimeout);

请注意，预超时是在超时触发前的秒数。并不是距离预超时还有多少秒。例如，如果你将超时设置为 60 秒，预超时设置为 10 秒，那么预超时将在 50 秒后触发。将预超时设置为零会禁用它。
还有一个获取预超时的功能：

    ioctl(fd, WDIOC_GETPRETIMEOUT, &pretimeout);
    printf("预超时是 %d 秒\n", pretimeout);

并非所有看门狗驱动都支持预超时。
获取重启前剩余秒数
=======================================

一些看门狗驱动能够报告系统重启前剩余的时间。WDIOC_GETTIMELEFT 是返回重启前剩余秒数的 ioctl：

    ioctl(fd, WDIOC_GETTIMELEFT, &timeleft);
    printf("重启前剩余时间是 %d 秒\n", timeleft);

环境监控
========================

所有看门狗驱动都需要提供更多的系统信息，一些进行温度、风扇和电源水平监测，一些可以告诉你系统上一次重启的原因。GETSUPPORT ioctl 可用于询问设备能做什么：

    struct watchdog_info ident;
    ioctl(fd, WDIOC_GETSUPPORT, &ident);

ident 结构体返回的字段有：

	================	=============================================
        identity		标识看门狗驱动的字符串
	firmware_version	如果有，则是卡片的固件版本
	options			描述设备支持功能的标志位
	================	=============================================

options 字段可以设置以下位，描述了 GET_STATUS 和 GET_BOOT_STATUS ioctls 可以返回的信息类型：
================	=========================
	WDIOF_OVERHEAT		因 CPU 过热导致的复位
	================	=========================

机器上次重启是因为看门狗检测到温度限制被超过了：

	==============		==========
	WDIOF_FANFAULT		风扇故障
	==============		==========

被看门狗监控的系统风扇发生故障。

	=============		================
	WDIOF_EXTERN1		外部继电器 1
	=============		================

外部监控继电器/源 1 被触发。针对实际应用设计的控制器通常包括外部监控引脚，这些引脚可以触发复位。

	=============		================
	WDIOF_EXTERN2		外部继电器 2
	=============		================

外部监控继电器/源 2 被触发。

	================	=====================
	WDIOF_POWERUNDER	电源异常/电源故障
	================	=====================

机器显示欠压状态。

	===============		=============================
	WDIOF_CARDRESET		卡片之前已复位 CPU
	===============		=============================

最后一次重启是由看门狗卡片引起的。

	================	=====================
	WDIOF_POWEROVER		电源过压
	================	=====================

机器显示过压状态。需要注意的是，如果一个电压级别过低而另一个过高，两个位都会被设置——这看起来可能有些奇怪，但这是有意义的。

	===================	=====================
	WDIOF_KEEPALIVEPING	存活检测回复
	===================	=====================

自上次查询以来，看门狗检测到了存活检测信号。

	================	=======================
	WDIOF_SETTIMEOUT	可以设置/获取超时时间
	================	=======================

看门狗支持预超时。

对于那些在选项字段中设置了任何位的驱动程序，可以使用 GETSTATUS 和 GETBOOTSTATUS ioctls 分别请求当前状态和上一次重启时的状态：

    int flags;
    ioctl(fd, WDIOC_GETSTATUS, &flags);

或者

    ioctl(fd, WDIOC_GETBOOTSTATUS, &flags);

请注意，并非所有设备都支持这两个调用，有些只支持 GETBOOTSTATUS 调用。
一些驱动程序可以使用 GETTEMP ioctl 测量温度。返回的值是以华氏度表示的温度：

    int temperature;
    ioctl(fd, WDIOC_GETTEMP, &temperature);

最后，SETOPTIONS ioctl 可用于控制卡片的部分操作：

    int options = 0;
    ioctl(fd, WDIOC_SETOPTIONS, &options);

可用的选项如下：

	=================	================================
	WDIOS_DISABLECARD	关闭看门狗计时器
	WDIOS_ENABLECARD	开启看门狗计时器
	WDIOS_TEMPPANIC		温度达到阈值时内核 panic
	=================	================================

[FIXME -- 更详细的解释]
