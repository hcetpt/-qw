以下是提供的文本翻译为中文：

======================================
用户空间软件挂起接口的文档
======================================

	（版权所有）2006年 Rafael J. Wysocki <rjw@sisk.pl>

首先，swsusp.txt 开头的警告仍然适用。
其次，如果您还没有阅读过，请现在就阅读 swsusp.txt 中的常见问题解答 (FAQ)。
要使用用户空间的软件挂起接口，您需要一些特殊的工具来从内核读取/写入系统内存快照。例如，可以从 <http://suspend.sourceforge.net> 获取这样的工具。如果您打算开发自己的挂起/恢复工具，您可能希望查看这些工具。
该接口由一个字符设备组成，提供了 open()、release()、read() 和 write() 操作以及在 include/linux/suspend_ioctls.h 中定义的若干 ioctl() 命令。该设备的主要和次要编号分别是 10 和 231，并且可以在 /sys/class/misc/snapshot/dev 中读取。
该设备可以被打开以供读取或写入。如果为读取而打开，则认为它处于挂起模式。否则假定它处于恢复模式。该设备不能同时用于读取和写入。同时，该设备也不能一次打开多次。
即使是打开设备也会产生副作用。会分配数据结构，并调用 PM_HIBERNATION_PREPARE / PM_RESTORE_PREPARE 链。
设备识别的 ioctl() 命令包括：

SNAPSHOT_FREEZE
冻结用户空间进程（当前进程不被冻结）；这对于 SNAPSHOT_CREATE_IMAGE 和 SNAPSHOT_ATOMIC_RESTORE 成功是必需的。

SNAPSHOT_UNFREEZE
解冻由 SNAPSHOT_FREEZE 冻结的用户空间进程。

SNAPSHOT_CREATE_IMAGE
创建系统内存的快照；ioctl() 的最后一个参数应该是指向 int 变量的指针，其值将指示调用是在创建快照后返回 (1) 还是在从快照恢复系统内存状态后返回 (0)（恢复后，系统发现自己再次完成 SNAPSHOT_CREATE_IMAGE ioctl()）。创建快照后，可以使用 read() 操作将其移出内核。

SNAPSHOT_ATOMIC_RESTORE
从上传的快照图像恢复系统内存状态；在调用之前，应使用 write() 操作将系统内存快照返回到内核；如果快照图像不可用于内核，则此调用不会成功。

SNAPSHOT_FREE
释放为快照图像分配的内存。

SNAPSHOT_PREF_IMAGE_SIZE
设置图像的首选最大大小（内核将尽力确保图像大小不超过这个数字，但如果无法实现，内核将创建尽可能小的图像）。

SNAPSHOT_GET_IMAGE_SIZE
返回休眠图像的实际大小（最后一个参数应该是指向 loff_t 变量的指针，如果调用成功则将包含结果）。

SNAPSHOT_AVAIL_SWAP_SIZE
返回可用交换空间的数量（字节）（最后一个参数应该是指向 loff_t 变量的指针，如果调用成功则将包含结果）。

SNAPSHOT_ALLOC_SWAP_PAGE
从恢复分区分配交换页（最后一个参数应该是指向 loff_t 变量的指针，如果调用成功则将包含交换页偏移量）。

SNAPSHOT_FREE_SWAP_PAGES
释放所有通过 SNAPSHOT_ALLOC_SWAP_PAGE 分配的交换页。

SNAPSHOT_SET_SWAP_AREA
设置恢复分区及其偏移量（以 <PAGE_SIZE> 为单位），从分区开始处的交换头位置（最后一个 ioctl() 参数应指向 kernel/power/suspend_ioctls.h 中定义的 struct resume_swap_area，其中包含恢复设备规范和偏移量）；对于交换分区，偏移量始终为 0，但对于交换文件，偏移量不同于零（详情请参阅 Documentation/power/swsusp-and-swap-files.rst）。

SNAPSHOT_PLATFORM_SUPPORT
根据参数值启用/禁用休眠平台支持（如果参数非零，则启用）。

SNAPSHOT_POWER_OFF
使内核将系统过渡到休眠状态（例如，ACPI S4）使用平台（例如，ACPI）驱动程序。

SNAPSHOT_S2RAM
挂起到 RAM；使用此调用会导致内核立即进入挂起到 RAM 状态，因此此调用必须始终由 SNAPSHOT_FREEZE 调用先行，并且系统唤醒后必须使用 SNAPSHOT_UNFREEZE 调用。此调用对于实现挂起到两者机制是必要的，在这种机制中，首先创建挂起图像，就好像系统已被挂起到磁盘一样，然后系统挂起到 RAM（这使得如果电池电量足够，可以从 RAM 恢复系统，或者否则基于保存的挂起图像恢复其状态）。

该设备的 read() 操作可用于从内核传输快照图像。它具有以下限制：

- 您一次不能 read() 多于一个虚拟内存页。
- 跨越页边界的 read() 是不可能的（即，如果您在上一次调用中 read() 了一页的一半，在下一次调用中您只能 read() **最多** 一半的页）。

该设备的 write() 操作用于将系统内存快照上传到内核。它与 read() 操作有相同的限制。
release() 操作释放为快照图像分配的所有内存以及所有通过 SNAPSHOT_ALLOC_SWAP_PAGE 分配的交换页（如果有）。因此，在关闭设备之前无需使用 SNAPSHOT_FREE 或 SNAPSHOT_FREE_SWAP_PAGES（实际上，如果在关闭设备时用户空间进程仍被冻结，它也将解冻由 SNAPSHOT_UNFREEZE 冻结的用户空间进程）。
目前假设用户空间工具在从/向内核读取/写入快照图像时将使用交换分区，称为恢复分区，或交换文件作为存储空间（如果使用交换文件，则恢复分区是包含该文件的分区）。然而，这并不是严格要求的，因为它们可以使用例如一个特殊的（空白的）暂停分区或者在SNAPSHOT_CREATE_IMAGE之前卸载并在之后挂载的分区上的文件。

这些工具不得对快照图像内部数据的顺序作出任何假设。图像的内容完全由内核拥有，其结构可能会在未来版本的内核中发生变化。

快照图像必须原样写入内核（即图像数据、元数据和头部都必须以完全相同的数量、形式和顺序写入，就像它们被读取时一样）。否则，恢复系统的运行行为可能是完全不可预测的。

在执行SNAPSHOT_ATOMIC_RESTORE时，内核会检查快照图像的结构是否与图像头部中存储的信息一致。如果检测到任何不一致性，SNAPSHOT_ATOMIC_RESTORE将不会成功。然而，这并不是一个万无一失的机制，使用该接口的用户空间工具应当采用额外的方法，如校验和，来确保快照图像的完整性。

暂停和恢复工具在调用SNAPSHOT_FREEZE之前必须锁定自身内存，最好使用mlockall()。

暂停工具必须检查SNAPSHOT_CREATE_IMAGE存放在ioctl()最后一个参数所指向内存位置中的值，并据此进行操作：

1. 如果该值为1（即系统内存快照刚刚创建完毕，系统准备好保存它）：
   (a) 暂停工具除非要取消整个暂停过程，否则不得关闭快照设备。在这种情况下，如果快照图像已经被保存，暂停工具应销毁它，最好是通过擦除其头部。如果不停止暂停，保存快照图像后必须关闭电源或重新启动系统。
   (b) 暂停工具不应尝试对在调用SNAPSHOT_CREATE_IMAGE之前已挂载的文件系统执行任何文件系统操作（包括读取）。但是，它可以挂载当时未挂载的文件系统并在此文件系统上执行一些操作（例如用于保存图像）。

2. 如果该值为0（即系统状态刚刚从快照图像中恢复），暂停工具必须关闭快照设备。之后它将被视为常规用户空间进程，因此不必退出。

恢复工具不应尝试挂载任何可能在暂停前挂载的文件系统，也不应尝试执行涉及此类文件系统的任何操作。
详细信息，请参阅源代码。
