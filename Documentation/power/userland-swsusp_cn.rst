用户空间软件挂起接口文档
=====================================================

	(C) 2006 Rafael J. Wysocki <rjw@sisk.pl>

首先，swsusp.txt 开头的警告仍然适用。
其次，如果你还没有阅读 swsusp.txt 中的常见问题解答（FAQ），现在应该立即阅读。
为了使用用户空间的软件挂起接口，你需要一些特殊的工具来从内核读取/写入系统内存快照。例如，可以从 <http://suspend.sourceforge.net> 获得这样的工具。如果你打算开发自己的挂起/恢复工具，可以参考这些工具。
该接口包括一个字符设备，提供 open()、release()、read() 和 write() 操作，以及在 include/linux/suspend_ioctls.h 中定义的若干个 ioctl() 命令。该设备的主要和次要编号分别是 10 和 231，并且可以从 /sys/class/misc/snapshot/dev 读取。
该设备可以为读取或写入打开。如果为读取打开，则认为它处于挂起模式；否则假定它处于恢复模式。不能同时为读取和写入打开该设备。一次也不能打开该设备超过一次。
即使打开设备也会有副作用。会分配数据结构，并调用 PM_HIBERNATION_PREPARE / PM_RESTORE_PREPARE 链。
设备识别的 ioctl() 命令如下：

SNAPSHOT_FREEZE
冻结用户空间进程（当前进程不被冻结）；这对于 SNAPSHOT_CREATE_IMAGE 和 SNAPSHOT_ATOMIC_RESTORE 成功是必需的。

SNAPSHOT_UNFREEZE
解冻由 SNAPSHOT_FREEZE 冻结的用户空间进程。

SNAPSHOT_CREATE_IMAGE
创建系统内存快照；ioctl() 的最后一个参数应指向一个 int 变量，其值将指示调用是在创建快照后返回（1）还是在从快照恢复系统内存状态后返回（0）（恢复后系统会再次完成 SNAPSHOT_CREATE_IMAGE ioctl()）；创建快照后，可以使用 read() 操作将其从内核中传输出来。

SNAPSHOT_ATOMIC_RESTORE
从上传的快照图像恢复系统内存状态；在调用此命令之前，应使用 write() 操作将系统内存快照传回内核；如果没有快照图像可供内核使用，此调用不会成功。

SNAPSHOT_FREE
释放用于快照图像的内存。

SNAPSHOT_PREF_IMAGE_SIZE
设置快照图像的首选最大大小（内核会尽力确保图像大小不超过这个数字，但如果无法实现，内核将创建尽可能小的图像）。

SNAPSHOT_GET_IMAGE_SIZE
返回休眠图像的实际大小（最后一个参数应指向一个 loff_t 变量，如果调用成功，该变量将包含结果）。

SNAPSHOT_AVAIL_SWAP_SIZE
返回可用交换空间的字节数（最后一个参数应指向一个 loff_t 变量，如果调用成功，该变量将包含结果）。

SNAPSHOT_ALLOC_SWAP_PAGE
从恢复分区分配一个交换页（最后一个参数应指向一个 loff_t 变量，如果调用成功，该变量将包含交换页偏移）。

SNAPSHOT_FREE_SWAP_PAGES
释放所有由 SNAPSHOT_ALLOC_SWAP_PAGE 分配的交换页。

SNAPSHOT_SET_SWAP_AREA
设置恢复分区及其偏移量（以 <PAGE_SIZE> 单位计，从分区开始处到交换头的位置）（最后一个 ioctl() 参数应指向一个 resume_swap_area 结构，如 kernel/power/suspend_ioctls.h 中所定义，包含恢复设备规范和偏移量）；对于交换分区，偏移量总是 0，但对于交换文件则不同（详见 Documentation/power/swsusp-and-swap-files.rst）。

SNAPSHOT_PLATFORM_SUPPORT
根据参数值启用或禁用休眠平台支持（如果参数非零则启用）。

SNAPSHOT_POWER_OFF
使内核通过平台驱动程序（例如 ACPI）将系统转换为休眠状态（例如 ACPI S4）。

SNAPSHOT_S2RAM
挂起到 RAM；使用此调用会导致内核立即进入挂起到 RAM 状态，因此此调用必须始终由 SNAPSHOT_FREEZE 调用前置，并且系统唤醒后也必须使用 SNAPSHOT_UNFREEZE 调用。此调用用于实现“挂起到两者”机制，在这种机制中，首先创建挂起图像，就像系统被挂起到磁盘一样，然后将系统挂起到 RAM（这使得可以在电池电量充足时从 RAM 恢复系统，否则基于保存的挂起图像恢复其状态）。

设备的 read() 操作可用于从内核传输快照图像。它有以下限制：

- 你不能一次 read() 超过一个虚拟内存页。
- 不能跨页边界 read()（即，如果你在前一个调用中读取了一页的一半，在下一个调用中你只能读取 **最多** 一半的页）。

设备的 write() 操作用于将系统内存快照上传到内核。它与 read() 操作具有相同的限制。
release() 操作会释放为快照图像分配的所有内存以及使用 SNAPSHOT_ALLOC_SWAP_PAGE 分配的所有交换页（如果有）。因此，在关闭设备之前不需要使用 SNAPSHOT_FREE 或 SNAPSHOT_FREE_SWAP_PAGES（事实上，如果在关闭设备时用户空间进程仍被冻结，它还会解冻由 SNAPSHOT_UNFREEZE 冻结的用户空间进程）。
目前假设用户空间工具会从内核读取/写入快照图像时，使用交换分区（称为恢复分区）或交换文件作为存储空间（如果使用交换文件，则恢复分区分区是包含该文件的分区）。然而，这并不是必需的，因为它们也可以使用一个特殊的（空白的）暂停分区或在执行SNAPSHOT_CREATE_IMAGE之前卸载并在之后挂载的一个分区上的文件。

这些工具不得对快照图像内的数据顺序作出任何假设。图像的内容完全由内核拥有，其结构可能在未来版本的内核中发生变化。
快照图像必须原封不动地写入内核（即所有图像数据、元数据和头部必须以完全相同的数量、形式和顺序写入，正如它们被读取的一样）。否则，恢复后的系统行为可能是完全不可预测的。

在执行SNAPSHOT_ATOMIC_RESTORE时，内核会检查快照图像的结构是否与图像头中存储的信息一致。如果检测到任何不一致，SNAPSHOT_ATOMIC_RESTORE将不会成功。然而，这并不是一个万无一失的机制，使用该接口的用户空间工具应使用额外的方法，如校验和，来确保快照图像的完整性。

暂停和恢复工具在调用SNAPSHOT_FREEZE之前必须锁定自身内存，最好使用mlockall()。

暂停工具必须检查SNAPSHOT_CREATE_IMAGE通过ioctl()的最后一个参数所指向的内存位置中存储的值，并据此进行操作：

1. 如果该值为1（即系统内存快照刚刚创建并且系统准备好保存它）：
   (a) 暂停工具除非取消整个暂停过程，否则不得关闭快照设备；在这种情况下，如果快照图像已经保存，则暂停工具应销毁它，最好通过擦除其头部。如果不取消暂停，则必须在快照图像保存后关机或重启系统。
   (b) 暂停工具不应尝试对在调用SNAPSHOT_CREATE_IMAGE之前已挂载的文件系统执行任何文件系统操作（包括读取）。但是，它可以挂载在此时间点未挂载的文件系统并对其执行一些操作（例如用于保存图像）。

2. 如果该值为0（即系统状态刚刚从快照图像中恢复），暂停工具必须关闭快照设备。之后，它将被视为常规用户空间进程，因此不必退出。

恢复工具不应尝试挂载任何在暂停前可以挂载的文件系统，也不应尝试执行涉及此类文件系统的任何操作。
详情请参阅源代码。
