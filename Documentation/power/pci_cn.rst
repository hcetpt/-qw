PCI电源管理
====================

版权所有 (c) 2010 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc
本文档概述了与PCI电源管理相关的概念和Linux内核接口。基于Patrick Mochel <mochel@transmeta.com>（及其他贡献者）的先前工作。
本文档仅涵盖与PCI设备特有的电源管理方面。对于内核中与设备电源管理相关的通用接口描述，请参阅`Documentation/driver-api/pm/devices.rst`和`Documentation/power/runtime_pm.rst`。
.. contents:

   1. 硬件和平台对PCI电源管理的支持
   2. PCI子系统和设备电源管理
   3. PCI设备驱动程序和电源管理
   4. 资源


1. 硬件和平台对PCI电源管理的支持
=========================================================

1.1. 本机和基于平台的电源管理
-----------------------------------------------

通常，电源管理是一种功能，通过将设备置于低功耗状态（即消耗较少电力的状态）来节省能源，但代价是减少功能或性能。
通常，在设备未充分利用或完全不活动时将其置于低功耗状态。然而，当需要再次使用该设备时，必须将其恢复到“完全功能”状态（全功率状态）。这可能是因为有数据需要处理或外部事件要求设备处于活动状态，这些事件可能由设备自身发出信号。
PCI设备可以通过两种方式进入低功耗状态：一种是使用PCI总线电源管理接口规范引入的设备能力；另一种是在平台固件（如ACPI BIOS）的帮助下实现。第一种方法被称为本机PCI电源管理（以下称为本机PCI PM），通过向设备的标准配置寄存器之一写入特定值来改变设备的电源状态。第二种方法则需要平台固件提供特殊的方法供内核使用以改变设备的电源状态。
支持本机PCI PM的设备通常可以生成唤醒信号，称为电源管理事件（PMEs），以通知内核外部事件要求设备处于活动状态。在接收到PME后，内核应该将发送该信号的设备置于全功率状态。但是，PCI总线电源管理接口规范并未定义从设备到CPU及操作系统内核的标准PME传递方法。
假设平台固件将完成此任务，因此即使PCI设备被设置为生成PME，也可能需要准备平台固件以通知CPU来自设备的PME（例如，通过生成中断）。
另一方面，如果使用平台固件提供的方法来改变设备的电源状态，则通常平台还会提供一种方法来准备设备生成唤醒信号。但在这种情况下，往往还需要使用本机PCI PM机制来准备设备生成PME，因为平台提供的方法依赖于这一点。
因此，在许多情况下，为了获得期望的结果，必须同时使用本机和基于平台的电源管理机制。
### 1.2. 本机PCI电源管理

PCI总线电源管理接口规范（PCI PM规范）是在PCI 2.1和PCI 2.2规范之间引入的。它定义了一个执行与电源管理相关的各种操作的标准接口。
对于传统的PCI设备，实现PCI PM规范是可选的，但对于PCI Express设备则是强制性的。如果一个设备支持PCI PM规范，那么在其PCI配置空间中会有一个8字节的电源管理功能字段。该字段用于描述和控制与本机PCI电源管理相关的标准特性。

PCI PM规范为设备（D0-D3）和总线（B0-B3）定义了4种工作状态。数字越大，该设备或总线在该状态下消耗的功率越少。然而，数字越大，设备或总线返回到全功率状态（分别为D0或B0）所需的延迟时间也越长。

规范定义了两种D3状态变体。第一种是D3hot，也称为软件可访问的D3，因为可以编程让设备进入这种状态。第二种是D3cold，这是当从PCI设备上移除供电电压（Vcc）时设备所处的状态。不可能编程让PCI设备进入D3cold状态，尽管可能有一个可编程接口可以让设备所在的总线进入一种状态，在这种状态下所有设备上的Vcc都被移除。

然而，截至本文档撰写之时，Linux内核并不支持PCI总线电源管理，因此这部分不在本文档的覆盖范围内。

请注意，每个PCI设备都可以处于全功率状态（D0）或D3cold状态，无论它是否实现了PCI PM规范。除此之外，如果设备实现了PCI PM规范，它必须同时支持D3hot和D0。对D1和D2电源状态的支持是可选的。

支持PCI PM规范的PCI设备可以被编程进入任何受支持的低功耗状态（除了D3cold）。当设备处于D1-D3hot状态时，其标准配置寄存器必须对软件可访问（即设备需要响应PCI配置访问），尽管此时它的I/O和内存空间被禁用。这允许设备被程序化地置入D0状态。因此内核可以在D0和受支持的低功耗状态（除了D3cold）之间切换设备，并且设备可能经历的电源状态转换如下：

+----------------------------+
| 当前状态 | 新状态  |
+----------------------------+
| D0            | D1, D2, D3 |
+----------------------------+
| D1            | D2, D3     |
+----------------------------+
| D2            | D3         |
+----------------------------+
| D1, D2, D3    | D0         |
+----------------------------+

从D3cold到D0的转换发生在向设备提供供电电压时（即恢复供电）。在这种情况下，设备通过完整的上电复位序列回到D0状态，并且硬件将上电默认值恢复到设备，就像初始上电一样。

支持PCI PM规范的PCI设备可以在任何电源状态（D0-D3）下被编程生成PMEs（电源管理事件），但它们不必能够在所有支持的电源状态下生成PMEs。特别是，从D3cold生成PMEs的能力是可选的，并且取决于是否存在额外的电压（3.3Vaux），使设备能够保持足够的活跃度以生成唤醒信号。

### 1.3. ACPI设备电源管理

平台固件对PCI设备的电源管理支持是系统特定的。但是，如果所讨论的系统遵循高级配置和电源接口（ACPI）规范，如大多数基于x86的系统，则应实现由ACPI标准定义的设备电源管理接口。

为此，ACPI BIOS提供了特殊的功能，称为“控制方法”，这些功能可以由内核执行以执行特定任务，例如将设备置于低功耗状态。这些控制方法使用特殊的字节码语言——ACPI机器语言（AML）进行编码，并存储在机器的BIOS中。内核从BIOS加载它们，并根据需要使用AML解释器来执行它们，该解释器将AML字节码转换为计算和内存或I/O空间访问。这样，理论上，BIOS编写者可以为内核提供一种手段，使其能够以系统特定的方式执行依赖于系统设计的操作。
ACPI 控制方法可以分为全局控制方法和设备控制方法。全局控制方法与特定的设备无关，而设备控制方法则需要为每个希望借助平台处理的设备单独定义。这意味着，ACPI 设备控制方法只能用于处理BIOS编写者事先知道的设备。用于设备电源管理的ACPI方法就属于这一类。

ACPI规范假设设备可以处于四种电源状态之一，标记为D0、D1、D2和D3，这些大致对应于原生PCI PM的D0-D3状态（尽管ACPI没有考虑到D3hot和D3cold之间的区别）。此外，对于设备的每种电源状态，都有一组需要启用的电源资源，以便将设备置于该状态。这些电源资源通过它们自己的控制方法来控制，即_ON和_OFF，这些方法必须为每一个资源单独定义。

为了将设备置于ACPI电源状态Dx（其中x是0到3之间的数字），内核应该（1）使用_ON控制方法启用该状态下设备所需的电源资源，并（2）执行为该设备定义的_PSx控制方法。此外，如果设备将被置于低功耗状态（D1-D3），并且预期从该状态产生唤醒信号，则在执行_PSx之前，还必须执行定义为其_DSW（或_PSW，ACPI 3.0中替换为_DSW）控制方法。不需要目标电源状态中的电源资源，并且不再被任何其他设备所需的电源资源应该被禁用（通过执行它们的_OFF控制方法）。如果设备当前的电源状态为D3，则只能通过这种方式将其置于D0状态。

然而，设备的电源状态经常会在系统进入睡眠状态或返回工作状态时发生变化。ACPI定义了四个系统睡眠状态S1、S2、S3和S4，并将系统的工作状态表示为S0。一般来说，目标系统睡眠（或工作）状态决定了设备可以进入的最高功率（最低编号）的状态，并且内核应该通过执行设备的_SxD控制方法（其中x是0到4之间的数字）来获取此信息。

如果设备需要从目标睡眠状态唤醒系统，则它能进入的最低功率（最高编号）状态也由系统的目标状态决定。此时内核应该使用设备的_SxW控制方法来获取该状态的编号。它也应该使用设备的_PRW控制方法来了解为了使设备能够产生唤醒信号，哪些电源资源需要被启用。

### 1.4 唤醒信号

由PCI设备产生的唤醒信号，无论是作为原生PCI PME还是在将设备置于低功耗状态前执行_DSW（或_PSW）ACPI控制方法的结果，都需要被捕获并适当地处理。如果它们在系统处于工作状态（ACPI S0）时发送，则应转换为中断，以便内核可以将生成它们的设备置于全功率状态，并处理触发它们的事件。另一方面，如果它们在系统处于睡眠状态时发送，则应导致系统的主逻辑触发唤醒。

在基于ACPI的系统上，传统PCI设备发送的唤醒信号会转换为ACPI通用事件（GPE），这些是系统主逻辑在响应各种需要采取行动的事件时生成的硬件信号。每个GPE都与一个或多个潜在有趣的事件源相关联。特别是，GPE可能与能够发出唤醒信号的PCI设备相关联。GPE与事件源之间的连接信息记录在系统的ACPI BIOS中，内核可以从那里读取这些信息。

如果系统ACPI BIOS已知的PCI设备发出唤醒信号，则与其关联的GPE（如果有）会被触发。与PCI桥相关的GPE也可能在响应来自桥下方设备的唤醒信号时被触发（根桥也是这种情况），例如，系统ACPI BIOS未知的设备的原生PCI PME可以通过这种方式处理。

GPE可能在系统处于睡眠状态（即处于ACPI S1-S4状态之一）时被触发，在这种情况下，系统的主逻辑开始启动系统唤醒（稍后可能会识别出导致系统唤醒发生的信号源设备）。在这种情况下使用的GPE被称为唤醒GPE。

然而，通常情况下，当系统处于工作状态（ACPI S0）时，GPE也会被触发，并且在这种情况下，系统的主逻辑会生成一个系统控制中断（SCI）以通知内核发生的事件。然后，SCI处理器会识别出引起中断生成的GPE，这反过来又允许内核识别出事件的来源（可能是发出唤醒信号的PCI设备）。在系统处于工作状态时用于通知内核发生事件的GPE被称为运行时GPE。
不幸的是，在非ACPI系统上处理传统PCI设备发送的唤醒信号并没有一个标准的方法，但对于PCI Express设备则有。具体来说，PCI Express基本规范引入了一种将原生PCI PME（Power Management Event）转换为由根端口生成的中断的机制。对于传统PCI设备，原生PME是带外的，因此它们需要单独路由，并且不需要通过桥接器（原则上可以直接路由到系统的主逻辑），但对PCI Express设备而言，它们是带内消息，必须通过PCI Express层次结构，包括从设备到根复合体路径上的根端口。因此，可以引入一种机制，使得每当根端口收到其下方某个设备的PME消息时，它就会生成一个中断。然后，发送PME消息的设备的PCI Express请求者ID会被记录在根端口的一个配置寄存器中，这样中断处理器就可以读取它来识别该设备。[由与根复合体集成的PCI Express终端发出的PME消息不会通过根端口，而是会触发根复合体事件收集器（如果存在的话）生成中断。]

原则上，原生PCI Express PME信号也可以与GPEs一起用于ACPI系统，但要使用它，内核必须要求系统的ACPI BIOS释放对根端口配置寄存器的控制。然而，ACPI BIOS并不一定允许内核控制这些寄存器，如果不这样做，内核不得修改其内容。当然，在这种情况下内核无法使用原生PCI Express PME信号。

### 2. PCI子系统和设备电源管理

#### 2.1 设备电源管理回调

PCI子系统以多种方式参与PCI设备的电源管理。首先，它提供了一个位于设备电源管理核心（PM core）和PCI设备驱动程序之间的中间代码层。具体来说，PCI子系统的`struct bus_type`对象`pci_bus_type`中的`pm`字段指向一个`struct dev_pm_ops`对象`pci_dev_pm_ops`，其中包含指向多个设备电源管理回调函数的指针，如下所示：

```c
const struct dev_pm_ops pci_dev_pm_ops = {
	.prepare = pci_pm_prepare,
	.complete = pci_pm_complete,
	.suspend = pci_pm_suspend,
	.resume = pci_pm_resume,
	.freeze = pci_pm_freeze,
	.thaw = pci_pm_thaw,
	.poweroff = pci_pm_poweroff,
	.restore = pci_pm_restore,
	.suspend_noirq = pci_pm_suspend_noirq,
	.resume_noirq = pci_pm_resume_noirq,
	.freeze_noirq = pci_pm_freeze_noirq,
	.thaw_noirq = pci_pm_thaw_noirq,
	.poweroff_noirq = pci_pm_poweroff_noirq,
	.restore_noirq = pci_pm_restore_noirq,
	.runtime_suspend = pci_pm_runtime_suspend,
	.runtime_resume = pci_pm_runtime_resume,
	.runtime_idle = pci_pm_runtime_idle,
};
```

这些回调函数会在各种与设备电源管理相关的情况下由PM core执行，并反过来执行由PCI设备驱动程序提供的电源管理回调函数。此外，它们还会执行涉及PCI设备某些标准配置寄存器的电源管理操作，而这些操作是设备驱动程序不必关心的。

表示PCI设备的结构`struct pci_dev`包含了一些这些回调函数所操作的字段：

```c
struct pci_dev {
	...
pci_power_t     current_state;  /* 当前运行状态。 */
	int		pm_cap;		/* 在配置空间中的PM能力结构偏移量 */
	unsigned int	pme_support:5;	/* 可以生成PME的状态位掩码 */
	unsigned int	pme_poll:1;	/* 轮询设备的PME状态位 */
	unsigned int	d1_support:1;	/* 支持低功耗状态D1 */
	unsigned int	d2_support:1;	/* 支持低功耗状态D2 */
	unsigned int	no_d1d2:1;	/* 禁止D1和D2状态 */
	unsigned int	wakeup_prepared:1;  /* 设备已准备好唤醒 */
	unsigned int	d3hot_delay;	/* D3hot到D0的过渡时间（毫秒） */
	...
};
```

它们还间接使用嵌入在`struct pci_dev`中的`struct device`的一些字段。

#### 2.2 设备初始化

PCI子系统与设备电源管理相关的首要任务是为电源管理准备设备并初始化`struct pci_dev`中用于此目的的字段。这发生在定义于`drivers/pci/`中的两个函数中：`pci_pm_init()`和`pci_acpi_setup()`。

第一个函数检查设备是否支持原生PCI PM，并且如果是这种情况，则将设备的电源管理功能结构在配置空间中的偏移量存储在其`struct pci_dev`对象的`pm_cap`字段中。接下来，该函数检查设备支持哪些PCI低功耗状态以及可以从哪些低功耗状态生成原生PCI PME。相应地更新设备的`struct pci_dev`和嵌入其中的`struct device`中的电源管理字段，并禁用设备生成PME的功能。

第二个函数检查设备是否可以通过平台固件（如ACPI BIOS）的帮助被准备用来发出唤醒信号。如果是这种情况，则更新嵌入在设备的`struct pci_dev`中的`struct device`中的唤醒字段，并使用固件提供的方法阻止设备发出唤醒信号。
此时，设备已准备好进行电源管理。但对于无驱动程序的设备，
此功能仅限于在系统范围从工作状态转换到睡眠状态以及反过来的操作中执行的一些基本操作。
2.3. 运行时设备电源管理
-------------------------------

PCI 子系统在 PCI 设备的运行时电源管理中扮演着核心角色。为此，它使用了文档 `Documentation/power/runtime_pm.rst` 中描述的一般运行时电源管理（运行时 PM）框架。具体来说，它提供了子系统级别的回调函数：

- pci_pm_runtime_suspend()
- pci_pm_runtime_resume()
- pci_pm_runtime_idle()

这些由核心运行时 PM 例程执行。此外，它还实现了处理 PCI 设备在低功耗状态下发出的唤醒信号所需的全部机制，在本文档撰写时，这适用于原生 PCI Express PME 信号以及第 1 节中描述的基于 ACPI GPE 的唤醒信号。

首先，通过使用 `pm_schedule_suspend()` 或 `pm_runtime_suspend()` 将 PCI 设备置于低功耗状态或挂起，这两个函数对于 PCI 设备会调用 `pci_pm_runtime_suspend()` 来完成实际任务。要使这一切生效，设备的驱动程序需要提供一个 `pm->runtime_suspend()` 回调函数（见下文），该回调作为 `pci_pm_runtime_suspend()` 执行的第一个动作。如果驱动程序的回调成功返回，则保存设备的标准配置寄存器、将设备准备好以生成唤醒信号，并最终将其置于目标低功耗状态。

将设备置于其中的低功耗状态是能发出唤醒信号的最低功耗（最高编号）状态。具体的唤醒信号方式取决于系统，并由 PCI 子系统根据设备报告的能力和平台固件来确定。为了准备设备发出唤醒信号并将其置于选定的低功耗状态，PCI 子系统可以使用平台固件以及设备的原生 PCI PM 功能（如果支持的话）。

期望设备驱动程序的 `pm->runtime_suspend()` 回调不会尝试准备设备以发出唤醒信号或将其置于低功耗状态。驱动程序应该把这些任务留给拥有所有必要信息的 PCI 子系统来完成。

挂起的设备可以通过 `pm_request_resume()` 或 `pm_runtime_resume()` 帮助恢复到“活动”状态，这两个函数都会为 PCI 设备调用 `pci_pm_runtime_resume()`。同样，这只有在设备的驱动程序提供了 `pm->runtime_resume()` 回调的情况下才有效（见下文）。但在执行驱动程序的回调之前，`pci_pm_runtime_resume()` 将设备恢复到全功率状态、阻止其在该状态下发出唤醒信号并恢复其标准配置寄存器。因此，驱动程序的回调不必担心与 PCI 特定方面相关的设备恢复问题。

通常情况下，`pci_pm_runtime_resume()` 可能在两种不同情况下被调用。首先，可能是应设备驱动程序的要求，例如如果有数据需要处理。其次，可能是由于来自设备本身的唤醒信号（有时称为“远程唤醒”）。为此，唤醒信号以第 1 节中描述的方式之一进行处理，并在识别出源设备后最终转换为对 PCI 子系统的通知。

`pci_pm_runtime_idle()` 函数由 `pm_runtime_idle()` 和 `pm_request_idle()` 为 PCI 设备调用，执行设备驱动程序的 `pm->runtime_idle()` 回调（如果定义），并且如果该回调不返回错误代码（或者根本不存在），则借助 `pm_runtime_suspend()` 挂起设备。

有时 `pci_pm_runtime_idle()` 会自动由 PM 核心调用（例如，在设备刚刚恢复之后立即调用），在这种情况下，如果合理的话，预计它会挂起设备。然而，通常 PCI 子系统并不真正知道设备是否真的可以被挂起，所以它让设备的驱动程序通过运行其 `pm->runtime_idle()` 回调来决定。
2.4. 系统范围的电源转换
----------------------------------
存在几种不同类型的系统范围的电源转换，这些在 `Documentation/driver-api/pm/devices.rst` 中有描述。每种转换都需要以特定方式处理设备，并且电源管理核心为此执行子系统级别的电源管理回调。它们按阶段执行，每个阶段涉及为属于给定子系统的每个设备执行相同的子系统级回调，然后才开始下一个阶段。这些阶段总是在任务被冻结后运行。
2.4.1. 系统挂起
^^^^^^^^^^^^^^^^^^^^^

当系统进入一个内存内容将被保留的睡眠状态（例如ACPI睡眠状态S1至S3）时，其阶段如下：

- 准备(prepare)，挂起(suspend)，挂起无中断(suspend_noirq)

对于PCI总线类型，这些阶段分别使用以下回调：

- pci_pm_prepare()
- pci_pm_suspend()
- pci_pm_suspend_noirq()

`pci_pm_prepare()` 首先借助 `pm_runtime_resume()` 将设备置于“完全功能”状态。之后，如果定义了（即驱动程序的 `struct dev_pm_ops` 对象存在且其中的 `prepare` 指针有效），则会执行设备驱动程序的 `pm->prepare()` 回调。
`pci_pm_suspend()` 首先检查设备的驱动程序是否实现了传统的PCI挂起例程（参见第3节），如果存在，则执行该驱动程序的传统挂起回调并返回结果。接下来，如果设备驱动程序没有提供 `struct dev_pm_ops` 对象（包含指向驱动程序回调的指针），则调用 `pci_pm_default_suspend()`，这仅仅是关闭设备的总线主控能力，并通过 `pcibios_disable_device()` 禁用设备（除非该设备是桥接器，PCI桥接器会被这个例程忽略）。然后，如果定义了，执行设备驱动程序的 `pm->suspend()` 回调，并返回失败的结果（如果有的话）。最后，调用 `pci_fixup_device()` 来根据需要应用与设备相关的硬件挂起特性。

需要注意的是，挂起阶段对于PCI设备是异步进行的，因此 `pci_pm_suspend()` 回调可能对任何一对互不依赖的PCI设备并行执行（即从根桥接到叶设备的设备树路径中都不同时包含这两个设备）。
`pci_pm_suspend_noirq()` 在调用 `suspend_device_irqs()` 之后执行，这意味着在执行此例程期间不会调用设备驱动程序的中断处理程序。它首先检查设备驱动程序是否实现了传统的PCI挂起例程（第3节），如果是这样，则调用传统延迟挂起例程并返回结果（如果驱动程序的回调没有保存标准配置寄存器，则保存这些寄存器）。其次，如果设备驱动程序的 `struct dev_pm_ops` 对象不存在，则保存设备的标准配置寄存器并返回成功。否则，如果存在，则执行设备驱动程序的 `pm->suspend_noirq()` 回调并返回失败的结果（如果有的话）。接下来，如果设备的标准配置寄存器尚未保存（之前执行的其中一个驱动程序回调可能已经保存了）， `pci_pm_suspend_noirq()` 会保存这些寄存器，准备设备以发出唤醒信号（如果必要的话），并将设备置于低功耗状态。

要将设备置于的低功耗状态是最节能的状态（最高编号的状态），在这种状态下设备可以在系统处于目标睡眠状态时发出唤醒信号。正如上面运行时PM情况所述，发出唤醒信号的方式取决于系统并且由PCI子系统确定，PCI子系统还负责根据适当的目标睡眠状态准备设备以发出唤醒信号。

通常情况下，不期望实现传统电源管理回调的PCI设备驱动程序准备设备以发出唤醒信号或将设备置于低功耗状态。然而，如果其中一个驱动程序的挂起回调（`pm->suspend()` 或 `pm->suspend_noirq()`）保存了设备的标准配置寄存器，那么 `pci_pm_suspend_noirq()` 会假设驱动程序已经准备好了设备以发出唤醒信号并将设备置于低功耗状态（假设驱动程序使用了PCI子系统提供的辅助函数来完成这一目的）。虽然不鼓励PCI设备驱动程序这样做，但在某些罕见的情况下，在驱动程序中这样做可能是最优方案。
2.4.2. 系统恢复
^^^^^^^^^^^^^^^^^^^^

当系统从一个内存内容得到保留的睡眠状态（例如ACPI睡眠状态S1至S3）过渡到工作状态（ACPI S0）时，其阶段如下：

- 恢复无中断(resume_noirq)，恢复(resume)，完成(complete)
以下这些 PCI 总线类型的回调函数分别在各个阶段执行：

	pci_pm_resume_noirq()
	pci_pm_resume()
	pci_pm_complete()

pci_pm_resume_noirq() 首先将设备置于全功率状态，恢复其标准配置寄存器，并根据需要应用与设备相关的早期恢复硬件特性。这一步骤无条件进行，无论设备的驱动程序是否实现了传统的 PCI 功率管理回调（这样当设备中断处理程序首次在恢复过程中被调用时，所有 PCI 设备都处于全功率状态且其标准配置寄存器已恢复，这使得内核能够避免处理共享中断的问题，这些问题可能发生在那些仍处于挂起状态的设备的驱动程序中）。如果设备的驱动程序实现了传统 PCI 功率管理回调（参见第 3 节），则会执行传统的早期恢复回调并返回其结果。否则，如果定义了设备驱动程序的 pm->resume_noirq() 回调，则执行该回调并返回其结果。
pci_pm_resume() 首先检查设备的标准配置寄存器是否已恢复，如果没有，则进行恢复（这仅在挂起失败的错误路径中是必要的）。接下来，如果需要，则应用与设备相关的恢复硬件特性；如果设备的驱动程序实现了传统 PCI 功率管理回调（参见第 3 节），则执行驱动程序的传统恢复回调并返回其结果。否则，阻止设备唤醒信号机制，并执行设备驱动程序的 pm->resume() 回调（如果定义的话）（然后返回回调的结果）。
PCI 设备的恢复阶段像上述挂起阶段一样异步进行，这意味着如果两个 PCI 设备之间没有已知的依赖关系，pci_pm_resume() 可能会同时为这两个设备执行。
pci_pm_complete() 仅执行设备驱动程序的 pm->complete() 回调（如果定义的话）。
2.4.3. 系统休眠
^^^^^^^^^^^^^^^^^^^^^^^^^

系统休眠比系统挂起更复杂，因为它需要创建一个系统镜像并将其写入持久性存储介质。镜像是原子性创建的，在此之前所有设备都会被静止或冻结。
设备的冻结是在释放足够内存之后进行的（在撰写本文时，镜像创建至少需要系统 RAM 的 50% 是空闲的），分为以下三个阶段：

	准备、冻结、冻结_noirq

它们对应于 PCI 总线类型的回调：

	pci_pm_prepare()
	pci_pm_freeze()
	pci_pm_freeze_noirq()

这意味着准备阶段与系统挂起完全相同。
但是其他两个阶段有所不同。
pci_pm_freeze() 与 pci_pm_suspend() 非常相似，但它运行设备驱动程序的 pm->freeze() 回调（如果定义的话），而不是 pm->suspend()，并且不应用与挂起相关的硬件特性。它异步地为不同且相互之间没有已知依赖关系的 PCI 设备执行。
pci_pm_freeze_noirq() 类似于 pci_pm_suspend_noirq()，但它调用设备驱动程序的 pm->freeze_noirq() 而不是 pm->suspend_noirq()。它也不尝试为发出唤醒信号和进入低功耗状态做准备。不过，如果标准配置寄存器尚未被驱动程序的回调之一保存，则仍然会保存它们。
一旦创建了镜像，就需要保存它。然而，在这一点上所有设备都被冻结，无法处理 I/O，而它们处理 I/O 的能力显然对于保存镜像是必需的。因此必须使它们恢复到完全功能状态，这一过程通过以下阶段完成：

	thaw_noirq、thaw、complete

使用以下 PCI 总线类型的回调：

	pci_pm_thaw_noirq()
	pci_pm_thaw()
	pci_pm_complete()

分别进行。
首先，`pci_pm_thaw_noirq()` 函数与 `pci_pm_resume_noirq()` 类似，它将设备置于全功率状态并恢复其标准配置寄存器。如果定义了设备驱动程序的 `pm->thaw_noirq()` 回调函数，则会执行该回调函数，而不是 `pm->resume_noirq()`。

`pci_pm_thaw()` 函数类似于 `pci_pm_resume()`，但它运行的是设备驱动程序的 `pm->thaw()` 回调函数，而不是 `pm->resume()`。对于相互间没有已知依赖关系的不同 PCI 设备，它是异步执行的。这一完整阶段与系统恢复时相同。

保存镜像后，在系统能够进入目标睡眠状态（对于基于 ACPI 的系统为 ACPI S4）之前，需要关闭设备电源。这分三个阶段进行：

- 准备 (`prepare`)：与系统挂起时完全相同。
- 关闭 (`poweroff`)：与挂起阶段类似。
- 无中断关闭 (`poweroff_noirq`)：与无中断挂起阶段类似。

PCI 子系统级别的回调函数分别对应如下：

- `pci_pm_poweroff()`：与 `pci_pm_suspend()` 类似。
- `pci_pm_poweroff_noirq()`：与 `pci_pm_suspend_noirq()` 类似。

尽管它们不会尝试保存设备的标准配置寄存器。

### 2.4.4 系统恢复

系统恢复要求将休眠镜像加载到内存中，并在恢复休眠前的系统活动之前恢复之前的内存内容。

如《Documentation/driver-api/pm/devices.rst》中所述，休眠镜像是由称为启动内核的新实例加载到内存中的，该启动内核又是通过常规方式由引导加载程序加载和运行的。加载完镜像后，启动内核需要用自己的代码和数据替换镜像内存储的“休眠”内核（称为镜像内核）的代码和数据。为此，所有设备都需要像创建镜像前一样被冻结，经过以下阶段：

- 准备 (`prepare`)：与休眠时完全相同。
- 冻结 (`freeze`)：与冻结阶段类似。
- 无中断冻结 (`freeze_noirq`)：与无中断冻结阶段类似。

但这些阶段只影响启动内核中存在的驱动程序对应的设备；其他设备仍将保持引导加载程序留下的状态。

如果恢复休眠前的内存内容失败，启动内核会经历上述的“解冻”过程，使用 `thaw_noirq`、`thaw` 和 `complete` 阶段（仅影响启动内核中存在的驱动程序对应的设备），然后继续正常运行。

如果成功恢复休眠前的内存内容，这是通常的情况，控制权将传递给镜像内核，它负责将系统恢复到工作状态。为了实现这一点，它必须恢复设备的休眠前功能，这与从内存睡眠状态唤醒类似，但涉及不同的阶段：

- 无中断恢复 (`restore_noirq`)：与上面描述的 `resume_noirq` 阶段类似。
- 恢复 (`restore`)：与上面描述的 `resume` 阶段类似。

这些阶段分别对应以下 PCI 子系统的回调函数：

- `pci_pm_restore_noirq()`：与 `pci_pm_resume_noirq()` 类似，但执行设备驱动程序的 `pm->restore_noirq()` 回调函数（如果可用）。
- `pci_pm_restore()`：与 `pci_pm_resume()` 类似，但执行设备驱动程序的 `pm->restore()` 回调函数（如果可用）。
完整的阶段完全按照系统恢复时的方式执行。

3. PCI 设备驱动程序与电源管理
==========================================

3.1. 电源管理回调
-------------------

PCI 设备驱动程序通过提供回调函数参与电源管理，这些回调函数由上述的 PCI 子系统的电源管理例程执行，并且通过控制其设备的运行时电源管理。在撰写本文时，为 PCI 设备驱动程序定义电源管理回调有两种方式：推荐的方法是使用 `dev_pm_ops` 结构体（在文档 `Documentation/driver-api/pm/devices.rst` 中描述）；另一种是“传统”的方法，即使用 `struct pci_driver` 中的 `.suspend()` 和 `.resume()` 回调。然而，传统方法不允许定义运行时电源管理回调，并且不适合新的驱动程序，因此本文件不涵盖传统方法（如需了解更多信息，请参阅源代码）。

建议所有 PCI 设备驱动程序定义一个包含电源管理 (PM) 回调指针的 `struct dev_pm_ops` 对象，这些回调将由 PCI 子系统的 PM 例程在不同情况下执行。必须将指向驱动程序的 `struct dev_pm_ops` 对象的指针分配给其 `struct pci_driver` 对象中的 `driver.pm` 字段。一旦完成此操作，“传统”PM 回调（即使它们不是 NULL）将被忽略。

`struct dev_pm_ops` 中的 PM 回调不是强制性的，如果不定义（即 `struct dev_pm_ops` 的相应字段未设置），则 PCI 子系统将以简化的默认方式处理设备。但如果定义了这些回调，则期望它们按以下小节所述的方式工作。

3.1.1. prepare()
^^^^^^^^^^^^^^^^

prepare() 回调在系统挂起、休眠（即将创建休眠映像）、保存休眠映像后的关机以及系统恢复时加载休眠映像后执行。

此回调仅当驱动程序的设备可能随时有子设备注册时才必要。在这种情况下，prepare() 回调的作用是防止新的子设备在执行 `resume_noirq()`、`thaw_noirq()` 或 `restore_noirq()` 回调之前注册。

此外，prepare() 回调还可以执行一些准备设备进行挂起的操作，但不应分配内存（如果需要额外内存来挂起设备，则应提前预分配，例如，在 `Documentation/driver-api/pm/notifiers.rst` 中描述的挂起/休眠通知器中）。

3.1.2. suspend()
^^^^^^^^^^^^^^^^

suspend() 回调仅在系统挂起期间执行，且在对系统中所有设备执行完 prepare() 回调之后。

此回调预期使设备处于静止状态并准备好由 PCI 子系统置于低功耗状态。不建议 PCI 驱动程序的 suspend() 回调保存设备的标准配置寄存器、为唤醒系统做准备或将其置于低功耗状态。所有这些操作都可以很好地由 PCI 子系统处理，无需驱动程序参与。
然而，在一些罕见的情况下，可能需要在PCI驱动程序中执行这些操作。这时，应当使用`pci_save_state()`、`pci_prepare_to_sleep()`以及`pci_set_power_state()`来保存设备的标准配置寄存器，为系统唤醒做准备（如果必要的话），以及将其置于低功耗状态。此外，如果驱动程序调用了`pci_save_state()`，那么PCI子系统将不会为其设备执行`pci_prepare_to_sleep()`或`pci_set_power_state()`，因此驱动程序需负责以适当的方式处理设备。

在执行`suspend()`回调期间，驱动程序的中断处理器可能会被调用来处理来自设备的中断，因此所有依赖于驱动程序能够处理中断的与挂起相关的操作都应在该回调中进行。

### 3.1.3 `suspend_noirq()` 回调
^^^^^^^^^^^^^^^^^^^^^^

`suspend_noirq()`回调仅在系统挂起时执行，此时已为系统中的所有设备执行了`suspend()`回调，并且PM核心已经禁用了设备中断。

`suspend_noirq()`与`suspend()`的区别在于：在`suspend_noirq()`运行期间，驱动程序的中断处理器不会被调用。因此，`suspend_noirq()`可以执行那些若在`suspend()`中执行可能会导致竞态条件的操作。

### 3.1.4 `freeze()` 回调
^^^^^^^^^^^^^^^

`freeze()`回调是专用于休眠的，并在两种情况下执行：一是在休眠过程中，当为创建系统映像准备而为所有设备执行了`prepare()`回调之后；二是在恢复过程中，当从持久存储加载系统映像到内存之后，以及为所有设备执行了`prepare()`回调之后。

此回调的作用类似于上述`suspend()`回调的作用。实际上，它们通常只需要不同的是在极少数情况下，驱动程序承担起将设备置于低功耗状态的责任。

在这种情况下，`freeze()`回调不应该为系统唤醒准备设备或将设备置于低功耗状态。但是，`freeze()`或`freeze_noirq()`应该使用`pci_save_state()`来保存设备的标准配置寄存器。

### 3.1.5 `freeze_noirq()` 回调
^^^^^^^^^^^^^^^^^^^^^

`freeze_noirq()`回调也是专用于休眠的。它在休眠过程中执行，即在为创建系统映像准备而为所有设备执行了`prepare()`和`freeze()`回调之后；以及在恢复过程中执行，即在系统映像加载到内存之后，以及为所有设备执行了`prepare()`和`freeze()`回调之后。它总是在PM核心禁用了设备中断后执行。

此回调的作用类似于上述`suspend_noirq()`回调的作用，且非常少需要定义`freeze_noirq()`。

`freeze_noirq()`与`freeze()`之间的区别类似于`suspend_noirq()`与`suspend()`之间的区别。
3.1.6. poweroff()
^^^^^^^^^^^^^^^^^

`poweroff()` 回调函数是针对休眠操作的。当系统即将关闭电源，但在将休眠映像保存到持久性存储之后，会执行此回调函数。在调用 `poweroff()` 之前，会对所有设备执行 `prepare()` 回调函数。
此回调函数的作用类似于上文所述的 `suspend()` 和 `freeze()` 回调函数，尽管它不需要保存设备寄存器的内容。特别地，如果驱动程序希望自行将设备置于低功耗状态，而不是让 PCI 子系统来完成这项工作，则 `poweroff()` 回调函数应该使用 `pci_prepare_to_sleep()` 和 `pci_set_power_state()` 来为系统唤醒做准备，并将设备置于低功耗状态，但不必保存设备的标准配置寄存器。

3.1.7. poweroff_noirq()
^^^^^^^^^^^^^^^^^^^^^^^

`poweroff_noirq()` 回调函数也是针对休眠操作的。在对系统中所有设备执行完 `poweroff()` 回调函数后，会执行此回调函数。
此回调函数的作用类似于上文所述的 `suspend_noirq()` 和 `freeze_noirq()` 回调函数，但它不需要保存设备寄存器的内容。
`poweroff_noirq()` 和 `poweroff()` 之间的区别类似于 `suspend_noirq()` 和 `suspend()` 之间的区别。

3.1.8. resume_noirq()
^^^^^^^^^^^^^^^^^^^^^

`resume_noirq()` 回调函数仅在系统恢复过程中执行，在电源管理核心启用非启动 CPU 之后。在 `resume_noirq()` 运行期间，驱动程序的中断处理程序不会被调用，因此这个回调可以执行可能与中断处理程序产生竞争的操作。
由于 PCI 子系统无条件地在系统恢复的 `resume_noirq` 阶段将所有设备置于全功率状态并恢复它们的标准配置寄存器，通常情况下不需要 `resume_noirq()`。一般来说，它只应用于执行可能导致竞争条件的操作，这些操作不能由 `resume()` 完成。

3.1.9. resume()
^^^^^^^^^^^^^^^

`resume()` 回调函数仅在系统恢复过程中执行，在对系统中所有设备执行完 `resume_noirq()` 回调函数以及电源管理核心启用设备中断之后。
此回调函数负责恢复设备在挂起前的配置，并将其恢复到完全功能状态。在 `resume()` 返回后，设备应该能够以常规方式处理输入/输出。

3.1.10. thaw_noirq()
^^^^^^^^^^^^^^^^^^^^

`thaw_noirq()` 回调函数是针对休眠操作的。在创建系统映像并且电源管理核心启用了非启动 CPU 之后，会在休眠的 `thaw_noirq` 阶段执行此回调函数。如果在系统恢复时加载休眠映像失败，也可能执行此回调（在这种情况下，它将在启用非启动 CPU 之后执行）。在 `thaw_noirq()` 运行期间，驱动程序的中断处理程序不会被调用。
### 3.1.11. thaw()
^^^^^^^^^^^^^^

`thaw()`回调是针对休眠特定的。它在系统中所有设备的`thaw_noirq()`回调执行完毕，并且电源管理（PM）核心已经启用了设备中断之后执行。

此回调负责恢复设备在冻结前的配置状态，以便在`thaw()`返回后设备能够正常工作。

### 3.1.12. restore_noirq()
^^^^^^^^^^^^^^^^^^^^^^^

`restore_noirq()`回调也是针对休眠特定的。它在休眠恢复阶段的`restore_noirq`阶段执行，此时启动内核已将控制权传递给镜像内核，并且非启动CPU已被镜像内核的PM核心启用。

这个回调类似于`resume_noirq()`，不同之处在于它不能假设设备之前的状态，即使BIOS（或通常平台固件）已知能够在挂起-恢复周期中保持该状态。

对于绝大多数PCI设备驱动程序而言，`resume_noirq()`与`restore_noirq()`之间没有区别。

### 3.1.13. restore()
^^^^^^^^^^^^^^^^^

`restore()`回调同样是针对休眠特定的。它在系统中所有设备的`restore_noirq()`回调执行完毕，并且PM核心已经使设备驱动程序的中断处理器可以被调用之后执行。

这个回调类似于`resume()`，正如`restore_noirq()`与`resume_noirq()`类似。因此，`restore_noirq()`与`restore()`之间的区别类似于`resume_noirq()`与`resume()`之间的区别。

对于绝大多数PCI设备驱动程序而言，`resume()`与`restore()`之间没有区别。

### 3.1.14. complete()
^^^^^^^^^^^^^^^^^^

`complete()`回调在以下情况中执行：

- 在系统恢复过程中，在所有设备的`resume()`回调执行之后；
- 在休眠过程中，在保存系统镜像之前，所有设备的`thaw()`回调执行之后；
- 在系统恢复时，当系统正回到休眠前的状态，在所有设备的`restore()`回调执行之后。
也可能在将休眠镜像加载到内存中失败时执行。
（在这种情况下，它会在为所有具有启动内核中驱动程序的设备执行完thaw()回调之后运行）
此回调完全是可选的，尽管如果prepare()回调执行了需要撤销的操作，则可能需要实现它。

3.1.15. runtime_suspend()
^^^^^^^^^^^^^^^^^^^^^^^^^

runtime_suspend()回调函数是针对设备运行时电源管理（运行时PM）特有的。当设备即将被挂起（即，静止并转入低功耗状态）时，由电源管理核心的运行时PM框架执行该回调。
此回调负责冻结设备并将其准备转入低功耗状态，但它必须允许PCI子系统执行所有必要的PCI特定操作来挂起设备。

3.1.16. runtime_resume()
^^^^^^^^^^^^^^^^^^^^^^^^

runtime_resume()回调函数是针对设备运行时PM特有的。当设备即将被恢复（即，转入全功率状态并正常处理I/O）时，由电源管理核心的运行时PM框架执行该回调。
此回调负责在PCI子系统将设备置于全功率状态后恢复设备的正常功能。
设备预计在runtime_resume()返回后能够以常规方式处理I/O。

3.1.17. runtime_idle()
^^^^^^^^^^^^^^^^^^^^^^

runtime_idle()回调函数是针对设备运行时PM特有的。每当根据电源管理核心的信息认为可能希望挂起设备时，由电源管理核心的运行时PM框架执行该回调。特别是，在runtime_resume()返回后立即自动执行此回调，以防设备恢复是由虚假事件引起的。
此回调是可选的，但如果未实现或返回0，则PCI子系统将调用pm_runtime_suspend()，进而导致驱动程序的runtime_suspend()回调被执行。

3.1.18. 指向多个回调指针的一个例程
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

虽然原则上每个在前面小节中描述的回调都可以定义为单独的函数，但通常将struct dev_pm_ops中的两个或多个成员指向同一个例程会很方便。为此目的有几个方便的宏可以使用。
### SIMPLE_DEV_PM_OPS 宏
`SIMPLE_DEV_PM_OPS` 宏声明了一个 `struct dev_pm_ops` 对象，其中包含一个由 `.suspend()`、`.freeze()` 和 `.poweroff()` 成员指向的挂起例程，以及一个由 `.resume()`、`.thaw()` 和 `.restore()` 成员指向的恢复例程。此 `struct dev_pm_ops` 中的其他函数指针未设置。

### UNIVERSAL_DEV_PM_OPS 宏
`UNIVERSAL_DEV_PM_OPS` 宏类似于 `SIMPLE_DEV_PM_OPS`，但除此之外还设置了 `.runtime_resume()` 指针为与 `.resume()`（和 `.thaw()`、`.restore()`）相同的值，并将 `.runtime_suspend()` 指针设置为与 `.suspend()`（和 `.freeze()`、`.poweroff()`）相同的值。

### SET_SYSTEM_SLEEP_PM_OPS
`SET_SYSTEM_SLEEP_PM_OPS` 可以在 `struct dev_pm_ops` 的声明中使用，以指示一个挂起例程由 `.suspend()`、`.freeze()` 和 `.poweroff()` 成员指向，而一个恢复例程由 `.resume()`、`.thaw()` 和 `.restore()` 成员指向。

### 3.1.19. 功率管理的驱动程序标志
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

功率管理核心允许设备驱动程序设置影响核心本身和中间层代码（包括 PCI 总线类型）对设备进行功率管理处理的标志。这些标志应该在驱动程序探测时通过 `dev_pm_set_driver_flags()` 函数一次性设置，之后不应该直接更新它们。

- `DPM_FLAG_NO_DIRECT_COMPLETE` 标志阻止功率管理核心使用允许在系统挂起开始时跳过设备挂起/恢复回调的直接完成机制。这也会影响设备的所有祖先节点，因此该标志仅在绝对必要时才应使用。
  
- `DPM_FLAG_SMART_PREPARE` 标志导致 PCI 总线类型仅当设备驱动程序提供的 `->prepare` 回调返回正值时才从 `pci_pm_prepare()` 返回正值。这允许驱动程序动态选择不使用直接完成机制（而设置 `DPM_FLAG_NO_DIRECT_COMPLETE` 则意味着永久性退出）。

- `DPM_FLAG_SMART_SUSPEND` 标志告诉 PCI 总线类型，从驱动程序的角度来看，在系统挂起期间可以安全地让设备保持在运行时挂起状态。这会导致 `pci_pm_suspend()`、`pci_pm_freeze()` 和 `pci_pm_poweroff()` 避免除非有特定的 PCI 原因才会从运行时挂起恢复设备。此外，如果设备在正在进行的全局转换的“后期”阶段保持在运行时挂起，则 `pci_pm_suspend_late/noirq()` 和 `pci_pm_poweroff_late/noirq()` 将提前返回。此外，如果设备在 `pci_pm_resume_noirq()` 或 `pci_pm_restore_noirq()` 中处于运行时挂起状态，则其运行时 PM 状态将更改为“活动”（因为它将进入 D0 状态）。

- 设置 `DPM_FLAG_MAY_SKIP_RESUME` 标志意味着驱动程序允许其 “noirq” 和 “early” 恢复回调在设备可以在系统范围内的工作状态转换后保持挂起的情况下被跳过。该标志与设备的 `power.may_skip_resume` 状态位一起被功率管理核心考虑，该状态位在某些情况下由 `pci_pm_suspend_noirq()` 设置。如果功率管理核心确定应跳过驱动程序的 “noirq” 和 “early” 恢复回调，则 `dev_pm_skip_resume()` 辅助函数将返回 “true”，这将导致 `pci_pm_resume_noirq()` 和 `pci_pm_resume_early()` 不触碰设备也不执行驱动程序回调就直接返回。

### 3.2. 设备运行时功率管理
------------------------------------

除了提供设备功率管理回调之外，PCI 设备驱动程序还负责控制其设备的运行时功率管理（运行时 PM）。
PCI 设备的运行时电源管理（PM）是可选的，但建议 PCI 设备驱动程序至少在能够可靠地验证设备未被使用的情况下实现它（例如，当网络电缆从以太网适配器上断开或没有设备连接到 USB 控制器时）。为了支持 PCI 运行时 PM，驱动程序首先需要实现 `runtime_suspend()` 和 `runtime_resume()` 回调函数。此外，可能还需要实现 `runtime_idle()` 回调函数来防止设备在 `runtime_resume()` 回调函数返回后立即再次被挂起（或者，`runtime_suspend()` 回调函数必须检查设备是否确实应该被挂起，并在不适用的情况下返回 `-EAGAIN`）。

PCI 核心默认启用 PCI 设备的运行时 PM。PCI 设备驱动程序不需要启用它，也不应尝试这样做。然而，它被 `pci_pm_init()` 阻止，该函数运行 `pm_runtime_forbid()` 辅助函数。除此之外，每个 PCI 设备的运行时 PM 使用计数器会在执行由设备驱动程序提供的探测回调之前通过 `local_pci_probe()` 增加。

如果 PCI 驱动程序实现了运行时 PM 回调函数，并打算使用由 PM 核心和 PCI 子系统提供的运行时 PM 框架，则需要在其探测回调函数中递减设备的运行时 PM 使用计数器。如果不这样做，对于该设备，计数器将始终非零，设备永远不会进入运行时挂起状态。最简单的方法是调用 `pm_runtime_put_noidle()`，但如果驱动程序希望立即安排自动挂起，例如，它可以调用 `pm_runtime_put_autosuspend()` 来达到这个目的。通常，它只需要从其探测例程调用一个递减设备使用计数器的函数，以便为设备启用运行时 PM。

重要的是要记住，驱动程序的 `runtime_suspend()` 回调函数可能在使用计数器被递减后立即被执行，因为用户空间可能已经通过 sysfs 调用了 `pm_runtime_allow()` 辅助函数解除了对设备运行时 PM 的阻止，因此驱动程序必须准备好处理这种情况。

驱动程序本身不应调用 `pm_runtime_allow()`。相反，应让用户空间或某些平台特定代码来做这件事（用户空间可以通过 sysfs 来做，如上所述），但它必须准备好在 `pm_runtime_allow()` 被调用后正确处理设备的运行时 PM（这可能发生在任何时候，甚至在驱动程序加载之前）。

当驱动程序的移除回调运行时，它需要平衡在探测时对设备运行时 PM 使用计数器的递减操作。为此，如果它已经在其探测回调中递减了计数器，则必须在其移除回调中运行 `pm_runtime_get_noresume()`。[由于核心在运行驱动程序的移除回调之前会执行设备的运行时恢复并增加设备的使用计数器，因此在移除执行期间，设备的运行时 PM 实际上是禁用的，并且所有递增设备使用计数器的运行时 PM 辅助函数实际上等同于 `pm_runtime_get_noresume()`。]

运行时 PM 框架通过处理挂起或恢复设备的请求或检查它们是否空闲（在这种情况下随后请求挂起它们是合理的）来工作。这些请求表示为放入电源管理队列 `pm_wq` 中的工作项。虽然在某些情况下，PM 核心会自动排队电源管理请求（例如，在处理恢复设备的请求之后，PM 核心会自动排队检查设备是否空闲的请求），但设备驱动程序通常负责为其设备排队电源管理请求。为此，他们应该使用 PM 核心提供的运行时 PM 辅助函数，详情请参阅 `Documentation/power/runtime_pm.rst`。

设备也可以同步挂起和恢复，无需将请求放入 `pm_wq`。大多数情况下，这也由其驱动程序完成，它们使用 PM 核心为此目的提供的辅助函数。有关设备运行时 PM 的更多信息，请参阅 `Documentation/power/runtime_pm.rst`。
资源
============

PCI 局部总线规范，修订版 3.0

PCI 总线电源管理接口规范，修订版 1.2

高级配置和电源接口（ACPI）规范，修订版 3.0b

PCI Express 基础规范，修订版 2.0

文档/driver-api/pm/devices.rst

文档/power/runtime_pm.rst
