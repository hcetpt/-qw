PCI电源管理
====================

版权所有 © 2010 Rafael J. Wysocki <rjw@sisk.pl>，Novell公司
这是关于PCI电源管理概念以及与之相关的Linux内核接口的概述。基于Patrick Mochel <mochel@transmeta.com>（及其他人员）的先前工作。
本文档仅涵盖了与PCI设备特有的电源管理方面。对于内核中与设备电源管理相关的通用接口的描述，请参阅Documentation/driver-api/pm/devices.rst和Documentation/power/runtime_pm.rst。
.. 目录：

   1. 硬件和平台对PCI电源管理的支持
   2. PCI子系统和设备电源管理
   3. PCI设备驱动程序和电源管理
   4. 资源


1. 硬件和平台对PCI电源管理的支持
=========================================================

1.1. 原生和基于平台的电源管理
-----------------------------------------------

通常，电源管理是一种功能，允许通过将设备置于功耗较低的状态（低功耗状态）来节省能源，代价是降低功能或性能。
通常，当设备未充分利用或完全不活动时，会将其置于低功耗状态。然而，一旦需要再次使用该设备，必须将其恢复到“完全功能”状态（全功率状态）。这可能发生在有数据需要处理或外部事件要求设备处于活动状态的情况下，这可能由设备自身发出信号。
PCI设备可以通过两种方式进入低功耗状态：一种是使用PCI总线电源管理接口规范引入的设备能力；另一种是在平台固件（如ACPI BIOS）的帮助下实现。在第一种方法中，即以下所称的原生PCI电源管理（原生PCI PM），设备电源状态的变化是由于向其标准配置寄存器之一写入特定值的结果。第二种方法则需要平台固件提供特殊方法，内核可以使用这些方法来改变设备的电源状态。
支持原生PCI PM的设备通常能够生成唤醒信号，称为电源管理事件（PMEs），以通知内核有关需要设备活跃的外部事件。在接收到PME后，内核应将发送它的设备置于全功率状态。但是，PCI总线电源管理接口规范并未定义从设备到CPU和操作系统内核的标准PME传输方法。
假设平台固件将执行此任务，因此即使PCI设备设置为生成PMEs，也可能需要准备平台固件以通知CPU来自设备的PMEs（例如，通过生成中断）。
相反，如果使用平台固件提供的方法来改变设备的电源状态，通常平台也会提供一种方法来准备设备生成唤醒信号。然而，在这种情况下，通常还需要使用原生PCI PM机制来准备设备生成PMEs，因为平台提供的方法依赖于这一点。
因此，在许多情况下，为了获得预期的结果，必须同时使用原生和基于平台的电源管理机制。
1.2. 本机PCI电源管理
------------------------

在PCI 2.1和PCI 2.2规范之间引入了PCI总线电源管理接口规范（PCI PM规范）。它定义了一个用于执行与电源管理相关的各种操作的标准接口。
对于传统PCI设备，实现PCI PM规范是可选的，但对于PCI Express设备则是强制性的。如果一个设备支持PCI PM规范，那么在其PCI配置空间中会有一个8字节的电源管理功能字段。这个字段被用来描述和控制与本机PCI电源管理相关的标准特性。
PCI PM规范为设备（D0-D3）和总线（B0-B3）定义了4种运行状态。数字越大，该状态下设备或总线消耗的功率越少。然而，数字越大，设备或总线返回到全功率状态（D0或B0，分别对应）的延迟时间也越长。
规范定义了D3状态的两个变体。第一个是D3hot，被称为软件可访问的D3，因为可以编程设备进入此状态。第二个是D3cold，这是当从PCI设备移除供电电压（Vcc）时设备所处的状态。不可能编程PCI设备进入D3cold，尽管可能存在一个可编程接口，可以将设备所在的总线置于所有总线上的设备都被移除Vcc的状态。
然而，在撰写本文时，Linux内核并不支持PCI总线电源管理，因此本文档不涵盖这一主题。
需要注意的是，每个PCI设备都可以处于全功率状态（D0）或D3cold，无论它是否实现了PCI PM规范。除此之外，如果设备实现了PCI PM规范，它必须同时支持D3hot和D0。对D1和D2电源状态的支持是可选的。
支持PCI PM规范的PCI设备可以被编程进入任何支持的低功耗状态（除了D3cold）。在D1-D3hot状态下，设备的标准配置寄存器必须对软件可访问（即设备需要响应PCI配置访问），尽管此时其I/O和内存空间被禁用。这允许设备被编程地置入D0。因此，内核可以在D0和受支持的低功耗状态（除了D3cold）之间切换设备，并且设备可能经历的电源状态转换如下：

+----------------------------+
| 当前状态 | 新状态      |
+----------------------------+
| D0       | D1, D2, D3  |
+----------------------------+
| D1       | D2, D3      |
+----------------------------+
| D2       | D3          |
+----------------------------+
| D1, D2, D3| D0          |
+----------------------------+

从D3cold到D0的转换发生在向设备提供供电电压（即恢复电力）时。在这种情况下，设备通过完整的上电重置序列返回到D0，并且硬件将上电默认值恢复到设备，就像初始上电一样。
支持PCI PM规范的PCI设备可以被编程在任何电源状态（D0-D3）下生成PMEs（电源管理事件），但它们不必能够在所有支持的电源状态下生成PMEs。特别是，从D3cold生成PMEs的能力是可选的，取决于是否存在额外的电压（3.3Vaux），使设备能够保持足够的活性以生成唤醒信号。

1.3. ACPI设备电源管理
--------------------------

平台固件对PCI设备电源管理的支持是系统特定的。然而，如果系统符合高级配置和电源接口（ACPI）规范，如大多数基于x86的系统，它应该实现由ACPI标准定义的设备电源管理接口。
为此，ACPI BIOS提供了特殊的函数，称为“控制方法”，这些函数可以由内核执行以执行特定任务，例如将设备置于低功耗状态。这些控制方法使用一种名为ACPI机器语言（AML）的特殊字节码语言编码，并存储在机器的BIOS中。内核从BIOS加载它们，并在需要时使用AML解释器执行它们，该解释器将AML字节码转换为计算和内存或I/O空间访问。这样，理论上，BIOS编写者可以为内核提供根据系统设计以系统特定的方式执行动作的手段。
ACPI控制方法可以分为全局控制方法和设备控制方法。全局控制方法不与任何特定设备相关联，而设备控制方法必须为平台预期处理的每个设备单独定义。这意味着ACPI设备控制方法仅能用于处理BIOS编写者预先了解的设备。设备电源管理中使用的ACPI方法属于此类。

ACPI规范假设设备可能处于四种电源状态之一，标记为D0、D1、D2和D3，大致对应于本机PCI PM的D0-D3状态（尽管ACPI并未考虑D3hot和D3cold之间的区别）。此外，对于设备的每个电源状态，都有一组需要启用的电源资源，以便将设备置于该状态。这些电源资源通过它们自己的控制方法（_ON和_OFF）进行控制，这些方法必须为每一个资源单独定义。

要将设备置于ACPI电源状态Dx（其中x是介于0到3之间的数字），内核应该（1）使用_ON控制方法启用此状态下设备所需的电源资源，并（2）执行为设备定义的_PSx控制方法。此外，如果设备即将进入低功耗状态（D1-D3），并且预计从该状态产生唤醒信号，则在_PSx之前应执行其定义的_DSW（或_PSW，在ACPI 3.0中被_DSW取代）控制方法。对于目标电源状态中设备不需要且其他设备不再需要的电源资源，应禁用它们（通过执行它们的_OFF控制方法）。如果设备的当前电源状态为D3，那么只能以这种方式将其置于D0。

然而，设备的电源状态通常在系统范围内的睡眠状态转换或返回工作状态时发生变化。ACPI定义了四个系统睡眠状态，S1、S2、S3和S4，并将系统工作状态表示为S0。一般而言，目标系统睡眠（或工作）状态决定了设备可以被置于的最高功率（最低编号）状态，内核应通过执行设备的_SxD控制方法（其中x是一个介于0到4之间的数字）来获取此信息。

如果设备需要从目标睡眠状态唤醒系统，它能被置于的最低功率（最高编号）状态也由系统的状态确定。然后，内核应使用设备的_SxW控制方法来获取该状态的编号。它还应使用设备的_PRW控制方法来了解为了使设备能够生成唤醒信号，哪些电源资源需要启用。

### 1.4 唤醒信号

由PCI设备生成的唤醒信号，无论是作为本机PCI PME还是在将设备置于低功耗状态前执行_DSW（或_PSW）ACPI控制方法的结果，都必须被捕捉并适当地处理。如果它们在系统处于工作状态（ACPI S0）时发送，应将它们转换为中断，以便内核可以将生成它们的设备置于全功率状态，并处理触发它们的事件。另一方面，如果它们在系统休眠时发送，它们应导致系统的主逻辑触发唤醒。

在基于ACPI的系统上，由传统PCI设备发送的唤醒信号被转换为ACPI通用事件（GPE），这是系统主逻辑在响应需要采取行动的各种事件时生成的硬件信号。每个GPE都与一个或多个潜在有趣的事件源关联。特别是，GPE可能与能够发出唤醒信号的PCI设备相关联。GPE与事件源之间的连接信息记录在系统的ACPI BIOS中，内核可以从那里读取。

如果系统ACPI BIOS已知的PCI设备发出唤醒信号，与之关联的GPE（如果存在）将被触发。与PCI桥关联的GPE也可能因桥下某个设备的唤醒信号而被触发（根桥也是这种情况），例如，系统ACPI BIOS未知的设备的本机PCI PME可能通过这种方式处理。

GPE可能在系统休眠（即处于ACPI S1-S4状态之一）时被触发，此时系统的核心逻辑开始启动唤醒（稍后可能会识别出导致系统唤醒的信号源）。在这种情况下使用的GPE被称为唤醒GPE。

然而，通常当系统处于工作状态（ACPI S0）时，GPE也会被触发，此时系统的核心逻辑会生成系统控制中断（SCI）以通知内核发生的事件。然后，SCI处理器会识别出引起中断的GPE，这反过来允许内核识别事件的来源（可能是发出唤醒信号的PCI设备）。在系统处于工作状态时用于通知内核事件的GPE被称为运行时GPE。
不幸的是，在非ACPI（高级配置和电源接口）系统中，处理传统PCI设备发送的唤醒信号没有标准方法，但对于PCI Express设备则存在一种方法。具体来说，PCI Express基础规范引入了一种将本地PCI PME（电源管理事件）转换为根端口生成的中断的原生机制。对于传统的PCI设备，原生PME是带外的，因此它们被单独路由，无需通过桥接器（原则上，它们可以直接路由到系统的内核逻辑），但对PCI Express设备而言，它们是在带内消息，必须通过PCI Express层次结构，包括从设备到根复合体路径上的根端口。因此，可以引入一种机制，使根端口在接收到其下任何设备发送的PME消息时生成中断。然后，发送PME消息的设备的PCI Express请求者ID会记录在根端口的一个配置寄存器中，中断处理程序可从中读取，从而允许识别该设备。[由与根复合体集成的PCI Express端点发送的PME消息不会经过根端口，而是导致根复合体事件收集器（如果存在）生成中断。]

原则上，原生PCI Express PME信号也可以在基于ACPI的系统上与GPE（通用可编程事件）一起使用，但要使用它，内核必须要求系统的ACPI BIOS释放对根端口配置寄存器的控制。然而，ACPI BIOS没有义务允许内核控制这些寄存器，如果它不允许，内核不得修改它们的内容。当然，在这种情况下，内核无法使用原生PCI Express PME信号。

2. PCI子系统和设备电源管理
===============================

2.1. 设备电源管理回调
-----------------------

PCI子系统以多种方式参与PCI设备的电源管理。首先，它在设备电源管理核心（PM核心）和PCI设备驱动程序之间提供了一个中间代码层。具体而言，PCI子系统的struct bus_type对象pci_bus_type中的pm字段指向一个struct dev_pm_ops对象pci_dev_pm_ops，其中包含指向多个设备电源管理回调的指针：

```const struct dev_pm_ops pci_dev_pm_ops = {
	.prepare = pci_pm_prepare,
	.complete = pci_pm_complete,
	.suspend = pci_pm_suspend,
	.resume = pci_pm_resume,
	.freeze = pci_pm_freeze,
	.thaw = pci_pm_thaw,
	.poweroff = pci_pm_poweroff,
	.restore = pci_pm_restore,
	.suspend_noirq = pci_pm_suspend_noirq,
	.resume_noirq = pci_pm_resume_noirq,
	.freeze_noirq = pci_pm_freeze_noirq,
	.thaw_noirq = pci_pm_thaw_noirq,
	.poweroff_noirq = pci_pm_poweroff_noirq,
	.restore_noirq = pci_pm_restore_noirq,
	.runtime_suspend = pci_pm_runtime_suspend,
	.runtime_resume = pci_pm_runtime_resume,
	.runtime_idle = pci_pm_runtime_idle,
};```

这些回调在与设备电源管理相关的情况下由PM核心执行，并反过来执行由PCI设备驱动程序提供的电源管理回调。它们还执行涉及PCI设备某些标准配置寄存器的电源管理操作，而这些操作设备驱动程序不必了解或关心。

表示PCI设备的结构struct pci_dev包含几个这些回调操作的字段：

```struct pci_dev {
	..
pci_power_t     current_state;  /* 当前运行状态。 */
	int		pm_cap;		/* 配置空间中电源管理能力结构的偏移量 */
	unsigned int	pme_support:5;	/* 可以从哪些状态生成PME#的位掩码 */
	unsigned int	pme_poll:1;	/* 轮询设备的PME状态位 */
	unsigned int	d1_support:1;	/* 支持低功耗状态D1 */
	unsigned int	d2_support:1;	/* 支持低功耗状态D2 */
	unsigned int	no_d1d2:1;	/* 禁止D1和D2 */
	unsigned int	wakeup_prepared:1;  /* 设备已准备好唤醒 */
	unsigned int	d3hot_delay;	/* D3hot->D0转换时间（毫秒） */
	..
};```

它们还间接使用嵌入在struct pci_dev中的struct device的一些字段。

2.2. 设备初始化
----------------

PCI子系统与设备电源管理相关的首要任务是准备设备进行电源管理并初始化用于此目的的struct pci_dev字段。这发生在drivers/pci/中定义的两个函数中，pci_pm_init()和pci_acpi_setup()。

第一个函数检查设备是否支持原生PCI PM，如果是这样，则将在设备的struct pci_dev对象的pm_cap字段中存储其电源管理能力结构在配置空间中的偏移量。接下来，函数检查设备支持哪些PCI低功耗状态以及设备可以从哪些低功耗状态生成原生PCI PME。相应地更新设备的struct pci_dev和嵌入其中的struct device的电源管理字段，并禁用设备生成PME。

第二个函数检查设备是否可以借助平台固件（如ACPI BIOS）来准备发出唤醒信号。如果是这样，该函数更新嵌入在设备的struct pci_dev中的struct device的唤醒字段，并使用固件提供的方法阻止设备发出唤醒信号。
此时，设备已准备好进行电源管理。然而，对于无驱动设备，此功能仅限于在系统范围的睡眠状态和工作状态转换期间执行的一些基本操作。

2.3 运行时设备电源管理
-------------------------------

PCI 子系统在 PCI 设备运行时电源管理中扮演着重要角色。为此，它使用了在文档 `Documentation/power/runtime_pm.rst` 中描述的一般运行时电源管理（运行时 PM）框架。具体而言，它提供了子系统级回调：

- pci_pm_runtime_suspend()
- pci_pm_runtime_resume()
- pci_pm_runtime_idle()

这些回调由核心运行时 PM 例程执行。它还实现了处理 PCI 设备在低功耗状态下运行时唤醒信号所需的全部机制，截至本文档撰写时，这适用于原生 PCI Express PME 信号以及第 1 节所述的基于 ACPI GPE 的唤醒信号。

首先，通过调用 `pm_schedule_suspend()` 或 `pm_runtime_suspend()` 将 PCI 设备置于低功耗状态或挂起，这两个函数对 PCI 设备调用 `pci_pm_runtime_suspend()` 来完成实际工作。要使此操作生效，设备的驱动程序必须提供一个 `pm->runtime_suspend()` 回调（如下所述），这是 `pci_pm_runtime_suspend()` 执行的第一个动作。如果驱动程序的回调成功返回，将保存设备的标准配置寄存器，准备设备生成唤醒信号，并最终将其置于目标低功耗状态。

将设备置于的低功耗状态是其能够发出唤醒信号的最低功耗（最高编号）状态。唤醒信号的确切方法依赖于系统，并由 PCI 子系统根据设备报告的能力和平台固件确定。为了准备设备以发出唤醒信号并将其置于选定的低功耗状态，PCI 子系统可以使用平台固件以及设备的原生 PCI PM 功能（如果支持）。

预期设备驱动程序的 `pm->runtime_suspend()` 回调不会尝试准备设备以发出唤醒信号或将设备置于低功耗状态。驱动程序应将这些任务留给拥有执行所需所有信息的 PCI 子系统。

挂起的设备借助 `pm_request_resume()` 或 `pm_runtime_resume()` 帮助恢复到“活动”状态，这两个函数都为 PCI 设备调用 `pci_pm_runtime_resume()`。同样，这只有在设备的驱动程序提供了 `pm->runtime_resume()` 回调的情况下才有效（如下所述）。但是，在执行驱动程序的回调之前，`pci_pm_runtime_resume()` 将设备恢复到全功率状态，防止其在该状态下发出唤醒信号，并恢复其标准配置寄存器。因此，驱动程序的回调不必担心设备恢复过程中的 PCI 特定方面。

请注意，通常 `pci_pm_runtime_resume()` 可能在两种不同情况下被调用。首先，它可能是应设备驱动程序的要求调用的，例如，如果有一些数据需要处理。其次，它可能是由于设备自身的唤醒信号而被调用的（这有时被称为“远程唤醒”）。当然，为此目的，唤醒信号按照第 1 节所述的方式之一进行处理，并在识别源设备后最终转化为对 PCI 子系统的通知。

`pci_pm_runtime_idle()` 函数，由 `pm_runtime_idle()` 和 `pm_request_idle()` 对 PCI 设备调用，执行设备驱动程序的 `pm->runtime_idle()` 回调（如果定义的话），如果该回调没有返回错误代码（或者根本没有），则借助 `pm_runtime_suspend()` 挂起设备。

有时 `pci_pm_runtime_idle()` 会自动由 PM 核心调用（例如，在设备刚刚恢复后立即调用），在这种情况下，如果合理，它应该挂起设备。然而，通常 PCI 子系统并不真正知道设备是否真的可以被挂起，因此它让设备的驱动程序通过运行其 `pm->runtime_idle()` 回调来决定。
2.4. 系统范围的电源转换
-----------------------------
存在几种不同类型的系统范围电源转换，具体描述见
Documentation/driver-api/pm/devices.rst。每种转换都要求以特定方式处理设备，为此PM核心会执行子系统级别的电源管理回调。这些回调分阶段执行，确保在开始下一阶段前为属于给定子系统的每个设备执行相同的子系统级回调。这些阶段总是在任务被冻结后运行。

2.4.1. 系统挂起
^^^^^^^^^^^^^^^^^^^^^

当系统进入睡眠状态（如ACPI的S1至S3睡眠状态），其中内存内容将被保留时，各阶段如下：

准备，挂起，挂起无中断
以下PCI总线类型的回调分别用于这些阶段：

pci_pm_prepare()
pci_pm_suspend()
pci_pm_suspend_noirq()

pci_pm_prepare()首先借助pm_runtime_resume()将设备置于“完全功能”状态。然后，如果定义了（即驱动程序的struct dev_pm_ops对象存在且其中的prepare指针有效）设备驱动程序的pm->prepare()回调，则执行该回调。
pci_pm_suspend()首先检查设备驱动程序是否实现了传统PCI挂起例程（参见第3节），如果是，则执行驱动程序的传统挂起回调（如果存在），并返回其结果。接下来，如果设备驱动程序不提供struct dev_pm_ops对象（包含驱动程序回调的指针），则调用pci_pm_default_suspend()，这仅关闭设备的总线主控能力，并运行pcibios_disable_device()来禁用它，除非设备是桥接器（PCI桥接器被此例程忽略）。之后，如果定义了设备驱动程序的pm->suspend()回调，则执行该回调，如果失败则返回其结果。最后，调用pci_fixup_device()来必要时应用与设备相关的硬件挂起怪癖。
请注意，对于PCI设备，挂起阶段是异步进行的，因此对于任何一对在已知方式下相互独立的PCI设备（即从根桥接到叶设备的设备树路径中不同时包含它们两者），pci_pm_suspend()回调可能并行执行。
在调用suspend_device_irqs()之后执行pci_pm_suspend_noirq()例程，这意味着在此例程运行期间不会调用设备驱动程序的中断处理程序。它首先检查设备驱动程序是否实现传统PCI挂起例程（第3节），如果是，则调用传统延迟挂起例程并返回其结果（如果驱动程序的回调没有保存设备的标准配置寄存器，则保存它们）。其次，如果设备驱动程序的struct dev_pm_ops对象不存在，则保存设备的标准配置寄存器并返回成功。否则，如果存在，则执行设备驱动程序的pm->suspend_noirq()回调，并在失败时返回其结果。接下来，如果尚未保存设备的标准配置寄存器（之前执行的设备驱动程序的回调之一可能已经完成），pci_pm_suspend_noirq()将保存它们，准备设备发出唤醒信号（如果必要），并将其置于低功耗状态。
要将设备置于的低功耗状态是最省电（数字最高）的状态，在系统处于目标睡眠状态时，设备可以从该状态发出唤醒信号。正如上述运行时PM情况一样，发出唤醒信号的机制取决于系统，并由PCI子系统确定，该子系统还负责根据系统的目标睡眠状态适当地准备设备发出唤醒信号。
通常，不期望PCI设备驱动程序（未实现传统电源管理回调的）准备设备发出唤醒信号或将其置于低功耗状态。但是，如果驱动程序的其中一个挂起回调（pm->suspend()或pm->suspend_noirq()）保存了设备的标准配置寄存器，pci_pm_suspend_noirq()将假定设备已被驱动程序准备发出唤醒信号并置于低功耗状态（假设驱动程序使用了PCI子系统提供的辅助函数来实现这一目的）。虽然不鼓励PCI设备驱动程序这样做，但在某些罕见情况下，在驱动程序中这样做可能是最佳方法。

2.4.2. 系统恢复
^^^^^^^^^^^^^^^^^^^^

当系统从内存内容得以保存的睡眠状态（如ACPI的S1至S3睡眠状态）过渡到工作状态（ACPI S0）时，各阶段如下：

恢复无中断，恢复，完成
以下是在各个阶段中执行的PCI总线类型的回调函数：

- pci_pm_resume_noirq()
- pci_pm_resume()
- pci_pm_complete()

`pci_pm_resume_noirq()` 首先将设备置于全功率状态，恢复其标准配置寄存器，并在必要时应用与设备相关的早期恢复硬件特殊处理。这无条件地完成，无论设备驱动程序是否实现了传统的PCI电源管理回调（这样当设备中断处理程序在恢复过程中首次被调用时，所有PCI设备都处于全功率状态并且它们的标准配置寄存器已被恢复，从而允许内核避免处理共享中断的问题，即那些设备仍然处于挂起状态的驱动程序）。如果设备驱动程序实现了传统PCI电源管理回调（参见第3节），则执行传统早期恢复回调并返回其结果。否则，如果定义了设备驱动程序的pm->resume_noirq()回调，则执行该回调并返回其结果。

`pci_pm_resume()` 首先检查设备的标准配置寄存器是否已恢复，如果没有则进行恢复（这仅在挂起失败的错误路径中是必要的）。接下来，如果需要，应用与设备相关的恢复硬件特殊处理，如果设备驱动程序实现了传统PCI电源管理回调（参见第3节），则执行驱动程序的传统恢复回调并返回其结果。否则，阻止设备的唤醒信号机制，并执行其驱动程序的pm->resume()回调，如果定义的话（然后返回回调的结果）。

对于PCI设备，恢复阶段像上面描述的挂起阶段一样异步执行，这意味着如果两个PCI设备以未知方式相互独立，`pci_pm_resume()` 可能会同时为两者执行。

`pci_pm_complete()` 仅执行设备驱动程序的pm->complete()回调，如果定义的话。

**2.4.3 系统休眠**

系统休眠比系统挂起更复杂，因为它要求创建并写入到持久存储介质中的系统映像。映像是原子性创建的，在此之前所有设备都会被静止或冻结。

设备的静止化是在释放足够内存后（截至本文撰写时，映像创建至少需要50%的系统RAM空闲）按以下三个阶段进行：

- 准备，冻结，冻结_noirq

这些阶段对应于PCI总线类型的回调：

- pci_pm_prepare()
- pci_pm_freeze()
- pci_pm_freeze_noirq()

这意味着准备阶段与系统挂起完全相同。
然而，其他两个阶段不同。

`pci_pm_freeze()` 与 `pci_pm_suspend()` 相似，但运行的是设备驱动程序的pm->freeze()回调（如果定义），而不是pm->suspend()，且不应用与挂起相关的硬件特殊处理。它对不以已知方式相互依赖的不同PCI设备异步执行。

`pci_pm_freeze_noirq()` 反过来与 `pci_pm_suspend_noirq()` 类似，但它调用的是设备驱动程序的pm->freeze_noirq()例程，而不是pm->suspend_noirq()。它也不尝试为信号唤醒做准备并将设备置于低功耗状态。但是，如果设备的标准配置寄存器尚未由其中一个驱动程序回调保存，它仍然会保存它们。

一旦创建了映像，就必须将其保存。然而，此时所有设备都被冻结，无法处理I/O，而它们处理I/O的能力显然是保存映像所必需的。因此，必须将它们恢复到完全功能状态，这是通过以下阶段完成的：

- 解冻_noirq，解冻，完成

使用以下PCI总线类型的回调：

- pci_pm_thaw_noirq()
- pci_pm_thaw()
- pci_pm_complete()
它们中的第一个，`pci_pm_thaw_noirq()`，与`pci_pm_resume_noirq()`类似。
它将设备置于全功率状态并恢复其标准配置寄存器。如果定义了，它还会执行设备驱动程序的`pm->thaw_noirq()`回调，而不是`pm->resume_noirq()`。
`pci_pm_thaw()`例程与`pci_pm_resume()`相似，但它运行设备驱动程序的`pm->thaw()`回调，而不是`pm->resume()`。对于不同PCI设备，它是异步执行的，这些设备以已知方式相互独立。
完整的阶段与系统恢复时相同。
保存镜像后，在系统可以进入目标睡眠状态（对于基于ACPI的系统是ACPI S4）之前，需要关闭设备电源。这分三个阶段进行：

- 准备，关机，关机_noirq

其中准备阶段与系统挂起完全相同。其他两个阶段分别与挂起和挂起_noirq阶段类似。
与之对应的PCI子系统级回调为：

- `pci_pm_poweroff()`
- `pci_pm_poweroff_noirq()`

它们分别与`pci_pm_suspend()`和`pci_pm_suspend_noirq()`的工作方式类似，尽管它们不会尝试保存设备的标准配置寄存器。

### 2.4.4 系统恢复

系统恢复要求将休眠镜像加载到内存中，并在恢复休眠前的系统活动前恢复预休眠的内存内容。
如Documentation/driver-api/pm/devices.rst所述，休眠镜像是由一个新的内核实例，即启动内核加载到内存中的，该内核由引导加载程序以常规方式加载和运行。加载完镜像后，启动内核需要用自己的代码和数据替换“休眠”内核的代码和数据，该“休眠”内核存储在镜像中，称为镜像内核。为此，所有设备都会像在创建镜像休眠之前一样被冻结，在上述

- 准备，冻结，冻结_noirq

阶段中描述。但是，受这些阶段影响的设备仅限于启动内核中存在的驱动程序；其他设备将保持在引导加载程序留下的任何状态。
如果恢复预休眠的内存内容失败，启动内核将通过上面描述的“解冻”程序，使用解冻_noirq、解冻和完整阶段（这仅影响启动内核中具有驱动程序的设备），然后继续正常运行。
如果成功恢复了预休眠的内存内容，这是通常的情况，控制权将传递给镜像内核，它负责将系统恢复到工作状态。为了实现这一点，它必须恢复设备的预休眠功能，这与从内存睡眠状态唤醒非常相似，尽管涉及不同的阶段：

- 恢复_noirq，恢复，完整

其中前两个分别与上面描述的resume_noirq和resume阶段类似，对应以下PCI子系统的回调：

- `pci_pm_restore_noirq()`
- `pci_pm_restore()`

这些回调的工作方式分别与`pci_pm_resume_noirq()`和`pci_pm_resume()`类似，但它们执行设备驱动程序的`pm->restore_noirq()`和`pm->restore()`回调，如果可用的话。
完整阶段的执行方式与系统恢复时完全相同。

3. PCI 设备驱动程序和电源管理
==========================================

3.1. 电源管理回调函数
-------------------------------

PCI 设备驱动程序通过提供回调函数参与电源管理，这些回调函数由上述的 PCI 子系统的电源管理例程执行，并控制其设备的运行时电源管理。
在撰写本文时，为 PCI 设备驱动程序定义电源管理回调有两种方法：推荐的方法是基于使用在 `Documentation/driver-api/pm/devices.rst` 中描述的 `dev_pm_ops` 结构；另一种是“传统”方法，其中使用来自 `struct pci_driver` 的 `.suspend()` 和 `.resume()` 回调。然而，传统方法不允许定义运行时电源管理回调，并且实际上不适合任何新驱动程序。因此，本文件不涵盖传统方法（要了解更多信息，请参考源代码）。
建议所有 PCI 设备驱动程序定义一个包含电源管理(PM)回调指针的 `struct dev_pm_ops` 对象，这些回调将由 PCI 子系统的 PM 例程在各种情况下执行。必须将指向驱动程序的 `struct dev_pm_ops` 对象的指针分配给其 `struct pci_driver` 对象中的 `driver.pm` 字段。一旦完成，即使它们不为 NULL，“传统”PM 回调也将被忽略。
`struct dev_pm_ops` 中的 PM 回调不是强制性的，如果未定义（即 `struct dev_pm_ops` 的相应字段未设置），则 PCI 子系统将以简化默认方式处理设备。但如果定义了它们，则期望它们按以下子节所述的行为进行操作。

3.1.1. prepare()
^^^^^^^^^^^^^^^^

prepare() 回调在系统挂起、休眠（即将创建休眠图像）、保存休眠图像后的关机以及系统恢复（当休眠图像刚被加载到内存中时）期间执行。
此回调仅在驱动程序的设备有可随时注册的子设备时才必要。在这种情况下，prepare() 回调的作用是在运行 resume_noirq()、thaw_noirq() 或 restore_noirq() 回调之一之前，防止设备的新子设备被注册。
此外，prepare() 回调可以执行一些准备设备暂停的操作，尽管它不应该分配内存（如果需要额外内存来暂停设备，应该更早预分配，例如在 suspend/hibernate 通知器中，如 `Documentation/driver-api/pm/notifiers.rst` 所述）。

3.1.2. suspend()
^^^^^^^^^^^^^^^^

suspend() 回调仅在系统挂起期间执行，在为系统中所有设备执行了 prepare() 回调之后。
此回调预计会使设备静默并准备好由 PCI 子系统将其置于低功耗状态。不需要（事实上甚至不推荐）PCI 驱动程序的 suspend() 回调保存设备的标准配置寄存器、准备唤醒系统或将设备置于低功耗状态。所有这些操作都可以很好地由 PCI 子系统独立处理，无需驱动程序参与。
然而，在一些罕见的情况下，可能需要在PCI驱动程序中执行这些操作。这时，应当使用`pci_save_state()`、`pci_prepare_to_sleep()`和`pci_set_power_state()`来保存设备的标准配置寄存器，为系统唤醒做准备（如果必要），以及将其置于低功耗状态。此外，如果驱动程序调用了`pci_save_state()`，那么PCI子系统将不会为其设备执行`pci_prepare_to_sleep()`或`pci_set_power_state()`，因此，驱动程序需负责根据适当情况处理设备。

在执行`suspend()`回调期间，驱动程序的中断处理器可能会被调用来处理来自设备的中断，因此所有依赖于驱动程序中断处理能力的挂起相关操作应该在这个回调中进行。

3.1.3. `suspend_noirq()`
-------------------------

`suspend_noirq()`回调仅在系统挂起时执行，此时系统中所有设备的`suspend()`回调已经执行完毕，并且设备中断已经被PM核心禁用。

`suspend_noirq()`与`suspend()`的区别在于，当`suspend_noirq()`运行时，驱动程序的中断处理器将不会被调用。因此，`suspend_noirq()`可以执行在`suspend()`中会引发竞争条件的操作。

3.1.4. `freeze()`
------------------

`freeze()`回调是休眠专用的，它会在两种情况下执行：在休眠过程中，所有设备的`prepare()`回调执行完毕以准备创建系统映像；以及在恢复过程中，从持久存储加载的系统映像已载入内存，所有设备的`prepare()`回调已经执行完毕。

这个回调的作用类似于上面描述的`suspend()`回调。实际上，它们只需要在罕见情况下不同，即当驱动程序承担起将设备置于低功耗状态的责任时。

在这种情况下，`freeze()`回调不应准备设备系统唤醒或将其置于低功耗状态。然而，它或`freeze_noirq()`应使用`pci_save_state()`来保存设备的标准配置寄存器。

3.1.5. `freeze_noirq()`
------------------------

`freeze_noirq()`回调也是休眠专用的。它在休眠过程中执行，此时所有设备的`prepare()`和`freeze()`回调已经执行完毕以准备创建系统映像；以及在恢复过程中，系统映像已经载入内存后，所有设备的`prepare()`和`freeze()`回调已经执行完毕。它总是在设备中断被PM核心禁用之后执行。

这个回调的作用类似于上面描述的`suspend_noirq()`回调，而且非常罕见地需要定义`freeze_noirq()`。

`freeze_noirq()`与`freeze()`之间的区别类似于`suspend_noirq()`与`suspend()`之间的区别。
3.1.6. poweroff()
^^^^^^^^^^^^^^^^^

`poweroff()` 回调函数是针对休眠操作的。当系统即将关闭电源并在持久化存储中保存了休眠镜像后，会执行此回调。在调用 `poweroff()` 之前，会对所有设备执行 `prepare()` 回调。
此回调的作用类似于上文描述的 `suspend()` 和 `freeze()` 回调，尽管它不需要保存设备寄存器的内容。特别地，如果驱动程序希望将设备置于低功耗状态，而不是让 PCI 子系统来做这件事，则 `poweroff()` 回调应该使用 `pci_prepare_to_sleep()` 和 `pci_set_power_state()` 来为系统的唤醒做准备，并将其置于低功耗状态，但不必保存设备的标准配置寄存器。

3.1.7. poweroff_noirq()
^^^^^^^^^^^^^^^^^^^^^^^

`poweroff_noirq()` 回调函数也是针对休眠操作的。在对系统中的所有设备执行了 `poweroff()` 回调之后，会执行此回调。
此回调的作用类似于上文描述的 `suspend_noirq()` 和 `freeze_noirq()` 回调，但它不需要保存设备寄存器的内容。
`poweroff_noirq()` 和 `poweroff()` 之间的区别类似于 `suspend_noirq()` 和 `suspend()` 之间的区别。

3.1.8. resume_noirq()
^^^^^^^^^^^^^^^^^^^^^

`resume_noirq()` 回调仅在系统恢复期间执行，即在电源管理核心已启用非启动 CPU 之后。在 `resume_noirq()` 运行时，不会调用驱动程序的中断处理程序，因此此回调可以执行可能与中断处理程序发生竞争的操作。
由于 PCI 子系统无条件地将所有设备置于全功率状态并在系统恢复的 `resume_noirq` 阶段恢复其标准配置寄存器，通常情况下 `resume_noirq()` 是不必要的。通常只应在执行可能导致竞争条件的操作时使用它，而不是在 `resume()` 中执行。

3.1.9. resume()
^^^^^^^^^^^^^^^

`resume()` 回调仅在系统恢复期间执行，在对系统中的所有设备执行了 `resume_noirq()` 回调并且由电源管理核心启用了设备中断之后。
此回调负责恢复设备的预暂停配置并使其恢复到完全功能状态。`resume()` 返回后，设备应能够以常规方式处理 I/O 操作。

3.1.10. thaw_noirq()
^^^^^^^^^^^^^^^^^^^^

`thaw_noirq()` 回调是针对休眠操作的。在创建了系统镜像并且电源管理核心启用了非启动 CPU 后，在休眠的 `thaw_noirq` 阶段执行此回调。如果在系统恢复过程中加载休眠镜像失败，也可能执行此回调（在这种情况下，在启用非启动 CPU 后执行）。在 `thaw_noirq()` 运行时，不会调用驱动程序的中断处理程序。
### 3.1.11. thaw()
^^^^^^^^^^^^^^

`thaw()`回调是针对休眠特定的。它在系统中所有设备的`thaw_noirq()`回调执行完毕，并且电源管理（PM）核心已经启用了设备中断之后执行。

此回调负责恢复设备在冻结前的配置状态，以便在`thaw()`返回后设备能够正常工作。

### 3.1.12. restore_noirq()
^^^^^^^^^^^^^^^^^^^^^^^

`restore_noirq()`回调也是针对休眠特定的。它在休眠的`restore_noirq`阶段执行，此时引导内核已将控制权传递给镜像内核，非引导CPU已经被镜像内核的PM核心启用。

此回调与`resume_noirq()`类似，不同之处在于它不能对设备的先前状态作出任何假设，即使BIOS（或通常平台固件）已知在挂起-恢复周期中保留了该状态。

对于绝大多数PCI设备驱动程序来说，`resume_noirq()`和`restore_noirq()`之间没有区别。

### 3.1.13. restore()
^^^^^^^^^^^^^^^^^

`restore()`回调同样是针对休眠特定的。它在系统中所有设备的`restore_noirq()`回调执行完毕，并且PM核心已使设备驱动程序的中断处理器可以被调用之后执行。

此回调类似于`resume()`，正如`restore_noirq()`类似于`resume_noirq()`一样。因此，`restore_noirq()`与`restore()`之间的区别类似于`resume_noirq()`与`resume()`之间的区别。

对于绝大多数PCI设备驱动程序来说，`resume()`和`restore()`之间没有区别。

### 3.1.14. complete()
^^^^^^^^^^^^^^^^^^

`complete()`回调在以下情况下执行：

- 在系统恢复过程中，在为所有设备执行`resume()`回调之后；
- 在休眠过程中，在保存系统镜像之前，在为所有设备执行`thaw()`回调之后；
- 在系统恢复过程中，当系统回到休眠前的状态时，在为所有设备执行`restore()`回调之后。
这也可能在将休眠映像加载到内存失败时执行（在这种情况下，在所有具有启动内核中驱动程序的设备上执行完thaw()回调后运行）
此回调是完全可选的，尽管如果prepare()回调执行了需要被撤销的操作，它可能是必要的。

3.1.15. runtime_suspend()

^^^^^^^^^^^^^^^^^^^^^^^^^

runtime_suspend()回调特定于设备运行时电源管理（运行时PM）。当设备即将在运行时被挂起（即静止并进入低功耗状态）时，由PM核心的运行时PM框架执行。
此回调负责冻结设备并准备将其置于低功耗状态，但它必须允许PCI子系统执行所有为挂起设备所必需的PCI特定操作。

3.1.16. runtime_resume()

^^^^^^^^^^^^^^^^^^^^^^^^

runtime_resume()回调特定于设备运行时PM。当设备即将在运行时被恢复（即置于全功率状态并编程以正常处理I/O）时，由PM核心的运行时PM框架执行。
此回调负责在PCI子系统已将设备置于全功率状态后恢复设备的正常功能。
设备应在runtime_resume()返回后能够以常规方式处理I/O。

3.1.17. runtime_idle()

^^^^^^^^^^^^^^^^^^^^^^

runtime_idle()回调特定于设备运行时PM。每当根据PM核心的信息可能希望挂起设备时，由PM核心的运行时PM框架执行。特别地，如果设备恢复是由于错误事件的结果，那么在runtime_resume()返回后立即自动执行。
此回调是可选的，但如果未实现或返回0，PCI子系统将为设备调用pm_runtime_suspend()，这将导致执行驱动程序的runtime_suspend()回调。

3.1.18. 指向多个回调指针的一个例程

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

虽然原则上每个在前几节描述的回调都可以定义为一个单独的函数，但通常将struct dev_pm_ops的两个或多个成员指向同一个例程是很方便的。为此有几个便利的宏可以使用。
SIMPLE_DEV_PM_OPS 宏声明了一个 struct dev_pm_ops 对象，其中有一个挂起例程由 .suspend()、.freeze() 和 .poweroff() 成员指向，以及一个恢复例程由 .resume()、.thaw() 和 .restore() 成员指向。此 struct dev_pm_ops 中的其他函数指针未设置。

UNIVERSAL_DEV_PM_OPS 宏与 SIMPLE_DEV_PM_OPS 类似，但额外地将 .runtime_resume() 指针设置为与 .resume()（和 .thaw()，和 .restore()）相同的值，并将 .runtime_suspend() 指针设置为与 .suspend()（和 .freeze() 和 .poweroff()）相同的值。

SET_SYSTEM_SLEEP_PM_OPS 可以在 struct dev_pm_ops 的声明中使用，以指示应由 .suspend()、.freeze() 和 .poweroff() 成员指向一个挂起例程，以及由 .resume()、.thaw() 和 .restore() 成员指向一个恢复例程。

3.1.19. 功耗管理的驱动程序标志
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

功耗核心允许设备驱动程序设置影响核心本身及包括 PCI 总线类型在内的中间层代码处理设备功耗管理的标志。这些标志应该在驱动程序探测时仅设置一次，借助 dev_pm_set_driver_flags() 函数，并且之后不应直接更新。

DPM_FLAG_NO_DIRECT_COMPLETE 标志阻止功耗核心使用允许跳过设备挂起/恢复回调的直接完成机制，如果设备在系统挂起开始时处于运行时挂起状态。这也会影响设备的所有祖先，因此这个标志只应在绝对必要时使用。

DPM_FLAG_SMART_PREPARE 标志导致 PCI 总线类型仅当设备驱动程序提供的 ->prepare 回调返回正值时从 pci_pm_prepare() 返回正值。这允许驱动程序动态选择不使用直接完成机制（而设置 DPM_FLAG_NO_DIRECT_COMPLETE 则意味着永久退出）。

DPM_FLAG_SMART_SUSPEND 标志告诉 PCI 总线类型，从驱动程序的角度来看，设备在系统挂起期间可以安全地留在运行时挂起状态。这使得 pci_pm_suspend()、pci_pm_freeze() 和 pci_pm_poweroff() 避免除非有特定的 PCI 原因才从运行时挂起状态唤醒设备。此外，如果设备在正在进行的系统范围转换的“后期”阶段保持在运行时挂起状态，pci_pm_suspend_late/noirq() 和 pci_pm_poweroff_late/noirq() 将提前返回。此外，如果设备在 pci_pm_resume_noirq() 或 pci_pm_restore_noirq() 中处于运行时挂起状态，其运行时功耗状态将更改为“活动”（因为它即将进入 D0 状态）。

设置 DPM_FLAG_MAY_SKIP_RESUME 标志意味着驱动程序允许在系统范围转换到工作状态后设备可以保持挂起的情况下跳过其“noirq”和“早期”恢复回调。此标志由功耗核心考虑，同时考虑设备的 power.may_skip_resume 状态位，该状态位在某些情况下由 pci_pm_suspend_noirq() 设置。如果功耗核心确定应该跳过驱动程序的“noirq”和“早期”恢复回调，dev_pm_skip_resume() 辅助函数将返回“真”，这将导致 pci_pm_resume_noirq() 和 pci_pm_resume_early() 提前返回而不触及设备或执行驱动程序回调。

3.2. 设备运行时功耗管理
------------------------------------

除了提供设备功耗管理回调之外，PCI 设备驱动程序还负责控制其设备的运行时功耗管理（运行时 PM）。
PCI 设备运行时电源管理（PM）是可选的，但强烈建议 PCI 设备驱动程序至少在能够可靠地验证设备未被使用的情况下实现它（例如，当网络电缆从以太网适配器上拔下或没有设备连接到 USB 控制器时）。为了支持 PCI 运行时 PM，驱动程序首先需要实现 `runtime_suspend()` 和 `runtime_resume()` 回调。它可能还需要实现 `runtime_idle()` 回调来防止设备在 `runtime_resume()` 回调返回后立即再次被暂停（或者，`runtime_suspend()` 回调需要检查设备是否真的应该被暂停，并在不满足条件时返回 `-EAGAIN`）。

PCI 核心默认启用 PCI 设备的运行时 PM。PCI 设备驱动程序无需启用它，也不应尝试这样做。然而，它被 `pci_pm_init()` 阻止，该函数运行 `pm_runtime_forbid()` 辅助函数。此外，每个 PCI 设备的运行时 PM 使用计数器在执行由设备驱动程序提供的探测回调之前由 `local_pci_probe()` 增量。

如果一个 PCI 驱动程序实现了运行时 PM 回调并打算使用 PM 核心和 PCI 子系统提供的运行时 PM 框架，它需要在其探测回调函数中减小设备的运行时 PM 使用计数器。如果不这样做，对于该设备计数器将始终非零，且它永远不会被运行时暂停。最简单的方法是通过调用 `pm_runtime_put_noidle()`，但如果驱动程序想要立即安排自动暂停，例如，它可以调用 `pm_runtime_put_autosuspend()` 为此目的。通常，它只需从其探测例程中调用一个递减设备使用计数器的函数，使运行时 PM 对于设备生效。

重要的是要记住，驱动程序的 `runtime_suspend()` 回调可能在使用计数器减小后立即执行，因为用户空间可能已经通过 sysfs 引起 `pm_runtime_allow()` 辅助函数解除设备运行时 PM 的阻止，因此驱动程序必须准备好应对这种情况。

但是，驱动程序本身不应调用 `pm_runtime_allow()`。相反，它应让用户空间或某些平台特定代码执行此操作（如上所述，用户空间可以通过 sysfs 来做），但它必须准备在 `pm_runtime_allow()` 被调用后正确处理设备的运行时 PM（这可能发生在任何时候，甚至在加载驱动程序之前）。

当驱动程序的移除回调运行时，它必须平衡在探测时对设备运行时 PM 使用计数器的减小。出于这个原因，如果它在探测回调中减小了计数器，那么它必须在其移除回调中运行 `pm_runtime_get_noresume()`。[由于核心在运行驱动程序的移除回调前执行设备的运行时恢复并增加设备的使用计数器，因此在移除执行期间设备的运行时 PM 实际上被禁用，所有递增设备使用计数器的运行时 PM 辅助函数实际上等同于 `pm_runtime_get_noresume()`。]

运行时 PM 框架通过处理请求来工作，这些请求可以是挂起或恢复设备，或检查它们是否空闲（在这种情况下，随后请求它们被挂起是合理的）。这些请求表示为放入电源管理队列 `pm_wq` 中的工作项。虽然存在几种情况，其中电源管理请求由 PM 核心自动排队（例如，在处理设备恢复请求后，PM 核心自动排队请求检查设备是否空闲），但设备驱动程序通常负责为其设备排队电源管理请求。为此，他们应使用 PM 核心提供的运行时 PM 辅助函数，详细信息请参阅 `Documentation/power/runtime_pm.rst`。

设备也可以同步地挂起和恢复，无需将请求放入 `pm_wq`。在大多数情况下，这也是由它们的驱动程序完成的，它们使用 PM 核心为此目的提供的辅助函数。有关设备运行时 PM 的更多信息，请参阅 `Documentation/power/runtime_pm.rst`。
资源
============

PCI局部总线规范，修订版3.0

PCI总线电源管理接口规范，修订版1.2

高级配置和电源接口（ACPI）规范，修订版3.0b

PCI Express基础规范，修订版2.0

文档/驱动程序API/pm/设备.rst

文档/电源/运行时电源管理.rst

以上信息翻译成了中文，涉及到的是一些计算机硬件和电源管理的规范与文档。这些规范和文档包括了PCI局部总线、PCI总线电源管理、ACPI以及PCI Express的基础规定，同时还有关于驱动程序API中电源管理和设备管理的相关说明。
