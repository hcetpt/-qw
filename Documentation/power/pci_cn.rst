====================
PCI电源管理
====================

版权所有 © 2010 Rafael J. Wysocki <rjw@sisk.pl>，Novell Inc
概述了与PCI电源管理相关的概念和Linux内核接口。基于Patrick Mochel <mochel@transmeta.com>（及其他人的）之前的工作。
本文档仅涵盖与PCI设备相关的电源管理方面。对于内核中与设备电源管理相关的通用接口的描述，请参阅Documentation/driver-api/pm/devices.rst 和 Documentation/power/runtime_pm.rst。
.. 目录：

   1. PCI电源管理的硬件和平台支持
   2. PCI子系统和设备电源管理
   3. PCI设备驱动程序和电源管理
   4. 资源

1. PCI电源管理的硬件和平台支持
=========================================================

1.1. 原生和基于平台的电源管理
-----------------------------------------------

一般来说，电源管理是一种通过将设备置于低功耗状态来节省能源的功能，代价是功能或性能的降低。
通常情况下，当设备利用率低或完全不活动时，会将其置于低功耗状态。然而，当需要再次使用该设备时，必须将其恢复到“完全功能”状态（全功率状态）。这可能是因为有数据需要处理，或者由于外部事件要求设备处于活动状态，这种事件可能是由设备本身发出信号的。
PCI设备可以通过两种方式进入低功耗状态：一种是使用PCI总线电源管理接口规范引入的设备功能；另一种是在平台固件（如ACPI BIOS）的帮助下实现。第一种方法称为原生PCI电源管理（以下简称原生PCI PM），通过向其标准配置寄存器写入特定值来改变设备的电源状态。第二种方法需要平台固件提供特殊的内核可以用来改变设备电源状态的方法。
支持原生PCI PM的设备通常能够生成唤醒信号，称为电源管理事件（PMEs），以通知内核外部事件要求设备处于活动状态。接收到PME后，内核应将发送该PME的设备置于全功率状态。但是，PCI总线电源管理接口规范并未定义从设备到CPU和操作系统内核的标准PME传输方法。
假设平台固件将执行此任务，因此即使设置了PCI设备以生成PME，也可能需要准备平台固件以通知CPU来自设备的PME（例如，通过生成中断）。
另一方面，如果使用平台固件提供的方法来改变设备的电源状态，则通常平台也提供了准备设备以生成唤醒信号的方法。然而，在这种情况下，通常还需要使用原生PCI PM机制来准备设备生成PME，因为平台提供的方法依赖于此。
因此，在许多情况下，为了获得预期的结果，必须同时使用原生和基于平台的电源管理机制。
### 1.2. 本地PCI电源管理

PCI总线电源管理接口规范（PCI PM 规范）介于PCI 2.1和PCI 2.2规范之间引入。它定义了一个用于执行与电源管理相关的各种操作的标准接口。
对于传统的PCI设备，实现PCI PM 规范是可选的，但对于PCI Express设备则是强制性的。如果一个设备支持PCI PM 规范，那么在它的PCI配置空间中会有一个8字节的电源管理功能字段。这个字段用于描述和控制与本地PCI电源管理相关的标准特性。
PCI PM 规范为设备（D0-D3）和总线（B0-B3）定义了四个工作状态。数字越大，该设备或总线在此状态下消耗的功率越低。然而，数字越大，设备或总线返回到全功率状态（D0 或 B0）的延迟就越长。
规范定义了两种D3状态的变体。第一种是D3hot，也称为软件可访问的D3，因为设备可以被编程进入这种状态。第二种是D3cold，这是当设备的供电电压（Vcc）被移除时PCI设备所处的状态。虽然不可能编程使PCI设备进入D3cold状态，但可能有一种可编程接口可以让设备所在的总线进入一种所有设备的Vcc都被移除的状态。
然而，在撰写本文时，Linux内核不支持PCI总线电源管理，因此不在本文档的覆盖范围内。
需要注意的是，每个PCI设备都可以处于全功率状态（D0）或D3cold状态，无论是否实现了PCI PM 规范。此外，如果设备实现了PCI PM 规范，则必须支持D3hot以及D0。对D1和D2电源状态的支持是可选的。
支持PCI PM 规范的PCI设备可以被编程进入任何支持的低功耗状态（除了D3cold）。在D1-D3hot状态下，设备的标准配置寄存器必须对软件可访问（即设备必须响应PCI配置访问），尽管其I/O和内存空间会被禁用。这使得设备可以通过编程进入D0。因此，内核可以在D0和支持的低功耗状态（除了D3cold）之间切换设备，并且设备可能经历的电源状态转换如下：

| 当前状态 | 新状态   |
|----------|---------|
| D0       | D1, D2, D3 |
| D1       | D2, D3   |
| D2       | D3       |
| D1, D2, D3 | D0 |

从D3cold到D0的转换发生在向设备提供供电电压时（即恢复供电）。在这种情况下，设备通过完整的上电复位序列返回到D0，并且硬件将初始上电默认值恢复到设备。
支持PCI PM 规范的PCI设备可以在任何电源状态（D0-D3）下被编程生成PME（电源管理事件），但不要求它们能够在所有支持的电源状态下生成PME。特别是，从D3cold生成PME的能力是可选的，并取决于是否存在额外的电压（3.3Vaux），使得设备能够保持足够的活动状态以生成唤醒信号。

### 1.3. ACPI 设备电源管理

平台固件对PCI设备的电源管理支持是系统特定的。但是，如果系统符合高级配置和电源接口（ACPI）规范，就像大多数基于x86的系统一样，它应该实现由ACPI标准定义的设备电源管理接口。
为此，ACPI BIOS提供了特殊功能，称为“控制方法”，这些方法可以由内核执行以完成特定任务，例如将设备置于低功耗状态。这些控制方法使用一种特殊的字节码语言——ACPI机器语言（AML）进行编码，并存储在机器的BIOS中。内核从BIOS加载它们，并根据需要使用AML解释器将AML字节码转换为计算和内存或I/O空间访问。这样，理论上，BIOS编写者可以以系统特定的方式为内核提供执行依赖于系统设计的操作的方法。
ACPI 控制方法可以分为全局控制方法和设备控制方法。全局控制方法与特定设备无关，而设备控制方法则需要为每个要通过平台处理的设备单独定义。这意味着，ACPI 设备控制方法只能用于处理 BIOS 编写者预先知道的设备。用于设备电源管理的 ACPI 方法属于此类。

ACPI 规范假设设备可以处于四种电源状态之一，即 D0、D1、D2 和 D3，这些状态大致对应于本机 PCI PM 的 D0-D3 状态（尽管 D3hot 和 D3cold 之间的区别并未被 ACPI 考虑）。此外，对于设备的每种电源状态，都有一组必须启用的电源资源，以便将设备置于该状态。这些电源资源通过它们各自的控制方法（_ON 和 _OFF）来控制，并且必须分别为每个资源单独定义。

为了将设备置于 ACPI 电源状态 Dx（其中 x 是介于 0 到 3 之间的数字），内核应该（1）使用 _ON 控制方法启用设备在该状态下所需的电源资源，并（2）执行为该设备定义的 _PSx 控制方法。另外，如果设备将进入低功耗状态（D1-D3）并且从该状态生成唤醒信号，则必须在其 _PSx 之前执行为其定义的 _DSW（或 _PSW，已被 ACPI 3.0 替换为 _DSW）控制方法。不为设备目标电源状态所必需且不再为任何其他设备所需的电源资源应被禁用（通过执行其 _OFF 控制方法）。如果设备当前的电源状态是 D3，则只能通过这种方式将其置于 D0。

然而，在系统进入睡眠状态或返回工作状态时，设备的电源状态通常会改变。ACPI 定义了四个系统睡眠状态：S1、S2、S3 和 S4，并将系统工作状态标记为 S0。一般来说，目标系统睡眠（或工作）状态决定了设备可以进入的最高电源状态（最低数字），内核应该通过执行设备的 _SxD 控制方法（其中 x 是介于 0 到 4 之间的数字）来获取此信息。

如果设备需要从目标睡眠状态唤醒系统，则它所能进入的最低电源状态（最高数字）也由系统的状态决定。此时，内核应该使用设备的 _SxW 控制方法来获取该状态的编号。内核还应该使用设备的 _PRW 控制方法来了解需要启用哪些电源资源，以便设备能够生成唤醒信号。

### 1.4 唤醒信号

PCI 设备生成的唤醒信号，无论是作为本机 PCI PME 还是在执行 _DSW（或 _PSW）ACPI 控制方法后进入低功耗状态的结果，都需要被捕获并适当处理。如果它们在系统处于工作状态（ACPI S0）时发送，应该转换为中断，以便内核可以将生成它们的设备置于全功率状态，并处理触发它们的事件。相反，如果它们在系统睡眠时发送，则应触发系统的逻辑核心进行唤醒。

在基于 ACPI 的系统中，传统 PCI 设备发送的唤醒信号会被转换为 ACPI 通用事件（GPE），这是系统逻辑核心针对需要处理的各种事件生成的硬件信号。每个 GPE 都关联一个或多个潜在有趣事件的来源。特别是，一个 GPE 可能关联一个能够生成唤醒信号的 PCI 设备。GPE 与事件源之间的连接信息记录在系统的 ACPI BIOS 中，内核可以从那里读取。

如果系统已知的 PCI 设备发出唤醒信号，与其关联的 GPE（如果有）将被触发。与 PCI 桥关联的 GPE 也可能因桥下方某个设备的唤醒信号而被触发（根桥也是如此），例如，系统未知的 PCI 设备的本机 PCI PME 可以通过这种方式处理。

当系统处于睡眠状态（即处于 ACPI S1-S4 状态之一）时，GPE 可能被触发，这时系统的核心逻辑启动唤醒（导致系统唤醒的信号源设备可能稍后才能识别）。在这种情况下使用的 GPE 称为唤醒 GPE。

通常，GPE 也会在系统处于工作状态（ACPI S0）时被触发，此时系统的逻辑核心会生成一个系统控制中断（SCI）来通知内核事件的发生。然后，SCI 处理程序识别出引发中断的 GPE，从而让内核能够识别事件的来源（可能是发出唤醒信号的 PCI 设备）。用于通知内核系统处于工作状态时发生的事件的 GPE 称为运行时 GPE。
不幸的是，在非ACPI系统上处理传统PCI设备发送的唤醒信号没有标准方法，但对于PCI Express设备则有。具体来说，PCI Express基础规范引入了一种将原生PCI PME（Power Management Event）转换为由根端口生成的中断的机制。对于传统的PCI设备，原生PME是带外信号，因此它们可以单独路由，并且不需要通过桥接器（原则上可以直接路由到系统的主逻辑），但对于PCI Express设备而言，它们是需要通过PCI Express层次结构的带内消息，包括从设备到Root Complex路径上的根端口。因此，可以引入一种机制，使根端口在收到其下方某个设备发送的PME消息时生成一个中断。然后，发送PME消息的PCI Express设备的请求者ID会被记录在根端口的一个配置寄存器中，中断处理程序可以从这里读取该值以识别设备。[集成到Root Complex中的PCI Express端点发送的PME消息不会通过根端口，而是会触发Root Complex事件收集器（如果存在的话）生成中断。]

原则上，原生的PCI Express PME信号也可以与GPE一起在基于ACPI的系统上使用，但要使用它，内核必须请求系统的ACPI BIOS释放对根端口配置寄存器的控制。然而，ACPI BIOS并不一定允许内核控制这些寄存器，如果不允许，则内核不得修改它们的内容。当然，在这种情况下内核不能使用原生的PCI Express PME信号。

2. PCI子系统和设备电源管理
==============================

2.1. 设备电源管理回调
-----------------------

PCI子系统以多种方式参与PCI设备的电源管理。首先，它提供了一个位于设备电源管理核心（PM core）和PCI设备驱动之间的中间代码层。具体来说，PCI子系统的`struct bus_type`对象`pci_bus_type`中的`pm`字段指向一个包含多个设备电源管理回调指针的`struct dev_pm_ops`对象`pci_dev_pm_ops`，如下所示：

```c
const struct dev_pm_ops pci_dev_pm_ops = {
	.prepare = pci_pm_prepare,
	.complete = pci_pm_complete,
	.suspend = pci_pm_suspend,
	.resume = pci_pm_resume,
	.freeze = pci_pm_freeze,
	.thaw = pci_pm_thaw,
	.poweroff = pci_pm_poweroff,
	.restore = pci_pm_restore,
	.suspend_noirq = pci_pm_suspend_noirq,
	.resume_noirq = pci_pm_resume_noirq,
	.freeze_noirq = pci_pm_freeze_noirq,
	.thaw_noirq = pci_pm_thaw_noirq,
	.poweroff_noirq = pci_pm_poweroff_noirq,
	.restore_noirq = pci_pm_restore_noirq,
	.runtime_suspend = pci_pm_runtime_suspend,
	.runtime_resume = pci_pm_runtime_resume,
	.runtime_idle = pci_pm_runtime_idle,
};
```

这些回调在与设备电源管理相关的各种情况下由PM core执行，并进一步执行由PCI设备驱动提供的电源管理回调。此外，它们还执行涉及某些PCI设备标准配置寄存器的电源管理操作，这些操作无需设备驱动关心或了解。
表示PCI设备的结构体`struct pci_dev`包含一些这些回调操作的字段：

```c
struct pci_dev {
	...
	pci_power_t     current_state;  /* 当前运行状态 */
	int		pm_cap;		/* 配置空间中电源管理能力结构的偏移量 */
	unsigned int	pme_support:5;	/* 可以生成PME的状态位掩码 */
	unsigned int	pme_poll:1;	/* 轮询设备的PME状态位 */
	unsigned int	d1_support:1;	/* 支持低功耗状态D1 */
	unsigned int	d2_support:1;	/* 支持低功耗状态D2 */
	unsigned int	no_d1d2:1;	/* 禁止D1和D2 */
	unsigned int	wakeup_prepared:1;  /* 设备已准备好唤醒 */
	unsigned int	d3hot_delay;	/* D3hot到D0过渡时间（毫秒） */
	...
};
```

这些回调还会间接使用嵌入在`struct pci_dev`中的`struct device`的某些字段。

2.2. 设备初始化
--------------------------

PCI子系统与设备电源管理相关的首要任务是准备设备进行电源管理并初始化用于此目的的`struct pci_dev`字段。这发生在`drivers/pci/`目录下的两个函数中：`pci_pm_init()` 和 `pci_acpi_setup()`。
第一个函数检查设备是否支持原生PCI PM，如果是，则将其电源管理能力结构在配置空间中的偏移量存储在设备的`struct pci_dev`对象的`pm_cap`字段中。接下来，该函数检查设备支持哪些PCI低功耗状态以及从哪些低功耗状态可以生成原生PCI PME。相应地更新设备的`struct pci_dev`及其嵌入的`struct device`中的电源管理字段，并禁用设备生成PME的功能。
第二个函数检查设备是否可以通过平台固件（如ACPI BIOS）的帮助准备唤醒信号。如果是这种情况，则该函数更新设备的`struct pci_dev`中嵌入的`struct device`的唤醒字段，并使用固件提供的方法阻止设备发出唤醒信号。
此时，设备已准备好进行电源管理。然而，对于无驱动程序的设备，此功能仅限于在系统级睡眠状态和工作状态转换期间执行的一些基本操作。

### 2.3 运行时设备电源管理

PCI 子系统在 PCI 设备的运行时电源管理中扮演着重要角色。为此，它使用了 `Documentation/power/runtime_pm.rst` 中描述的一般运行时电源管理（runtime PM）框架。具体来说，它提供了子系统级别的回调函数：

- `pci_pm_runtime_suspend()`
- `pci_pm_runtime_resume()`
- `pci_pm_runtime_idle()`

这些回调由核心运行时 PM 例程执行。此外，它还实现了处理处于低功耗状态下的 PCI 设备唤醒信号所需的全部机制，目前这适用于本机 PCI Express PME 信号以及第 1 节中描述的基于 ACPI GPE 的唤醒信号。

首先，通过调用 `pm_schedule_suspend()` 或 `pm_runtime_suspend()` 将 PCI 设备置于低功耗状态或挂起，这两个函数对于 PCI 设备会调用 `pci_pm_runtime_suspend()` 来完成实际工作。为了使这一过程生效，设备的驱动程序需要提供一个 `pm->runtime_suspend()` 回调（见下文），该回调由 `pci_pm_runtime_suspend()` 作为第一个动作执行。如果驱动程序的回调返回成功，则保存设备的标准配置寄存器，并将设备准备为生成唤醒信号，最后将其置于目标低功耗状态。

要将设备置于的低功耗状态是最节能的状态（即编号最高的状态），从该状态可以发出唤醒信号。具体的唤醒信号方法取决于系统，并由 PCI 子系统根据设备报告的能力和平台固件确定。为了准备设备以发出唤醒信号并将其置于选定的低功耗状态，PCI 子系统可以使用平台固件以及设备的本机 PCI PM 功能（如果支持的话）。

预期设备驱动程序的 `pm->runtime_suspend()` 回调不会尝试准备设备以发出唤醒信号或将设备置于低功耗状态。驱动程序应将这些任务留给拥有所有必要信息的 PCI 子系统。

挂起的设备通过 `pm_request_resume()` 或 `pm_runtime_resume()` 帮助恢复到“活动”状态，这两个函数都会为 PCI 设备调用 `pci_pm_runtime_resume()`。同样，这只有在设备的驱动程序提供了 `pm->runtime_resume()` 回调（见下文）的情况下才有效。但是，在执行驱动程序的回调之前，`pci_pm_runtime_resume()` 会将设备恢复到全功率状态，防止其在该状态下发出唤醒信号，并恢复其标准配置寄存器。因此，驱动程序的回调无需担心与 PCI 相关的设备恢复细节。

注意，通常 `pci_pm_runtime_resume()` 可能在两种不同情况下被调用。首先，可能是应设备驱动程序的请求，例如有数据需要处理。其次，可能是由于设备本身发出的唤醒信号（有时称为“远程唤醒”）。当然，为此目的，唤醒信号是按照第 1 节中描述的一种方式处理的，并最终转换为对 PCI 子系统的通知，在识别出源设备后。

`pci_pm_runtime_idle()` 函数由 `pm_runtime_idle()` 和 `pm_request_idle()` 为 PCI 设备调用，执行设备驱动程序的 `pm->runtime_idle()` 回调（如果定义的话），如果该回调没有返回错误代码（或者根本不存在），则借助 `pm_runtime_suspend()` 挂起设备。

有时 `pci_pm_runtime_idle()` 会自动由 PM 核心调用（例如，在设备刚刚恢复之后立即调用），在这种情况下，如果合理则预期会挂起设备。然而，通常 PCI 子系统并不真正知道设备是否可以挂起，因此它让设备的驱动程序通过运行其 `pm->runtime_idle()` 回调来决定。
2.4. 全局电源转换
-------------------------------

有几种不同类型的全局电源转换，这些类型在 `Documentation/driver-api/pm/devices.rst` 中进行了描述。每种转换都需要以特定方式处理设备，并且 PM 核心为此执行子系统级别的电源管理回调。这些回调按阶段执行，每个阶段涉及在开始下一阶段之前为属于给定子系统的每个设备执行相同的子系统级别回调。这些阶段总是在任务冻结后运行。

2.4.1. 系统挂起
^^^^^^^^^^^^^^^^^^^^^^

当系统进入一个将保留内存内容的睡眠状态（例如 ACPI 的 S1 至 S3 睡眠状态）时，各阶段如下：

- 准备（prepare）
- 挂起（suspend）
- 挂起无中断（suspend_noirq）

在这些阶段中，分别使用以下 PCI 总线类型的回调：

- `pci_pm_prepare()`
- `pci_pm_suspend()`
- `pci_pm_suspend_noirq()`

`pci_pm_prepare()` 首先通过 `pm_runtime_resume()` 将设备置于“完全功能”状态。然后，如果定义了设备驱动程序的 `pm->prepare()` 回调（即，如果驱动程序的 `struct dev_pm_ops` 对象存在并且该对象中的 `prepare` 指针有效），则执行该回调。
`pci_pm_suspend()` 首先检查设备的驱动程序是否实现了传统的 PCI 挂起例程（参见第 3 节）。如果实现，则执行驱动程序的传统挂起回调并返回其结果。接下来，如果设备的驱动程序没有提供 `struct dev_pm_ops` 对象（包含指向驱动程序回调的指针），则调用 `pci_pm_default_suspend()`，该函数会关闭设备的总线主控能力，并运行 `pcibios_disable_device()` 来禁用设备（除非设备是桥接器，PCI 桥接器在此过程中被忽略）。然后，如果定义了设备驱动程序的 `pm->suspend()` 回调，则执行该回调并返回其结果（如果失败的话）。
最后，调用 `pci_fixup_device()` 在必要时应用与设备相关的硬件挂起修复。
需要注意的是，对于 PCI 设备，挂起阶段是异步进行的，因此 `pci_pm_suspend()` 回调可能会并行地针对任何不依赖于彼此的 PCI 设备对执行（即，在根桥接到叶设备的设备树路径中没有同时包含这两个设备）。
`pci_pm_suspend_noirq()` 回调是在调用 `suspend_device_irqs()` 后执行的，这意味着在执行此例程期间不会调用设备驱动程序的中断处理器。它首先检查设备的驱动程序是否实现了传统的 PCI 挂起例程（参见第 3 节），如果是，则调用传统晚挂起例程并返回其结果（如果驱动程序的回调没有保存设备的标准配置寄存器，则会保存它们）。其次，如果设备驱动程序的 `struct dev_pm_ops` 对象不存在，则保存设备的标准配置寄存器并返回成功。否则，如果存在设备驱动程序的 `pm->suspend_noirq()` 回调，则执行该回调并返回其结果（如果失败的话）。接下来，如果设备的标准配置寄存器尚未保存（之前的某个驱动程序回调可能已经完成了这一操作），`pci_pm_suspend_noirq()` 会保存它们，准备设备发出唤醒信号（如果需要的话），并将设备置于低功耗状态。
要将设备置于的低功耗状态是从其中可以在目标睡眠状态下发出唤醒信号的最低功耗（最高编号）状态。与上述运行时 PM 情况一样，发出唤醒信号的机制取决于系统，并由 PCI 子系统确定，该子系统还负责根据系统的目标睡眠状态准备设备发出唤醒信号。
通常，不期望 PCI 设备驱动程序（不实现传统电源管理回调的驱动程序）准备设备发出唤醒信号或将它们置于低功耗状态。然而，如果驱动程序的一个挂起回调（`pm->suspend()` 或 `pm->suspend_noirq()`）保存了设备的标准配置寄存器，则 `pci_pm_suspend_noirq()` 会假定设备已经被驱动程序准备好了发出唤醒信号并置于低功耗状态（假定驱动程序使用了 PCI 子系统提供的辅助函数来完成这一任务）。虽然不鼓励 PCI 设备驱动程序这样做，但在某些罕见的情况下，在驱动程序中这样做可能是最优的选择。

2.4.2. 系统恢复
^^^^^^^^^^^^^^^^^^^^^^

当系统从一个保留了内存内容的睡眠状态（例如 ACPI 的 S1 至 S3 睡眠状态）过渡到工作状态（ACPI S0）时，各阶段如下：

- 恢复无中断（resume_noirq）
- 恢复（resume）
- 完成（complete）
以下PCI总线类型的回调函数分别在这些阶段执行：

- `pci_pm_resume_noirq()`
- `pci_pm_resume()`
- `pci_pm_complete()`

`pci_pm_resume_noirq()` 函数首先将设备置于全功率状态，恢复其标准配置寄存器，并根据需要应用与设备相关的早期恢复硬件特性。这一步骤是无条件执行的，无论设备驱动程序是否实现了传统的PCI电源管理回调（这样所有PCI设备在恢复过程中第一次调用中断处理程序时都处于全功率状态，并且其标准配置寄存器已被恢复，从而避免内核处理共享中断时出现的问题）。如果设备驱动程序实现了传统PCI电源管理回调（参见第3节），则会执行该驱动程序的遗留早期恢复回调并返回其结果。否则，如果定义了设备驱动程序的 `pm->resume_noirq()` 回调，则执行该回调并返回其结果。

`pci_pm_resume()` 函数首先检查设备的标准配置寄存器是否已恢复，并在未恢复的情况下恢复它们（这仅在挂起失败的错误路径中是必要的）。接下来，如果有必要，应用与设备相关的恢复硬件特性。如果设备驱动程序实现了传统PCI电源管理回调（参见第3节），则执行驱动程序的传统恢复回调并返回其结果。否则，阻止设备唤醒信号机制，并执行设备驱动程序的 `pm->resume()` 回调（如果定义的话），然后返回回调的结果。

对于PCI设备，恢复阶段是异步进行的，就像上面描述的挂起阶段一样，这意味着如果两个PCI设备没有明确的依赖关系，则 `pci_pm_resume()` 可能会同时为这两个设备执行。

`pci_pm_complete()` 函数仅在定义了设备驱动程序的 `pm->complete()` 回调时执行该回调。

### 2.4.3 系统休眠
^^^^^^^^^^^^^^^^^^^^^^^^^

系统休眠比系统挂起更复杂，因为它需要创建一个系统映像并将其写入持久存储介质中。映像是原子创建的，并且在创建之前所有设备都被静止或冻结。

设备的静止操作是在释放足够内存后进行的（截至本文撰写时，映像创建至少需要系统RAM的50%是空闲的），分为以下三个阶段：

- prepare（准备）
- freeze（冻结）
- freeze_noirq（无中断冻结）

这些阶段对应于PCI总线类型的回调函数：

- `pci_pm_prepare()`
- `pci_pm_freeze()`
- `pci_pm_freeze_noirq()`

这意味着准备阶段与系统挂起完全相同。然而，其他两个阶段有所不同。

`pci_pm_freeze()` 函数与 `pci_pm_suspend()` 非常相似，但它运行的是设备驱动程序的 `pm->freeze()` 回调（如果定义的话），而不是 `pm->suspend()`，并且不应用与挂起相关的硬件特性。它异步地为不同的、没有明确依赖关系的PCI设备执行。

`pci_pm_freeze_noirq()` 函数类似于 `pci_pm_suspend_noirq()`，但调用的是设备驱动程序的 `pm->freeze_noirq()` 函数而不是 `pm->suspend_noirq()`。它也不尝试为唤醒信号做准备并将设备置于低功耗状态。但是，如果设备的标准配置寄存器尚未被保存，则仍然会保存它们。

一旦映像创建完成，就需要将其保存。然而，在这一点上所有设备都被冻结，无法处理I/O，而保存映像显然需要它们能够处理I/O。因此，必须将它们恢复到完全功能状态，这是通过以下阶段实现的：

- thaw_noirq（无中断解冻）
- thaw（解冻）
- complete（完成）

使用以下PCI总线类型的回调函数：

- `pci_pm_thaw_noirq()`
- `pci_pm_thaw()`
- `pci_pm_complete()`
第一个函数 `pci_pm_thaw_noirq()` 与 `pci_pm_resume_noirq()` 类似。它将设备置于全功率状态并恢复其标准配置寄存器。如果定义了设备驱动程序的 `pm->thaw_noirq()` 回调，则会执行该回调，而不是 `pm->resume_noirq()`。

`pci_pm_thaw()` 函数与 `pci_pm_resume()` 类似，但它运行设备驱动程序的 `pm->thaw()` 回调，而不是 `pm->resume()`。对于不同且相互之间没有已知依赖关系的 PCI 设备，它是异步执行的。

整个阶段与系统恢复相同。保存镜像后，需要先关闭设备电源，然后系统才能进入目标睡眠状态（对于基于 ACPI 的系统为 ACPI S4）。这个过程分为三个阶段：

- 准备（prepare）
- 关闭电源（poweroff）
- 不中断地关闭电源（poweroff_noirq）

其中准备阶段与系统挂起时的准备阶段完全相同。其他两个阶段分别类似于挂起（suspend）和不中断地挂起（suspend_noirq）阶段。对应的 PCI 子系统级回调如下：

- `pci_pm_poweroff()`
- `pci_pm_poweroff_noirq()`

这些回调分别与 `pci_pm_suspend()` 和 `pci_pm_suspend_noirq()` 类似，尽管它们不会尝试保存设备的标准配置寄存器。

### 2.4.4 系统恢复

系统恢复需要将休眠镜像加载到内存中，并在恢复休眠前的系统活动之前恢复休眠前的内存内容。如《Documentation/driver-api/pm/devices.rst》所述，休眠镜像是由一个新实例的内核加载到内存中的，称为引导内核，该内核是由引导加载程序以常规方式加载并运行的。在引导内核加载完镜像后，需要用自己的代码和数据替换镜像中存储的“休眠”内核（称为镜像内核）的代码和数据。为此，所有设备都必须像创建镜像时那样冻结，经过以下阶段：

- 准备（prepare）
- 冻结（freeze）
- 不中断地冻结（freeze_noirq）

但是受影响的设备仅限于引导内核中有驱动程序的设备；其他设备仍然处于引导加载程序留下的状态。如果恢复休眠前的内存内容失败，引导内核将通过上述的“解冻”过程，使用 `thaw_noirq`、`thaw` 和 `complete` 阶段（仅影响引导内核中有驱动程序的设备），然后继续正常运行。

如果成功恢复了休眠前的内存内容，这是通常的情况，控制权将传递给镜像内核，后者负责将系统恢复到工作状态。为了实现这一点，它必须恢复设备的休眠前功能，这与从内存睡眠状态唤醒类似，但涉及不同的阶段：

- 不中断地恢复（restore_noirq）
- 恢复（restore）
- 完成（complete）

前两个阶段分别类似于上述的 `resume_noirq` 和 `resume` 阶段，对应以下 PCI 子系统的回调：

- `pci_pm_restore_noirq()`
- `pci_pm_restore()`

这些回调分别与 `pci_pm_resume_noirq()` 和 `pci_pm_resume()` 类似，但它们执行设备驱动程序的 `pm->restore_noirq()` 和 `pm->restore()` 回调（如果可用的话）。
完整的阶段与系统恢复时的执行方式完全相同。

3. PCI 设备驱动程序和电源管理
==========================================

3.1. 电源管理回调函数
-------------------------------

PCI 设备驱动程序通过提供回调函数参与电源管理，这些回调函数由上述 PCI 子系统的电源管理例程执行，并控制设备的运行时电源管理。
在撰写本文时，有两种方法来定义 PCI 设备驱动程序的电源管理回调函数。推荐的方法是使用 `dev_pm_ops` 结构体（详见 `Documentation/driver-api/pm/devices.rst`），另一种是“传统”方法，即使用 `struct pci_driver` 中的 `.suspend()` 和 `.resume()` 回调函数。然而，“传统”方法不允许定义运行时电源管理回调函数，并且不适合新的驱动程序。因此，本文档不涵盖这种方法（参阅源代码以了解更多信息）。

建议所有 PCI 设备驱动程序定义一个包含电源管理（PM）回调函数指针的 `struct dev_pm_ops` 对象。这些回调函数将在不同情况下由 PCI 子系统的 PM 例程执行。必须将指向驱动程序的 `struct dev_pm_ops` 对象的指针赋值给其 `struct pci_driver` 对象中的 `driver.pm` 字段。一旦完成这一操作，“传统”的 PM 回调函数（即使它们不为 NULL）将被忽略。

`struct dev_pm_ops` 中的 PM 回调函数不是强制性的。如果未定义这些回调函数（即 `struct dev_pm_ops` 的相应字段未设置），PCI 子系统将以简化的方式处理设备。但如果定义了这些回调函数，则期望它们按以下小节中描述的方式工作。

3.1.1. prepare()
^^^^^^^^^^^^^^^^

`prepare()` 回调函数在系统暂停期间、休眠期间（当即将创建休眠映像时）、保存休眠映像后的关机期间以及系统恢复期间（休眠映像刚刚加载到内存中时）执行。

此回调仅在驱动程序的设备有子设备，并且这些子设备可能在任何时候注册的情况下才需要。在这种情况下，`prepare()` 回调的作用是阻止设备的新子设备在此回调之一 (`resume_noirq()`、`thaw_noirq()` 或 `restore_noirq()`) 运行之前注册。

此外，`prepare()` 回调还可以执行一些准备设备暂停的操作，但不应分配内存（如果需要额外的内存来暂停设备，则应提前预分配，例如在 suspend/hibernate 通知器中，详见 `Documentation/driver-api/pm/notifiers.rst`）。

3.1.2. suspend()
^^^^^^^^^^^^^^^^

`suspend()` 回调函数仅在系统暂停期间，在所有设备的 `prepare()` 回调函数执行之后执行。

此回调函数应使设备处于静止状态，并准备好由 PCI 子系统将其置于低功耗状态。不建议 PCI 驱动程序的 `suspend()` 回调函数保存设备的标准配置寄存器、使其准备好唤醒系统或将设备置于低功耗状态。所有这些操作都可以很好地由 PCI 子系统处理，无需驱动程序参与。
然而，在某些罕见的情况下，执行这些操作可能会在 PCI 驱动程序中更加方便。这时，应该使用 `pci_save_state()`、`pci_prepare_to_sleep()` 和 `pci_set_power_state()` 来保存设备的标准配置寄存器，为系统唤醒做准备（如果必要），并将其置于低功耗状态。此外，如果驱动程序调用了 `pci_save_state()`，那么 PCI 子系统将不会为该设备执行 `pci_prepare_to_sleep()` 或 `pci_set_power_state()`，因此驱动程序需要负责适当地处理设备。

在执行 `suspend()` 回调时，驱动程序的中断处理器可能会被调用来处理来自设备的中断，因此所有依赖于驱动程序处理中断能力的挂起相关操作都应在该回调中进行。

3.1.3. `suspend_noirq()`
^^^^^^^^^^^^^^^^^^^^^^

`suspend_noirq()` 回调仅在系统挂起过程中执行，此时所有设备的 `suspend()` 回调已经执行完毕，并且设备中断已经被 PM 核心禁用。

`suspend_noirq()` 与 `suspend()` 的区别在于，在 `suspend_noirq()` 运行期间，驱动程序的中断处理器不会被调用。因此，`suspend_noirq()` 可以执行那些在 `suspend()` 中执行会导致竞争条件的操作。

3.1.4. `freeze()`
^^^^^^^^^^^^^^^

`freeze()` 回调是针对休眠特定的，并在两种情况下执行：在休眠期间，在为创建系统镜像而执行了所有设备的 `prepare()` 回调之后；以及在恢复期间，在从持久存储加载系统镜像到内存后，执行了所有设备的 `prepare()` 回调之后。

此回调的作用类似于上面描述的 `suspend()` 回调。事实上，它们只有在罕见情况下才需要不同，即当驱动程序承担将设备置于低功耗状态的责任时。

在这种情况下，`freeze()` 回调不应为系统唤醒准备设备或将其置于低功耗状态。尽管如此，它或 `freeze_noirq()` 应使用 `pci_save_state()` 保存设备的标准配置寄存器。

3.1.5. `freeze_noirq()`
^^^^^^^^^^^^^^^^^^^^^

`freeze_noirq()` 回调也是针对休眠特定的。它在休眠期间执行，在为创建系统镜像而执行了所有设备的 `prepare()` 和 `freeze()` 回调之后；以及在恢复期间，在从持久存储加载系统镜像到内存后，执行了所有设备的 `prepare()` 和 `freeze()` 回调之后。它总是在设备中断被 PM 核心禁用之后执行。

此回调的作用类似于上面描述的 `suspend_noirq()` 回调，并且很少有必要定义 `freeze_noirq()`。

`freeze_noirq()` 与 `freeze()` 之间的区别类似于 `suspend_noirq()` 与 `suspend()` 之间的区别。
3.1.6. poweroff()
^^^^^^^^^^^^^^^^^

`poweroff()` 回调函数是与休眠相关的。当系统即将在保存了休眠镜像到持久存储后关机时，会执行此回调。在调用 `poweroff()` 之前，会对所有设备执行 `prepare()` 回调。
该回调的作用类似于上面描述的 `suspend()` 和 `freeze()` 回调，尽管它不需要保存设备寄存器的内容。特别是，如果驱动程序希望将设备置于低功耗状态而不是让 PCI 子系统来完成这一操作，则 `poweroff()` 回调应该使用 `pci_prepare_to_sleep()` 和 `pci_set_power_state()` 来为系统唤醒准备设备，并将其置于低功耗状态，但不必保存设备的标准配置寄存器。

3.1.7. poweroff_noirq()
^^^^^^^^^^^^^^^^^^^^^^^

`poweroff_noirq()` 回调函数是与休眠相关的。在对系统中的所有设备执行完 `poweroff()` 回调之后，会执行此回调。
该回调的作用类似于上面描述的 `suspend_noirq()` 和 `freeze_noirq()` 回调，但它不需要保存设备寄存器的内容。
`poweroff_noirq()` 和 `poweroff()` 之间的区别类似于 `suspend_noirq()` 和 `suspend()` 之间的区别。

3.1.8. resume_noirq()
^^^^^^^^^^^^^^^^^^^^^

`resume_noirq()` 回调函数仅在系统恢复期间执行，即在 PM 核心启用非引导 CPU 之后。当 `resume_noirq()` 运行时，驱动程序的中断处理程序不会被调用，因此这个回调可以执行可能与中断处理程序竞争的操作。
由于 PCI 子系统无条件地在系统恢复的 `resume_noirq` 阶段将所有设备置于全功率状态并恢复其标准配置寄存器，`resume_noirq()` 通常不是必需的。一般来说，它只用于执行可能会导致竞争条件的操作，如果由 `resume()` 执行这些操作则可能导致问题。

3.1.9. resume()
^^^^^^^^^^^^^^^

`resume()` 回调函数仅在系统恢复期间执行，即在对系统中的所有设备执行完 `resume_noirq()` 回调并且设备中断由 PM 核心启用之后。
此回调负责恢复设备在暂停前的配置并使其恢复到完全功能状态。在 `resume()` 返回后，设备应能够以常规方式处理 I/O 操作。

3.1.10. thaw_noirq()
^^^^^^^^^^^^^^^^^^^^

`thaw_noirq()` 回调函数是与休眠相关的。在创建系统镜像且 PM 核心启用了非引导 CPU 后，在休眠的 `thaw_noirq` 阶段执行此回调。如果在系统恢复过程中加载休眠镜像失败（在这种情况下，它将在启用非引导 CPU 之后执行），也可能执行此回调。当 `thaw_noirq()` 运行时，驱动程序的中断处理程序不会被调用。
### 3.1.11. thaw()
^^^^^^^^^^^^^^

此回调函数的作用类似于`resume_noirq()`。这两个回调之间的区别在于，`thaw_noirq()`是在执行完`freeze()`和`freeze_noirq()`之后执行的，因此通常不需要修改设备寄存器的内容。

### 3.1.12. thaw()
^^^^^^^^^^^^^^

`thaw()`回调函数是专为休眠设计的。它在系统中所有设备的`thaw_noirq()`回调执行完毕，并且设备中断被电源管理（PM）核心启用之后执行。
此回调负责恢复设备在冻结之前的配置，以便在`thaw()`返回后设备能够正常工作。

### 3.1.13. restore_noirq()
^^^^^^^^^^^^^^^^^^^^^^^

`restore_noirq()`回调函数是专为休眠设计的。它在休眠恢复阶段执行，此时引导内核已将控制权传递给镜像内核，并且非引导CPU已被镜像内核的PM核心启用。
此回调与`resume_noirq()`类似，但不同之处在于它不能对设备的先前状态做出任何假设，即使BIOS（或一般平台固件）已知在挂起-恢复周期中保留该状态。
对于绝大多数PCI设备驱动程序来说，`resume_noirq()`和`restore_noirq()`之间没有区别。

### 3.1.14. restore()
^^^^^^^^^^^^^^^^^

`restore()`回调函数是专为休眠设计的。它在系统中所有设备的`restore_noirq()`回调执行完毕，并且PM核心启用了设备驱动程序的中断处理程序之后执行。
此回调与`resume()`类似，就像`restore_noirq()`与`resume_noirq()`类似。因此，`restore_noirq()`与`restore()`之间的区别类似于`resume_noirq()`与`resume()`之间的区别。
对于绝大多数PCI设备驱动程序来说，`resume()`和`restore()`之间没有区别。

### 3.1.15. complete()
^^^^^^^^^^^^^^^^^^

`complete()`回调函数在以下情况下执行：

  - 在系统恢复期间，在所有设备的`resume()`回调执行完毕之后，
  - 在休眠期间，在保存系统镜像之前，在所有设备的`thaw()`回调执行完毕之后，
  - 在系统恢复过程中，当系统回到休眠前的状态时，在所有设备的`restore()`回调执行完毕之后。
3.1.15. 运行时挂起（runtime_suspend）
^^^^^^^^^^^^^^^^^^^^^^^^^

运行时挂起（runtime_suspend）回调函数是针对设备运行时电源管理（运行时PM）的。当设备即将在运行时被挂起（即进入静止状态并切换到低功耗模式）时，由电源管理（PM）核心的运行时PM框架执行此回调。

此回调负责冻结设备并将其准备好切换到低功耗状态，但它必须允许PCI子系统执行所有必要的PCI特定操作以挂起设备。

3.1.16. 运行时恢复（runtime_resume）
^^^^^^^^^^^^^^^^^^^^^^^^

运行时恢复（runtime_resume）回调函数也是针对设备运行时PM的。当设备即将在运行时恢复（即切换到全功率状态并重新配置为正常处理I/O）时，由PM核心的运行时PM框架执行此回调。

此回调负责在PCI子系统将设备恢复到全功率状态后，恢复设备的正常功能。在运行时恢复（runtime_resume）返回后，设备应能够按常规方式处理I/O。

3.1.17. 运行时空闲（runtime_idle）
^^^^^^^^^^^^^^^^^^^^^^

运行时空闲（runtime_idle）回调函数也是针对设备运行时PM的。当根据PM核心的信息可能需要挂起设备时，由PM核心的运行时PM框架执行此回调。特别是，在运行时恢复（runtime_resume）返回后立即自动执行此回调，如果设备恢复是由于一个虚假事件引起的。

此回调是可选的，但如果未实现或返回0，则PCI子系统会调用pm_runtime_suspend()，进而导致驱动程序的运行时挂起（runtime_suspend）回调被执行。

3.1.18. 指向同一例程的多个回调指针
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

虽然原则上每个前面小节中描述的回调都可以定义为单独的函数，但通常将结构体dev_pm_ops中的两个或多个成员指向同一个例程更为方便。为此目的，有一些方便的宏可以使用。
### SIMPLE_DEV_PM_OPS 宏

`SIMPLE_DEV_PM_OPS` 宏声明了一个 `struct dev_pm_ops` 对象，其中包含一个由 `.suspend()`、`.freeze()` 和 `.poweroff()` 成员指向的挂起例程，以及一个由 `.resume()`、`.thaw()` 和 `.restore()` 成员指向的恢复例程。该 `struct dev_pm_ops` 中的其他函数指针未设置。

### UNIVERSAL_DEV_PM_OPS 宏

`UNIVERSAL_DEV_PM_OPS` 宏与 `SIMPLE_DEV_PM_OPS` 类似，但还额外设置了 `.runtime_resume()` 指针，使其与 `.resume()`（及 `.thaw()` 和 `.restore()`）相同，并将 `.runtime_suspend()` 指针设置为与 `.suspend()`（及 `.freeze()` 和 `.poweroff()`）相同。

### SET_SYSTEM_SLEEP_PM_OPS

`SET_SYSTEM_SLEEP_PM_OPS` 可以在声明 `struct dev_pm_ops` 时使用，以指示一个挂起例程应由 `.suspend()`、`.freeze()` 和 `.poweroff()` 成员指向，而一个恢复例程应由 `.resume()`、`.thaw()` 和 `.restore()` 成员指向。

### 3.1.19. 功耗管理的驱动标志
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

PM 核心允许设备驱动程序设置影响设备功耗管理处理的标志，这些标志由核心和中间层代码（包括 PCI 总线类型）处理。这些标志应在驱动程序探测时通过 `dev_pm_set_driver_flags()` 函数一次性设置，并且之后不应直接更新。

- `DPM_FLAG_NO_DIRECT_COMPLETE` 标志防止 PM 核心使用直接完成机制，从而在系统挂起开始时跳过设备的挂起/恢复回调。如果设备处于运行时挂起状态，则会跳过这些回调。这也会影响设备的所有祖先节点，因此只有在绝对必要的情况下才应使用此标志。
  
- `DPM_FLAG_SMART_PREPARE` 标志使得 PCI 总线类型仅当设备驱动程序提供的 `->prepare` 回调返回正值时才从 `pci_pm_prepare()` 返回正值。这允许驱动程序动态选择不使用直接完成机制（而设置 `DPM_FLAG_NO_DIRECT_COMPLETE` 表示永久性选择不使用）。

- `DPM_FLAG_SMART_SUSPEND` 标志告诉 PCI 总线类型，从驱动程序的角度来看，设备可以在系统挂起期间安全地留在运行时挂起状态。这导致 `pci_pm_suspend()`、`pci_pm_freeze()` 和 `pci_pm_poweroff()` 在没有特定 PCI 原因的情况下避免将设备从运行时挂起中恢复。此外，如果设备在系统范围转换的“晚期”阶段保持在运行时挂起状态，`pci_pm_suspend_late/noirq()` 和 `pci_pm_poweroff_late/noirq()` 会提前返回。此外，如果设备在 `pci_pm_resume_noirq()` 或 `pci_pm_restore_noirq()` 中处于运行时挂起状态，其运行时 PM 状态将更改为“活动”（因为它将进入 D0 状态）。

- 设置 `DPM_FLAG_MAY_SKIP_RESUME` 标志意味着驱动程序允许其 “noirq” 和 “early” 恢复回调在系统范围转换到工作状态后可以跳过，如果设备可以保持在挂起状态。此标志由 PM 核心考虑，同时考虑设备的 `power.may_skip_resume` 状态位，该状态位由 `pci_pm_suspend_noirq()` 在某些情况下设置。如果 PM 核心确定应跳过驱动程序的 “noirq” 和 “early” 恢复回调，则 `dev_pm_skip_resume()` 辅助函数将返回 “true”，这将导致 `pci_pm_resume_noirq()` 和 `pci_pm_resume_early()` 提前返回，而不触碰设备并执行驱动程序回调。

### 3.2. 设备运行时功耗管理

除了提供设备功耗管理回调外，PCI 设备驱动程序还负责控制其设备的运行时功耗管理（运行时 PM）。
PCI 设备的运行时电源管理（PM）是可选的，但建议 PCI 设备驱动程序至少在能够可靠地验证设备未被使用的情况下实现它（例如，当网络电缆从以太网适配器上拔下或没有设备连接到 USB 控制器时）。为了支持 PCI 运行时 PM，驱动程序首先需要实现 `runtime_suspend()` 和 `runtime_resume()` 回调函数。此外，可能还需要实现 `runtime_idle()` 回调函数，以防止设备在 `runtime_resume()` 回调函数返回后立即再次被挂起（或者，`runtime_suspend()` 回调函数需要检查设备是否真的应该被挂起，并在不满足条件时返回 `-EAGAIN`）。

PCI 核心默认启用 PCI 设备的运行时 PM。PCI 设备驱动程序不需要启用它，也不应尝试这样做。但是，它会通过运行 `pci_pm_init()` 中的 `pm_runtime_forbid()` 辅助函数来阻止。除此之外，每个 PCI 设备的运行时 PM 使用计数器会在执行由设备驱动程序提供的探测回调之前由 `local_pci_probe()` 增加。

如果 PCI 驱动程序实现了运行时 PM 回调函数并打算使用由 PM 核心和 PCI 子系统提供的运行时 PM 框架，则需要在其探测回调函数中减少设备的运行时 PM 使用计数器。如果不这样做，计数器将始终不为零，设备永远不会进入运行时挂起状态。最简单的方法是调用 `pm_runtime_put_noidle()`，但如果驱动程序希望立即安排自动挂起，可以调用 `pm_runtime_put_autosuspend()`。通常，只需在探测例程中调用一个减少设备使用计数器的函数即可使运行时 PM 对设备生效。

需要注意的是，驱动程序的 `runtime_suspend()` 回调函数可能在使用计数器减少后立即被执行，因为用户空间可能已经通过 sysfs 调用了 `pm_runtime_allow()` 辅助函数解除了对设备运行时 PM 的阻止，因此驱动程序必须准备好应对这种情况。

然而，驱动程序本身不应调用 `pm_runtime_allow()`。相反，应让用户空间或某些平台特定代码来做这件事（用户空间可以通过 sysfs 来完成），但必须准备好在 `pm_runtime_allow()` 被调用后正确处理设备的运行时 PM（这可能发生在任何时候，甚至在驱动程序加载之前）。

当驱动程序的移除回调运行时，需要平衡在探测时对设备运行时 PM 使用计数器的减少操作。为此，如果在探测回调中减少了计数器，则必须在移除回调中运行 `pm_runtime_get_noresume()`。（由于核心在运行驱动程序的移除回调之前会执行一次运行时恢复并将设备的使用计数器增加，因此在移除执行期间设备的运行时 PM 实际上被禁用，并且所有增加设备使用计数器的运行时 PM 辅助函数实际上等效于 `pm_runtime_get_noresume()`。）

运行时 PM 框架通过处理请求来挂起或恢复设备，或检查它们是否处于空闲状态（在这种情况下，随后请求挂起它们是合理的）。这些请求表示为放入电源管理队列 `pm_wq` 的工作项。尽管在某些情况下 PM 核心会自动排队电源管理请求（例如，在处理设备恢复请求之后，PM 核心会自动排队检查设备是否空闲的请求），但设备驱动程序通常负责为其设备排队电源管理请求。为此，他们应使用 PM 核心提供的运行时 PM 辅助函数，具体参见 `Documentation/power/runtime_pm.rst`。

设备也可以同步地挂起和恢复，而无需将请求放入 `pm_wq`。大多数情况下，这也是由其驱动程序使用 PM 核心提供的辅助函数来完成的。有关设备运行时 PM 的更多信息，请参见 `Documentation/power/runtime_pm.rst`。
4. 资源
------------

PCI 局部总线规范，修订版 3.0

PCI 总线电源管理接口规范，修订版 1.2

高级配置和电源接口（ACPI）规范，修订版 3.0b

PCI Express 基础规范，修订版 2.0

Documentation/driver-api/pm/devices.rst

Documentation/power/runtime_pm.rst
