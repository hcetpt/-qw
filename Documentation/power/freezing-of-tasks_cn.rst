任务冻结
=================

(C) 2007 Rafael J. Wysocki <rjw@sisk.pl>，GPL

I. 什么是任务冻结？
=================================

任务冻结是一种机制，在休眠或系统范围的暂停期间（在某些架构上）控制用户空间进程和部分内核线程。

II. 它是如何工作的？
=====================

有一个每任务标志（PF_NOFREEZE）和三种每任务状态（TASK_FROZEN、TASK_FREEZABLE 和 __TASK_FREEZABLE_UNSAFE）用于此目的。具有未设置 PF_NOFREEZE 标志的任务（所有用户空间任务和部分内核线程）被视为“可冻结”的，并在系统进入睡眠状态之前以及创建休眠映像之前以特殊方式处理（休眠直接由以下内容涵盖，但描述也适用于系统范围的暂停）。具体来说，作为休眠过程的第一步，会调用函数 freeze_processes()（定义在 kernel/power/process.c 中）。一个系统范围的静态键 freezer_active（与每个任务标志或状态相反）用于指示系统是否将进行冻结操作。freeze_processes() 设置这个静态键。之后，它执行 try_to_freeze_tasks()，该函数向所有用户空间进程发送一个假信号，并唤醒所有内核线程。所有可冻结任务必须对此作出反应，通过调用 try_to_freeze()，这将导致调用 __refrigerator()（定义在 kernel/freezer.c 中），该函数将任务状态更改为 TASK_FROZEN，并使其循环直到被明确的 TASK_FROZEN 唤醒。然后，该任务被视为“已冻结”，因此处理此机制的一组函数被称为“冷冻器”（这些函数定义在 kernel/power/process.c、kernel/freezer.c 和 include/linux/freezer.h 中）。用户空间任务通常在内核线程之前冻结。
__refrigerator() 不应直接调用。而应使用 try_to_freeze() 函数（定义在 include/linux/freezer.h 中），该函数检查任务是否需要冻结，并使任务进入 __refrigerator()。
对于用户空间进程，try_to_freeze() 会自动从信号处理代码中调用，但可冻结的内核线程需要在适当的地方显式调用它，或者使用 wait_event_freezable() 或 wait_event_freezable_timeout() 宏（定义在 include/linux/wait.h 中），这些宏会在 freezer_active 被设置时将任务置于睡眠状态（TASK_INTERRUPTIBLE）或冻结状态（TASK_FROZEN）。可冻结内核线程的主要循环可能如下所示：

```c
set_freezable();

while (true) {
    struct task_struct *tsk = NULL;

    wait_event_freezable(oom_reaper_wait, oom_reaper_list != NULL);
    spin_lock_irq(&oom_reaper_lock);
    if (oom_reaper_list != NULL) {
        tsk = oom_reaper_list;
        oom_reaper_list = tsk->oom_reaper_list;
    }
    spin_unlock_irq(&oom_reaper_lock);

    if (tsk)
        oom_reap_task(tsk);
}
```

（来自 mm/oom_kill.c::oom_reaper()）
如果冷冻器启动冻结操作后可冻结的内核线程没有进入冻结状态，则任务冻结将失败，整个系统范围的过渡将被取消。出于这个原因，可冻结的内核线程必须在某个地方调用 try_to_freeze() 或使用 wait_event_freezable() 和 wait_event_freezable_timeout() 宏之一。
在系统内存状态从休眠映像恢复并重新初始化设备之后，会调用函数 thaw_processes() 以唤醒每个冻结任务。然后，已被冻结的任务将离开 __refrigerator() 并继续运行。
处理任务冻结和解冻的函数原理
-------------------------------------------------------------------------

freeze_processes():
- 只冻结用户空间任务

freeze_kernel_threads():
- 冻结所有任务（包括内核线程），因为我们不能在不冻结用户空间任务的情况下冻结内核线程

thaw_kernel_threads():
- 只解冻内核线程；这特别有用，如果我们需要在解冻内核线程和解冻用户空间任务之间做任何特殊的事情，或者如果我们想推迟解冻用户空间任务

thaw_processes():
- 解冻所有任务（包括内核线程），因为我们不能在不解冻内核线程的情况下解冻用户空间任务

III. 哪些内核线程是可冻结的？
========================================

内核线程默认情况下不是可冻结的。但是，内核线程可以通过调用 set_freezable() 清除 PF_NOFREEZE 来使自己成为可冻结的（直接重置 PF_NOFREEZE 是不允许的）。从这一点起，它被视为可冻结的，并且必须在适当的地方调用 try_to_freeze() 或 wait_event_freezable() 的变体。

IV. 为什么我们要这样做？
======================

总的来说，使用任务冻结有几个原因：

1. 主要原因是防止休眠后文件系统损坏。目前我们没有简单的手段来检查点文件系统，所以如果有任何对磁盘上的文件系统数据和元数据所做的修改，我们无法将它们恢复到修改前的状态。同时，每个休眠映像包含一些文件系统相关的信息，这些信息必须与从映像恢复系统内存状态后的磁盘上的数据和元数据状态一致（否则文件系统将以一种糟糕的方式损坏，通常几乎不可能修复）。因此，我们在创建休眠映像后且系统最终关闭电源之前冻结可能导致磁盘上的文件系统数据和元数据被修改的任务。大多数此类任务是用户空间进程，但如果任何内核线程可能会导致类似情况发生，那么它们必须是可冻结的。
2. 接下来，为了创建休眠镜像，我们需要释放足够的内存（大约是可用RAM的50%），并且需要在设备停用之前完成这一操作，因为我们通常需要这些设备来进行交换。

然后，在为镜像释放内存之后，我们不希望任务分配额外的内存，通过提前冻结它们来防止这种情况的发生。当然，这也意味着设备驱动程序不应该在其 `.suspend()` 回调中大量分配内存，但这是一个单独的问题。

3. 第三个原因是防止用户空间进程和某些内核线程干扰设备的挂起和恢复。例如，当我们在挂起设备时，另一个CPU上的用户空间进程可能会造成麻烦，如果没有冻结任务，我们需要一些防护措施来防止在这种情况下可能发生的竞态条件。
尽管 Linus Torvalds 不喜欢冻结任务，他在 LKML 的一次讨论中说道（https://lore.kernel.org/r/alpine.LFD.0.98.0704271801020.9964@woody.linux-foundation.org）：

“RJW：为什么我们要冻结任务或冻结内核线程？

Linus：在很多方面，‘完全冻结’
我确实意识到IO请求队列的问题，并且我们不能在DMA过程中对某些设备进行s2ram。所以我们需要避免这种情况，毫无疑问。我认为停止用户线程并等待同步实际上是一种比较简单的方法。
因此，在实践中，‘完全冻结’可能会变成‘为什么冻结内核线程？’，而冻结用户线程我不认为有什么问题。”

然而，仍然有一些内核线程可能希望被冻结。例如，如果一个属于设备驱动程序的内核线程直接访问设备，原则上它需要知道设备何时被挂起，以免在挂起时尝试访问设备。但是，如果内核线程是可以冻结的，它将在驱动程序的 `.suspend()` 回调执行前被冻结，并在 `.resume()` 回调运行后被解冻，因此它不会在设备挂起期间访问设备。

4. 冻结任务的另一个原因是防止用户空间进程意识到正在发生休眠（或挂起）操作。理想情况下，用户空间进程不应注意到这种系统级操作已经发生，并应在恢复（或从挂起恢复）后继续运行而不出现任何问题。不幸的是，在最一般的情况下，如果不冻结任务，这是相当难以实现的。例如，考虑一个依赖于所有CPU在线运行的进程。由于我们需要在休眠期间禁用非引导CPU，如果该进程未被冻结，它可能会注意到CPU数量的变化，并因此开始不正确地工作。

V. 冻结任务是否存在相关问题？
==================================

是的，存在一些问题。

首先，如果内核线程相互依赖，则冻结内核线程可能会变得复杂。例如，如果内核线程A等待由可冻结内核线程B完成的一个completion（处于 TASK_UNINTERRUPTIBLE 状态），并且B在此期间被冻结，那么A将被阻塞直到B被解冻，这可能是不可取的。这就是为什么内核线程默认情况下不可冻结的原因。

其次，冻结用户空间进程存在以下两个问题：

1. 将进程置于不可中断的睡眠状态会扭曲负载平均值。
2. 随着FUSE的引入以及用户空间中执行设备驱动程序框架，情况变得更加复杂，因为一些用户空间进程现在执行类似内核线程的工作（https://lists.linux-foundation.org/pipermail/linux-pm/2007-May/012309.html）。
问题 1 看起来是可以修复的，尽管到目前为止还没有被修复。另一个问题更严重，但似乎我们可以通过使用休眠（和挂起）通知器来绕过它（不过，在这种情况下，我们将无法避免用户空间进程意识到正在发生休眠）。

任务冻结往往会暴露出一些问题，尽管这些问题与冻结本身并不直接相关。例如，如果设备驱动程序的 .resume() 函数中调用了 request_firmware()，它将会超时并最终失败，因为此时应该响应请求的用户空间进程已被冻结。因此，看起来失败是由于任务被冻结造成的。

然而，假设固件文件位于一个只能通过尚未恢复的其他设备访问的文件系统上。在这种情况下，无论是否使用任务冻结，request_firmware() 都会失败。因此，这个问题实际上与任务冻结无关，因为它本来就存在。

在调用 suspend() 之前，驱动程序必须将所有可能需要的固件加载到 RAM 中。如果这样做不切实际，例如由于固件大小的问题，则必须使用文档中描述的 suspend 通知器 API 提前请求这些固件（参见 Documentation/driver-api/pm/notifiers.rst）。

### 是否有预防冻结失败的措施？

确实有一些预防措施。

首先，获取 'system_transition_mutex' 锁以排除一段代码在整个系统的睡眠过程中（如挂起/休眠）是不鼓励的。如果可能，这段代码应改为挂钩到挂起/休眠通知器以实现互斥。可以参考 CPU-Hotplug 代码（kernel/cpu.c）作为示例。

然而，如果这样做不可行，并且认为获取 'system_transition_mutex' 是必要的，则强烈建议不要直接调用 mutex_[un]lock(&system_transition_mutex)，因为这可能会导致冻结失败。原因是如果挂起/休眠代码成功获取了 'system_transition_mutex' 锁，从而使其他实体未能获取该锁，那么该任务将在 TASK_UNINTERRUPTIBLE 状态下被阻塞。结果，冻结器将无法冻结该任务，从而导致冻结失败。

然而，在这种情况下，[un]lock_system_sleep() API 是安全使用的，因为它们要求冻结器跳过冻结这个任务，因为它已经被“足够冻结”了，因为它被阻塞在 'system_transition_mutex' 上，而这个锁只有在完成整个挂起/休眠序列后才会释放。因此，总结一下，在这种情况下使用 [un]lock_system_sleep() 而不是直接使用 mutex_[un]lock(&system_transition_mutex)，这样可以防止冻结失败。

### 其他事项

/sys/power/pm_freeze_timeout 控制最多花费多长时间来冻结所有用户空间进程或所有可冻结的内核线程，单位为毫秒。默认值为 20000，范围为无符号整数。
当然，请提供您需要翻译的文本。
