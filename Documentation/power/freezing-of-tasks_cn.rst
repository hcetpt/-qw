任务冻结
=================

(C) 2007 Rafael J. Wysocki <rjw@sisk.pl>，GPL

I. 什么是任务冻结？
=================================

任务冻结是一种机制，用于在休眠或系统范围的挂起期间（在某些架构上）控制用户空间进程和某些内核线程。

II. 它是如何工作的？
=====================

有一个每任务标志（PF_NOFREEZE）和三种每任务状态（TASK_FROZEN、TASK_FREEZABLE 和 __TASK_FREEZABLE_UNSAFE）被用来实现这一点。
对于没有设置 PF_NOFREEZE 标志的任务（所有用户空间任务和某些内核线程），被认为是“可冻结”的，并且在系统进入睡眠状态之前以及在创建休眠映像之前以特殊方式处理（休眠直接由以下内容覆盖，但描述同样适用于系统范围的挂起）。
具体来说，在休眠过程的第一步中，会调用函数 freeze_processes()（定义在 kernel/power/process.c 中）。一个系统范围的静态键 freezer_active（与每任务标志或状态相反）用于指示系统是否将经历冻结操作。freeze_processes() 设置这个静态键。之后，它执行 try_to_freeze_tasks()，该函数向所有用户空间进程发送一个假信号，并唤醒所有内核线程。所有可冻结任务必须对此做出反应，通过调用 try_to_freeze()，这将导致调用 __refrigerator()（定义在 kernel/freezer.c 中），这会将任务的状态更改为 TASK_FROZEN，并使其循环直到被明确的 TASK_FROZEN 唤醒。然后，该任务被视为“已冻结”，因此处理此机制的一组函数被称为“冷冻器”（这些函数定义在 kernel/power/process.c、kernel/freezer.c 和 include/linux/freezer.h 中）。用户空间任务通常在内核线程之前被冻结。
__refrigerator() 不应直接调用。相反，使用 try_to_freeze() 函数（定义在 include/linux/freezer.h 中），该函数检查任务是否需要被冻结，并使任务进入 __refrigerator()。
对于用户空间进程，try_to_freeze() 自动从信号处理代码中调用，但是可冻结的内核线程需要在适当的地方显式调用它或使用 wait_event_freezable() 或 wait_event_freezable_timeout() 宏（定义在 include/linux/wait.h 中），这些宏会使任务处于睡眠状态（TASK_INTERRUPTIBLE）或冻结状态（TASK_FROZEN），如果设置了 freezer_active。
可冻结内核线程的主要循环可能如下所示：

```c
set_freezable();

while (true) {
    struct task_struct *tsk = NULL;

    wait_event_freezable(oom_reaper_wait, oom_reaper_list != NULL);
    spin_lock_irq(&oom_reaper_lock);
    if (oom_reaper_list != NULL) {
        tsk = oom_reaper_list;
        oom_reaper_list = tsk->oom_reaper_list;
    }
    spin_unlock_irq(&oom_reaper_lock);

    if (tsk)
        oom_reap_task(tsk);
}
```

（来自 mm/oom_kill.c::oom_reaper()）
如果在冷冻器启动冻结操作后，可冻结的内核线程未进入冻结状态，则任务冻结将失败，整个系统范围的转换将被取消。出于这个原因，可冻结的内核线程必须在某个地方调用 try_to_freeze() 或使用 wait_event_freezable() 和 wait_event_freezable_timeout() 宏之一。
在从休眠映像恢复系统内存状态并且重新初始化设备之后，会调用 thaw_processes() 函数来唤醒每个冻结的任务。然后，已被冻结的任务离开 __refrigerator() 并继续运行。
处理任务冻结和解冻的函数背后的理由
-------------------------------------------------------------------------

freeze_processes():
  - 只冻结用户空间任务

freeze_kernel_threads():
  - 冻结所有任务（包括内核线程），因为我们不能单独冻结内核线程而不冻结用户空间任务

thaw_kernel_threads():
  - 只解冻内核线程；这特别有用，如果我们需要在解冻内核线程和解冻用户空间任务之间做任何特殊的事情，或者如果我们想要推迟用户空间任务的解冻

thaw_processes():
  - 解冻所有任务（包括内核线程），因为我们不能单独解冻用户空间任务而不解冻内核线程

III. 哪些内核线程是可冻结的？
========================================

内核线程默认不是可冻结的。但是，内核线程可以通过调用 set_freezable() 来为自己清除 PF_NOFREEZE（直接重置 PF_NOFREEZE 是不允许的）。从这一点开始，它被视为可冻结的，并且必须在合适的地方调用 try_to_freeze() 或 wait_event_freezable() 的变体。

IV. 我们为什么这样做？
======================

一般来说，使用任务冻结有几个原因：

1. 主要原因是防止休眠后文件系统受损。目前我们没有简单的方法来检查点文件系统，所以如果对磁盘上的文件系统数据和元数据进行了任何修改，我们无法将它们恢复到修改前的状态。同时，每个休眠映像都包含一些与文件系统相关的信息，这些信息在从映像恢复系统内存状态后必须与磁盘上的数据和元数据的状态一致（否则文件系统将以一种糟糕的方式受损，通常使它们几乎不可能修复）。因此，我们在创建休眠映像后和系统最终关闭电源之前冻结可能导致磁盘上文件系统数据和元数据被修改的任务。这些主要是用户空间进程，但如果任何内核线程可能导致发生类似情况，它们也必须是可冻结的。
2. 首先，为了创建休眠镜像，我们需要释放足够的内存（大约为可用RAM的50%），并且必须在设备停用之前完成这一操作，因为我们通常需要这些设备来进行交换。然后，在为镜像释放内存后，我们不希望任务分配额外的内存，通过提前冻结它们来防止这种情况发生。[当然，这也意味着设备驱动程序不应从它们的.suspend()回调中在休眠前分配大量内存，但这是一个单独的问题。]

3. 第三个原因是防止用户空间进程和某些内核线程干扰设备的挂起和恢复过程。例如，当我们在挂起设备时，运行在第二个CPU上的用户空间进程可能会造成麻烦，如果没有冻结任务，我们需要一些保护措施来防止在这种情况下可能发生的竞态条件。尽管林纳斯·托瓦兹不喜欢冻结任务，但他在LKML（https://lore.kernel.org/r/alpine.LFD.0.98.0704271801020.9964@woody.linux-foundation.org）的一次讨论中表示：

“RJW:>为什么我们要冻结所有任务或为何要冻结内核线程？

林纳斯：在很多方面，‘冻结所有’
我确实意识到I/O请求队列问题，以及我们不能在某些设备处于DMA过程中执行s2ram。因此，我们想要避免*那个*情况，这一点毫无疑问。我认为停止用户线程然后等待同步实际上是一种较为简单的实现方式。
因此，实践中，‘冻结所有’可能转化为‘为何冻结内核线程？’，而冻结用户线程我并不认为有真正的反对理由。”

然而，仍有一些内核线程可能需要可被冻结。例如，如果一个属于设备驱动程序的内核线程直接访问设备，原则上它需要知道设备何时被挂起，以免在该时刻尝试访问设备。但是，如果内核线程是可冻结的，它将在执行驱动程序的.suspend()回调之前被冻结，并在驱动程序的.resume()回调运行后被解冻，因此它不会在设备被挂起时访问设备。

4. 冻结任务的另一个原因是防止用户空间进程意识到休眠（或挂起）操作正在进行。理想情况下，用户空间进程不应该注意到此类系统级操作已经发生，并且在恢复（或从挂起状态恢复）后应能继续无问题地运行。不幸的是，如果不冻结任务，在最一般的情况下，这很难实现。例如，考虑依赖于所有CPU在线的进程。由于在休眠期间需要禁用非启动CPU，如果此进程未被冻结，它可能会注意到CPU数量的变化，并因此开始出现错误工作。

V. 冻结任务是否存在问题？
=============================

是的，存在一些问题。
首先，如果内核线程相互依赖，冻结内核线程可能很棘手。例如，如果内核线程A以不可中断状态等待由可冻结内核线程B完成的completion，而B在此期间被冻结，则A将被阻塞直到B被解冻，这可能是不希望的。这就是为什么内核线程默认情况下不是可冻结的。
其次，与冻结用户空间进程相关的以下两个问题：

1. 将进程置于不可中断睡眠状态会扭曲负载平均值。
2. 现在我们有了FUSE，加上在用户空间中进行设备驱动程序的框架，情况变得更加复杂，因为一些用户空间进程现在执行内核线程所做的事情
（https://lists.linux-foundation.org/pipermail/linux-pm/2007-May/012309.html）
问题1似乎可以修复，尽管到目前为止还未解决。另一个问题更为严重，但似乎我们可以通过使用休眠（和挂起）通知器来绕过它（但在那种情况下，我们将无法避免用户空间进程意识到正在发生休眠）。

任务冻结往往暴露出一些问题，尽管这些问题与之并非直接相关。例如，如果在设备驱动程序的.resume()例程中调用request_firmware()，它将超时并最终失败，因为此时应该响应请求的用户空间进程已被冻结。因此，看起来失败是由于任务的冻结造成的。

然而，假设固件文件位于一个只能通过尚未恢复的其他设备访问的文件系统上。在这种情况下，无论是否使用任务冻结，request_firmware()都将失败。因此，问题实际上与任务冻结无关，因为它本来就存在。

在调用suspend()之前，驱动程序必须在RAM中拥有其可能需要的所有固件。如果由于大小等原因保留它们不切实际，则必须使用在Documentation/driver-api/pm/notifiers.rst中描述的挂起通知器API提前足够早地请求它们。

六、是否有预防措施可以防止冻结失败？

确实有。

首先，获取'system_transition_mutex'锁以相互排除系统范围内的睡眠（如挂起/休眠）代码的做法并不鼓励。如果可能，该代码段应改为挂接到挂起/休眠通知器以实现互斥。可以参考CPU热插拔代码（kernel/cpu.c）作为示例。

然而，如果这不可行，并且获取'system_transition_mutex'被认为是必要的，强烈不建议直接调用mutex_[un]lock(&system_transition_mutex)，因为这可能导致冻结失败。如果挂起/休眠代码成功获取了'system_transition_mutex'锁，从而导致另一实体未能获取锁，那么该任务将在TASK_UNINTERRUPTIBLE状态下被阻塞。结果，冻结器将无法冻结该任务，导致冻结失败。

然而，在这种情况下，[un]lock_system_sleep() API是安全使用的，因为它们要求冻结器跳过冻结此任务，因为它已经被“足够冻结”了，因为它被阻塞在'system_transition_mutex'上，而这个锁只有在整个挂起/休眠序列完成后才会释放。因此，总结来说，使用[un]lock_system_sleep()而不是直接使用mutex_[un]lock(&system_transition_mutex)。这将防止冻结失败。

五、杂项

/sys/power/pm_freeze_timeout控制最多花费多长时间来冻结所有用户空间进程或所有可冻结的内核线程，单位为毫秒。默认值为20000，取值范围为无符号整数。
你没有给出需要翻译的句子或词语，所以我无法为你提供具体的翻译。请提供需要翻译的内容，我将很乐意帮助你。例如，如果你需要翻译"Hello, how are you?"，那么中文翻译就是“你好，你怎么样？”。

如果你是想让我用中文描述我是如何作为一个助手的，那么可以这样表达：“作为一名助手，我的目标是帮助用户解决他们的问题和需求。无论是提供信息、提供建议还是执行任务，我都尽力以最有效和准确的方式为用户提供支持。”
