任务冻结
=================

(C) 2007 Rafael J. Wysocki <rjw@sisk.pl>，GPL

I. 什么是任务冻结？
=================================

任务冻结是一种机制，用于在休眠或系统范围的挂起期间（在某些架构上）控制用户空间进程和某些内核线程。

II. 它是如何工作的？
=====================

有一个每任务标志（PF_NOFREEZE）和三种每任务状态（TASK_FROZEN、TASK_FREEZABLE 和 __TASK_FREEZABLE_UNSAFE）被用来实现这一点。
对于没有设置 PF_NOFREEZE 标志的任务（所有用户空间任务和某些内核线程），被认为是“可冻结”的，并且在系统进入睡眠状态之前以及在创建休眠映像之前以特殊方式处理（休眠直接由以下内容覆盖，但描述同样适用于系统范围的挂起）。
具体来说，在休眠过程的第一步中，会调用函数 freeze_processes()（定义在 kernel/power/process.c 中）。一个系统范围的静态键 freezer_active（与每任务标志或状态相反）用于指示系统是否将经历冻结操作。freeze_processes() 设置这个静态键。之后，它执行 try_to_freeze_tasks()，该函数向所有用户空间进程发送一个假信号，并唤醒所有内核线程。所有可冻结任务必须对此做出反应，通过调用 try_to_freeze()，这将导致调用 __refrigerator()（定义在 kernel/freezer.c 中），这会将任务的状态更改为 TASK_FROZEN，并使其循环直到被明确的 TASK_FROZEN 唤醒。然后，该任务被视为“已冻结”，因此处理此机制的一组函数被称为“冷冻器”（这些函数定义在 kernel/power/process.c、kernel/freezer.c 和 include/linux/freezer.h 中）。用户空间任务通常在内核线程之前被冻结。
__refrigerator() 不应直接调用。而应使用 try_to_freeze() 函数（定义在 include/linux/freezer.h 中），该函数检查任务是否需要被冻结，并使任务进入 __refrigerator()。
对于用户空间进程，try_to_freeze() 会自动从信号处理代码中调用，但是可冻结的内核线程需要在合适的地方显式调用它，或者使用 wait_event_freezable() 或 wait_event_freezable_timeout() 宏（定义在 include/linux/wait.h 中），它们会使任务进入睡眠（TASK_INTERRUPTIBLE）或冻结（TASK_FROZEN），如果设置了 freezer_active。可冻结内核线程的主要循环可能如下所示：

```c
set_freezable();

while (true) {
    struct task_struct *tsk = NULL;

    wait_event_freezable(oom_reaper_wait, oom_reaper_list != NULL);
    spin_lock_irq(&oom_reaper_lock);
    if (oom_reaper_list != NULL) {
        tsk = oom_reaper_list;
        oom_reaper_list = tsk->oom_reaper_list;
    }
    spin_unlock_irq(&oom_reaper_lock);

    if (tsk)
        oom_reap_task(tsk);
}
```

（来自 mm/oom_kill.c::oom_reaper()）
如果在冷冻器启动冻结操作后可冻结内核线程未进入冻结状态，则任务冻结将失败，并取消整个系统范围的转换。出于这个原因，可冻结内核线程必须在某个地方调用 try_to_freeze() 或使用 wait_event_freezable() 和 wait_event_freezable_timeout() 宏之一。
在从休眠映像恢复系统内存状态并重新初始化设备之后，会调用函数 thaw_processes() 以唤醒每个已冻结的任务。然后，已被冻结的任务离开 __refrigerator() 并继续运行。
处理任务冻结和解冻功能背后的原理
-------------------------------------------------------------------------

freeze_processes():
- 只冻结用户空间任务

freeze_kernel_threads():
- 冻结所有任务（包括内核线程），因为我们不能在不冻结用户空间任务的情况下冻结内核线程

thaw_kernel_threads():
- 只解冻内核线程；这特别有用，如果我们需要在解冻内核线程和解冻用户空间任务之间做任何特殊的事情，或者如果我们想推迟解冻用户空间任务

thaw_processes():
- 解冻所有任务（包括内核线程），因为我们不能在不解冻内核线程的情况下解冻用户空间任务

III. 哪些内核线程是可冻结的？
========================================

内核线程默认不是可冻结的。然而，内核线程可以通过调用 set_freezable() 来为自己清除 PF_NOFREEZE（直接重置 PF_NOFREEZE 是不允许的）。从这一刻起，它被视为可冻结的，并且必须在合适的地方调用 try_to_freeze() 或 wait_event_freezable() 的变体。

IV. 我们为什么这么做？
======================

总的来说，使用任务冻结有几个原因：

1. 主要原因是防止休眠后文件系统损坏。目前我们没有简单的方法来对文件系统进行检查点，所以如果有任何修改被应用到磁盘上的文件系统数据和元数据，我们就无法将其恢复到修改前的状态。同时，每个休眠映像包含一些与文件系统相关的信息，这些信息在从映像恢复系统内存状态后必须与磁盘上的数据和元数据的状态一致（否则文件系统将以非常糟糕的方式损坏，通常几乎不可能修复）。因此，我们在创建休眠映像后并且系统最终关闭电源之前，冻结可能导致磁盘上的文件系统数据和元数据被修改的任务。这些任务大多数是用户空间进程，但如果任何内核线程可能导致类似的情况发生，它们也必须是可冻结的。
2. 首先，为了创建休眠镜像，我们需要释放足够的内存（大约为可用RAM的50%），并且需要在设备被停用之前完成这一操作，因为我们通常需要这些设备来进行交换。然后，在为镜像分配的内存被释放之后，我们不希望任务再分配额外的内存，我们通过提前冻结它们来防止这种情况发生。[当然，这也意味着设备驱动程序不应该从它们的.suspend()回调中在休眠前分配大量的内存，但这是一个单独的问题。]

3. 第三个原因是防止用户空间进程和某些内核线程干扰设备的挂起和恢复过程。当我们在挂起设备时，如果一个用户空间进程在第二个CPU上运行，可能会带来麻烦。如果没有冻结任务，我们需要采取一些措施来避免在这种情况下可能出现的竞争条件。
尽管Linus Torvalds不喜欢冻结任务，他在LKML（https://lore.kernel.org/r/alpine.LFD.0.98.0704271801020.9964@woody.linux-foundation.org）的一次讨论中提到：

"RJW:> 为什么我们要冻结任务或者为什么要冻结内核线程？

Linus: 在很多方面，‘根本’
我确实意识到I/O请求队列的问题，并且我们不能在某些设备正在进行DMA时进行s2ram操作。因此，我们需要避免*这种情况*，这一点毫无疑问。我认为停止用户线程然后等待同步实际上是实现这一目标的一种相对简单的方法。
因此，在实践中，‘根本’可能会变成‘为什么要冻结内核线程？’而冻结用户线程我个人并不觉得有什么问题。”

然而，仍有一些内核线程可能需要能够被冻结。例如，如果一个属于设备驱动程序的内核线程直接访问设备，原则上它需要知道设备何时处于挂起状态，以便不会在该时刻尝试访问设备。但是，如果这个内核线程可以被冻结，那么它将在驱动程序的.suspend()回调执行前被冻结，并在驱动程序的.resume()回调运行后被解冻，因此它不会在设备处于挂起状态时访问设备。

4. 冻结任务的另一个原因是防止用户空间进程意识到正在发生休眠（或挂起）操作。理想情况下，用户空间进程不应注意到发生了这种系统级操作，并应在恢复（或从挂起恢复）后无任何问题地继续运行。不幸的是，在最一般的情况下，如果不冻结任务，要实现这一点是相当困难的。例如，考虑一个依赖于所有CPU在线的进程。由于我们需要在休眠期间禁用非启动CPU，如果这个进程没有被冻结，它可能会注意到CPU数量的变化，并因此开始出现异常行为。

V. 冻结任务是否存在相关问题？
==================================

是的，存在一些问题。
首先，如果内核线程相互依赖，冻结内核线程可能会变得复杂。例如，如果内核线程A等待由可冻结内核线程B完成的一个completion（处于TASK_UNINTERRUPTIBLE状态），而此时B被冻结，则A将被阻塞直到B被解冻，这可能是不可取的。这就是为什么内核线程默认不是可冻结的原因。
其次，冻结用户空间进程存在以下两个问题：

1. 将进程置于不可中断睡眠状态会扭曲负载平均值。
2. 现在有了FUSE以及在用户空间中实现设备驱动程序的框架，情况变得更加复杂，因为一些用户空间进程现在执行了类似内核线程的工作（https://lists.linux-foundation.org/pipermail/linux-pm/2007-May/012309.html）。
问题 1. 看起来是可以修复的，尽管到目前为止还未进行修复。另一个问题更为严重，但似乎我们可以通过使用休眠（以及挂起）通知器来规避这个问题（但在这种情况下，我们将无法避免用户空间进程意识到正在发生休眠过程）。
还有一些问题往往由任务冻结所暴露出来，尽管这些问题与任务冻结并非直接相关。例如，如果在设备驱动程序的 .resume() 函数中调用了 request_firmware()，它将超时并最终失败，因为此时应该响应请求的用户空间进程已经被冻结。因此，看似这个失败是由任务冻结引起的。
然而，假设固件文件位于一个仅通过尚未恢复的其他设备可访问的文件系统上。在这种情况下，无论是否使用任务冻结，request_firmware() 都会失败。因此，该问题实际上与任务冻结无关，因为它本身就存在。
驱动程序必须在调用 suspend() 之前将其可能需要的所有固件保存在 RAM 中。如果不切实际，例如由于其大小，它们必须使用文档中描述的 suspend 通知器 API 提前请求（请参阅 Documentation/driver-api/pm/notifiers.rst）。
六、是否有预防措施可以防止冻结失败？
=================================================================================

确实有。
首先，获取 'system_transition_mutex' 锁以排除代码从系统级睡眠如挂起/休眠的情况是不被鼓励的。如果可能，这部分代码应改为通过挂起/休眠通知器来实现互斥。可以参考 CPU-Hotplug 代码（kernel/cpu.c）作为示例。
然而，如果这样做不可行，并且认为获取 'system_transition_mutex' 是必要的，则强烈不建议直接调用 mutex_[un]lock(&system_transition_mutex)，因为这可能会导致冻结失败，因为如果挂起/休眠代码成功获取了 'system_transition_mutex' 锁，从而使其他实体未能获取锁，那么该任务将在 TASK_UNINTERRUPTIBLE 状态下阻塞。结果，冻结器将无法冻结此任务，导致冻结失败。
但是，在这种情况下，[un]lock_system_sleep() API 是安全使用的，因为它们要求冻结器跳过冻结此任务，因为它已经“足够冻结”了，因为它被阻塞在 'system_transition_mutex' 上，而这个锁只有在完成整个挂起/休眠序列后才会释放。因此，总结来说，请使用 [un]lock_system_sleep() 而不是直接使用 mutex_[un]lock(&system_transition_mutex)。这样可以防止冻结失败。
五、杂项
======================
/sys/power/pm_freeze_timeout 控制冻结所有用户空间进程或所有可冻结内核线程所需的最大时间，单位为毫秒。默认值为 20000，取值范围为无符号整数。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
