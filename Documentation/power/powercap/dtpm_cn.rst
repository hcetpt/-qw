... SPDX 许可证标识符：GPL-2.0

==========================================
动态热能功耗管理框架
==========================================

在嵌入式世界中，系统级芯片（SoC）的复杂性导致了越来越多的热点，这些热点需要作为一个整体进行监控和缓解，以防止温度超过规范和法律规定的“皮肤温度”。另一方面，在给定的功耗预算下保持性能，例如在虚拟现实场景中，如果大CPU处理其他任务时性能受到限制，用户可能会感到头晕。或者因为与其它设备消耗的功率相比，散失的功率过高而减少电池充电速度。
用户空间是最适合动态作用于不同设备的地方，通过限制它们的功耗来适应应用程序配置文件：它了解平台的情况。
动态热能功耗管理（DTPM）是一种技术，通过限制和/或平衡不同设备之间的功耗预算来作用于设备功耗。
概述
========

DTPM框架依赖于powercap框架来在sysfs目录中创建powercap条目，并实现后端驱动程序以与可管理功耗的设备建立连接。
DTPM是一种树状表示，描述的是设备间共享的功耗约束，而不是它们的物理位置。
树中的节点是子节点功耗特性的虚拟汇总及其功耗限制。
树的叶节点是真实的可管理功耗的设备。
例如：

```
SoC
 |
 `-- pkg
   |
   |-- pd0 (cpu0-3)
   |
   `-- pd1 (cpu4-5)
```

pkg的功耗将是pd0和pd1功耗数字的总和：

```
SoC (400mW - 3100mW)
 |
 `-- pkg (400mW - 3100mW)
   |
   |-- pd0 (100mW - 700mW)
   |
   `-- pd1 (300mW - 2400mW)
```

当节点被插入到树中时，它们的功耗特性会被传播到父节点：

```
SoC (600mW - 5900mW)
 |
 |-- pkg (400mW - 3100mW)
 |    |
 |    |-- pd0 (100mW - 700mW)
 |    |
 |    `-- pd1 (300mW - 2400mW)
 |
 `-- pd2 (200mW - 2800mW)
```

每个节点都有一个基于2^10的权重，反映了与其兄弟节点相比的功耗百分比：

```
SoC (w=1024)
 |
 |-- pkg (w=538)
 |    |
 |    |-- pd0 (w=231)
 |    |
 |    `-- pd1 (w=794)
 |
 `-- pd2 (w=486)
```

请注意，同一级别的权重之和等于1024。
当对节点施加功率限制时，该限制会根据其权重在子节点间分配。例如，如果我们在'SoC'根节点设置3200mW的功率限制，则生成的树结构如下：

```
SoC (w=1024) <--- 功率限制 = 3200mW
  |
  |-- pkg (w=538) --> 功率限制 = 1681mW
      |
      |-- pd0 (w=231) --> 功率限制 = 378mW
      |
      `-- pd1 (w=794) --> 功率限制 = 1303mW
  |
  `-- pd2 (w=486) --> 功率限制 = 1519mW
```

**平面描述**

创建一个根节点，它是所有其他节点的父节点。这种描述是最简单的，旨在为用户空间提供一个平面表示，展示所有支持功率限制的设备，而不涉及任何功率限制的分配。

**层次描述**

支持功率限制的不同设备被层次化地表示。存在一个根节点，所有中间节点都集合了子节点，这些子节点可以是中间节点或实际设备。中间节点汇总功率信息，并允许根据节点的权重设置功率限制。

**用户空间API**

如概述所述，DTPM框架建立在powercap框架之上。因此，sysfs接口是相同的，请参考powercap文档获取更多详细信息。
* power_uw: 瞬时功率消耗。如果节点是一个中间节点，那么功率消耗将是所有子节点功率消耗的总和。
* max_power_range_uw: 最大功率减去最小功率后得到的功率范围。
* name: 节点的名称。这取决于具体实现。尽管不推荐用户空间使用，但多个节点可以具有相同的名称。
* constraint_X_name: 约束的名称。
* constraint_X_max_power_uw: 应用于节点的最大功率限制。
* constraint_X_power_limit_uw: 应用于节点的功率限制。如果在constraint_X_max_power_uw中设置的值有效，则将移除该约束。
* constraint_X_time_window_us: 此文件的含义将取决于约束编号
约束
------

 * 约束 0: 功率限制立即应用，不受时间限制
内核API
========

概览
------

DTPM框架没有功率限制后端支持。它是通用的，并提供了一组API，让不同的驱动程序可以实现功率限制的后端部分并创建功率约束树。
平台需要提供初始化函数来分配和链接树的不同节点。
一个特殊的宏用于通过描述结构声明一个节点及其相应的初始化函数。此结构包含一个可选的父级字段，允许在启动时将不同设备挂接到已存在的树上。
例如::

    struct dtpm_descr my_descr = {
        .name = "my_name",
        .init = my_init_func,
    };

    DTPM_DECLARE(my_descr);

DTPM树的节点用dtpm结构进行描述。添加新的可功率限制设备的步骤分为三步：

 * 分配dtpm节点
 * 设置dtpm节点的功率编号
 * 注册dtpm节点

dtpm节点的注册是通过powercap ops完成的。基本上，它必须实现获取和设置功率及限制的回调。
或者，如果要插入的节点是一个中间节点，则有一个简单的函数可以将其作为未来的父节点插入。
如果设备的功率特性发生变化，则必须使用新的功率数值和权重更新树。
命名规则
------------

 * dtpm_alloc() : 分配并初始化一个dtpm结构

 * dtpm_register() : 将dtpm节点添加到树中

 * dtpm_unregister() : 从树中移除dtpm节点

 * dtpm_update_power() : 更新dtpm节点的功率特性
