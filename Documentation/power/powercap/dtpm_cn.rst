### SPDX 许可证标识符：GPL-2.0

==========================================
动态热功耗管理框架
==========================================

在嵌入式领域，系统级芯片（SoC）的复杂性导致越来越多的热点需要被监控和整体控制以防止温度超过规范和法律规定的“皮肤温度”。
另一方面，需要在给定的功耗预算内维持性能，例如虚拟现实场景中，如果大功率CPU处理其他任务时性能受到限制，用户可能会感到头晕。或者因为散失的功率相对于其他设备消耗的功率过高而导致电池充电减少。
用户空间是最适合动态调整不同设备功耗的地方，根据应用配置文件限制它们的功耗：它了解平台的情况。
动态热功耗管理（DTPM）是一种通过限制和/或平衡不同设备之间的功耗预算来作用于设备功耗的技术。
概述
========

DTPM框架依赖于功耗上限（powercap）框架创建sysfs目录中的功耗上限条目并实现后端驱动程序以连接可管理功耗的设备。
DTPM是一个树状表示，描述了设备之间共享的功耗约束，而不是它们的实际物理位置。
树中的节点是子节点功耗特性的虚拟聚合及其功耗限制。
树的叶子是真实的可管理功耗的设备。
例如：

```
SoC
 |
 `-- pkg
   |
   |-- pd0 (cpu0-3)
   |
   `-- pd1 (cpu4-5)
```

pkg的功耗将是pd0和pd1功耗数值之和：

```
SoC (400mW - 3100mW)
 |
 `-- pkg (400mW - 3100mW)
   |
   |-- pd0 (100mW - 700mW)
   |
   `-- pd1 (300mW - 2400mW)
```

当节点被插入到树中时，它们的功耗特性会向上传播到父节点：

```
SoC (600mW - 5900mW)
 |
 |-- pkg (400mW - 3100mW)
 |    |
 |    |-- pd0 (100mW - 700mW)
 |    |
 |    `-- pd1 (300mW - 2400mW)
 |
 `-- pd2 (200mW - 2800mW)
```

每个节点都有一个基于2^10的基础权重，反映了与兄弟节点相比的功耗百分比：

```
SoC (w=1024)
 |
 |-- pkg (w=538)
 |    |
 |    |-- pd0 (w=231)
 |    |
 |    `-- pd1 (w=794)
 |
 `-- pd2 (w=486)

注意同一层级的权重总和等于1024
```
当对一个节点应用功率限制时，该限制会根据其子节点的权重进行分配。例如，如果我们在“SoC”根节点上设置3200毫瓦的功率限制，则生成的树形结构如下：

  SoC (w=1024) <--- 功率限制 = 3200毫瓦
   |
   |-- pkg (w=538) --> 功率限制 = 1681毫瓦
   |    |
   |    |-- pd0 (w=231) --> 功率限制 = 378毫瓦
   |    |
   |    `-- pd1 (w=794) --> 功率限制 = 1303毫瓦
   |
   `-- pd2 (w=486) --> 功率限制 = 1519毫瓦

**平面描述**
------------

创建一个根节点，并且它是所有节点的父节点。这种描述是最简单的形式，旨在为用户空间提供一个所有支持功率限制的设备的平面表示，而不涉及任何功率限制的分配。

**层次描述**
------------

支持功率限制的不同设备以层级的方式表示。存在一个根节点，所有中间节点将子节点分组在一起，这些子节点可以是中间节点或实际的设备。
中间节点汇总功率信息，并允许根据节点的权重设置功率限制。

**用户空间API**
=================

如概述中所述，DTPM框架构建在powercap框架之上。因此，sysfs接口是相同的，请参阅powercap文档获取更多详细信息：
* power_uw: 瞬时功率消耗。如果节点是一个中间节点，则功率消耗将是所有子节点功率消耗的总和
* max_power_range_uw: 最大功率减去最小功率得到的功率范围
* name: 节点的名称。这取决于具体实现。尽管不建议用户空间这样做，但多个节点可以具有相同的名称
* constraint_X_name: 约束的名称
* constraint_X_max_power_uw: 应用于节点的最大功率限制
* constraint_X_power_limit_uw: 应用于节点的功率限制。如果constraint_X_max_power_uw中设置的值有效，则该约束将被移除
* constraint_X_time_window_us: 本文件的意义将取决于约束编号
约束
-----

* 约束 0: 功率限制立即生效，不受时间限制
内核API
=======

概览
----

DTPM框架目前没有功率限制后端支持。它是通用的，并提供了一组API以让不同的驱动程序实现功率限制的后端部分并创建功率约束树。
平台需要提供初始化函数来分配和链接树中的不同节点。
一个特殊的宏用于声明一个节点及其对应的初始化函数通过描述结构。此结构包含一个可选的父级字段，允许在启动时将不同的设备挂接到已存在的树上。
例如::

    struct dtpm_descr my_descr = {
        .name = "my_name",
        .init = my_init_func,
    };

    DTPM_DECLARE(my_descr);

DTPM树的节点用dtpm结构进行描述。添加新的可功率限制设备的步骤分为三步：

* 分配dtpm节点
* 设置dtpm节点的功率编号
* 注册dtpm节点

dtpm节点的注册是通过powercap ops完成的。基本上，它必须实现获取和设置功率及限制的回调。
如果要插入的节点是一个中间节点，则有一个简单的函数可供将其作为未来的父节点插入。
如果设备的功率特性发生变化，则必须使用新的功率编号和权重更新树。
命名规则
---------

* dtpm_alloc(): 分配并初始化一个dtpm结构

* dtpm_register(): 将dtpm节点添加到树中

* dtpm_unregister(): 从树中移除dtpm节点

* dtpm_update_power(): 更新dtpm节点的功率特性
