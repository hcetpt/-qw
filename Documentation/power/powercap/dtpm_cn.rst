SPDX 许可证标识符: GPL-2.0

==========================================
动态热功耗管理框架
==========================================

在嵌入式领域，SoC 的复杂性导致越来越多的热点需要整体监控和缓解，以防止温度超过规范和法律规定的“皮肤温度”。另一个方面是在给定的功耗预算下维持性能，例如虚拟现实场景中，如果性能受限而大 CPU 在处理其他任务时，用户可能会感到头晕。或者由于散热量相对于其他设备消耗的功率过高而导致电池充电减少。用户空间是最适合动态调整不同设备功耗的地方，根据应用程序配置文件限制其功耗：它了解平台信息。动态热功耗管理（DTPM）是一种通过限制和/或平衡不同设备之间的功耗来作用于设备功耗的技术。DTPM 框架提供了一个统一的接口来调整设备的功耗。

概述
========

DTPM 框架依赖于 powercap 框架，在 sysfs 目录中创建 powercap 条目，并实现后端驱动程序以连接可管理功耗的设备。DTPM 是一个树形表示，描述了设备之间共享的功耗约束，而不是它们的物理位置。树中的节点是对子节点的功耗特性的虚拟汇总及其功耗限制。树的叶子是实际的可管理功耗的设备。例如：

```
SoC
 |
 `-- pkg
   |
   |-- pd0 (cpu0-3)
   |
   `-- pd1 (cpu4-5)
```

pkg 的功耗将是 pd0 和 pd1 功耗之和：

```
SoC (400mW - 3100mW)
 |
 `-- pkg (400mW - 3100mW)
   |
   |-- pd0 (100mW - 700mW)
   |
   `-- pd1 (300mW - 2400mW)
```

当节点插入到树中时，它们的功耗特性会向上传播到父节点：

```
SoC (600mW - 5900mW)
 |
 |-- pkg (400mW - 3100mW)
 |    |
 |    |-- pd0 (100mW - 700mW)
 |    |
 |    `-- pd1 (300mW - 2400mW)
 |
 `-- pd2 (200mW - 2800mW)
```

每个节点都有一个基于 2^10 的权重，反映了与兄弟节点相比的功耗百分比：

```
SoC (w=1024)
 |
 |-- pkg (w=538)
 |    |
 |    |-- pd0 (w=231)
 |    |
 |    `-- pd1 (w=794)
 |
 `-- pd2 (w=486)
```

请注意，同一级别的权重总和等于 1024。
当对一个节点应用功率限制时，该限制会根据子节点的权重进行分配。例如，如果我们为“SoC”根节点设置3200mW的功率限制，则生成的树如下：

```
SoC (w=1024) <--- 功率限制 = 3200mW
  |
  |-- pkg (w=538) --> 功率限制 = 1681mW
     |
     |-- pd0 (w=231) --> 功率限制 = 378mW
     |
     `-- pd1 (w=794) --> 功率限制 = 1303mW
  |
  `-- pd2 (w=486) --> 功率限制 = 1519mW
```

扁平描述
--------

创建一个根节点，它是所有节点的父节点。这种描述是最简单的，并且旨在向用户空间提供一个扁平化的表示，展示所有支持功率限制的设备，而不涉及任何功率限制的分配。

分层描述
--------

支持功率限制的不同设备以分层方式表示。有一个根节点，所有中间节点聚合子节点，这些子节点可以是中间节点也可以是实际的设备。
中间节点汇总功率信息，并允许根据节点的权重设置功率限制。

用户空间API
============

如概述中所述，DTPM框架建立在powercap框架之上。因此，sysfs接口是相同的，请参阅powercap文档获取更多详细信息：
* power_uw：瞬时功率消耗。如果节点是一个中间节点，则功率消耗将是所有子节点功率消耗的总和。
* max_power_range_uw：最大功率减去最小功率得到的功率范围。
* name：节点的名称。这是实现相关的。虽然不建议用户空间这样做，但几个节点可以具有相同的名称。
* constraint_X_name：约束的名称。
* constraint_X_max_power_uw：适用于节点的最大功率限制。
* constraint_X_power_limit_uw：应用于节点的功率限制。如果constraint_X_max_power_uw中的值被设置，则将移除该约束。
* constraint_X_time_window_us: 该文件的意义将取决于约束编号
约束
------

* Constraint 0（约束0）：功率限制立即生效，没有时间限制

内核API
=======

概述
--------

DTPM框架没有功率限制后端支持。它是通用的，并提供了一组API，让不同的驱动程序能够实现功率限制的后端部分并创建功率约束树。
平台需要提供初始化函数来分配和连接树的不同节点。
一个特殊的宏用于通过描述结构声明一个节点及其相应的初始化函数。该描述结构包含一个可选的父节点字段，允许在启动时将不同设备挂接到已存在的树上。
例如：

```c
    struct dtpm_descr my_descr = {
        .name = "my_name",
        .init = my_init_func,
    };

    DTPM_DECLARE(my_descr);
```

DTPM树的节点使用dtpm结构进行描述。添加一个新的可功率限制设备的步骤分为三步：

1. 分配dtpm节点
2. 设置dtpm节点的功率数量
3. 注册dtpm节点

dtpm节点的注册是通过powercap ops完成的。基本上，它必须实现获取和设置功率及限制的回调。
如果要插入的节点是一个中间节点，则可以使用一个简单的函数将其作为未来的父节点插入。
如果某个设备的功率特性发生变化，则树必须更新为新的功率数值和权重。

术语
------------

* dtpm_alloc()：分配并初始化一个dtpm结构
* dtpm_register()：将dtpm节点添加到树中
* dtpm_unregister()：从树中移除dtpm节点
* dtpm_update_power()：更新dtpm节点的功率特性
