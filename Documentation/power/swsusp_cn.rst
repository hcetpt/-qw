交换挂起
==========

一些警告，首先
.. 警告::

   **重要的警告**

   如果你在挂起到恢复期间对磁盘上的任何内容进行操作...
...你的数据可能会丢失
如果你在文件系统已挂载后从initrd中恢复...
...根分区可能会丢失
[这实际上是上述情况的同一种情形]

   如果你有不支持（）DMA的设备，你可能会遇到一些问题。如果你的磁盘驱动程序不支持挂起...（IDE支持），它也可能导致一些问题。如果你在挂起到恢复期间更改内核命令行，它可能会做些错误的事情。如果你在系统挂起时更改硬件...嗯，这不是个好主意；但它可能只会导致崩溃
（）需要挂起/恢复支持才能确保安全
如果你在软件挂起之前挂载了USB设备上的文件系统，在恢复之后它们将无法访问，并且你可能会丢失数据，就像你在挂载文件系统的USB设备未卸载的情况下拔掉设备一样；请参阅下面的常见问题解答以获取详细信息。（对于更传统的电源状态如“待机”，通常不会关闭USB，因此这种情况并不适用。）

交换分区：
  你需要在内核命令行中添加resume=/dev/your_swap_partition，或者使用/sys/power/resume来指定。
交换文件：
  如果使用交换文件，也可以使用resume_offset=<数字>在内核命令行中指定一个恢复偏移量，或在/sys/power/resume_offset中指定。
准备完毕后，你可以通过以下方式挂起：

```
echo shutdown > /sys/power/disk; echo disk > /sys/power/state
```

- 如果你觉得ACPI在你的系统上工作得很好，你可以尝试：

```
echo platform > /sys/power/disk; echo disk > /sys/power/state
```

- 如果你想将休眠映像写入交换空间然后再挂起到RAM（前提是你的平台支持），你可以尝试：

```
echo suspend > /sys/power/disk; echo disk > /sys/power/state
```

- 如果你有SATA磁盘，你需要较新的带有SATA挂起支持的内核。为了使挂起和恢复功能正常工作，请确保你的磁盘驱动程序是内置到内核中的——而不是模块。[有一种方法可以在模块化磁盘驱动程序下实现挂起/恢复功能，详见常见问题解答，但你可能不应该这样做。]

如果你想将挂起映像大小限制为N字节，在挂起之前执行：

```
echo N > /sys/power/image_size
```

（默认情况下，它被限制为可用RAM的大约2/5）
恢复过程检查恢复设备是否存在，
如果找到，则进一步检查内容中是否有休眠图像签名。
如果两者都找到，恢复休眠图像。

恢复过程可以通过两种方式触发：

1) 在lateinit期间：如果内核命令行指定了resume=/dev/your_swap_partition，lateinit将运行恢复过程。如果恢复设备尚未被探测到，恢复过程会失败，并继续启动。
2) 从initrd或initramfs手动执行：可以在init脚本中通过/sys/power/resume文件来运行。必须在重新挂载任何文件系统（即使是只读的）之前完成此操作，否则数据可能会损坏。

关于Linux软件挂起的目标和实现的文章
================================================

作者：Gábor Kuti
最后修订：2003-10-20 由 Pavel Machek

理念和目标
-------------------------
如今，在许多笔记本电脑中常见的功能是有一个挂起按钮。它将机器的状态保存到文件系统或分区，并切换到待机模式。之后，当恢复机器时，保存的状态会被加载回RAM，机器可以继续工作。这有两个实际的好处。首先，我们节省了机器关机和重新启动所需的时间；其次，使用电池时能源成本很高。另一个好处是我们不必中断正在运行的程序，因此长时间计算的进程不需要被打断以支持可中断性。
swsusp 将机器状态保存到活动交换区，然后重启或关闭电源。你必须显式指定要从中恢复的交换分区，使用 `resume=` 内核选项。如果找到签名，它会加载并恢复保存的状态。如果启动参数中指定了 `noresume` 选项，则跳过恢复。如果启动参数中指定了 `hibernate=nocompress` 选项，则不压缩地保存休眠图像。
在此期间，系统挂起时不应添加或移除任何硬件，也不应写入文件系统等。

睡眠状态总结
====================
有三种不同的接口可以使用，/proc/acpi 应该像这样工作：

在一个真正完美的世界里：
```
  echo 1 > /proc/acpi/sleep       # 对于待机
  echo 2 > /proc/acpi/sleep       # 对于内存挂起
  echo 3 > /proc/acpi/sleep       # 对于内存挂起，但更节能
  echo 4 > /proc/acpi/sleep       # 对于磁盘挂起
  echo 5 > /proc/acpi/sleep       # 对于不友好的关机
```
也许还可以：
```
  echo 4b > /proc/acpi/sleep      # 通过s4bios进行磁盘挂起
```

常见问题解答
==========================
问：
  嗯，挂起服务器在我看来真的很愚蠢，但是……（Diego Zuccato）：

答：
  你为你的服务器买了新的UPS。如何在不使机器关机的情况下安装它？磁盘挂起到，重新布置电源线，恢复。
  你的服务器在UPS上运行。电源断了，UPS显示还有30秒就失效。你应该怎么做？磁盘挂起到。
问：
  或许我漏掉了什么，但为什么常规的I/O路径不起作用？

答：
  我们确实使用了常规的I/O路径。然而，我们不能在加载数据时将其恢复到原始位置。这将导致内核状态不一致，从而必然导致系统崩溃。
相反，我们将图像加载到未使用的内存中，然后原子地将其复制回原来的位置。当然，这意味着图像的最大尺寸为内存总量的一半。
解决这个问题有两种方法：

* 要求在挂起期间至少有一半的内存是空闲的。这样你可以在空闲位置读取“新”数据，然后进行CLI（关闭中断）和复制。

* 假设我们有一个特殊的“轮询”IDE驱动程序，它只使用0-640KB之间的内存。这样一来，在挂起时我需要确保0-640KB是空闲的，但除此之外就可以正常工作。
Suspend2也有这个基本限制，但它不把用户数据和磁盘缓存算作“已用内存”，因为这些数据已经被提前保存了。这意味着实际上这个限制消失了。

问：Linux支持ACPI S4吗？

答：支持。这就是`echo platform > /sys/power/disk`的作用。

问：什么是“suspend2”？

答：suspend2即“软件挂起2”，是一个针对suspend-to-disk功能的分叉实现，可以从swsusp.sourceforge.net获取适用于2.4和2.6内核的独立补丁包。它支持SMP、4GB高内存和抢占性调度。此外，它还具有可扩展架构，允许对图像进行任意变换（如压缩、加密），并可以将图像写入不同的后端（例如交换分区或NFS共享[仍在开发中]）。关于suspend2的问题应发送至该网站提供的邮件列表，而不是Linux内核邮件列表。我们正在努力将suspend2合并到主线内核中。

问：任务冻结是什么？为什么我们要使用它？

答：任务冻结是一种机制，用于在休眠或系统级挂起（某些架构上）期间控制用户空间进程和部分内核线程。详见`freezing-of-tasks.txt`文件中的详细信息。

问：“platform”与“shutdown”的区别是什么？

答：
- `shutdown`：在Linux中保存状态，然后告诉BIOS关机。
- `platform`：在Linux中保存状态，然后告诉BIOS关机，并闪烁“挂起指示灯”。

`platform`实际上是正确做法，如果得到支持的话，但`shutdown`最可靠（除了在ACPI系统上）。

问：我不明白为什么你对选择性挂起的想法有这么强烈的反对意见。

答：在运行时电源管理中进行选择性挂起是可以的，但这对于suspend-to-disk毫无用处。（而且我看不出你如何能将其用于suspend-to-ram，希望你不是想这样做。）
让我们来看看你的建议：

1. 挂起除交换设备及其父设备之外的所有设备。
2. 快照。
3. 将图像写入磁盘。
4. 挂起交换设备及其父设备。
5. 关机。

哦不，这行不通。如果交换设备或其父设备使用DMA，那么数据就会被破坏。你必须做的是：

1. 挂起除交换设备及其父设备之外的所有设备。
2. 冻结交换设备及其父设备。
3. 快照。
4. 解冻交换设备及其父设备。
5. 写入。
6. 挂起交换设备及其父设备。

这意味着你仍然需要那个冻结状态，并且代码会变得更复杂。（这里还没有引入诸如系统设备等细节问题。）
Q:
似乎在SUSPEND和FREEZE之间没有任何普遍有用的行为区别。

A:
当你被要求执行FREEZE时，执行SUSPEND总是正确的，但这可能会不必要地慢。如果你希望你的驱动程序保持简单，那么这种慢速可能对你来说无关紧要。它总能在以后进行修复。
对于像磁盘这样的设备，速度确实很重要，你不想在FREEZE时进行停转。

Q:
恢复后，系统大量分页，导致非常差的交互性。

A:
尝试在恢复后运行以下命令：

    cat /proc/[0-9]*/maps | grep / | sed 's:.* /:/:' | sort -u | while read file
    do
      test -f "$file" && cat "$file" > /dev/null
    done

禁用交换分区（swapoff -a）；然后再启用交换分区（swapon -a）也可能有用。

Q:
在swsusp过程中设备发生了什么？它们似乎在系统挂起时被恢复了？

A:
是的，这是正确的。如果我们想将镜像写入磁盘，就需要恢复它们。整个序列如下：

**挂起部分**

- 运行中的系统，用户请求挂起到磁盘
- 用户进程被停止
- 挂起（PMSG_FREEZE）：设备被冻结以防止它们干扰状态快照
- 状态快照：在禁用中断的情况下复制整个使用中的内存
- 恢复（resume）：设备被唤醒以便我们可以将镜像写入交换分区
- 将镜像写入交换分区
- 挂起（PMSG_SUSPEND）：为了关闭电源而冻结设备
- 关闭电源

**恢复部分**

（实际上是非常相似的）

- 运行中的系统，用户请求挂起到磁盘
- 用户进程被停止（通常情况下没有进程，但在从initrd恢复时，情况未知）
- 从磁盘读取镜像
- 挂起（PMSG_FREEZE）：设备被冻结以防止它们干扰镜像恢复
- 镜像恢复：使用镜像重写内存
- 恢复（resume）：设备被唤醒以便系统继续运行
- 恢复所有用户进程

Q:
“加密挂起镜像”有什么作用？

A:
首先，这不是dm-crypt加密交换分区的替代品。它不能保护你的计算机在挂起期间的安全。相反，它可以在恢复后防止敏感数据泄露。
考虑以下情况：当一个应用程序正在运行并保存敏感数据在内存中时，你进行了挂起操作。应用程序本身阻止了数据被交换出去。然而，挂起必须将这些数据写入交换分区以便能够稍后恢复。如果没有加密挂起，你的敏感数据将以明文形式存储在磁盘上。这意味着恢复后，任何可以直接访问用于挂起的交换分区的应用程序都可以访问你的敏感数据。如果你在恢复后不需要交换分区，这些数据可能会永久保留在磁盘上。因此，可能会出现几周后系统被攻破，并且你以为加密并受保护的敏感数据从交换分区中被检索和窃取的情况。
为了避免这种情况，你应该使用“加密挂起镜像”。
在挂起期间，会创建一个临时密钥，并使用这个密钥来加密写入磁盘的数据。在恢复期间，当数据被重新读回到内存中时，临时密钥会被销毁，这意味着所有写入磁盘的数据变得无法访问，从而无法被窃取。唯一需要确保的是，在常规启动过程中尽早调用“mkswap”来初始化用于挂起的交换分区。这样可以确保任何由于错误挂起或失败的恢复而产生的临时密钥被从交换分区中擦除。
作为一般规则，请使用加密交换分区来保护系统关闭或挂起时的数据。另外，使用加密的挂起镜像以防止恢复后敏感数据被盗。

**问：**
我可以将系统挂起到交换文件吗？

**答：**
通常可以。但是，这需要您在内核命令行参数中使用“resume=”和“resume_offset=”，因此从交换文件恢复不能由initrd或initramfs图像发起。详细信息请参阅swsusp-and-swap-files.txt。

**问：**
swsusp支持的最大系统RAM大小是多少？

**答：**
它应该能够与高内存一起正常工作。

**问：**
swsusp（到磁盘）是否仅使用一个交换分区还是可以使用多个交换分区（将它们聚合为一个逻辑空间）？

**答：**
仅使用一个交换分区，抱歉。

**问：**
如果我的应用程序使用了大量的内存和交换空间（超过总系统RAM的一半），那么在该应用程序运行时尝试挂起到磁盘是否有用？

**答：**
不，只要您的应用程序没有调用mlock()，这应该是可行的。只需准备足够大的交换分区即可。

**问：**
哪些信息对于调试挂起到磁盘的问题是有用的？

**答：**
屏幕上的最后几条消息总是有用的。如果出现问题，通常是一些内核驱动程序造成的，所以尽量减少加载的模块数量会很有帮助。我也建议人们从控制台进行挂起操作，最好是在未运行X的情况下。通过设置init=/bin/bash启动，然后手动进行swapon和挂起序列通常能解决问题。之后尝试使用最新的原生内核版本也是个好主意。

**问：**
发行版如何提供带有模块化磁盘驱动程序（特别是SATA驱动）的swsusp支持内核？

**答：**
可以通过加载驱动程序，然后从initrd写入/sys/power/resume文件来实现。确保不要挂载任何东西，即使是只读挂载，否则会导致数据丢失。

**问：**
如何使挂起过程更详细地输出信息？

**答：**
如果您希望在挂起过程中看到非错误的内核消息，您需要将内核控制台的日志级别设置为至少4（KERN_WARNING），例如，可以这样做：

```sh
# 保存旧的日志级别
read LOGLEVEL DUMMY < /proc/sys/kernel/printk
# 设置日志级别以便我们能看到进度条
# 如果级别已经高于所需，则保持不变
if [ $LOGLEVEL -lt 5 ]; then
    echo 5 > /proc/sys/kernel/printk
fi

IMG_SZ=0
read IMG_SZ < /sys/power/image_size
echo -n disk > /sys/power/state
RET=$?
#
# 这里的逻辑是：
# 如果image_size大于0（如果没有内核支持，IMG_SZ将是零），
# 则尝试再次将image_size设为零
```
```bash
if [ $RET -ne 0 -a $IMG_SZ -ne 0 ]; then # 如果返回值和图像大小都不为0，则再次尝试使用最小图像大小
                echo 0 > /sys/power/image_size
                echo -n disk > /sys/power/state
                RET=$?
        fi

	# 恢复之前的日志级别
	echo $LOGLEVEL > /proc/sys/kernel/printk
	exit $RET
```

**问：**
如果我在一个USB设备上挂载了一个文件系统，并且我将系统挂起到磁盘，那么除非文件系统是用 "sync" 方式挂载的，否则我会丢失数据吗？

**答：**
没错……如果你断开那个设备，你可能会丢失数据。
实际上，即使使用了 "-o sync"，如果你的程序中有信息在缓冲区中还没有写入到你断开的磁盘中，或者你在设备完成保存你写入的数据之前断开，你也可能会丢失数据。
软件挂起通常会关闭USB控制器的电源，这相当于断开所有连接到系统的USB设备。
你的系统可能支持USB控制器在系统休眠时的低功耗模式，保持连接，使用真正的休眠模式如 "suspend-to-RAM" 或 "standby"。（不要写 "disk" 到 /sys/power/state 文件；而应写 "standby" 或 "mem"。）我们没有看到任何硬件可以通过软件挂起到使用这些模式，尽管理论上有些系统可能支持不会断开USB连接的 "platform" 模式。
请记住，拔掉包含已挂载文件系统的磁盘驱动器总是一个坏主意。即使当你的系统处于休眠状态时也是如此！最安全的做法是在挂起前卸载所有可移动媒体（如USB、Firewire、CompactFlash、MMC、外部SATA或甚至IDE热插拔托架）上的文件系统；然后在恢复后重新挂载它们。
有一个解决此问题的方法。更多信息，请参阅 `Documentation/driver-api/usb/persist.rst`。

**问：**
我可以使用LVM下的交换分区进行挂起到磁盘吗？

**答：**
可以，但不可以。你可以成功地挂起，但内核无法自己恢复。你需要一个能识别恢复情况的initramfs，激活包含交换卷的逻辑卷（但不触碰任何文件系统！），并最终调用：
    
    echo -n "$major:$minor" > /sys/power/resume
    
其中 $major 和 $minor 分别是交换卷的主要和次要设备号。
uswsusp 也支持LVM。详情见 http://suspend.sourceforge.net/

**问：**
我从内核2.6.15升级到了2.6.16。两个内核都是用类似的配置文件编译的。不过我发现，在2.6.16上挂起到磁盘（及恢复）比2.6.15慢得多。这可能是为什么？或者我如何加快速度？

**答：**
这是因为挂起图像的大小现在比2.6.15大（通过保存更多的数据，我们可以得到更响应的系统）。/sys/power/image_size 控制图像的大小。如果你把它设置为0（例如作为root用户执行 `echo 0 > /sys/power/image_size`），则应该恢复2.6.15的行为。如果仍然太慢，请查看 suspend.sf.net — 用户空间挂起更快，并支持LZF压缩以进一步加快速度。
