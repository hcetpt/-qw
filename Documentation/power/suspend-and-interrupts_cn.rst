系统挂起与设备中断
====================

版权所有 © 2014 Intel 公司  
作者：Rafael J. Wysocki <rafael.j.wysocki@intel.com>

挂起和恢复设备中断请求线（IRQ）
-----------------------------------

在系统挂起期间，通常会在设备挂起的“晚期”阶段之后禁用设备中断请求线（IRQ）（即，在所有设备的->prepare、->suspend 和->suspend_late 回调执行完毕后）。这是通过 suspend_device_irqs() 函数实现的。这样做的理由是，在设备挂起的“晚期”阶段之后，没有正当的理由使任何来自已挂起设备的中断触发；如果某些设备尚未正确挂起，则无论如何都应该阻止这些设备的中断。过去我们遇到过共享 IRQ 的中断处理程序的问题，即设备驱动程序在设备挂起后未准备好处理中断。在某些情况下，它们会尝试访问已挂起设备的内存地址空间，从而导致不可预测的行为。不幸的是，这样的问题非常难以调试，引入 suspend_device_irqs() 函数以及设备挂起和恢复过程中的“noirq”阶段，是唯一实用的缓解方法。

设备 IRQ 在系统恢复时重新启用，就在设备恢复的“早期”阶段之前（即，在开始执行设备的->resume_early 回调之前）。执行此操作的函数是 resume_device_irqs()。

IRQF_NO_SUSPEND 标志
------------------------

有些中断在整个系统挂起-恢复周期内合法触发，包括设备挂起和恢复过程中的“noirq”阶段以及非引导 CPU 下线和上线期间。这首先适用于定时器中断，但也适用于 IPI（Inter-Processor Interrupts）和其他一些特殊用途的中断。

IRQF_NO_SUSPEND 标志用于在请求特殊用途中断时向 IRQ 子系统指示这一点。它使得 suspend_device_irqs() 不禁用相应的 IRQ，以便允许该中断在整个挂起-恢复周期中按预期工作，但并不保证该中断会唤醒处于挂起状态的系统——对于这种情况，需要使用 enable_irq_wake()。

需要注意的是，IRQF_NO_SUSPEND 标志影响整个 IRQ 而不仅仅是一个使用者。因此，如果 IRQ 是共享的，则所有安装的中断处理程序在 suspend_device_irqs() 之后都会像往常一样执行，即使某些 IRQ 用户在 request_irq()（或等效函数）中未传递 IRQF_NO_SUSPEND 标志。因此，同时使用 IRQF_NO_SUSPEND 和 IRQF_SHARED 应该避免。

系统唤醒中断、enable_irq_wake() 和 disable_irq_wake()
----------------------------------------------------------

系统唤醒中断通常需要配置为从睡眠状态唤醒系统，特别是在它们在工作状态下用于其他目的（例如作为 I/O 中断）的情况下。
这可能涉及在平台（例如SoC）内启用一种特殊的信号处理逻辑，以便在系统休眠期间以不同的方式路由来自特定线路的信号，从而在需要时触发系统唤醒。例如，平台可能包含一个专门的中断控制器，专门用于处理系统唤醒事件。那么，如果某个中断线应该从休眠状态唤醒系统，则该中断控制器对应的输入需要被启用，以便接收来自该线路的信号。唤醒后，通常最好禁用该输入，以防止专用控制器不必要的触发中断。

IRQ子系统提供了两个辅助函数供设备驱动程序使用。具体来说，`enable_irq_wake()` 启用了平台对于给定IRQ作为系统唤醒中断线的处理逻辑，而 `disable_irq_wake()` 则关闭这一逻辑。

调用 `enable_irq_wake()` 会使 `suspend_device_irqs()` 以特殊的方式处理给定的IRQ。具体而言，IRQ保持启用状态，但在第一个中断发生时将被禁用并标记为待处理和“暂停”，以便在随后的系统恢复过程中由 `resume_device_irqs()` 重新启用。此外，PM核心会收到关于导致系统暂停中止的事件的通知（这不一定立即发生，但会在暂停线程检查待处理唤醒事件的某个时刻发生）。

这样，来自唤醒中断源的每个中断要么会导致当前正在进行的系统暂停被中止，要么在系统已经暂停的情况下将其唤醒。然而，在 `suspend_device_irqs()` 之后，不会执行系统唤醒IRQ的中断处理程序。此时只会执行设置了 `IRQF_NO_SUSPEND` 标志的IRQ，但这些IRQ不应使用 `enable_irq_wake()` 配置为系统唤醒中断。

### 中断与挂起到空闲

#### 挂起到空闲

挂起到空闲（也称为“冻结”睡眠状态）是一种相对较新的系统睡眠状态，通过使所有处理器处于空闲状态并在设备暂停的“无中断”阶段之后等待中断来实现。

当然，这意味着在该状态下，所有设置了 `IRQF_NO_SUSPEND` 标志的中断都会使CPU退出空闲状态，但不会导致IRQ子系统触发系统唤醒。

相反，系统唤醒中断会像在完全系统暂停情况下一样，触发从挂起到空闲状态的唤醒。唯一的区别是，从挂起到空闲状态的唤醒使用常规的工作状态中断传递机制，并不需要平台使用任何特殊的中断处理逻辑。

### IRQF_NO_SUSPEND 和 enable_irq_wake()

在同一个IRQ上同时使用 `enable_irq_wake()` 和 `IRQF_NO_SUSPEND` 标志的有效理由非常少，并且对于同一设备来说，这样做是不正确的。

首先，如果中断不是共享的，那么处理 `IRQF_NO_SUSPEND` 中断的规则（中断处理程序在 `suspend_device_irqs()` 之后被调用）直接与处理系统唤醒中断的规则（中断处理程序在 `suspend_device_irqs()` 之后不被调用）相冲突。
第二，enable_irq_wake() 和 IRQF_NO_SUSPEND 都是针对整个中断（IRQ）而不是单个中断处理程序的，因此将一个系统唤醒中断源和一个 IRQF_NO_SUSPEND 中断源共享同一个 IRQ 通常是没有意义的。

在极少数情况下，一个 IRQ 可以被一个唤醒设备驱动程序和一个 IRQF_NO_SUSPEND 用户共享。为了使这种情况安全，唤醒设备驱动程序必须能够区分虚假的 IRQ 和真实的唤醒事件（通过 pm_system_wakeup() 向内核核心报告后者），必须使用 enable_irq_wake() 确保该 IRQ 能够作为唤醒源工作，并且必须使用 IRQF_COND_SUSPEND 请求该 IRQ 以告诉内核核心它满足这些要求。如果这些要求没有得到满足，则使用 IRQF_COND_SUSPEND 是不正确的。
