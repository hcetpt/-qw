系统挂起与设备中断

====================================

版权所有 (C) 2014 Intel公司  
作者：Rafael J. Wysocki <rafael.j.wysocki@intel.com>

挂起和恢复设备中断请求线（IRQ）

-----------------------------------

在系统挂起过程中，通常会在设备挂起的“后期”阶段之后禁用设备中断请求线（IRQ）（即，在所有设备执行了->prepare、->suspend 和 ->suspend_late 回调之后）。这是通过 suspend_device_irqs() 函数完成的。这样做的原因是，在设备挂起的“后期”阶段之后，没有正当的理由使任何来自已挂起设备的中断被触发；如果某些设备尚未正确挂起，则无论如何最好阻止这些设备的中断。过去我们遇到过共享 IRQ 的中断处理程序在设备挂起后仍被触发的问题，而设备驱动程序并没有为此做好准备。在某些情况下，它们会尝试访问已挂起设备的内存地址空间，从而导致不可预测的行为。不幸的是，此类问题非常难以调试，因此引入 suspend_device_irqs() 函数以及设备挂起和恢复过程中的“无中断”阶段成为了缓解这些问题的唯一实用方法。在系统恢复期间，设备 IRQ 在设备恢复的“早期”阶段之前重新启用（即，在开始执行设备的 ->resume_early 回调之前）。这个操作是由 resume_device_irqs() 函数完成的。

IRQF_NO_SUSPEND 标志
------------------------

有些中断可以在整个系统挂起-恢复周期内合法地触发，包括设备挂起和恢复的“无中断”阶段，以及非启动 CPU 下线和上线的时间段。这首先适用于计时器中断，但也适用于 IPI（中断请求）和其他一些特殊用途的中断。IRQF_NO_SUSPEND 标志用于在请求特殊用途中断时向 IRQ 子系统指示这一点。它使得 suspend_device_irqs() 保持相应的 IRQ 处于启用状态，以便允许该中断在挂起-恢复周期中按预期工作，但并不保证该中断能够唤醒处于挂起状态的系统——对于这种情况，需要使用 enable_irq_wake()。需要注意的是，IRQF_NO_SUSPEND 标志影响整个 IRQ 而不仅仅是其中的一个用户。因此，如果 IRQ 是共享的，则在 suspend_device_irqs() 执行后，为该 IRQ 安装的所有中断处理程序都会像往常一样被执行，即使某些 IRQ 用户在调用 request_irq()（或等效函数）时并未传递 IRQF_NO_SUSPEND 标志。出于这个原因，应避免同时使用 IRQF_NO_SUSPEND 和 IRQF_SHARED。

系统唤醒中断、enable_irq_wake() 和 disable_irq_wake()
------------------------------------------------------------------

系统唤醒中断通常需要配置为从睡眠状态唤醒系统，特别是当它们在工作状态下用于其他目的（例如作为 I/O 中断）时。
这段英文描述了在系统挂起（suspend）过程中对中断（IRQs, Interrupt Request Lines）的特殊处理逻辑，尤其是与唤醒相关的中断。以下是该段落的中文翻译：

这可能涉及到在平台内部（例如片上系统SoC）开启一种特殊的信号处理逻辑，以便在系统休眠期间以不同的方式路由来自特定线路的信号，从而在需要时触发系统唤醒。例如，平台可能包含一个专门的中断控制器，专门用于处理系统唤醒事件。那么，如果某个中断线路需要从睡眠状态唤醒系统，则需要使能该中断控制器的相应输入端口来接收来自该线路的信号。唤醒后，通常最好禁用该输入端口，以防止专用控制器不必要地触发中断。

中断子系统提供了两个辅助函数供设备驱动程序使用这些目的。具体来说，`enable_irq_wake()` 开启平台对给定IRQ作为系统唤醒中断线的处理逻辑，而 `disable_irq_wake()` 则关闭该逻辑。
调用 `enable_irq_wake()` 将导致 `suspend_device_irqs()` 特殊处理给定的IRQ。具体来说，中断保持启用状态，但在首次中断时将被禁用、标记为待处理并“挂起”，以便在随后的系统恢复过程中由 `resume_device_irqs()` 重新启用。同时，PM核心会被告知关于导致正在进行的系统挂起中止的事件（这不一定立即发生，但在挂起线程寻找待处理唤醒事件的某个时刻会发生）。

这样，来自唤醒中断源的每一个中断要么会导致当前进行中的系统挂起中止，要么在系统已挂起时唤醒系统。然而，在 `suspend_device_irqs()` 后，对于系统唤醒IRQ不会执行中断处理程序。此时只对设置了 `IRQF_NO_SUSPEND` 标志的IRQ执行中断处理程序，但这些IRQ不应该通过 `enable_irq_wake()` 配置为系统唤醒。

### 中断和挂起到空闲

挂起到空闲（也称为“冻结”睡眠状态）是一种相对较新的系统睡眠状态，其工作原理是在所有处理器空闲之后等待中断，紧接着是设备挂起过程中的“无中断”阶段。

当然，这意味着设置有 `IRQF_NO_SUSPEND` 标志的所有中断都会在该状态下将CPU带出空闲状态，但它们不会导致中断子系统触发系统唤醒。
相反，系统唤醒中断将以类似于完全系统挂起的方式触发从挂起到空闲状态的唤醒。唯一的区别是，从挂起到空闲状态的唤醒是使用常规的工作状态中断传递机制进行的，并不需要平台使用任何特殊的中断处理逻辑使其生效。

### `IRQF_NO_SUSPEND` 和 `enable_irq_wake()`

对于同一个IRQ同时使用 `enable_irq_wake()` 和 `IRQF_NO_SUSPEND` 标志的情况很少见，且绝不应该对同一设备使用两者。
首先，如果IRQ不是共享的，处理 `IRQF_NO_SUSPEND` 中断的规则（中断处理程序在 `suspend_device_irqs()` 之后被调用）直接与处理系统唤醒中断的规则（中断处理程序在 `suspend_device_irqs()` 之后不被调用）相冲突。
其次，无论是`enable_irq_wake()`还是`IRQF_NO_SUSPEND`都应用于整个中断请求(IRQ)，而不是单个中断处理程序。因此，通常情况下，在系统唤醒中断源和`IRQF_NO_SUSPEND`中断源之间共享一个IRQ是没有意义的。

在极少数情况下，一个IRQ可以在一个唤醒设备驱动程序和一个`IRQF_NO_SUSPEND`用户之间共享。为了使这种共享安全，唤醒设备驱动程序必须能够区分虚假的IRQ与真实的唤醒事件（通过`pm_system_wakeup()`向内核核心报告后者），必须使用`enable_irq_wake()`来确保该IRQ可以作为唤醒源工作，并且必须使用`IRQF_COND_SUSPEND`请求IRQ以告诉内核核心它满足这些要求。如果这些要求没有得到满足，则使用`IRQF_COND_SUSPEND`是不正确的。
