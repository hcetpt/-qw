系统挂起与设备中断

版权 (C) 2014 英特尔公司
作者：Rafael J. Wysocki <rafael.j.wysocki@intel.com>

挂起与恢复设备中断请求线（IRQ）

通常，在系统挂起的“后期”阶段后，会禁用设备中断请求线（IRQ）（即在所有设备的 ->prepare、->suspend 和 ->suspend_late 回调执行完毕之后）。这是通过 suspend_device_irqs() 完成的。
这样做的理由是，在设备挂起的“后期”阶段之后，没有正当的理由任何来自已挂起设备的中断应该触发；如果有些设备尚未正确挂起，无论如何阻止它们的中断更好。在过去，我们遇到过共享 IRQ 的中断处理程序的问题，设备驱动程序在设备被挂起后未准备好处理中断触发的情况。在某些情况下，它们会尝试访问例如已挂起设备的内存地址空间，导致不可预测的行为。不幸的是，这样的问题非常难以调试，引入 suspend_device_irqs() 以及设备挂起和恢复的“noirq”阶段，是唯一实用的方法来缓解这些问题。
设备 IRQ 在系统恢复时重新启用，在设备恢复的“早期”阶段之前（即在开始执行 ->resume_early 回调之前）。执行此操作的函数是 resume_device_irqs()。

IRQF_NO_SUSPEND 标志

有些中断在整个系统挂起-恢复周期内合法触发，包括设备挂起和恢复的“noirq”阶段以及非启动 CPU 被离线和重新上线的时间。这首先适用于定时器中断，但也适用于 IPI 和一些其他特殊用途的中断。
IRQF_NO_SUSPEND 标志用于在请求特殊用途中断时向 IRQ 子系统指示这一点。它使 suspend_device_irqs() 保持相应的 IRQ 启用状态，以允许中断在挂起-恢复周期中按预期工作，但并不保证中断将从挂起状态唤醒系统——对于这种情况，需要使用 enable_irq_wake()。
需要注意的是，IRQF_NO_SUSPEND 标志影响整个 IRQ 而不仅仅是其中一个用户。因此，如果 IRQ 是共享的，即使某些 IRQ 用户在 request_irq()（或等效函数）中未传递 IRQF_NO_SUSPEND 标志，所有为该 IRQ 安装的中断处理程序在 suspend_device_irqs() 之后仍会像往常一样执行。出于这个原因，应避免同时使用 IRQF_NO_SUSPEND 和 IRQF_SHARED。

系统唤醒中断、enable_irq_wake() 和 disable_irq_wake()

系统唤醒中断通常需要配置以从睡眠状态唤醒系统，特别是在它们在工作状态下用于其他目的（例如作为 I/O 中断）的情况下。
这可能涉及在平台（如片上系统SoC）内启动特殊的信号处理逻辑，以便在系统休眠期间，来自特定线路的信号能以不同方式路由，从而在需要时触发系统唤醒。例如，平台可能包含一个专门的中断控制器，专门用于处理系统唤醒事件。那么，如果某个中断线路应该从休眠状态唤醒系统，相应的中断控制器输入就需要被启用，以便接收来自该线路的信号。唤醒后，通常最好禁用该输入，以防止专用控制器不必要的触发中断。

中断子系统为此提供了两个辅助函数供设备驱动程序使用。具体来说，enable_irq_wake() 启动平台对给定IRQ作为系统唤醒中断线路的处理逻辑，而disable_irq_wake() 则关闭该逻辑。

调用enable_irq_wake() 会导致suspend_device_irqs() 特殊处理给定的IRQ。即，IRQ保持启用状态，但在第一次中断时将被禁用、标记为待处理并“挂起”，以便在后续系统恢复过程中由resume_device_irqs()重新启用。同时，PM核心会收到关于该事件的通知，这可能导致正在进行的系统暂停被中止（这不一定要立即发生，但会在暂停线程寻找待处理唤醒事件的某一点上发生）。

这样，来自唤醒中断源的每个中断要么导致当前正在进行的系统暂停被中止，要么在已暂停的情况下唤醒系统。然而，在suspend_device_irqs()之后，对于系统唤醒IRQ不会执行中断处理器。此时只执行IRQF_NO_SUSPEND IRQ的中断处理器，但是这些IRQ不应使用enable_irq_wake()配置为系统唤醒。

**中断与空闲挂起**

空闲挂起（也称为“冻结”睡眠状态）是一种相对较新的系统睡眠状态，其工作原理是在设备暂停的“无中断”阶段后使所有处理器处于空闲状态并等待中断。

当然，这意味着在该状态下，所有设置了IRQF_NO_SUSPEND标志的中断都会使CPU从空闲状态退出，但它们不会导致中断子系统触发系统唤醒。

相反，系统唤醒中断将以类似于完全系统暂停情况的方式触发从空闲挂起到唤醒。唯一的区别是，从空闲挂起唤醒使用常规的工作状态中断传递机制进行信号发送，并不需要平台采用任何特殊中断处理逻辑使其生效。

**IRQF_NO_SUSPEND和enable_irq_wake()**

在同一IRQ上同时使用enable_irq_wake()和IRQF_NO_SUSPEND标志的有效理由非常少，而且对于同一设备来说，这样做永远是无效的。

首先，如果IRQ未共享，处理IRQF_NO_SUSPEND中断的规则（在suspend_device_irqs()之后调用中断处理器）直接与处理系统唤醒中断的规则（在suspend_device_irqs()之后不调用中断处理器）相冲突。
其次，enable_irq_wake() 和 IRQF_NO_SUSPEND 都是应用于整个中断请求(IRQ)的，而不是针对单个中断处理程序。因此，通常情况下，在系统唤醒中断源和 IRQF_NO_SUSPEND 中断源之间共享一个 IRQ 并没有实际意义。

在极少数情况下，一个 IRQ 可以被唤醒设备驱动和 IRQF_NO_SUSPEND 用户共享。为了确保这种共享的安全性，唤醒设备驱动必须能够区分虚假的 IRQ 与真实的唤醒事件（通过 pm_system_wakeup() 向内核核心报告后者），必须使用 enable_irq_wake() 来确保该 IRQ 能够作为唤醒源工作，并且必须使用 IRQF_COND_SUSPEND 请求 IRQ，以此告知内核核心它满足这些需求。如果这些需求未得到满足，则使用 IRQF_COND_SUSPEND 是不正确的。

简而言之，这段文字强调了在某些特定条件下，中断请求(IRQ)可以在唤醒设备驱动和需要 IRQF_NO_SUSPEND 的用户之间共享，但这种共享需遵循一系列规则以确保系统的稳定性和安全性。如果不能满足这些规则，那么使用 IRQF_COND_SUSPEND 将被认为是无效或不安全的。
