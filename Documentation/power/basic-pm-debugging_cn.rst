调试休眠和挂起

(C) 2007 Rafael J. Wysocki <rjw@sisk.pl>，GPL

1. 测试休眠（又称磁盘挂起或STD）
==================================

要检查休眠是否正常工作，可以尝试在“重启”模式下进行休眠：

```
# echo reboot > /sys/power/disk
# echo disk > /sys/power/state
```

系统应创建一个休眠镜像，重启，恢复，并返回到你开始转换时的命令提示符。如果发生这种情况，休眠很可能正常工作。不过，为了确保可靠性，你仍需要连续重复该测试几次。[这是必要的，因为有些问题仅在第二次尝试挂起和恢复系统时才会出现。] 此外，在“重启”和“关机”模式下休眠会导致电源管理核心跳过一些与平台相关的回调，这些回调在ACPI系统上可能是使休眠工作所必需的。因此，如果你的机器在“重启”模式下无法休眠或恢复，你应该尝试“平台”模式：

```
# echo platform > /sys/power/disk
# echo disk > /sys/power/state
```

这是默认且推荐的休眠模式。不幸的是，“平台”休眠模式在某些具有故障BIOS的系统上不起作用。在这种情况下，“关机”模式的休眠可能有效：

```
# echo shutdown > /sys/power/disk
# echo disk > /sys/power/state
```

（这类似于“重启”模式，但需要你按电源按钮才能使系统恢复）
如果“平台”和“关机”休眠模式都无法工作，则需要确定出错的原因。
a) 测试休眠模式
------------------

要找出休眠在你的系统上失败的原因，可以使用内核编译时设置CONFIG_PM_DEBUG时可用的特殊测试功能。这样，可以通过文件`/sys/power/pm_test`使休眠核心以测试模式运行。有五种测试模式可供选择：

freezer
- 测试进程冻结

devices
- 测试进程冻结和设备挂起

platform
- 测试进程冻结、设备挂起和平台全局控制方法\[1\]_

processors
- 测试进程冻结、设备挂起、平台全局控制方法\[1\]_和非启动CPU的禁用

core
- 测试进程冻结、设备挂起、平台全局控制方法\[1\]_、非启动CPU的禁用以及平台/系统设备的挂起

\[1\]

    平台全局控制方法仅在ACPI系统上可用，并且仅在休眠模式设置为“平台”时进行测试

要使用其中一种模式，需要将相应的字符串写入`/sys/power/pm_test`（例如，写入“devices”来测试进程冻结和设备挂起），然后发出标准的休眠命令。例如，要在“平台”休眠模式下使用“devices”测试模式，你应该执行以下操作：

```
# echo devices > /sys/power/pm_test
# echo platform > /sys/power/disk
# echo disk > /sys/power/state
```

然后，内核将尝试冻结进程，挂起设备，等待几秒钟（默认为5秒，但可以通过模块参数`suspend.pm_test_delay`进行配置），恢复设备并解冻进程。如果向`/sys/power/pm_test`写入“platform”，则在挂起设备之后，内核还将调用用于准备平台固件进行休眠的全局控制方法（例如ACPI全局控制方法）。接下来，它将等待可配置的秒数，并调用用于取消休眠的平台（例如ACPI）全局方法等。向`/sys/power/pm_test`写入“none”会使内核切换到正常的休眠/挂起操作。此外，当打开以供读取时，`/sys/power/pm_test`包含所有可用测试（包括表示正常功能的“none”）的空格分隔列表，当前测试级别由方括号指示。

通常，如你所见，每个测试级别都比前一个更“侵入性”，而“core”级别在不创建休眠镜像的情况下尽可能深入地测试硬件和驱动程序。显然，如果“devices”测试失败，“platform”测试也会失败，依此类推。因此，一般而言，你应该从“freezer”开始，通过“devices”、“platform”和“processors”一直到“core”（在每个级别上重复测试几次以确保避免任何随机因素）。

如果“freezer”测试失败，则有一个任务无法被冻结（在这种情况下，通常可以通过分析失败测试后获得的dmesg输出来识别该任务）。此级别的失败通常意味着任务冻结子系统存在问题，应该报告此问题。

如果“devices”测试失败，则可能是某个驱动程序无法挂起或恢复其设备（在这种情况下，系统可能会在测试后挂起或变得不稳定，请注意这一点）。要找到这个驱动程序，可以根据以下规则进行二分查找：

- 如果测试失败，卸载一半当前加载的驱动程序并重复测试（这可能涉及重新启动系统，因此请始终记录测试前已加载的驱动程序），
- 如果测试成功，加载一半最近卸载的驱动程序并重复测试

一旦找到失败的驱动程序（可能不止一个），每次休眠前必须将其卸载。在这种情况下，请务必报告驱动程序的问题。

也有可能在卸载所有模块后，“devices”测试仍然失败。在这种情况下，你可以在内核配置中查找可以作为模块编译的驱动程序（并再次测试这些驱动程序作为模块编译）。你还可以尝试使用一些特殊的内核命令行选项，如“noapic”、“noacpi”甚至“acpi=off”。
如果“platform”测试失败，说明系统（例如ACPI）固件处理存在问题。在这种情况下，“platform”模式的休眠可能无法正常工作。您可以尝试使用“shutdown”模式，但这只是个很不完善的替代方案。
如果“processors”测试失败，表明禁用/启用非启动CPU的功能不起作用（当然，这仅在SMP系统中可能是问题），并且应报告该问题。您也可以通过/sys/devices/system/cpu/cpu*/online 的 sysfs 属性尝试关闭和开启非启动CPU，看看是否有效。
如果“core”测试失败，意味着系统/平台设备的挂起失败（这些设备在一个中断关闭的CPU上被挂起），问题很可能与硬件有关且较为严重，因此应当报告。
“platform”、“processors”或“core”测试中的任何一个失败都可能导致您的系统挂起或变得不稳定，请务必注意。这种失败通常表明存在一个严重的问题，并且很可能与硬件相关，但请无论如何都要报告。

b) 测试最小配置
----------------------

如果所有休眠测试模式均能正常工作，您可以使用 "init=/bin/bash" 命令行参数启动系统，并尝试以“reboot”、“shutdown”和“platform”模式进行休眠。如果不起作用，可能是一个静态编译到内核中的驱动程序存在问题，您可以尝试将更多驱动程序编译为模块，以便单独测试它们。否则，问题可能出在一个模块化驱动程序上，您可以通过加载一半常用模块并进行二分查找来找到它：
- 如果有n个模块已加载而挂起和恢复尝试失败，则卸载一半的模块并再次尝试（这可能需要重新启动系统），
- 如果有n个模块已加载而挂起和恢复尝试成功，则再加载一半的模块并再次尝试
如果您找到了引起问题的模块，每次休眠前必须将其卸载，并请报告此问题。

c) 使用 "test_resume" 休眠选项
---------------------------------------------

/sys/power/disk 通常告诉内核创建休眠镜像后应执行的操作。其中一个可用选项是 "test_resume"，这会立即触发刚刚创建的镜像的恢复操作，而不涉及任何平台固件。具体来说，在执行以下命令后：

	# echo test_resume > /sys/power/disk
	# echo disk > /sys/power/state

将创建一个休眠镜像，并立即触发其恢复，完全不涉及平台固件。这个测试可用于检查从休眠恢复失败是否与平台固件的不良交互有关。也就是说，如果上述方法每次都可行，而实际休眠后的恢复不可行或不可靠，那么平台固件可能是导致失败的原因。
对于支持使用不同内核恢复休眠镜像（即用于从存储读取镜像并将其加载到内存中的内核与镜像中包含的内核不同）或支持内核地址空间随机化的架构和平台，还可以用来检查恢复失败是否与恢复内核和镜像内核之间的差异有关。

d) 高级调试
------------------------

如果即使在最小配置下休眠也无法在您的系统上工作，并且将更多驱动程序编译为模块不切实际或某些模块无法卸载，您可以使用更高级的调试技术来找到问题。首先，如果您的机器中有串行端口，可以使用 'no_console_suspend' 参数启动内核，并尝试使用串行控制台记录内核消息。这可能会提供一些关于挂起（恢复）失败原因的信息。或者，可以使用 FireWire 端口配合 firescope（http://v3.sk/~lkundrak/firescope/）进行调试。在x86平台上，还可以使用 PM_TRACE 机制，详细信息见文档 power/s2ram.rst。
### 2. 测试挂起到内存 (STR)

为了验证 STR 是否正常工作，通常更方便使用来自 http://suspend.sf.net 的 s2ram 工具，并参考文档 http://en.opensuse.org/SDB:Suspend_to_RAM (S2RAM_LINK)。具体来说，在将 "freezer"、"devices"、"platform"、"processors" 或 "core" 写入 /sys/power/pm_test（如果内核编译时启用了 CONFIG_PM_DEBUG 选项，则该文件存在）后，挂起代码将以与给定字符串对应的测试模式运行。STR 的测试模式与休眠的定义方式相同，请参阅第 1 节获取更多关于这些模式的信息。特别是，“core” 测试允许您测试除实际调用平台固件以将系统置于睡眠状态之外的所有内容。通过 /sys/power/pm_test 进行测试可以帮助您识别未能正确挂起或恢复设备的驱动程序。每次进行 STR 转换之前应卸载这些驱动程序。

接下来，您可以按照 S2RAM_LINK 中的说明来测试系统，但如果系统无法“开箱即用”，则可能需要使用 "init=/bin/bash" 启动系统，并在最小配置下测试 s2ram。在这种情况下，您可以按照第 1 节中描述的类似程序来查找失败的驱动程序。如果您发现了一些失败的驱动程序，您需要在每次 STR 转换前（即在运行 s2ram 之前）卸载它们，并请报告这些问题。

有一个 debugfs 条目显示了挂起到内存的统计信息。以下是一个示例输出：

```
# mount -t debugfs none /sys/kernel/debug
# cat /sys/kernel/debug/suspend_stats
success: 20
fail: 5
failed_freeze: 0
failed_prepare: 0
failed_suspend: 5
failed_suspend_noirq: 0
failed_resume: 0
failed_resume_noirq: 0
failures:
  last_failed_dev: alarm
             adc
  last_failed_errno: -16
             -16
  last_failed_step: suspend
             suspend
```

字段 `success` 表示成功挂起到内存的次数，而字段 `fail` 表示失败次数。其他字段表示挂起到内存过程中不同步骤的失败次数。`suspend_stats` 只列出最近两次失败的设备、错误编号和失败的步骤。
