调试休眠和挂起

	(C) 2007 Rafael J. Wysocki <rjw@sisk.pl>，GPL

1. 测试休眠（又称为磁盘挂起或STD）
===================================================

要检查休眠是否正常工作，可以尝试在“重启”模式下进行休眠：

	# echo reboot > /sys/power/disk
	# echo disk > /sys/power/state

系统应创建一个休眠映像，重启，恢复，并返回到你开始转换的命令提示符。如果发生这种情况，休眠很可能正确工作。不过，为了确信，你至少需要连续重复此测试几次。[这是必要的，因为某些问题仅在第二次尝试暂停和恢复系统时才会出现。]此外，在“重启”和“关机”模式下休眠会导致电源管理核心跳过一些与平台相关的回调，这在ACPI系统上可能是使休眠工作所必需的。因此，如果你的机器在“重启”模式下无法休眠或恢复，你应该尝试“平台”模式：

	# echo platform > /sys/power/disk
	# echo disk > /sys/power/state

这是默认和推荐的休眠模式。不幸的是，“平台”休眠模式在一些BIOS有问题的系统上不起作用。在这种情况下，“关机”休眠模式可能会起作用：

	# echo shutdown > /sys/power/disk
	# echo disk > /sys/power/state

（它类似于“重启”模式，但需要你按下电源按钮才能使系统恢复）
如果“平台”和“关机”休眠模式都无法工作，你需要确定出错的地方。
a) 测试休眠模式
----------------------------

要找出为什么休眠在你的系统上失败，你可以使用在内核编译时设置CONFIG_PM_DEBUG时可用的特殊测试设施。然后，存在文件/sys/power/pm_test，可用于使休眠核心以测试模式运行。有5种可用的测试模式：

freezer
	- 测试进程冻结

devices
	- 测试进程冻结和设备挂起

platform
	- 测试进程冻结、设备挂起和平台全局控制方法[1]_

processors
	- 测试进程冻结、设备挂起、平台全局控制方法[1]_和非启动CPU的禁用

core
	- 测试进程冻结、设备挂起、平台全局控制方法[1]_、非启动CPU的禁用以及平台/系统设备的挂起

.. [1]

    平台全局控制方法仅在ACPI系统上可用，并且仅在休眠模式设置为“平台”时进行测试

要使用其中之一，需要将相应的字符串写入/sys/power/pm_test（例如，“devices”用于测试进程冻结和挂起设备），并发出标准的休眠命令。例如，要使用“devices”测试模式以及“平台”休眠模式，你应该执行以下操作：

	# echo devices > /sys/power/pm_test
	# echo platform > /sys/power/disk
	# echo disk > /sys/power/state

然后，内核将尝试冻结进程，挂起设备，等待几秒钟（默认为5秒，但可通过suspend.pm_test_delay模块参数进行配置），恢复设备并解冻进程。如果将“platform”写入/sys/power/pm_test，则在挂起设备后，内核将另外调用全局控制方法（例如ACPI全局控制方法）用于准备平台固件进行休眠。接下来，它将等待可配置数量的秒数，并调用平台（例如ACPI）全局方法取消休眠等。
将“none”写入/sys/power/pm_test将导致内核切换到正常的休眠/挂起操作。此外，当打开以供读取时，/sys/power/pm_test包含所有可用测试（包括代表正常功能的“none”）的空格分隔列表，其中当前测试级别由方括号表示。
通常，如你所见，每个测试级别都比前一个更“侵入性”，并且“core”级别的测试尽可能深入地测试硬件和驱动程序，而不创建休眠映像。显然，如果“devices”测试失败，“platform”测试也会失败，依此类推。因此，作为一般规则，你应该从“freezer”开始尝试测试模式，通过“devices”，“platform”和“processors”直到“core”（在每个级别重复测试几次，以确保避免任何随机因素）
如果“freezer”测试失败，有一个任务无法被冻结（在这种情况下，通常可以通过分析失败测试后获得的dmesg输出来识别罪魁祸首任务）。此级别的失败通常意味着任务冻结子系统存在问题，应该报告此问题。
如果“devices”测试失败，很可能有一个驱动程序无法挂起或恢复其设备（在这种情况下，系统可能在测试后挂起或变得不稳定，所以请考虑这一点）。要找到这个驱动程序，你可以根据以下规则进行二进制搜索：

- 如果测试失败，卸载当前加载的一半驱动程序并重复（这可能涉及重新启动系统，所以总是记下测试前已加载的驱动程序），
- 如果测试成功，加载最近卸载的一半驱动程序并重复
一旦你找到了失败的驱动程序（可能不止一个），你必须每次在休眠前将其卸载。在这种情况下，请务必报告驱动程序的问题
还有一种可能性是，在你卸载所有模块后，“devices”测试仍然失败。在这种情况下，你可能想要查看你的内核配置中可以编译为模块的驱动程序（并再次使用这些驱动程序编译为模块进行测试）。你也可以尝试使用一些特殊的内核命令行选项，如“noapic”，“noacpi”甚至“acpi=off”。
如果“platform”测试失败，说明你的系统在处理平台（例如ACPI）固件时存在问题。在这种情况下，“platform”模式的休眠可能无法正常工作。你可以尝试“shutdown”模式，但这只是一种简陋的变通方法。
如果“processors”测试失败，意味着非启动CPU的禁用/启用功能不起作用（当然，这仅在SMP系统上可能是问题），并且应报告此问题。在这种情况下，你也可以尝试使用/sys/devices/system/cpu/cpu*/online sysfs属性来关闭和开启非启动CPU，看看这种方法是否可行。
如果“core”测试失败，意味着系统/平台设备的暂停失败（这些设备在一个中断关闭的CPU上被暂停），问题很可能与硬件有关且较为严重，因此应报告该问题。
任何“platform”，“processors”或“core”测试的失败都可能导致你的系统挂起或变得不稳定，请务必注意。此类失败通常表明存在严重的硬件相关问题，但请无论如何进行报告。

b) 测试最小配置
-----------------
如果所有休眠测试模式都能正常工作，你可以使用"init=/bin/bash"命令行参数启动系统，并尝试以“reboot”，“shutdown”和“platform”模式进行休眠。如果这样仍然不行，可能是因为静态编译到内核中的驱动程序存在问题，你可以尝试将更多驱动程序编译为模块，以便单独测试它们。否则，问题可能出在某个模块化驱动程序上，你可以通过加载一半常用的模块并根据以下算法进行二分查找：
- 如果有n个模块加载，并且尝试暂停和恢复失败，卸载n/2个模块并再次尝试（这可能涉及重新启动系统），
- 如果有n个模块加载，并且尝试暂停和恢复成功，再加载n/2个模块并再次尝试
再次强调，如果你找到导致问题的模块，在每次休眠前必须将其卸载，并请报告与此模块相关的问题。

c) 使用“test_resume”休眠选项
---------------------------------
/sys/power/disk通常告诉内核在创建休眠映像后要执行的操作。其中一种可用的选项是“test_resume”，它会立即使用刚创建的映像进行恢复，而无需以任何形式涉及平台固件。
具体操作如下：

	# echo test_resume > /sys/power/disk
	# echo disk > /sys/power/state

这将创建一个休眠映像，并立即触发从该映像恢复，完全不涉及平台固件。
这个测试可以用来检查从休眠恢复失败是否与平台固件的不良交互有关。也就是说，如果上述操作每次都有效，但实际从休眠状态恢复不工作或不可靠，则平台固件可能是导致失败的原因。
对于支持使用不同内核恢复休眠映像（即用于从存储读取映像并将其加载到内存中的内核与包含在映像中的内核不同）或支持内核地址空间随机化的架构和平台，也可以使用此选项来检查恢复失败是否可能与恢复和映像内核之间的差异有关。

d) 高级调试
---------------------
如果即使在最小配置下休眠在你的系统上也无法正常工作，或者编译更多驱动程序作为模块不切实际，或者某些模块无法卸载，你可以使用更高级的调试技术来查找问题。首先，如果你的机器中有串行端口，你可以使用'no_console_suspend'参数启动内核，并尝试使用串行控制台记录内核消息。这可能会提供一些关于暂停（恢复）失败原因的信息。或者，有可能使用FireWire端口与firescope（http://v3.sk/~lkundrak/firescope/）进行调试。在x86平台上，还可以使用PM_TRACE机制，具体文档参见Documentation/power/s2ram.rst。
### 测试挂起到内存（STR）
=================================

为了验证 STR 功能是否正常工作，通常使用来自 http://suspend.sf.net 的 s2ram 工具更为方便，该工具的文档可参考 http://en.opensuse.org/SDB:Suspend_to_RAM (S2RAM_LINK)。
具体来说，在将 "freezer"、"devices"、"platform"、"processors" 或 "core" 写入 /sys/power/pm_test（如果内核编译时设置了 CONFIG_PM_DEBUG，则此文件可用）之后，挂起代码将以对应字符串定义的测试模式运行。STR 的测试模式与休眠模式定义相同，请参阅第 1 节以获取更多关于它们的信息。特别是，“core”测试允许您测试除了实际调用平台固件使系统进入睡眠状态之外的所有内容。
通过 /sys/power/pm_test 进行测试可以帮助您识别未能正确挂起或恢复其设备的驱动程序。这些驱动程序应该在每次 STR 转换前被卸载。
接下来，您可以按照 S2RAM_LINK 中的说明测试系统，但如果系统无法“开箱即用”，您可能需要使用 "init=/bin/bash" 启动，并在最小配置下测试 s2ram。在这种情况下，您可以遵循类似于第 1 节中描述的流程来查找失败的驱动程序。如果您发现了某些失败的驱动程序，那么您需要在每次 STR 转换前（即运行 s2ram 之前）卸载它们，并请报告这些问题。

存在一个 debugfs 条目可以显示挂起到内存的统计信息。以下是一个输出示例：

```
# mount -t debugfs none /sys/kernel/debug
# cat /sys/kernel/debug/suspend_stats
success: 20
fail: 5
failed_freeze: 0
failed_prepare: 0
failed_suspend: 5
failed_suspend_noirq: 0
failed_resume: 0
failed_resume_noirq: 0
failures:
  last_failed_dev: alarm
                adc
  last_failed_errno: -16
                -16
  last_failed_step: suspend
                suspend
```

字段 `success` 表示挂起到内存成功的次数，而字段 `fail` 则表示失败的次数。其他字段则表示挂起到内存不同步骤中的失败次数。`suspend_stats` 列出了最后两次失败的设备、错误码以及失败的步骤。
