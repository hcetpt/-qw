调试休眠和挂起到硬盘
==============================

	(C) 2007 Rafael J. Wysocki <rjw@sisk.pl>，GPL

1. 测试休眠（也称为挂起到硬盘或STD）
==================================================

要检查休眠是否工作正常，您可以尝试以“重启”模式进行休眠：

	# echo reboot > /sys/power/disk
	# echo disk > /sys/power/state

系统应创建一个休眠映像、重启，然后恢复，并返回到您开始转换时的命令提示符。如果这种情况发生，则休眠很可能正确工作。尽管如此，为了确保无误，您仍需连续重复此测试几次。（这是必要的，因为某些问题仅在第二次尝试挂起和恢复系统时才会出现。）此外，在“重启”和“关机”模式下进行休眠会导致电源管理核心跳过一些与平台相关的回调，这些回调在ACPI系统上可能是使休眠工作所必需的。因此，如果您的机器在“重启”模式下无法休眠或恢复，您应该尝试“平台”模式：

	# echo platform > /sys/power/disk
	# echo disk > /sys/power/state

这是默认且推荐的休眠模式。不幸的是，“平台”休眠模式在某些BIOS有问题的系统上可能不起作用。在这种情况下，“关机”休眠模式可能会起作用：

	# echo shutdown > /sys/power/disk
	# echo disk > /sys/power/state

（这类似于“重启”模式，但它需要您按下电源按钮来使系统恢复。）
如果“平台”或“关机”休眠模式都无法工作，您将需要确定出了什么问题。
a) 测试休眠模式
----------------------

要找出为什么休眠在您的系统上失败，您可以使用一种特殊的测试设施，该设施在内核编译时通过设置CONFIG_PM_DEBUG可用。然后，可以使用文件/sys/power/pm_test使休眠核心以测试模式运行。有5种可用的测试模式：

freezer
	- 测试进程冻结

devices
	- 测试进程冻结和设备挂起

platform
	- 测试进程冻结、设备挂起以及平台全局控制方法\[1\]_

processors
	- 测试进程冻结、设备挂起、平台全局控制方法\[1\]_以及非启动CPU的禁用

core
	- 测试进程冻结、设备挂起、平台全局控制方法\[1\]_、非启动CPU的禁用以及平台/系统设备的挂起

\[1\]

    平台全局控制方法仅在ACPI系统上可用，并且仅在休眠模式设置为“平台”时进行测试。

要使用其中任何一种，必须将相应的字符串写入/sys/power/pm_test（例如，“devices”用于测试进程冻结和挂起设备），并发出标准的休眠命令。例如，要使用“devices”测试模式与“平台”休眠模式一起，您应执行以下操作：

	# echo devices > /sys/power/pm_test
	# echo platform > /sys/power/disk
	# echo disk > /sys/power/state

然后，内核将尝试冻结进程、挂起设备、等待几秒（默认为5秒，但可以通过suspend.pm_test_delay模块参数进行配置）、恢复设备并解冻进程。如果向/sys/power/pm_test写入"platform"，则在挂起设备后，内核将另外调用用于准备平台固件进行休眠的全局控制方法（例如，ACPI全局控制方法）。接下来，它将等待可配置数量的秒数，并调用平台（例如，ACPI）全局方法以取消休眠等。
向/sys/power/pm_test写入“none”将导致内核切换到正常的休眠/挂起操作。此外，当打开以供读取时，/sys/power/pm_test包含所有可用测试（包括代表正常功能的“none”）的空格分隔列表，其中当前测试级别由方括号指示。
通常，如您所见，每个测试级别都比前一个更“侵入性”，而“core”级别尽可能深入地测试硬件和驱动程序，而不创建休眠映像。显然，如果“devices”测试失败，则“platform”测试也将失败，依此类推。因此，一般的经验法则是从“freezer”开始尝试测试模式，经过“devices”、“platform”和“processors”直到“core”（在每个级别重复测试几次以确保避免任何随机因素）。
如果“freezer”测试失败，说明有一个任务无法被冻结（在这种情况下，通常可以通过分析失败测试后获得的dmesg输出来识别出罪魁祸首任务）。在这个级别上的失败通常意味着任务冻结子系统存在问题，这应该上报。
如果“devices”测试失败，很可能是有一个驱动程序无法挂起或恢复其设备（在后一种情况下，系统可能会在测试后挂起或变得不稳定，所以请考虑这一点）。要找到这个驱动程序，您可以根据以下规则进行二分搜索：

- 如果测试失败，卸载当前加载的一半驱动程序并重复（这可能涉及重启系统，因此始终记录测试前已加载了哪些驱动程序），
- 如果测试成功，加载最近卸载的一半驱动程序并重复
一旦找到失败的驱动程序（可能不止一个），您必须在每次休眠之前将其卸载。在这种情况下，请确保报告驱动程序的问题。
还有一种可能是，在您卸载所有模块之后，“devices”测试仍然失败。在这种情况下，您可能想要查看您的内核配置中可以作为模块编译的驱动程序（并再次测试这些作为模块编译的驱动程序）。您也可以尝试使用一些特殊的内核命令行选项，如“noapic”、“noacpi”甚至“acpi=off”。
如果“platform”测试失败，说明你的系统中处理平台（例如ACPI）固件存在问题。这种情况下，“platform”模式的休眠可能无法正常工作。你可以尝试使用“shutdown”模式，但这只是一种较为简陋的解决办法。
如果“processors”测试失败，则意味着非启动CPU的启用/禁用功能不起作用（当然，这仅在SMP系统上可能是问题），并且应当报告此问题。在这种情况下，你也可以尝试通过/sys/devices/system/cpu/cpu*/online 的 sysfs 属性来关闭和打开非启动CPU，看看是否有效。
如果“core”测试失败，意味着系统/平台设备的挂起操作失败（这些设备在一个关闭中断的CPU上被挂起），那么问题很可能与硬件相关且较为严重，因此应当上报。
“platform”、“processors”或“core”中的任何一项测试失败都可能导致你的系统挂起或变得不稳定，请务必注意。此类失败通常表明存在严重的问题，很可能与硬件有关，但请无论如何都要报告该问题。
b) 测试最小配置
------------------

如果所有休眠测试模式都能正常工作，你可以使用 "init=/bin/bash" 命令行参数引导系统，并尝试以 “reboot”、“shutdown” 和 “platform” 模式进行休眠。如果不成功，可能是因为内核中静态编译的驱动程序存在问题，你可以尝试将更多驱动程序编译为模块，以便单独测试。否则，可能是某个模块驱动程序的问题，你可以通过加载一半常用模块并进行二分查找的方式来找到问题所在：
- 如果已加载 n 个模块而挂起恢复尝试失败，则卸载 n/2 个模块后再次尝试（这可能需要重新引导系统），
- 如果已加载 n 个模块而挂起恢复尝试成功，则再加载 n/2 个模块后再次尝试
如果你找到了导致问题的模块，每次休眠之前必须将其卸载，并请务必报告该问题。
c) 使用 "test_resume" 休眠选项
-----------------------------------

/sys/power/disk 通常告诉内核在创建休眠镜像之后要执行的操作。其中一个可用的选项是 "test_resume"，它会立即使用刚刚创建的镜像进行恢复，而不会涉及平台固件的任何参与。具体步骤如下：

	# echo test_resume > /sys/power/disk
	# echo disk > /sys/power/state

这样将会创建一个休眠镜像并立即触发从该镜像的恢复过程。
这个测试可以用来检查从休眠状态恢复失败是否与平台固件之间的不良交互有关。也就是说，如果上述操作每次都成功，但是实际从休眠状态恢复不成功或不可靠，那么平台固件可能是导致失败的原因。
对于支持使用不同内核恢复休眠镜像（即用于从存储读取镜像并加载到内存中的内核与镜像中包含的内核不同）或者支持内核地址空间随机化的架构和平台，也可以利用该选项检查恢复失败是否与两个内核之间的差异有关。
d) 高级调试
------------------

如果你的系统即使在最小配置下也无法实现休眠，或者编译更多驱动作为模块不切实际或某些模块无法卸载，你可以采用更高级的调试技术来定位问题。首先，如果你的计算机有串口，你可以使用 'no_console_suspend' 参数启动内核，并尝试使用串行控制台记录内核消息。这可能会为你提供一些关于挂起（恢复）失败原因的信息。另外，也可以尝试使用 FireWire 接口配合 firescope（http://v3.sk/~lkundrak/firescope/）进行调试。对于 x86 架构，还可以使用文档中描述的 PM_TRACE 机制（位于 Documentation/power/s2ram.rst）。
### 测试挂起到内存（STR）
=================================

为了验证 STR 功能是否正常工作，通常使用来自 http://suspend.sf.net 的 s2ram 工具更为方便，该工具的文档可参考 http://en.opensuse.org/SDB:Suspend_to_RAM (S2RAM_LINK)。
具体来说，在将 "freezer"、"devices"、"platform"、"processors" 或 "core" 写入 /sys/power/pm_test（如果内核编译时设置了 CONFIG_PM_DEBUG，则此文件可用）之后，挂起代码将以对应字符串定义的测试模式运行。STR 的测试模式与休眠模式定义相同，请参阅第 1 节以获取更多关于它们的信息。特别是，“core”测试允许您测试除了实际调用平台固件使系统进入睡眠状态之外的所有内容。
通过 /sys/power/pm_test 进行测试可以帮助您识别未能正确挂起或恢复其设备的驱动程序。这些驱动程序应该在每次 STR 转换前被卸载。
接下来，您可以按照 S2RAM_LINK 中的说明测试系统，但如果系统无法“开箱即用”，您可能需要使用 "init=/bin/bash" 启动，并在最小配置下测试 s2ram。在这种情况下，您可以遵循类似于第 1 节中描述的流程来查找失败的驱动程序。如果您发现了某些失败的驱动程序，那么您需要在每次 STR 转换前（即运行 s2ram 之前）卸载它们，并请报告这些问题。

存在一个 debugfs 条目可以显示挂起到内存的统计信息。以下是一个输出示例：

```
# mount -t debugfs none /sys/kernel/debug
# cat /sys/kernel/debug/suspend_stats
success: 20
fail: 5
failed_freeze: 0
failed_prepare: 0
failed_suspend: 5
failed_suspend_noirq: 0
failed_resume: 0
failed_resume_noirq: 0
failures:
  last_failed_dev: alarm
                adc
  last_failed_errno: -16
                -16
  last_failed_step: suspend
                suspend
```

字段 `success` 表示挂起到内存成功的次数，而字段 `fail` 表示失败的次数。其他字段表示挂起到内存过程中不同步骤的失败次数。`suspend_stats` 列出了最后两次失败的设备、错误码以及失败的步骤。
