监管器消费者驱动接口
=====================

本文本描述了消费者设备驱动程序的监管器接口。
有关本文中使用的术语的描述，请参阅overview.txt。
1. 消费者监管器访问（静态与动态驱动）
======================================

一个消费者驱动可以通过调用以下函数来获取其供电监管器:: 

    regulator = regulator_get(dev, "Vcc");

消费者需要传递其结构体device指针和电源供应ID。核心通过查询特定于机器的查找表找到正确的监管器。
如果查找成功，此调用将返回指向为该消费者供电的struct regulator的指针。
为了释放监管器，消费者驱动应该调用:: 

    regulator_put(regulator);

一个消费者可能由多个监管器供电，例如：具有模拟和数字供电的编解码器消费者:: 

    digital = regulator_get(dev, "Vcc");  /* 数字内核 */
    analog = regulator_get(dev, "Avdd");  /* 模拟 */

监管器访问函数regulator_get() 和 regulator_put() 通常会在您的设备驱动的probe()和remove()函数中分别被调用。
2. 监管器输出启用与禁用（静态与动态驱动）
==================================================

消费者可以通过调用以下函数来启用其电源供应:: 

    int regulator_enable(regulator);

**注：**
  在调用regulator_enable()之前，电源可能已经被启用。
这可能会发生当消费者共享监管器或监管器已被引导加载程序或内核板初始化代码先前启用。
消费者可以通过调用以下函数确定监管器是否已启用:: 

    int regulator_is_enabled(regulator);

当监管器被启用时，此函数会返回大于零的值。
当不再需要时，消费者可以调用以下函数来禁用其电源供应:: 

    int regulator_disable(regulator);

**注：**
  如果它与其他消费者共享，则这可能不会禁用电源。只有当启用的引用计数为零时，监管器才会被禁用。
最后，在紧急情况下，监管器可以被强制禁用:: 

    int regulator_force_disable(regulator);

**注：**
  这将立即且强制地关闭监管器输出。所有消费者都将被断电。
3. 电压调节器控制与状态（动态驱动程序）
=======================================================

一些消费者驱动程序需要能够动态改变其供电电压以匹配系统的运行状态。例如，CPU频率调整驱动程序可以根据频率调整电压来节省电力，SD卡驱动程序可能需要选择正确的卡片电压等。
消费者可以通过调用以下函数来控制其供电电压：

```c
int regulator_set_voltage(调节器, 最小微伏, 最大微伏);
```

其中最小微伏和最大微伏是可接受的最小和最大电压值（单位：微伏）。
**注意**：此函数可以在调节器启用或禁用时被调用。如果在启用状态下调用，则电压会立即改变；否则，电压配置会发生变化，并且当调节器下次启用时实际设置电压。
可以使用以下函数获取调节器配置的输出电压：

```c
int regulator_get_voltage(调节器);
```

**注意**：
  `get_voltage()` 函数无论调节器是否启用都会返回配置的输出电压，并不应该用于判断调节器的输出状态。然而，这可以与 `is_enabled()` 函数结合使用来确定调节器的实际输出电压。

4. 电流限制调节器控制与状态（动态驱动程序）
=============================================================

一些消费者驱动程序需要能够动态改变其供电电流限制以匹配系统的运行状态。例如，LCD背光驱动程序可以改变电流限制以调节背光亮度，USB驱动程序可能希望在供电时将限制设置为500毫安。
消费者可以通过调用以下函数来控制其供电电流限制：

```c
int regulator_set_current_limit(调节器, 最小微安, 最大微安);
```

其中最小微安和最大微安是可接受的最小和最大电流限制值（单位：微安）。
**注意**：
  此函数可以在调节器启用或禁用时被调用。如果在启用状态下调用，则电流限制会立即改变；否则，电流限制配置会发生变化，并且当调节器下次启用时实际设置电流限制。
可以使用以下函数获取调节器的电流限制：

```c
int regulator_get_current_limit(调节器);
```

**注意**：
  `get_current_limit()` 函数无论调节器是否启用都会返回电流限制值，并不应该用于判断调节器的电流负载。

5. 调节器运行模式控制与状态（动态驱动程序）
==============================================================

一些消费者可以通过改变其供电调节器的运行模式来进一步节省系统电力，使其在消费者的运行状态发生变化时更加高效。例如，当消费者驱动程序处于空闲状态并且随后消耗较少电流时。

调节器的运行模式可以通过间接或直接方式改变
间接运行模式控制
消费者驱动程序可以请求更改其供电调节器的工作模式，方法是调用：

```c
int regulator_set_load(struct regulator *regulator, int load_uA);
```

这将导致核心根据所有消费者的负载重新计算调节器上的总负载，并在必要和允许的情况下更改工作模式以最佳匹配当前的工作负载。
`load_uA` 的值可以从消费者的规格书中确定。例如，大多数规格书中有表格显示在某些情况下消耗的最大电流。

大多数消费者将使用间接工作模式控制，因为他们不知道调节器或者调节器是否与其他消费者共享。

### 直接工作模式控制

定制或紧密耦合的驱动程序可能希望直接根据它们的操作点来控制调节器的工作模式。这可以通过调用以下函数实现：

```c
int regulator_set_mode(struct regulator *regulator, unsigned int mode);
unsigned int regulator_get_mode(struct regulator *regulator);
```

直接模式仅被那些知道调节器并且不与其他消费者共享调节器的消费者使用。

### 6. 调节器事件

调节器可以向消费者通知外部事件。在调节器压力或故障条件下，消费者可能会接收到这些事件。

消费者可以通过调用以下函数注册对调节器事件的兴趣：

```c
int regulator_register_notifier(struct regulator *regulator,
					struct notifier_block *nb);
```

消费者可以通过调用以下函数取消注册对调节器事件的兴趣：

```c
int regulator_unregister_notifier(struct regulator *regulator,
					  struct notifier_block *nb);
```

调节器使用内核通知框架来向感兴趣的消费者发送事件。

### 7. 调节器直接寄存器访问

某些类型的电源管理硬件或固件设计为需要对调节器进行低级别的硬件访问，而不需要内核的参与。此类设备的例子包括：

- 具有电压控制振荡器和控制逻辑的时钟源，通过I2C改变供电电压以达到期望的输出时钟速率
- 在过温情况下可以发出任意I2C事务以执行系统关机的热管理固件

为了设置这样的设备/固件，需要配置各种参数，如调节器的I2C地址、各种调节器寄存器的地址等。调节器框架提供了以下帮助函数来查询这些细节。

对于特定总线的细节（如I2C地址或传输速率）由`regmap`框架处理。要获取调节器的`regmap`（如果支持的话），使用：

```c
struct regmap *regulator_get_regmap(struct regulator *regulator);
```

要获取调节器电压选择寄存器的硬件寄存器偏移量和掩码，使用：

```c
int regulator_get_hardware_vsel_register(struct regulator *regulator,
						 unsigned *vsel_reg,
						 unsigned *vsel_mask);
```

要将调节器框架中的电压选择代码（用于`regulator_list_voltage`）转换为可以直接写入电压选择寄存器的硬件特定电压选择器，使用：

```c
int regulator_list_hardware_vsel(struct regulator *regulator,
					 unsigned selector);
```

为了启用/禁用调节器的硬件访问，消费者必须使用`regulator_get_exclusive()`，因为它不能在有多于一个消费者的情况下工作。要启用/禁用调节器，使用：

```c
int regulator_hardware_enable(struct regulator *regulator, bool enable);
```
