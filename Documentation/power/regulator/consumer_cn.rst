===================================
调节器消费者驱动接口
===================================

本文描述了消费者设备驱动程序的调节器接口。请参阅overview.txt以了解本文中使用的术语。
1. 消费者调节器访问（静态和动态驱动）
=======================================================

消费者驱动可以通过调用以下函数来获取其供电调节器：

```c
regulator = regulator_get(dev, "Vcc");
```

消费者需要传递其结构体device指针和电源供应ID。核心通过查询特定于机器的查找表来找到正确的调节器。如果查找成功，此调用将返回一个指向为该消费者供电的struct regulator的指针。

为了释放调节器，消费者驱动应调用：

```c
regulator_put(regulator);
```

消费者可以由多个调节器供电，例如带有模拟和数字供电的编解码器消费者：

```c
digital = regulator_get(dev, "Vcc");  /* 数字核心 */
analog = regulator_get(dev, "Avdd");  /* 模拟 */
```

通常情况下，调节器访问函数`regulator_get()`和`regulator_put()`将在您的设备驱动程序的`probe()`和`remove()`函数中分别被调用。
2. 调节器输出启用与禁用（静态和动态驱动）
===============================================================

消费者可以通过调用以下函数来启用其电源供应：

```c
int regulator_enable(regulator);
```

**注意：**
在调用`regulator_enable()`之前，电源可能已经启用。这可能会发生在消费者共享调节器或调节器已被引导加载程序或内核板初始化代码预先启用的情况下。

消费者可以通过调用以下函数来确定调节器是否已启用：

```c
int regulator_is_enabled(regulator);
```

当调节器已启用时，此函数将返回大于零的值。

消费者可以在不再需要供电时通过调用以下函数来禁用其电源供应：

```c
int regulator_disable(regulator);
```

**注意：**
如果电源与其他消费者共享，则此操作可能不会禁用电源。只有当启用引用计数为零时，调节器才会被禁用。

最后，在紧急情况下，可以强制禁用调节器：

```c
int regulator_force_disable(regulator);
```

**注意：**
这会立即且强制性地关闭调节器输出。所有消费者都将断电。
3. 电压调节器控制与状态（动态驱动程序）
============================================

某些消费者驱动程序需要能够动态更改其供电电压以匹配系统的运行状态。例如，CPU频率驱动程序可以随频率调整电压以节省电力，SD卡驱动程序可能需要选择正确的卡片电压等。
消费者可以通过调用以下函数来控制其供电电压：

```c
int regulator_set_voltage(调节器, 最小微伏, 最大微伏);
```

其中最小微伏和最大微伏是可接受的最小和最大电压值（单位为微伏）。
**注意：**此函数可以在调节器启用或禁用时调用。如果在启用时调用，则电压会立即改变；否则电压配置会更改，并在下次启用调节器时物理设置电压。
可以通过调用以下函数来获取调节器配置的电压输出：

```c
int regulator_get_voltage(调节器);
```

**注意：**
  `get_voltage()`会在调节器启用或禁用时返回配置的输出电压，并不应用于确定调节器的输出状态。但是，可以结合使用`is_enabled()`来确定调节器的物理输出电压。

4. 电压调节器电流限制控制与状态（动态驱动程序）
===============================================

某些消费者驱动程序需要能够动态更改其供电电流限制以匹配系统的运行状态。例如，LCD背光驱动程序可以更改电流限制以改变背光亮度，USB驱动程序可能希望在供电时将限制设置为500毫安。
消费者可以通过调用以下函数来控制其供电电流限制：

```c
int regulator_set_current_limit(调节器, 最小微安, 最大微安);
```

其中最小微安和最大微安是可接受的最小和最大电流限制（单位为微安）。
**注意：**
  此函数可以在调节器启用或禁用时调用。如果在启用时调用，则电流限制会立即改变；否则电流限制配置会更改，并在下次启用调节器时物理设置电流限制。
可以通过调用以下函数来获取调节器的电流限制：

```c
int regulator_get_current_limit(调节器);
```

**注意：**
  `get_current_limit()`会在调节器启用或禁用时返回电流限制，并不应用于确定调节器的电流负载。

5. 电压调节器运行模式控制与状态（动态驱动程序）
===============================================

某些消费者可以通过更改其供电调节器的运行模式，在消费者的操作状态发生变化时进一步节省系统电力。例如，当消费者驱动程序处于空闲状态并且随后消耗较少电流时。
调节器运行模式可以间接或直接更改。
间接运行模式控制
消费者驱动程序可以请求更改其供电调节器的操作模式，方法如下：

```c
int regulator_set_load(struct regulator *regulator, int load_uA);
```

这将导致核心重新计算调节器上的总负载（基于所有消费者），并在必要且允许的情况下更改操作模式以最佳匹配当前的操作负载。`load_uA` 的值可以从消费者的规格书中确定，例如，大多数规格书中有表格显示在特定情况下消耗的最大电流。

大多数消费者会使用间接操作模式控制，因为他们不知道调节器或调节器是否与其他消费者共享。

直接操作模式控制
-------------------

定制或紧密耦合的驱动程序可能希望根据其工作点直接控制调节器的操作模式。这可以通过以下调用来实现：

```c
int regulator_set_mode(struct regulator *regulator, unsigned int mode);
unsigned int regulator_get_mode(struct regulator *regulator);
```

直接模式仅由了解调节器并且不与其他消费者共享调节器的消费者使用。

6. 调节器事件
==============

调节器可以通知消费者外部事件。在调节器压力或故障条件下，消费者可能会接收到事件。

消费者可以通过以下调用注册对调节器事件的兴趣：

```c
int regulator_register_notifier(struct regulator *regulator, struct notifier_block *nb);
```

消费者可以通过以下调用取消注册：

```c
int regulator_unregister_notifier(struct regulator *regulator, struct notifier_block *nb);
```

调节器使用内核通知框架向感兴趣的消费者发送事件。

7. 调节器直接寄存器访问
========================

某些类型的电源管理硬件或固件设计为需要对调节器进行低级硬件访问，并且不需要内核参与。这类设备的例子包括：

- 带有电压控制振荡器和通过I2C改变供电电压来实现所需输出时钟速率的控制逻辑的时钟源。
- 在过温条件下发出任意I2C事务以执行系统关机的热管理固件。

为了设置此类设备/固件，需要配置各种参数，如调节器的I2C地址、各种调节器寄存器地址等。调节器框架提供了以下帮助函数来查询这些详细信息。

总线特定的细节，如I2C地址或传输速率由regmap框架处理。要获取调节器的regmap（如果支持），请使用：

```c
struct regmap *regulator_get_regmap(struct regulator *regulator);
```

要获取调节器电压选择寄存器的硬件寄存器偏移和掩码，请使用：

```c
int regulator_get_hardware_vsel_register(struct regulator *regulator, unsigned *vsel_reg, unsigned *vsel_mask);
```

要将调节器框架中的电压选择代码（用于`regulator_list_voltage`）转换为可以直接写入电压选择寄存器的硬件特定电压选择器，请使用：

```c
int regulator_list_hardware_vsel(struct regulator *regulator, unsigned selector);
```

要访问调节器启用/禁用的硬件，消费者必须使用`regulator_get_exclusive()`，因为它不能在有多个消费者的情况下工作。要启用/禁用调节器，请使用：

```c
int regulator_hardware_enable(struct regulator *regulator, bool enable);
```
