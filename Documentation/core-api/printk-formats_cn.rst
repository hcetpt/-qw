如何正确使用`printk`格式化参数
=========================================

.. _printk-specifiers:

:作者: Randy Dunlap <rdunlap@infradead.org>
:作者: Andrew Murray <amurray@mpc-data.co.uk>

整数类型
=============

::

    如果变量的类型为,          使用`printk`格式化参数:
    ------------------------------------------------------------
        signed char            %d 或 %hhx
        unsigned char          %u 或 %x
        char                   %u 或 %x
        short int              %d 或 %hx
        unsigned short int     %u 或 %x
        int                    %d 或 %x
        unsigned int           %u 或 %x
        long                   %ld 或 %lx
        unsigned long          %lu 或 %lx
        long long              %lld 或 %llx
        unsigned long long     %llu 或 %llx
        size_t                 %zu 或 %zx
        ssize_t                %zd 或 %zx
        s8                     %d 或 %hhx
        u8                     %u 或 %x
        s16                    %d 或 %hx
        u16                    %u 或 %x
        s32                    %d 或 %x
        u32                    %u 或 %x
        s64                    %lld 或 %llx
        u64                    %llu 或 %llx


如果`<type>`的大小依赖于架构（例如，cycles_t, tcflag_t）或其大小依赖于配置选项（例如，blk_status_t），则应使用其最大可能类型的格式化参数，并明确地进行类型转换。
示例::

    printk("test: latency: %llu cycles\n", (unsigned long long)time);

提醒：sizeof()返回类型为size_t
内核的printf不支持%n。浮点数格式（%e, %f, %g, %a）同样也不被识别，这是显而易见的原因。使用任何不受支持的格式化参数或长度限定符会导致发出警告并从vsnprintf()中提前返回。
指针类型
=============

原始指针值可以使用%p打印，它会在打印之前对地址进行哈希处理。内核还支持扩展的格式化参数来打印不同类型的指针。

一些扩展的格式化参数会打印给定地址上的数据，而不是地址本身。在这种情况下，可能会打印以下错误消息代替无法访问的信息：

- (null) 数据位于纯NULL地址上
- (efault) 数据位于无效地址上
- (einval) 有效地址上有无效数据

纯指针
--------------

::

    %p      abcdef12 或 00000000abcdef12

没有扩展的%p（即未修饰的%p）打印出来的指针经过哈希处理以防止泄露有关内核内存布局的信息。这具有额外的好处，即提供了一个唯一的标识符。在64位机器上，前32位会被清零。内核将在收集到足够的熵之前打印`(ptrval)`。

当可能时，请使用专门的修饰符如%pS或%pB（如下所述）以避免需要提供必须事后解释的未哈希地址。如果不可能，并且打印地址的目的是为了提供更多调试信息，则使用%p并在调试期间使用`no_hash_pointers`参数启动内核，这将使所有%p地址保持不变。如果你确实总是想要未修改的地址，请参阅下面的%px。

如果（并且仅当）你是在procfs或sysfs等虚拟文件的内容中打印地址（使用如seq_printf()而非printk()），并且该内容将由用户空间进程读取，则应使用下面描述的%pK修饰符而不是%p或%px。

错误指针
--------------

::

    %pe     -ENOSPC

用于打印错误指针（即IS_ERR()为true的指针）作为符号错误名称。对于没有已知符号名称的错误值，将以十进制形式打印；而传递给%pe的非ERR_PTR则会被当作普通的%p处理。

符号/函数指针
-------------------------

::

    %pS     versatile_init+0x0/0x110
    %ps     versatile_init
    %pSR    versatile_init+0x9/0x110
            （使用__builtin_extract_return_addr()转换）
    %pB     prev_fn_of_versatile_init+0x88/0x88

`S`和`s`格式化参数用于以符号格式打印指针。它们分别产生带有（S）或不带（s）偏移量的符号名称。如果禁用了KALLSYMS，则打印符号地址。

`B`格式化参数产生带有偏移量的符号名称，并应用于打印堆栈回溯。此格式化参数考虑到了编译器优化的影响，这种优化在使用尾调用并标记为noreturn GCC属性时可能发生。
如果指针位于模块内，模块名以及可选的构建ID会在符号名之后打印，并且在指定符的末尾附加一个额外的 "b"，如下所示：

	%pS	versatile_init+0x0/0x110 [模块名]
	%pSb	versatile_init+0x0/0x110 [模块名 ed5019fdf5e53be37cb1ba7899292d7e143b259e]
	%pSRb	versatile_init+0x9/0x110 [模块名 ed5019fdf5e53be37cb1ba7899292d7e143b259e]
		（使用__builtin_extract_return_addr()转换）
	%pBb	prev_fn_of_versatile_init+0x88/0x88 [模块名 ed5019fdf5e53be37cb1ba7899292d7e143b259e]

来自BPF / 追踪的已探测指针
------------------------------

	%pks	内核字符串
	%pus	用户字符串

"k" 和 "u" 指定符用于打印先前从内核内存 (k) 或用户内存 (u) 中探测到的内容。随后的 "s" 指定符导致打印出字符串。对于直接在常规vsnprintf()中使用，(k)和(u)注释会被忽略；然而，在BPF的bpf_trace_printk()之外使用时，它会读取所指向的内存而不会出现故障。

内核指针
---------

	%pK	01234567 或 0123456789abcdef

用于打印应隐藏于非特权用户的内核指针。%pK的行为取决于kptr_restrict sysctl - 更多详细信息请参阅Documentation/admin-guide/sysctl/kernel.rst
此修改器仅当生成由用户空间从例如procfs或sysfs读取的文件内容时使用，而不是用于dmesg。关于如何在printk()中管理指针哈希，请参考上面关于%p的部分进行讨论。

未修改的地址
-------------

	%px	01234567 或 0123456789abcdef

用于当你确实需要打印地址时打印指针。在使用%px之前，请考虑是否会泄露有关内核内存布局的敏感信息。%px在功能上等同于%lx（或%lu）。%px更受推荐，因为它更容易通过grep查找。如果将来我们需要修改内核处理打印指针的方式，我们将能够更好地找到调用点。
在使用%px之前，请考虑使用%p是否已经足够，并在调试会话中启用`no_hash_pointers`内核参数（参见上面关于%p的描述）。%px的一个有效场景可能是在恐慌前立即打印信息，这可以防止任何敏感信息被利用，而且使用%px就没有必要复现恐慌与no_hash_pointers。

指针差异
---------

	%td	2560
	%tx	a00

用于打印指针差异时，使用%t修饰符为ptrdiff_t类型。
示例：

	printk("test: 指针之间的差异: %td\n", ptr2 - ptr1);

结构资源
---------

	%pr	[mem 0x60000000-0x6fffffff 标志 0x2200] 或
		[mem 0x0000000060000000-0x000000006fffffff 标志 0x2200]
	%pR	[mem 0x60000000-0x6fffffff 预设] 或
		[mem 0x0000000060000000-0x000000006fffffff 预设]

用于打印结构资源。"R" 和 "r" 指定符导致打印出带有 (R) 或不带有 (r) 解码标志成员的资源。

传递引用
物理地址类型 phys_addr_t
----------------------------------

	%pa[p]	0x01234567 或 0x0123456789abcdef

用于打印phys_addr_t类型（及其派生类型，如resource_size_t），这些类型可能会根据构建选项而变化，而不论CPU数据路径的宽度如何。
通过引用传递
DMA 地址类型 dma_addr_t
----------------------------

::

	%pad	0x01234567 或 0x0123456789abcdef

用于打印 dma_addr_t 类型，该类型可能根据构建选项而变化，与 CPU 数据路径的宽度无关。
通过引用传递
原始缓冲区作为转义字符串
-------------------------------

::

	%*pE[achnops]

用于将原始缓冲区打印为转义字符串。对于以下缓冲区::

		1b 62 20 5c 43 07 22 90 0d 5d

有几个示例展示了如何执行转换（不包括周围引号）::

		%*pE		"\eb \C\a"\220\r]"
		%*pEhp		"\x1bb \C\x07"\x90\x0d]"
		%*pEa		"\e\142\040\\\103\a\042\220\r\135"

转换规则根据可选标志组合应用（参见 :c:func:`string_escape_mem` 内核文档以获取详细信息）:

	- a - ESCAPE_ANY
	- c - ESCAPE_SPECIAL
	- h - ESCAPE_HEX
	- n - ESCAPE_NULL
	- o - ESCAPE_OCTAL
	- p - ESCAPE_NP
	- s - ESCAPE_SPACE

默认情况下使用 ESCAPE_ANY_NP
ESCAPE_ANY_NP 在许多情况下是合理的选择，特别是打印 SSIDs 的时候
如果省略字段宽度，则只转义一个字节
原始缓冲区作为十六进制字符串
--------------------------

::

	%*ph	00 01 02  ...  3f
	%*phC	00:01:02: ... :3f
	%*phD	00-01-02- ... -3f
	%*phN	000102 ... 3f

用于将小缓冲区（最长 64 字节）打印为带特定分隔符的十六进制字符串。对于更大的缓冲区，请考虑使用 :c:func:`print_hex_dump`
MAC/FDDI 地址
------------------

::

	%pM	00:01:02:03:04:05
	%pMR	05:04:03:02:01:00
	%pMF	00-01-02-03-04-05
	%pm	000102030405
	%pmR	050403020100

用于以十六进制表示法打印 6 字节的 MAC/FDDI 地址。``M`` 和 ``m`` 标识符将生成带有 (M) 或没有 (m) 字节分隔符的打印地址。默认的字节分隔符是冒号 (:)
对于 FDDI 地址，可以在 ``M`` 标识符后使用 ``F`` 标识符来代替默认分隔符使用破折号 (-) 分隔符
对于蓝牙地址，应当在 ``M`` 标识符后使用 ``R`` 标识符来使用适用于蓝牙地址视觉解释的小端序的逆序字节顺序
通过引用传递
IPv4 地址
----------

::

	%pI4	1.2.3.4
	%pi4	001.002.003.004
	%p[Ii]4[hnbl]

用于打印点分十进制格式的 IPv4 地址。`I4` 和 `i4` 标记分别产生带有（i4）或不带（I4）前导零的打印地址。
额外的 `h`、`n`、`b` 和 `l` 标记被用来指定主机，网络，大端或小端顺序的地址。如果没有提供任何标记，则默认使用网络/大端顺序。
通过引用传递
IPv6 地址
----------

::

	%pI6	0001:0002:0003:0004:0005:0006:0007:0008
	%pi6	00010002000300040005000600070008
	%pI6c	1:2:3:4:5:6:7:8

用于打印网络顺序的 16 位十六进制格式的 IPv6 地址。`I6` 和 `i6` 标记分别产生带有（I6）或不带（i6）冒号分隔符的打印地址。始终使用前导零。
额外的 `c` 标记可以与 `I` 标记一起使用来打印压缩的 IPv6 地址，如 https://tools.ietf.org/html/rfc5952 所描述。

通过引用传递
IPv4/IPv6 地址（通用，包含端口、流信息、范围）
---------------------------------------------------

::

	%pIS	1.2.3.4		或 0001:0002:0003:0004:0005:0006:0007:0008
	%piS	001.002.003.004	或 00010002000300040005000600070008
	%pISc	1.2.3.4		或 1:2:3:4:5:6:7:8
	%pISpc	1.2.3.4:12345	或 [1:2:3:4:5:6:7:8]:12345
	%p[Ii]S[pfschnbl]

用于打印 IP 地址，无需区分是 AF_INET 还是 AF_INET6 类型。可以通过 `IS` 或 `iS` 指定的有效 struct sockaddr 的指针传递给这个格式标记。
额外的 `p`、`f` 和 `s` 标记被用来指定端口（IPv4, IPv6）、流信息（IPv6）和范围（IPv6）。端口前有 `:` 前缀，流信息前有 `/`，范围前有 `%`，每个都跟随着实际的值。
在 IPv6 地址的情况下，如果提供了额外的 `c` 标记，则使用 https://tools.ietf.org/html/rfc5952 中描述的压缩 IPv6 地址。在存在额外的 `p`、`f` 或 `s` 标记时，IPv6 地址周围会加上 `[` 和 `]`，如 https://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-07 所建议的那样。

对于 IPv4 地址，额外的 `h`、`n`、`b` 和 `l` 标记也可以被使用，并且在 IPv6 地址中会被忽略。
通过引用传递
进一步的例子：

``%pISfc``      1.2.3.4       或者 [1:2:3:4:5:6:7:8]/123456789
``%pISsc``      1.2.3.4       或者 [1:2:3:4:5:6:7:8]%1234567890
``%pISpfc``     1.2.3.4:12345 或者 [1:2:3:4:5:6:7:8]:12345/123456789

UUID/GUID 地址
--------------

``%pUb``        00010203-0405-0607-0809-0a0b0c0d0e0f
``%pUB``        00010203-0405-0607-0809-0A0B0C0D0E0F
``%pUl``        03020100-0504-0706-0809-0a0b0c0e0e0f
``%pUL``        03020100-0504-0706-0809-0A0B0C0E0E0F

用于打印 16 字节的 UUID/GUID 地址。额外的 ``l``, ``L``, ``b`` 和 ``B`` 标记被用来指定小端字节序，以小写（``l``）或大写（``L``）十六进制表示 - 以及大端字节序，以小写（``b``）或大写（``B``）十六进制表示。
如果没有使用额外的标记，则默认使用大端字节序和小写的十六进制表示。
通过引用传递

目录项名称
----------

``%pd{,2,3,4}``
``%pD{,2,3,4}``

用于打印目录项名称；如果我们与 `d_move` 函数发生竞争，名称可能是旧的和新的混合，但它不会引发错误。``%pd`` 目录项是更安全的等价形式，我们以前使用的 ``%s dentry->d_name.name``，``%pd<n>`` 打印最后 ``n`` 个组件。``%pD`` 对于 `struct file` 结构做同样的事情。
通过引用传递

块设备名称
-----------

``%pg``         sda, sda1 或 loop0p1

用于打印块设备指针的名称
`struct va_format` 结构体
----------------------

``%pV``

用于打印 `struct va_format` 结构体。这些结构包含一个格式字符串和 `va_list` 如下所示：

```c
struct va_format {
    const char *fmt;
    va_list *va;
};
```

实现了一种“递归的 vsnprintf”
在没有某种机制来验证格式字符串和 `va_list` 参数正确性的情况下，请勿使用此功能。
通过引用传递

设备树节点
------------

``%pOF[fnpPcCF]``

用于打印设备树节点结构。默认行为相当于 ``%pOFf``。
- `f` - 设备节点的完整名称
    - `n` - 设备节点的名称
    - `p` - 设备节点的句柄（phandle）
    - `P` - 设备节点路径规范（名称+@单元）
    - `F` - 设备节点标志
    - `c` - 主兼容字符串
    - `C` - 完整兼容字符串

使用多个参数时的分隔符是 `:`

示例：

    `%pOF` `/foo/bar@0` - 节点完整名称
    `%pOFf` `/foo/bar@0` - 同上
    `%pOFfp` `/foo/bar@0:10` - 节点完整名称 + 句柄
    `%pOFfcF` `/foo/bar@0:foo,device:--P-` - 节点完整名称 + 主兼容字符串 + 节点标志
        D - 动态
        d - 已分离
        P - 已填充
        B - 已填充总线

通过引用传递
Fwnode 句柄
--------------

```
%pfw[fP]
```

用于打印 fwnode 句柄的信息。默认情况下，打印包括路径的完整节点名称。修饰符的功能与上面的 `%pOF` 相同：
- `f` - 包括路径的节点完整名称
    - `P` - 包含地址（如果有）的节点名称

ACPI 示例：

    `%pfwf` `_SB.PCI0.CIO2.port@1.endpoint@0` - 完整节点名称
    `%pfwP` `endpoint@0` - 节点名称

OF 示例：

    `%pfwf` `/ocp@68000000/i2c@48072000/camera@10/port/endpoint` - 完整名称
    `%pfwP` `endpoint` - 节点名称

时间和日期
-------------

```
%pt[RT] YYYY-mm-ddTHH:MM:SS
%pt[RT]s YYYY-mm-dd HH:MM:SS
%pt[RT]d YYYY-mm-dd
%pt[RT]t HH:MM:SS
%pt[RT][dt][r][s]
```

以人类可读的格式打印由以下表示的时间和日期：

    R - `struct rtc_time` 结构体
    T - `time64_t` 类型

默认情况下，年份将增加 1900，月份将增加 1。
使用 `%pt[RT]r`（原始）来抑制这种行为。
`%pt[RT]s`（空格）会用 `' '`（空格）替代 ISO 8601 分隔符 `'T'`（大写 T），位于日期和时间之间。如果省略了日期或时间，则该选项不会产生任何效果。

通过引用传递
`struct clk`
--------------

```
%pC pll1
%pCn pll1
```

用于打印 `struct clk` 结构体。`%pC` 和 `%pCn` 打印时钟名称（通用时钟框架）或一个唯一的 32 位 ID（传统时钟框架）

通过引用传递
位图及其衍生类如 cpumask 和 nodemask
-------------------------------------------------------

```
%*pb 0779
%*pbl 0,3-6,8-10
```

用于打印位图及其衍生类如 cpumask 和 nodemask，
`%*pb` 按位输出位图，其中字段宽度为位数；
`%*pbl` 将位图作为范围列表输出，其中字段宽度为位数。
字段宽度按值传递，位图按引用传递。
辅助宏 `cpumask_pr_args()` 和 `nodemask_pr_args()` 可用于简化打印 `cpumask` 和 `nodemask`。
标志位字段如页标志、页类型、`gfp_flags`

示例：

```
%pGp	0x17ffffc0002036(被引用|最新|LRU|活跃|私有|节点=0|区域=2|最后CPUID=0x1fffff)
%pGt	0xffffff7f(伙伴)
%pGg	GFP_USER|GFP_DMA32|GFP_NOWARN
%pGv	读取|执行|可读|可写|可执行|禁止写
```

用于将标志位字段作为一组符号常量集合进行打印，这些常量能够构建出该值。标志的类型由第三个字符给出。目前支持的类型包括：

- p - [p] 页标志，期望类型为 (`unsigned long *`)
- t - 页 [t] 类型，期望类型为 (`unsigned int *`)
- v - [v]ma_flags，期望类型为 (`unsigned long *`)
- g - [g]fp_flags，期望类型为 (`gfp_t *`)

标志名称和打印顺序取决于特定类型。
注意不要直接在追踪点的 `TP_printk()` 部分使用这种格式。相反，请从 `<trace/events/mmflags.h>` 中使用 show_*_flags() 函数。
按引用传递
网络设备特性

示例：

```
%pNF	0x000000000000c000
```

用于打印 `netdev_features_t`。
按引用传递
V4L2 和 DRM FourCC 码（像素格式）

示例：

```
%p4cc
```

打印 V4L2 或 DRM 使用的 FourCC 码，包括格式字节序及其十六进制数值。
按引用传递
示例：

```
%p4cc	BG12 小端字节序 (0x32314742)
%p4cc	Y10  小端字节序 (0x20303159)
%p4cc	NV12 大端字节序 (0xb231564e)
```

Rust

示例：

```
%pA
```

仅打算在 Rust 代码中使用以格式化 `core::fmt::Arguments`。
请*不要*从 C 语言中使用它。
谢谢
======

如果您添加了其他 %p 扩展，请在可行的情况下，在 `<lib/test_printf.c>` 中添加一个或多个测试案例。
感谢您的配合与关注。
