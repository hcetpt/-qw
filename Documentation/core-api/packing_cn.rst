通用位字段打包和解包函数
=================================

问题陈述
--------

在与硬件交互时，需要在几种方法中做出选择。
一种方法是将精心设计的结构体指针映射到硬件设备的内存区域，并像访问结构体成员一样访问其字段（可能声明为位字段）。但是以这种方式编写代码会降低其可移植性，因为可能会出现CPU与硬件设备之间的字节序不匹配的问题。
此外，在将硬件文档中的寄存器定义转换为结构体的位字段索引时必须格外小心。另外，某些硬件（通常是网络设备）倾向于将其寄存器字段以违反任何合理字边界的方式进行分组（有时甚至64位边界也会被跨越）。这导致了不得不在结构体中定义寄存器字段的“高位”和“低位”的不便。
相对于结构体字段定义而言，一个更稳健的选择是从移位适当数量的位来提取所需的字段。但这仍然无法防止字节序不匹配的问题，除非所有的内存访问都按字节进行。此外，代码很容易变得杂乱无章，高级思想可能会在众多位移操作中丢失。
许多驱动程序采用位移的方法，然后试图通过定制宏来减少杂乱，但这些宏往往采取捷径，使得代码仍然不具备真正的可移植性。

解决方案
---------

此API处理两个基本操作：

  - 将CPU可用的数字打包到内存缓冲区中（考虑到硬件限制/特殊要求）
  - 从内存缓冲区（具有硬件限制/特殊要求）中解包出CPU可用的数字
该API为这些硬件限制和特殊要求提供了抽象层，同时也考虑了CPU的字节序，因此可以解决两者之间可能存在的不匹配问题。
这些API函数的基本单位是u64。从CPU的角度来看，位63始终意味着第7个字节的第7位偏移量，尽管这只是逻辑上的。问题是：我们如何在内存中布局这个位？

以下示例涵盖了已打包的u64字段的内存布局情况
已打包缓冲区中的字节偏移总是隐含地为0、1、...、7。
示例展示的是逻辑字节和位的位置。
1. 通常情况下（无特殊设置），我们这样做：

::

  63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32
  7                       6                       5                        4
  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
  3                       2                       1                        0

也就是说，CPU 可用的 u64 的最高位字节 (MSByte) 7 位于内存偏移量 0 处，而该 u64 的最低位字节 (LSByte) 0 位于内存偏移量 7 处。
这对应于大多数人认为的“大端模式”，其中位 i 对应数字 2^i。在代码注释中也称为“逻辑”表示法。
2. 如果设置了 QUIRK_MSB_ON_THE_RIGHT，我们将这样做：

::

  56 57 58 59 60 61 62 63 48 49 50 51 52 53 54 55 40 41 42 43 44 45 46 47 32 33 34 35 36 37 38 39
  7                       6                        5                       4
  24 25 26 27 28 29 30 31 16 17 18 19 20 21 22 23  8  9 10 11 12 13 14 15  0  1  2  3  4  5  6  7
  3                       2                        1                       0

也就是说，QUIRK_MSB_ON_THE_RIGHT 不影响字节定位，而是反转字节内部的位偏移。
3. 如果设置了 QUIRK_LITTLE_ENDIAN，我们将这样做：

::

  39 38 37 36 35 34 33 32 47 46 45 44 43 42 41 40 55 54 53 52 51 50 49 48 63 62 61 60 59 58 57 56
  4                       5                       6                       7
  7  6  5  4  3  2  1  0  15 14 13 12 11 10  9  8 23 22 21 20 19 18 17 16 31 30 29 28 27 26 25 24
  0                       1                       2                       3

因此，QUIRK_LITTLE_ENDIAN 表示在内存区域中，每个 4 字节词中的每一个字节都放置在其相对于该词边界镜像的位置。
4. 如果同时设置了 QUIRK_MSB_ON_THE_RIGHT 和 QUIRK_LITTLE_ENDIAN，我们将这样做：

::

  32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63
  4                       5                       6                       7
  0  1  2  3  4  5  6  7  8   9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
  0                       1                       2                       3


5. 如果仅设置了 QUIRK_LSW32_IS_FIRST，我们将这样做：

::

  31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
  3                       2                       1                        0
  63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32
  7                       6                       5                        4

在这种情况下，8 字节内存区域被解释为：前 4 字节对应最不重要的 4 字节词，接下来的 4 字节对应更重要的 4 字节词。
6. 如果同时设置了 QUIRK_LSW32_IS_FIRST 和 QUIRK_MSB_ON_THE_RIGHT，我们将这样做：

::

  24 25 26 27 28 29 30 31 16 17 18 19 20 21 22 23  8  9 10 11 12 13 14 15  0  1  2  3  4  5  6  7
  3                       2                        1                       0
  56 57 58 59 60 61 62 63 48 49 50 51 52 53 54 55 40 41 42 43 44 45 46 47 32 33 34 35 36 37 38 39
  7                       6                        5                       4


7. 如果同时设置了 QUIRK_LSW32_IS_FIRST 和 QUIRK_LITTLE_ENDIAN，结果如下：

::

  7  6  5  4  3  2  1  0  15 14 13 12 11 10  9  8 23 22 21 20 19 18 17 16 31 30 29 28 27 26 25 24
  0                       1                       2                       3
  39 38 37 36 35 34 33 32 47 46 45 44 43 42 41 40 55 54 53 52 51 50 49 48 63 62 61 60 59 58 57 56
  4                       5                       6                       7


8. 如果同时设置了 QUIRK_LSW32_IS_FIRST、QUIRK_LITTLE_ENDIAN 和 QUIRK_MSB_ON_THE_RIGHT，结果如下：

::

  0  1  2  3  4  5  6  7  8   9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
  0                       1                       2                       3
  32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63
  4                       5                       6                       7


我们始终认为我们的偏移量不受任何特殊设置的影响，并在访问内存区域之前进行转换。
预期用途
-----------

选择使用此 API 的驱动程序首先需要确定上述三种特殊设置组合中的哪一种（总共八种）与硬件文档描述相匹配。然后，他们应该封装 packing() 函数，创建一个新的 xxx_packing()，使用正确的 QUIRK_* 一位热编码位来调用它。
packing() 函数返回一个 int 编码的错误码，以防止程序员错误地使用 API。这些错误不期望在运行时发生，因此对于 xxx_packing() 来说返回 void 并简单地忽略这些错误是合理的。可选地，它可以转储堆栈或打印错误描述。
