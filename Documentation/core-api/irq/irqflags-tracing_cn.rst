=======================
IRQ标志状态追踪
=======================

:作者: 起始于 Ingo Molnar <mingo@redhat.com>

"IRQ标志追踪"功能追踪硬件中断和软件中断的状态，即它为感兴趣的子系统提供了通知每次内核中发生的硬件中断关闭/开启、软件中断关闭/开启事件的机会。
CONFIG_TRACE_IRQFLAGS_SUPPORT 是 CONFIG_PROVE_SPIN_LOCKING 和 CONFIG_PROVE_RW_LOCKING 由通用锁调试代码提供的必要条件。否则，仅提供 CONFIG_PROVE_MUTEX_LOCKING 和 CONFIG_PROVE_RWSEM_LOCKING —— 这些是在中断上下文中不使用的锁定 API。（rwsem 的唯一例外被绕过处理）

对这种支持的架构实现肯定不属于“简单”类别，因为大量底层汇编代码涉及 IRQ 标志状态变化。但是，架构可以在相当直接且风险较小的方式下启用 IRQ 标志追踪：
架构要支持此功能需要先进行一些代码组织上的变更：

- 在其架构级别的 Kconfig 文件中添加并启用 TRACE_IRQFLAGS_SUPPORT

然后还需要实施一些功能性变更以支持 IRQ 标志追踪：

- 在底层入口代码中添加（构建条件性的）调用至 trace_hardirqs_off()/trace_hardirqs_on() 函数。锁验证器紧密监控“真实的”IRQ 标志是否与“虚拟”的 IRQ 标志状态匹配，并在两者不匹配时大声警告（并自行关闭）。通常，在支持 IRQ 标志追踪的架构上花费大部分时间是为了查看锁依赖性（lockdep）的警告，尝试找出我们尚未覆盖的汇编代码部分，修复后重复该过程。一旦系统启动并能在没有 IRQ 标志追踪函数中的锁依赖性警告的情况下正常运行，则架构支持就完成了。
- 如果架构有不可屏蔽中断，则需要通过 lockdep_off()/lockdep_on() 将其从 IRQ 追踪（及锁验证）机制中排除。

通常来说，架构中具有不完整的 IRQ 标志追踪实现是没有风险的：锁依赖性会检测到这一点并自行关闭。也就是说，锁验证器仍然可靠。由于 IRQ 追踪错误导致崩溃的情况应该不会发生。（除非汇编更改通过修改不应被修改的条件或寄存器破坏了其他代码）
