==============================
Reed-Solomon 库编程接口
==============================

:作者: Thomas Gleixner

简介
============

通用的 Reed-Solomon 库提供了编码、解码和错误校正功能。
Reed-Solomon 码在通信和存储应用中用于确保数据完整性。
本文档为希望利用库提供的功能的开发者提供指南。

已知缺陷与假设
==========================

无

使用说明
=====

本章提供了如何使用该库的例子。

初始化
------------

初始化函数 `init_rs` 返回一个指向 `rs` 解码器结构的指针，该结构保存了给定多项式进行编码、解码及错误校正所需的必要信息。它要么使用现有的匹配解码器，要么创建一个新的解码器。在创建时会生成所有快速编解码所用的查找表。此函数可能需要一段时间来执行，因此请确保不要在关键代码路径中调用它。
::
    
    /* Reed-Solomon 控制结构 */
    static struct rs_control *rs_decoder;

    /* 符号大小为 10（位）
     * 原始多项式为 x^10 + x^3 + 1
     * 第一个连续根为 0
     * 生成根的原始元素 = 1
     * 生成多项式次数（根的数量）= 6
     */
    rs_decoder = init_rs (10, 0x409, 0, 1, 6);

编码
--------

编码器根据给定的数据长度计算 Reed-Solomon 码，并将结果存放在奇偶校验缓冲区中。请注意，在调用编码器之前必须先初始化奇偶校验缓冲区。
可以通过提供非零反转掩码来实时反转扩展后的数据。扩展后的数据与掩码进行异或运算。例如，对于 FLASH ECC，所有的 0xFF 被反转为全 0x00。Reed-Solomon 码对于全 0x00 的情况也是全 0x00。在存储到 FLASH 中前对码进行反转使其变为 0xFF，这可以避免从擦除过的 FLASH 读取时出现 ECC 错误。
数据字节会被实时扩展到指定的符号大小。目前不支持编码连续比特流且符号大小不等于 8 的情况。如果确实需要这种功能，实现起来应该不是难事。
::
    
    /* 奇偶校验缓冲区。大小等于根的数量 */
    uint16_t par[6];
    /* 初始化奇偶校验缓冲区 */
    memset(par, 0, sizeof(par));
    /* 编码 512 字节的数据 data8。将奇偶校验值存入缓冲区 par */
    encode_rs8 (rs_decoder, data8, 512, par, 0);

解码
--------

解码器根据给定的数据长度和接收到的奇偶校验符号计算综合症并修正数据中的错误。
如果可以从硬件解码器获得综合症（syndrome），则跳过综合症计算。
可以通过向解码器提供一个校正模式缓冲区和一个错误位置缓冲区来抑制数据缓冲区的校正。
解码器将计算出的错误位置和校正位掩码存储在给定的缓冲区中。这对于使用奇怪的位排序方案的硬件解码器非常有用。
数据字节会即时扩展到指定的符号大小。目前不支持解码连续比特流，其中符号大小不等于8的情况。如果需要实现这样的功能，应该不是什么大问题。
带有综合症计算及直接数据校正的解码
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    /* 奇偶校验缓冲区。大小=根的数量 */
    uint16_t par[6];
    uint8_t  data[512];
    int numerr;
    /* 接收数据 */
    ....
/* 接收奇偶校验 */
    ....
/* 解码 data 中的 512 字节。*/
    numerr = decode_rs8 (rs_decoder, data, par, 512, NULL, 0, NULL, 0, NULL);


带有由硬件解码器给出的综合症以及直接数据校正的解码
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    /* 奇偶校验缓冲区。大小=根的数量 */
    uint16_t par[6], syn[6];
    uint8_t  data[512];
    int numerr;
    /* 接收数据 */
    ....
/* 接收奇偶校验 */
    ....
/* 从硬件解码器获取综合症 */
    ....
/* 解码 data 中的 512 字节。*/
    numerr = decode_rs8 (rs_decoder, data, par, 512, syn, 0, NULL, 0, NULL);


带有由硬件解码器给出的综合症、无直接数据校正的解码
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:: 

    /* 奇偶校验缓冲区。大小=根的数量 */
    uint16_t par[6], syn[6];
    uint8_t  data[512];
    int numerr;
    /* 接收数据 */
    ....
/* 接收奇偶校验 */
    ....
/* 从硬件解码器获取综合症 */
    ....
/* 解码 data 中的 512 字节。*/
    numerr = decode_rs8 (rs_decoder, data, par, 512, syn, 0, NULL, 0, NULL);
注：向解码器提供数据和接收到的校验位并不是必要的。

```
/* 校验缓冲区。大小 = 根的数量 */
uint16_t par[6], syn[6], corr[8];
uint8_t  data[512];
int numerr, errpos[8];
/* 接收数据 */
....
/* 接收校验位 */
....
/* 从硬件解码器获取综合症 */
....
/* 解码 data 中的 512 字节。*/
numerr = decode_rs8 (rs_decoder, NULL, NULL, 512, syn, 0, errpos, 0, corr);
for (i = 0; i < numerr; i++) {
    do_error_correction_in_your_buffer(errpos[i], corr[i]);
}
```

### 清理

`free_rs` 函数释放分配的资源，如果调用者是解码器的最后一个使用者。

```
/* 释放资源 */
free_rs(rs_decoder);
```

### 结构体

本章包含 Reed-Solomon 库中使用的结构体的自动生成文档，这些结构体对于开发者来说是相关的。

```
.. kernel-doc:: include/linux/rslib.h
   :internal:
```

### 提供的公共函数

本章包含导出的 Reed-Solomon 函数的自动生成文档。

```
.. kernel-doc:: lib/reed_solomon/reed_solomon.c
   :export:
```

### 致谢

编码和解码的库代码由 Phil Karn 编写：

```
版权所有 2002, Phil Karn, KA9Q
可以在 GNU 通用公共许可证（GPL）条款下使用。
```

包装函数和接口由 Thomas Gleixner 编写。
许多用户提供了错误修复、改进以及测试帮助。非常感谢大家。
以下人员对本文档做出了贡献：

Thomas Gleixner\ tglx@linutronix.de
