### 循环缓冲区

**作者：** David Howells <dhowells@redhat.com>  
**作者：** Paul E. McKenney <paulmck@linux.ibm.com>

Linux 提供了多种特性，可用于实现循环缓冲。这些特性分为两大类：

1. 用于确定 2 的幂大小的缓冲区信息的便利函数。
2. 当缓冲区中的生产者和消费者不想共享锁时使用的内存屏障。

要使用这些设施，如下所述，需要有一个生产者和一个消费者。可以通过串行化来处理多个生产者，并通过同样的方式处理多个消费者。

#### 目录

* 什么是循环缓冲区？
* 测量 2 的幂大小的缓冲区
* 在循环缓冲区中使用内存屏障
    * 生产者
    * 消费者

#### 什么是循环缓冲区？

首先，什么是循环缓冲区？循环缓冲区是一个具有固定有限大小的缓冲区，其中包含两个索引：

1. **头部索引** —— 生产者向缓冲区插入项目的点。
2. **尾部索引** —— 消费者在缓冲区中找到下一个项目的点。

通常当尾指针等于头指针时，表示缓冲区为空；而当头指针比尾指针小一的时候，表示缓冲区已满。
头部索引在添加项目时递增，尾部索引在移除项目时递增。尾部索引不应超过头部索引，并且当这两个索引达到缓冲区末尾时都应循环回0，从而允许无限量的数据通过缓冲区流动。
通常情况下，所有项目都是相同单位大小的，但这并不是使用以下技术的严格要求。如果要在缓冲区中包含多个项目或可变大小的项目，则可以将索引增加超过1，前提是任一索引都不超过另一个。然而，实现者必须小心，因为超过一个单位大小的区域可能会跨越缓冲区的末尾并被分成两部分。

测量2的幂次缓冲区
============================

对于任意大小的循环缓冲区，计算其占用率或剩余容量通常是一个较慢的操作，需要使用模运算（即除法）指令。但是，如果缓冲区大小为2的幂次，则可以使用更快的位与操作指令代替。

Linux提供了一组宏来处理2的幂次循环缓冲区。这些宏可以通过以下方式使用：

	#include <linux/circ_buf.h>

这些宏包括：

(#) 测量缓冲区的剩余容量：

	CIRC_SPACE(头部索引, 尾部索引, 缓冲区大小);

     这个函数返回缓冲区中剩余可用于插入项目的空间数量[1]。
(#) 测量缓冲区中的最大连续立即可用空间：

	CIRC_SPACE_TO_END(头部索引, 尾部索引, 缓冲区大小);

     这个函数返回缓冲区中剩余的连续空间数量[1]，可以在不回到缓冲区开头的情况下立即插入项目。
(#) 测量缓冲区的占用情况：

	CIRC_CNT(头部索引, 尾部索引, 缓冲区大小);

     这个函数返回当前占据缓冲区的项目数量[2]。
(#) 测量缓冲区的非循环占用情况：

	CIRC_CNT_TO_END(头部索引, 尾部索引, 缓冲区大小);

     这个函数返回可以从缓冲区中提取的连续项目数量[2]，无需回到缓冲区开头。

每个宏理论上会返回一个介于0和缓冲区大小减1之间的值，但：

 (1) CIRC_SPACE*() 主要用于生产者端。对生产者而言，它返回的是下限，因为生产者控制头部索引，但消费者可能正在另一个CPU上消耗缓冲区并移动尾部索引。
对于消费者来说，它显示的是上限，因为生产者可能正在另一个CPU上消耗空间。
(2) CIRC_CNT*() 主要用于消费者端。对于消费者而言，它们返回的是下限，因为消费者控制尾部索引，但生产者可能仍然在另一个CPU上填充缓冲区并移动头部索引。
通过使用内存屏障与循环缓冲区结合，您可以避免以下需求：

(1) 使用单一锁来控制缓冲区两端的访问，从而允许缓冲区同时被填充和清空；以及

(2) 使用原子计数器操作。

这个问题有两个方面：填充缓冲区的生产者和清空缓冲区的消费者。在任何时刻，只应有一个实体在填充缓冲区，只应有一个实体在清空缓冲区，但这两个操作可以同时进行。

### 生产者

生产者的代码看起来像这样：

```c
spin_lock(&producer_lock);

unsigned long head = buffer->head;
/* spin_unlock() 和下一个 spin_lock() 提供所需的排序。*/
unsigned long tail = READ_ONCE(buffer->tail);

if (CIRC_SPACE(head, tail, buffer->size) >= 1) {
    /* 向缓冲区中插入一个元素 */
    struct item *item = buffer[head];

    produce_item(item);

    smp_store_release(buffer->head,
                      (head + 1) & (buffer->size - 1));

    /* wake_up() 将确保 head 已提交然后再唤醒任何人 */
    wake_up(consumer);
}

spin_unlock(&producer_lock);
```

这会指示 CPU 必须先写入新元素的内容，然后才能让头指针对消费者可用，并且之后才唤醒消费者。请注意，wake_up() 只有在实际唤醒了某个线程时才提供某种形式的屏障。因此我们不能依赖它来进行排序。然而，数组始终保留一个元素为空。因此，生产者必须产生两个元素才有可能破坏消费者当前正在读取的元素。因此，连续调用消费者之间的解锁-加锁对提供了必要的排序，即从读取消费者已释放给定元素的索引到生产者对该元素的写入。

### 消费者

消费者的代码看起来像这样：

```c
spin_lock(&consumer_lock);

/* 在读取该索引处的内容之前读取索引。*/
unsigned long head = smp_load_acquire(buffer->head);
unsigned long tail = buffer->tail;

if (CIRC_CNT(head, tail, buffer->size) >= 1) {

    /* 从缓冲区中提取一个元素 */
    struct item *item = buffer[tail];

    consume_item(item);

    /* 在递增尾指针前完成读取描述符。*/
    smp_store_release(buffer->tail,
                      (tail + 1) & (buffer->size - 1));
}

spin_unlock(&consumer_lock);
```

这会指示 CPU 确保索引是最新的，然后再读取新元素，并且它将确保 CPU 完成了元素的读取后才写入新的尾指针，该指针将移除该元素。

注意使用 READ_ONCE() 和 smp_load_acquire() 来读取对立方的索引。这防止了编译器丢弃并重新加载其缓存的值。如果你能确信对立方的索引仅在这次使用一次，则这不是严格必需的。

smp_load_acquire() 还强制 CPU 对后续的内存引用进行排序。类似地，在两个算法中都使用了 smp_store_release() 来写入线程的索引。这记录了我们将写入的内容可能会被并发读取的事实，防止编译器撕裂存储操作，并强制执行相对于先前访问的排序。

### 进一步阅读

请参阅 `Documentation/memory-barriers.txt` 以了解 Linux 的内存屏障设施的描述。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
