未对齐的内存访问
=========================

:作者: Daniel Drake <dsd@gentoo.org>,
:作者: Johannes Berg <johannes@sipsolutions.net>

:获得帮助自: Alan Cox, Avuton Olrich, Heikki Orsila, Jan Engelhardt,
  Kyle McMartin, Kyle Moffett, Randy Dunlap, Robert Hancock, Uli Kunitz,
  Vadim Lobanov

Linux运行在各种具有不同内存访问行为的架构上。本文档介绍了一些关于未对齐内存访问的详细信息，解释了为什么你需要编写不会导致这些访问的代码，以及如何编写这样的代码。

未对齐内存访问的定义
=====================================

当尝试从一个地址读取N字节的数据时，如果该地址不能被N整除（即addr % N != 0），就会发生未对齐的内存访问。例如，从地址0x10004读取4字节数据是正常的，但从地址0x10005读取4字节数据则属于未对齐的内存访问。
上述描述可能显得有些模糊，因为内存访问可以以不同的方式进行。这里的上下文是在机器码级别：某些指令会从或向内存读写一定数量的字节（例如，在x86汇编中movb、movw和movl）。很明显，容易识别出哪些C语句会被编译为多字节内存访问指令，特别是处理如u16、u32和u64等类型的时候。

自然对齐
=================

上述规则构成了我们所说的自然对齐：
当访问N字节的内存时，基内存地址必须能被N整除，即addr % N == 0
编写代码时，假设目标架构有自然对齐的要求。
实际上，只有少数架构要求所有大小的内存访问都进行自然对齐。但是，我们必须考虑到所有支持的架构；编写满足自然对齐要求的代码是最简单的方式来实现完全的可移植性。

未对齐访问为何不好
===========================

未对齐内存访问的影响因架构而异。在此很容易写出一篇详细的文档来描述这些差异；下面将简要概述常见的几种情况：

- 一些架构能够透明地执行未对齐的内存访问，但通常会有显著的性能成本。
- 当发生未对齐访问时，一些架构会引发处理器异常。异常处理程序能够修正未对齐的访问，但会对性能造成显著影响。
- 当发生未对齐访问时，一些架构会引发处理器异常，但异常中没有足够的信息来修正未对齐的访问。
- 一些架构无法执行未对齐的内存访问，但会默默地执行与请求不同的内存访问，从而导致难以检测的微妙代码bug！

从以上内容可以看出，如果你的代码导致未对齐的内存访问发生，那么你的代码在某些平台上将无法正确工作，并且在其他平台上会造成性能问题。
不引起未对齐访问的代码
======================

起初，上述概念可能看起来与实际编程实践有点难以联系。毕竟，你无法完全控制某些变量的内存地址等。幸运的是，情况并不太复杂，因为在大多数情况下，编译器确保了一切都能正常工作。例如，考虑以下结构体：

    struct foo {
        u16 field1;
        u32 field2;
        u8 field3;
    };

假设上述结构体的一个实例从内存地址 0x10000 开始。基于基本的理解，你可能会认为访问 `field2` 将会导致未对齐访问。你会期望 `field2` 位于结构体偏移量 2 字节的位置，即地址 0x10002，但该地址不能被 4（记住，我们正在读取一个 4 字节值）整除。

幸运的是，编译器理解对齐约束，因此在这种情况下它会在 `field1` 和 `field2` 之间插入 2 字节的填充。因此，对于标准结构体类型，你可以始终依赖于编译器来填充结构体，以使对字段的访问适当对齐（假设你没有将字段转换为不同长度的类型）。

同样地，你也可以依赖于编译器来根据变量大小的自然对齐方案对变量和函数参数进行对齐。

此时应该清楚，访问单个字节（`u8` 或 `char`）永远不会导致未对齐访问，因为所有内存地址都可以被 1 整除。

相关地，考虑到上述因素，你可能会注意到可以重新排列结构体中的字段，以便在原本会插入填充的地方放置字段，从而减少结构体实例占用的总内存大小。上述示例的最佳布局如下：

    struct foo {
        u32 field2;
        u16 field1;
        u8 field3;
    };

对于自然对齐方案，编译器只需在结构体末尾添加一个字节的填充。这种填充是为了满足这些结构体数组的对齐约束而添加的。

还有一点值得提及的是在结构体类型上使用 `__attribute__((packed))`。这是 GCC 特定的属性，告诉编译器不要在结构体内插入任何填充，这在你想用 C 结构体表示一些固定格式的数据时非常有用。

你可能倾向于认为当访问不符合架构对齐要求的字段时，此属性很容易导致未对齐访问。然而，再次地，编译器了解对齐约束，并将生成额外的指令来执行不会导致未对齐访问的内存访问。当然，额外的指令显然会导致性能下降，与非打包的情况相比，因此仅当避免结构体填充非常重要时才应使用打包属性。

引起未对齐访问的代码
==================

有了上述内容作为基础，让我们来看看一个能引起未对齐内存访问的实际函数示例。下面的函数取自 `include/linux/etherdevice.h`，是一个用于比较两个以太网 MAC 地址是否相等的优化例程：

    bool ether_addr_equal(const u8 *addr1, const u8 *addr2)
    {
    #ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
        u32 fold = ((*(const u32 *)addr1) ^ (*(const u32 *)addr2)) |
                   ((*(const u16 *)(addr1 + 4)) ^ (*(const u16 *)(addr2 + 4)));

        return fold == 0;
    #else
        const u16 *a = (const u16 *)addr1;
        const u16 *b = (const u16 *)addr2;
        return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2])) == 0;
    #endif
    }

在上述函数中，如果硬件具有高效的未对齐访问能力，则此代码没有问题。但如果硬件无法在任意边界访问内存，则对 `a[0]` 的引用将导致从地址 `addr1` 开始读取 2 字节（16 位）。
考虑如果`addr1`是一个奇数地址，例如`0x10003`会发生什么情况（提示：这将导致未对齐访问）。

尽管上述函数可能存在未对齐访问的问题，但它仍然被包含在内核中，但仅适用于16位对齐的地址。调用者需要确保这种对齐方式，否则就不要使用这个函数。这个不安全的对齐函数仍然很有用，因为它在可以确保对齐的情况下是一个很好的优化，而这在以太网网络上下文中几乎总是成立的。
这里还有一个可能导致未对齐访问的代码示例：

```c
void myfunc(u8 *data, u32 value)
{
	[...]
	*((u32 *) data) = cpu_to_le32(value);
	[...]
}
```

每次`data`参数指向一个不能被4整除的地址时，这段代码都会导致未对齐访问。
总之，遇到未对齐访问问题的两个主要场景涉及：

1. 将变量转换为不同长度的类型
2. 指针运算后访问至少2字节的数据

避免未对齐访问
=================

避免未对齐访问最简单的方法是使用`<asm/unaligned.h>`头文件提供的`get_unaligned()`和`put_unaligned()`宏。
回到之前可能导致未对齐访问的代码示例：

```c
void myfunc(u8 *data, u32 value)
{
	[...]
	*((u32 *) data) = cpu_to_le32(value);
	[...]
}
```

为了避免未对齐内存访问，您可以这样重写它：

```c
void myfunc(u8 *data, u32 value)
{
	[...]
	value = cpu_to_le32(value);
	put_unaligned(value, (u32 *) data);
	[...]
}
```

`get_unaligned()`宏的工作原理类似。假设`data`是指向内存的指针，并且您希望避免未对齐访问，其使用方法如下：

```c
u32 value = get_unaligned((u32 *) data);
```

这些宏适用于任何长度的内存访问（不仅仅是上面示例中的32位）。需要注意的是，与标准的对齐内存访问相比，使用这些宏来访问未对齐内存可能会在性能上付出成本。
如果不方便使用这些宏，另一种选择是使用`memcpy()`，其中源或目标（或两者）为`u8*`或`unsigned char*`类型。由于该操作的字节特性，因此避免了未对齐访问。
对齐与网络
=================

对于要求对齐加载的架构，网络要求IP头部必须在四字节边界上对齐以优化IP栈。对于常规以太网硬件，常量`NET_IP_ALIGN`被使用。在大多数架构中，这个常量的值为2，因为正常的以太网头部长度为14字节，因此为了获得正确的对齐，需要DMA到可以表示为`4*n + 2`的地址。一个显著的例外是PowerPC，它将`NET_IP_ALIGN`定义为0，因为DMA到未对齐地址可能非常昂贵，并且远远超过未对齐加载的成本。
对于一些不能DMA到如`4*n+2`这样的未对齐地址的以太网硬件或其他非以太网硬件，这可能是个问题，此时需要将接收到的数据帧复制到对齐的缓冲区中。因为在能够进行未对齐访问的架构上这是不必要的，因此代码可以根据`CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS`配置依赖性地编写，如下所示：

```c
#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
	skb = 原始skb
#else
	skb = 复制skb
#endif
```
