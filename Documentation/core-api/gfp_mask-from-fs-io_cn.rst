标题: 从文件系统/输入输出环境中使用的GFP掩码

=================================
从文件系统/输入输出环境使用的GFP掩码
=================================

:日期: 2018年5月
:作者: Michal Hocko <mhocko@kernel.org>

简介
============

在文件系统和输入输出栈中的代码路径在分配内存时必须谨慎，以防止直接内存回收回调到文件系统或输入输出路径并阻塞已持有的资源（例如锁——最常见的是用于事务上下文的锁）而引起的递归死锁。
传统的避免这种死锁问题的方法是在调用分配器时清除gfp掩码中的__GFP_FS或__GFP_IO（注意后者也隐含清除前者）。可以使用GFP_NOFS或GFP_NOIO作为快捷方式。然而，这种方法导致了滥用情况的发生，即在没有深入考虑的情况下“以防万一”地使用受限制的gfp掩码，这会导致问题，因为过度使用GFP_NOFS/GFP_NOIO可能导致内存过度回收或其他内存回收问题。

新API
========

自4.12版本开始，我们有了一个适用于NOFS和NOIO环境的通用范围API：`memalloc_nofs_save`、`memalloc_nofs_restore`以及`memalloc_noio_save`、`memalloc_noio_restore`。这些函数允许标记一个范围为文件系统或I/O角度的关键部分。从该范围进行的任何分配都会自动从给定掩码中清除__GFP_FS或__GFP_IO，因此没有任何内存分配可以递归回到文件系统/I/O中。

文件系统/I/O代码只需在与回收相关的任何关键部分开始前调用相应的保存函数即可——例如，与回收上下文共享的锁，或者通过回收可能发生事务上下文嵌套的情况。当关键部分结束时应调用恢复函数。理想情况下，应该伴随一些解释说明回收上下文，以便于维护。

请注意，正确配对的保存/恢复函数允许嵌套，因此从现有的NOIO或NOFS范围内安全地调用`memalloc_noio_save`或`memalloc_noio_restore`。

关于__vmalloc(GFP_NOFS)
==============================

`vmalloc`不支持GFP_NOFS语义，因为在分配器内部有硬编码的GFP_KERNEL分配，修复起来相当复杂。这意味着带有GFP_NOFS/GFP_NOIO参数调用`vmalloc`几乎总是一个错误。好消息是可以通过范围API实现NOFS/NOIO语义。

在理想的世界里，上层应该已经标记了危险的上下文，因此不需要特别的关注，并且`vmalloc`应该可以毫无问题地被调用。有时如果上下文不是很明确或者存在层次违规，则推荐的做法是通过范围API包裹`vmalloc`，并附带注释来解释问题。
