===================
当前CPU操作
===================

:作者: Christoph Lameter, 2014年8月4日
:作者: Pranith Kumar, 2014年8月2日

当前CPU操作是一种优化访问与*当前*执行处理器关联的每核变量的方法。这是通过使用段寄存器（或一个专用寄存器，在该寄存器中CPU永久存储特定处理器的每核区域的起始地址）来实现的。
当前CPU操作会将每核变量偏移量添加到特定处理器的每核基地址上，并将此操作编码在对每核变量进行操作的指令中。
这意味着计算偏移量和对数据进行操作之间没有原子性问题。因此，没有必要禁用抢占或中断以确保在计算地址和对数据进行操作之间处理器不会改变。
读-改-写操作尤其值得关注。通常，处理器具有特殊的低延迟指令，可以在不增加典型同步开销的情况下运行，但仍提供某种形式的放松原子性保证。例如，x86架构可以无锁前缀执行RMW（读取-修改-写入）指令，如inc/dec/cmpxchg，避免了相关的延迟惩罚。
对变量的访问不加锁前缀不是同步的，但同步不是必要的，因为我们处理的是针对当前执行处理器的每核数据。只有当前处理器应该访问那个变量，因此与其他系统中的处理器不存在并发问题。
请注意，远程处理器对每核区域的访问是异常情况，可能会影响本地通过`this_cpu_*`操作的性能和/或正确性（远程写操作）。
当前CPU操作的主要用途是优化计数器操作。
定义了以下带有隐式抢占保护的`this_cpu()`操作。这些操作可以使用而不用担心抢占和中断： 

- `this_cpu_read(pcp)`
- `this_cpu_write(pcp, val)`
- `this_cpu_add(pcp, val)`
- `this_cpu_and(pcp, val)`
- `this_cpu_or(pcp, val)`
- `this_cpu_add_return(pcp, val)`
- `this_cpu_xchg(pcp, nval)`
- `this_cpu_cmpxchg(pcp, oval, nval)`
- `this_cpu_sub(pcp, val)`
- `this_cpu_inc(pcp)`
- `this_cpu_dec(pcp)`
- `this_cpu_sub_return(pcp, val)`
- `this_cpu_inc_return(pcp)`
- `this_cpu_dec_return(pcp)`


当前CPU操作的内部工作原理
------------------------------

在x86上，fs: 或 gs: 段寄存器包含每核区域的基地址。然后就可以简单地使用段覆盖将每核相对地址重定位到处理器正确的每核区域。因此，重定位到每核基地址被编码在指令中，通过段寄存器前缀实现。
例如：

```c
DEFINE_PER_CPU(int, x);
int z;

z = this_cpu_read(x);
```

这将产生单一指令：

```assembly
mov ax, gs:[x]
```

而不是一系列先计算地址然后再从该地址获取的操作，这发生在使用每核操作时。在引入`this_cpu_ops`之前，这种序列还需要禁用/启用抢占，以防止内核在计算过程中将线程移动到不同的处理器上。
考虑以下当前CPU操作：

```c
this_cpu_inc(x)
```

上述操作将产生如下单一指令（无锁前缀！）：

```assembly
inc gs:[x]
```

而不是如果没有段寄存器需要的以下操作：

```c
int *y;
int cpu;

cpu = get_cpu();
y = per_cpu_ptr(&x, cpu);
(*y)++;
put_cpu();
```

请注意，这些操作只能用于为特定处理器保留的每核数据。如果没有在周围代码中禁用抢占，则`this_cpu_inc()`仅能保证其中一个每核计数器被正确递增。然而，不能保证操作系统不会在执行当前CPU指令前后直接移动进程。一般来说，这意味着每个处理器的单个计数器的值是没有意义的。所有每核计数器之和是唯一感兴趣的值。
每CPU变量用于性能原因。如果多个处理器同时经过相同的代码路径，可以避免缓存行的跳跃。因为每个处理器都有自己的每CPU变量，所以不会发生并发的缓存行更新。为了这种优化所付出的代价是在需要一个计数器的值时，需要将每CPU计数器加总起来。
特殊操作
----------

::

    y = this_cpu_ptr(&x)

取每CPU变量的偏移量（&x！），并返回属于当前执行处理器的每CPU变量的地址。this_cpu_ptr避免了通常的get_cpu/put_cpu序列所需的多个步骤。没有提供处理器编号。相反，本地每CPU区域的偏移量直接被加到每CPU偏移量上。
需要注意的是，此操作通常在已禁用抢占的代码段中使用。然后该指针用于在关键部分访问本地每CPU数据。当重新启用抢占时，此指针通常不再有用，因为它可能不再指向当前处理器的每CPU数据。
每CPU变量和偏移量
-------------------

每CPU变量有到每CPU区域开始处的*偏移量*。它们没有地址，尽管在代码中看起来像是地址。偏移量不能直接解引用。必须将偏移量加到某个处理器的每CPU区域的基指针上以形成有效的地址。
因此，在每CPU操作之外使用x或&x是无效的，并且通常会被当作NULL指针解引用来处理。
::

    DEFINE_PER_CPU(int, x);

在每CPU操作的上下文中，上述内容意味着x是一个每CPU变量。大多数this_cpu操作需要一个每CPU变量。
::

    int __percpu *p = &x;

&x以及因此的p是每CPU变量的*偏移量*。this_cpu_ptr()需要每CPU变量的偏移量，这使得看起来有些奇怪。
对每CPU结构字段的操作
----------------------------

假设我们有一个每CPU结构。
::

    struct s {
        int n, m;
    };

    DEFINE_PER_CPU(struct s, p);

对这些字段的操作很简单。
::

    this_cpu_inc(p.m)

    z = this_cpu_cmpxchg(p.m, 0, 1);

如果我们有一个指向struct s的偏移量。
::

    struct s __percpu *ps = &p;

    this_cpu_dec(ps->m);

    z = this_cpu_inc_return(ps->n);

计算指针可能需要使用this_cpu_ptr()，如果我们后面不使用this_cpu操作来操纵字段的话。
::

    struct s *pp;

    pp = this_cpu_ptr(&p);

    pp->m--;

    z = pp->n++;

每CPU操作的变体
-------------------

this_cpu操作是中断安全的。一些架构不支持这些每CPU本地操作。在这种情况下，操作必须由禁用中断、执行保证原子性的操作、然后重新启用中断的代码替换。这样做是昂贵的。如果还有其他原因导致调度器无法改变我们正在执行的处理器，则没有理由禁用中断。为此提供了以下__this_cpu操作。
这些操作无法保证防止并发中断或抢占。如果一个每CPU变量不在中断上下文中使用并且调度器无法抢占，则它们是安全的。如果在操作进行过程中仍有任何中断发生，并且如果中断也修改了变量，则RMW动作不能保证是安全的。
::

    __this_cpu_read(pcp)
    __this_cpu_write(pcp, val)
    __this_cpu_add(pcp, val)
    __this_cpu_and(pcp, val)
    __this_cpu_or(pcp, val)
    __this_cpu_add_return(pcp, val)
    __this_cpu_xchg(pcp, nval)
    __this_cpu_cmpxchg(pcp, oval, nval)
    __this_cpu_sub(pcp, val)
    __this_cpu_inc(pcp)
    __this_cpu_dec(pcp)
    __this_cpu_sub_return(pcp, val)
    __this_cpu_inc_return(pcp)
    __this_cpu_dec_return(pcp)

将会递增x，并且不会退回到禁用中断的代码，在那些不能通过地址重定位和同一个指令中的读-改-写操作实现原子性的平台上。
&this_cpu_ptr(pp)->n 与 this_cpu_ptr(&pp->n)
------------------------------------------------

第一个操作获取偏移量并形成地址，然后加上n字段的偏移量。这可能会导致编译器发出两条加法指令。
第二个方法首先将两个偏移量相加，然后执行重定位。依我之见，第二种形式看起来更简洁，并且在处理括号（）时更加方便。此外，第二种形式也与使用 `this_cpu_read()` 及其相关函数的方式保持一致。

### 远程访问每个CPU的数据

每个CPU的数据结构设计为由单个CPU独占使用。如果你按照预期的方式使用这些变量，`this_cpu_ops()` 将保证是“原子”的，因为没有其他CPU可以访问这些数据结构。有时你可能需要远程访问每个CPU的数据结构。通常情况下，进行远程读取操作是安全的，并且这种操作经常被用来汇总计数器。然而，远程写入操作可能会有问题，因为 `this_cpu` 操作不具有锁语义。远程写入可能与 `this_cpu` 的读/改/写（Read-Modify-Write, RMW）操作发生冲突。

强烈不建议对每个CPU的数据结构进行远程写入访问，除非绝对必要。请考虑使用中断请求（IPI）来唤醒远程CPU，并对其每个CPU区域进行更新。

为了远程访问每个CPU的数据结构，通常使用 `per_cpu_ptr()` 函数：

```c
DEFINE_PER_CPU(struct data, datap);

struct data *p = per_cpu_ptr(&datap, cpu);
```

这明确表示我们正准备远程访问一个每个CPU的区域。

你也可以这样将 `datap` 的偏移量转换为地址：

```c
struct data *p = this_cpu_ptr(&datap);
```

但是，通过 `this_cpu_ptr` 计算出的指针传递给其他CPU是非常罕见的，应当避免这样做。

远程访问通常只用于读取另一个CPU的每个CPU数据的状态。写入访问可能会导致独特的问题，因为每个CPU的操作具有宽松的同步要求。

下面的例子说明了写操作的一些问题，这是因为两个每个CPU的变量共享同一个缓存行，但宽松的同步仅应用于其中一个更新缓存行的过程。

考虑以下例子：

```c
struct test {
    atomic_t a;
    int b;
};

DEFINE_PER_CPU(struct test, onecacheline);
```

如果字段 `'a'` 从一个处理器远程更新，而本地处理器使用 `this_cpu` 操作来更新字段 `b`，人们会担心会发生什么。需要注意的是，应避免同时访问同一缓存行内的数据。在这种情况下，可能还需要昂贵的同步机制。一般推荐在这样的场景中使用中断请求（IPI），而不是对另一个处理器的每个CPU区域进行远程写入。
即使在远程写入操作很少发生的情况下，请记住，一次远程写入会将最有可能访问该缓存行的处理器上的缓存行驱逐出去。如果处理器醒来时发现其所负责的CPU区域中缺少本地缓存行，其性能以及唤醒时间将会受到影响。
