### 错误序列类型 (`errseq_t`)

`errseq_t` 是一种记录错误并在一个地方允许任意数量的“订阅者”判断自上次采样以来是否发生变化的方法。
最初的应用场景是跟踪文件同步系统调用（如 `fsync`、`fdatasync`、`msync` 和 `sync_file_range`）中的错误，但也可以用于其他情况。
它被实现为一个无符号32位值。低位被指定用来存储错误码（介于1到`MAX_ERRNO`之间）。高位用作计数器。这是通过原子操作而非加锁来完成的，以便这些函数可以从任何上下文调用。
需要注意的是，如果频繁记录新错误，则存在碰撞的风险，因为我们只有很少的位作为计数器使用。
为了缓解这个问题，错误值与计数器之间的位用作标志，以判断自记录新值后是否已对值进行了采样。这样可以在自上次记录错误以来没有人采样时避免增加计数器。
因此，我们得到的值大致如下所示：

+--------------------------------------+----+------------------------+
| 31..13                               | 12 | 11..0                  |
+--------------------------------------+----+------------------------+
| 计数器                              | SF | 错误号                 |
+--------------------------------------+----+------------------------+

总体思路是让“观察者”采样 `errseq_t` 值并将其作为运行游标保持。该值以后可以用来判断自采样以来是否发生了新的错误，并且原子性地记录检查时的状态。这使得我们可以在一个地方记录错误，然后有多个“观察者”能够判断自上次检查以来值是否已变化。
新的 `errseq_t` 应始终清零。全零的 `errseq_t` 值是一个特殊（但常见）的情况，表示从未发生过错误。全零值可以作为“纪元”，如果想知道自初始化以来是否设置过错误。

### API 使用

让我给你讲个故事，关于一个小职员的故事。总的来说，他是个好员工，但公司有点……管理层过多。今天他要向77位主管汇报工作，而明天“大老板”会从外地来，肯定也会考验这个可怜的家伙。
他们都给他分配工作——多得他记不住是谁给他的，但这并不是什么大问题。主管们只想知道他是否完成了他们交给他的所有工作以及自上次询问以来是否犯了错误。
他可能在主管没有实际交给他任务的时候犯了错，但他无法记住那么详细的信息，他只能记住最近犯下的错误。
这是我们的`worker_drone`表示方法：

    ```c
    struct worker_drone {
            errseq_t        wd_err; /* 用于记录错误 */
    };
    ```

每天，`worker_drone`都以一张白纸开始：

    ```c
    struct worker_drone wd;

    wd.wd_err = (errseq_t)0;
    ```

监管者进来并为这一天获取初始读数。他们不关心在他们的监控开始之前发生的事情：

    ```c
    struct supervisor {
            errseq_t        s_wd_err; /* 私有的“游标”用于 wd_err */
            spinlock_t      s_wd_err_lock; /* 保护 s_wd_err */
    }

    struct supervisor       su;

    su.s_wd_err = errseq_sample(&wd.wd_err);
    spin_lock_init(&su.s_wd_err_lock);
    ```

现在他们开始给他分配任务。每隔几分钟，他们会让他完成迄今为止分配给他的所有工作。然后他们问他是否在这些工作中犯了错误：

    ```c
    spin_lock(&su.s_wd_err_lock);
    err = errseq_check_and_advance(&wd.wd_err, &su.s_wd_err);
    spin_unlock(&su.s_wd_err_lock);
    ```

到目前为止，这只会返回 0。
这家公司的老板们非常吝啬，给了他一些次品设备来完成工作。偶尔设备会出现故障，导致他犯错。他会沉重地叹一口气，并记录下来：

    ```c
    errseq_set(&wd.wd_err, -EIO);
    ```

然后继续工作。监管者最终会再次轮询，并且在下一次检查时每个人都会得到这个错误。随后的调用将返回 0，直到另一个错误被记录，在这种情况下，该错误将向每个人报告一次。
值得注意的是，监管者无法知道他犯了多少错误，只知道自上次检查以来是否犯了错误，以及最新的记录值。
有时大老板会进来抽查，并要求工人为他做一项一次性的工作。他不像监管者那样全天候盯着工人，但他确实需要知道在他这项工作处理过程中是否发生了错误。
他可以简单地从工人那里取样当前的`errseq_t`，然后使用它来判断之后是否发生了错误：

    ```c
    errseq_t since = errseq_sample(&wd.wd_err);
    /* 提交一些工作并等待其完成 */
    err = errseq_check(&wd.wd_err, since);
    ```

因为他将在那之后丢弃“since”，所以在这里不需要推进它。他也不需要任何锁定，因为它是不可被其他人使用的。
### `errseq_t` 游标更新序列化

请注意，`errseq_t` API 并不在`check_and_advance`操作期间保护`errseq_t`游标。只有规范的错误代码是原子处理的。在多个任务可能同时使用相同的`errseq_t`游标的情况下，重要的是要序列化对该游标的更新。
如果不这样做，游标可能会倒退，导致同一错误被报告多次。
因此，通常先执行`errseq_check`来查看是否有变化，然后再在获取锁后执行`errseq_check_and_advance`是有利的。例如：

    ```c
    if (errseq_check(&wd.wd_err, READ_ONCE(su.s_wd_err))) {
            /* su.s_wd_err 受 s_wd_err_lock 保护 */
            spin_lock(&su.s_wd_err_lock);
            err = errseq_check_and_advance(&wd.wd_err, &su.s_wd_err);
            spin_unlock(&su.s_wd_err_lock);
    }
    ```

这避免了在没有发生变化的常见情况下使用自旋锁。
### 函数

.. kernel-doc:: lib/errseq.c
