### SPDX 许可证标识符：GPL-2.0+

#### 浮点 API
==================

内核代码通常禁止使用浮点（FP）寄存器或指令，包括 C 语言中的 `float` 和 `double` 数据类型。这条规则减少了系统调用的开销，因为内核不需要保存和恢复用户空间的浮点寄存器状态。
然而，偶尔驱动程序或库函数可能需要包含 FP 代码。这种支持是通过将包含 FP 代码的函数隔离到单独的编译单元（一个单独的源文件），并在调用这些函数前后保存/恢复 FP 寄存器状态来实现的。这创建了“临界区”，即浮点使用的临界区。
进行这种隔离的原因是防止编译器在这些临界区之外生成涉及 FP 寄存器的代码。编译器有时会使用 FP 寄存器来优化内联的 `memcpy` 或变量赋值，因为浮点寄存器可能比通用寄存器更宽。
内核中浮点代码的可用性取决于具体架构。
此外，由于单一内核可能被配置为支持既有浮点运算单元又没有浮点运算单元的平台，因此必须在构建时和运行时检查 FPU 的可用性。
许多架构实现了来自 `linux/fpu.h` 的通用内核浮点 API，如下所述。一些其他架构实现了它们自己独特的 API，这些 API 在其他地方有单独的文档。

#### 构建时 API
------------------

如果启用了选项 `ARCH_HAS_KERNEL_FPU_SUPPORT`，则可以构建浮点代码。对于 C 代码，此类代码必须放在单独的文件中，并且该文件的编译标志必须按照以下模式进行调整：

```makefile
CFLAGS_foo.o += $(CC_FLAGS_FPU)
CFLAGS_REMOVE_foo.o += $(CC_FLAGS_NO_FPU)
```

架构应该在其顶层 Makefile 中根据需要定义这两个变量中的一个或两个。例如：

```makefile
CC_FLAGS_FPU := -mhard-float
```

或者：

```makefile
CC_FLAGS_NO_FPU := -msoft-float
```

正常的内核代码假定使用等同于 `CC_FLAGS_NO_FPU` 的标志。

#### 运行时 API
-------------------

运行时 API 提供在 `linux/fpu.h` 中。这个头文件不能从实现 FP 代码的文件（那些已经调整过其编译标志的文件）中包含。相反，当定义 FP 临界区时，它必须被包含进来。

.. c:function:: bool kernel_fpu_available(void)

        此函数报告此 CPU 或平台上是否可以使用浮点代码。此函数返回的值不期望在运行时发生变化，因此只需调用一次即可，不必在每个临界区之前都调用。
```c
/* 函数:: void kernel_fpu_begin(void)
   void kernel_fpu_end(void)

   这些函数创建了一个浮点数临界区。只有在先前调用
   `kernel_fpu_available()` 返回 `true` 之后，才允许调用
   `kernel_fpu_begin()`。这些函数仅保证可以从（可抢占或不可抢占）进程上下文中被调用。

   在临界区内可能会禁用抢占，因此应该尽量减少临界区的大小。
   它们不需要是可重入的。如果调用者期望嵌套临界区，则必须实现自己的引用计数机制。*/
```

这里的注释翻译为中文大致如下：

```c
/* 函数:: void kernel_fpu_begin(void)
   void kernel_fpu_end(void)

   这些函数用于创建一个浮点运算的临界区。只有在之前调用
   `kernel_fpu_available()` 返回 `true` 之后，才能调用
   `kernel_fpu_begin()`。这些函数仅保证可以在（可抢占或不可抢占）进程上下文中被调用。

   在临界区内可能会禁用抢占，因此应当尽量减小临界区的范围。
   它们不保证是可重入的。如果调用者期望嵌套临界区，则必须实现自己的引用计数机制。*/
```
