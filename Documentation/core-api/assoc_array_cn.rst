======================
通用关联数组实现
======================

概述
========

此关联数组实现是一个对象容器，具有以下特性：

1. 对象是不透明指针。实现不关心它们指向何处（如果有的话）或指向什么（如果有任何内容）
.. 注意::

      指向对象的指针_必须_在最低有效位为零
2. 对象无需包含供数组使用的链接块。这
   允许一个对象可以同时位于多个数组中
相反，数组由指向对象的元数据块组成
3. 对象需要索引键以便在数组中定位它们
4. 索引键必须唯一。插入与数组中已存在的键相同的对象会替换旧的对象
5. 索引键可以是任意长度，并且可以具有不同的长度
6. 索引键应该尽早编码长度，在出现由于长度差异导致的变化之前
7. 索引键可以包含散列以将对象分散到数组中的各个位置
8. 可以遍历数组。对象不一定按照键的顺序输出
9. 可以在修改数组的同时进行迭代，前提是迭代器持有 RCU 读锁。但是，在这种情况下，某些对象可能会被多次看到。如果这是一个问题，则迭代器应锁定以防止修改。不过，除非被删除，否则不会遗漏任何对象。
10. 可以通过索引键查找数组中的对象。
11. 在持有 RCU 读锁的情况下，可以在修改数组的同时查找对象。

实现上内部使用了一个由 16 指针节点构成的树，这些节点按照类似径向树的方式，根据索引键中的每个层级的十六进制位（nibbles）进行索引。为了提高内存效率，可以设置快捷方式来跳过一系列单个元素的节点。此外，节点会在节点内未使用的空间中存储叶子对象指针，而不是每次都额外分支，直到需要将对象添加到已满节点时才这样做。

公共API
========

公共API可以在 `<linux/assoc_array.h>` 中找到。关联数组基于以下结构：

```c
struct assoc_array {
        ..
};
```

要选择使用这段代码，需要启用 `CONFIG_ASSOCIATIVE_ARRAY`，方法如下：

```sh
./script/config -e ASSOCIATIVE_ARRAY
```

编辑脚本
--------

插入和删除函数会生成一个“编辑脚本”，稍后可应用该脚本来执行更改，而无需担心 `ENOMEM` 的风险。这样可以保留预分配的元数据块，这些元数据块将安装在内部树中，并跟踪将在应用脚本时从树中移除的元数据块。

这也是用于跟踪脚本应用后死块和死对象的方法，以便稍后释放它们。释放操作是在经过 RCU 宽限期之后进行的，从而允许在 RCU 读锁下继续访问。

编辑脚本对外表现为类型为：

```c
struct assoc_array_edit;
```

的指针。处理编辑脚本有两种函数：

1. 应用编辑脚本：

```c
void assoc_array_apply_edit(struct assoc_array_edit *edit);
```

这将执行编辑函数，并插入各种写屏障，以允许在 RCU 读锁下继续访问。然后将编辑脚本传递给 `call_rcu()` 来释放它以及它指向的所有已死内容。
2. 取消编辑脚本：

```c
void assoc_array_cancel_edit(struct assoc_array_edit *edit);
```

这会立即释放编辑脚本和所有预分配的内存。如果是插入操作，此函数不会释放新对象，而是需要调用者来释放。

这些函数保证不会失败。
操作表
------
各种函数需要一个操作表：

    struct assoc_array_ops {
            ..
    };

这指向了一系列的方法，所有这些方法都需要被提供：

1. 从调用者数据中获取索引键的一部分：

    unsigned long (*get_key_chunk)(const void *index_key, int level);

此函数应返回由`level`参数给出的*位*位置开始的调用者提供的索引键的一部分。`level`参数将是`ASSOC_ARRAY_KEY_CHUNK_SIZE`的倍数，并且该函数应该返回`ASSOC_ARRAY_KEY_CHUNK_SIZE`位。不可能出现错误。
2. 获取对象索引键的一部分：

    unsigned long (*get_object_key_chunk)(const void *object, int level);

与前一个函数类似，但其数据是从数组中的对象获取的，而不是从调用者提供的索引键。
3. 判断是否是我们要找的对象：

    bool (*compare_object)(const void *object, const void *index_key);

将对象与索引键进行比较，如果匹配则返回`true`，如果不匹配则返回`false`。
4. 比较两个对象的索引键：

    int (*diff_objects)(const void *object, const void *index_key);

返回指定对象的索引键与给定索引键不同的位位置，或者如果它们相同则返回-1。
5. 释放一个对象：

    void (*free_object)(void *object);

释放指定的对象。请注意，这可能在调用`assoc_array_apply_edit()`之后的一个RCU宽限期中被调用，因此在卸载模块时可能需要`synchronize_rcu()`。

操作函数
--------
有多个用于操作关联数组的函数：

1. 初始化一个关联数组：

    void assoc_array_init(struct assoc_array *array);

此函数初始化关联数组的基本结构。它不会失败。
2. 在关联数组中插入或替换一个对象：

    struct assoc_array_edit *
    assoc_array_insert(struct assoc_array *array,
                       const struct assoc_array_ops *ops,
                       const void *index_key,
                       void *object);

此函数将给定的对象插入数组。请注意，指针的最低有效位必须为零，因为它被用来内部标记指针类型。
如果已经存在对应于该键的对象，则它将被新对象替换，并且旧对象将自动被释放。
`index_key`参数应包含索引键信息，并在调用操作表中的方法时传递给它们。
1. 此函数不对数组本身进行任何修改，而是返回一个必须应用的编辑脚本。在内存不足错误的情况下返回 ``-ENOMEM``。
调用者应针对其他修改数组的操作者独占加锁。

3. 从关联数组中删除一个对象：

    ```
    struct assoc_array_edit * 
    assoc_array_delete(struct assoc_array *array,
                       const struct assoc_array_ops *ops,
                       const void *index_key);
    ```

此函数从数组中删除与指定数据匹配的对象。
参数 `index_key` 应包含索引键信息，并且在调用操作表中的方法时传递给这些方法。
此函数不对数组本身进行任何修改，而是返回一个必须应用的编辑脚本。在内存不足错误的情况下返回 ``-ENOMEM``。如果指定的对象不在数组中，则返回 ``NULL``。
调用者应针对其他修改数组的操作者独占加锁。

4. 从关联数组中删除所有对象：

    ```
    struct assoc_array_edit *
    assoc_array_clear(struct assoc_array *array,
                      const struct assoc_array_ops *ops);
    ```

此函数从关联数组中删除所有对象，并使其完全为空。
此函数不对数组本身进行任何修改，而是返回一个必须应用的编辑脚本。在内存不足错误的情况下返回 ``-ENOMEM``。
调用者应针对其他修改数组的操作者独占加锁。

5. 销毁关联数组并删除所有对象：

    ```
    void assoc_array_destroy(struct assoc_array *array,
                             const struct assoc_array_ops *ops);
    ```

此函数销毁关联数组的内容并使其完全为空。不允许其他线程在该函数销毁数组的同时持有 RCU 读锁遍历数组，因为释放内存时不执行任何 RCU 延迟操作——这将需要分配内存。
调用者应独占锁定以防止其他修改器和访问器对数组进行操作。

6. 回收关联数组：

    ```c
    int assoc_array_gc(struct assoc_array *array,
                       const struct assoc_array_ops *ops,
                       bool (*iterator)(void *object, void *iterator_data),
                       void *iterator_data);
    ```

此函数遍历关联数组中的对象，并将每个对象传递给`iterator()`。如果`iterator()`返回`true`，则保留该对象；如果返回`false`，则释放该对象。如果`iterator()`函数返回`true`，它必须在返回之前对对象执行适当的引用计数递增。
内部树结构会在遍历过程中尽可能地压缩，以减少其中的节点数量。
`iterator_data`直接传递给`iterator()`，除此以外，该函数忽略`iterator_data`。
该函数成功时返回`0`，内存不足时返回`-ENOMEM`。
在此函数执行期间，其他线程可以在RCU读锁下遍历或搜索数组。调用者应独占锁定以防止其他对数组的修改。
访问函数
-----------

有两种访问关联数组的函数：

1. 遍历关联数组中的所有对象：

    ```c
    int assoc_array_iterate(const struct assoc_array *array,
                            int (*iterator)(const void *object,
                                            void *iterator_data),
                            void *iterator_data);
    ```

此函数将数组中的每个对象传递给迭代回调函数。
`iterator_data`是该函数的私有数据。
即使数组正在被修改，也可以使用此函数（只要持有RCU读锁）。在这种情况下，迭代函数可能会看到某些对象两次。如果这是个问题，则应锁定修改操作。然而，迭代算法不应该错过任何对象。
如果没有对象在数组中，该函数将返回`0`；否则，它将返回最后一次调用迭代函数的结果。一旦任何迭代函数调用导致非零返回值，迭代立即停止。
### 在关联数组中查找对象：

    void *assoc_array_find(const struct assoc_array *array,
                           const struct assoc_array_ops *ops,
                           const void *index_key);

此函数直接遍历数组的内部树，直到找到由索引键指定的对象。
可以在修改数组的同时使用此函数（前提是持有RCU读锁）。
如果找到了对象，则返回该对象（并将`*_type`设置为对象类型），如果未找到对象，则返回`NULL`。

#### 索引键形式

索引键可以是任何形式，但由于算法不知道键的长度，强烈建议在任何长度差异影响比较之前，在索引键中尽早包含其长度。
这将导致具有不同长度键的叶节点分散开，并使具有相同长度键的叶节点聚集在一起。
还建议索引键以其余键的哈希值开头，以最大限度地在整个键空间内分散数据。
分散得越好，内部树就会越宽且层级更少。
即使分散效果不佳也不是太大问题，因为存在快捷方式，并且节点可以包含叶节点和元数据指针的混合。
索引键按机器字长的块进行读取。每个块进一步细分为每层一个四分位（4位）。因此，在32位CPU上，这适用于8层；而在64位CPU上，则适用于16层。除非分散效果非常差，否则不太可能需要使用任何特定索引键的多于一个字的数据。

### 内部工作原理

关联数组数据结构具有一个内部树。此树由两种类型的元数据块组成：节点和快捷方式。
一个节点是由多个槽组成的数组。每个槽可以包含以下四种之一：

* 一个NULL指针，表示该槽为空
* 指向一个对象（叶子）的指针
* 指向下一个层级节点的指针
* 指向一个快捷方式的指针

基本的内部树布局
------------------

暂时忽略快捷方式，节点形成一个多级树结构。索引键空间被树中的节点严格细分，并且节点位于固定的层级上。例如：

```
层级：0               1               2               3
    =============== =============== =============== ===============
                                                        节点 D
                        节点 B          节点 C  +------>+---+
                +------>+---+   +------>+---+   |       | 0 |
        节点 A  |       | 0 |   |       | 0 |   |       +---+
        +---+   |       +---+   |       +---+   |       :   :
        | 0 |   |       :   :   |       :   :   |       +---+
        +---+   |       +---+   |       +---+   |       | f |
        | 1 |---+       | 3 |---+       | 7 |---+       +---+
        +---+           +---+           +---+
        :   :           :   :           | 8 |---+
        +---+           +---+           +---+   |       节点 E
        | e |---+       | f |           :   :   +------>+---+
        +---+   |       +---+           +---+           | 0 |
        | f |   |                       | f |           +---+
        +---+   |                       +---+           :   :
                |       节点 F                          +---+
                +------>+---+                           | f |
                        | 0 |           节点 G          +---+
                        +---+   +------>+---+
                        :   :   |       | 0 |
                        +---+   |       +---+
                        | 6 |---+       :   :
                        +---+           +---+
                        :   :           | f |
                        +---+           +---+
                        | f |
                        +---+
```

在上面的例子中，共有7个节点（A-G），每个节点有16个槽（0-f）
假设树中没有其他元数据节点，键空间将这样划分：

```
KEY PREFIX      节点
==========      ====
137*            D
138*            E
13[0-69-f]*     C
1[0-24-f]*      B
e6*             G
e[0-57-f]*      F
[02-df]*        A
```

因此，具有以下示例索引键的键将在适当的节点中找到：

```
INDEX KEY       PREFIX  节点
=============== ======= ====
13694892892489  13      C
13795289025897  137     D
13889dde88793   138     E
138bbb89003093  138     E
1394879524789   12      C
1458952489      1       B
9431809de993ba  -       A
b4542910809cd   -       A
e5284310def98   e       F
e68428974237    e6      G
e7fffcbd443     e       F
f3842239082     -       A
```

为了节省内存，如果一个节点可以容纳其键空间部分中的所有叶子，则该节点将包含所有这些叶子，并且不会有元数据指针——即使某些叶子希望处于同一个槽位。节点可以包含叶子和元数据指针的异构混合。元数据指针必须位于与它们的键空间子区域匹配的槽中。叶子可以位于任何未被元数据指针占用的槽中。可以保证的是，节点中的叶子不会与元数据指针占用的槽相匹配。如果存在元数据指针，则任何与元数据键前缀匹配的叶子都必须位于元数据指针指向的子树中。

在上述示例列表的索引键中，节点A将包含：

```
SLOT    CONTENT         INDEX KEY (PREFIX)
====    =============== ==================
1       指向节点 B 的指针   1*
any     叶子            9431809de993ba
any     叶子            b4542910809cd
e       指向节点 F 的指针   e*
any     叶子            f3842239082
```

而节点B则包含：

```
3	指向节点 C 的指针	13*
any	叶子		1458952489
```

快捷方式
---------

快捷方式是跳过一段键空间的元数据记录。快捷方式取代了一系列从低层到高层的单占用节点。快捷方式的存在是为了节省内存并加快遍历速度。
树的根可能是快捷方式——例如，假设树中至少有17个节点，它们的键前缀都是`1111`。插入算法将插入一个快捷方式，以便一步跨越`1111`键空间，并到达第四层，在这一层上这些键实际上变得不同。
### 分裂与合并节点

每个节点的最大容量为16个叶节点和元数据指针。如果插入算法发现尝试在一个节点中插入第17个对象，那么该节点将被分裂，确保至少有两个具有相同键段的叶节点位于一个单独的节点中，这个节点以该共同键段为根。

如果一个满节点中的叶节点与要插入的新叶节点足够相似，则会在树中插入一条快捷方式。

当以某个节点为根的子树中的对象数量减少到16个或更少时，该子树将被压缩至单个节点，并且这种压缩会尽可能地向根节点推进。

### 非递归迭代

每个节点和快捷方式都包含指向其父节点及其在父节点中所处槽位编号的回溯指针。非递归迭代利用这些信息沿树向上移动，前往父节点的第N+1个槽位以确保无需使用栈即可进行前进。

然而，这些回溯指针使得同时修改和迭代变得复杂。

### 同时修改与迭代

有几个情况需要考虑：

1. **简单的插入/替换**：这仅涉及在屏障后用新叶节点的指针替换空指针或旧匹配叶节点的指针。除此之外，元数据块不会改变。旧的叶节点将在RCU宽限期之后才被释放。
   
2. **简单的删除**：这仅涉及清除旧的匹配叶节点。除此之外，元数据块不会改变。旧的叶节点将在RCU宽限期之后才被释放。

3. **插入替换我们尚未进入的部分子树**：这可能涉及到替换子树的一部分，但这不会影响迭代，因为我们还没有到达指向它的指针，并且祖先块不会被替换（它们的布局不会改变）。

4. **替换正在处理中的节点的插入**：这不是问题，因为我们已经越过了锚定点，并且直到跟随回溯指针时才会切换到新的布局——这时我们已经检查了被替换节点中的所有叶节点（我们在跟随任何元数据指针之前遍历一个节点中的所有叶节点）。
然而，我们可能会重新看到一些被分割到一个新分支中的叶子节点，这个新分支的位置比我们之前所在的位置要远。
5. 当我们处理依赖分支时，用新的节点替换原有节点
这种情况直到我们跟随回指针才会对我们产生影响。这与情况（4）类似。
6. 删除操作导致我们下方的分支被合并。这不会对我们产生影响，因为回指针会将我们带回新节点的父节点，在我们能看到新节点之前。整个被合并的子树会被原封不动地丢弃，并且它仍然位于相同的槽位上，所以我们不应该再次处理它，因为我们将会回到槽位+1的位置。
.. note::
   
   在某些情况下，我们需要同时改变节点的父指针和父槽指针（例如，我们在它前面插入了另一个节点并将其向上移动了一个层级）。如果不锁定以防止读取操作，我们无法做到这一点——因此我们也必须替换那个节点。
然而，当我们正在将一个快捷方式转换为节点时，这不是一个问题，因为快捷方式只有一个槽位，所以在反向遍历一个快捷方式时不会使用父槽号。这意味着可以先更改槽号——前提是使用适当的屏障来确保在读取回指针之后读取父槽号。
过时的块和叶子节点会在RCU恩典期过后被释放，因此只要任何进行遍历或迭代的操作持有RCU读锁，旧的结构就不会消失。
