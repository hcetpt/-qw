### 内存分配指南

Linux提供了多种内存分配API。您可以使用`kmalloc`或`kmem_cache_alloc`系列函数来分配小块内存，使用`vmalloc`及其派生函数来分配大的虚拟连续区域，或者直接从页面分配器请求页面使用`alloc_pages`。此外，还可以使用更专业的分配器，例如`cma_alloc`或`zs_malloc`。
大多数内存分配API使用GFP标志来指定如何分配这些内存。GFP是“get free pages”的缩写，代表底层的内存分配函数。
各种内存分配API与众多GFP标志的结合使得“我应该如何分配内存？”这个问题并不容易回答，不过在大多数情况下，您可能会使用：

```c
kzalloc(<size>, GFP_KERNEL);
```

当然，在某些情况下需要使用其他内存分配API和不同的GFP标志。

#### Get Free Page 标志

GFP标志控制着分配器的行为。它们指定了可以使用的内存区域、分配器应该多努力寻找空闲内存以及内存是否可以被用户空间访问等。在`:ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`中提供了关于GFP标志及其组合的参考文档，下面简要概述了这些标志的推荐使用方法：

- **大多数情况下**，`GFP_KERNEL`就是你需要的。内核数据结构、DMA可访问的内存、inode缓存等所有这些类型的内存分配都可以使用`GFP_KERNEL`。需要注意的是，使用`GFP_KERNEL`意味着会启用`GFP_RECLAIM`，这意味着在内存压力下可能会触发直接回收；调用上下文必须允许睡眠。
- **如果内存分配是在原子上下文中进行的**（例如中断处理程序），则应使用`GFP_NOWAIT`。这个标志阻止直接回收和I/O或文件系统操作。因此，在内存压力下，`GFP_NOWAIT`分配很可能失败。那些有合理备选方案的分配应该使用`GFP_NOWARN`。
- **如果你认为有必要访问内存储备，并且除非分配成功否则内核将承受很大压力**，你可以使用`GFP_ATOMIC`。
- **由用户空间触发的不可信分配**应当受到kmem会计的管理，并且必须设置`__GFP_ACCOUNT`位。对于需要记账的`GFP_KERNEL`分配，有一个方便的快捷方式`GFP_KERNEL_ACCOUNT`。
- **用户空间的分配**应当使用`GFP_USER`、`GFP_HIGHUSER`或`GFP_HIGHUSER_MOVABLE`中的一个标志。标志名越长，其限制就越少。
  - `GFP_HIGHUSER_MOVABLE`不要求分配的内存可以直接被内核访问，并暗示数据是可以移动的。
  - `GFP_HIGHUSER`意味着分配的内存不可移动，但也不要求可以直接被内核访问。一个例子可能是硬件分配，它直接将数据映射到用户空间，但没有地址限制。
``GFP_USER`` 表示分配的内存不可移动，并且必须可以直接被内核访问。
您可能会注意到现有代码中有很多分配指定了 ``GFP_NOIO`` 或 ``GFP_NOFS``。历史上，它们被用来防止直接内存回收回调到文件系统或 I/O 路径并因已持有的资源阻塞而导致的递归死锁。自 4.12 版本以来，解决此问题的首选方法是使用新的作用域 API，这些 API 在 :ref:`文档/core-api/gfp_mask-from-fs-io.rst <gfp_mask_from_fs_io>` 中进行了描述。
其他遗留的 GFP 标志包括 ``GFP_DMA`` 和 ``GFP_DMA32``。它们用于确保分配的内存可以被具有有限寻址能力的硬件访问。因此，除非您正在为具有此类限制的设备编写驱动程序，否则请避免使用这些标志。即使对于具有限制的硬件，也更倾向于使用 `dma_alloc*` API。

### GFP 标志与回收行为

内存分配可能触发直接或后台回收，了解页分配器为满足请求将付出多大努力是有用的。
* ``GFP_KERNEL & ~__GFP_RECLAIM`` — 不尝试释放任何内存的乐观分配。这是最轻量级的模式，甚至不会启动后台回收。应谨慎使用，因为它可能会耗尽内存，导致下一个用户触发更激进的回收。
* ``GFP_KERNEL & ~__GFP_DIRECT_RECLAIM``（或 ``GFP_NOWAIT``）— 不从当前上下文尝试释放任何内存的乐观分配，但如果区域低于低水位线，则可以唤醒 kswapd 来回收内存。可用于原子上下文或当请求是一种性能优化且存在较慢路径的备选方案时。
* ``(GFP_KERNEL|__GFP_HIGH) & ~__GFP_DIRECT_RECLAIM`` （即 ``GFP_ATOMIC``）— 不睡眠分配，具有昂贵的备选方案，因此它可以访问一部分内存储备。通常用于中断/下半部上下文中，具有昂贵的较慢路径备选方案。
* ``GFP_KERNEL`` — 允许后台和直接回收，并使用**默认**的页分配器行为。这意味着不昂贵的分配请求基本上不会失败，但不能保证这种行为，因此调用者需要适当检查失败情况（例如，当前允许 OOM 杀手受害者失败）。
* ``GFP_KERNEL | __GFP_NORETRY`` — 覆盖默认分配器行为，所有分配请求早期失败而不是触发破坏性的回收（在此实现中为一轮回收）。不会调用 OOM 杀手。
* ``GFP_KERNEL | __GFP_RETRY_MAYFAIL`` - 覆盖默认分配器的行为，使所有的分配请求尽最大努力尝试。如果回收无法取得任何进展，则该请求将失败。不会触发内存不足（OOM）杀手。
* ``GFP_KERNEL | __GFP_NOFAIL`` - 覆盖默认分配器的行为，并且所有分配请求将会无限循环直到成功为止。对于较大的分配请求，这可能会非常危险。

选择内存分配器
==========================

最直接的内存分配方法是使用`kmalloc()`家族中的函数。为了安全起见，最好使用像`kzalloc()`这样的函数，这些函数会将分配的内存设置为零。如果你需要为数组分配内存，可以使用`kmalloc_array()`和`kcalloc()`辅助函数。`struct_size()`、`array_size()` 和 `array3_size()` 这些辅助函数可用于安全地计算对象大小，避免溢出问题。

通过`kmalloc`分配的块的最大尺寸是有限制的。实际限制取决于硬件和内核配置，但通常推荐使用`kmalloc`来分配小于页大小的对象。

使用`kmalloc`分配的块地址至少对齐到`ARCH_KMALLOC_MINALIGN`字节。对于2的幂次方大小，对齐保证至少也是该大小。对于其他大小，对齐保证至少是该大小的最大2的幂次方除数。

使用`kmalloc()`分配的块可以通过`krealloc()`进行调整大小。类似地，对于数组调整大小，提供了`krealloc_array()`辅助函数。

对于大块内存的分配，你可以使用`vmalloc()`和`vzalloc()`，或者直接从页分配器请求页面。通过`vmalloc`及其相关函数分配的内存并不是物理连续的。

如果你不确定分配大小是否适合`kmalloc`，可以考虑使用`kvmalloc()`及其衍生函数。它会首先尝试使用`kmalloc`分配内存，如果失败，则改用`vmalloc`重试。使用`kvmalloc`时有一些关于GFP标志的限制，请参阅`kvmalloc_node()`的参考文档。需要注意的是，`kvmalloc`返回的内存可能不是物理连续的。

如果你需要分配许多相同的对象，可以使用slab缓存分配器。在使用之前，需要使用`kmem_cache_create()`或`kmem_cache_create_usercopy()`设置缓存。如果缓存的一部分可能会被复制到用户空间，则应使用第二个函数。
创建缓存后，可以使用 `kmem_cache_alloc()` 及其便捷封装函数从该缓存分配内存。
当分配的内存不再需要时，必须将其释放。
通过 `kmalloc` 分配的对象可以通过 `kfree` 或 `kvfree` 释放。通过 `kmem_cache_alloc` 分配的对象可以通过 `kmem_cache_free`、`kfree` 或 `kvfree` 释放，其中后两种可能更方便，因为不需要 kmem_cache 指针。
对于批量 (_bulk) 和 RCU (_rcu) 版本的释放函数，同样的规则适用。
通过 `vmalloc` 分配的内存可以通过 `vfree` 或 `kvfree` 释放。
通过 `kvmalloc` 分配的内存可以通过 `kvfree` 释放。
由 `kmem_cache_create` 创建的缓存仅在首先释放所有已分配对象后，才应该使用 `kmem_cache_destroy` 进行释放。
