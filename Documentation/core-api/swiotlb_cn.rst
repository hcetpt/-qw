### SPDX 许可证标识符：GPL-2.0

#### DMA 和 swiotlb

swiotlb 是 Linux 内核 DMA 层使用的一种内存缓冲分配器。它通常用于当进行 DMA 的设备由于硬件限制或其他需求无法直接访问目标内存缓冲区的情况。在这种情况下，DMA 层调用 swiotlb 分配一个符合限制条件的临时内存缓冲区。DMA 操作针对这个临时内存缓冲区进行，而 CPU 负责在临时缓冲区和原始的目标内存缓冲区之间复制数据。这种做法通常被称为“中转缓冲”，而临时内存缓冲区则被称为“中转缓冲区”。

设备驱动程序不会直接与 swiotlb 进行交互。相反，驱动程序会告知 DMA 层其所管理设备的 DMA 属性，并在配置设备执行 DMA 时使用标准的 DMA 映射、取消映射和同步 API。这些 API 根据设备的 DMA 属性和内核范围内的设置来确定是否需要中转缓冲。如果需要，DMA 层会管理中转缓冲区的分配、释放和同步操作。因为 DMA 属性是按设备设置的，系统中的某些设备可能需要使用中转缓冲，而其他设备则不需要。

由于 CPU 需要在中转缓冲区和原始的目标内存缓冲区之间复制数据，因此使用中转缓冲比直接对原始内存缓冲区进行 DMA 操作要慢，而且消耗更多的 CPU 资源。因此，只有在提供 DMA 功能所必需的情况下才会使用中转缓冲。

#### 使用场景

swiotlb 最初是为了处理具有寻址限制的设备的 DMA 操作而创建的。随着物理内存大小超过 4 GiB，一些设备只能提供 32 位 DMA 地址。通过将中转缓冲区内存分配在 4 GiB 线之下，这些有寻址限制的设备仍然可以工作并执行 DMA 操作。

最近，为了支持机密计算（CoCo）虚拟机，其中虚拟机的内存默认被加密且不可由主机的虚拟机监视器（VMM）访问，所有 DMA I/O 都必须强制使用中转缓冲。中转缓冲区内存被设置为未加密状态。主机对中转缓冲区内存执行 DMA I/O 操作，而 Linux 内核的 DMA 层执行“同步”操作以触发 CPU 将数据从原始目标缓冲区复制到中转缓冲区或反之。这种 CPU 复制过程架起了加密内存和非加密内存之间的桥梁。这种方法使得设备驱动程序可以在 CoCo 虚拟机中“正常运行”，无需对处理内存加密复杂性的代码进行任何修改。

还有其他边缘情况也适用于中转缓冲。例如，在为被认为“不可信”的设备设置 IOMMU 映射时，该设备仅应访问包含传输数据的内存。但如果该内存只占用了 IOMMU 颗粒的一部分，则颗粒的其他部分可能会包含无关的内核数据。由于 IOMMU 的访问控制是以颗粒为单位的，不可信设备可能会访问到无关的内核数据。这个问题可以通过对 DMA 操作进行中转缓冲解决，并确保中转缓冲区中未使用的部分不包含任何无关的内核数据。

#### 核心功能

swiotlb 的主要 API 包括 `swiotlb_tbl_map_single()` 和 `swiotlb_tbl_unmap_single()`。`map` API 分配一个指定字节大小的中转缓冲区，并返回该缓冲区的物理地址。缓冲区内存是物理连续的。预期的是 DMA 层将物理内存地址映射到 DMA 地址，并将 DMA 地址返回给驱动程序以便写入设备。如果 DMA 操作指定了多个内存缓冲区段，则每个段都需要单独分配一个中转缓冲区。`swiotlb_tbl_map_single()` 总是会执行一次“同步”操作（即 CPU 复制），以初始化中转缓冲区使其内容与原始缓冲区相匹配。

`swiotlb_tbl_unmap_single()` 则执行相反的操作。如果 DMA 操作可能更新了中转缓冲区的内存，且没有设置 `DMA_ATTR_SKIP_CPU_SYNC`，那么取消映射时会执行一次“同步”操作，使 CPU 将数据从中转缓冲区复制回原始缓冲区。之后释放中转缓冲区内存。

swiotlb 还提供了与驱动程序可能在缓冲区控制权在 CPU 和设备之间转换时使用的 `dma_sync_*()` API 相对应的“同步”API。swiotlb 的“同步”API 会在原始缓冲区和中转缓冲区之间复制数据。类似于 `dma_sync_*()` API，swiotlb 的“同步”API 支持部分同步，即仅复制中转缓冲区子集的内容到原始缓冲区或反之。
核心功能约束
------------------------------
swiotlb 的 map/unmap/sync API 必须在不阻塞的情况下运行，因为它们被相应的 DMA API 调用，而这些 API 可能在不允许阻塞的上下文中运行。因此，swiotlb 分配的默认内存池必须在启动时预先分配（但请参阅下面的动态 swiotlb）。由于 swiotlb 分配需要物理上连续，所以整个默认内存池作为一个单一的连续块进行分配。
预分配默认 swiotlb 池的需求在启动时产生了一个折衷
该池应足够大以确保可以始终满足缓冲区请求，因为非阻塞要求意味着请求不能等待空间变得可用。但是，一个大的池可能会浪费内存，因为这部分预先分配的内存无法用于系统中的其他用途。这种折衷在使用缓冲区处理所有 DMA I/O 的 CoCo 虚拟机中尤为明显。这些虚拟机使用一种启发式方法将默认池大小设置为大约 6% 的内存，最大为 1GiB，这有可能非常浪费内存。
相反，启发式方法可能产生的大小不足以满足虚拟机中工作负载的 I/O 模式。下面描述的动态 swiotlb 功能可能会有所帮助，但存在局限性。更好地管理 swiotlb 默认内存池的大小仍然是一个未解决的问题。
来自 swiotlb 的单次分配限制为 IO_TLB_SIZE * IO_TLB_SEGSIZE 字节，当前定义下为 256KiB。当设备的 DMA 设置使得设备可能使用 swiotlb 时，DMA 段的最大大小必须限制在这个 256KiB。这个值通过 dma_map_mapping_size() 和 swiotlb_max_mapping_size() 传递给更高层的内核代码。如果更高层的代码未能考虑到这个限制，它可能会提出对 swiotlb 来说过大的请求，并收到“swiotlb 已满”的错误。
一个关键的设备 DMA 设置是 “min_align_mask”，这是一个 2 的幂减 1 的值，以便一些低位被设置，或者它可以为零。swiotlb 分配确保缓冲区物理地址的 min_align_mask 位与原始缓冲区地址的相同位匹配。当 min_align_mask 非零时，它可能会在缓冲区地址中产生一个“对齐偏移量”，略微减少了分配的最大大小。
这个潜在的对齐偏移量反映在 swiotlb_max_mapping_size() 返回的值中，它可能出现在如 /sys/block/<device>/queue/max_sectors_kb 等地方。例如，如果设备不使用 swiotlb，则 max_sectors_kb 可能为 512KiB 或更大。如果设备可能使用 swiotlb，则 max_sectors_kb 将为 256KiB。当 min_align_mask 非零时，max_sectors_kb 可能更小，例如 252KiB。
swiotlb_tbl_map_single() 还接受一个“alloc_align_mask”参数。此参数指定缓冲区空间的分配必须从物理地址开始，该地址的 alloc_align_mask 位被设置为零。但如果 min_align_mask 非零，则实际的缓冲区可能从更大的地址开始。
因此，在缓冲区开始之前可能存在预填充空间。同样地，缓冲区的末尾向上取整到 alloc_align_mask 边界，可能导致后填充空间。任何预填充或后填充的空间都不会由 swiotlb 代码初始化。“alloc_align_mask”参数在为不可信设备映射时由 IOMMU 代码使用。它被设置为粒度大小减 1，以便缓冲区完全从不用于任何其他目的的粒度中分配。
数据结构概念
------------------------
用于 swiotlb 缓冲区的内存是从整体系统内存中分配的一个或多个“池”。默认池在系统启动时分配，默认大小为 64MiB。可以通过内核引导行参数 "swiotlb=" 修改默认池的大小。默认大小也可能因其他条件而调整，例如在 CoCo 虚拟机中运行，如上所述。如果启用了 CONFIG_SWIOTLB_DYNAMIC，则可以在系统的生命周期后期分配额外的池。每个池都必须是一个连续的物理内存范围。默认池分配在 4GiB 物理地址线以下，以便适用于只能寻址 32 位物理内存的设备（除非架构特定代码提供了 SWIOTLB_ANY 标志）。在 CoCo 虚拟机中，池内存必须在使用 swiotlb 之前解密。
每个池被划分为大小为`IO_TLB_SIZE`的“槽”，按照当前定义，这个大小是2KiB。连续的`IO_TLB_SEGSIZE`个槽（128个槽）可以被称为一个“槽集”。当分配一个缓冲区时，它会占据一个或多个连续的槽。一个槽永远不会被多个缓冲区共享。此外，一个缓冲区必须从单个槽集中分配，这导致最大的缓冲区大小为`IO_TLB_SIZE * IO_TLB_SEGSIZE`。如果满足对齐和大小约束条件，则可以在单个槽集中共存多个较小的缓冲区。
槽也被分组为“区域”，其中的约束是一个槽集必须完全位于单个区域内。每个区域都有自己的自旋锁，在操纵该区域内的槽时必须持有这个锁。将槽分为区域避免了在大量使用swiotlb的情况下（例如在一个CoCo虚拟机中）争夺单一全局自旋锁的问题。区域的数量默认为系统中的CPU数量以实现最大并行性，但是由于一个区域不能小于`IO_TLB_SEGSIZE`个槽，可能需要将多个CPU分配到同一个区域。区域的数量也可以通过"swiotlb="内核启动参数来设置。
当分配一个缓冲区时，如果调用CPU关联的区域没有足够的空闲空间，则会依次尝试其他CPU关联的区域。对于每个尝试的区域，在尝试分配之前必须获得该区域的自旋锁，因此如果swiotlb相对繁忙，则可能会出现竞争。但是除非所有区域都没有足够的空闲空间，否则分配请求不会失败。
`IO_TLB_SIZE`、`IO_TLB_SEGSIZE`以及区域的数量都必须是2的幂次，因为代码使用位移和位掩码来进行许多计算。如果有必要，区域的数量会被向上取整为2的幂次以满足此要求。
默认的池是以`PAGE_SIZE`对齐的方式分配的。如果`swiotlb_tbl_map_single()`函数的`alloc_align_mask`参数指定了更大的对齐方式，那么每个槽集中的初始槽可能不满足`alloc_align_mask`的要求。
因为缓冲区分配不能跨越槽集边界，去掉这些初始槽实际上减小了缓冲区的最大尺寸。目前没有问题，因为`alloc_align_mask`是基于IOMMU粒度大小设置的，并且粒度不能大于`PAGE_SIZE`。但如果将来这种情况发生变化，初始池的分配可能需要以大于`PAGE_SIZE`的对齐方式进行。
### 动态swiotlb
-----------------
当启用`CONFIG_SWIOTLB_DYNAMIC`时，swiotlb可以根据需求扩展可用于分配为缓冲区的内存量。如果缓冲区请求因缺乏可用空间而失败，会启动一个异步后台任务从一般系统内存中分配内存并将其转换为swiotlb池。创建额外的池必须异步进行，因为内存分配可能会阻塞，如上所述，swiotlb请求不允许阻塞。一旦后台任务被启动，缓冲区请求就会创建一个“临时池”以避免返回“swiotlb已满”的错误。临时池的大小与缓冲区请求相同，并在释放缓冲区时删除。临时池的内存来自一般系统内存的原子池，以便创建时不阻塞。
创建临时池的成本相对较高，尤其是在CoCo虚拟机中，此时内存必须解密，因此仅作为权宜之计，直到后台任务能够添加另一个非临时池。
动态池的添加存在限制。与默认池一样，内存必须物理上连续，因此大小受限于`MAX_PAGE_ORDER`页（例如，在典型的x86系统上为4MiB）。由于内存碎片化，可能无法提供最大尺寸的分配。动态池分配器会尝试更小的尺寸直到成功，但最小尺寸为1MiB。鉴于足够的系统内存碎片化，动态添加池可能根本不会成功。
动态池中的区域数量可能与默认池中的数量不同。因为新池的大小通常最多只有几兆字节，所以区域的数量可能会更少。例如，在新池大小为4兆字节且最小区域大小为256千字节的情况下，只能创建16个区域。如果系统中有超过16个CPU，则多个CPU必须共享一个区域，这会增加锁的竞争。

通过动态swiotlb添加的新池以线性列表的形式链接在一起。
swiotlb代码经常需要查找包含特定swiotlb物理地址的池，因此这种搜索是线性的，并且在大量动态池存在时性能不佳。数据结构可以进行改进以实现更快的搜索。

总体而言，动态swiotlb最适合配置较小、CPU相对较少的情况。它允许默认的swiotlb池更小，这样就不会浪费内存；如果有需要，动态池可以提供更多空间（只要碎片化不是障碍）。对于大型CoCo虚拟机来说，它的作用就较小。

### 数据结构详情

swiotlb通过四个主要的数据结构进行管理：`io_tlb_mem`、`io_tlb_pool`、`io_tlb_area`和`io_tlb_slot`。`io_tlb_mem`描述了一个swiotlb内存分配器，包括默认内存池以及与其链接的任何动态或临时池。每个内存分配器都保存了有限的swiotlb使用统计信息，这些信息存储在这个数据结构中。当设置了`CONFIG_DEBUG_FS`时，这些统计信息可以在`/sys/kernel/debug/swiotlb`下获取。

`io_tlb_pool`描述了一个内存池，无论是默认池、动态池还是临时池。描述包括池中内存的起始和结束地址、指向一组`io_tlb_area`结构的指针以及指向一组与该池关联的`io_tlb_slot`结构的指针。

`io_tlb_area`描述了一个区域。主要字段是用于序列化访问该区域中槽的自旋锁。池的`io_tlb_area`数组对每个区域都有一个条目，使用基于调用处理器ID的0为基础的区域索引来访问。区域的存在仅仅是为了允许从多个CPU并行访问swiotlb。

`io_tlb_slot`描述了池中的单个内存槽，其大小为`IO_TLB_SIZE`（目前为2千字节）。`io_tlb_slot`数组根据从池起始内存地址计算出的反弹缓冲区地址相对于的槽索引进行索引。`struct io_tlb_slot`的大小为24字节，因此开销大约为槽大小的1%。

`io_tlb_slot`数组的设计旨在满足几个要求。首先，DMA API和相应的swiotlb API使用反弹缓冲区地址作为反弹缓冲区的标识符。这个地址由`swiotlb_tbl_map_single()`返回，然后作为参数传递给`swiotlb_tbl_unmap_single()`和`swiotlb_sync_*()`函数。原始内存缓冲区地址显然必须作为参数传递给`swiotlb_tbl_map_single()`，但它不被传递给其他API。因此，swiotlb数据结构必须保存原始内存缓冲区地址，以便在执行同步操作时使用。这个原始地址保存在`io_tlb_slot`数组中。

其次，`io_tlb_slot`数组必须处理部分同步请求。在这种情况下，`swiotlb_sync_*()`的参数不是反弹缓冲区的起始地址，而是位于反弹缓冲区中间某个位置的地址，并且swiotlb代码不知道反弹缓冲区的起始地址。但是swiotlb代码必须能够计算出对应的原始内存缓冲区地址来执行由“同步”指令指定的CPU复制。因此，为每个由反弹缓冲区占用的槽填充调整后的原始内存缓冲区地址到`struct io_tlb_slot`中。同样地，也记录每个`struct io_tlb_slot`中的调整后的“alloc_size”值，以便对“同步”操作的大小进行合理性检查。“alloc_size”字段除了用于合理性检查外没有其他用途。
第三，io_tlb_slot 数组用于跟踪可用的槽位。结构体 `struct io_tlb_slot` 中的 "list" 字段记录从该槽位开始存在的连续可用槽位的数量。一个 "0" 表示该槽位已被占用。值为 "1" 表示只有当前槽位可用。值为 "2" 表示当前槽位和下一个槽位都可用，依此类推。最大值是 IO_TLB_SEGSIZE，这可能出现在每个槽位集的第一个槽位中，并表示整个槽位集都是可用的。这些值在搜索新弹射缓冲区要使用的可用槽位时会被使用。它们会在分配新的弹射缓冲区和释放弹射缓冲区时被更新。在池创建时，“list” 字段对于每个槽位集中所有槽位的初始化值从 IO_TLB_SEGSIZE 到 1。

第四，io_tlb_slot 数组还用于跟踪为了满足上述 alloc_align_mask 要求而分配的任何 “填充槽”。当 `swiotlb_tlb_map_single()` 分配弹射缓冲区空间以满足 alloc_align_mask 的要求时，它可能会跨零个或多个槽分配预填充空间。但是当调用 `swiotlb_tlb_unmap_single()` 并传入弹射缓冲区地址、控制分配（包括任何填充槽）的 alloc_align_mask 值时，这个 alloc_align_mask 值是未知的。"pad_slots" 字段记录了填充槽的数量，以便 `swiotlb_tlb_unmap_single()` 可以释放它们。“pad_slots” 值仅记录在为弹射缓冲区分配的第一个非填充槽中。

### 受限池

受限池是与默认 swiotlb 池分开的内存池，这些池专用于特定设备的 DMA 使用。受限池为硬件保护能力有限（例如，没有 IOMMU）的系统提供了一定程度的 DMA 内存保护。这种用途通过 DeviceTree 条目指定，并且需要设置 CONFIG_DMA_RESTRICTED_POOL。每个受限池基于其独立的 `io_tlb_mem` 数据结构，该结构与主 swiotlb 的 `io_tlb_mem` 结构无关。

受限池增加了 `swiotlb_alloc()` 和 `swiotlb_free()` API，这些 API 由 `dma_alloc_*()` 和 `dma_free_*()` API 调用。`swiotlb_alloc/free()` API 直接从受限池分配/释放槽位，而不是通过 `swiotlb_tbl_map/unmap_single()`。
