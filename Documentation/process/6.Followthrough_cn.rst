.. _development_followthrough:

跟进工作
=============

到目前为止，你已经遵循了迄今为止给出的指导方针，并且在加入自己的工程技能后，发布了一系列完美的补丁。即使是经验丰富的内核开发者也可能会犯的一个最大错误就是认为他们的工作已经完成了。事实上，发布补丁标志着进入了过程的下一个阶段，可能还有很多工作要做。很少有补丁在第一次发布时就完美无缺，没有改进的空间。内核开发过程认识到了这一事实，因此非常注重对已发布代码的改进。作为该代码的作者，你将被期望与内核社区合作，以确保你的代码符合内核的质量标准。不参与这个过程很可能会阻止你的补丁被合并到主线中。

与评审者合作
----------------------

任何重要的补丁都会收到其他开发者在评审代码时提出的一系列评论。对于许多开发者来说，与评审者合作可能是内核开发过程中最令人生畏的部分。但是，如果你记住以下几点，事情会变得容易得多：

- 如果你很好地解释了你的补丁，评审者将会理解它的价值以及你为什么费心编写它。但这种价值不会阻止他们提出一个根本性的问题：十年或二十年后，维护包含这些代码的内核会是什么样的？你可能被要求做出的许多更改——从编码风格调整到重大重写——都是基于对Linux在未来十年仍然存在并继续开发的理解。
- 代码评审是一项艰苦的工作，而且是一项相对缺乏感激之情的任务；人们记得是谁写了内核代码，但那些评审代码的人却很少获得持久的名声。因此，评审者有时会变得烦躁，特别是当他们看到同样的错误一再出现时。如果你收到了一条看似愤怒、侮辱甚至冒犯的评审意见，请克制住以相同方式回应的冲动。代码评审是关于代码本身，而不是关于人，代码评审者并不是针对你个人进行攻击。
- 同样，代码评审者并不是试图以牺牲你的利益来推动其雇主的议程。内核开发者通常期望多年后仍能继续为内核工作，但他们明白自己的雇主可能会改变。他们几乎无一例外地都在努力创建最好的内核；他们并不是试图给其雇主的竞争者制造麻烦。
- 准备好应对一些看似愚蠢的编码风格更改请求以及要求将部分代码提取到内核共享部分的需求。维护者的职责之一就是保持代码的一致性。有时候这意味着你在驱动程序中为了绕过某个问题而使用的巧妙黑客技术实际上需要成为一个通用的内核特性，以备下次使用。

所有这一切归结起来就是，当评审者给你发送评论时，你需要关注他们所做的技术观察。不要因为他们的表达方式或你的自尊心而忽略这一点。当你收到补丁的评审意见时，花时间去理解评审者想说什么。如果可能的话，修复评审者要求你修复的问题。并向评审者回复：感谢他们，并描述你将如何回答他们的问题。

请注意，你不必同意评审者建议的所有更改。如果你认为评审者误解了你的代码，请解释实际发生了什么。如果你对建议的更改有技术上的异议，请描述并证明你的解决方案。如果你的解释合理，评审者会接受它们。但如果评审者并不认同你的解释，特别是在其他人也开始同意评审者的观点时，花点时间重新思考。很容易因为过于专注于自己的解决方案而看不到根本问题所在，甚至可能没有解决正确的问题。

Andrew Morton 建议，每个未导致代码更改的评审评论都应在代码中添加注释；这可以帮助未来的评审者避免重复最初出现的问题。

一个致命的错误是忽略评审评论，希望它们会消失。它们不会消失。如果你在没有回应之前评论的情况下重新发布代码，你可能会发现你的补丁无法得到进展。
说到转发代码：请记住，评审者不会记得你上次发布的所有代码细节。因此，提醒评审者之前提出的问题以及你是如何处理这些问题的总是个好主意；补丁的日志是个记录这些信息的好地方。评审者不应该需要去搜索邮件列表来熟悉上次讨论的内容；如果你能帮助他们快速了解情况，他们在重新审查你的代码时会更愉快。

如果你已经尽力去做了一切正确的事情，但事情仍然没有进展，该怎么办？大多数技术分歧可以通过讨论解决，但有时确实需要有人来做决定。如果你真诚地认为这个决定对你不公平，你可以尝试向上级求助。截至本文撰写之时，这个上级通常是安德鲁·莫顿（Andrew Morton）。安德鲁在内核开发社区中享有很高的声望；他经常能够解决看似无法推进的情况。不过，向安德鲁求助不应轻率行事，而应在穷尽其他所有方法之后再考虑。当然，请记住，他也可能不同意你的观点。

接下来会发生什么
-------------------

如果一个补丁被认为对内核有益，并且大部分评审问题已经解决，下一步通常是将其纳入子系统的维护者的树中。不同子系统之间的做法各不相同；每个维护者都有自己的方式。特别是，可能会有多个树——一个可能专门用于计划在下一个合并窗口中使用的补丁，另一个则用于长期工作。

对于那些没有明显子系统树的领域（例如内存管理补丁），默认树通常是-mm。影响多个子系统的补丁也可能通过-mm树。

将补丁纳入子系统树可以提高其可见性。现在，使用该树的其他开发者将默认获得该补丁。子系统树通常也会向linux-next提供内容，使其对整个开发社区可见。在这个阶段，你很可能会收到新一批评审者的评论；这些评论同样需要回应。

根据补丁的性质，在这个阶段还可能出现与其他开发者工作的冲突。最糟糕的情况下，严重的补丁冲突可能导致某些工作被暂时搁置，以便其余补丁能够整理好并合并。

有时，解决冲突可能涉及与其他开发者合作，甚至可能需要在不同树之间移动一些补丁，以确保所有补丁都能顺利应用。虽然这项工作可能令人头疼，但请庆幸：在linux-next树出现之前，这些冲突往往只在合并窗口期间才暴露出来，必须紧急解决。而现在，可以在合并窗口打开之前从容解决。

有一天，如果你一切顺利，你会登录后发现你的补丁已经被合并到主线内核中。恭喜！一旦庆祝完毕（并且你已经在MAINTAINERS文件中添加了自己的名字），请记住一个重要事实：工作还没有结束。

合并到主线内核本身会带来新的挑战。
首先，你的补丁的可见性再次增加了。可能会有新的开发者对这个补丁发表评论，因为他们之前可能没有注意到它。你可能会觉得可以忽略这些评论，因为你的代码已经不可能被合并了。但是请抵制这种诱惑；你仍然需要对提出问题或建议的开发者做出回应。

更重要的是：进入主线意味着你的代码会被更多的测试者使用。即使你提交的驱动程序是为尚未上市的硬件编写的，你也会惊讶于有多少人会将你的代码编入他们的内核中。当然，只要有测试者，就会有bug报告。

最糟糕的bug报告是导致了回归的问题。如果你的补丁引起了回归，你会发现有很多双眼睛盯着你；回归问题必须尽快修复。如果你不愿意或者无法修复这个问题（并且也没有其他人替你解决），你的补丁几乎肯定会在这个稳定化阶段被移除。这不仅会使你之前所做的所有努力白费，而且由于未能修复回归问题而导致补丁被移除，将来你提交的工作可能会更难被合并。

在处理完所有的回归问题之后，还可能有其他普通bug需要处理。稳定化阶段是你修复这些问题的最佳机会，确保你的代码在主线内核发布时尽可能稳定。因此，请回复bug报告，并尽可能修复问题。这就是稳定化阶段的目的；一旦旧问题解决，你就可以开始创建新的酷炫补丁了。

不要忘记，还有其他里程碑也可能产生bug报告：下一个主线稳定版本发布时，主流发行版采用包含你补丁的内核版本等。继续响应这些报告是对工作基本的自豪感。如果这还不够激励你，那么请考虑一下开发社区会记住那些在代码合并后就失去兴趣的开发者。下次你提交补丁时，他们会假设你不会在之后维护它。

其他可能发生的情况
-------------------

有一天，你可能会打开邮件客户端，看到有人给你发了一封关于你代码的补丁。毕竟，公开你的代码就有这样的好处。如果你同意这个补丁，你可以将其转发给子系统维护者（一定要包含正确的From:行以正确归因，并加上你自己的签名），或者发送一个Acked-by:回复让原作者向上发送。

如果你不同意这个补丁，请礼貌地回复解释原因。如果可能的话，告诉作者需要做哪些改动才能使你接受这个补丁。尽管反对者会对合并受作者和维护者反对的补丁有一定抵触，但这种抵触是有限度的。如果你被视为无端阻止好的工作，这些补丁最终还是会绕过你并进入主线。在Linux内核中，除了Linus之外，没有人对任何代码拥有绝对否决权。

非常罕见的情况下，你可能会看到完全不同的情况：另一位开发者发布了另一种解决你问题的方法。在这种情况下，很可能其中一个补丁不会被合并，“我的先出现”并不是一个有力的技术论据。如果其他人的补丁取代了你的补丁并进入了主线，唯一恰当的反应就是高兴问题得到了解决，并继续你的工作。虽然这种方式被取代可能会让人感到受伤和沮丧，但社区会记得你的反应，而不会在意究竟是谁的补丁被合并了。
