向 Linux 内核应用补丁
++++++++++++++++++++++++++++++++++++

原始作者：
    Jesper Juhl，2005年8月

.. note::

   本文档已经过时。在大多数情况下，您几乎肯定希望使用 Git 而不是手动使用 `patch` 工具。
   
Linux 内核邮件列表中经常被问到的问题是如何将补丁应用于内核，或者更具体地说，如何确定针对众多分支/树中的一个的补丁应该应用到哪个基础内核版本上。希望本文档能够为您解释这一点。
除了说明如何应用和撤销补丁外，还简要介绍了不同的内核树（以及如何应用它们特定的补丁的示例）。

什么是补丁？
================

补丁是一个包含两个不同源树版本之间的差异的小型文本文件。补丁是通过 `diff` 程序创建的。
为了正确地应用补丁，您需要知道它是从什么基础版本生成的，以及该补丁将把源树改变为什么新版本。这些信息通常都会出现在补丁文件的元数据中，或者可以从文件名推断出来。

如何应用或撤销补丁？
=================================

您可以通过 `patch` 程序来应用补丁。`patch` 程序读取一个差分（或补丁）文件，并根据其中描述的内容对源树进行更改。
Linux 内核的补丁是相对于包含内核源码目录的父目录生成的。
这意味着补丁文件中的文件路径包含了它所针对的内核源码目录名称（或其他目录名称如 "a/" 和 "b/"）。
由于这很可能与您本地机器上的内核源码目录名称不匹配（但通常是看到未标记的补丁是基于哪个版本生成的有用信息），您应该进入您的内核源码目录，并在应用补丁时去掉文件名路径中的第一个元素（`patch` 的 `-p1` 参数可以做到这一点）。
要撤销之前已应用的补丁，请使用 `patch` 的 `-R` 参数。
因此，如果你应用了一个像这样的补丁：

```shell
patch -p1 < ../patch-x.y.z
```

你可以这样撤销（取消）它：

```shell
patch -R -p1 < ../patch-x.y.z
```

如何将补丁/差异文件输入到 `patch` 命令？
=============================================

这（与 Linux 和其他类 Unix 操作系统一样）可以通过几种不同的方式完成。
在下面所有的示例中，我都通过标准输入以未压缩的形式将文件输入给 `patch` 命令，使用以下语法：

```shell
patch -p1 < path/to/patch-x.y.z
```

如果你只想能够跟随下面的示例，并且不想了解超过一种使用 `patch` 的方法，那么你可以在这里停止阅读本节。
`patch` 也可以通过 `-i` 参数获取要使用的文件名，例如：

```shell
patch -p1 -i path/to/patch-x.y.z
```

如果你的补丁文件被 gzip 或 xz 压缩了，并且你不想在应用之前解压它，那么你可以这样将它输入给 `patch`：

```shell
xzcat path/to/patch-x.y.z.xz | patch -p1
bzcat path/to/patch-x.y.z.gz | patch -p1
```

如果你想手动先解压补丁文件再应用它（我认为你在下面的示例中就是这样做的），那么你只需运行 `gunzip` 或 `xz -d` 来处理文件，如下所示：

```shell
gunzip patch-x.y.z.gz
xz -d patch-x.y.z.xz
```

这将留下一个纯文本的 `patch-x.y.z` 文件，你可以通过标准输入或 `-i` 参数将其输入给 `patch`，任选其一。
`patch` 的一些不错的参数包括 `-s`，该参数使 `patch` 除了错误信息之外保持静默，这对于防止错误信息过快滚动出屏幕很有用；`--dry-run` 使 `patch` 只打印会发生什么的列表，但实际上不进行任何更改。最后，`--verbose` 告诉 `patch` 打印更多关于正在进行的工作的信息。

应用补丁时常见的错误
==========================

当 `patch` 应用补丁文件时，它会尝试以不同的方式验证文件的合理性。
检查文件是否看起来像是有效的补丁文件以及检查被修改部分周围的代码是否与补丁中提供的上下文匹配，这只是 `patch` 执行的基本合理性检查中的两个例子。
如果 `patch` 遇到某些看起来不太对劲的东西，它有两种选择。它可以拒绝应用更改并中止操作，或者它尝试找到一种方法来通过对补丁进行一些小的调整来使其适用。
一个 `patch` 尝试修正的例子是：所有上下文都匹配，要更改的行也匹配，但行号不同。这种情况可能发生在补丁在文件中间做出更改，但由于某种原因，在文件开头附近添加或删除了几行。在这种情况下，一切都看起来不错，只是上下移动了一点，`patch` 通常会调整行号并应用补丁。
每当 `patch` 应用了一个它不得不稍作修改才能使其适用的补丁时，它会告诉你它应用了带有 **fuzz** 的补丁。
你应该对这种变化持谨慎态度，因为尽管 `patch` 大概率是正确的，但它并不总是正确，有时结果可能是错误的。
当补丁遇到无法通过模糊匹配修复的更改时，它会直接拒绝该更改，并留下一个带有``.rej``扩展名的文件（拒绝文件）。你可以阅读这个文件以确切地了解哪些更改未能应用，这样如果你愿意的话可以手动修复这些更改。
如果你没有在内核源码上应用任何第三方补丁，而只应用了来自kernel.org的补丁，并且按照正确的顺序应用了这些补丁，同时自己没有对源文件进行过任何修改，那么你应该永远不会看到补丁程序输出的模糊匹配或拒绝消息。如果你确实看到了这样的消息，那么有很大可能是你的本地源码树或补丁文件在某种程度上受到了损坏。在这种情况下，你可能需要尝试重新下载补丁；如果问题仍然存在，那么建议你从kernel.org完整地重新下载一个新的源码树开始。

让我们更详细地看一下补丁程序可能产生的某些消息。
如果补丁程序停止并显示“要修补的文件:”提示符，这意味着补丁程序未能找到要修补的文件。最有可能的原因是你忘记指定`-p1`选项或者你位于错误的目录中。较少见的情况是，有些补丁需要使用`-p0`而不是`-p1`来应用（阅读补丁文件应该能揭示这种情况——如果是这样，那么这是创建补丁的人的错误，但并不是致命的问题）。
如果你收到类似“第2个块在1887行成功应用，模糊偏移量为2（偏移7行）。”的消息，这意味着补丁程序必须调整更改的位置（在这个例子中，它需要从预期位置移动7行才能使更改适配）。
生成的文件是否正确取决于文件与预期不同的原因。
这通常发生在试图将为不同内核版本生成的补丁应用于当前内核版本上的情况。
如果你收到类似“第3个块在2387行失败。”的消息，这意味着补丁无法正确应用，补丁程序无法通过模糊匹配解决问题。这会产生一个带有导致补丁失败的更改的``.rej``文件，以及一个显示无法被更改的原始内容的``.orig``文件。
如果你收到“检测到已反转（或先前已应用）的补丁！是否假设使用-R？[n]”的消息，则意味着补丁程序检测到补丁中包含的更改似乎已经被做了。
如果你实际上之前已经应用了这个补丁，只是不小心再次应用了它，那么只需输入[n]o并终止此次补丁操作即可。如果你之前确实应用了这个补丁，并且有意要撤销它，但忘记了指定-R选项，那么你可以在这里输入[**y**]es让补丁程序为你撤销它。
这也可能发生在创建补丁时，补丁的制作者将源目录和目标目录颠倒了，在这种情况下，反转补丁实际上会应用它。

类似“patch: **** 文件结束在补丁中的意外位置”或“补丁在行中间意外结束”的消息意味着补丁程序无法理解你输入给它的文件。可能是你的下载有问题，你尝试在不解压的情况下将压缩的补丁文件输入给补丁程序，或者你在使用的过程中，补丁文件被邮件客户端或邮件传输代理以某种方式破坏了，例如，将一行长文本分割成了两行。

通常，这些警告可以通过合并（连接）被分割的两行来轻松修复。

如我上面已经提到的，如果你将来自kernel.org的补丁应用到未经修改的正确版本的源代码树上，这些错误不应该发生。所以，如果你在使用kernel.org的补丁时遇到这些错误，你应该假设要么是你的补丁文件，要么是你的树有问题，我建议你从全新的内核树和你想应用的补丁的完整下载开始重新操作。

有没有“patch”的替代方案？
==================================

是的，有替代方案。

你可以使用“interdiff”程序（http://cyberelk.net/tim/patchutils/）生成两个补丁之间的差异所代表的补丁，然后应用结果。这将使你能够一步从像5.7.2这样的版本直接跳到5.7.3。interdiff的-z标志甚至允许你直接输入gzip或bzip2压缩格式的补丁，无需使用zcat或bzcat或手动解压缩。

以下是如何从5.7.2一次性跳到5.7.3的方法：

```
interdiff -z ../patch-5.7.2.gz ../patch-5.7.3.gz | patch -p1
```

尽管interdiff可能可以为你节省一两步，但通常还是建议你执行额外的步骤，因为interdiff在某些情况下可能会出错。

另一个替代方案是“ketchup”，这是一个用于自动下载和应用补丁的Python脚本（https://www.selenic.com/ketchup/）。
其他一些不错的工具包括：

- `diffstat`，它显示由补丁所做的更改摘要；
- `lsdiff`，它在补丁文件中显示受影响文件的简短列表，以及（可选地）每个补丁开始的行号；
- `grepdiff`，它显示由补丁修改的文件列表，其中补丁包含给定的正则表达式。

我可以在哪里下载这些补丁？
=================================

补丁可在 https://kernel.org/ 获取。
最近的补丁通常链接在主页上，但它们也有特定的存放位置：
5.x.y（-stable）和5.x补丁位于

    https://www.kernel.org/pub/linux/kernel/v5.x/

5.x.y增量补丁位于

    https://www.kernel.org/pub/linux/kernel/v5.x/incr/

-rc补丁不存储在网络服务器上，而是根据如下的git标签按需生成：

    https://git.kernel.org/torvalds/p/v5.1-rc1/v5.0

稳定的-rc补丁位于

    https://www.kernel.org/pub/linux/kernel/v5.x/stable-review/

5.x内核
===============

这些是由Linus发布的基础稳定版本。编号最高的发布是最新的。
如果发现退化或其它严重缺陷，则会在该基础上发布一个-stable修复补丁（见下文）。一旦新的5.x基础内核发布，就会提供一个补丁，它是前一个5.x内核与新内核之间的差值。
要从5.6升级到5.7，你可以按照以下步骤操作（请注意，此类补丁**不适用于**5.x.y内核之上，而是在基础5.x内核之上应用——如果你需要从5.x.y升级到5.x+1，你需要先撤销5.x.y补丁）
以下是一些示例：

    # 从5.6升级到5.7

    $ cd ~/linux-5.6     # 进入内核源码目录
    $ patch -p1 < ../patch-5.7   # 应用5.7补丁
    $ cd .
    $ mv linux-5.6 linux-5.7     # 重命名源码目录

    # 从5.6.1升级到5.7

    $ cd ~/linux-5.6.1   # 进入内核源码目录
    $ patch -p1 -R < ../patch-5.6.1   # 撤销5.6.1补丁
                            # 此时源码目录为5.6
    $ patch -p1 < ../patch-5.7   # 应用新的5.7补丁
    $ cd .
    $ mv linux-5.6.1 linux-5.7   # 重命名源码目录

5.x.y内核
=================

三位数版本的内核是-stable内核。它们包含了针对特定5.x内核中发现的安全问题或重大退化的小型关键修复。
这是推荐给想要最新稳定内核且对测试开发/实验性版本不感兴趣的用户分支。
如果没有5.x.y内核可用，那么编号最高的5.x内核就是当前的稳定内核。
稳定团队提供的补丁包括普通补丁和增量补丁。以下是应用这些补丁的方法。

### 普通补丁
~~~
这些补丁不是增量式的，这意味着例如 5.7.3 的补丁并不是基于 5.7.2 内核源代码之上应用的，而是直接应用于基础的 5.7 内核源代码。
因此，为了将 5.7.3 补丁应用于现有的 5.7.2 内核源代码，你首先需要撤销 5.7.2 的补丁（这样你就回到了基础的 5.7 内核源代码），然后才能应用新的 5.7.3 补丁。
下面是一个简单的示例：

```
$ cd ~/linux-5.7.2		# 进入内核源码目录
$ patch -p1 -R < ../patch-5.7.2	# 撤销 5.7.2 的补丁
$ patch -p1 < ../patch-5.7.3	# 应用新的 5.7.3 补丁
$ cd .
$ mv linux-5.7.2 linux-5.7.3	# 重命名内核源码目录
```
~~~

### 增量补丁
~~~
增量补丁是不同的：它们不是基于基础的 5.x 内核之上应用的，而是基于上一个稳定版本的内核（5.x.y-1）之上应用的。
下面是如何应用这些补丁的例子：

```
$ cd ~/linux-5.7.2		# 进入内核源码目录
$ patch -p1 < ../patch-5.7.2-3	# 应用新的 5.7.3 补丁
$ cd .
$ mv linux-5.7.2 linux-5.7.3	# 重命名内核源码目录
```
~~~

### -rc 内核
~~~
这些是发布候选内核。这是 Linus 在认为当前 git（内核的源码管理工具）树处于足够稳定的测试状态时发布的开发内核。
这些内核并不稳定，如果你打算运行它们，请预计到偶尔会出现问题。然而，这是主开发分支中最稳定的，并且最终会变成下一个稳定内核，所以尽可能多的人进行测试非常重要。
对于想要帮助测试开发内核但又不想运行一些真正实验性内容的人来说，这是一个不错的选择（这类人可以参阅下面关于 -next 和 -mm 内核的部分）。
-rc 补丁不是增量式的，它们适用于基础的 5.x 内核，就像上面描述的 5.x.y 补丁一样。-rcN 后缀之前的内核版本表示这个 -rc 内核最终将转变为的内核版本。
~~~
因此，5.8-rc5 意味着这是 5.8 内核的第五个候选版本，而此补丁应该应用在 5.7 内核源代码之上。下面是三种如何应用这些补丁的例子：

	# 首先是从 5.7 升级到 5.8-rc3 的例子

	$ cd ~/linux-5.7			# 进入 5.7 源码目录
	$ patch -p1 < ../patch-5.8-rc3		# 应用 5.8-rc3 补丁
	$ cd .
	$ mv linux-5.7 linux-5.8-rc3		# 重命名源码目录

	# 现在让我们从 5.8-rc3 升级到 5.8-rc5

	$ cd ~/linux-5.8-rc3			# 进入 5.8-rc3 目录
	$ patch -p1 -R < ../patch-5.8-rc3	# 回退 5.8-rc3 补丁
	$ patch -p1 < ../patch-5.8-rc5		# 应用新的 5.8-rc5 补丁
	$ cd .
	$ mv linux-5.8-rc3 linux-5.8-rc5	# 重命名源码目录

	# 最后尝试从 5.7.3 升级到 5.8-rc5

	$ cd ~/linux-5.7.3			# 进入内核源码目录
	$ patch -p1 -R < ../patch-5.7.3		# 回退 5.7.3 补丁
	$ patch -p1 < ../patch-5.8-rc5		# 应用新的 5.8-rc5 补丁
	$ cd .
	$ mv linux-5.7.3 linux-5.8-rc5		# 重命名内核源码目录

-**mm 补丁和 linux-next 树**
==============================

-**mm 补丁** 是由 Andrew Morton 发布的实验性补丁。
过去，-**mm 树** 也被用来测试子系统的补丁，但这个功能现在通过 `linux-next`（https://www.kernel.org/doc/man-pages/linux-next.html）树来完成。子系统维护者首先将他们的补丁推送到 linux-next 中，在合并窗口期间直接将它们发送给 Linus。
-**mm 补丁** 可以作为新特性和其他未通过子系统树合并的实验性补丁的试验场。
一旦这类补丁在 -**mm** 中证明了自己的价值一段时间后，Andrew 会将其推送给 Linus，以便纳入主线内核。
linux-next 树每天都会更新，并包含 -**mm 补丁**。
两者都在不断变化中，包含了大量实验性特性、很多不适合纳入主线的调试补丁等，是本文档描述的分支中最实验性的。
这些补丁不适合在应该保持稳定的系统上使用，它们比其他任何分支运行起来风险更大（确保你的备份是最新的——这适用于任何实验性内核，但对于-mm补丁或使用来自linux-next树的内核来说尤为重要）。非常感谢对-mm补丁和linux-next进行测试，因为这些测试的整个目的是在更改合并到更稳定的主线Linus树之前，找出退步、崩溃、数据损坏错误、构建破坏（以及一般性的任何其他错误）。

但是，-mm和linux-next的测试者应该意识到，与在任何其他树中相比，故障更为常见。

这结束了对各种内核树的解释列表。我希望你现在清楚如何应用不同的补丁并帮助测试内核。

感谢Randy Dunlap、Rolf Eike Beer、Linus Torvalds、Bodo Eggert、Johannes Stezenbach、Grant Coady、Pavel Machek以及其他可能被我遗忘的人，感谢他们对本文档的审阅和贡献。

这段话翻译自一篇关于Linux内核开发和测试的文档，强调了实验性内核补丁的风险，并表达了对那些为内核稳定性和改进做出贡献的人的感激之情。
