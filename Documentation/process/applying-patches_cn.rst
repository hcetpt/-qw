.. _应用补丁：

为 Linux 内核应用补丁
++++++++++++++++++++++++++++++++++++

原作者：
    Jesper Juhl，2005年8月

.. note::

   本文档已过时。在大多数情况下，您几乎肯定希望使用 Git 而不是手动使用 `patch`。

Linux 内核邮件列表中经常被问到的问题是如何将补丁应用于内核，或者更具体地说，某个补丁应该应用于哪个基础内核版本。希望本文档能够解释这一点。
除了说明如何应用和撤销补丁之外，还简要介绍了不同的内核树（以及如何应用它们的特定补丁）。

什么是补丁？
================

补丁是一个包含两个不同源树版本之间差异的小文本文件。补丁是用 `diff` 程序生成的。
为了正确地应用一个补丁，你需要知道它是在什么基础上生成的，以及这个补丁会将源树变成什么新版本。这些信息应该都包含在补丁文件的元数据中，或者可以从文件名中推断出来。

如何应用或撤销补丁？
=================================

你可以使用 `patch` 程序来应用补丁。`patch` 程序读取一个差分文件（或补丁文件），并根据其中描述的内容对源树进行更改。
Linux 内核的补丁是相对于包含内核源码目录的父目录生成的。
这意味着补丁文件中的文件路径包含生成补丁时所针对的内核源码目录名称（或其他目录名称如 "a/" 和 "b/"）。
由于这不太可能与您本地机器上的内核源码目录名称匹配（但通常是查看未标记补丁版本的有用信息），因此您应该进入您的内核源码目录，并在应用补丁时从文件名中去掉第一个路径元素（`patch` 的 `-p1` 参数可以实现这一点）。
要撤销之前已应用的补丁，请使用 `patch` 的 `-R` 参数。
因此，如果你应用了一个像这样的补丁：

```sh
patch -p1 < ../patch-x.y.z
```

你可以通过以下命令来撤销（取消）它：

```sh
patch -R -p1 < ../patch-x.y.z
```

如何将补丁/差异文件传递给 `patch`？
=======================================

这（与Linux和其他类UNIX操作系统一样）可以通过几种不同的方式完成。
在下面的所有示例中，我都是使用以下语法通过标准输入将未压缩的文件传递给 `patch` ：

```sh
patch -p1 < path/to/patch-x.y.z
```

如果你只想能够跟随下面的示例，并且不想了解多种使用 `patch` 的方法，那么你可以在这里停止阅读。
`patch` 也可以通过 `-i` 参数获取要使用的文件名，如下所示：

```sh
patch -p1 -i path/to/patch-x.y.z
```

如果你的补丁文件是用 gzip 或 xz 压缩的，并且不希望在应用之前解压它，那么你可以这样将其传递给 `patch` ：

```sh
xzcat path/to/patch-x.y.z.xz | patch -p1
bzcat path/to/patch-x.y.z.gz | patch -p1
```

如果你想手动先解压补丁文件然后再应用它（假设你在下面的示例中就是这样做的），那么你只需运行 `gunzip` 或 `xz` 来处理该文件——就像这样：

```sh
gunzip patch-x.y.z.gz
xz -d patch-x.y.z.xz
```

这将留下一个纯文本的 `patch-x.y.z` 文件，你可以根据喜好通过标准输入或 `-i` 参数将其传递给 `patch` 。
`patch` 的一些其他不错的参数包括 `-s` ，它使 `patch` 除了错误信息外保持静默，这对于防止错误信息滚动得太快很有帮助；`--dry-run` 使 `patch` 只打印会发生什么的列表，但不会实际进行任何更改。最后，`--verbose` 告诉 `patch` 打印更多关于正在执行的工作的信息。
应用补丁时的常见错误
============================

当 `patch` 应用补丁文件时，它会尝试以不同的方式验证文件的合理性。
检查文件是否看起来像一个有效的补丁文件以及检查被修改的部分周围的代码是否与补丁中提供的上下文匹配只是 `patch` 进行的基本合理性检查中的两个例子。
如果 `patch` 遇到一些看起来不太对劲的东西，它有两种选择。它可以拒绝应用更改并终止，或者尝试找到一种通过少量修改使补丁应用的方法。
一个 `patch` 尝试修复的例子是：所有上下文都匹配，被修改的行也匹配，但是行号不同。例如，如果补丁在文件中间进行了更改，但由于某种原因，在文件开头附近添加或删除了几行，那么情况看起来很好，只是上下移动了一点点，`patch` 通常会调整行号并应用补丁。
每当 `patch` 应用了一个需要稍作修改才能使其适用的补丁时，它会告诉你这个补丁是以 **fuzz** 方式应用的。
你应该警惕这种更改，因为尽管 `patch` 大多数时候是对的，但它并不总是正确的，有时结果会出错。
当补丁遇到无法通过模糊匹配修复的更改时，它会直接拒绝该更改，并留下一个带有 ``.rej`` 扩展名的文件（拒绝文件）。你可以阅读这个文件以了解到底是什么更改无法应用，这样你就可以手动修复它。

如果你没有在内核源码中应用任何第三方补丁，而只有来自 kernel.org 的补丁，并且按照正确的顺序应用这些补丁，并且你自己没有对源文件进行过任何修改，那么你不应该看到任何模糊或拒绝消息。如果你确实看到了这样的消息，那么有很大可能性是你的本地源树或补丁文件在某种程度上被损坏了。这种情况下，你应该尝试重新下载补丁，并且如果问题仍然存在，建议你从 kernel.org 完整地下载一个新的源树。

让我们更详细地看一下补丁可能产生的某些消息。

如果补丁停止并显示 ``File to patch:`` 提示符，则表示补丁找不到要修补的文件。最有可能的情况是你忘记了指定 `-p1` 或者你在错误的目录中。较少见的是，你会发现一些需要使用 `-p0` 而不是 `-p1` 应用的补丁（读取补丁文件应该可以揭示这种情况——如果是这样，这说明创建补丁的人有误，但不是致命的）。

如果你收到类似 ``Hunk #2 succeeded at 1887 with fuzz 2 (offset 7 lines).`` 的消息，这意味着补丁必须调整更改的位置（在这个例子中，它需要将更改移动 7 行才能使更改生效）。

最终文件是否正确取决于文件与预期不同的原因。这种情况经常发生在你试图应用一个针对不同内核版本生成的补丁时。

如果你收到类似 ``Hunk #3 FAILED at 2387.`` 的消息，则意味着补丁无法正确应用，并且补丁程序无法通过模糊匹配解决问题。这将生成一个包含导致补丁失败的更改的 ``.rej`` 文件，以及一个显示无法更改的原始内容的 ``.orig`` 文件。

如果你收到 ``Reversed (or previously applied) patch detected! Assume -R? [n]`` 消息，则表示补丁检测到补丁中的更改似乎已经被应用过了。

如果你实际上之前已经应用了这个补丁，并且只是错误地再次应用了它，那么只需回答 `[n]o` 并终止此补丁操作。如果你之前已经应用了这个补丁，并且实际意图是撤销它，但忘记了指定 `-R`，那么你可以在这里回答 `[**y**]es` 让补丁为你撤销更改。
这也可能是因为创建补丁时将源目录和目标目录颠倒了，在这种情况下，撤销补丁实际上会应用它。

类似“patch: **** 文件结束意外”的信息或“补丁在行中间意外结束”意味着补丁程序无法理解你输入的文件。可能是你的下载有问题，或者你尝试在不解压的情况下给补丁程序输入压缩过的补丁文件，又或者是你在使用过程中补丁文件被邮件客户端或邮件传输代理破坏了，例如通过将长行分割为两行。

通常这些警告可以通过合并（连接）被分割的两行来轻松解决。

正如上面提到的，如果你对未修改的源树正确版本应用kernel.org的补丁，这些错误不应该发生。所以如果你在使用kernel.org的补丁时遇到这些问题，你应该假设要么是你的补丁文件有问题，要么是你的源树有问题，并建议你重新下载完整的内核源码树以及你想要应用的补丁。

有没有替代“patch”的工具？
============================

是的，有替代工具。

你可以使用`interdiff`程序（http://cyberelk.net/tim/patchutils/）生成两个补丁之间的差异补丁，然后应用结果。这样可以让你一次性从5.7.2升级到5.7.3。`interdiff`的-z标志甚至允许你直接输入gzip或bzip2压缩格式的补丁文件，而无需使用zcat或bzcat或手动解压。

以下是如何一次性从5.7.2升级到5.7.3：

```
interdiff -z ../patch-5.7.2.gz ../patch-5.7.3.gz | patch -p1
```

尽管`interdiff`可能会为你节省一两个步骤，但通常建议你执行额外的步骤，因为`interdiff`在某些情况下可能会出错。

另一个替代方案是`ketchup`，这是一个用于自动下载和应用补丁的Python脚本（https://www.selenic.com/ketchup/）。
其他不错的工具包括 `diffstat`，它显示一个补丁所做的更改摘要；`lsdiff`，它显示补丁文件中受影响文件的简短列表（可选地包括每个补丁开始的行号）；以及 `grepdiff`，它显示包含给定正则表达式的补丁中修改的文件列表。

我在哪里可以下载这些补丁？
==============================

补丁可以在 https://kernel.org/ 下载。
最近的补丁链接在首页上，但它们也有特定的位置。
5.x.y（-stable）和5.x补丁位于

    https://www.kernel.org/pub/linux/kernel/v5.x/

5.x.y增量补丁位于

    https://www.kernel.org/pub/linux/kernel/v5.x/incr/

-rc 补丁没有存储在网络服务器上，而是根据 git 标签按需生成，例如

    https://git.kernel.org/torvalds/p/v5.1-rc1/v5.0

稳定的 -rc 补丁位于

    https://www.kernel.org/pub/linux/kernel/v5.x/stable-review/

5.x 内核
========

这些是由 Linus 发布的基础稳定版本。编号最高的发布是最新的。
如果发现退化或其他严重问题，则会在基础版本之上发布一个 -stable 修复补丁（见下文）。一旦发布了一个新的 5.x 基础内核，就会提供一个从之前的 5.x 内核到新内核的增量补丁。
要从 5.6 升级到 5.7，请执行以下操作（请注意，此类补丁**不**适用于 5.x.y 内核，而是适用于基础 5.x 内核——如果你需要从 5.x.y 升级到 5.x+1，首先需要撤销 5.x.y 的补丁）。
以下是几个示例：

    # 从 5.6 升级到 5.7

    $ cd ~/linux-5.6         # 切换到内核源码目录
    $ patch -p1 < ../patch-5.7  # 应用 5.7 补丁
    $ cd .
    $ mv linux-5.6 linux-5.7     # 重命名源码目录

    # 从 5.6.1 升级到 5.7

    $ cd ~/linux-5.6.1        # 切换到内核源码目录
    $ patch -p1 -R < ../patch-5.6.1  # 撤销 5.6.1 补丁
                                    # 源码目录现在是 5.6
    $ patch -p1 < ../patch-5.7  # 应用新的 5.7 补丁
    $ cd .
    $ mv linux-5.6.1 linux-5.7     # 重命名源码目录

5.x.y 内核
==========

带有三位版本号的内核是 -stable 内核。它们包含针对特定 5.x 内核中发现的安全问题或重要退化的小型关键修复。
这是推荐的分支，适合那些希望使用最新稳定内核且不想帮助测试开发/实验版本的用户。
如果没有可用的 5.x.y 内核，则编号最高的 5.x 内核是当前稳定的内核。
-stable 团队提供常规补丁和增量补丁。以下是应用这些补丁的方法。

### 常规补丁
~~~~~~~~~~~~~~

这些补丁不是增量的，这意味着例如 5.7.3 补丁不会应用在 5.7.2 内核源码之上，而是应用在基础的 5.7 内核源码之上。
因此，为了将 5.7.3 补丁应用到现有的 5.7.2 内核源码上，你需要先回滚 5.7.2 补丁（这样你就回到了基础的 5.7 内核源码），然后再应用新的 5.7.3 补丁。
下面是一个简单的示例：

```
$ cd ~/linux-5.7.2		# 进入内核源码目录
$ patch -p1 -R < ../patch-5.7.2	# 回滚 5.7.2 补丁
$ patch -p1 < ../patch-5.7.3	# 应用新的 5.7.3 补丁
$ cd .
$ mv linux-5.7.2 linux-5.7.3	# 重命名内核源码目录
```

### 增量补丁
~~~~~~~~~~~~~~~~~~~

增量补丁是不同的：它们不是应用在基础的 5.x 内核之上，而是应用在之前的稳定内核（5.x.y-1）之上。
下面是应用这些补丁的一个示例：

```
$ cd ~/linux-5.7.2		# 进入内核源码目录
$ patch -p1 < ../patch-5.7.2-3	# 应用新的 5.7.3 补丁
$ cd .
$ mv linux-5.7.2 linux-5.7.3	# 重命名内核源码目录
```

### -rc 内核
=================

这些是发布候选内核。这些是由 Linus 在他认为当前 git（内核的源码管理工具）树处于一个足够稳定的状态以供测试时发布的开发内核。
这些内核并不稳定，如果你打算运行它们，可能会遇到偶尔的故障。然而，这是主开发分支中最稳定的版本，并且最终会成为下一个稳定内核，因此尽可能多的人进行测试是非常重要的。
这是一个适合那些想要帮助测试开发内核但又不想运行一些真正实验性内容的人的好选择（这些人可以参考下面关于 -next 和 -mm 内核的部分）。
-rc 补丁不是增量的，它们应用在基础的 5.x 内核上，就像上面描述的 5.x.y 补丁一样。-rcN 后缀之前的内核版本表示这个 -rc 内核最终会变成的内核版本。
所以，5.8-rc5 表示这是 5.8 内核的第五个候选版本，补丁应该应用在 5.7 内核源码上。以下是三种应用这些补丁的方法：

- 首先是一个从 5.7 升级到 5.8-rc3 的例子

```sh
$ cd ~/linux-5.7			# 进入 5.7 源码目录
$ patch -p1 < ../patch-5.8-rc3		# 应用 5.8-rc3 补丁
$ cd .
$ mv linux-5.7 linux-5.8-rc3		# 重命名源码目录
```

- 现在让我们从 5.8-rc3 升级到 5.8-rc5

```sh
$ cd ~/linux-5.8-rc3			# 进入 5.8-rc3 目录
$ patch -p1 -R < ../patch-5.8-rc3	# 回退 5.8-rc3 补丁
$ patch -p1 < ../patch-5.8-rc5		# 应用新的 5.8-rc5 补丁
$ cd .
$ mv linux-5.8-rc3 linux-5.8-rc5	# 重命名源码目录
```

- 最后，尝试从 5.7.3 升级到 5.8-rc5

```sh
$ cd ~/linux-5.7.3			# 进入内核源码目录
$ patch -p1 -R < ../patch-5.7.3		# 回退 5.7.3 补丁
$ patch -p1 < ../patch-5.8-rc5		# 应用新的 5.8-rc5 补丁
$ cd .
$ mv linux-5.7.3 linux-5.8-rc5		# 重命名内核源码目录
```

-mm 补丁和 linux-next 树
=========================

-mm 补丁是由 Andrew Morton 发布的实验性补丁。过去，-mm 树曾用于测试子系统的补丁，但这一功能现在通过 `linux-next`（https://www.kernel.org/doc/man-pages/linux-next.html）树来完成。子系统维护者首先将他们的补丁推送到 linux-next，在合并窗口期间直接发送给 Linus。-mm 补丁作为新功能和其他未通过子系统树合并的实验性补丁的试验场。一旦某个补丁在 -mm 中经过一段时间的验证，Andrew 就会将其提交给 Linus，以便包含在主线中。linux-next 树每天都会更新，并且包含了 -mm 补丁。两者都处于不断变化中，包含许多实验性功能、大量不适合进入主线的调试补丁等，是本文档中描述的分支中最具有实验性的。
这些补丁不适合用于应该保持稳定的系统，并且它们比其他任何分支都更具有风险（请确保你的备份是最新的——这对任何实验性内核都是必要的，但对于-mm补丁或使用linux-next树中的内核来说尤为重要）。测试-mm补丁和linux-next是非常受赞赏的，因为它们的主要目的是在变更合并到更加稳定的主线Linus树之前，找出回退、崩溃、数据损坏错误、构建中断（以及任何其他类型的错误）。

但是，-mm和linux-next的测试者应该意识到，这些问题的发生频率要比其他任何树都要高。

这结束了对各种内核树的解释列表。希望你现在清楚如何应用各种补丁并帮助测试内核。

感谢Randy Dunlap、Rolf Eike Beer、Linus Torvalds、Bodo Eggert、Johannes Stezenbach、Grant Coady、Pavel Machek以及其他可能被我遗漏的人对本文档的审阅和贡献。
