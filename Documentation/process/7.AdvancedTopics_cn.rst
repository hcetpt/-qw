### 高级主题

到目前为止，希望您已经掌握了开发流程的基本操作。然而，还有更多内容值得学习！本节将涵盖一些对于希望成为 Linux 内核开发过程常规成员的开发者们非常有帮助的主题。

#### 使用 git 管理补丁

内核使用分布式版本控制始于 2002 年初，当时 Linus 开始尝试使用专有的 BitKeeper 应用程序。虽然 BitKeeper 本身颇具争议，但其所体现的软件版本管理方式却不是。分布式版本控制使得内核开发项目的发展速度立即加快。目前，有许多 BitKeeper 的免费替代品。无论好坏，内核项目最终选择了 git 作为其首选工具。

使用 git 管理补丁可以使开发者的日常工作变得更加轻松，尤其是当补丁数量增加时。git 也有一些缺点，并且存在一定的风险；它是一个年轻而强大的工具，仍然在由其开发者进行改进。本文档不会试图教会读者如何使用 git；这需要单独的一篇长文来详细说明。相反，本文档的重点在于 git 如何融入特定的内核开发过程中。希望熟悉 git 的开发者可以访问：

- https://git-scm.com/
- https://www.kernel.org/pub/software/scm/git/docs/user-manual.html

以及网络上其他各种教程。

首要任务是阅读上述网站并深入了解 git 的工作原理，然后再尝试使用它来向他人提供补丁。使用 git 的开发者应该能够获取主线仓库的副本、浏览修订历史记录、向树中提交更改、使用分支等。了解 git 中用于重写历史的工具（如 rebase）也是有用的。git 有自己的术语和概念；新用户应该了解 refs、远程分支、索引、快进合并、推送和拉取、分离头指针等。这些概念一开始可能有些令人望而生畏，但稍加学习就能理解它们并不难。

在熟悉 git 的同时，使用 git 生成要通过电子邮件提交的补丁是一个很好的练习。

当你准备开始为其他人设置 git 仓库时，当然需要一台可以从其中拉取数据的服务器。如果你有一个可以通过互联网访问的系统，那么使用 git-daemon 设置这样的服务器相对直接。否则，免费的公共托管站点（例如 Github）也开始在网络上出现。成熟的开发者可以在 kernel.org 上获得账户，但这些账户并不容易获得；更多信息请参阅 https://kernel.org/faq/。

正常的 git 工作流涉及大量分支的使用。每个开发线都可以分离到一个独立的“主题分支”并独立维护。git 中的分支成本低廉，没有理由不充分利用它们。而且，在任何情况下，你不应该在你打算让别人从中拉取的分支中进行开发。
公开可用的分支应该谨慎创建；只有当补丁处于完整形式且准备好时才从开发分支合并补丁——而不是在此之前。

git 提供了一些强大的工具，可以让你重写你的开发历史。不方便的补丁（例如，破坏了二分法或明显有错误的补丁）可以就地修复或者完全从历史中消失。即使你已经开发了几个月，补丁系列也可以被重写成好像它是基于今天的主线编写的。更改可以透明地从一个分支转移到另一个分支。等等。适当使用 git 重写历史的能力有助于创建更干净、问题更少的补丁集。

然而，过度使用这种能力可能会导致其他问题，除了对创造完美项目历史的简单痴迷之外。
将历史重写会改变其中包含的变更，这会将一个经过测试（希望如此）的内核树变成未经测试的状态。但除此之外，如果没有共享的历史视图，开发者之间很难进行协作；如果你重写了其他开发者已拉取到其仓库中的历史记录，会给这些开发者带来更多的困扰。因此，这里有一个简单的经验法则：一旦历史被导出给其他人后，通常应被视为不可更改。
因此，一旦你将一组变更推送到公开服务器上，就不应该再对这些变更进行重写。如果尝试推送不会导致快速前进合并的变更（即没有共享相同历史的变更），Git 会试图强制执行这一规则。虽然可以覆盖这个检查，但在某些情况下可能有必要重写已导出的树。例如，在不同树之间移动变更集以避免在 `linux-next` 中产生冲突就是一种情况。但这种行为应该很少发生。这也是为什么开发工作应在私有分支中进行（必要时可以重写）的原因之一，并且只有当开发进展到相对成熟的状态时才移至公共分支。

随着主线（或作为一组变更基础的其他树）的发展，与该树合并以保持领先地位是很诱人的。对于私有分支而言，重新基化（rebasing）可以轻松地跟上另一棵树的步伐，但是一旦树被导出到全世界之后，重新基化就不再是一个选项。此时，必须进行完整的合并。偶尔进行合并是有道理的，但是过于频繁的合并可能会无谓地杂乱历史记录。建议的做法是不频繁地合并，并且通常只在特定发布点（如主线 `-rc` 发布）进行。如果你担心某些具体变更，可以在私有分支中执行测试合并。`git rerere` 工具在这种情况下非常有用；它可以记住如何解决合并冲突，这样你就无需重复做同样的工作。

关于像 Git 这样的工具最大的反复抱怨之一是：从一个仓库到另一个仓库的大规模变更移动使得容易在审查雷达下溜进不合理的变更，进而进入主线。内核开发者看到这种情况发生往往会感到不满；如果在 git 树中放置未经审查或偏离主题的补丁可能会影响你未来获取树被拉取的机会。引用 Linus 的话：

:: 

    你可以给我发送补丁，但要我从你那里拉取 Git 补丁，我需要知道你明白自己在做什么，而且我需要能够信任这些变更，而不需要手动检查每个变更。

为了避免这种情况，请确保给定分支内的所有补丁都紧密围绕相关主题；“驱动修复”分支不应该对核心内存管理代码进行修改。最重要的是，不要使用 Git 树来绕过审查过程。定期在相关列表中发布树的总结，并在适当的时候请求将树包含在 `linux-next` 中。

如果其他人开始向你的树发送要纳入的补丁，请不要忘记审查它们。同时，请确保保留正确的作者信息；`git am` 工具在这方面尽力做到最好，但如果补丁是由第三方转发给你的，则可能需要在补丁中添加 “From:” 行。

在请求拉取时，请务必提供所有相关信息：你的树在哪里、要拉取哪个分支以及拉取会产生哪些变更。`git request-pull` 命令在这方面很有帮助；它将以其他开发者期望的方式格式化请求，并且还会检查你是否记得将这些变更推送到公共服务器。

.. _development_advancedtopics_reviews:

审查补丁
---------

一些读者可能会反对将本节放在“高级主题”中，理由是即使是初学者级别的内核开发者也应该审查补丁。确实，没有什么比查看他人发布的代码更好的方法来学习在内核环境中编程了。此外，审查者总是供不应求；通过查看代码，你可以为整个流程做出重大贡献。

审查代码可能是一件令人望而生畏的事情，尤其是对于新内核开发者来说，他们可能会在公开场合质疑由更有经验的人发布的代码时感到紧张。即便是由最有经验的开发者编写的代码也可能得到改进。也许对于审查者（所有审查者）来说最好的建议是：将审查评论表述为问题而不是批评。问“这条路径中的锁是如何释放的？”总比说“这里的锁定有问题”效果要好得多。

在出现分歧的情况下，另一种有用的技巧是请求其他人发表意见。如果讨论在几次交流后陷入僵局，那么可以要求其他审查者或维护者提出他们的看法。通常那些同意审查者观点的人除非被要求否则会保持沉默。
多人的意见具有指数级的更大分量。
不同的开发者会从不同的角度审查代码。一些人主要关注编码风格和代码行尾是否有空白。另一些人则主要关注整个补丁实现的更改是否对内核有益。还有一些人会检查可能存在的锁问题、过度使用栈空间、潜在的安全问题、与其他地方重复的代码、充分的文档说明、对性能的负面影响、用户空间ABI变更等。
所有类型的审查，只要能促使更好的代码被纳入内核，都是受欢迎且有价值的。
没有严格要求必须使用特定的标签，如“Reviewed-by”（已审阅）。
事实上，即使是提供了标签，用纯英文进行的审查也更具有信息性和鼓励性，例如，“我查看了这个提交的A、B和C方面，我认为它是好的。”
显然，某种形式的审查消息或回复是必要的，否则维护者将无法得知审查者是否已经查看过该补丁。

最后但同样重要的是，补丁审查可能会变成一个负面的过程，专注于指出问题。请偶尔给出表扬，特别是对于新手！
