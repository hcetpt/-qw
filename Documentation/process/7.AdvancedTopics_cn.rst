.. _development_advancedtopics:

高级主题
===============

到目前为止，希望你已经掌握了开发过程的基本操作。然而，还有更多可以学习的内容！本节将涵盖一些有助于开发者成为Linux内核开发过程常规成员的主题。

使用git管理补丁
-------------------------

内核使用分布式版本控制始于2002年初，当时Linus开始尝试使用专有的BitKeeper应用程序。虽然BitKeeper本身存在争议，但它所体现的软件版本管理方法并没有争议。分布式版本控制使内核开发项目立即加速。目前，有几种免费的BitKeeper替代工具。不管怎样，内核项目最终选择了git作为首选工具。

使用git管理补丁可以使开发人员的生活更轻松，尤其是在补丁数量增加时。git也有一些缺点并带来一定的风险；它是一个年轻而强大的工具，仍在由其开发者不断改进。本文档不会试图教会读者如何使用git；这需要单独写一个长篇文档来说明。相反，这里的重点是如何在特定的内核开发过程中使用git。希望熟悉git的开发者可以在以下网址找到更多信息：

    https://git-scm.com/

    https://www.kernel.org/pub/software/scm/git/docs/user-manual.html

以及互联网上的各种教程。

首要任务是阅读上述网站，获得对git工作原理的扎实理解，然后再尝试用它来提供补丁给他人。使用git的开发人员应该能够获取主线仓库的副本，浏览修订历史记录，提交更改到树中，使用分支等。了解git用于重写历史（如rebase）的工具也很有用。git有自己的术语和概念；新用户应该了解refs、远程分支、索引、快进合并、推送和拉取、分离的头指针等。一开始可能会有点让人望而生畏，但通过一点学习，这些概念并不难理解。

使用git生成通过电子邮件提交的补丁，在熟悉的过程中是一个很好的练习。

当你准备开始为其他人搭建git树时，当然需要一个可以从其拉取的服务器。如果你有一个可访问互联网的系统，通过git-daemon设置这样的服务器相对直接。否则，免费的公共托管网站（如Github）也开始出现在网络上。成熟的开发者可以在kernel.org上获得账户，但这些账户并不容易得到；更多信息请参阅 https://kernel.org/faq/

正常的git工作流程涉及大量分支的使用。每条开发线都可以分离成独立的“主题分支”并独立维护。git中的分支是廉价的，没有理由不充分利用它们。无论如何，你不应在任何打算让别人从中拉取的分支中进行开发。

公开可用的分支应谨慎创建；只有当补丁在开发分支中完全形成且准备好后才将其合并进来——而不是在此之前。

git提供了一些强大的工具，可以让你重写开发历史。一个不方便的补丁（比如破坏了二分查找，或者有其他明显的错误）可以在原地修复或从历史中完全消失。即使你已经工作了几个月，也可以将补丁系列重写为好像它是基于今天的主线编写的。更改可以透明地从一个分支转移到另一个分支。等等。合理利用git重写历史的能力可以帮助创建干净的补丁集，减少问题。

然而，过度使用这种能力会导致其他问题，而不仅仅是对创建完美项目历史的简单痴迷。
重写历史将重写该历史中的变更，
将一个经过测试（希望如此）的内核树变成未经测试的。除此之外，如果开发者们没有共享的历史视图，他们就无法轻松协作；如果你重写了其他开发者已经拉取到其仓库的历史记录，将会给这些开发者带来很大的麻烦。因此，这里有一个简单的经验法则：一旦历史被导出给其他人，之后一般应视为不可变。
因此，一旦你将一组变更推送到公开服务器上，就不应该再重写这些变更。当你尝试推送不能进行快速合并的变更（即不共享相同历史的变更）时，Git会尝试强制执行此规则。虽然可以覆盖此检查，并且有时可能需要重写已导出的树，比如为了在不同树之间移动变更集以避免在`linux-next`中的冲突。但这种行为应当很少发生。这也是为什么开发工作应在私有分支中进行（必要时可以重写），只有在进入相对成熟的状态时才移到公共分支中的原因之一。
随着主干（或作为一组变更基础的其他树）的发展，与该树合并以保持领先是很诱人的。对于私有分支来说，重新基化（rebase）是一种简单的方法来跟上另一个树的步伐，但在一棵树被导出给全世界后，重新基化就不再是一个选项。一旦发生这种情况，必须进行完整的合并。偶尔合并是合理的，但过于频繁的合并可能会不必要的杂乱历史记录。在这种情况下，建议的技巧是不频繁地合并，并且通常仅在特定发布点（如主干-rc版本）进行合并。如果你对某些特定变更感到不安，可以在私有分支中进行测试合并。`git rerere`工具在这种情况下很有用；它记住了解决合并冲突的方式，因此你不必重复做同样的工作。
关于像Git这样的工具的最大反复抱怨之一是：从一个仓库到另一个仓库的大规模变更移动使得容易在未经审查的情况下引入不良变更，从而进入主干。当内核开发者看到这种情况发生时往往会感到不满；发布包含未审查或偏离主题补丁的Git树会影响你在未来获得合并的能力。引用Linus的话：

::

    你可以发送补丁给我，但对于我来说，要从你那里拉取Git补丁，我需要知道你知道自己在做什么，并且我需要能够信任这些内容，而不需要手动去检查每一个单独的变更。

为了避免这种情况，请确保给定分支中的所有补丁紧密围绕相关主题；“驱动修复”分支不应更改核心内存管理代码。最重要的是，不要使用Git树绕过审查过程。定期向相关列表发布树的摘要，并在适当的时候请求将其包含在`linux-next`中。
如果其他人开始发送补丁以包含在你的树中，请不要忘记审查它们。同时确保维护正确的作者信息；`git am`工具在这方面尽力了，但如果补丁是通过第三方转发给你的，则可能需要在补丁中添加一个“From:”行。
在请求拉取时，请务必提供所有相关信息：你的树在哪里、要拉取哪个分支以及拉取会导致哪些变更。`git request-pull`命令在这方面可能是有用的；它可以按照其他开发者期望的格式提出请求，并且还会检查你是否记得将这些变更推送到公共服务器。

.. _development_advancedtopics_reviews:

审查补丁
---------

一些读者肯定会反对将本节归类为“高级主题”，认为即使是初学的内核开发者也应该审查补丁。确实，没有比查看他人发布的代码更好的学习如何在内核环境中编程的方法了。此外，审查者总是供不应求；通过查看代码，你可以对整个过程做出重要贡献。
审查代码可能是一个令人畏惧的任务，特别是对于新内核开发者来说，他们可能对在公共场合质疑由更有经验的人发布的代码感到紧张。即使是经验最丰富的开发者编写的代码也可能有所改进。或许对审查者（所有审查者）来说最好的建议是：将审查评论表述为问题而非批评。询问“这条路径中的锁是如何释放的？”总是比断言“这里的锁定有问题”更好。

另一种在出现分歧时有用的技术是邀请其他人发表意见。如果讨论在几次交流后陷入僵局，则可以呼吁其他审查者或维护者的意见。通常那些同意审查者观点的人会保持沉默，除非被要求发言。
多人的意见具有指数级的更大分量。
不同的开发者会从不同的角度审查代码。一些开发者主要关注编码风格和代码行尾是否有空白。另一些则主要关注整个补丁实现的变更是否对内核有益。还有一些会检查有问题的锁、过多的栈使用、可能的安全问题、其他地方重复的代码、充分的文档、性能的负面影响、用户空间ABI变更等。

所有类型的审查，如果能导致更好的代码进入内核，都是受欢迎且有价值的。
没有严格要求使用特定的标签，如“Reviewed-by”。
事实上，即使提供了标签，用简单的英语进行审查也更有信息量并被鼓励，例如：“我查看了此提交的A、B和C方面，我认为很好。”

显然，某种形式的审查信息或回复是必要的，否则维护者将不知道审查者是否查看过该补丁。

最后但同样重要的是，补丁审查可能会变成一个负面的过程，专注于指出问题。请偶尔给予表扬，特别是对于新手！
