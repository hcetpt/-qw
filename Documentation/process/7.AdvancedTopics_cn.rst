高级主题
===============

到目前为止，希望你已经掌握了开发流程的基本操作。然而，还有更多要学习的！本节将涵盖一系列对那些希望成为Linux内核开发过程常规部分的开发者有帮助的主题。

使用git管理补丁
-------------------------

对于内核使用分布式版本控制始于2002年初，当时Linus开始尝试使用专有的BitKeeper应用。尽管BitKeeper存在争议，但其所体现的软件版本管理方式绝不是有争议的。分布式版本控制立即加速了内核开发项目的进展。目前，有多个BitKeeper的免费替代品。无论好坏，内核项目已选择git作为其首选工具。

使用git管理补丁可以极大地简化开发者的生活，尤其是在补丁数量增加时。git也有一些粗糙的边缘并带来一定的风险；它是一个年轻且强大的工具，仍处于开发者文明化的过程中。本文档不会试图教会读者如何使用git；这足以成为一篇独立的长篇文章。相反，这里关注的重点是git如何特别融入内核开发流程中。想要熟悉git的开发者可以在以下链接找到更多信息：

	https://git-scm.com/

	https://www.kernel.org/pub/software/scm/git/docs/user-manual.html

以及网络上各种教程。

首要任务是从上述网站阅读并获得对git工作原理的扎实理解，在尝试使用它向他人提供补丁之前。使用git的开发者应该能够获取主线仓库的副本，探索修订历史，对树进行更改提交，使用分支等。了解git用于重写历史（如rebase）的工具也是有用的。git带有自己的术语和概念；新的git用户应该了解refs、远程分支、索引、快进合并、推送和拉取、分离的头部等。一开始可能会有点令人生畏，但是通过一点学习，这些概念并不难掌握。

在熟悉使用git生成电子邮件提交的补丁时，这可以是一个很好的练习。

当你准备开始为其他人建立git树时，当然需要一个可以从其拉取的服务器。如果你拥有一台可访问互联网的系统，使用git-daemon设置这样的服务器相对直接。否则，免费的公共托管站点（如Github）已经开始在网络上出现。经验丰富的开发者可以获得kernel.org上的账户，但这并不容易获得；更多信息请参阅https://kernel.org/faq/。

正常的git工作流涉及大量分支的使用。每个开发线都可以分离成单独的“主题分支”，并独立维护。git中的分支成本低廉，没有理由不充分利用它们。无论如何，你不应该在任何你打算让别人从其拉取的分支中进行开发。

公开可用的分支应谨慎创建；仅当补丁以完整形式准备好时才从开发分支合并补丁——而不是在此之前。

git提供了一些强大的工具，允许你重写你的开发历史。一个不方便的补丁（例如，破坏二分法或有其他明显错误的补丁）可以在原地修复或完全从历史中消失。即使你已经为此工作了数月，补丁系列也可以被重写，仿佛它是基于今天的主线编写的。更改可以透明地从一个分支转移到另一个分支。等等。明智地使用git修改历史的能力有助于创建干净的补丁集，问题更少。

然而，过度使用这种能力会导致其他问题，而不仅仅是对创建完美项目历史的简单痴迷。
重写历史将重写其中包含的变更，将一个经过测试（希望如此）的内核树变成未经测试的。但除此之外，如果开发者们没有共享的历史项目视图，他们就无法轻松地协作；如果你重写了其他开发者已经拉取到其仓库中的历史，你将使这些开发者的处境变得困难得多。因此，这里有一个简单的经验法则：一旦历史被导出给其他人，之后一般应视为不可更改。

所以，一旦你将一组变更推送到公开可用的服务器上，那些变更就不应该被重写。Git会在你尝试推送不导致快进合并的变更时（即变更历史不相同）试图强制执行这一规则。虽然可以覆盖此检查，且有时可能需要重写已导出的树。将变更集在树之间移动以避免在linux-next中发生冲突就是一个例子。但此类操作应尽量少。这也是为什么开发应在私有分支中进行（如果必要的话可以重写），只有在达到相当高级阶段时才移至公共分支的原因之一。

随着主线（或变更集所基于的其它树）的发展，与之合并以保持领先地位是很诱人的。对于私有分支，重新基化可以是一种轻松的方式，以跟上另一棵树的步伐，但一旦树被导出到全世界，重新基化就不是一个选项了。一旦发生这种情况，必须进行完全合并。偶尔合并是有意义的，但过于频繁的合并会无谓地杂乱历史。在这种情况下建议的技巧是不频繁地合并，通常只在特定发布点（如主线-rc发布）进行。如果你对特定的变更感到不安，你总可以在私有分支中执行测试合并。git的“rerere”工具在这种情况下很有用；它会记住如何解决合并冲突，这样你就不会重复做同样的工作。

关于像git这样的工具最大的反复抱怨之一是：从一个仓库到另一个的大规模补丁移动使得容易在审查雷达下悄悄混入不理智的变更，然后进入主线。当看到这种事情发生时，内核开发者往往会感到不满；在未审查或偏离主题的补丁下建立git树可能会影响你将来获得树被拉动的能力。引用Linus的话：

你可以向我发送补丁，但如果我要从你那里拉动git补丁，我需要知道你知道自己在做什么，并且我需要能够信任事情，而无需手动去检查每一项变更。

为了避免这种局面，确保给定分支内的所有补丁都紧密遵循相关主题；“驱动修复”分支不应更改核心内存管理代码。最重要的是，不要使用git树来绕过审查过程。偶尔在相关列表上发布树的总结，并在适当的时候请求将树包含在linux-next中。

如果他人开始向你的树发送补丁以供纳入，请不要忘记审查它们。同时确保维护正确的作者信息；git的“am”工具在这方面尽力而为，但如果补丁是通过第三方转发给你的，你可能需要在补丁中添加一个“From:”行。

在请求拉动时，务必提供所有相关信息：你的树在哪里，要拉动哪个分支，以及拉动后会发生什么变更。git的request-pull命令在这方面可能有所帮助；它将以其他开发者期望的格式提出请求，并还会检查你是否记得将这些变更推送到公共服务器。

.. _development_advancedtopics_reviews:

审查补丁

一些读者可能会反对将本节归类于“高级主题”，理由是即使是初学者内核开发者也应该审查补丁。确实，没有比查看他人发布的代码更好的学习在内核环境中编程的方法了。此外，评审者总是短缺；通过审查代码，你可以对整个流程做出重大贡献。

审查代码可能是一个令人生畏的前景，尤其是对于新内核开发者来说，他们可能对在公共场合质疑由更有经验的人发布的代码感到紧张。即使是由最有经验的开发者编写的代码也可以改进。也许对评审者（所有评审者）来说最好的建议是：将评审评论表述为问题而非批评。询问“这条路径中的锁是如何释放的？”总是比陈述“这里的锁定是错误的”效果更好。

在遇到分歧时，另一种有用的技术是要求其他人参与讨论。如果几次交流后讨论陷入僵局，则可以呼吁其他评审者或维护者的意见。通常，那些同意评审者观点的人除非被召唤否则会保持沉默。
多人的意见具有指数级的更大分量。
不同的开发者会从不同的角度审查代码。有些人主要关注编码风格和代码行尾是否有空白。另一些人则主要关注补丁整体实现的更改对内核来说是否是好事。还有一些人会检查可能存在的锁定问题、过度使用栈空间、潜在的安全问题、与其他地方重复的代码、充分的文档说明、对性能的负面影响、用户空间 ABI 的变更等。
所有类型的审查，只要能导致更好的代码被合并到内核中，都是受欢迎且有价值的。
没有严格要求必须使用特定标签如“Reviewed-by”（已审查）。
事实上，即使提供了标签，用纯英文进行的审查也更具有信息性和鼓励性，例如：“我查看了此提交的A、B和C方面，我认为它看起来不错。”
显然需要某种形式的审查消息或回复，否则维护者将无法得知审查者是否已经查看过该补丁！

最后但同样重要的是，补丁审查可能会变成一个负面过程，专注于指出问题。请偶尔给出一些赞美，特别是对于新手！
