SPDX 许可证标识符：GPL-2.0

KVM x86
=======

前言
--------
KVM 力求成为一个包容的社区；我们珍视并鼓励新成员的贡献。请不要被这份文件的长度及其包含的众多规则/指导方针所吓倒或感到压力。每个人都会犯错，每个人都有过新手时期。只要你真诚地努力遵循 KVM x86 的指导方针，对反馈持开放态度，并从你所犯的任何错误中学习，你将受到热情的欢迎，而不是遭遇火把和长柄叉。

简而言之（TL;DR）
-----
测试是强制性的。与已建立的风格和模式保持一致。

树结构
-----
目前，KVM x86 正处于从作为主 KVM 树的一部分向成为“另一个 KVM 架构”的过渡期。因此，KVM x86 分布在主 KVM 树，“git.kernel.org/pub/scm/virt/kvm/kvm.git”，和一个专门针对 KVM x86 的树，“github.com/kvm-x86/linux.git”。

通常来说，当前周期的修复会直接应用于主 KVM 树，而所有针对下个周期的开发则通过 KVM x86 树进行。万一当前周期的修复通过 KVM x86 树进行，它将在到达主 KVM 树之前应用到“fixes”分支上。

值得注意的是，这一过渡期预计将持续相当长的时间，即在可预见的未来，这将是常态。

分支
~~~~~~~~
KVM x86 树由多个主题分支组成。使用更精细的主题分支的目的在于，便于关注某一领域的开发进展，以及限制人为错误和/或有缺陷的提交所带来的附带损害，例如，丢弃主题分支的最新提交不会影响其他正在进行中的提交的 SHA1 哈希值，而且由于 bug 而不得不拒绝的拉取请求只会延迟那个特定主题分支。

除了“next”和“fixes”之外的所有主题分支，根据需要以克苏鲁合并的方式整合到“next”分支中，即当某个主题分支更新时。

因此，对“next”分支的强制推送很常见。

生命周期
~~~~~~~~~
针对当前版本（即主线）的修复通常直接应用于主 KVM 树，即不通过 KVM x86 树进行。

针对下一个版本的变更则通过 KVM x86 树进行。对于每个 KVM x86 主题分支，会在 Linus 开启合并窗口前一周左右（例如，在“常规”版本的 rc7 后的一周），发送拉取请求（从 KVM x86 到主 KVM）。如果一切顺利，这些主题分支将在 Linus 的合并窗口期间发送的主 KVM 拉取请求中整合。
KVM x86树没有自己的官方合并窗口，但在rc5左右对新功能有一个非正式的关闭时间点，在rc6左右对修复（针对下一个版本发布；有关当前版本发布的修复请参见上述内容）也有一个非正式的关闭时间点。

时间表
------
提交通常按照先进先出（FIFO）的顺序进行审查和应用，对于系列的大小、"热点缓存"的补丁等有一些灵活的空间。修复，特别是针对当前版本或稳定分支的修复可以优先处理。
那些将通过非KVM树（最常见的是通过tip树）进行处理和/或其他获得确认/审查的补丁也在一定程度上享有优先权。
需要注意的是，绝大多数的审查工作是在rc1到rc6之间完成的，前后略有浮动。
从rc6到下一个rc1之间的这段时间用于处理其他任务，即在这段时间内保持无线电静默并不罕见。
欢迎发送消息以获取状态更新，但请记住当前版本周期的时间，并且要有合理的期望值。如果您请求接受而非仅仅反馈或更新，请确保您的补丁已经准备好合并！对于破坏构建或测试失败的系列发送消息会导致维护者不高兴！

开发
----
基础树/分支
~~~~~~~~~~
针对当前版本的修复，也称为主线版本，应该基于`git://git.kernel.org/pub/scm/virt/kvm/kvm.git master`。请注意，修复并不自动保证被纳入当前版本。没有单一的规则，但通常只有那些紧急、关键或者是在当前版本中引入的bug的修复才应针对当前版本。
其他所有内容都应基于`kvm-x86/next`，即无需选择特定的主题分支作为基线。如果存在跨主题分支的冲突和/或依赖关系，则由维护者负责解决这些问题。
使用`kvm-x86/next`作为基线的唯一例外是当补丁/系列为多架构系列时，即对通用KVM代码进行了非微不足道的修改，和/或对其他架构的代码进行了不仅仅是表面的修改。多架构的补丁/系列应该基于KVM历史中的一个共同稳定的点，例如`kvm-x86 next`所基于的发布候选版本。如果您不确定某个补丁/系列是否真正属于多架构，请谨慎行事并将其视为多架构，即使用共同的基线。

编码风格
~~~~~~~~
在风格、命名、模式等方面，一致性是KVM x86的首要关注点。如果无法确定，就与已存在的内容保持一致。
除了下面列出的一些例外情况，遵循tip树维护者首选的:ref:`maintainer-tip-coding-style`，因为补丁/系列经常涉及KVM和非KVM x86文件，即会同时引起KVM和tip树维护者的注意。
使用反向圣诞树形式（又称为反向圣诞节树或反向XMAS树）进行变量声明并非严格要求，尽管仍较为推荐。除少数特殊情况外，不要为函数使用内核文档注释。绝大多数所谓的“公共”KVM函数实际上并不真正对外开放，因为它们仅用于KVM内部使用（有计划将KVM的头文件和导出私有化以实施这一点）。

注释
~~~~~
使用祈使语气编写注释，并避免使用代词。利用注释来提供代码的高层次概述，或者解释代码为何如此工作。不要重复代码本身所做的事情；让代码自己说话。如果代码本身难以理解，注释也无法帮助。

SDM 和 APM 参考
~~~~~~~~~~~~~~~~
KVM的大量代码直接与Intel的软件开发手册(SDM)及AMD的架构程序员手册(APM)中定义的架构行为相关联。在没有额外上下文的情况下使用“Intel的SDM”、“AMD的APM”，甚至仅仅使用“SDM”或“APM”是完全可接受的。

不要按数字引用特定章节、表格、图表等，尤其是在注释中。相反，如果必要（见下文），可以复制相关的片段，并通过名称而不是编号来引用章节/表格/图表。SDM和APM的布局经常变化，因此这些编号/标签并不稳定。

一般来说，在注释中明确引用或从SDM或APM复制粘贴内容并不合适。除了少数例外，KVM必须遵守架构行为，因此可以认为KVM的行为是在模拟SDM和/或APM的行为。

注意，在变更日志中引用SDM/APM以证明变更合理性并提供背景信息是完全合适的，也是鼓励的。

简要日志
~~~~~~~~
首选的前缀格式是`KVM: <主题>:`，其中`<主题>`可以是：

  - x86
  - x86/mmu
  - x86/pmu
  - x86/xen
  - 自测
  - SVM
  - nSVM
  - VMX
  - nVMX

**不要使用 x86/kvm！** `x86/kvm` 专门用于Linux作为KVM客户机的变化，即用于arch/x86/kernel/kvm.c。不要使用文件名或完整的文件路径作为主题/简要日志的前缀。

注意，这些与主题分支并不一致（主题分支更关注代码冲突）。

所有名称都是大小写敏感的！`KVM: x86:` 是正确的，而`kvm: vmx:` 则不正确。
将压缩的补丁描述中的第一个单词大写，但省略结尾标点。例如：

    KVM: x86: 修复function_xyz()中的空指针解引用

而不是：

    kvm: x86: 修复function_xyz中空指针解引用
如果一个补丁涉及多个主题，请沿着概念树向上查找第一个共同父级（通常是“x86”）。当有疑问时，“git log path/to/file”应该提供一个合理的提示。
新主题偶尔会出现，但如果想要提议引入新主题，请在列表上开始讨论，即不要擅自行动。
更多信息请参阅：:ref:`the_canonical_patch_format`，但有一个修改：不要将70-75个字符的限制视为绝对硬性限制。相反，将75个字符作为坚定但非硬性的限制，并将80个字符作为硬性限制。也就是说，如果有充分的理由，可以让短日志稍微超过标准限制。
变更日志
~~~~~~~~~
最重要的是，使用祈使语气编写变更日志并避免使用代词。
更多信息请参阅：:ref:`describe_changes`，但有一个修改：首先简要说明实际的变更，然后跟进上下文和背景。注意！这个顺序与尖端树首选的方法直接冲突！在发送主要针对arch/x86代码（_不是_KVM代码）的补丁时，请遵循尖端树的首选风格。
在KVM x86中，在深入细节之前先说明补丁的作用是首选的，原因有几个。首先，实际正在更改的代码可以认为是最重要的信息，因此这些信息应该容易找到。将“实际更改了什么”埋藏在一两句话后、三段以上的背景信息之后的变更日志，使得很难找到这些信息。
对于初步审查，可以说“出了什么问题”更重要，但对于浏览日志和git考古学而言，详细信息变得越来越不重要。
例如，在进行一系列“git blame”时，沿途每个变更的详细信息都是无用的，只有罪魁祸首的详细信息才重要。提供“变更了什么”使得可以轻松确定提交是否可能感兴趣。
首先说明“变更了什么”的另一个好处是，几乎总能用一句话来说明“变更了什么”。相比之下，除了最简单的bug之外，完全描述问题通常需要多句或多个段落。如果“变更了什么”和“bug是什么”都非常简短，那么顺序并不重要。但如果其中一个更短（通常是“变更了什么”），那么首先涵盖较短的部分是有利的，因为对于有严格顺序偏好的读者/评审者来说，这不太麻烦。例如，跳过一句话到达上下文比跳过三段到达“变更了什么”带来的不便要小得多。
修复
~~~~~
如果变更修复了KVM/内核的bug，即使该变更无需回退到稳定版本的内核，也即使该变更修复的是旧版本中的bug，也要添加一个Fixes:标签。
反之，如果修复确实需要回退，则需明确在补丁上标记“Cc: stable@vger.kernel”（尽管邮件本身不必抄送stable）；KVM x86默认不参与回退修复。一些自动选择的补丁确实会得到回退，但需要显式维护者批准（搜索MANUALSEL）。

函数引用
~~~~~~~~~~~~~~~~~~~
当在注释、更改日志或简短日志（或任何地方）中提及一个函数时，使用格式`function_name()`。括号提供了上下文并消除了引用的歧义。

测试
-------
至少，系列中的所有补丁都必须能够干净地构建KVM_INTEL=m, KVM_AMD=m和KVM_WERROR=y。构建所有可能的Kconfig组合并不现实，但越多越好。KVM_SMM, KVM_XEN, PROVE_LOCKING, 和 X86_64是特别有趣的配置选项。

运行KVM自测和KVM单元测试也是强制性的（显然，测试需要通过）。唯一的例外是那些对运行时行为几乎没有影响概率的变更，例如仅修改注释的补丁。尽可能且相关的情况下，在Intel和AMD上进行测试是强烈推荐的。启动一个实际的虚拟机是鼓励的，但不是强制的。

对于触及KVM影子分页代码的变更，禁用TDP（EPT/NPT）是强制性的。对于影响通用KVM MMU代码的变更，禁用TDP是强烈推荐的。对于所有其他变更，如果被修改的代码依赖于和/或与模块参数交互，那么进行相关设置的测试是强制性的。

请注意，KVM自测和KVM单元测试确实存在已知的失败情况。如果你怀疑失败并非由于你的变更引起，请验证在有无你的变更下是否出现完全相同的失败。

触及reStructured Text文档，即.rst文件的变更，必须能够干净地构建htmldocs，即没有新的警告或错误。

如果你无法全面测试一个变更，例如由于缺乏硬件，请清楚说明你能够做到的测试水平，例如在封面信中。

新特性
~~~~~~~~~~~~
除了一种例外，新功能必须附带测试覆盖。KVM特定的测试不是严格要求的，例如，如果通过运行足够启用的guest VM或在VM中运行相关的内核自测来提供覆盖，但是专用的KVM测试在所有情况下都是首选的。特别是，启用新硬件特性的负向测试案例是强制性的，因为错误和异常流程很少仅仅通过运行VM来锻炼。
### 唯一的例外

此规则的唯一例外是，如果KVM仅通过KVM_GET_SUPPORTED_CPUID宣传对某个功能的支持，即对于KVM无法阻止客户机使用且不存在真正启用机制的指令/特性。请注意，“新特性”并不仅仅意味着“新硬件特性”！那些无法很好地利用现有的KVM自测或KVM单元测试进行验证的新特性必须附带测试。

在没有测试的情况下发布新特性的开发以获取早期反馈是非常受欢迎的，但此类提交应该标记为RFC，并且在封面信中应清楚说明所请求/期望的是哪种类型的反馈。不要滥用RFC流程；RFC通常不会获得深入审查。

### 修复错误

除了那些显而易见、通过检查就能发现的错误之外，修复必须附带可以重现该问题的方法。在许多情况下，重现方法是不言自明的，例如构建错误和测试失败的情况，但是读者仍需清楚地知道哪里出了问题以及如何验证修复结果。对于那些通过非公开的工作负载/测试发现的错误，允许有一定的灵活性，但对于这类错误提供回归测试则更为优选。

一般来说，对于不容易重现的任何错误，都更倾向于提供回归测试。例如，即使最初是通过诸如syzkaller之类的模糊测试工具发现的错误，如果该错误需要触发一种百万分之一的竞态条件，那么一个有针对性的回归测试可能是合理的。

请注意，KVM中的错误很少既紧急又难以重现。在没有提供重现方法的情况下发布修复之前，请问问自己这个错误是否真的那么严重。

### 发布

#### 链接

不要通过`In-Reply-To:`头部明确引用错误报告、补丁/系列的先前版本等。对于大型系列或者当版本号变得很高时，使用`In-Reply-To:`会变得一团糟，而且对于没有原始消息的人来说（例如某人没有被抄送错误报告或收件人列表在不同版本之间发生了变化）`In-Reply-To:`毫无用处。

要链接到错误报告、先前版本或任何值得关注的内容，请使用lore链接。一般而言，在更改日志中不要包含指向先前版本的Link:，因为没有必要将历史记录记录在git中——即把链接放在封面信或git忽略的部分即可。对于导致了补丁的错误报告和/或讨论，请提供正式的Link:。对于未来读者来说，了解做出变更的原因极其有价值。
Git 基础

如果你使用的是 2.9.0 或更高版本的 Git（Google 的员工，这包括你们所有人！），请使用 `git format-patch` 命令，并带上 `--base` 标志来自动在生成的补丁中包含基树信息。

注意：只有当一个分支的上游被设置为其基础主题分支时，`--base=auto` 才能按预期工作，例如，如果您的上游被设置为个人仓库用于备份目的，它将产生错误的结果。另一种“自动”解决方案是基于开发分支的 KVM x86 主题来派生分支名称，并将其输入到 `--base` 中。例如，`x86/pmu/my_branch_name`，然后编写一个小的包装器从当前分支名称中提取 `pmu` 来得到 `--base=x/pmu`，其中 `x` 是你的仓库用来追踪 KVM x86 远程的任意名称。

协同发布测试

与 KVM 变更相关的 KVM 自我测试，例如，用于 bug 修复的回归测试，应作为一个系列与 KVM 变更一起发布。标准内核二分法规则适用，即导致测试失败的 KVM 变更应排在自我测试更新之后，反之亦然，由于 KVM bug 而失败的新测试应在 KVM 修复之后。

KVM 单元测试应该始终单独发布。工具，例如 b4 am，不知道 KVM 单元测试是一个独立的仓库，并会在一系列补丁适用于不同的树时感到困惑。为了将 KVM 单元测试补丁与 KVM 补丁联系起来，首先发布 KVM 变更，然后在 KVM 单元测试补丁中提供指向 KVM 补丁/系列的 lore 链接。

通知

当补丁/系列正式被接受后，会向原始发布（多补丁系列的封面信）发送回复的通知邮件。通知将包括树和主题分支，以及应用补丁的提交的 SHA1。

如果仅应用了补丁集的一部分，这将在通知中明确说明。除非另有说明，否则可以推断出未被接受的系列中的任何补丁需要更多工作并应在新版本中提交。

如果由于某种原因，在正式接受后删除了补丁，将向通知邮件发送回复解释为何删除该补丁，以及下一步行动。

SHA1 稳定性

直到补丁进入 Linus 的树中，SHA1 并非100％稳定！一旦发送了通知，SHA1 通常就是稳定的，但事情总有可能发生。

在大多数情况下，如果已应用补丁的 SHA1 发生变化，将提供对通知邮件的更新。然而，在某些场景下，例如，如果所有 KVM x86 分支都需要重新基化，将不会给出个别通知。

漏洞

能够被来宾利用以攻击主机（内核或用户空间）的 bug，或者能够被嵌套虚拟机利用以攻击其宿主（L2 攻击 L1）的 bug 对 KVM 尤为重要。如果您怀疑 bug 可能导致逃逸、数据泄露等，请遵循 :ref:`securitybugs` 的协议进行处理。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
