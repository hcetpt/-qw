SPDX 许可证标识符: GPL-2.0

KVM x86
=======

前言
--------
KVM 力求成为一个包容的社区；我们重视并鼓励新成员的贡献。请不要被本文档的长度和其中包含的众多规则/指南所吓倒。每个人都会犯错误，每个人都有新手时期。只要你真诚地努力遵循 KVM x86 的指南，乐于接受反馈，并从你所犯的错误中学习，你会受到热烈欢迎，而不是遭遇愤怒和指责。

TL;DR
-----
测试是强制性的。请与已建立的风格和模式保持一致。

树
-----
KVM x86 目前处于一个过渡期，即从作为主 KVM 树的一部分转变为“只是另一个 KVM 架构”。因此，KVM x86 分布在主 KVM 树 `git.kernel.org/pub/scm/virt/kvm/kvm.git` 和一个特定于 KVM x86 的树 `github.com/kvm-x86/linux.git` 中。
一般来说，当前周期的修复直接应用于主 KVM 树，而所有下一周期的开发则通过 KVM x86 树进行。如果极少数情况下当前周期的修复通过 KVM x86 树进行，则会在进入主 KVM 树之前先应用到 `fixes` 分支上。
请注意，这个过渡期预计将持续很长时间，即在可预见的未来内将是常态。

分支
~~~~~~~~
KVM x86 树组织为多个主题分支。使用更细粒度的主题分支的目的是为了更容易跟踪某个开发领域，并限制人为错误或有缺陷提交所带来的附带损害，例如删除某个主题分支的 HEAD 提交不会影响其他在途提交的 SHA1 哈希值，而且因错误而拒绝拉取请求只会延迟该主题分支。

除了 `next` 和 `fixes` 之外的所有主题分支都会根据需要（如当某个主题分支更新时）通过 Cthulhu 合并到 `next` 中。因此，对 `next` 的强制推送是很常见的。

生命周期
~~~~~~~~~
针对当前发布的修复通常直接应用于主 KVM 树，即不通过 KVM x86 树。
针对下一发布的更改会通过 KVM x86 树进行。对于每个 KVM x86 主题分支，通常在 Linus 打开合并窗口的一周前发送拉取请求（从 KVM x86 到主 KVM）。如果一切顺利，这些主题分支会在 Linus 的合并窗口期间被合并进主 KVM 拉取请求中。
KVM x86树没有自己的官方合并窗口，但在rc5左右对新功能有软截止，在rc6左右对修复有软截止（针对下一个版本；当前版本的修复请参见上述内容）。

时间表
~~~~~~~
提交通常按先进先出（FIFO）顺序进行审查和应用，但会根据系列大小、"缓存热点"补丁等因素有一定的灵活性。特别是针对当前版本或稳定分支的修复可以优先处理。通过非KVM树（最常见的是通过tip树）处理或将有其他确认/审查的补丁也在一定程度上享有优先权。
请注意，大部分审查工作是在rc1到rc6之间完成的。从rc6到下一个rc1期间用于处理其他任务，即此期间的无线电静默并不罕见。
欢迎发送消息询问状态更新，但请记住当前版本周期的时间安排，并保持合理的期望值。如果你请求接受而非仅仅是反馈或更新，请确保你的补丁已经准备好被合并！导致构建中断或测试失败的系列消息会导致维护者不高兴！

开发
~~~~

基础树/分支
~~~~~~~~~~~
针对当前版本（即主线）的修复应基于`git://git.kernel.org/pub/scm/virt/kvm/kvm.git master`。注意，修复并不自动意味着会被纳入当前版本。没有单一规则，但通常只有那些紧急、关键或者是在当前版本中引入的bug修复才会针对当前版本。
其他所有内容应基于`kvm-x86/next`，即无需选择特定的主题分支作为基础。如果有跨主题分支的冲突和依赖关系，则是维护者的职责来解决这些问题。
使用`kvm-x86/next`作为基础的唯一例外是当一个补丁/系列为多架构系列时，即对通用KVM代码有非轻微修改和/或其他架构代码有非表面变化的情况。多架构补丁/系列应基于KVM历史中的某个共同稳定的点，例如`kvm-x86 next`所基于的候选发布版本。如果你不确定某个补丁/系列是否真正属于多架构，请谨慎行事，将其视为多架构，即使用共同的基础。

编码风格
~~~~~~~~~
在风格、命名、模式等方面，一致性是KVM x86的首要原则。如果无法确定，就遵循现有的做法。
除了以下几点注意事项外，遵循tip树维护者偏好的:ref:`maintainer-tip-coding-style`，因为补丁/系列经常同时涉及KVM和非KVM x86文件，即会引起KVM和tip树维护者的注意。
使用逆圣诞树（也称为逆圣诞节树或逆XMAS树）进行变量声明虽然不是严格要求的，但仍然是首选的做法。
除了少数特殊情况外，不要为函数使用kernel-doc注释。绝大多数“公共”KVM函数实际上并不是真正的公共函数，因为它们仅用于KVM内部消费（有计划将KVM的头文件和导出内容私有化以强制执行这一点）。

注释
~~~~~~
使用祈使语气编写注释，并避免使用代词。用注释提供代码的高层次概览，或者解释代码为何这样做。不要重复代码字面上做的事情；让代码自己说话。如果代码本身难以理解，注释也不会有所帮助。

SDM 和 APM 引用
~~~~~~~~~~~~~~~
KVM的大部分代码直接与Intel的《软件开发手册》（SDM）和AMD的《架构程序员手册》（APM）中定义的架构行为相关联。在没有额外上下文的情况下使用“Intel的SDM”和“AMD的APM”，或者甚至只是“SDM”或“APM”都是可以的。
不要通过编号引用特定的部分、表格、图等，尤其是在注释中。相反，如果必要（见下文），复制相关的片段并通过名称引用部分/表格/图。SDM和APM的布局不断变化，因此编号/标签并不稳定。
一般来说，不要在注释中明确引用或复制SDM或APM的内容。除了少数例外情况，KVM *必须* 遵守架构行为，因此可以认为KVM的行为是在模拟SDM和/或APM的行为。
注意，在更改日志中引用SDM/APM来证明更改并提供上下文是完全可以的，并且鼓励这样做。

简短日志
~~~~~~~~
首选的前缀格式是 ``KVM: <主题>:``，其中 ``<主题>`` 是以下之一：

  - x86
  - x86/mmu
  - x86/pmu
  - x86/xen
  - selftests
  - SVM
  - nSVM
  - VMX
  - nVMX

**不要使用 x86/kvm！**  ``x86/kvm`` 专门用于Linux作为KVM客户机的更改，即用于arch/x86/kernel/kvm.c。不要使用文件名或完整的文件路径作为主题/简短日志的前缀。
注意，这些并不与主题分支对齐（主题分支更关心代码冲突）。
所有名称都是区分大小写的！ ``KVM: x86:`` 是好的，而 ``kvm: vmx:`` 不是。
将压缩的补丁描述中的第一个单词大写，但省略结尾标点。例如：

    KVM: x86: 修复 function_xyz() 中的空指针解引用

而不是：

    kvm: x86: 修复 function_xyz 中的空指针解引用

如果一个补丁涉及多个主题，请向上遍历概念树以找到第一个共同父级（通常是 `x86`）。如果有疑问，`git log path/to/file` 应该能提供合理的提示。

新主题偶尔会出现，但如果想提议引入新主题，请先在列表中发起讨论，即不要擅自行动。

更多信息请参阅 :ref:`the_canonical_patch_format`，有一点修正：不要将70-75个字符的限制视为绝对硬性限制。相反，将75个字符视为坚定但非严格的限制，并将80个字符视为硬性限制。也就是说，如果你有充分的理由，可以让简短日志稍微超出标准限制几个字符。

变更日志
~~~~~~~~~
最重要的是，使用祈使语气编写变更日志，并避免使用代词。更多信息请参阅 :ref:`describe_changes`，有一点修正：首先简要介绍实际的变更内容，然后跟进上下文和背景信息。注意！这一顺序与主干树的首选方法直接冲突！当提交主要针对 arch/x86 代码（而非 KVM 代码）的补丁时，请遵循主干树的首选风格。

KVM x86 偏好在深入细节之前说明补丁做了什么，原因有几个。首先，实际修改了哪些代码可以说是最重要的信息，因此这些信息应该易于查找。将“实际修改了什么”埋藏在一两行文字之后的三段以上的背景信息中，使得很难找到这些信息。

对于初步审查，可以争论“哪里出了问题”更重要，但对于浏览日志和 Git 考古学来说，细节变得越来越不重要。例如，在进行一系列 “git blame” 操作时，沿途每个变更的细节都是无用的，只有罪魁祸首的细节才重要。提供“变更了什么”使得能够快速确定某个提交是否可能感兴趣。

首先说明“变更了什么”的另一个好处是，几乎总能在一句话中表述清楚。相反，除了最简单的错误之外，完全描述问题通常需要多句话或几段文字。如果“变更了什么”和“问题是什么”都超级简短，则顺序无关紧要。但如果其中一个较短（几乎总是“变更了什么”），则先覆盖较短的部分是有利的，因为对有严格顺序偏好的读者/审阅者来说，这造成的不便较小。例如，跳过一句话来获取上下文比跳过三段文字来获取“变更了什么”要容易得多。
修复
~~~~~
如果一个变更修复了 KVM/内核中的错误，即使该变更不需要回退到稳定版本的内核，或者该变更修复的是旧版本中的错误，也要添加一个 Fixes: 标签。相反，如果一个修复确实需要回退，则需明确在补丁上添加 "Cc: stable@vger.kernel" 标签（尽管邮件本身不需要抄送 stable）；默认情况下，KVM x86 不会自动回退 Fixes: 标签的补丁。一些自动选择的补丁确实会回退，但需要显式获得维护者的批准（搜索 MANUALSEL）。

函数引用
~~~~~~~~~~~
当在注释、更改日志或简短日志（或其他任何地方）中提到某个函数时，请使用 ``function_name()`` 的格式。括号提供了上下文并消除了歧义。

测试
-------
最起码，系列中的所有补丁都必须在 KVM_INTEL=m、KVM_AMD=m 和 KVM_WERROR=y 的情况下干净构建。构建所有可能的 Kconfig 组合是不现实的，但越多越好。特别是 KVM_SMM、KVM_XEN、PROVE_LOCKING 和 X86_64 这些配置项非常值得关注。

运行 KVM 自测和 KVM 单元测试也是强制性的（显而易见，测试需要通过）。唯一的例外是对那些几乎不可能影响运行时行为的变更，例如仅修改注释的补丁。尽可能且相关的情况下，在 Intel 和 AMD 上进行测试是非常推荐的。鼓励启动实际的虚拟机，但这不是强制性的。

对于涉及 KVM 影子分页代码的变更，禁用 TDP（EPT/NPT）是强制性的。对于影响常见 KVM 内存管理单元（MMU）代码的变更，禁用 TDP 是强烈建议的。对于其他所有变更，如果被修改的代码依赖于和/或与模块参数交互，那么使用相关设置进行测试是强制性的。

请注意，KVM 自测和 KVM 单元测试确实存在已知的失败情况。如果你怀疑某个失败不是由于你的变更引起的，请验证在有无你变更的情况下是否出现完全相同的失败。

涉及 reStructured Text 文档（即 .rst 文件）的变更必须能够干净地构建 htmldocs，即没有任何新的警告或错误。

如果你无法全面测试一个变更（例如由于缺乏硬件），请清楚说明你能够进行的测试级别，例如在封面信中说明。

新特性
~~~~~~~~~~~~
除一种例外情况外，新特性 *必须* 配备测试覆盖。虽然严格的 KVM 特定测试不是必需的（例如，如果通过运行足够启用的虚拟机或在虚拟机中运行相关的内核自测来提供覆盖），但在所有情况下首选专门的 KVM 测试。特别是，在启用新硬件特性时，负测试案例是强制性的，因为错误和异常流程很少仅通过运行虚拟机就能得到充分测试。
### 唯一的例外

此规则的唯一例外是，如果KVM仅通过KVM_GET_SUPPORTED_CPUID宣传对某个功能的支持，即对于KVM无法阻止客户机使用且没有真正启用机制的指令/特性。请注意，“新特性”不仅仅指“新硬件特性”！那些不能通过现有的KVM自检和/或KVM单元测试进行有效验证的新特性必须附带测试。

在没有测试的情况下发布新特性的开发以获取早期反馈是受欢迎的，但此类提交应标记为RFC，并且封面信中应明确说明请求/期望什么样的反馈。不要滥用RFC流程；RFC通常不会收到深入审查。

### Bug修复

除了一些显而易见的检查发现的bug之外，修复必须附带可重现的bug实例。在许多情况下，重现过程是隐含的，例如构建错误和测试失败，但读者仍需清楚哪些地方出了问题以及如何验证修复。对于通过非公开工作负载/测试发现的bug，可以适当放宽要求，但强烈建议为此类bug提供回归测试。

一般来说，对于不容易复现的bug，推荐提供回归测试。即使该bug最初是由模糊测试工具（如syzkaller）发现的，如果需要命中一个百万分之一的竞态条件，那么针对性的回归测试也是必要的。

请注意，KVM的bug很少既紧急又难以复现。在没有重现实例的情况下发布修复之前，请问自己这个bug是否真的如此严重。

### 发布

#### 链接

不要通过`In-Reply-To:`头显式引用bug报告、补丁/系列的先前版本等。当系列较大或版本号较高时，使用`In-Reply-To:`会变得一团糟，而且对于没有原始邮件的人来说（例如，某人未被抄送在bug报告中或收件人列表在不同版本间发生变化），`In-Reply-To:`毫无用处。

为了链接到bug报告、先前版本或其他相关内容，请使用lore链接。一般而言，在引用先前版本时，不要在变更日志中包含`Link:`，因为没有必要在git中记录历史记录，即把链接放在封面信或git忽略的部分。但对于导致补丁的bug报告和/或讨论，应提供正式的`Link:`。变更的原因背景对未来读者来说非常有价值。
Git 基础
~~~~~~~~

如果您使用的是 Git 2.9.0 或更高版本（Google 的员工，这适用于所有人！），请使用 `git format-patch` 命令，并带上 `--base` 标志以自动在生成的补丁中包含基础树信息。
注意，`--base=auto` 只有在分支的上游设置为基础主题分支时才按预期工作，例如，如果您的上游设置为个人仓库用于备份目的，则会出错。另一种“自动”解决方案是根据您的开发分支的 KVM x86 主题派生分支名称，并将其输入到 `--base` 中。例如，`x86/pmu/my_branch_name`，然后编写一个小的包装器从当前分支名称中提取 `pmu` 来生成 `--base=x/pmu`，其中 `x` 是您的仓库用来跟踪 KVM x86 远程库的名称。

协同发布测试
~~~~~~~~~~~~~~~~

与 KVM 变更相关的 KVM 自动测试（例如，针对错误修复的回归测试）应作为单一系列与 KVM 变更一起发布。标准内核分段规则适用，即导致测试失败的 KVM 变更应位于自动测试更新之后，反之亦然，由于 KVM 错误而失败的新测试应位于 KVM 修复之后。
KVM 单元测试 *始终* 应单独发布。工具（如 b4 am）不知道 KVM 单元测试是一个独立的仓库，在一个系列中的补丁应用于不同的树时会感到困惑。为了将 KVM 单元测试补丁与 KVM 补丁关联起来，请首先发布 KVM 变更，然后在 KVM 单元测试补丁中提供指向 KVM 补丁/系列的 lore 链接。

通知
-------------

当补丁/系列被正式接受时，将发送一封回复原始发布的通知邮件（对于多补丁系列，是指封面信）。该通知将包括树和主题分支，以及应用补丁的提交的 SHA1 值。
如果只应用了一部分补丁，这将在通知中明确说明。除非另有说明，否则隐含的意思是系列中未被接受的任何补丁需要进一步工作，并应在新版本中重新提交。
如果某个补丁在正式接受后被取消，将回复通知邮件解释为什么取消了该补丁，以及下一步措施。

SHA1 稳定性
~~~~~~~~~~~~~~

SHA1 在进入 Linus 的树之前不能保证 100% 稳定！一旦发送了通知，SHA1 通常就稳定了，但事情总是会发生。
大多数情况下，如果已应用的补丁的 SHA1 发生变化，将会更新通知邮件。然而，在某些场景下，例如所有 KVM x86 分支都需要重基，将不会单独给出通知。

漏洞
--------------

那些可以被来宾利用攻击主机（内核或用户空间），或者可以被嵌套 VM 利用攻击其主机（L2 攻击 L1）的错误对 KVM 尤为重要。如果您怀疑某个错误可能导致逃逸、数据泄露等，请遵循 :ref:`securitybugs` 中的安全漏洞协议。
当然，请提供您需要翻译的文本。
