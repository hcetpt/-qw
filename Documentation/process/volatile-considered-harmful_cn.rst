为何“volatile”类型类别不应被使用
-----------------------------------

C 程序员经常将 `volatile` 视为变量可能在当前执行线程之外被更改；因此，他们在内核代码中使用共享数据结构时有时会倾向于使用它。换句话说，他们已习惯于将 `volatile` 类型视为某种简易的原子变量，但实际上并非如此。在内核代码中使用 `volatile` 几乎总是不正确的；本文档解释了原因。

理解 `volatile` 的关键在于它的目的是抑制优化，而这几乎从来不是人们真正想做的事情。在内核中，必须保护共享数据结构免受未授权并发访问的影响，这是一项非常不同的任务。防止未授权并发的过程也将以更有效的方式避免几乎所有与优化相关的问题。

像 `volatile` 一样，使数据并发访问安全的内核原语（自旋锁、互斥锁、内存屏障等）设计用于防止未授权的优化。如果正确地使用它们，则无需再使用 `volatile`。如果仍然需要 `volatile`，那么代码中几乎肯定存在错误。在编写良好的内核代码中，`volatile` 只会导致性能下降。

考虑一段典型的内核代码：

```c
spin_lock(&the_lock);
do_something_on(&shared_data);
do_something_else_with(&shared_data);
spin_unlock(&the_lock);
```

如果所有代码都遵循锁定规则，当持有 `the_lock` 时，`shared_data` 的值不会意外改变。任何可能想要操作这些数据的其他代码都会等待这个锁。自旋锁原语充当内存屏障 — 它们明确为此目的而编写 — 意味着数据访问不会被跨越它们优化。因此，编译器可能认为它知道 `shared_data` 中的内容，但是 `spin_lock()` 调用，由于它作为内存屏障，会迫使编译器忘记其已知的一切。因此，对这些数据的访问不会出现优化问题。

如果声明 `shared_data` 为 `volatile`，仍然需要锁定。但是，编译器也会被阻止在临界区内优化对 `shared_data` 的访问，而我们知道此时没有其他人可以操作它。当持有锁时，`shared_data` 并非 `volatile`。处理共享数据时，正确的锁定使得 `volatile` 不必要 — 甚至可能是有害的。

`volatile` 存储类别最初是为了内存映射 I/O 寄存器而设计的。在内核中，寄存器访问也应通过锁来保护，但同样不想让编译器在临界区内“优化”寄存器访问。然而，在内核中，I/O 内存访问始终通过访问函数完成；直接通过指针访问 I/O 内存的做法是不推荐的，并且在所有架构上都无法工作。这些访问函数被编写以防止未授权的优化，因此，再一次，`volatile` 是不必要的。

另一种可能想要使用 `volatile` 的情况是处理器正在忙等待一个变量的值。正确的忙等待方法是：

```c
while (my_variable != what_i_want)
    cpu_relax();
```

`cpu_relax()` 调用可以降低 CPU 功耗或让出给超线程的双处理器；它还恰好充当了编译器屏障，所以再一次，`volatile` 是不必要的。当然，忙等待通常本身就是一种不好的做法。

在内核中仍有少数罕见的情况，其中使用 `volatile` 有意义：

- 上述提到的访问函数可能在那些支持直接 I/O 内存访问的架构上使用 `volatile`。实际上，每个访问函数调用都成为一个自己的小临界区，确保访问按程序员预期发生。
- 改变内存但没有其他可见副作用的内联汇编代码可能会被 GCC 删除。向 asm 语句添加 `volatile` 关键字可以防止这种删除。
- `jiffies` 变量具有特殊性，即每次引用时都可能有不同的值，但它可以在没有任何特殊锁定的情况下读取。因此 `jiffies` 可以是 `volatile` 的，但添加其他此类变量的做法强烈不建议。`jiffies` 在这方面被视为“愚蠢的遗留问题”（林纳斯的话）；修复它所带来的麻烦比它本身的价值要大。
指向连贯内存中数据结构的指针有时可能是合法地易变的，这些数据结构可能会被I/O设备修改。网络适配器使用的环形缓冲区就是一个这种情况的例子，其中适配器会更改指针以指示哪些描述符已被处理。

对于大多数代码来说，上述关于使用`volatile`的正当理由都不适用。因此，使用`volatile`很可能会被视为一个bug，并给代码带来额外的审查。受到使用`volatile`诱惑的开发者应该退一步思考他们真正想要实现的目标。

移除`volatile`变量的补丁通常是受欢迎的——只要它们附带有合理的解释，表明已经正确地考虑了并发问题。

参考文献
==========

[1] https://lwn.net/Articles/233481/

[2] https://lwn.net/Articles/233482/

致谢
=======

最初的推动和研究由Randy Dunlap完成

本文由Jonathan Corbet撰写

根据Satyam Sharma、Johannes Stezenbach、Jesper Juhl、Heikki Orsila、H. Peter Anvin、Philipp Hahn和Stefan Richter的评论进行了改进
