为何“volatile”类型类别不应被使用
-----------------------------------

C程序员时常将`volatile`理解为变量可能在当前执行线程之外被更改；因此，当共享数据结构被使用时，他们有时会倾向于在内核代码中使用它。换句话说，他们已知会将`volatile`类型视为某种简易的原子变量，而实际上它并非如此。在内核代码中使用`volatile`几乎总是不正确的；本文档阐述了原因。

关于`volatile`的关键点在于，它的目的是抑制优化，而这几乎从来不是人们真正想要做的。在内核中，必须保护共享数据结构免受未预期的并发访问，这是一项截然不同的任务。防止未预期并发的过程也将以更高效的方式避免几乎所有与优化相关的问题。

与`volatile`一样，使数据的并发访问安全的内核原语（自旋锁、互斥锁、内存屏障等）设计用于阻止未预期的优化。如果它们被正确使用，就没有必要同时使用`volatile`。如果仍然需要`volatile`，代码中几乎肯定存在错误。在编写得当的内核代码中，`volatile`只能起到拖慢程序的作用。

考虑一段典型的内核代码：

```c
spin_lock(&the_lock);
do_something_on(&shared_data);
do_something_else_with(&shared_data);
spin_unlock(&the_lock);
```

如果所有代码遵循锁定规则，那么在持有`the_lock`期间，`shared_data`的值不会意外改变。任何可能想操作该数据的其他代码都将等待锁。自旋锁原语充当内存屏障——它们就是为此而明确编写的——这意味着数据访问不会跨越它们进行优化。因此，编译器可能认为它知道`shared_data`中的内容，但`spin_lock()`调用，由于其作为内存屏障的作用，将迫使编译器忘记它所知道的一切。对那个数据的访问将没有优化问题。

如果`shared_data`被声明为`volatile`，锁定仍然是必要的。但是，编译器还将被阻止优化临界区内对`shared_data`的访问，而我们知道此时没有其他人可以操作它。在持有锁的情况下，`shared_data`并不是`volatile`的。在处理共享数据时，正确的锁定使`volatile`变得不必要——甚至可能有害。

`volatile`存储类最初是为内存映射的I/O寄存器设计的。在内核中，寄存器访问也应受到锁的保护，但同样不希望编译器在临界区内“优化”寄存器访问。但在内核中，I/O内存访问总是通过访问函数完成；直接通过指针访问I/O内存的做法受到反对，并且在所有架构上都无法工作。那些访问函数被编写以防止未预期的优化，因此，再次，`volatile`是不必要的。

另一个可能让人想要使用`volatile`的情况是处理器忙等待一个变量的值。正确的忙等待方式是：

```c
while (my_variable != what_i_want)
    cpu_relax();
```

`cpu_relax()`调用可以降低CPU功耗消耗或让出给超线程双处理器；它同时也作为编译器屏障，因此，再次，`volatile`是不必要的。当然，忙等待通常从一开始就是一种反社会的行为。

在内核中，仍有极少数情况下`volatile`是有意义的：

- 上述提到的访问函数可能在直接I/O内存访问可行的架构上使用`volatile`。本质上，每个访问函数调用都成为一个自己的小临界区，并确保访问按照程序员的预期发生。
- 更改内存但没有其他可见副作用的内联汇编代码有被GCC删除的风险。在`asm`语句中添加`volatile`关键字将阻止这种删除。
- `jiffies`变量是特殊的，因为它每次被引用时可能有不同的值，但可以无需特殊锁定即可读取。因此，`jiffies`可以是`volatile`的，但强烈反对增加其他此类变量。`jiffies`在这方面被视为一个“愚蠢的遗留”问题（Linus的话）；修复它将比它本身的价值带来更多的麻烦。
指向连贯内存中数据结构的指针，这些数据结构可能会被I/O设备修改，在某些情况下，合理地被视为易变的（volatile）。网络适配器使用的环形缓冲区就是一个例子，在这种情况下，适配器会更改指针以指示哪些描述符已被处理。

对于大多数代码而言，上述对使用`volatile`的正当理由均不适用。因此，使用`volatile`很可能会被视为一个错误，并会给代码带来额外的审查。受到使用`volatile`诱惑的开发者应当退一步思考他们真正想要实现的目标。

移除`volatile`变量的补丁通常是受欢迎的——只要它们附带了合理的解释，证明并发问题已经被充分考虑过。

参考文献
==========

[1] https://lwn.net/Articles/233481/

[2] https://lwn.net/Articles/233482/

致谢
=======

最初的推动力和研究由Randy Dunlap提供

本文由Jonathan Corbet撰写

根据Satyam Sharma、Johannes Stezenbach、Jesper Juhl、Heikki Orsila、H. Peter Anvin、Philipp Hahn及Stefan Richter的评论进行了改进
