标题：如何避免在ioctl中出错

来源：https://blog.ffwll.ch/2013/11/botching-up-ioctls.html

作者：Daniel Vetter，版权所有 © 2013 英特尔公司

过去几年里，内核图形黑客们明确意识到的一个事实是，试图为完全不同的GPU设计一个统一的接口来管理执行单元和内存是一项徒劳的努力。因此，如今每个驱动程序都有其自己的ioctl集来分配内存和向GPU提交工作。这很好，因为不再有那种看似通用但实际上只使用一次的疯狂接口。但明显的缺点是出错的可能性大大增加。

为了避免重蹈覆辙，我整理了一些在为drm/i915驱动程序处理任务时学到的经验教训。这些经验大多涉及技术细节，并不涵盖大局问题，如命令提交ioctl到底应该是什么样子。学习这些教训可能是每个GPU驱动程序都需要独自完成的事情。

先决条件
----------

首先，是先决条件。如果没有这些，你已经失败了，因为你需要添加一个32位兼容层：

* 只使用固定大小的整数。为了避免与用户空间中的typedef冲突，内核有特殊类型如__u32、__s64。使用它们。
* 将所有内容对齐到自然大小并使用显式填充。32位平台不一定将64位值对齐到64位边界，但64位平台会这样做。所以我们总是需要填充到自然大小以确保正确性。
* 如果结构体包含64位类型，则将整个结构体填充到64位的倍数——否则结构体大小在32位与64位之间会不同。当向内核传递结构体数组或内核检查结构体大小时（例如，drm核心就会这样做），这将带来麻烦。
* 指针是__u64，从用户空间的角度转换为/from uintptr_t，在内核中转换为/from void __user *。尽量不要延迟这种转换，更糟糕的是，不要让你的代码处理原始的__u64，因为这会削弱像sparse这样的检查工具能提供的帮助。内核中可以使用u64_to_user_ptr宏来避免关于不同大小的整数和指针的警告。

基础
----

避免了编写兼容层的痛苦后，我们可以看看基本的失误。忽视这些会使向后和向前兼容性成为真正的痛苦。而且，由于第一次尝试就做对是不可能的，你将会有第二次迭代或至少是对任何给定接口的扩展。

* 有一种清晰的方法让用户空间确定你的新ioctl或ioctl扩展是否在特定内核上受支持。如果你不能依赖旧内核拒绝新的标志/模式或ioctls（因为在过去，这样做已经被搞砸了），那么你需要在某处有一个驱动器功能标志或修订号。
* 对于在结构末尾添加新标志或新字段以扩展ioctls，要有计划。drm核心会检查每次ioctl调用传入的大小，并零扩展内核和用户空间之间的任何不匹配。这有所帮助，但并不是完整的解决方案，因为较新的用户空间在较旧的内核上不会注意到新添加的字段被忽略了。所以仍然需要新的驱动器功能标志。
* 检查所有未使用的字段和标志以及所有的填充部分是否为0，并在不满足此条件的情况下拒绝ioctl请求。否则，你对将来扩展的美好计划将会付诸东流，因为有人可能会提交一个ioctl结构，在尚未使用的部分填充随机的栈垃圾。这会将ABI固化为这些字段永远只能用于存储垃圾数据而不能用于其他用途。这也是为什么你必须明确地填充所有结构体的原因，即使你从未将它们用作数组——编译器插入的填充部分可能包含垃圾数据。
* 对上述所有情况有简单的测试案例。
错误路径的乐趣
--------------------

如今，我们已经没有任何借口让drm驱动成为整洁的小型root漏洞了。这意味着我们需要进行全面的输入验证和稳固的错误处理路径 —— GPU最终会在各种极端情况下出故障：

* ioctl必须检查数组溢出。同时，它需要检查整数值的一般性溢出、下溢以及截断问题。一个典型的例子是直接送入硬件的精灵定位值，而硬件只有大约12位。这种情况在一些奇怪的显示服务器上表现良好，这些服务器不会自行进行截断处理，导致光标在屏幕上绕圈。
* 对ioctl中的每一个输入验证失败情况都有简单的测试案例。确保错误代码符合你的预期。最后，确保每个子测试只针对单个错误路径进行测试，通过提交其他方面完全有效的数据来实现。如果没有这样做，早期的检查可能会直接拒绝ioctl请求，从而掩盖你实际想要测试的代码路径，隐藏bug和回归问题。
* 让你的所有ioctl可重启。首先X服务器确实喜欢信号，其次这将允许你通过不断用信号中断主测试套件来测试90%的错误处理路径。由于X服务器对信号的喜爱，你几乎可以免费获得图形驱动程序中所有错误路径的良好基础覆盖。此外，在处理ioctl重启时要保持一致性 —— 例如，drm在其用户空间库中有一个小小的drmIoctl辅助函数。i915驱动在set_tiling ioctl上的处理不当，现在我们在内核和用户空间中都不得不接受一些神秘的语义。
* 如果无法使某个代码路径可重启，请至少确保被卡住的任务可以被杀死。GPU就是会死掉，如果你挂起了用户的整个系统（通过一个无法杀死的X进程），他们不会更喜欢你。如果状态恢复仍然太复杂，请设置超时或挂起检查的安全网作为最后的努力，以防硬件出现问题。
* 对你的错误恢复代码中真正棘手的边缘情况进行测试案例 —— 在你的挂起检查代码和等待者之间创建死锁非常容易。
时间、等待与错过
----------------------------

GPU几乎都是异步完成工作的，所以我们需要对操作计时并等待正在进行的操作完成。这是一个极其棘手的问题；目前drm/i915支持的所有ioctl都无法完全正确地做到这一点，这意味着这里还有很多教训需要学习。
* 始终使用CLOCK_MONOTONIC作为参考时间。这是alsa、drm和v4l现在默认使用的时间基准。但要让用户空间知道哪些时间戳来自不同的时钟域，如你的主要系统时钟（由内核提供）或某个其他地方的独立硬件计数器。仔细观察，时钟会出现不匹配的情况，但如果性能测量工具拥有这些信息，它们至少可以进行补偿。如果你的用户空间能够获取某些时钟的原始值（例如，通过命令流中的性能计数器采样指令），考虑也公开这些信息。
* 使用__s64秒加上__u64纳秒来指定时间。这并不是最方便的时间表示方式，但基本上是标准的。
* 检查输入的时间值是否已规范化，并在不符合时拒绝它们。请注意，内核原生结构ktime中的秒和纳秒都是带符号整数，因此这里要小心。
* 对于超时，使用绝对时间。如果你是一个乐于助人的人，并且使你的ioctl重启时相对超时可能过于粗糙，并且可能会由于每次重启时的舍入而无限延长你的等待时间。特别是如果您的参考时钟是非常慢的东西，比如显示帧计数器。从规范律师的角度来看，这不是一个bug，因为超时总是可以扩展的 - 但如果他们的精美动画开始因这个问题而卡顿，用户肯定会讨厌你。
* 考虑放弃任何带有超时的同步等待ioctl，并仅仅通过可轮询文件描述符传递异步事件。这种方式更符合基于事件的应用程序的主要循环。
* 对极端情况进行测试案例编写，特别是对于已完成事件、成功等待和超时等待的返回值是否合理并符合你的需求。

资源泄露，不是问题
----------------------

一个完整的drm驱动实质上实现了一个小型操作系统，但针对给定的GPU平台进行了专门化。这意味着驱动需要向用户空间暴露大量不同对象和其他资源的句柄。正确地做到这一点涉及自身的一系列陷阱：

* 始终将动态创建的资源的生命周期与文件描述符的生命周期绑定在一起。如果资源需要在进程间共享，请考虑使用一对一映射 - 通过Unix域套接字进行文件描述符传递也可以简化用户空间的生命周期管理。
* 总是要支持O_CLOEXEC。
* 确保在不同的客户端之间有足够的隔离。默认情况下选择私有的每文件描述符命名空间，强制任何共享都必须明确执行。只有当对象确实是设备独有的时候才采用更全局的每设备命名空间。drm模式设置接口中的一个反例是：每个设备的模式设置对象（如连接器）与帧缓冲区对象共享一个命名空间，而后者大多数情况下并不共享。为帧缓冲区提供一个单独的、默认私有的命名空间会更加合适。
* 考虑用户空间句柄的独特性要求。例如，对于大多数drm驱动而言，在同一个命令提交ioctl中提交相同的对象是用户空间的一个bug。但是如果对象是可共享的，则用户空间需要知道它是否已经见过来自其他进程导入的对象。我自己还没有尝试过这种方法，因为缺少新的对象类别，但是可以考虑使用共享文件描述符上的inode编号作为唯一标识符 - 这也是区分真实文件的方式。
不幸的是，这需要在内核中实现一个完整的虚拟文件系统。

最后但同样重要的一点是，

并非每个问题都需要一个新的 ioctl：

- 认真思考你是否真的需要一个驱动程序私有的接口。当然，推行一个驱动程序私有的接口比参与长时间讨论以寻求更通用的解决方案要快得多。偶尔，为了引领新概念而创建一个私有接口是必要的。但最终，一旦通用接口出现，你将不得不长期维护两个接口。
- 考虑使用ioctl之外的其他接口。对于每个设备的设置，或者对于具有相对静态生命周期的子对象（例如，在drm中的输出连接器及其所有的检测覆盖属性），sysfs属性是一个更好的选择。或者，也许只有你的测试套件需要这个接口，那么debugfs及其不稳定的ABI声明可能更适合。

最后，关键在于首次尝试就要做到正确，因为如果你的驱动程序受到欢迎，并且你的硬件平台寿命长，那么你将会长期受制于给定的ioctl。你可以尝试在较新的硬件版本上弃用糟糕的ioctl，但这通常需要几年的时间才能完成。然后还需要再等几年直到最后一个能抱怨回归问题的用户消失。
