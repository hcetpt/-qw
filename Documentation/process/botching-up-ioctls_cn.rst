如何避免ioctl出错
==================

来源：https://blog.ffwll.ch/2013/11/botching-up-ioctls.html

作者：Daniel Vetter，版权所有 © 2013 Intel Corporation

在过去几年里，内核图形黑客们得出的一个明确结论是，试图为完全不同的GPU设计一个统一的接口来管理执行单元和内存是一项徒劳的努力。因此，现在每个驱动程序都有自己的ioctl集来分配内存并向GPU提交任务。这很好，因为不再有那种表面上通用但实际上只用一次的接口了。但明显的缺点是更容易出错。
为了避免重蹈覆辙，我在处理drm/i915驱动程序时总结了一些经验教训。这些经验主要涉及技术细节，并不涵盖诸如命令提交ioctl应该是什么样的这类宏观问题。学习这些教训可能是每个GPU驱动程序都需要独立完成的任务。

前提条件
----------

首先，我们来看一下前提条件。如果没有这些前提条件，你已经失败了，因为你需要添加一个32位兼容层：

* 只使用固定大小的整数。为了避免与用户空间中的typedef发生冲突，内核提供了一些特殊类型，如__u32、__s64。请使用它们。
* 将所有内容对齐到自然大小并使用显式填充。32位平台不一定将64位值对齐到64位边界，但64位平台会这样做。所以我们总是需要对齐到自然大小以确保正确性。
* 如果结构体包含64位类型，则将其整个结构体填充到64位的倍数——否则结构体大小在32位和64位平台上会不同。当向内核传递结构体数组或内核检查结构体大小（例如，drm核心会进行这种检查）时，结构体大小的不同会导致问题。
* 指针类型为__u64，在用户空间中从/转换为uintptr_t，在内核中从/转换为void __user *。尽量不要延迟这个转换，更不要在代码中直接操作原始的__u64，因为这样会削弱像sparse这样的检查工具的功能。内核中可以使用u64_to_user_ptr宏来避免关于不同大小的整数和指针的警告。

基础知识
---------

在避免编写兼容层的乐趣之后，我们可以看看一些基本的错误。忽视这些问题会使前后向兼容性变得非常痛苦。而且由于第一次尝试时出错是不可避免的，因此任何给定接口都将会有第二次迭代或至少有一个扩展。

* 提供一种清晰的方式让用户空间确定新ioctl或ioctl扩展是否在给定内核上受支持。如果你不能依赖旧内核拒绝新的标志/模式或ioctl（因为过去在这方面出过错），那么你需要在某个地方设置一个驱动程序特性标志或版本号。
* 制定一个计划来扩展ioctl，包括在结构体末尾添加新标志或新字段。drm核心会对每个ioctl调用传入的大小进行检查，并对内核和用户空间之间的任何不匹配进行零扩展。这有所帮助，但并不是完整的解决方案，因为较新的用户空间在旧内核上不会注意到新添加的字段被忽略了。因此，这仍然需要新的驱动程序特性标志。
* 检查所有未使用的字段和标志以及所有的填充部分是否为0，并在不满足条件时拒绝ioctl。否则，你美好的未来扩展计划将会付诸东流，因为有人可能会提交一个ioctl结构，在尚未使用的部分填充随机的栈垃圾。这也会导致ABI固化这些字段只能用于垃圾数据。这也是为什么即使你不将结构体用于数组中，也必须显式地进行填充——编译器插入的填充部分可能包含垃圾数据。
* 对上述所有情况编写简单的测试用例。
错误路径的乐趣
--------------------

如今，我们已经没有理由再让drm驱动成为简洁的小root漏洞了。这意味着我们需要进行全面的输入验证和稳健的错误处理路径——无论如何，GPU最终会在某些极端情况下出故障：

 * ioctl必须检查数组溢出。此外，还需要检查整数值的一般溢出、下溢以及裁剪问题。一个常见的例子是直接送入硬件的精灵定位值，而硬件只有大约12位。这种情况下，工作正常直到某个奇怪的显示服务器不自行处理裁剪，导致光标绕屏幕转圈。
* 为ioctl中的每个输入验证失败案例编写简单的测试用例。确保错误代码符合预期。最后，通过提交其他方面完全有效的数据来确保每个子测试只测试单一的错误路径。如果没有这样做，早期的检查可能会提前拒绝ioctl，从而掩盖了你实际要测试的代码路径，隐藏了bug和回归。
* 让所有的ioctl可重启。首先，X真的喜欢信号，其次这样可以通过不断发送信号中断主测试套件来测试90%的错误处理路径。由于X对信号的喜爱，你可以几乎免费获得图形驱动的所有错误路径的良好基础覆盖。此外，在处理ioctl重启时保持一致性——例如，drm在其用户空间库中有一个小小的drmIoctl辅助函数。i915驱动在set_tiling ioctl上搞砸了，现在我们在内核和用户空间都不得不面对一些晦涩的语义。
* 如果无法使特定代码路径可重启，则至少使其能够终止挂起的任务。GPU可能会死机，如果你让用户整个系统挂起（通过无法终止的X进程），他们不会更喜欢你。如果状态恢复仍然过于复杂，请设置超时或挂起检查的安全网作为最后一道防线，以防硬件出现问题。
* 为你的错误恢复代码中的真正棘手的边界情况编写测试用例——很容易在这之间创建死锁。
时间、等待与错过
-------------------

GPU几乎一切操作都是异步的，所以我们需要对操作计时并等待正在进行的操作。这是一项非常棘手的工作；目前drm/i915支持的ioctl没有一个能完全正确处理这一点，这意味着这里还有很多教训需要吸取。
* 始终使用CLOCK_MONOTONIC作为参考时间。这是alsa、drm和v4l现在默认使用的。但要让用户空间知道哪些时间戳来自不同的时钟域，如主要系统时钟（由内核提供）或某处独立的硬件计数器。如果仔细观察，时钟会存在不匹配，但如果性能测量工具拥有这些信息，它们至少可以进行补偿。如果用户空间可以获取某些时钟的原始值（例如，通过命令流中的性能计数器采样指令），请考虑公开这些信息。
使用 __s64 秒加 __u64 纳秒来指定时间。这不是最方便的时间表示方法，但基本上是标准的。

检查输入的时间值是否已规范化，并在不规范时拒绝它们。请注意，内核原生结构体 ktime 的秒和纳秒都是带符号整数，因此在这里要小心。

对于超时操作，使用绝对时间。如果你是一个好心人，并且使你的 ioctl 可重启，则相对超时可能会过于粗糙，并且由于每次重启时的舍入误差，可能会无限期地延长等待时间。特别是当你的参考时钟非常慢（如显示帧计数器）时。从规范的角度来看，这并不是一个错误，因为超时总是可以扩展的——但如果用户的漂亮动画因这一问题而出现卡顿，他们肯定会讨厌你。

考虑放弃带有超时功能的同步等待 ioctl，改为在可轮询文件描述符上发送异步事件。这种方式更适合事件驱动应用程序的主循环。

编写测试用例以覆盖边缘情况，特别是检查已完成事件、成功等待和超时等待的返回值是否合理并符合你的需求。

资源泄露，不是问题
----------------------

一个完整的 DRM 驱动程序实际上实现了一个小的操作系统，但专门针对特定的 GPU 平台。这意味着驱动程序需要向用户空间暴露大量不同对象和其他资源的句柄。正确处理这些句柄本身也有一系列陷阱：

* 始终将动态创建的资源生命周期与文件描述符的生命周期关联起来。如果资源需要跨进程共享，请考虑使用一对一映射 —— 通过 Unix 域套接字传递文件描述符也可以简化用户空间中的生命周期管理。
* 始终支持 O_CLOEXEC。
* 确保不同客户端之间有足够的隔离。默认情况下选择私有的每个文件描述符命名空间，强制任何共享必须显式进行。只有在对象真正唯一时才使用更全局的每个设备命名空间。DRM 模式设置接口中的一个反例是，每设备模式设置对象（如连接器）与帧缓冲区对象共享命名空间，而后者通常是不共享的。对于帧缓冲区来说，有一个单独的、默认私有的命名空间会更为合适。
* 考虑用户空间句柄的唯一性要求。例如，对于大多数 DRM 驱动程序，在同一个命令提交 ioctl 中提交同一个对象两次是用户空间的一个错误。但如果对象是可以共享的，用户空间需要知道是否已经从其他进程中导入了该对象。由于缺乏新的对象类别，我还没有尝试过这一点，但可以考虑使用共享文件描述符上的inode编号作为唯一标识符 —— 这也是区分真实文件的方法。
不幸的是，这需要在内核中实现一个完整的虚拟文件系统。

最后但同样重要的一点
-------------------

并不是每个问题都需要一个新的ioctl：

- 认真思考是否真的需要一个驱动程序私有的接口。当然，推动一个驱动程序私有接口比参与长时间讨论以获得更通用的解决方案要快得多。偶尔使用私有接口来引领新概念是必要的。但最终，一旦通用接口出现，你将不得不长期维护两个接口。
- 考虑除ioctl之外的其他接口。对于每个设备的设置，或者具有相对静态生命周期的子对象（如drm中的输出连接器及其所有检测覆盖属性），sysfs属性是一个更好的选择。或许只有你的测试套件需要这个接口，那么带有不保证稳定ABI声明的debugfs可能更好。

最后，关键在于第一次就做对，因为如果你的驱动程序很受欢迎，并且你的硬件平台寿命很长，那么你将会被某个特定的ioctl所束缚。你可以尝试在新版本的硬件上废弃糟糕的ioctl，但这通常需要几年时间才能完成。然后再过几年，直到最后一个能够抱怨退步问题的用户消失。
