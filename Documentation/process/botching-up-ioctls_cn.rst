如何避免在ioctl中出错
====================

来源：https://blog.ffwll.ch/2013/11/botching-up-ioctls.html

作者：Daniel Vetter，版权所有 © 2013 Intel Corporation

在过去几年里，内核图形黑客们明确了一个观点：尝试为完全不同的GPU创建一个统一的接口来管理执行单元和内存是一项徒劳的努力。因此，如今每个驱动程序都有一套自己的ioctl用于分配内存和向GPU提交任务。这很好，因为不再存在那种假通用但实际上只使用一次的接口所带来的混乱。但明显的缺点是，犯错误的可能性大大增加。
为了避免重复同样的错误，我总结了一些在为drm/i915驱动程序处理任务时学到的经验教训。这些经验主要涉及技术细节，并不涵盖如命令提交ioctl具体应该是什么样子等宏观问题。学习这些经验可能是每个GPU驱动程序都需要自己去做的事情。
先决条件
----------

首先，需要满足一些先决条件。如果没有这些，你已经失败了，因为你需要添加一个32位兼容层：

* 只使用固定大小的整数。为了避免与用户空间中的类型定义冲突，内核有一些特殊类型如`__u32`、`__s64`。请使用它们。
* 将所有内容对齐到自然大小并使用显式填充。32位平台不一定将64位值对齐到64位边界，但64位平台会这样做。所以我们总是需要填充到自然大小以确保正确性。
* 如果结构体包含64位类型，则将整个结构体填充为64位的倍数——否则结构体大小在32位和64位上会不同。当向内核传递结构体数组或内核检查结构体大小时（例如，drm核心就会这么做），结构体大小的不同会导致问题。
* 指针类型为`__u64`，在用户空间侧转换为/from `uintptr_t`，在内核中转换为/from `void __user *`。尽量避免延迟这种转换，更不要在代码中直接操作原始的`__u64`，因为这会削弱像`sparse`这样的检查工具所能提供的帮助。内核中可以使用宏`u64_to_user_ptr`来避免关于不同大小的整数和指针之间的警告。

基础
----

避免编写兼容层的乐趣后，我们可以看看基本的失误。忽视这些会使向前和向后兼容性成为真正的痛苦。而且，由于首次尝试就做对几乎是不可能的，你将会有第二次迭代或至少为任何给定接口提供扩展。

* 有一个清晰的方法让用户空间判断你的新ioctl或ioctl扩展是否被特定内核支持。如果你不能依赖旧内核拒绝新的标志/模式或ioctl（因为过去在这方面也出过问题），那么你需要一个驱动特性标志或版本号。
* 对于在ioctl中添加新标志或在结构体末尾添加新字段，需要有扩展计划。drm核心会检查每次ioctl调用传入的大小，并对内核和用户空间之间的不匹配进行零扩展。这有所帮助，但并不是完整的解决方案，因为较新的用户空间在较旧的内核上不会注意到新添加的字段被忽略。因此，这仍然需要新的驱动特性标志。
* 检查所有未使用的字段和标志以及所有的填充部分是否为0，并在不满足此条件的情况下拒绝ioctl请求。否则，你对将来扩展的美好计划将会付诸东流，因为有人可能会提交一个ioctl结构，在尚未使用的部分填充随机的栈垃圾。这会将ABI固化为这些字段永远只能用于存储垃圾数据而不能用于其他用途。这也是为什么你必须明确地填充所有结构体的原因，即使你从未将它们用作数组——编译器插入的填充部分可能包含垃圾数据。
* 对上述所有情况准备简单的测试案例。
错误路径的乐趣
--------------------

如今，我们已经没有任何借口让drm驱动成为整洁的小型root漏洞了。这意味着我们需要进行全面的输入验证和稳固的错误处理路径 —— GPU最终会在各种极端情况下出故障：

* ioctl必须检查数组溢出。同时，它还需要检查整数值的一般性溢出、下溢以及截断问题。一个典型的例子是直接送入硬件的精灵定位值，而硬件只有大约12位。这种情况在一些奇怪的显示服务器上表现良好，这些服务器不会自行进行截断处理，导致光标在屏幕上绕圈。
* 对ioctl中的每一个输入验证失败情况准备简单的测试案例。确保错误代码符合你的预期。最后，确保每个子测试只针对单一的错误路径进行测试，通过提交其他方面完全有效的数据来实现。如果没有这样做，较早的检查可能会直接拒绝ioctl请求，从而掩盖你实际想要测试的代码路径，隐藏错误和回归。
* 让你的所有ioctl都可重启。首先，X服务器确实喜欢信号；其次，这将允许你通过不断地使用信号中断主测试套件来测试90%的错误处理路径。由于X服务器对信号的喜爱，你几乎可以免费获得图形驱动程序中所有错误路径的良好基础覆盖。此外，在处理ioctl重启时要保持一致性——例如，drm在其用户空间库中有一个小型的drmIoctl辅助函数。i915驱动程序在set_tiling ioctl上处理不当，现在我们在内核和用户空间中都被困于某种晦涩难懂的语义中。
* 如果无法使某个代码路径可重启，请至少使阻塞任务可被杀死。GPU可能会死掉，如果你让用户整个系统挂起（通过一个不可杀死的X进程），他们不会更喜欢你。如果状态恢复仍然过于复杂，可以设置超时或挂起检测安全网作为最后的努力，以防硬件出现问题。
* 为你的错误恢复代码中的真正棘手的边缘案例准备测试案例 —— 在你的挂起检测代码和等待者之间创建死锁实在是太容易了。
时间、等待与错过
----------------------------

GPU几乎总是异步执行任务，所以我们需要对操作计时并等待未完成的任务。这是一个非常棘手的问题；目前，drm/i915支持的所有ioctl都没有完全正确地处理这一点，这意味着这里还有很多教训需要学习。
* 始终使用CLOCK_MONOTONIC作为参考时间。这是alsa、drm和v4l当前默认采用的时间基准。但是要让用户空间知道哪些时间戳来源于不同的时钟域，比如你的主要系统时钟（由内核提供）或其他地方的独立硬件计数器。如果你仔细观察，时钟会出现不匹配的情况，但如果性能测量工具拥有这些信息，它们至少可以进行补偿。如果你的用户空间能够获取某些时钟的原始值（例如，通过命令流中的性能计数器采样指令），考虑将这些也暴露出来。
* 使用__s64秒加上__u64纳秒来指定时间。这并不是最方便的时间表示方式，但基本上是标准的。
* 检查输入的时间值是否已规范化，并在不符合时拒绝它们。请注意，内核原生结构ktime中的秒和纳秒都是带符号整数，因此这里要小心。
* 对于超时，使用绝对时间。如果你是一个乐于助人的人并且使你的ioctl可重启，那么相对超时可能会过于粗糙，并且由于每次重启时的舍入可能导致等待时间无限延长。特别是如果您的参考时钟是非常慢的东西，比如显示帧计数器。从规范律师的角度来看，这不是一个错误，因为超时总是可以扩展的——但如果他们的精美动画因为这个原因开始卡顿，用户肯定会讨厌你。
* 考虑放弃任何带有超时的同步等待ioctl，而是仅通过可轮询文件描述符传递异步事件。它更适合事件驱动应用程序的主要循环。
* 为边界情况进行测试案例，特别是对于已完成事件、成功等待和超时等待的返回值是否都合理并符合您的需求。

资源泄露，不
----------------------

一个完整的drm驱动实质上实现了一个小的操作系统，但针对给定的GPU平台进行了专门化。这意味着驱动需要向用户空间暴露大量的句柄，用于不同的对象和其他资源。正确地做到这一点包含了一系列特有的陷阱：

* 始终将动态创建资源的生命周期与文件描述符的生命周期绑定在一起。如果您的资源需要跨进程共享，请考虑使用一对一映射——通过Unix域套接字进行文件描述符传递也可以简化用户空间中的生命周期管理。
* 始终支持O_CLOEXEC。
* 确保您有足够的隔离措施以区分不同的客户端。默认情况下选择私有的每文件描述符命名空间，强制任何共享必须显式进行。只有当对象确实是设备独有的时候才采用更全局的每设备命名空间。drm模式设置接口中的一个反例是，每个设备的模式设置对象（如连接器）与帧缓冲区对象共享一个命名空间，而后者大部分并不共享。一个单独的命名空间，默认私有，对于帧缓冲区来说会更加合适。
* 考虑用户空间句柄的独特性要求。例如，对于大多数drm驱动程序，在同一个命令提交ioctl中提交相同的对象是一个用户空间错误。但是，如果对象是可以共享的，则用户空间需要知道是否已经见过从其他进程导入的对象。我自己还没有尝试过这一点，因为缺乏一类新的对象，但可以考虑使用共享文件描述符上的inode号作为唯一标识符——这也是真实文件区别开的方式。
不幸的是，这需要在内核中实现一个完整的虚拟文件系统。

最后但同样重要的一点是，

并非每个问题都需要一个新的 ioctl：

- 认真思考你是否真的需要一个驱动程序私有的接口。当然，推行一个驱动程序私有的接口比参与长时间讨论以寻求更通用的解决方案要快得多。偶尔地，为了引领新的概念，实现一个私有接口是必要的。但最终，一旦有了通用接口，你就得无限期地维护两个接口。
- 考虑除 ioctl 之外的其他接口。对于每个设备的设置，或者具有相对静态生命周期的子对象（例如 DRM 中的所有检测覆盖属性的输出连接器），sysfs 属性是一个更好的选择。或者可能只有你的测试套件需要这个接口，在这种情况下，带有不稳定的 ABI 免责声明的 debugfs 可能更适合。
  
最终，关键在于第一次就要做对，因为如果您的驱动程序很受欢迎，并且您的硬件平台寿命长，那么你将几乎永远受制于给定的 ioctl。你可以在新版本的硬件上尝试废弃糟糕的 ioctl，但这通常需要几年的时间才能完成。然后还需要再过几年，直到最后一个能够抱怨退化问题的用户消失。
