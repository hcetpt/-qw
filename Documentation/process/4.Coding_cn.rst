确保代码正确无误
==================

虽然一个坚实且以社区为导向的设计流程十分重要，但最终的成果还是要通过实际的代码来证明。代码会被其他开发者审查，并决定是否将其合并到主线版本中。因此，代码的质量将直接决定项目的成败。本节将探讨编码过程。首先，我们将介绍一些开发过程中容易犯的错误，然后将重点转移到如何正确地编写代码以及可以为此提供帮助的工具上。

误区
---------

编码风格
************

内核一直以来都有标准的编码风格，具体描述参见 :ref:`Documentation/process/coding-style.rst <codingstyle>`。很长一段时间以来，该文件中的规定最多被认为是建议性的。结果是，内核中存在大量不符合编码风格指导原则的代码。这些代码的存在给内核开发者带来了两个独立的风险。

第一个风险是认为内核的编码标准并不重要也不被强制执行。实际上，如果新增的代码不遵循这些标准，很难被添加到内核中；许多开发者会要求在审查代码之前先对其进行格式化。对于像内核这样庞大的代码库来说，为了使开发者能够快速理解其中任何部分，需要有一定的代码统一性。因此，不符合常规格式的代码已经没有空间了。

偶尔，内核的编码风格可能会与雇主规定的编码风格产生冲突。在这种情况下，内核的编码风格必须优先，才能将代码合并。将代码提交到内核意味着在多个方面放弃一定程度的控制权，包括对代码格式的控制。

另一个陷阱是假设已经存在于内核中的代码迫切需要进行编码风格的修正。开发者可能会开始生成格式调整补丁作为一种熟悉流程的方式，或者作为一种将自己的名字加入内核变更日志的方法——或者两者兼而有之。但是，纯粹的编码风格修正被视为噪声，通常会受到冷遇。因此，这类补丁最好避免。在出于其他原因修改代码时自然地修正其风格是可以接受的，但不应仅仅为了改变编码风格而做出更改。

编码风格文档也不应被视为不可逾越的绝对法则。如果有充分的理由偏离这种风格（例如，如果将一行代码分割以适应80列限制会使这行代码变得难以阅读），那么就按实际情况处理即可。

需要注意的是，您还可以使用 `clang-format` 工具来帮助遵守这些规则，自动快速重新格式化代码的一部分，审查整个文件以发现编码风格错误、拼写错误和可能的改进等。它也非常适合于排序 `#include` 语句、对齐变量/宏、重新排列文本等类似任务。更多详细信息请参阅 :ref:`Documentation/dev-tools/clang-format.rst <clangformat>`。

如果您使用的是兼容 EditorConfig 的编辑器，一些基本的编辑器设置（如缩进和行尾）将自动设置。更多信息请访问官方 EditorConfig 网站：https://editorconfig.org/

抽象层
******************

计算机科学教授教导学生广泛利用抽象层以提高灵活性和隐藏信息。
当然，内核广泛使用了抽象；对于涉及数百万行代码的项目来说，如果不这样做就无法生存。但经验表明，过度或过早的抽象就跟过早优化一样有害。抽象应该仅用于所需的程度，不能再多。

在简单层面上考虑，假设有一个函数，其参数总是被所有调用者传为零。你可以保留这个参数，以防万一将来有人需要利用它提供的额外灵活性。但是到那时，很可能实现这个额外参数的代码已经在某个微妙的地方被破坏了，却从未被发现——因为它从未被使用过。或者，当需要额外灵活性时，并不是以程序员最初预期的方式出现。内核开发者会经常提交补丁来移除未使用的参数；通常情况下，这些参数从一开始就不应该添加。

隐藏硬件访问的抽象层——通常是为使大部分驱动程序可以在多个操作系统中使用——特别不受欢迎。这样的层会使代码变得模糊，并可能带来性能损失；它们不属于 Linux 内核。

另一方面，如果你发现自己从另一个内核子系统大量复制代码，那么是时候问问自己是否实际上应该将其中一些代码抽取到单独的库中，或者在更高层次上实现该功能。在整个内核中复制相同的代码没有任何价值。

`#ifdef` 和预处理器的一般使用
**************************************

C 预处理器对某些 C 程序员来说似乎是一个强大的诱惑，他们将其视为一种高效地将大量灵活性编码到源文件中的方式。但预处理器并不是 C 语言的一部分，大量使用它会导致其他人更难读懂代码，也使得编译器更难以检查代码的正确性。大量使用预处理器几乎总是意味着代码需要进行一些清理工作。

带有 `#ifdef` 的条件编译确实是一个强大的特性，并且在内核中得到了应用。但很少有人希望看到到处都是 `#ifdef` 块的代码。一般来说，尽可能将 `#ifdef` 的使用限制在头文件中。

条件编译的代码可以限制在函数中，如果不需要这些代码，则函数变为为空。编译器随后会悄悄地优化掉对空函数的调用。这样产生的代码更加清晰易懂。

C 预处理器宏存在多种风险，包括可能多次评估具有副作用的表达式以及缺乏类型安全性。

如果你想要定义一个宏，请考虑创建一个内联函数。生成的代码将是相同的，但内联函数更容易阅读，不会多次评估其参数，并允许编译器对参数和返回值执行类型检查。
内联函数
**********

尽管如此，内联函数本身也存在一定的隐患。程序员可能会因为避免函数调用所带来的表面上的效率提升而过度使用内联函数，从而在源文件中填充大量的内联函数。然而，这些函数实际上可能降低性能。由于它们的代码在每个调用点都被复制，最终导致编译后的内核体积膨胀。反过来，这会给处理器的内存缓存带来压力，可能会显著减慢执行速度。通常情况下，内联函数应该非常小且相对较少。毕竟，函数调用的成本并不是很高；创建大量内联函数是过早优化的一个典型例子。
一般来说，内核程序员如果忽视缓存效果将会付出代价。在初级数据结构课程中教授的经典的时间/空间权衡在现代硬件上往往并不适用。空间就是时间，也就是说，较大的程序运行速度会比紧凑的程序慢。
较新的编译器在决定某个特定函数是否应该被内联方面扮演着越来越积极的角色。因此，过度使用 "inline" 关键字可能不仅是多余的，也可能无关紧要。

锁定
*******

2006年5月，“Devicescape”网络堆栈在一片热烈的宣传下以GPL许可证发布，并可供纳入主线内核。这一捐赠受到了欢迎，因为当时Linux的无线网络支持被认为最多只能算是次标准，而Devicescape堆栈承诺可以改善这种情况。然而，这段代码直到2007年6月（2.6.22版本）才真正进入主线。发生了什么？

这段代码显示出了明显的在企业内部开发的迹象。但一个特别大的问题是它没有为多处理器系统设计。在将这个网络堆栈（现称为mac80211）合并之前，需要为其后向添加锁定方案。
曾经，Linux内核代码可以在不考虑多处理器系统带来的并发问题的情况下进行开发。但现在，本文档正在一台双核笔记本电脑上编写。即使是在单处理器系统上，为了提高响应性所做的工作也会提高内核中的并发程度。那些可以不考虑锁定来编写内核代码的日子已经一去不复返了。
任何可能被多个线程同时访问的资源（如数据结构、硬件寄存器等）都必须通过锁进行保护。
新代码应该从一开始就考虑到这一要求；事后添加锁定是一个更为困难的任务。内核开发者应该花时间充分理解可用的锁定原语，以便选择合适的工具。表现出对并发性缺乏关注的代码在进入主线时将会遇到困难。

退化
***********

还有一个值得提及的隐患是：有时人们可能会受到诱惑，做出改变（可能会带来巨大改进），但却导致现有用户某些功能失效。这种改变被称为“退化”，在主线内核中退化已经变得极其不受欢迎。除非能及时修复退化问题，否则引起退化的更改大多数情况下会被撤销。最好一开始就避免退化。
有人经常争论说，如果退化使得更多的系统正常工作而不是出现问题，那么这种退化是可以接受的。为什么不做这样一个改变，如果它能让十个系统的功能增强却只让一个系统出现问题呢？对于这个问题的最佳回答是由Linus在2007年7月表达的：

::

	我们不会通过引入新问题的方式来修复bug。那样只会陷入疯狂，没有人会知道你是否真的取得了任何实质性的进展。这是两步前进，一步后退，还是一步前进，两步后退呢？

(https://lwn.net/Articles/243460/)
一种特别不受欢迎的回归类型是对用户空间 ABI 的任何更改。一旦接口被导出到用户空间，就必须无限期地支持它。这一事实使得创建用户空间接口变得尤其具有挑战性：由于它们不能以不兼容的方式更改，因此必须从一开始就做得正确。因此，对于用户空间接口来说，总是需要大量的思考、清晰的文档和广泛的审查。
代码检查工具
-------------

至少到现在为止，编写无错误代码仍然是我们很少有人能达到的理想状态。然而，我们可以希望在代码进入主线内核之前尽可能多地发现并修复这些错误。为此，内核开发者们已经汇集了一套令人印象深刻的工具，可以自动检测出各种隐蔽的问题。任何被计算机发现的问题都不会在以后困扰用户，因此合理的做法是尽可能使用自动化工具。
第一步仅仅是关注编译器产生的警告
现代版本的 gcc 可以检测（并警告）大量潜在的错误。很多时候，这些警告指向实际存在的问题。提交审核的代码原则上不应该产生任何编译器警告。在消除警告时，请务必理解其根本原因，并尽量避免那些仅仅让警告消失而不解决其根本原因的“修复”。
请注意，并非所有编译器警告默认都是启用的。使用 "make KCFLAGS=-W" 构建内核以获取完整的警告集。
内核提供了多个配置选项来开启调试功能；其中大多数可以在“内核调试”子菜单中找到。对于用于开发或测试目的的内核，应该启用其中的一些选项。特别是，你应该启用：

- FRAME_WARN 来获取超过指定大小的栈帧警告。生成的输出可能很冗长，但不必担心来自内核其他部分的警告。
- DEBUG_OBJECTS 将添加代码来跟踪内核创建的各种对象的生命周期，并在事情处理顺序不当的时候发出警告。如果你正在添加一个创建（并导出）复杂对象的子系统，请考虑增加对对象调试基础设施的支持。
- DEBUG_SLAB 可以检测多种内存分配和使用错误；它应该用于大多数开发内核中。
- `DEBUG_SPINLOCK`, `DEBUG_ATOMIC_SLEEP` 和 `DEBUG_MUTEXES` 能够发现许多常见的锁错误。
还有不少其他的调试选项，其中一些将在下面讨论。它们中的一些会对性能产生显著影响，因此不应一直启用。但花些时间了解可用的选项，很可能会在短期内获得多倍的回报。
一个较重的调试工具是锁检查器，或称为“lockdep”。此工具会跟踪系统中每个锁（自旋锁或互斥锁）的获取和释放、锁相对于彼此被获取的顺序、当前中断环境等更多内容。它能确保锁始终以相同的顺序被获取，同样的中断假设适用于所有情况等等。换句话说，lockdep能够发现系统可能偶尔发生死锁的多种情形。这类问题在一个部署的系统中可能是痛苦的（对开发者和用户都是如此）；lockdep允许在事前以自动化的方式发现这些问题。任何具有非平凡锁机制的代码，在提交合并之前都应该启用lockdep进行运行。
作为一名尽职的内核程序员，毫无疑问你会检查任何可能失败的操作（如内存分配）的返回状态。然而，实际情况是，由此产生的故障恢复路径很可能完全没有经过测试。未经测试的代码往往是有问题的；如果你所有的错误处理路径都经过了几次测试，你对自己的代码就会更有信心。
内核提供了一个故障注入框架，可以专门针对涉及内存分配的情况做到这一点。启用故障注入后，可配置百分比的内存分配将被故意设置为失败；这些失败可以限定在特定的代码范围内。
启用故障注入运行可以让程序员看到当事情出错时代码是如何响应的。有关如何使用此功能的更多信息，请参阅 `Documentation/fault-injection/fault-injection.rst`。
其他类型的错误可以通过静态分析工具“sparse”来发现。
通过sparse，程序员可以收到关于用户空间与内核空间地址混淆、大端与小端数量混合、在期望一组位标志的地方传递整数值等问题的警告。sparse需要单独安装（如果发行版没有打包的话，可以在 https://sparse.wiki.kernel.org/index.php/Main_Page 找到它）；然后可以通过在make命令中添加 `C=1` 来运行它。
"Coccinelle" 工具（http://coccinelle.lip6.fr/）能够识别各种潜在的编程问题，并且还能提出修复建议。相当多的内核“语义补丁”已经被打包在 `scripts/coccinelle` 目录下；运行 `make coccicheck` 将遍历这些语义补丁并报告发现的问题。更多信息请参见 `Documentation/dev-tools/coccinelle.rst <devtools_coccinelle>`。
其他类型的可移植性错误最好通过为其他架构编译你的代码来发现。即使你手头没有S/390系统或Blackfin开发板，你仍然可以执行编译步骤。一系列用于x86系统的交叉编译器可以在以下网址找到：

    https://www.kernel.org/pub/tools/crosstool/

花费一些时间安装并使用这些编译器有助于避免以后出现尴尬情况。
---

### 文档

在内核开发中，文档往往更像是例外而非规则。即便如此，充分的文档将有助于新代码合并到内核中，使其他开发者的工作更轻松，并且对用户有所帮助。在许多情况下，添加文档已成为实质上的必需品。

对于任何补丁来说，其关联的更改日志是第一份文档。日志条目应描述所解决的问题、解决方案的形式、参与补丁工作的人员、与性能相关的任何影响以及理解该补丁所需了解的任何其他内容。确保更改日志说明为什么该补丁值得应用；令人惊讶的是，很多开发者未能提供这些信息。

任何增加了新的用户空间接口（包括新的 sysfs 或 /proc 文件）的代码都应该包含该接口的文档，以便用户空间开发者知道他们正在处理什么。请参阅 `Documentation/ABI/README` 以了解此类文档的格式要求和需要提供的信息。

文件 :ref:`Documentation/admin-guide/kernel-parameters.rst <kernelparameters>` 描述了内核所有的启动参数。

任何添加新参数的补丁都应在此文件中添加相应的条目。

任何新的配置选项都必须附带清晰解释这些选项及其适用场景的帮助文本。

许多子系统的内部 API 信息通过特别格式化的注释进行记录；这些注释可以通过 "kernel-doc" 脚本以多种方式提取和格式化。如果你在一个已有 kerneldoc 注释的子系统中工作，你应该维护这些注释，并根据需要为对外提供的函数添加注释。即使在尚未如此记录的领域，为将来添加 kerneldoc 注释也没有坏处；事实上，这对初学内核开发的人来说可能是一项有用的活动。这些注释的格式以及如何创建 kerneldoc 模板的信息可以在 :ref:`Documentation/doc-guide/ <doc_guide>` 中找到。

任何阅读大量现有内核代码的人都会注意到，通常最引人注意的是缺少注释。对于新代码而言，期望值比过去要高；未加注释的代码合并起来将更加困难。话虽如此，人们并不希望看到冗余注释的代码。代码本身应该是可读的，注释用来解释更微妙的方面。

某些事情应该始终有注释。使用内存屏障的地方应该有一行注释来解释为什么需要这个屏障。数据结构的锁定规则通常需要在某处进行解释。

重要的数据结构通常需要全面的文档。
非显而易见的代码片段间的依赖关系应当被指出。任何可能诱使代码维护者做出错误“清理”的地方，都需要添加注释说明为何要这样实现。如此等等。

### 内部API变更

内核向用户空间提供的二进制接口除非在最极端的情况下，否则不能被破坏。相反，内核的内部编程接口是非常灵活的，并且可以根据需要进行更改。如果你发现自己不得不绕过某个内核API，或者仅仅因为某个功能不符合你的需求而不使用它，这可能是API需要更改的一个信号。作为内核开发者，你有权做出这样的更改。

当然，也有一些限制。可以进行API更改，但这些更改需要充分的理由。因此，任何涉及内部API变更的补丁都应该附带有关变更内容及其必要性的描述。这种类型的更改也应该独立成为一个补丁，而不是埋藏在一个更大的补丁中。

另一个限制是，更改内部API的开发者通常需要负责修复因该变更而受到影响的内核树中的所有代码。对于一个广泛使用的函数来说，这项工作可能会导致成百上千处更改——其中许多可能会与其它开发者正在进行的工作产生冲突。不言而喻，这可能是一项巨大的工作，所以最好确保理由足够充分。需要注意的是，Coccinelle工具可以帮助处理广泛的API变更。

在进行不兼容的API变更时，只要可能，应当确保未更新的代码会被编译器捕获。
这将有助于确保你已经找到了所有使用该接口的内核内部代码。同时也会提醒外部代码的开发者有变更需要他们响应。支持外部代码并不是内核开发者必须关心的事情，但我们也没有必要让外部开发者的任务变得比必要的更加困难。
