开发编码：

将代码编写正确
======================

虽然稳健且以社区为中心的设计流程值得大书特书，但任何内核开发项目的关键在于最终的代码。正是这些代码会被其他开发者审查，并决定是否合并到主线树中。因此，代码的质量将直接决定项目的最终成功与否。本节将探讨编码过程。我们首先会探讨内核开发者可能犯的一些错误，然后转向如何正确地做事以及在这一过程中可以使用的工具。

陷阱
---------

编码风格
************

内核长期以来有一套标准的编码风格，详细描述见 :ref:`Documentation/process/coding-style.rst <codingstyle>`。在这段时间的大部分时间里，文件中描述的政策最多被视为建议性的。结果，内核中有大量代码并不遵循编码风格指南。这部分代码的存在给内核开发者带来了两个独立的风险。

第一个风险是认为内核编码标准无关紧要，不被强制执行。实际上，如果新加入的代码不符合标准，将其添加到内核中将非常困难；许多开发者会在审查代码之前要求重新格式化。对于像内核这样庞大的代码库来说，需要一定程度的代码一致性，以便开发者能够快速理解其中的任何部分。因此，现在没有空间留给格式奇怪的代码了。

偶尔，内核的编码风格可能会与雇主规定的风格发生冲突。在这种情况下，在代码能被合并前，内核的风格必须占据主导地位。将代码放入内核意味着在多个方面放弃一定的控制权——包括对代码格式的控制。

另一个陷阱是假设已经在内核中的代码迫切需要进行编码风格修正。开发者可能会开始生成重格式化补丁，作为熟悉流程的方式，或者作为一种让自己的名字出现在内核变更日志中的方式——或者两者兼有。但是，纯粹的编码风格修正被开发社区视为噪音；它们往往会受到冷遇。因此，这类补丁最好避免。在处理代码的其他原因时，自然会修正其风格，但不应仅为了改变编码风格而修改代码。

编码风格文档也不应被解读为绝对不可违背的法律。如果有充分的理由违反风格（例如，如果将一行代码分割以适应80列限制会使它变得远不如原来易读），那就直接这样做吧。

注意，你也可以使用 ``clang-format`` 工具来帮助你遵守这些规则，自动快速地重新格式化代码的一部分，审查整个文件以发现编码风格错误、拼写错误和可能的改进。它也适用于排序 ``#includes``，对齐变量/宏，重新排列文本等类似任务。详情请参阅 :ref:`Documentation/dev-tools/clang-format.rst <clangformat>` 文件。

如果你使用的是与 EditorConfig 兼容的编辑器，一些基本的编辑器设置，如缩进和行尾，将自动设置。更多信息，请访问官方 EditorConfig 网站：https://editorconfig.org/

抽象层
******************

计算机科学教授教导学生广泛使用抽象层，以提高灵活性和信息隐藏。
当然，内核广泛使用了抽象；对于涉及数百万行代码的项目来说，
如果不这样做就无法生存。但是经验表明，过度或过早的抽象就跟过
早优化一样有害。抽象应该只用到所需的程度，不能再多。

在简单层面上考虑一个其参数总是被所有调用者传为零的函数。
你可以保留这个参数，以防万一将来有人需要利用它提供的额外灵活性。
但到那时，很可能实现这个额外参数的代码已经在某个微妙的方式下损坏了，
却从未被发现——因为它从未被使用过。或者，当需要额外灵活性时，
并不会以程序员最初预期的方式出现。内核开发者会经常提交补丁来移除未使用的参数；
一般来说，这些参数从一开始就不要添加。

隐藏对硬件访问的抽象层——通常是为了让大部分驱动程序可以在多个操作系统中使用——
特别不受欢迎。这样的层使代码变得模糊，并可能带来性能损失；它们不属于 Linux 内核。

另一方面，如果你发现自己从另一个内核子系统大量复制代码，那么是时候问问自己是否
实际上应该把这些代码抽取出来形成单独的库，或者在更高层次上实现该功能。在整个内核中
复制相同的代码没有任何价值。

##### `#ifdef` 和预处理器的一般使用

**************

C 预处理器似乎给一些 C 程序员带来了极大的诱惑，他们将其视为一种高效地将大量灵活性编码到源文件中的方式。
但预处理器并不是 C 语言的一部分，大量使用它会导致其他人更难读懂代码，也使得编译器更难以检查代码的正确性。
大量使用预处理器几乎总是表明代码需要进行一些清理工作。

带有 `#ifdef` 的条件编译确实是一个强大的特性，并且在内核中得到了应用。但很少有人希望看到到处都是 `#ifdef` 块的代码。
作为一般规则，`#ifdef` 的使用应尽可能限制在头文件中。

条件编译的代码可以限定在函数内部，如果不需要这些代码，则这些函数变成空函数。这样，编译器会悄悄地优化掉对空函数的调用。
结果是更加清晰、易于理解的代码。

C 预处理器宏存在许多隐患，包括可能导致具有副作用的表达式被多次求值以及没有类型安全性。

如果你有定义宏的冲动，请考虑创建一个内联函数。生成的代码将是相同的，但内联函数更容易阅读，
不会多次求值其参数，并允许编译器对参数和返回值进行类型检查。
内联函数
**********

尽管内联函数存在自身的隐患。程序员可能会因为避免函数调用所带来的直观效率而过度使用内联函数，导致源文件中充斥着大量的内联函数。然而，这些函数实际上可能会降低性能。由于它们的代码在每个调用点都会被复制，这最终会增加编译后内核的大小。反过来，这会对处理器的内存缓存产生压力，可能导致执行速度显著下降。通常情况下，内联函数应该非常小且相对较少。毕竟，函数调用的成本并不是很高；创建大量内联函数是过早优化的一个典型例子。
总的来说，内核开发者忽视缓存效果将自食其果。在入门级数据结构课程中所教授的经典的时间/空间权衡往往不适用于现代硬件。空间即是时间，即一个较大的程序运行起来比更紧凑的程序要慢。
较新的编译器在决定某个函数是否真正需要内联方面扮演了越来越积极的角色。因此，过度使用“inline”关键字可能不仅是多余的，也可能是无关紧要的。

锁定
*******

2006年5月，“Devicescape”网络堆栈在大肆宣传下发布，并根据GPL开源，可以被合并到主线内核中。这一捐赠受到了欢迎，因为当时Linux的无线网络支持被认为最多只能算是次标准，而Devicescape堆栈承诺能够改善这种情况。然而，这段代码直到2007年6月（2.6.22版本）才真正进入主线。发生了什么？

这段代码显示出了明显的在企业内部开发的迹象。但最突出的一个问题是它没有为多处理器系统设计。在将这个网络堆栈（现称为mac80211）合并之前，必须为其添加锁定机制。
曾经有一段时间，Linux内核代码的开发无需考虑多处理器系统带来的并发问题。但现在，本文档正在一台双核笔记本电脑上编写。即使是在单处理器系统上，为了提高响应性所做的工作也会增加内核中的并发程度。那些无需考虑锁定就能编写内核代码的日子早已一去不复返了。
任何可能被多个线程同时访问的资源（如数据结构、硬件寄存器等）都必须通过锁进行保护。
新代码应当从一开始就考虑到这一要求；事后添加锁定机制是一项更为艰巨的任务。内核开发者应该花时间充分理解可用的锁定原语，以便选择正确的工具来完成任务。如果代码显示出了对并发性缺乏关注，那么它进入主线的过程将会非常艰难。

退化
***********

还有一个值得提及的隐患是：有时人们会被一种诱惑所吸引，那就是做一个改变（可能带来重大改进），但这会导致现有用户某些功能出现问题。这种改变被称为“退化”，在主线内核中退化变得极其不受欢迎。除了少数例外情况，如果无法及时修复退化问题，导致退化的更改将会被撤销。最好一开始就避免退化。
有人常常争论说，如果改变能让更多的人受益而不是造成问题，则退化是可以接受的。为什么不让十个系统的功能得到提升而只让一个系统受到影响呢？对此问题最好的回答是由Linus在2007年7月表达的：

::

	我们不会通过引入新问题来修复旧的问题。这样只会陷入疯狂，而且没有人能知道你是否真的取得了实质性的进展。这是前进两步后退一步，还是前进一步后退两步？

(https://lwn.net/Articles/243460/)
一种特别不受欢迎的回归类型是对用户空间 ABI 的任何更改。一旦接口被导出到用户空间，就必须无限期地支持它。这一事实使得创建用户空间接口变得尤其具有挑战性：由于它们不能以不兼容的方式更改，因此必须从一开始就做得正确。因此，对于用户空间接口来说，总是需要大量的思考、清晰的文档和广泛的审查。
代码检查工具
-------------

至少到现在为止，编写无错误代码仍然是我们很少有人能达到的理想状态。然而，我们可以希望在代码进入主线内核之前尽可能多地发现并修复这些错误。为此，内核开发者们已经汇集了一套令人印象深刻的工具，能够自动检测出各种隐蔽的问题。任何被计算机发现的问题都不会在以后困扰用户，因此合理的做法是尽可能使用自动化工具。
第一步仅仅是关注编译器产生的警告
现代版本的 gcc 可以检测（并警告）大量潜在的错误。很多时候，这些警告指向实际存在的问题。提交审核的代码原则上不应产生任何编译器警告。在消除警告时，请务必理解其根本原因，并尽量避免那些只是让警告消失而没有解决根本原因的“修复”。
请注意，并非所有编译器警告默认都是启用的。使用 "make KCFLAGS=-W" 构建内核以获取完整的警告集。
内核提供了多个配置选项来开启调试功能；其中大多数可以在“内核调试”子菜单中找到。对于用于开发或测试目的的内核，应该启用其中的一些选项。特别是，你应该启用：

- FRAME_WARN 来获取超过指定大小的栈帧警告。生成的输出可能很冗长，但不必担心来自内核其他部分的警告。
- DEBUG_OBJECTS 将添加代码来跟踪内核创建的各种对象的生命周期，并在事情处理顺序不当的时候发出警告。如果你正在添加一个创建（并导出）复杂对象的子系统，请考虑增加对对象调试基础设施的支持。
- DEBUG_SLAB 可以检测多种内存分配和使用错误；它应该用于大多数开发内核中。
- `DEBUG_SPINLOCK`, `DEBUG_ATOMIC_SLEEP` 和 `DEBUG_MUTEXES` 能够发现许多常见的锁错误。
还有不少其他的调试选项，其中一些将在下面讨论。它们中的一些会对性能产生显著影响，因此不应一直启用。但花些时间了解可用的选项可能会在短期内带来数倍的回报。
其中一个较重的调试工具是锁检查器，或称为“lockdep”。此工具会跟踪系统中每个锁（自旋锁或互斥锁）的获取与释放、锁相对于彼此获取的顺序、当前中断环境等更多内容。它能够确保锁始终以相同的顺序被获取，相同中断假设适用于所有情况等。换句话说，lockdep可以发现许多可能导致系统偶尔死锁的情形。这类问题在部署后的系统中可能给开发者和用户带来痛苦；lockdep允许我们提前以自动化的方式找到这些问题。任何包含非平凡锁机制的代码，在提交合并之前都应当启用lockdep进行测试。
作为尽责的内核开发者，毫无疑问您将检查任何可能失败的操作（如内存分配）的返回状态。然而，实际上，由此产生的故障恢复路径可能完全未经测试。未经测试的代码往往是有问题的；如果您所有的错误处理路径都经过了几次测试，那么您可以对您的代码更有信心。
内核提供了一个故障注入框架，可以特别针对涉及内存分配的情况实现这一点。启用故障注入后，可以配置一定百分比的内存分配失败；这些失败可以限制在一个特定的代码范围内。
启用故障注入运行可以让开发者看到代码在出现问题时的表现。有关如何使用此功能的更多信息，请参阅 `Documentation/fault-injection/fault-injection.rst`。
其他类型的错误可以通过静态分析工具“sparse”来检测。
通过sparse，开发者可以被警告关于用户空间和内核空间地址混淆、大端与小端数量混用、在期望一组位标志的地方传递整数值等问题。sparse需要单独安装（如果发行版未打包它，可以在 https://sparse.wiki.kernel.org/index.php/Main_Page 找到它）；然后可以通过在编译命令中添加 `C=1` 来运行。
"Coccinelle" 工具（http://coccinelle.lip6.fr/）能够发现各种潜在的编码问题，并且还可以提出修复建议。已经为内核打包了许多“语义补丁”，位于 `scripts/coccinelle` 目录下；运行 `make coccicheck` 将遍历这些语义补丁并报告发现的问题。更多信息请参见 `Documentation/dev-tools/coccinelle.rst`。
其他类型的可移植性错误最好通过为其他架构编译您的代码来发现。如果您没有S/390系统或Blackfin开发板，仍然可以执行编译步骤。为x86系统准备的一系列交叉编译器可以在以下位置找到：

    https://www.kernel.org/pub/tools/crosstool/

花费一些时间安装和使用这些编译器将有助于避免后续的尴尬。
文档
--------------

在内核开发中，文档往往更像是一种例外而非规则。即便如此，充分的文档将有助于新代码合并到内核中，使其他开发人员的生活更加轻松，并且对你的用户有所帮助。在许多情况下，添加文档已成为实质上的必要条件。

任何补丁的第一个文档是其关联的更改日志。日志条目应描述要解决的问题、解决方案的形式、参与补丁工作的人、任何相关的性能影响以及理解补丁所需的所有其他信息。确保更改日志说明为什么该补丁值得应用；令人惊讶的是，许多开发人员未能提供此信息。

任何添加新用户空间接口（包括新的sysfs或/proc文件）的代码都应包含该接口的文档，以便用户空间开发人员了解他们正在处理的内容。请参阅Documentation/ABI/README，以了解如何格式化此文档以及需要提供的信息。

文件:ref:`Documentation/admin-guide/kernel-parameters.rst <kernelparameters>` 描述了内核的所有启动时间参数。

任何添加新参数的补丁都应向此文件添加适当的条目。

任何新的配置选项必须附有帮助文本，清楚地解释这些选项以及用户可能想要选择它们的情况。

许多子系统的内部API信息通过特别格式化的注释进行记录；这些注释可以由“kernel-doc”脚本以多种方式提取和格式化。如果你在一个具有kerneldoc注释的子系统中工作，你应该维护这些注释，并根据需要为外部可用的函数添加它们。即使在尚未如此记录的领域，为将来添加kerneldoc注释也无害；事实上，这对初学者内核开发者来说可能是一项有益的活动。这些注释的格式以及如何创建kerneldoc模板的一些信息可以在:ref:`Documentation/doc-guide/ <doc_guide>` 中找到。

任何阅读大量现有内核代码的人都会注意到，往往最引人注目的是评论的缺失。再次，对新代码的期望高于过去；未加注释的代码合并将更加困难。也就是说，冗长注释的代码并不受欢迎。代码本身应该是可读的，注释解释更微妙的方面。

某些事情应该始终注释。内存屏障的使用应附有一行解释为什么需要屏障。数据结构的锁定规则通常需要在某处进行解释

主要的数据结构通常需要全面的文档。
代码各部分之间不易察觉的依赖关系应当被指出。任何可能诱使代码维护者进行错误“清理”的地方，都需要有注释说明为何要这样实现。如此等等。

内部API变更
-------------

内核向用户空间提供的二进制接口在极其严重的情况下才可打破。相反，内核的内部编程接口高度灵活，在需要时可以更改。如果你发现自己不得不绕过某个内核API工作，或者仅仅因为某功能不满足需求而未使用它，这可能是API需要改变的信号。作为内核开发者，你有权做出这样的变更。

当然，有一些限制条件。可以进行API变更，但必须有充分的理由。因此，任何涉及内部API变更的补丁都应该附带描述变更内容及必要性的说明。这类变更应该独立成为一个补丁，而不是隐藏在更大的补丁中。

另一个限制是，修改内部API的开发者通常需要负责修复因变更导致的内核树中任何破坏的代码。对于广泛使用的函数，这项职责可能导致成百上千个变更——其中许多可能会与其它开发者正在进行的工作产生冲突。不用说，这可能是一项巨大的工作，所以最好确保理由充分。注意，Coccinelle工具可以帮助处理广泛的API变更。

在进行不兼容的API变更时，应尽可能确保未更新的代码能被编译器捕获。这将帮助你确定已找到所有使用该接口的内核内部代码。同时，也会提醒树外代码的开发者，他们需要响应这一变更。支持树外代码不是内核开发者需要担忧的事情，但我们也没有必要让树外开发者的处境比必要的更加艰难。
