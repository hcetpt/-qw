.. _development_coding:

代码编写正确
======================

尽管一个坚实且面向社区的设计过程有很多值得称道的地方，但任何内核开发项目的关键在于最终的代码。代码将由其他开发者审查，并决定是否合并到主线树中。因此，代码的质量将决定项目的最终成功与否。本节将探讨编码过程。首先，我们将探讨内核开发者可能犯的一些错误。然后，重点将转向如何正确地做事以及在此过程中可以提供帮助的工具。

陷阱
---------

编码风格
************

内核长期以来一直有标准的编码风格，描述在 :ref:`Documentation/process/coding-style.rst <codingstyle>` 中。在这段时间的大部分时间里，该文件中的政策被认为最多只是建议性的。结果是，内核中有大量代码不符合编码风格指南。这些代码的存在给内核开发者带来了两个独立的风险。

第一个风险是认为内核编码标准无关紧要且不被强制执行。事实上，如果新添加的代码不符合标准，则很难将其加入内核；许多开发者会在审查代码之前要求其重新格式化。对于像内核这样庞大的代码库来说，保持一定的代码一致性是必要的，以便开发者能够快速理解任何部分。因此，不再允许格式奇怪的代码存在。

偶尔，内核的编码风格可能会与雇主规定的编码风格发生冲突。在这种情况下，内核的编码风格必须优先，才能将代码合并。将代码放入内核意味着在多个方面放弃一定程度的控制——包括对代码格式的控制。

另一个陷阱是假设已经在内核中的代码急需进行编码风格修复。开发者可能会开始生成重新格式化的补丁，作为熟悉流程的一种方式，或者作为将自己的名字写入内核变更日志的方式——或者两者兼而有之。但是纯粹的编码风格修复被视为噪音，通常会受到冷遇。因此，这种类型的补丁最好避免。在处理其他问题时顺便修复代码风格是很自然的，但不应为了修改编码风格而专门进行更改。

编码风格文档也不应被视为绝对不可违反的法律。如果有充分的理由违背风格（例如，如果将一行代码拆分成多行会使可读性大大降低），则应直接这样做。

请注意，您也可以使用 `clang-format` 工具来帮助遵守这些规则，自动快速重新格式化代码的一部分，审查整个文件以发现编码风格错误、拼写错误和可能的改进。它还适用于排序 `#include` 语句、对齐变量/宏、重新排版文本等类似任务。有关更多详细信息，请参阅 :ref:`Documentation/dev-tools/clang-format.rst <clangformat>`。

如果您使用的是与 EditorConfig 兼容的编辑器，一些基本的编辑器设置（如缩进和行尾）将自动设置。有关更多信息，请访问官方 EditorConfig 网站：https://editorconfig.org/

抽象层
******************

计算机科学教授教导学生广泛使用抽象层，以提高灵活性和隐藏信息。
当然，内核广泛使用了抽象；对于涉及数百万行代码的项目来说，如果不这样做，将难以生存。但经验表明，过度或过早地使用抽象和过早优化一样有害。抽象应该仅在必要时使用，并且不应过度。

举一个简单的例子，考虑一个函数，其有一个参数总是被所有调用者传为零。可以保留这个参数以备将来有人需要这种额外的灵活性。但到那时，很有可能实现这个额外参数的代码已经在某个细微之处被破坏了，而从未被发现——因为它从未被使用过。或者，当需要额外灵活性时，它并不会以程序员最初预期的方式出现。内核开发者通常会提交补丁来移除未使用的参数；一般来说，这些参数一开始就不要添加。

隐藏硬件访问的抽象层——通常是为使大部分驱动程序能够在多个操作系统上使用——尤其不受欢迎。这样的层会使代码变得晦涩，并可能导致性能下降；它们不应该出现在Linux内核中。

另一方面，如果你发现自己从另一个内核子系统复制了大量的代码，那么就应该考虑是否确实有必要将其中一些代码提取到单独的库中，或者在更高层次实现该功能。在整个内核中重复相同的代码是没有价值的。

##### `#ifdef` 和预处理的一般使用

C语言预处理器对某些C程序员来说似乎是一种强大的诱惑，他们将其视为一种高效地将大量灵活性编码到源文件中的方式。但预处理器并不是C语言的一部分，大量使用它会导致代码更难阅读，并且编译器更难检查其正确性。大量使用预处理器几乎总是代码需要清理的标志。

条件编译（使用`#ifdef`）确实是一个强大的特性，并且在内核中有所应用。但是，人们并不希望看到到处都是`#ifdef`块的代码。作为一般规则，应尽可能将`#ifdef`的使用限制在头文件中。

条件编译的代码可以限制在函数内部，如果不需要这些代码，则函数变成空函数。编译器会默默地优化掉对空函数的调用。这样产生的代码更加简洁，也更容易理解。

C预处理器宏存在多种风险，包括可能多次计算带有副作用的表达式以及缺乏类型安全。如果你倾向于定义一个宏，请考虑创建一个内联函数。生成的代码将是相同的，但内联函数更容易阅读，不会多次计算其参数，并允许编译器对参数和返回值进行类型检查。
内联函数
**************

内联函数本身存在一定的隐患。程序员可能会被避免函数调用所带来的假象效率所吸引，从而在一个源文件中充斥大量的内联函数。然而，这些函数实际上可能会降低性能。由于它们的代码在每个调用点都被复制，最终会导致编译后的内核体积膨胀。这反过来又会对处理器的内存缓存造成压力，可能导致执行速度显著下降。通常来说，内联函数应该非常小且数量较少。毕竟，函数调用的成本并不是很高；创建大量内联函数是一个典型的过早优化的例子。总的来说，内核程序员忽视缓存效应将自食其果。在初等数据结构课程中教授的经典时间/空间权衡在现代硬件上往往不适用。空间即是时间，这意味着较大的程序运行速度会比紧凑的程序慢。

较新的编译器在决定某个函数是否应该真正内联方面发挥了越来越积极的作用。因此，随意放置“inline”关键字不仅可能是多余的，甚至可能是无关紧要的。

锁定
******

2006年5月，备受瞩目的“Devicescape”网络栈在GPL许可下发布，并可用于合并到主线内核中。这一捐赠令人欢迎，因为Linux对无线网络的支持被认为至多是次标准的，而Devicescape网络栈提供了改进这种情况的希望。然而，这段代码直到2007年6月（2.6.22版本）才真正进入主线。发生了什么？

这段代码显示出许多迹象表明它是在企业内部开发的。但一个特别大的问题是它没有设计成能在多处理器系统上工作。在合并这个网络栈（现在称为mac80211）之前，需要为其添加锁定机制。

曾经有一段时间，Linux内核代码可以在不考虑多处理器系统并发问题的情况下开发。但现在，本文档是在一台双核笔记本电脑上编写的。即使在单处理器系统上，为了提高响应性所做的工作也会增加内核中的并发程度。不再考虑锁定就编写内核代码的日子早已过去。

任何可能被多个线程同时访问的资源（如数据结构、硬件寄存器等）都必须受到锁的保护。新代码应从一开始就考虑到这一要求；事后添加锁定机制是一项更为困难的任务。内核开发者应花时间充分理解可用的锁定原语，以便选择合适的工具。缺乏对并发关注的代码很难被合并进主线。

倒退
**********

最后值得一提的一个隐患是：做出改变（这可能会带来重大改进）导致现有用户某些功能失效的情况。这种改变被称为“倒退”，在主线内核中已经变得极其不受欢迎。除了少数例外情况，如果倒退无法及时修复，则会导致此类更改被回滚。最好是从一开始就避免倒退。

有人经常争论说，如果某个倒退使得更多的系统受益，那么这个倒退是可以接受的。为什么不在使十个系统受益的同时让一个系统出问题呢？对此问题的最佳回答由Linus在2007年7月表达：

::

	我们不会通过引入新问题来修复bug。那样做只会陷入疯狂，没有人能知道你是否真的取得了进展。是前进一步后退两步，还是前进一步后退一步？

（https://lwn.net/Articles/243460/）
一种特别不受欢迎的回归是任何对用户空间 ABI（应用程序二进制接口）的更改。一旦一个接口被导出到用户空间，它就必须无限期地支持下去。这一事实使得创建用户空间接口尤其具有挑战性：由于它们不能以不兼容的方式进行更改，因此必须在第一次就做到正确。因此，对于用户空间接口，始终需要大量的思考、清晰的文档和广泛的审查。

代码检查工具
------------

至少在目前，编写无错误代码仍然是我们大多数人难以达到的理想状态。然而，我们可以希望尽可能多地在代码进入主干内核之前发现并修复这些错误。为此，内核开发者们开发了一套令人印象深刻的工具，可以自动检测各种隐蔽的问题。任何被计算机捕获的问题都不会在后续使用中困扰用户，因此有理由认为应尽可能使用自动化工具。

第一步是注意编译器产生的警告。现代版本的 GCC 可以检测（并警告）大量潜在的错误。很多时候，这些警告指向实际存在的问题。提交审核的代码原则上不应产生任何编译器警告。在消除警告时，务必理解其真正原因，并尽量避免那些仅使警告消失而不解决问题根源的“修复”。

请注意，并非所有编译器警告都是默认启用的。通过 `make KCFLAGS=-W` 构建内核以获取完整的警告集。

内核提供了多个配置选项来启用调试功能；大多数这些选项可以在“kernel hacking”子菜单中找到。对于用于开发或测试目的的内核，应该启用其中的一些选项。特别是：

- **FRAME_WARN**：启用此选项可以获得关于堆栈帧大于特定大小的警告。生成的输出可能较多，但无需担心来自内核其他部分的警告。
- **DEBUG_OBJECTS**：此选项将添加代码来跟踪内核创建的各种对象的生命周期，并在操作顺序不正确时发出警告。如果你正在添加一个创建（并导出）复杂对象的新子系统，请考虑支持对象调试基础设施。
- **DEBUG_SLAB**：此选项可以检测多种内存分配和使用错误；应在大多数开发内核中使用。
- `DEBUG_SPINLOCK`、`DEBUG_ATOMIC_SLEEP` 和 `DEBUG_MUTEXES` 可以发现许多常见的锁错误。
还有一些其他的调试选项，其中一些将在下面讨论。这些选项中有一些会对性能产生显著影响，因此不应一直使用。但花时间了解可用的选项，很快就会得到多倍的回报。

一个较重的调试工具是锁检查器，或称为“lockdep”。此工具可以跟踪系统中每个锁（自旋锁或互斥锁）的获取和释放，锁相对于彼此的获取顺序，当前的中断环境等。它可以确保锁始终按照相同的顺序获取，相同中断假设适用于所有情况等。换句话说，lockdep可以发现系统在极少数情况下可能会死锁的多种场景。这类问题在部署系统时可能会给开发者和用户带来痛苦；lockdep允许在部署前自动发现这些问题。任何包含非平凡锁的代码，在提交合并之前都应该启用lockdep进行测试。

作为一名勤勉的内核程序员，毫无疑问，您会检查任何可能失败的操作（如内存分配）的返回状态。然而，事实是，由此产生的故障恢复路径很可能完全没有经过测试。未经测试的代码往往是错误的代码；如果所有这些错误处理路径都经过几次测试，您将对自己的代码更有信心。

内核提供了一个故障注入框架，可以做到这一点，尤其是在涉及内存分配的情况下。启用故障注入后，可配置比例的内存分配将被设置为失败；这些失败可以限制在特定范围的代码中。启用故障注入运行可以让程序员看到当事情出错时代码如何响应。更多关于如何使用此功能的信息，请参阅 `Documentation/fault-injection/fault-injection.rst`。

其他类型的错误可以通过静态分析工具“sparse”来发现。通过sparse，程序员可以被警告用户空间和内核空间地址混淆、大端和小端数量混合、传递整数值而非预期的位标志集等问题。sparse必须单独安装（如果发行版没有打包它，可以在 https://sparse.wiki.kernel.org/index.php/Main_Page 找到它）；然后可以通过在编译命令中添加 `C=1` 来运行该工具。

“Coccinelle”工具（http://coccinelle.lip6.fr/）能够发现各种潜在的编码问题，并提出修复建议。相当多的内核“语义补丁”已经打包在 `scripts/coccinelle` 目录下；运行 `make coccicheck` 将遍历这些语义补丁并报告发现的问题。更多信息请参见 `Documentation/dev-tools/coccinelle.rst`。

其他类型的移植性错误最好通过为其他架构编译您的代码来发现。如果您没有S/390系统或Blackfin开发板，您仍然可以执行编译步骤。大量用于x86系统的交叉编译器可以在以下网址找到：

https://www.kernel.org/pub/tools/crosstool/

花些时间安装和使用这些编译器将有助于避免后续的尴尬。
文档
------------

在内核开发中，文档常常是例外而非规则。即便如此，充分的文档有助于新代码合并到内核中，使其他开发者的任务变得容易，并且对用户也有帮助。在许多情况下，增加文档已经成为基本要求。
每个补丁的第一个文档是其相关的更改日志。日志条目应描述要解决的问题、解决方案的形式、参与补丁工作的人员、任何相关的性能影响，以及其他可能需要理解补丁的信息。确保更改日志说明为什么该补丁值得应用；令人惊讶的是，许多开发者未能提供这些信息。
任何添加新的用户空间接口（包括新的sysfs或/proc文件）的代码都应该包含对该接口的文档，以便用户空间开发者了解他们在处理什么。参见Documentation/ABI/README以了解如何格式化此文档以及需要提供的信息。
文件:ref:`Documentation/admin-guide/kernel-parameters.rst <kernelparameters>` 描述了内核的所有启动参数。
任何添加新参数的补丁都应在此文件中添加相应的条目。
任何新的配置选项必须附有清晰解释选项及其使用场景的帮助文本。
许多子系统的内部API信息通过特别格式化的注释来记录；这些注释可以通过“kernel-doc”脚本以多种方式提取和格式化。如果你在一个已经有kerneldoc注释的子系统中工作，你应该维护这些注释，并根据需要为对外可用的函数添加注释。即使在尚未如此记录的领域，为将来添加kerneldoc注释也没有坏处；实际上，这对初学者来说是一项有用的活动。这些注释的格式以及如何创建kerneldoc模板的信息可以在 :ref:`Documentation/doc-guide/ <doc_guide>` 中找到。
任何阅读大量现有内核代码的人都会注意到，注释往往是最缺乏的。再一次，对新代码的要求比过去更高；未加注释的代码将更难合并。尽管如此，人们并不希望看到冗长注释的代码。代码本身应该是可读的，注释用于解释更微妙的方面。
某些事情应该始终加上注释。内存屏障的使用应该附有一行解释为什么需要屏障。数据结构的锁定规则通常需要在某处进行解释。
主要的数据结构需要全面的文档。
代码之间的非显而易见的依赖关系应当被指出。任何可能诱使代码维护者进行错误“清理”的地方都需要加上注释说明为何这样实现。如此类推。

内部API变更
------------

内核向用户空间提供的二进制接口除非在最极端的情况下，否则不能被破坏。相反，内核的内部编程接口是非常灵活的，并且可以根据需要进行更改。如果你发现自己不得不绕过某个内核API，或者仅仅因为该功能不符合你的需求而不使用它，这可能是API需要变更的一个信号。作为内核开发者，你有权进行这样的变更。

当然，也有一些限制条件。可以进行API变更，但这些变更必须有充分的理由。因此，任何包含内部API变更的补丁都应该附带对该变更的描述以及其必要性。这种类型的变更还应该单独成为一个补丁，而不是埋在一个较大的补丁中。

另一个限制是，修改内部API的开发者通常需要负责修复因该变更而受影响的内核树中的所有代码。对于一个广泛使用的函数，这项任务可能导致数百甚至数千个变更——其中许多可能会与其他开发者的改动冲突。不言而喻，这可能是一项巨大的工作，因此最好确保理由充分。需要注意的是，Coccinelle工具可以帮助处理广泛的API变更。

在进行不兼容的API变更时，尽可能确保未更新的代码会被编译器捕捉到。这将帮助你确认已经找到了该接口的所有内核树中的使用情况。同时也会提醒外部代码的开发者需要应对这一变更。支持外部代码并不是内核开发者需要担心的问题，但我们也没有必要让外部开发者的任务比必要的更加困难。
