SPDX 许可证标识符：GPL-2.0

尖端树手册
==========

什么是尖端树？
---------------

尖端树是多个子系统和开发领域的集合。尖端树既是直接的开发树，也是多个子维护者树的聚合树。尖端树的 GitWeb URL 是：https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git

尖端树包含以下子系统：

- **x86 架构**

    x86 架构的开发在尖端树中进行，除了 x86 KVM 和 XEN 特定部分，这些部分在相应的子系统中维护，并直接从那里导入主线。对于 x86 特定的 KVM 和 XEN 补丁，向 x86 维护者抄送仍然是一个好习惯。
    某些 x86 子系统除了总体 x86 维护者之外还有自己的维护者。请在触及 arch/x86 目录下文件的补丁上抄送总体 x86 维护者，即使 MAINTAINER 文件中没有明确指出。
    注意，“x86@kernel.org”不是一个邮件列表，它只是一个将邮件分发给 x86 高层维护者团队的邮件别名。请始终抄送 Linux 内核邮件列表（LKML）“linux-kernel@vger.kernel.org”，否则你的邮件只会出现在维护者的私人收件箱中。

- **调度器**

    调度器开发在 -tip 树中进行，在 sched/core 分支下——偶尔会有针对工作中的补丁集的子主题树。

- **锁定和原子操作**

    锁定开发（包括原子操作和其他与锁定相关的同步原语）在 -tip 树中进行，在 locking/core 分支下——偶尔会有针对工作中的补丁集的子主题树。

- **通用中断子系统和中断芯片驱动程序**：

    - 中断核心开发发生在 irq/core 分支下。

    - 中断芯片驱动程序开发也发生在 irq/core 分支下，但补丁通常在一个单独的维护者树中应用，然后聚合到 irq/core。

- **时间、定时器、时钟保持、NOHZ 及相关芯片驱动程序**：

    - 时钟保持、clocksource 核心、NTP 和 alarmtimer 开发在 timers/core 分支下进行，但补丁通常在一个单独的维护者树中应用，然后聚合到 timers/core。

    - clocksource/event 驱动程序开发在 timers/core 分支下进行，但补丁大多在一个单独的维护者树中应用，然后聚合到 timers/core。

- **性能计数器核心、架构支持和工具**：

    - perf 核心和架构支持开发在 perf/core 分支下进行。

    - perf 工具开发在 perf 工具维护者树中进行，并聚合到尖端树中。

- **CPU 热插拔核心**

- **RAS 核心**

    大多数 x86 特定的 RAS 补丁收集在尖端 ras/core 分支下。

- **EFI 核心**

    EFI 在 efi Git 树中开发。收集的补丁在尖端 efi/core 分支中聚合。

- **RCU**

    RCU 在 linux-rcu 树中开发。结果更改聚合到尖端 core/rcu 分支中。

- **各种核心代码组件**：

    - debugobjects

    - objtool

    - 零散的部分

提交补丁注意事项
-------------------

选择树/分支
^^^^^^^^^^^^^^^^^^^^^^^^^

一般来说，对尖端树主分支的头部进行开发是可以的，但对于那些独立维护、有自己的 Git 树并仅聚合到尖端树的子系统，开发应该针对相关的子系统树或分支进行。
### 错误修复

针对主线的目标错误修复应当适用于主线内核树。对于已经在tip树中排队的更改可能产生的冲突，由维护者处理。

### 补丁主题
^^^^^^^^^^^^^

补丁主题前缀在tip树中的首选格式是`子系统/组件:`, 例如 `x86/apic:`, `x86/mm/fault:`, `sched/fair:`, `genirq/core:`。请不要使用文件名或完整的文件路径作为前缀。在大多数情况下，“git log path/to/file”应该能给出一个合理的提示。

主题行中的精简补丁描述应以大写字母开头，并用命令式语气书写。

### 变更日志
^^^^^^^^^

关于变更日志的一般规则，在《提交补丁指南》(:ref:`Submitting patches guide <describe_changes>`)中适用。

tip树的维护者重视遵循这些规则，特别是要求以命令式语气编写变更日志，而不是将代码或其执行过程拟人化。这不仅仅是维护者的个人偏好。用抽象词语编写的变更日志更为精确，通常也比小说形式的日志更少引起混淆。

同时，将变更日志结构化为几个段落而非全部堆砌在一个段落中也是有用的。一个好的结构是按顺序分别解释上下文、问题和解决方案。

### 示例说明

#### 示例 1:
```
x86/intel_rdt/mbm: 在热插拔CPU期间修复MBM溢出处理器

当一个CPU即将失效时，我们取消工作进程并在同一域内的另一个CPU上安排一个新的工作进程。但如果定时器几乎就要到期（比如0.99秒），那么实际上就将间隔加倍了。
我们修改了热插拔CPU的处理方式：取消即将失效的CPU上的延迟工作，并立即在同一域内的另一个CPU上运行工作进程。我们不刷新工作进程，因为MBM溢出工作进程会在同一CPU上重新安排工作进程，并扫描域->cpu_mask来获取域指针。
改进版本：
x86/intel_rdt/mbm: 在CPU热插拔期间修复MBM溢出处理器

当一个CPU即将失效时，溢出工作进程被取消并重新安排在同一个域内的另一个CPU上。但如果定时器几乎就要到期，这实际上会将间隔加倍，可能会导致溢出未被检测到。
取消溢出工作进程，并立即在同一域内的另一个CPU上重新安排它。工作进程可以被刷新，但这会重新将其安排在相同的CPU上。
```
示例2：

时间：POSIX CPU计时器：确保变量已初始化

如果`cpu_timer_sample_group`返回`-EINVAL`，它将不会写入`*sample`。检查`cpu_timer_sample_group`的返回值避免了在下一块代码中潜在地使用未初始化的`now`值。
当给定无效的`clock_idx`时，之前的代码可能会以未定义的方式覆盖`*oldval`。现在这已经被阻止。我们还利用&&的短路特性，在结果实际用于更新`*oldval`时才采样计时器。

改进版本：

POSIX-CPU计时器：使`set_process_cpu_timer()`更健壮

由于没有检查`cpu_timer_sample_group()`的返回值，编译器和静态检查器可以合法地警告关于可能使用未初始化变量`now`的潜在问题。这不是运行时的问题，因为所有调用站点都传递了有效的时钟ID。
此外，即使结果没有被使用（因为`*oldval`为NULL）时，`cpu_timer_sample_group()`也被无条件地调用。
使调用条件化并检查返回值。

示例3：

实体也可以用于其他目的
让我们将其重命名为更通用的名字

改进版本：

实体也可以用于其他目的
将其重命名为更通用的名字

对于复杂场景，特别是在竞争条件和内存排序问题上，用表格描绘场景，显示事件的并行性和时间顺序是很有价值的。下面是一个例子：

```
CPU0                              CPU1
free_irq(X)                       中断X
                                     spin_lock(desc->lock)
                                     唤醒irq线程()
                                     spin_unlock(desc->lock)
spin_lock(desc->lock)
移除操作()
shutdown_irq()
释放资源()                         线程处理器()
spin_unlock(desc->lock)               访问已释放的资源
``` 

在这个例子中，两个CPU上的操作展示了并发执行和事件的时间顺序，突出了资源访问和中断处理中的潜在问题。
同步中断处理程序（synchronize_irq()）

锁依赖性（Lockdep）提供了类似有用的输出来描绘一个可能的死锁场景：

    CPU0                                    CPU1
    rtmutex_lock(&rcu->rt_mutex)
      spin_lock(&rcu->rt_mutex.wait_lock)
                                            local_irq_disable()
                                            spin_lock(&timer->it_lock)
                                            spin_lock(&rcu->mutex.wait_lock)
    --> 中断
        spin_lock(&timer->it_lock)

在更改日志中的函数引用
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

当在更改日志中提及一个函数，无论是文本主体还是主题行，请使用'function_name()'的格式。省略函数名后的括号可能会引起歧义：

  主题：子系统/组件：将reservation_count设为静态

  reservation_count仅在reservation_stats中使用。将其设为静态
使用括号变体更为精确：

  主题：子系统/组件：将reservation_count()设为静态

  reservation_count()仅从reservation_stats()调用。将其设为静态

在更改日志中的回溯信息
^^^^^^^^^^^^^^^^^^^^^^^^

请参阅：:ref:`backtraces`

提交标签的顺序
^^^^^^^^^^^^^^^^^^^^^^^

为了使提交标签有一个统一的视图，tip维护者使用以下标签排序方案：

 - Fixes: 12char-SHA1("子系统/原主题行")

   即使对于不需要反向移植到稳定内核的变化，也应添加Fixes标签，即当处理最近引入的问题时，该问题只影响tip或主线当前的头部。这些标签有助于识别原始提交，并且比在更改日志本身的文本中突出显示引入问题的提交更有价值，因为它们可以自动提取。
下面的例子说明了区别：

     提交

       abcdef012345678 ("x86/xxx: 将foo替换为bar")

     留下了一个未使用的变量foo实例。移除它
签署者：J.Dev <j.dev@mail>

   请改为说：

     最近将foo替换为bar留下了一个未使用的变量foo实例。移除它
修复：abcdef012345678 ("x86/xxx: 将foo替换为bar")
     签署者：J.Dev <j.dev@mail>

   后者将关于补丁的信息置于焦点，并通过引用引入问题的提交来修正，而不是首先将焦点放在原始提交上。
- 报告者：``Reporter <reporter@mail>``
 - 关闭：``此修复的bug报告的URL或Message-ID``
 - 原作者：``原作者 <original-author@mail>``
 - 建议者：``建议者 <suggester@mail>``
 - 共同开发者：``共同作者 <co-author@mail>``
   
   签署者：``共同作者 <co-author@mail>``
   
   注意，共同开发者和共同作者的签署者必须成对出现。
- 签署者：``作者 <author@mail>``
   
   在最后一个共同开发者/签署者对之后的第一个签署者（SOB）是作者SOB，即由git标记为作者的人。
- 签署者：``补丁处理器 <handler@mail>``
   
   作者SOB之后的签署者来自处理和传输补丁的人，但并未参与开发。确认应该以Acked-by行给出，审查批准应以Reviewed-by行给出。
如果处理者对补丁或变更日志进行了修改，则应在**变更日志文本之后**和**所有提交标签之上**以以下格式提及这些修改：

```
... 变更日志文本结束
[ 处理者: 用 bar 替换了 foo 并更新了变更日志 ]

     第一个标签: ....
请注意，这两行空白的新行用于将变更日志文本和提交标签与该通知分开。
如果一个补丁由处理者发送到邮件列表，则作者必须在变更日志的第一行中注明，例如：

     来自: 作者 <author@mail>

     变更日志文本从这里开始...
这样可以保留作者信息。'来自:'行后必须跟一个空的换行符。如果缺少这条'来自:'行，则该补丁将被归因于发送（传输、处理）它的人。
'来自:'行会在应用补丁时自动删除，并不会出现在最终的 Git 变更日志中。它仅影响结果 Git 提交的作者信息。
- 测试者: ``测试者 <tester@mail>``

 - 审查者: ``审查者 <reviewer@mail>``

 - 认可者: ``认可者 <acker@mail>``

 - 抄送: ``抄送人 <person@mail>``

   如果补丁需要回溯到稳定版本，请添加一个'``抄送:
   stable@vger.kernel.org``'标签，但在发送邮件时不要抄送 stable
- 链接: ``https://link/to/information``

   对于引用内核邮件列表上发布的邮件，请使用lore.kernel.org重定向URL，例如：

     链接: https://lore.kernel.org/email-message-id@here

   当引用相关邮件列表主题、关联的补丁集或其他值得注意的讨论线程时，应使用此URL
一种方便的方法是使用类似markdown的方括号表示法将``链接:``注释与提交消息关联起来，例如：

     之前曾尝试过类似的方案作为另一项工作的组成部分 [1]，但最初的实现导致了太多的问题 [2]，因此我们撤销了这一改动并重新实现了它
链接: https://lore.kernel.org/some-msgid@here # [1]
     链接: https://bugzilla.example.org/bug/12345  # [2]

   当将补丁应用于您的 Git 仓库时，您也可以使用``链接:``注释来标明补丁的来源。在这种情况下，请使用专用的``patch.msgid.link``域而不是``lore.kernel.org``。```
这种做法使得自动化工具能够识别出哪个链接用于检索原始补丁提交。例如：

     链接: https://patch.msgid.link/patch-source-message-id@here

请不要使用组合标签，例如 ``Reported-and-tested-by``，因为它们只会使标签的自动化提取变得复杂。
链接到文档
^^^^^^^^^^^^^^^^^^^^^^

在变更日志中提供指向文档的链接对于后续的调试和分析非常有帮助。不幸的是，URL往往很快就失效了，因为公司经常会重组他们的网站。非“易变”（非-volatile）的例外包括英特尔SDM（Intel SDM）和AMD APM。因此，对于“易变”的文档，请在内核Bugzilla（https://bugzilla.kernel.org）中创建一个条目，并将这些文档的副本附在Bugzilla条目上。最后，在变更日志中提供Bugzilla条目的URL。
补丁重发或提醒
^^^^^^^^^^^^^^^^^^^^^^^^^

参见 :ref:`resend_reminders`
合并窗口
^^^^^^^^^^^^

请不要期望在合并窗口期间或其前后，顶端维护者会审查或合并补丁。在这段时间里，除了紧急修复之外，树是关闭的。一旦合并窗口关闭并且发布了一个新的-rc1内核后，它们就会重新开放。
大型系列应该至少在合并窗口开启前一周以可合并的状态提交。对于错误修复以及有时针对新硬件的小型独立驱动程序或对硬件支持影响最小的补丁，可以例外。
在合并窗口期间，维护者们主要关注上游的变化、解决合并窗口引发的问题、收集错误修复，并给自己喘息的机会。请对此表示尊重。
所谓的_紧急_分支将在每个发布的稳定阶段被合并到主线中。
Git
^^^

顶端维护者接受来自提供子系统更改以集成到顶端树中的维护者的git拉取请求。
对于新的补丁提交的拉取请求通常不会被接受，也不能替代通过邮件列表进行的适当补丁提交。主要原因在于审查流程基于电子邮件。
如果你提交一个较大的补丁系列，提供一个私有仓库中的 Git 分支会很有帮助，这样感兴趣的人可以轻松地拉取该系列进行测试。通常提供这种方式的方法是在补丁系列的封面信中包含一个 Git URL。

**测试**

在向维护者提交代码之前应该对代码进行测试。除了微小的改动之外，任何改动都应该构建、启动，并使用全面（且重量级）的内核调试选项进行测试。
这些调试选项可以在 `kernel/configs/x86_debug.config` 中找到，并可以通过运行以下命令添加到现有的内核配置中：

```bash
make x86_debug.config
```

其中一些选项是针对 x86 架构的，在其他架构上测试时可以忽略它们。

.. _maintainer-tip-coding-style:

**编码风格注意事项**

**注释风格**

- 注释中的句子以大写字母开头
- 单行注释：

```c
/* 这是一个单行注释 */
```

- 多行注释：

```c
/*
 * 这是一个格式正确的
 * 多行注释
 *
 * 较大的多行注释应分为段落
 */
```

- 不要使用尾部注释（见下文）：

  请不要使用尾部注释。尾部注释几乎在所有上下文中都会干扰阅读流程，尤其是在代码中：

```c
if (somecondition_is_true) /* 不要在这种位置放注释 */
    dostuff(); /* 也不要在这里 */
seed = MAGIC_CONSTANT; /* 也不要在这里 */
```

  请使用独立注释：

```c
/* 如果没有注释这个条件不明显 */
if (somecondition_is_true) {
    /* 这确实需要文档说明 */
    dostuff();
}

/* 这个魔法初始化需要一个注释。也许不需要？ */
seed = MAGIC_CONSTANT;
```

  在头文件中使用 C++ 风格的尾部注释来记录结构体，以实现更紧凑的布局和更好的可读性：

```c
// eax
u32     x2apic_shift    :  5, // 将 APIC ID 向右移位的位数，用于下一级的拓扑 ID
                                : 27; // 保留
// ebx
u32     num_processors  : 16, // 当前层级的处理器数量
                                : 16; // 保留
```

  相对于：

```c
/* eax */
/*
 * 将 APIC ID 向右移位的位数，用于下一级的拓扑 ID
 */
u32     x2apic_shift    :  5,
        /* 保留 */
                : 27;

/* ebx */
/*
 * 当前层级的处理器数量
 */
u32     num_processors  : 16,
        /* 保留 */
                : 16;
```

- 注释重要的内容：

  应该在操作不明显的地方添加注释。记录显而易见的内容只会造成干扰：

```c
/* 减少引用计数并检查是否为零 */
if (refcount_dec_and_test(&p->refcnt)) {
    do;
    lots;
    of;
    magic;
    things;
}
```

  相反，注释应该解释非显而易见的细节，并记录约束：

```c
if (refcount_dec_and_test(&p->refcnt)) {
    /*
     * 真正好的解释为什么下面的魔法事情
     * 需要做，以及排序和锁定约束等
     */
    do;
    lots;
    of;
    magic;
    /* 需要是最后一个操作，因为... */
    things;
}
```

- 函数文档注释：

  要记录函数及其参数，请使用 kernel-doc 格式，而不是自由形式的注释：

```c
/**
 * magic_function - 做大量的魔法事情
 * @magic: 指向要操作的魔法数据的指针
 * @offset: @magic 数据数组中的偏移量
 *
 * 使用 @magic 执行神秘事情的深入解释，
 * 以及返回值的文档说明
 *
 * 注意，上面的参数描述是以表格的形式排列的
 */
```

  这尤其适用于全局可见的函数和公共头文件中的内联函数。对于每个需要简短解释的（静态）函数使用 kernel-doc 格式可能是过度的。使用描述性的函数名称通常可以替代这些简短的注释。
始终运用常识  
----------------

记录锁定要求是一件好事，但注释不一定是最佳选择。请不要这样写：

	/* 调用者必须持有 foo->lock 锁 */
	void func(struct foo *foo)
	{
		..
	}

而是使用如下方式：

	void func(struct foo *foo)
	{
		lockdep_assert_held(&foo->lock);
		..
	}

在 PROVE_LOCKING 内核中，如果调用者没有持有锁，`lockdep_assert_held()` 将会发出警告。注释无法做到这一点。

括号规则  
--------------

只有当紧跟在 `if`、`for`、`while` 等后面的语句真正为单行时才省略括号：

	if (foo)
		do_something();

以下代码虽然 C 语言不需要括号，但并不被认为是单行语句：

	for (i = 0; i < end; i++)
		if (foo[i])
			do_something(foo[i]);

在外层循环周围添加括号可以增强阅读流程：

	for (i = 0; i < end; i++) {
		if (foo[i])
			do_something(foo[i]);
	}

变量声明  
------------

函数开始处的变量声明首选顺序是倒置的松树状顺序：

	struct long_struct_name *descriptive_name;
	unsigned long foo, bar;
	unsigned int tmp;
	int ret;

以上比反向顺序更容易理解：

	int ret;
	unsigned int tmp;
	unsigned long foo, bar;
	struct long_struct_name *descriptive_name;

并且比随机顺序更容易理解：

	unsigned long foo, bar;
	int ret;
	struct long_struct_name *descriptive_name;
	unsigned int tmp;

请尽量将相同类型的变量聚合到一行中。没有必要浪费屏幕空间：

	unsigned long a;
	unsigned long b;
	unsigned long c;
	unsigned long d;

实际上只需要这样做即可：

	unsigned long a, b, c, d;

请避免在变量声明中进行换行分割：

	struct long_struct_name *descriptive_name = container_of(bar,
						      struct long_struct_name,
						      member);
	struct foobar foo;

最好是将初始化移到声明之后的单独行：

	struct long_struct_name *descriptive_name;
	struct foobar foo;

	descriptive_name = container_of(bar, struct long_struct_name, member);

变量类型  
------------

对于描述硬件或作为访问硬件函数参数的变量，请使用正确的 `u8`、`u16`、`u32`、`u64` 类型。这些类型清楚地定义了位宽，并且避免了截断、扩展以及 32/64 位混淆的问题。
`u64` 也推荐用于代码中，在使用 `unsigned long` 会导致对 32 位内核产生歧义的情况下。虽然在这种情况下也可以使用 `unsigned long long`，但是 `u64` 更短，并且明确表明操作需要独立于目标 CPU 的 64 位宽度。

请使用 `unsigned int` 而不是 `unsigned`。

常量  
------

请不要在代码或初始化器中使用字面 (十六进制) 十进制数字。要么使用具有描述性名称的适当定义，要么考虑使用枚举。

结构体声明和初始化  
-------------------

结构体声明应以表格形式对齐结构体成员名称：

	struct bar_order {
		unsigned int	guest_id;
		int		ordered_item;
		struct menu	*menu;
	};

请避免在声明中记录结构体成员，因为这通常会导致格式奇怪的注释，并使结构体成员变得模糊不清：

	struct bar_order {
		unsigned int	guest_id; /* 唯一的顾客编号 */
		int		ordered_item;
		/* 指向包含所有饮品的菜单实例 */
		struct menu	*menu;
	};

相反，请考虑使用内核文档格式，在结构体声明前的注释中记录相关信息，这种方式更易于阅读，并且具有额外优势，即信息会被包括在内核文档中，例如：

	/**
	 * struct bar_order - 酒吧订单描述
	 * @guest_id:		唯一的顾客编号
	 * @ordered_item:	从菜单上点的项目编号
	 * @menu:		指针指向从其中点单的菜单
	 *
	 * 使用该结构体的补充信息
	 */
请注意，上述结构体成员描述符是以表格形式排列的。

```c
struct bar_order {
    unsigned int guest_id;       // 客户ID
    int ordered_item;            // 订单项目
    struct menu *menu;           // 菜单指针
};
```

静态结构初始化必须使用C99初始化器，并且也应该以表格形式对齐：

```c
static struct foo statfoo = {
    .a         = 0,              // 成员a初始化为0
    .plain_integer = CONSTANT_DEFINE_OR_ENUM, // 整型常量或枚举类型
    .bar       = &statbar,       // 指向另一个静态结构体的指针
};
```

请注意，尽管C99语法允许省略最后一个逗号，但我们建议在最后一行使用逗号，因为这样使得重新排序和添加新行更容易，也使得未来的补丁阅读起来稍微容易一些。

**换行**

限制每行长度为80个字符会使得深度缩进的代码难以阅读。考虑将代码分解成辅助函数以避免过多的换行。
80个字符的规则并不是严格的规定，所以在换行时请使用常识。特别是格式字符串不应该被分割。
当分割函数声明或函数调用时，请将第二行的第一个参数与第一行的第一个参数对齐：

```c
static int long_function_name(struct foobar *barfoo, unsigned int id,
                              unsigned int offset)
{
    if (!id) {
        ret = longer_function_name(barfoo, DEFAULT_BARFOO_ID,
                                   offset);
        ..
```

**命名空间**

函数/变量命名空间可以提高可读性并便于搜索。这些命名空间是全局可见的函数和变量名称（包括内联函数）的字符串前缀，如'x86_comp_'、'sched_'、'irq_'和'mutex_'。
这也包括那些立即放入全局可见驱动程序模板中的静态文件作用域函数——对于回溯的可读性来说，这些符号携带一个良好的前缀也是有用的。
命名空间前缀可以省略用于局部静态函数和变量。真正局部的函数，仅被其他局部函数调用的，可以有更短的描述性名称——我们主要关注的是可搜索性和回溯的可读性。
请注意，'xxx_vendor_' 和 'vendor_xxx_' 前缀对于特定供应商文件中的静态函数没有帮助。毕竟，代码是特定供应商的这一点已经很清楚了。此外，供应商名称应该只用于真正特定于供应商的功能。
一如既往地，应用常识并追求一致性和可读性。
提交通知
--------------------

小贴士树由一个机器人监控新的提交。对于每个新提交，机器人会向专门的邮件列表（``linux-tip-commits@vger.kernel.org``）发送一封电子邮件，并将所有在提交标签中被提及的人抄送。它使用链接标签末尾的电子邮件消息ID来设置In-Reply-To邮件头，以便消息能与补丁提交邮件正确地关联成线程。

小贴士的维护者和子维护者尝试在合并补丁时回复提交者，但他们有时会忘记，或者这不符合当前的工作流程。虽然机器人的消息是纯机械性的，但它也意味着一个“谢谢你！已应用。”

这段文字描述了在一个开源项目中，当有新的代码提交时，系统如何自动通知相关人员的过程。具体来说，每当有人向项目（这里称为“小贴士树”）提交新的代码更改，一个自动化机器人会发送邮件到指定的邮件列表，并同时抄送给所有在提交信息中被提及的人。此外，机器人还会利用提交信息中的链接标签来确保邮件能正确地与原始补丁提交邮件形成关联，便于追踪讨论。虽然维护者和子维护者也会尽量在合并代码时给予反馈，但机器人的通知提供了一种可靠的、即时的确认方式，表示提交已被接收并应用，带有感谢的意味。
