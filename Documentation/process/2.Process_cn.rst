开发流程
==================

20世纪90年代初的Linux内核开发相当松散，涉及的用户和开发者数量相对较少。随着用户基数达到数百万，并且每年有大约2000名开发者参与其中，内核不得不进化出一些流程以确保开发顺利进行。为了有效地参与其中，必须对这一过程有深入的理解。

大局观
--------------

内核开发者采用了一种大致基于时间的发布流程，每隔两到三个月就会发布一个新的主要版本。最近的发布历史如下：

======  =================
5.0     2019年3月3日
5.1     2019年5月5日
5.2     2019年7月7日
5.3     2019年9月15日
5.4     2019年11月24日
5.5     2020年1月6日
======  =================

每个5.x版本都是一个带有新功能、内部API变更等的主要版本。一个典型的发布可能包含大约13,000个更改集，涉及数十万行代码的变化。5.x是Linux内核开发的前沿；内核使用持续集成的开发模式，不断整合重大变更。

对于每个发布的合并补丁，遵循一种相对简单的纪律。在每个开发周期开始时，“合并窗口”被认为是开放的。此时，被认为足够稳定（并且被开发者社区接受）的代码将被合并到主线内核中。新开发周期中的大部分变更（以及所有重大变更）将在这一时间段内完成，每天的合并速度接近1,000个变更（即“补丁”或“更改集”）。

（顺便说一句，合并窗口期间集成的变更并不是凭空出现的；它们已经被收集、测试并提前准备好了。这个过程的具体工作方式将在后面详细描述）

合并窗口大约持续两周。在此之后，Linus Torvalds会宣布窗口关闭并发布第一个“rc”内核。例如，对于预定为5.6的内核，合并窗口结束时发布的版本将被称为5.6-rc1。-rc1的发布标志着合并新功能的时间已经过去，现在是稳定下一个内核的时间。

接下来的六到十周内，只有修复问题的补丁才能提交到主线。偶尔允许进行更重大的变更，但这种情况很少见；试图在合并窗口之外合并新功能的开发者往往会受到不友好的回应。

一般来说，如果你错过某个特定功能的合并窗口，最好的做法是等待下一个开发周期。（有时会对之前不受支持的硬件驱动做出例外处理；如果它们不触及树内的代码，则不会导致回归，因此可以在任何时候安全添加）

随着修复补丁逐渐进入主线，补丁率将随着时间减慢。Linus大约每周发布一个新的-rc内核；一个正常的系列会在最终发布前达到-rc6到-rc9之间。

此时整个过程重新开始。以下是一个示例，展示了5.4开发周期的过程（所有日期均为2019年）：

==============  ===============================
9月15日         5.3 稳定版发布
9月30日         5.4-rc1，合并窗口关闭
10月6日         5.4-rc2
10月13日        5.4-rc3
10月20日        5.4-rc4
10月27日        5.4-rc5
11月3日         5.4-rc6
11月10日        5.4-rc7
11月17日        5.4-rc8
11月24日        5.4 稳定版发布
==============  ===============================

开发者如何决定何时结束开发周期并创建稳定版本？最重要的指标是来自先前版本的回归列表。虽然任何bug都不受欢迎，但那些破坏了以前正常工作的系统的bug被视为特别严重。因此，导致回归的补丁在稳定期间往往会被视为不利，并且很有可能被回滚。
开发者的目的是在稳定版发布之前修复所有已知的倒退问题。然而，在现实世界中，这种完美很难实现；一个如此规模的项目中有太多的变量。在某个时刻，延迟最终发布的做法只会让问题变得更糟；等待下一次合并窗口的更改堆积会变得更多，从而在下次合并时产生更多的倒退问题。因此，大多数5.x内核在发布时仍带有少量已知的倒退问题，但希望其中没有一个是严重的。

一旦稳定版发布，其后续维护工作将交给“稳定团队”，目前该团队由Greg Kroah-Hartman负责。稳定团队将使用5.x.y编号方案不定期发布稳定版更新。要被考虑用于更新发布的补丁必须满足以下两个条件：(1) 修复一个重要的错误，(2) 已经合并到下一个开发内核的主线中。内核通常会在其初始发布后的一个多开发周期内收到稳定更新。例如，5.2内核的历史记录如下（所有日期为2019年）：

==============  ===============================
July 7          5.2 稳定版发布
July 14         5.2.1
July 21         5.2.2
July 26         5.2.3
July 28         5.2.4
July 31         5.2.5
...             ...
October 11      5.2.21
==============  ===============================

5.2.21 是5.2版本的最终稳定更新。

一些内核被指定为“长期支持”内核；它们将获得更长时间的支持。请参考以下链接获取活跃的长期支持内核版本及其维护者列表：

<https://www.kernel.org/category/releases.html>

选择某个内核进行长期支持完全取决于维护者是否有需求和时间来维护该版本。目前没有针对任何特定即将发布的内核进行长期支持的具体计划。

补丁的生命周期
------------------------

补丁不会直接从开发者的键盘进入主线内核。相反，有一个较为复杂（尽管有些非正式）的过程，旨在确保每个补丁经过质量审查，并且每个补丁实现的变化是主线所期望的。这个过程对于小的修复可能会很快完成，而对于大的有争议的变更，则可能需要多年时间。很多开发者的挫败感来源于对这一过程的不了解或试图绕过它。

为了减少这种挫败感，本文档将描述补丁如何进入内核的过程。以下是一个简化的介绍，详细说明将在后续部分给出。

补丁经历的一般阶段包括：

- 设计。这是确定补丁的真实需求以及如何满足这些需求的地方。设计工作通常是在不涉及社区的情况下完成的，但如果可能的话，最好公开进行这项工作；这可以节省以后重新设计的时间。
### 早期审查
补丁会发布到相关的邮件列表中，该列表中的开发者会对这些补丁发表评论。如果一切顺利，这个过程应该能够发现补丁中的主要问题。

### 更广泛的审查
当补丁接近准备合并到主线时，它应该被相关子系统的维护者接受——尽管这种接受并不保证补丁最终会被合并到主线。补丁会在维护者的子系统树中出现，并进入下一个版本的树（如下所述）。当流程顺利进行时，这一步会导致对补丁进行更广泛的审查，并发现由此补丁与其他工作结合时可能出现的问题。

### 注意事项
大多数维护者还有日常工作，因此合并你的补丁可能不是他们的首要任务。如果你的补丁收到了需要修改的反馈，你应该要么做出这些修改，要么解释为什么不应该做出这些修改。如果你的补丁没有审查上的问题但还没有被相应的子系统或驱动程序维护者合并，你应该坚持更新补丁以适应当前内核，使其能干净地应用，并继续提交审核和合并请求。

### 合并到主线
最终，成功的补丁将被合并到由Linus Torvalds管理的主线仓库中。此时可能会出现更多的评论和/或问题；重要的是开发者要对这些问题作出回应，并解决由此产生的任何问题。

### 稳定发布
现在，受此补丁影响的用户数量很大，因此可能会再次出现新的问题。

### 长期维护
虽然开发者在合并代码后可能会忘记它，但这种行为通常会在开发社区留下不好的印象。合并代码确实减轻了一些维护负担，因为其他人会修复由于API更改引起的问题。但是，如果代码要在长期中保持有用性，原始开发者应继续对其负责。

内核开发者（或其雇主）所犯的最大错误之一是试图将整个过程简化为单一的“合并到主线”步骤。这种方法总是会导致所有相关人员的挫败感。

### 补丁如何进入内核

只有一人可以将补丁合并到主线内核仓库中：Linus Torvalds。例如，在2.6.38内核中包含的9500多个补丁中，只有112个（约1.3%）是由Linus本人直接选择的。内核项目早已发展到一个规模，任何单个开发者都不可能独自检查和选择每一个补丁。内核开发者通过建立信任链的副官系统来应对这一增长。

内核代码库逻辑上被划分为一组子系统：网络、特定架构支持、内存管理、视频设备等。大多数子系统都有指定的维护者，即对该子系统内的代码负有总体责任的开发者。这些子系统维护者是他们所管理部分的守门人（在某种程度上）；他们是通常会接受补丁并将其纳入主线内核的人。

每个子系统维护者都会管理自己版本的内核源码树，通常使用git这样的源代码管理工具。像git（以及quilt或mercurial等相关的工具）这样的工具允许维护者跟踪补丁列表，包括作者信息和其他元数据。在任何时候，维护者都可以识别出其仓库中哪些补丁尚未出现在主线中。
当合并窗口打开时，顶级维护者会请求林纳斯从他们的仓库中“拉取”他们选择用于合并的补丁。如果林纳斯同意，这些补丁流将流入他的仓库，并成为主线内核的一部分。林纳斯对每次拉取操作中具体补丁的关注程度各不相同。有时他会仔细查看，但通常情况下，他信任子系统的维护者不会推送有问题的补丁到上游。

反过来，子系统维护者也可以从其他维护者那里拉取补丁。例如，网络树是由首先累积在网络设备驱动、无线网络等专用树中的补丁构建而成的。这个仓库链可以任意长，但通常不超过两三个环节。由于链条上的每个维护者都信任管理下层树的人，这一过程被称为“信任链”。

显然，在这样的系统中，将补丁纳入内核取决于找到合适的维护者。直接向林纳斯发送补丁通常不是正确的做法。

### 下一周期树

子系统树指导补丁流入内核的过程，但也提出了一个有趣的问题：如果有人想查看所有为下一合并窗口准备的补丁怎么办？开发者们会对其他待处理的变化感兴趣，以查看是否有任何冲突需要担心；例如，修改核心内核函数原型的补丁会与使用该函数旧形式的其他补丁冲突。审查者和测试者希望在所有这些变化进入主线内核之前能够访问集成后的变更。虽然可以从所有有趣的子系统树中拉取变更，但这将是一个庞大且容易出错的工作。

解决办法是使用“-next”树，这些树收集子系统树供测试和审查。其中较老的一棵树由安德鲁·莫顿（Andrew Morton）维护，称为“-mm”（起源于内存管理）。-mm树集成了来自大量子系统树的补丁，还包含一些帮助调试的补丁。除此之外，-mm中还有大量由安德鲁直接挑选的补丁。这些补丁可能发布在邮件列表上，或者适用于没有指定子系统树的内核部分。因此，-mm充当了一种最后的子系统树；如果没有其他明显的途径将补丁推入主线，它很可能会出现在-mm中。积累在-mm中的各种补丁最终会被转发到适当的子系统树或直接发送给林纳斯。在一个典型的开发周期中，大约有5-10%的补丁通过-mm进入主线。

当前的-mm补丁位于：

```
https://www.ozlabs.org/~akpm/mmotm/
```

尽管如此，使用MMOTM树可能会是一种令人沮丧的经历；它甚至可能无法编译。

下一周期补丁合并的主要树是linux-next，由斯蒂芬·罗斯韦尔（Stephen Rothwell）维护。设计上，linux-next树是主线内核在下一个合并窗口关闭后预期样子的快照。linux-next树在组装完成时会在linux-kernel和linux-next邮件列表中宣布；可以从以下地址下载：

```
https://www.kernel.org/pub/linux/kernel/next/
```

linux-next已成为内核开发过程的重要组成部分；所有在特定合并窗口期间合并的补丁应该在合并窗口打开前就已进入linux-next。

### 准备阶段树

内核源码树包含drivers/staging/目录，许多驱动程序或文件系统在加入内核树之前都会暂存在这里。它们会留在drivers/staging中，直到完成进一步的工作；一旦完成，就可以移入内核主干。这是一种跟踪不符合Linux内核编码或质量标准的驱动程序的方法，但人们可能希望使用它们并跟踪其开发进度。
Greg Kroah-Hartman 目前维护着 staging 树。需要进一步工作的驱动程序会被发送给他，每个驱动程序在 `drivers/staging/` 下都有自己的子目录。除了驱动源文件外，该目录中还应包含一个 TODO 文件。TODO 文件列出了该驱动程序为了被正式接受到内核中所需完成的工作，以及应该抄送任何驱动补丁的人员名单。目前的规定要求提交给 staging 的驱动程序至少必须能够正确编译。

将新驱动程序纳入主线内核，staging 可以是一个相对简单的方式，在这种情况下，这些驱动程序可能会引起其他开发者的注意并迅速改进。然而，进入 staging 并不是故事的结束；如果代码在 staging 中没有定期进展，最终会被移除。发行版也倾向于相对不愿意启用 staging 驱动程序。因此，staging 最多只是一个成为正式主线驱动程序过程中的临时站点。

工具
----

从上述文字可以看出，内核开发过程严重依赖于收集和管理各种补丁集的能力。如果没有强大的工具，整个过程的效果将大打折扣。如何使用这些工具的教程超出了本文档的范围，但这里可以提供一些指导。

内核社区中最主要使用的源代码管理系统是 Git。Git 是自由软件社区开发的分布式版本控制系统之一。它非常适合内核开发，因为它在处理大型仓库和大量补丁时表现出色。尽管 Git 被认为学习和使用起来比较困难，但它随着时间的推移有所改善。对于内核开发者来说，熟悉 Git 几乎是必须的；即使他们不亲自使用 Git，也需要用 Git 来跟进其他开发者（包括主线）的工作。

几乎所有 Linux 发行版都提供了 Git 的包。Git 的主页位于：

  https://git-scm.com/

该页面有指向文档和教程的链接。

在不使用 Git 的内核开发者中，最受欢迎的选择几乎肯定是 Mercurial：

  https://www.selenic.com/mercurial/

Mercurial 和 Git 共享许多特性，但它提供了一个许多开发者觉得更容易使用的界面。

另一个值得了解的工具是 Quilt：

  https://savannah.nongnu.org/projects/quilt/

Quilt 是一个补丁管理系统，而不是源代码管理系统。它不跟踪历史记录；而是面向跟踪一组特定的更改与不断演进的代码库之间的关系。

一些主要子系统的维护者使用 Quilt 来管理打算提交上游的补丁。对于某些类型的树（如 -mm），Quilt 是最佳工具。

邮件列表
--------

大量的 Linux 内核开发工作都是通过邮件列表进行的。如果不加入至少一个邮件列表，很难成为一个活跃的社区成员。但是，Linux 邮件列表也可能对开发者构成潜在的风险，他们可能被大量的电子邮件淹没，或者违反了 Linux 列表上的约定。

大多数内核邮件列表托管在 kernel.org 上；主列表可以在以下地址找到：

  https://subspace.kernel.org

也有其他地方托管的列表；请查看相关子系统的 MAINTAINERS 文件以获取相应的列表。
内核开发的核心邮件列表当然是 linux-kernel。这个列表是一个让人感到压力的地方；每天的信息量可能达到500条，噪音很多，讨论可能非常技术化，参与者并不总是注重礼貌。但是没有其他地方能让整个内核开发者社区聚集在一起；避开这个列表的开发者会错过重要的信息。

以下是一些有助于应对 linux-kernel 邮件列表的小技巧：

- 将列表发送到一个单独的文件夹，而不是你的主要收件箱。必须能够在一段时间内忽略这些信息流。
- 不要试图跟踪每一段对话——其他人也不会这样做。重要的是根据感兴趣的议题（注意长期对话可能会偏离原始主题而电子邮件的主题行却没有改变）和参与的人进行过滤。
- 不要回应那些故意挑起愤怒反应的人。如果有人试图激起你的愤怒反应，忽略他们。
- 在回复 linux-kernel 的邮件（或其他列表的邮件）时，请保留 Cc: 标头中的所有相关人员。除非有充分的理由（例如明确请求），否则不应删除任何收件人。始终确保你回复的人在 Cc: 列表中。这一惯例也使得不需要专门要求在回复中抄送你。
- 在提问之前搜索邮件列表存档（以及整个网络）。一些开发者会对明显没有做足功课的人失去耐心。
- 使用交错式（"inline"）回复，这会让你的回答更容易阅读。（即避免顶部回复——将你的答案放在引用文本上方的做法。）更多细节请参阅 :ref:`Documentation/process/submitting-patches.rst <interleaved_replies>`。
- 在正确的邮件列表上提问。虽然 linux-kernel 是一个通用的聚会点，但它并不是找到所有子系统开发者的最佳地点。

最后一个要点——找到正确的邮件列表——是初学者开发者常犯的一个错误。在 linux-kernel 上提出与网络相关的问题的人几乎肯定会收到建议，让他们转而向 netdev 列表提问，因为大多数网络开发者都经常访问该列表。还有其他列表用于 SCSI、video4linux、IDE、文件系统等子系统。查找邮件列表的最佳地点是在随内核源代码一起发布的 MAINTAINERS 文件中。
如何开始内核开发
---------------------------------------

关于如何开始内核开发过程的问题非常常见，无论是来自个人还是公司。同样常见的是一些错误做法，使得这一过程比预期更困难。公司通常希望雇佣知名的开发者来启动一个开发团队。这实际上可以是一种有效的策略，但同时也往往成本高昂，并且对增加有经验的内核开发者数量帮助不大。通过投入一些时间，可以将内部开发者培养成熟悉Linux内核开发的人才。这样做可以让雇主拥有一支既了解内核又了解公司的开发团队，并且能够帮助培训其他人。从中期来看，这通常是更有利可图的方法。

对于个人开发者来说，他们常常不知道从何开始，这是可以理解的。从一个大型项目开始可能会让人感到压力山大；人们通常希望先从小规模的事情开始尝试。这时，有些开发者会着手修复拼写错误或代码风格问题的小补丁。不幸的是，这样的补丁会给整个开发社区带来干扰性的噪音，因此越来越不受欢迎。新开发者如果希望通过这种方式介绍自己，可能不会得到他们所期望的欢迎。

安德鲁·莫顿（Andrew Morton）为有志于内核开发的新手提供了以下建议：

::

    对所有内核初学者来说，首要任务应该是“确保内核在你能接触到的所有机器上始终完美运行”。通常实现这一点的方法是与其他开发者合作解决问题（这可能需要一定的毅力！），但这没问题——这是内核开发的一部分。（来源：https://lwn.net/Articles/283982/）

在没有明显问题需要解决的情况下，开发者被建议查看当前的回归列表和一般开放的bug列表。总是有很多问题需要修复；通过解决这些问题，开发者不仅可以获得实践经验，同时也能赢得其他开发者的尊重。
