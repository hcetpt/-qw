开发流程如何运作
=================

20世纪90年代初的Linux内核开发是一个相当宽松的过程，涉及的用户和开发者数量相对较少。随着用户基数达到数百万，并且每年有大约2,000名开发者参与其中，内核不得不发展出一系列流程以确保开发顺利进行。为了有效地成为这个过程的一部分，对这一流程有一个扎实的理解是必要的。

大局观
--------

内核开发者采用一种基于时间的发布流程，每隔两到三个月就会有一个新的主要内核版本发布。最近的发布历史如下：

| 版本号 | 发布日期       |
|--------|--------------|
| 5.0    | 2019年3月3日  |
| 5.1    | 2019年5月5日  |
| 5.2    | 2019年7月7日  |
| 5.3    | 2019年9月15日 |
| 5.4    | 2019年11月24日|
| 5.5    | 2020年1月6日  |

每个5.x版本都是一个带有新功能、内部API变更等的主要内核版本。一个典型的版本可能包含约13,000个更改集，涉及数十万行代码的更改。5.x是Linux内核开发的最前沿；内核使用持续集成的主要变化的滚动开发模型。

对于每次发布的补丁合并遵循一个相对直接的规则。在每个开发周期开始时，“合并窗口”被视为开放。此时，被认为足够稳定（并被开发者社区接受）的代码将被合并到主线内核中。新开发周期的大部分更改（以及所有重大更改）将在这一时期合并，每天的合并速度接近1,000个更改（“补丁”或“更改集”）。

（顺便说一下，值得注意的是，在合并窗口期间集成的更改并非凭空出现；它们已被收集、测试并在之前阶段准备就绪。稍后会详细描述这个过程是如何工作的）

合并窗口持续大约两周。在此期间结束后，Linus Torvalds将宣布窗口关闭并发布第一个“rc”内核。例如，对于即将成为5.6的内核，合并窗口结束时发布的版本将被称为5.6-rc1。-rc1的发布标志着合并新功能的时间已经过去，而稳定下一个内核的时间已经开始。

接下来的六到十周内，只有修复问题的补丁才能提交到主线。偶尔会有更重大的更改被允许，但这种情况很少见；试图在合并窗口之外合并新功能的开发者通常会遭到不友好的对待。

一般而言，如果你错过了一定功能的合并窗口，最好的做法就是等待下一次开发周期。（有时会对以前不受支持的硬件驱动程序做出例外处理；如果它们不触及树内的代码，它们就不会导致倒退并且可以随时安全添加）

随着修复程序逐渐进入主线，补丁率将随时间放缓。Linus大约每周发布一个新的-rc内核；一个正常的系列会在最终版本发布前达到-rc6到-rc9之间。

在这一点上，整个过程又重新开始。

以下是以5.4开发周期为例（所有日期为2019年）：

| 日期       | 事件/版本                  |
|------------|---------------------------|
| 9月15日    | 5.3稳定版发布             |
| 9月30日    | 5.4-rc1，合并窗口关闭     |
| 10月6日    | 5.4-rc2                   |
| 10月13日   | 5.4-rc3                   |
| 10月20日   | 5.4-rc4                   |
| 10月27日   | 5.4-rc5                   |
| 11月3日    | 5.4-rc6                   |
| 11月10日   | 5.4-rc7                   |
| 11月17日   | 5.4-rc8                   |
| 11月24日   | 5.4稳定版发布             |

开发者如何决定何时关闭开发周期并创建稳定版本？最重要的指标是来自先前版本的倒退列表。虽然任何bug都不受欢迎，但那些破坏了过去工作系统的bug被认为是特别严重的。因此，导致倒退的补丁不受欢迎，并且很可能会在稳定期被撤销。
开发者的目的是在稳定版发布前修复所有已知的退化问题。然而，在现实世界中，这种完美很难达成；像这样大规模的项目中有太多的变量。到了某个点，延迟最终发布只会让问题变得更糟；等待下一次合并窗口的变更堆会变得更大，从而在下一轮产生更多的退化问题。因此，大多数5.x版本的内核都会带着一些已知的退化问题发布，不过，希望其中没有严重的问题。

一旦稳定版发布，其后续维护工作就会移交给“稳定团队”，目前这一角色由Greg Kroah-Hartman担任。稳定团队将使用5.x.y的编号方案偶尔发布稳定版更新。要被考虑用于更新发布的补丁必须满足两个条件：(1) 修复一个重要的错误，(2) 已经合并到下一个开发版内核的主线中。内核通常会在它们最初发布后的一个多开发周期内收到稳定更新。例如，5.2内核的历史如下（所有日期均为2019年）：

| 发布日期 | 版本号 |
|----------|--------|
| 7月7日   | 5.2 稳定版发布 |
| 7月14日  | 5.2.1  |
| 7月21日  | 5.2.2  |
| 7月26日  | 5.2.3  |
| 7月28日  | 5.2.4  |
| 7月31日  | 5.2.5  |
| ...      | ...    |
| 10月11日 | 5.2.21 |

5.2.21是5.2版本的最终稳定更新。

某些内核被指定为“长期支持”内核；它们会获得更长时间的支持。请参考以下链接获取活跃的长期支持内核版本及其维护者列表：

https://www.kernel.org/category/releases.html

选择某个内核进行长期支持纯粹取决于维护者是否有需求和时间来维护该版本。目前尚无任何已知计划对特定即将到来的版本提供长期支持。

### 补丁的生命周期

补丁不会直接从开发者的键盘进入主线内核。相反，有一个虽然非正式但相当复杂的过程来确保每个补丁都经过质量审查，并且实现的变更对于主线来说是可取的。这个过程对于较小的修复可能很快完成，而对于大型且有争议的更改，则可能持续数年。开发者们的很多挫败感来自于对这个过程缺乏理解或试图绕过它。

为了减少这种挫败感，本文档将描述补丁如何进入内核的过程。下面是一个理想化的介绍，概述了这个过程。更详细的说明将在后续部分给出。

补丁经历的一般阶段包括：

- 设计。这是确定补丁的真实需求以及如何满足这些需求的地方。设计工作通常是在不涉及社区的情况下完成的，但如果有可能的话，最好在这个阶段就公开进行这项工作；这样做可以节省日后重新设计的时间。
- 早期审查。补丁会被发布到相关的邮件列表中，该列表中的开发者会回复他们对补丁的任何意见。如果一切顺利，这个过程应该能发现补丁中存在的主要问题。
  
- 更广泛的审查。当补丁接近准备好被合并入主线时，它应该得到相关子系统维护者的认可——尽管这种认可并不能保证补丁最终一定会被合并至主线。补丁将出现在维护者的子系统分支中，并进入下一个版本的分支（如下所述）。当流程顺利进行时，这一步将导致对补丁进行更全面的审查，并发现由此补丁与其他人的工作集成所带来的任何问题。
  
- 请注意大多数维护者也有日常工作，因此合并你的补丁可能并不是他们的首要任务。如果你的补丁收到了需要做出更改的反馈，你应该要么做出这些更改，要么说明为什么不应该做出这些更改。如果你的补丁没有收到负面的审查意见但并没有被相应的子系统或驱动程序维护者合并，你应该持续更新补丁以适应当前内核版本，确保其能正确应用，并继续发送进行审查和合并。
  
- 合并到主线。最终，成功的补丁将被合并到由Linus Torvalds管理的主线仓库中。此时可能会出现更多的评论和/或问题；重要的是开发者要对此作出响应，并解决可能出现的任何问题。
  
- 稳定版发布。现在受补丁影响的用户数量很大，因此再次可能会出现新的问题。
  
- 长期维护。虽然开发者在合并代码后忘记它是完全有可能的，但这种行为往往会在开发社区留下不好的印象。合并代码减轻了一些维护负担，因为其他人会修复API变更引起的问题。但如果代码要在长期内保持有用，原始开发者应继续对其负责。

内核开发者（或他们的雇主）犯下的最大错误之一就是试图将整个过程简化为单一的“合并到主线”步骤。这种做法总是会给所有相关人员带来挫败感。

补丁如何进入内核
------------------

能够将补丁合并到主线内核仓库的人只有一个：Linus Torvalds。但是例如，在2.6.38内核版本中合并的超过9500个补丁中，只有112个（大约1.3%）是由Linus本人直接挑选的。内核项目已经发展到了一个规模，没有任何一个开发者可能独自检查和选择每一个补丁而无需帮助。内核开发者们通过建立信任链为基础的副手制度来应对这一增长。

内核代码库逻辑上被分解为一系列子系统：网络、特定架构支持、内存管理、视频设备等。大多数子系统都有指定的维护者，即对该子系统内的代码负有总体责任的开发者。这些子系统维护者是他们所管理的部分内核的把关人（以一种较为宽松的方式来说）；他们是通常会接受补丁以纳入主线内核的人。

子系统维护者各自管理着自己的内核源码树版本，通常（但并非总是）使用git这样的源代码管理工具。像git（以及类似quilt或mercurial这样的工具）这样的工具允许维护者跟踪一系列补丁，包括作者信息和其他元数据。在任何时候，维护者都能识别出在他或她的仓库中哪些补丁尚未被合并进主线。
当合并窗口开启时，顶级维护者会请求林纳斯“提取”他们从其代码仓库中挑选出以进行合并的补丁。如果林纳斯同意，这些补丁流将流入他的代码库，成为主线内核的一部分。林纳斯对通过提取操作收到的具体补丁的关注程度各不相同。很明显，有时候他会仔细查看。但通常情况下，林纳斯信任子系统维护者不会把有问题的补丁发往上游。反过来，子系统维护者也可以从其他维护者那里提取补丁。例如，网络树是由首先累积在网络设备驱动程序、无线网络等专用树中的补丁构建而成的。这个仓库链可以任意长，尽管很少超过两到三个环节。由于链条上的每个维护者都信任管理下层树的人，因此这一过程被称为“信任链”。

显然，在这样的体系中，让补丁进入内核取决于找到合适的维护者。直接向林纳斯发送补丁通常不是正确的做法。
下一周期树
----------

子系统树组成的链条指导着补丁流入内核的过程，但也引发了一个有趣的问题：如果有谁想查看所有为下一个合并窗口准备的补丁该怎么办？开发者们会关心还有哪些待定的变化，以确认是否存在冲突问题；例如，一个改变了核心内核函数原型的补丁就会与使用该函数旧形式的任何其他补丁产生冲突。而评审人员和测试人员希望在所有这些变化被集成进主线内核之前就能接触到它们。虽然可以从所有感兴趣的子系统树中提取变化，但这将是一项庞大且容易出错的工作。

答案就是通过“-next”树来收集子系统树以供测试和评审。其中最老的一棵-“-mm”树由安德鲁·莫顿维护（因最初关注内存管理而得名）。-mm树集成了来自众多子系统树的补丁；它还包括了一些有助于调试的补丁。

除此之外，-mm树还包含了一大堆由安德鲁直接挑选的补丁。这些补丁可能是在邮件列表上发布的，也可能适用于那些没有指定子系统树的内核部分。结果是，-mm树起到了一种最后手段的子系统树的作用；如果没有其他明显的路径能让补丁进入主线内核，那么它很可能会出现在-mm树中。积累在-mm树中的各种补丁最终要么被转发给适当的子系统树，要么直接提交给林纳斯。在一个典型的开发周期中，大约有5-10%的补丁是通过-mm树进入主线的。

当前的-mm补丁可以在“mmotm”（-mm of the moment）目录中找到：

	https://www.ozlabs.org/~akpm/mmotm/

不过使用MMOTM树可能会是一次令人沮丧的经历；有很大可能性它甚至编译都无法通过。

用于下一周期补丁合并的主要树是斯蒂芬·罗思韦尔维护的linux-next树。按设计，linux-next树是对主线内核在下一个合并窗口关闭后预计的样子的一个快照。当linux-next树被组装好时，会在linux-kernel和linux-next邮件列表上宣布；可以从以下位置下载：

	https://www.kernel.org/pub/linux/kernel/next/

linux-next已经成为内核开发过程中不可或缺的一部分；所有在一个特定合并窗口期间合并的补丁应该在合并窗口开启前的某个时候就已经进入了linux-next树。
预备阶段树
--------------

内核源码树包含drivers/staging/目录，许多处于进入内核树过程中的驱动程序或文件系统的子目录就在这里。它们留在drivers/staging目录中是因为还需要更多的工作；一旦完成，就可以移入内核主体。这是一种跟踪那些不符合Linux内核编码或质量标准但人们可能想要使用并追踪其发展的驱动程序的方法。
Greg Kroah-Hartman 目前维护着暂存树。那些仍需改进的驱动程序会被发送给他，每个驱动程序在 `drivers/staging/` 下都有自己的子目录。除了驱动源文件外，目录中还应该有一个待办事项（TODO）文件。待办事项文件列出了该驱动程序为了被正式接受进入内核还需要完成的工作，以及任何对该驱动程序的补丁都应该抄送的人列表。当前的规定要求，提交到暂存中的驱动程序至少必须能够正确编译。
暂存可以是一个相对简单的途径来让新的驱动程序进入主线内核，在那里，如果运气好的话，它们会吸引其他开发者的注意并迅速得到改进。但是，进入暂存并不是故事的终点；如果暂存中的代码没有定期取得进展，则最终会被移除。发行版也往往不太愿意启用暂存驱动程序。因此，暂存最多只是成为正式主线驱动程序道路上的一个停靠点。
工具
------

从上面的文字可以看出，内核开发过程严重依赖于将一系列补丁集合向不同方向推进的能力。如果没有强大的工具，整个流程的效果远不会像现在这样好。如何使用这些工具的教程远远超出了本文档的范围，但这里有一些提示。
内核社区中使用的主导版本控制系统无疑是 Git。Git 是自由软件社区中正在开发的分布式版本控制系统之一。它非常适合内核开发，因为它在处理大型仓库和大量补丁时表现出色。虽然它以难以学习和使用而闻名，但随着时间的推移，它的可用性已经有所提高。对于内核开发者来说，对 Git 的一定程度的熟悉几乎是必须的；即使他们不亲自使用 Git 进行工作，也需要用 Git 来跟踪其他开发者（包括主线）的工作。
几乎所有 Linux 发行版都包含了 Git。其主页位于：

	https://git-scm.com/

该页面提供了指向文档和教程的链接。
在不使用 Git 的内核开发者中，最受欢迎的选择几乎肯定是 Mercurial：

	https://www.selenic.com/mercurial/

Mercurial 与 Git 共享许多特性，但它提供了一个许多人觉得更容易使用的界面。
另一个值得了解的工具是 Quilt：

	https://savannah.nongnu.org/projects/quilt/

Quilt 是一个补丁管理系统，而不是一个源代码管理系统。它不跟踪随时间变化的历史记录；相反，它侧重于针对不断发展的代码库跟踪一组特定的变化。
一些主要子系统的维护者使用 Quilt 来管理计划合并到上游的补丁。对于某些类型树（例如 -mm 树）的管理，Quilt 是最佳选择。
邮件列表
--------------

大量的 Linux 内核开发工作是通过邮件列表进行的。如果不加入至少一个列表，很难成为社区的活跃成员。但 Linux 邮件列表也对开发者构成潜在的风险，他们可能会被大量的电子邮件淹没，或者违反 Linux 列表上使用的约定，甚至两者皆有。
大多数内核邮件列表托管在 kernel.org；主列表可以在这里找到：

	https://subspace.kernel.org

也有其他地方托管的列表；请检查 MAINTAINERS 文件以找到与特定子系统相关的列表。
核心的内核开发邮件列表当然是 linux-kernel。这个列表可能让人感到压力巨大；邮件数量有时能达到每天 500 封，无关信息的比例很高，讨论可能会极其技术化，参与者并不总是注重表现出高度的礼貌。但是没有其他地方能让整个内核开发者社区如此集中地汇聚一堂；避开这个列表的开发者会错过重要的信息。
以下是一些有助于适应 linux-kernel 邮件列表的建议：

- 让该列表发送到一个单独的文件夹，而不是你的主邮箱。有时候你必须能够忽略这些邮件流一段时间。
- 不要试图跟踪每一个讨论——没有人能做到。重要的是根据感兴趣的主题进行过滤（需要注意的是，长时间的讨论可能会偏离最初的题目，但电子邮件的主题行却没有更改），同时也考虑参与者的身份。
- 不要回应那些试图激起激烈反应的人。如果有人在故意挑事，请忽略他们。
- 在回复 linux-kernel 的邮件（或其他列表）时，保留所有相关方的 Cc: 标头。除非有强烈的理由（比如明确请求），否则你不应该移除收件人。确保你回复的人出现在 Cc: 列表中。这一惯例也使得没有必要明确要求将回复抄送给你。
- 在提问前搜索邮件列表存档（以及整个网络）。一些开发者会对明显没有做好功课的人失去耐心。
- 使用交错式（"内联"）回复，这样你的回复更容易阅读。（即避免顶部回复——把你的答案放在引用文本上方的做法。）更多详情，请参阅 :ref:`Documentation/process/submitting-patches.rst <interleaved_replies>`。
- 在正确的邮件列表上提问。虽然 linux-kernel 可能是一个总的聚会点，但它并不是找到所有子系统开发者的最佳地点。
最后一个点——找到正确的邮件列表——是新手开发者常犯的错误。向 linux-kernel 提出与网络相关的问题的人几乎肯定会得到礼貌的建议，让他们转而向 netdev 列表提问，因为大多数网络开发者都会关注那个列表。还有其他的列表用于 SCSI、video4linux、IDE、文件系统等子系统。查找邮件列表的最佳位置是在随内核源码一起打包的 MAINTAINERS 文件中。
开始内核开发
-------------------------------

关于如何开始内核开发过程的问题很常见 —— 无论是来自个人还是公司。同样常见的是一些让这段关系的开始比必要时更艰难的错误步骤。公司通常希望聘请知名的开发者来启动一个开发团队。这实际上可能是一种有效的策略。但这也往往代价昂贵，并且对增加经验丰富的内核开发者数量帮助不大。如果投入一些时间，是可以让内部开发者熟悉Linux内核开发的。花这些时间可以使雇主拥有一组既了解内核又了解公司的开发者，并且他们还可以帮助培训其他人。从中期来看，这通常是更有利可图的方法。

对于个人开发者来说，常常会困惑于该从哪里开始，这是可以理解的。以一个大项目开始可能会让人感到畏惧；人们通常希望先从一个小一点的项目入手试试水。这就是一些开发者选择通过修复拼写错误或小的代码风格问题这样的补丁来介入的时候。不幸的是，这类补丁会产生一种干扰整个开发者社区的噪音水平，因此，越来越多的人对此持否定态度。希望向社区介绍自己的新开发者通过这种方式不会得到他们所期望的那种欢迎。

安德鲁·莫顿（Andrew Morton）为有志于成为内核开发者的人员提供了以下建议：

:: 

    对所有内核初学者来说，首要的任务应该是“确保内核在你能够接触到的所有机器上始终完美运行”。通常，实现这一目标的方式是与其他人员合作解决问题（这可能需要持之以恒！），但这很好——这是内核开发的一部分。
(https://lwn.net/Articles/283982/)

如果没有明显的问题需要解决，建议开发者查看当前的回归列表和一般性的未解决bug。永远不缺少需要修复的问题；通过解决这些问题，开发者将获得过程中的经验，同时也会在其他开发者社区中建立起尊重。
