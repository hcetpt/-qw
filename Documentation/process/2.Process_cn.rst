开发过程如何运作
==================

在1990年代初，Linux内核的开发相当松散，涉及的用户和开发者数量相对较少。随着用户基数达到数百万，每年有约2000名开发者参与其中，内核不得不发展出一系列流程以确保开发进程的顺利进行。为了有效地成为这一过程的一部分，对流程的深入了解是必要的。

大局观
--------

内核开发者采用了一种基于时间的发布流程，大约每两到三个月会发布一个新的主要内核版本。最近的发布历史如下：

======  =================
5.0     2019年3月3日
5.1     2019年5月5日
5.2     2019年7月7日
5.3     2019年9月15日
5.4     2019年11月24日
5.5     2020年1月6日
======  =================

每个5.x版本都是一个带有新特性、内部API变更等的主要内核版本。一个典型的发布可能包含大约13,000个更改集，涉及数十万行代码的更改。5.x代表了Linux内核开发的最前沿；内核采用持续集成的重大变化的滚动开发模型。

对于每次发布的补丁合并，遵循着一种相对直接的纪律。在每个开发周期开始时，所谓的“合并窗口”被视为开放。此时，被认为足够稳定（并被开发者社区接受）的代码将被合并到主线内核中。新开发周期的大部分变更（以及所有重大变更）将在这一期间合并，每天接近1,000个变更（或称为“补丁”、“更改集”）。

（顺便说一句，值得注意的是，在合并窗口期间整合的更改并非凭空出现；它们已被收集、测试，并提前准备就绪。这一过程的工作方式将在后面详细描述）

合并窗口大约持续两周。在这段时间结束时，Linus Torvalds会宣布窗口关闭，并发布第一个“rc”内核。例如，对于预定为5.6的内核，合并窗口结束时的发布将被称为5.6-rc1。-rc1的发布标志着合并新特性的时刻已经过去，现在是时候稳定下一个内核了。

在接下来的六到十周内，只有修复问题的补丁才应提交给主线。偶尔，可能会允许更重大的变更，但这种情况很少见；试图在合并窗口之外合并新特性的开发者往往会受到不友好的对待。

一般而言，如果你错过了某个特性的合并窗口，最好的做法是等待下一个开发周期。（有时会对之前不受支持的硬件驱动做出例外；如果它们不触及树内的代码，它们不会导致回归，应该可以在任何时候安全地添加）

随着修复程序进入主线，随着时间推移，补丁率将逐渐降低。Linus大约每周发布一次新的-rc内核；一个正常的系列会在最终内核被认为足够稳定并进行最终发布前达到-rc6到-rc9之间。

在这一点上，整个过程又重新开始。

以下是一个例子，展示5.4开发周期的进展情况（所有日期为2019年）：

==============  ===============================
9月15日         5.3 稳定版发布
9月30日         5.4-rc1，合并窗口关闭
10月6日         5.4-rc2
10月13日        5.4-rc3
10月20日        5.4-rc4
10月27日        5.4-rc5
11月3日         5.4-rc6
11月10日        5.4-rc7
11月17日        5.4-rc8
11月24日        5.4 稳定版发布
==============  ===============================

开发者如何决定何时结束开发周期并创建稳定版本？最重要的指标是来自先前版本的回归列表。虽然没有bug是受欢迎的，但是那些破坏了过去正常工作的系统的bug被认为是特别严重的。因此，导致回归的补丁不受欢迎，并且很可能在稳定化期间被撤销。
开发者的目的是在稳定版发布前修复所有已知的退化问题。然而，在现实世界中，这种完美很难达成；像这样大规模的项目中有太多的变量。到了某个点，延迟最终发布只会让问题变得更糟；等待下一次合并窗口的变更堆会变得更大，从而在下一轮产生更多的退化问题。因此，大多数5.x版本的内核都会带着一些已知的退化问题发布，不过，希望其中没有严重的问题。

一旦稳定版发布，其后续维护工作就会移交给“稳定团队”，目前这一角色由Greg Kroah-Hartman担任。稳定团队将使用5.x.y的编号方案偶尔发布稳定版更新。要被考虑用于更新发布的补丁必须满足两个条件：(1) 修复一个重要的错误，(2) 已经合并到下一个开发版内核的主线中。内核通常会在它们最初发布后的一个多开发周期内收到稳定更新。例如，5.2内核的历史如下（所有日期均为2019年）：

| 发布日期 | 版本号 |
|----------|--------|
| 7月7日   | 5.2 稳定版发布 |
| 7月14日  | 5.2.1  |
| 7月21日  | 5.2.2  |
| 7月26日  | 5.2.3  |
| 7月28日  | 5.2.4  |
| 7月31日  | 5.2.5  |
| ...      | ...    |
| 10月11日 | 5.2.21 |

5.2.21是5.2版本的最终稳定更新。

某些内核被指定为“长期支持”内核；它们会获得更长时间的支持。请参考以下链接获取活跃的长期支持内核版本及其维护者列表：

https://www.kernel.org/category/releases.html

选择某个内核进行长期支持纯粹取决于维护者是否有需求和时间来维护该版本。目前尚无任何已知计划对特定即将到来的版本提供长期支持。

### 补丁的生命周期

补丁不会直接从开发者的键盘进入主线内核。相反，有一个虽然非正式但相当复杂的过程来确保每个补丁都经过质量审查，并且实现的变更对于主线来说是可取的。这个过程对于较小的修复可能很快完成，而对于大型且有争议的更改，则可能持续数年。开发者们的很多挫败感来自于对这个过程缺乏理解或试图绕过它。

为了减少这种挫败感，本文档将描述补丁如何进入内核的过程。下面是一个理想化的介绍，概述了这个过程。更详细的说明将在后续部分给出。

补丁经历的一般阶段包括：

- 设计。这是确定补丁的真实需求以及如何满足这些需求的地方。设计工作通常是在不涉及社区的情况下完成的，但如果可能的话，最好公开进行这项工作；这可以节省日后重新设计的时间。
- 早期审查。补丁会被发布到相关的邮件列表中，该列表中的开发者会回复他们对补丁的任何意见。如果一切顺利，这个过程应该能发现补丁中的主要问题。
- 更广泛的审查。当补丁接近准备好被主线收录时，应该由相关子系统的维护者接受——尽管这种接受并不能保证补丁一定能进入主线。补丁将出现在维护者的子系统树中，并进入下一个树（如下所述）。当流程顺利进行时，这一步会导致对补丁进行更全面的审查，并发现由此补丁与他人工作整合时可能产生的任何问题。
- 请注意大多数维护者也有日常工作，因此合并你的补丁可能不是他们的首要任务。如果你的补丁收到了需要更改的反馈，你应该做出这些更改或解释为什么不应该做出这些更改。如果你的补丁没有收到审查中的投诉但没有被适当的子系统或驱动程序维护者合并，你应该坚持更新补丁以适应当前内核，以便它可以干净地应用，并继续发送进行审查和合并。
- 合并到主线。最终，成功的补丁将被合并到由Linus Torvalds管理的主线存储库中。此时可能会出现更多的评论和/或问题；重要的是开发者要对此作出回应，并解决可能出现的任何问题。
- 稳定版本。现在受补丁影响的潜在用户数量很大，因此，再次，可能会出现新的问题。
- 长期维护。虽然开发者在合并代码后忘记它是完全可能的，但这种行为往往会给开发社区留下不好的印象。合并代码减轻了一些维护负担，因为其他人会修复因API变更引起的问题。但如果代码要在长期内保持有用，原始开发者应继续对其负责。

内核开发者（或他们的雇主）犯的最大错误之一就是试图将流程简化为单一的“合并到主线”步骤。这种方法总是会导致所有相关人员的挫败感。

如何将补丁纳入内核
------------------------

只有一个人可以将补丁合并到主线内核存储库：Linus Torvalds。但是，例如，在2.6.38内核中包含的超过9,500个补丁中，只有112个（大约1.3%）是直接由Linus本人选择的。内核项目已经发展到了一个规模，没有任何一个开发者可能单独检查和选择每个补丁而不借助帮助。内核开发者通过使用基于信任链的副手系统来应对这种增长。

内核代码库从逻辑上被划分为一系列子系统：网络、特定架构支持、内存管理、视频设备等。大多数子系统都有指定的维护者，即对该子系统内的代码负有总体责任的开发者。这些子系统维护者是他们所管理内核部分的守门人（以一种宽泛的方式而言）；他们是通常会接受补丁纳入主线内核的人。

子系统维护者各自管理着自己的内核源代码树版本，通常（但肯定不是总是）使用git这样的源代码管理工具。像git（以及quilt或mercurial等相关的工具）这样的工具允许维护者跟踪补丁列表，包括作者信息和其他元数据。在任何时候，维护者都可以确定其仓库中的哪些补丁尚未出现在主线中。
当合并窗口开启时，顶级维护者会请求林纳斯从他们的仓库中“拉取”他们挑选出来用于合并的补丁。如果林纳斯同意，这一系列的补丁将流入他的仓库，成为主线内核的一部分。林纳斯对通过拉取操作收到的具体补丁的关注程度各不相同。很明显，有时候他会仔细查看。但通常情况下，林纳斯信任子系统维护者不会向上游发送有问题的补丁。反过来，子系统维护者可以从其他维护者那里拉取补丁。例如，网络树是由首先在专门针对网络设备驱动、无线网络等领域的仓库中积累的补丁构建而成的。这个仓库链可以任意长，尽管很少超过两到三个环节。由于链条中的每个维护者都信任管理下级树的人员，因此这个过程被称为“信任链”。

显然，在这样的体系中，将补丁送入内核的关键在于找到合适的维护者。直接向林纳斯发送补丁通常不是正确的做法。

### 下一周期树

子系统树链引导补丁流入内核，但也引出了一个有趣的问题：如果有人想查看所有准备用于下一合并窗口的补丁怎么办？开发者会对其他待定的变更感兴趣，以确认是否有任何冲突需要担心；例如，修改核心内核函数原型的补丁将与使用该函数旧形式的任何其他补丁产生冲突。审查者和测试者希望在所有这些变更进入主线内核之前，就能访问到集成后的变更。人们可以从所有有趣的子系统树中拉取变更，但这将是一项庞大且容易出错的工作。

答案在于 -next 树，其中子系统树被收集起来供测试和审查。由安德鲁·莫顿维护的这些树中较老的一个被称为“-mm”（最初是为内存管理而开始的）。-mm 树整合了来自一系列子系统树的补丁；它还包含了一些旨在帮助调试的补丁。除此之外，-mm 还包含了一大堆由安德鲁直接挑选的补丁。这些补丁可能是在邮件列表上发布的，或者它们可能适用于没有指定子系统树的内核部分。结果，-mm 作为最后的子系统树运行；如果没有其他明显的路径让补丁进入主线，它很可能会最终出现在 -mm 中。在 -mm 中累积的杂项补丁最终要么被转发到适当的子系统树，要么直接发送给林纳斯。在一个典型的开发周期中，大约 5-10% 的补丁是通过 -mm 进入主线的。

当前的 -mm 补丁可以在“mmotm”（即刻的-mm）目录中找到：

```
https://www.ozlabs.org/~akpm/mmotm/
```

然而，使用 MMOTM 树可能会是一次令人沮丧的经历；有很大可能它甚至无法编译。

下一周期合并的主要树是 Stephen Rothwell 维护的 linux-next。linux-next 树按设计是一个快照，展示了在下一个合并窗口关闭后主线预计的样子。当 linux-next 树组装完成时，会在 linux-kernel 和 linux-next 邮件列表中宣布；可以从以下位置下载：

```
https://www.kernel.org/pub/linux/kernel/next/
```

linux-next 已经成为内核开发流程不可或缺的一部分；在特定合并窗口期间合并的所有补丁实际上都应该在合并窗口打开前的某个时间点进入 linux-next。

### 预备阶段树

内核源代码树中包含 drivers/staging/ 目录，许多驱动程序或文件系统的子目录就在这里，它们正等待加入内核树。它们留在 drivers/staging 目录中，直到它们需要更多的工作；一旦完成，就可以移入内核主体。这是一种跟踪不符合 Linux 内核编码或质量标准的驱动程序的方式，但人们可能想要使用它们并跟踪其开发进度。
格雷格·克罗亚-哈特曼（Greg Kroah-Hartman）目前维护着暂存树。仍需工作的驱动程序会被发送给他，每个驱动程序在`drivers/staging/`目录下都有自己的子目录。除了驱动程序的源文件外，目录中还应该有一个TODO文件。TODO文件列出了该驱动程序为了被正式内核接受所需完成的工作，以及任何对该驱动程序的补丁都应抄送的人名单。当前的规定要求，提交到暂存中的驱动程序至少必须能够正确编译。
暂存可以是一个相对简单的方式，让新的驱动程序进入主线内核，在那里，如果运气好的话，它们会受到其他开发者的关注并迅速改进。但进入暂存并不是故事的结束；如果暂存中的代码没有看到定期进展，最终会被移除。发行版也倾向于相对不愿意启用暂存驱动程序。因此，暂存充其量只是成为正式主线驱动程序道路上的一个站点。
工具
-----

从上面的文字可以看出，内核开发过程非常依赖于对各种方向的补丁集进行管理的能力。如果没有足够强大的工具，整个过程的效果将远不如现在这样好。如何使用这些工具的教程超出了本文档的范围，但这里有一些指导建议。

内核社区中使用最广泛的源代码管理系统无疑是git。Git是自由软件社区中正在开发的众多分布式版本控制系统之一。它非常适合内核开发，因为它在处理大型仓库和大量补丁时表现得相当好。虽然它以难以学习和使用而闻名，但随着时间的推移已经有所改善。对于内核开发者来说，某种程度上熟悉git几乎是必须的；即使他们不亲自使用它，也需要git来跟踪其他开发者（和主线）的工作。
几乎所有Linux发行版现在都提供了git包。其主页位于：

	https://git-scm.com/

该页面有指向文档和教程的链接。

在不使用git的内核开发者中，最受欢迎的选择几乎肯定是Mercurial：

	https://www.selenic.com/mercurial/

Mercurial与git有许多共同的特点，但它提供了一个许多人发现更容易使用的界面。

另一个值得了解的工具是Quilt：

	https://savannah.nongnu.org/projects/quilt/

Quilt是一个补丁管理系统，而不是源代码管理系统。它不追踪随时间变化的历史记录；相反，它是针对在不断发展的代码库中追踪一组特定更改而设计的。
一些主要子系统的维护者使用Quilt来管理计划提交上游的补丁。对于某些类型的树（如-mm树），Quilt是最适合这项工作的工具。
邮件列表
-------------

大量的Linux内核开发工作是通过邮件列表完成的。如果不加入某个地方的一个列表，很难成为一名功能齐全的社区成员。但Linux邮件列表也可能给开发者带来潜在的风险，他们可能会被大量的电子邮件淹没，或者违反Linux列表上的惯例，甚至两者皆有。
大多数内核邮件列表托管在kernel.org；主列表可以在以下位置找到：

	https://subspace.kernel.org

也有在其他地方托管的列表；请查看MAINTAINERS文件以获取任何特定子系统的相关列表。
核心的内核开发邮件列表当然是 linux-kernel。这个列表可能让人感到压力巨大；邮件数量有时能达到每天 500 封，无关信息的比例很高，讨论可能会极其技术化，并且参与者并不总是注重保持高度的礼貌。但没有其他地方能让整个内核开发社区聚集在一起；避开这个列表的开发者会错过重要的信息。
以下是一些有助于在 linux-kernel 邮件列表中生存的小提示：

- 让该列表发送到一个单独的文件夹，而不是你的主邮箱。有时候你必须能够忽略这些邮件流一段时间。
- 不要试图跟踪每一个讨论——其他人也不会这么做。重要的是根据感兴趣的主题进行过滤（需要注意的是，长时间的讨论可能会偏离最初的题目，而电子邮件的主题行却没有更改），同时也考虑参与者的身份。
- 不要给那些故意挑起争端的人回应。如果有人试图激起激烈的反应，请忽略他们。
- 在回复 linux-kernel 的邮件（或其他列表）时，请保留所有相关人员的 Cc: 头部。除非有充分的理由（例如明确请求），否则你不应该删除收件人。确保你回复的人出现在 Cc: 列表中。这一惯例也使得没有必要明确要求将回复抄送给发帖者。
- 提问之前先搜索邮件列表归档（以及整个网络）。一些开发者可能会对明显没有做足功课的人失去耐心。
- 使用交错式（"内联"）回复，这样你的回复更容易阅读。（即避免顶部回复——把你的答案放在你回复的引用文本上方的做法。）更多细节，请参阅 :ref:`Documentation/process/submitting-patches.rst <interleaved_replies>`。
- 在正确的邮件列表上提问。虽然 linux-kernel 可能是一个通用的聚会点，但它并不是找到所有子系统开发者的最佳地点。
最后一点——找到正确的邮件列表——是新手开发者容易犯错的地方。向 linux-kernel 提出与网络相关的问题的人几乎肯定会得到建议，让他们转而在 netdev 列表上提出问题，因为大多数网络开发人员都在那里活动。还有其他列表专门针对 SCSI、video4linux、IDE、文件系统等子系统。查找邮件列表的最佳位置是在随内核源代码一起打包的 MAINTAINERS 文件中。
开始内核开发
-------------------------------

关于如何开始内核开发过程的问题很常见 —— 无论是来自个人还是公司。同样常见的是一些让这段关系的开始比必要时更艰难的错误步骤。公司通常希望聘请知名的开发者来启动一个开发团队。这实际上可能是一种有效的策略。但这也往往代价昂贵，并且对增加经验丰富的内核开发者数量帮助不大。如果投入一些时间，是可以让内部开发者熟悉Linux内核开发的。花这些时间可以使雇主拥有一组既了解内核又了解公司的开发者，并且他们还可以帮助培训其他人。从中期来看，这通常是更有利可图的方法。

对于个人开发者来说，常常不知道从何开始，这是可以理解的。从一个大型项目开始可能会让人感到害怕；人们通常希望先从小项目开始尝试。这就是一些开发者开始着手修复拼写错误或轻微编码风格问题的补丁的地方。不幸的是，这样的补丁产生了一种分散整个开发社区注意力的噪音水平，因此，它们越来越不被看好。希望通过这种方式向社区介绍自己的新开发者不会得到他们所期望的那种欢迎。

安德鲁·莫顿给有志于内核开发的人提供了以下建议：

:: 

    对所有内核初学者来说，首要任务肯定是“确保内核在你手头的所有机器上始终完美运行”。通常实现这一点的方式是与其他开发者合作解决问题（这可能需要持之以恒！），但这很好——这是内核开发的一部分。
(https://lwn.net/Articles/283982/)

如果没有明显的需要解决的问题，开发者被建议查看当前的退化列表和一般开放的错误列表。永远不会有缺少需要修复的问题；通过解决这些问题，开发者将获得经验，同时也会在其他开发社区中建立起尊重。
