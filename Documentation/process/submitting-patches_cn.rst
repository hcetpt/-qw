提交补丁：将你的代码纳入内核的核心指南
================================================================================

对于希望向 Linux 内核提交更改的个人或公司而言，如果你对“这套体系”不熟悉，这个过程有时可能会让人感到畏惧。本文档收集了一些建议，可以极大地提高你的更改被接受的可能性。本文件以相对简洁的形式包含了大量的建议。若想详细了解内核开发流程，请参阅 `Documentation/process/development-process.rst`。另外，请阅读 `Documentation/process/submit-checklist.rst` 中列出的在提交代码前需要检查的事项。对于设备树绑定补丁，请参阅 `Documentation/devicetree/bindings/submitting-patches.rst`。本文档假设你正在使用 `git` 来准备你的补丁。如果你还不熟悉 `git`，强烈建议你学习如何使用它，这将会大大简化你作为内核开发者的工作，也会使你的日常工作更加轻松。

一些子系统和维护者管理的仓库有额外的信息关于它们的工作流程和期望，请参考 `Documentation/process/maintainer-handbooks.rst <maintainer_handbooks_main>`。
获取最新的源码树
-----------------

如果你没有手头现成的最新内核源码库，可以使用 `git` 来获取一个。你应该从主线仓库开始，可以通过以下命令来克隆：

```bash
git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
```

然而，请注意，你可能并不希望直接基于主线树进行开发。大多数子系统的维护者都有他们自己的分支，并且希望看到针对这些分支准备的补丁。在 `MAINTAINERS` 文件中找到该子系统的 `T:` 条目以找到那个分支，或者如果该分支没有列在那里，可以直接询问维护者。
描述你的更改
-----------------

描述你面临的问题。无论你的补丁是一行的错误修复还是5000行的新功能，都应该有一个潜在的问题促使你进行这项工作。说服审阅者存在值得解决的问题，并且有理由继续阅读超过第一段的内容。

描述用户可见的影响。明显的崩溃和锁定是非常有说服力的，但并非所有的错误都如此明显。即使问题是在代码审查过程中发现的，也要描述你认为它可能对用户产生的影响。请记住，大多数 Linux 安装运行的是来自次要稳定分支或是厂商/产品特定分支的内核，这些分支仅从上游选择性地采纳某些补丁，因此包括任何有助于将你的更改引入下游的信息：触发情况、dmesg 的摘录、崩溃描述、性能退化、延迟峰值、锁定等。

量化优化和权衡。如果你声称提高了性能、内存消耗、栈空间大小或二进制文件大小，那么请提供支持这些说法的数据。但同时也请描述那些不那么显而易见的成本。优化通常不是免费的，而是涉及CPU、内存以及可读性之间的权衡；或者是当涉及到启发式方法时，在不同工作负载之间进行权衡。描述你的优化预期会带来的负面影响，以便审阅者能够权衡成本与收益。
一旦问题被确定，就需要从技术细节上描述你实际是如何处理这个问题的。重要的是要用通俗易懂的英语来描述这种变化，以便审查者可以验证代码是否按照你的意图运行。

如果你能以一种易于被拉入Linux的源代码管理系统“git”作为“提交日志”的形式来编写你的补丁说明，维护者会非常感谢你。请参阅 :ref:`标准补丁格式`

每个补丁只解决一个问题。如果你的描述开始变长，这可能意味着你需要将你的补丁拆分。请参阅 :ref:`拆分变更`

当你提交或重新提交一个补丁或补丁系列时，请包含完整的补丁描述及其理由。不要只是说这是第N个版本的补丁（系列）。不要期望子系统的维护者会回溯到早期的补丁版本或参考的URL来找寻补丁描述并将其放入补丁中。

也就是说，补丁（系列）及其描述应该是自包含的。这对维护者和审查者都有好处。一些审查者可能根本没有收到过早期版本的补丁。

用命令语气描述你的更改，例如“让xyzzy执行frotz”而不是“[这个补丁]让xyzzy执行frotz”或“[我]改变了xyzzy使其执行frotz”，就像你在给代码库下命令改变其行为一样。

如果你想引用一个特定的提交，请不要只引用该提交的SHA-1 ID。请同时包括提交的一行总结，这样可以让审查者更容易了解它的内容。

示例::

    提交e21d2170f36602ae2708 (“video: 删除不必要的 platform_set_drvdata()”) 删除了不必要的 platform_set_drvdata()，但留下了未使用的变量 "dev"，删除它。
你也应该确保至少使用SHA-1标识符的前十二个字符。内核仓库包含大量的对象，这使得较短的标识符发生冲突成为可能。请记住，即使现在你的六位字符标识符没有发生冲突，五年后这种情况也可能发生变化。
如果相关讨论或其他变更背景信息可以在网络上找到，请添加`Link:`标签指向这些信息。如果补丁是基于早期邮件列表讨论或网络上记录的内容产生的，请给出相应的链接。
当链接到邮件列表归档时，最好使用lore.kernel.org的消息归档服务。创建链接URL时，使用消息`Message-ID`头的内容，去掉周围的尖括号。
例如：

    Link: https://lore.kernel.org/30th.anniversary.repost@klaava.Helsinki.FI

请确认链接实际有效并指向相关的消息。
然而，尽量使你的解释在没有外部资源的情况下也能被理解。除了提供邮件列表归档或错误报告的URL外，还应总结导致提交该补丁的相关讨论的关键点。
如果你的补丁修复了一个错误，请使用`Closes:`标签，并附带一个链接引用邮件列表归档或公共错误追踪系统中的报告。例如：

    Closes: https://example.com/issues/1234

一些错误追踪系统能够在应用带有此类标签的提交时自动关闭问题。监控邮件列表的一些机器人也可以追踪这样的标签并采取某些行动。私人错误追踪系统和无效URL是不允许的。
如果你的补丁修复了某个特定提交中的错误，例如你使用`git bisect`发现了问题，请使用`Fixes:`标签，并附上SHA-1标识符的前十二个字符及一行总结。不要将标签分成多行，标签不受“在第75列换行”规则的约束，以便简化解析脚本。例如：

    Fixes: 54a4f0239f2e ("KVM: MMU: make kvm_mmu_zap_page() return the number of pages it actually freed")

可以使用以下`git config`设置来为`git log`或`git show`命令输出上述样式的漂亮格式：

    [core]
        abbrev = 12
    [pretty]
        fixes = Fixes: %h (\"%s\")
    
一个示例调用如下：

    $ git log -1 --pretty=fixes 54a4f0239f2e
    Fixes: 54a4f0239f2e ("KVM: MMU: make kvm_mmu_zap_page() return the number of pages it actually freed")

.. _split_changes:

分离你的更改
---------------------
将每个**逻辑上的更改**分隔成单独的补丁
例如，如果你的更改既包括单一驱动程序中的错误修复也包括性能增强，请将这些更改分成两个或更多的补丁。如果你的更改包括API更新以及使用这个新API的新驱动程序，请将它们分成两个补丁。
另一方面，如果你对多个文件进行了单一的更改，则将这些更改组合成一个补丁。这样，一个逻辑上的更改就被包含在一个补丁中。
要记住的是，每个补丁都应该实现一个容易理解且可以由审阅者验证的更改。每个补丁都应该凭其自身的优点来说服人。
如果一个补丁依赖于另一个补丁才能使更改完整，这是可以接受的。只需在你的补丁描述中注明**“此补丁依赖于X补丁”**。
当你将你的更改分割成一系列补丁时，请特别注意确保内核在该系列中的每个补丁之后都能正确构建和运行。使用`git bisect`来追踪问题的开发人员可能会在任何点上拆分你的补丁系列；如果你在中间引入了错误，他们不会感谢你。
如果你无法将你的补丁集精简为更小的一组补丁，则一次只发布大约15个左右，并等待审查和集成。
检查你的更改风格
------------------

检查你的补丁是否有基本的风格违规情况，详细信息可以在文档 `Documentation/process/coding-style.rst` 中找到。
未能这样做只会浪费审查者的时间，并且你的补丁很可能会被拒绝，甚至可能根本不会被阅读。
一个重要的例外是在将代码从一个文件移动到另一个文件时——在这种情况下，你不应在移动代码的同时在同一补丁中修改它。这清楚地划分了移动代码的行为和你的更改。这极大地有助于审查实际差异，并允许工具更好地跟踪代码本身的历史。
提交补丁前，请使用补丁风格检查器进行检查（scripts/checkpatch.pl）。但是请注意，风格检查器应被视为一种指导，而不是人类判断的替代品。如果你的代码看起来违反了规则但视觉效果更好，那么可能最好保持原样。
检查器报告分为三个级别：
- 错误：非常可能是错误的情况
- 警告：需要仔细审查的情况
- 检查：需要思考的情况

你应该能够为你补丁中保留的所有违规行为提供合理的解释。
选择你的补丁接收者
---------------------

对于你维护的代码的任何补丁，你应该始终抄送适当的子系统维护者及相关列表；查看MAINTAINERS文件和源代码修订历史以确定这些维护者是谁。在这个步骤中，脚本 scripts/get_maintainer.pl 可能会非常有用（将补丁路径作为参数传递给 scripts/get_maintainer.pl）。如果你找不到负责你正在工作的子系统的维护者，Andrew Morton (akpm@linux-foundation.org) 可以作为最后的维护者。
默认情况下，所有补丁都应发送至 linux-kernel@vger.kernel.org，但由于该列表的邮件量很大，导致一些开发人员不再关注它。请不要向无关的列表和无关的人发送垃圾邮件。
许多与内核相关的邮件列表都托管在 kernel.org；你可以在这个网址找到它们的列表：https://subspace.kernel.org。也有一些与内核相关的邮件列表托管在其他地方，
但林纳斯·托瓦兹（Linus Torvalds）是所有被接受到 Linux 内核变更的最终仲裁者。他的电子邮件地址是 <torvalds@linux-foundation.org>。
他收到了大量的邮件，而且现在很少有补丁直接通过 Linus，因此通常你应该尽量避免给他发送邮件。
如果你有一个修复可利用安全漏洞的补丁，请将该补丁发送至 security@kernel.org。对于严重的漏洞，可能会考虑短暂的保密期以允许分发者将补丁提供给用户；在这种情况下，
显然不应该将补丁发送到任何公开的列表中。更多信息请参阅 Documentation/process/security-bugs.rst
如果补丁修复了已发布内核中的严重漏洞，则应将其发送给稳定维护者，在你的补丁签名区域加入如下行：

  Cc: stable@vger.kernel.org

（注意，这不是电子邮件接收者的地址）。你还应该阅读 Documentation/process/stable-kernel-rules.rst，除了本文档之外。
如果变更影响了用户空间-内核接口，请向 MAN-PAGES 维护者（如 MAINTAINERS 文件中所列）发送 man-pages 补丁，或者至少通知他们有关变更的情况，以便相关信息可以被添加到手册页中。用户空间 API 的变更也应该抄送给 linux-api@vger.kernel.org
不要使用 MIME、链接、压缩或附件，只使用纯文本。

----------------------------------------------

林纳斯和其他内核开发者需要能够阅读并评论你提交的变更。对一个内核开发者来说，使用标准的电子邮件工具“引用”你的变更非常重要，这样他们就可以对你代码的具体部分进行评论。
因此，所有的补丁都应该作为电子邮件正文内联提交。最简单的方法是使用 `git send-email`，这强烈推荐。`git send-email` 的交互式教程可以在 https://git-send-email.io 找到。
如果你选择不使用 `git send-email`：

.. warning::
  
  如果你选择剪切和粘贴你的补丁，请小心编辑器的文字换行功能可能会破坏你的补丁。
不要将补丁作为 MIME 附件（无论是否压缩）附加。
许多流行的电子邮件应用程序并不会总是以纯文本的形式传输MIME附件，这使得我们无法对你的代码进行评论。MIME附件也会让Linus处理起来花费更多的时间，从而降低了你的MIME附件更改被接受的可能性。
例外：如果你的邮件客户端在处理补丁时存在问题，可能会有人要求你使用MIME重新发送。
请参阅 `Documentation/process/email-clients.rst` 中关于如何配置电子邮件客户端以便它能原封不动地发送你的补丁的提示。
回应评审意见
--------------------------

你的补丁几乎肯定会收到评审者的反馈，这些反馈通常是以对你邮件的回复形式出现，指出补丁可以改进的地方。你必须对这些反馈做出回应；忽视评审者是让你自己也被忽视的好方法。你可以直接回复他们的邮件来解答他们的问题。对于那些不涉及代码变更但有助于下一位评审者更好地理解情况的评审意见或问题，应当尽可能地添加注释或变更日志条目。
一定要告诉评审者你所做的修改，并感谢他们投入的时间。代码评审是一项既耗时又累人的工作，评审者有时会变得有些烦躁。即便如此，在回应时也要保持礼貌并解决他们提出的问题。在发送新版本时，应在邮件正文或单个补丁中添加“补丁变更日志”，说明与前一版本的差异（参见 :ref:`the_canonical_patch_format`）。
通过将之前评论过你补丁的人添加到补丁的抄送列表中来通知他们有关新版本的信息。
请参阅 `Documentation/process/email-clients.rst` 中关于推荐使用的电子邮件客户端和邮件列表礼仪的建议。
.. _interleaved_replies:

在邮件讨论中使用精简的交错回复
----------------------------------------------------
在Linux内核开发讨论中，顶部回复（Top-posting）是被强烈反对的做法。交错回复（也称为“内联”回复）能让对话更容易追踪。更多细节请参阅：https://en.wikipedia.org/wiki/Posting_style#Interleaved_style

正如邮件列表中经常引用的例子所示::

  A: http://en.wikipedia.org/wiki/Top_post
  Q: 我在哪里能找到关于顶部回复的信息？
  A: 因为它打乱了人们通常阅读文本的顺序
Q: 为什么顶部回复是一件坏事？
  A: 顶部回复
Q: 电子邮件中最让人恼火的事情是什么？

同样，请删除所有与你的回复无关的多余引用。这样可以让回复更易于查找，并节省时间和空间。更多详情请参阅：http://daringfireball.net/2007/07/on_top ::

  A: No
问：我在回复后应该附上引号吗？

.. _重发提醒:

不要气馁——也不要急躁
------------------------

提交你的更改后，请耐心等待。评审人员很忙，可能不会立即处理你的补丁。
曾经，补丁可能会无声无息地消失，但现在开发流程比那时更顺畅了。你应该在几周内（通常2到3周）收到评论；如果没有发生这种情况，请确保你已将补丁发送到了正确的地方。至少等待一周再重新提交或提醒评审人——在合并窗口这样的繁忙时期，可能需要等待更长时间。
在几周后也可以重新发送补丁或补丁系列，并在主题行中加上“RESEND”字样：

   [PATCH Vx RESEND] sub/sys: 简化的补丁摘要

当你提交修改后的补丁或补丁系列时，不要添加“RESEND”——“RESEND”仅适用于重新提交完全未作任何修改的补丁或补丁系列。
在主题中包含“PATCH”
------------------------------

由于Linus和linux-kernel邮件列表中的邮件流量很高，通常的做法是在主题行前加上[PATCH]。这样可以让Linus和其他内核开发者更容易地区分补丁和其他邮件讨论。
`git send-email`会自动为你完成这个操作。
签署你的工作——开发者的起源证书
------------------------------------------------------

为了更好地追踪谁做了什么，特别是对于那些可能通过多层维护者流转最终进入内核的补丁，我们引入了一种电子邮件传输补丁的“签名”程序。
签名是一段简单的文字，放在补丁解释的末尾，用来证明你是该补丁的作者，或者你有权将其作为开源补丁进行传播。规则相当简单：如果你可以保证以下内容：

开发者起源证书 1.1
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

通过向本项目做出贡献，我保证：

        (a) 该贡献由我全部或部分创建，并且我有权根据文件中指定的开源许可提交它；或

        (b) 该贡献基于之前的工作，据我所知，这些工作受到适当的开源许可保护，并且我有权根据该许可提交这项工作及其修改，无论这些修改是由我全部还是部分创建的（除非我被允许使用不同的许可），如文件中所示；或

        (c) 该贡献直接由其他人提供给我，此人已认证(a)，(b) 或 (c)，并且我没有对其进行修改；
(d) 我理解并同意本项目及贡献是公开的，并且贡献记录（包括我提交的所有个人信息，包括我的签名）将永久保存，并可按照本项目或涉及的开源许可进行重新分发
那么你只需添加一行文字表示：

	签署者：Random J Developer <random@developer.example.org>

使用已知的身份（抱歉，不接受匿名贡献）。
如果你使用`git commit -s`，这将自动为你完成。
### 翻译成中文：

#### 回退操作也应包含 "Signed-off-by"。`git revert -s` 会为你自动添加这一点。
有些人还在末尾添加额外的标签。目前这些标签会被忽略，但你可以这样做来标记公司内部的流程或仅仅指出关于批准的一些特殊细节。

任何在作者的 "Signed-off-by" 之后的进一步的 "Signed-off-by" 标签都是由处理和传递补丁的人添加的，但他们并未参与补丁的开发。"Signed-off-by" 链应当反映补丁传播到维护者并最终到达 Linus 的 **真实** 路径，其中第一个 "Signed-off-by" 条目标志着单一作者的主要创作权。

#### 何时使用 Acked-by:、Cc: 和 Co-developed-by：
--------------------------------------------------

"Signed-off-by:" 标签表明签署者参与了补丁的开发，或者他/她处于补丁的传递路径中。

如果某人并未直接参与补丁的准备或处理，但希望表明并记录他们对该补丁的认可，则可以要求在补丁的日志中添加 "Acked-by:" 行。

"Acked-by:" 常被受补丁影响代码的维护者使用，当该维护者既未贡献也未转发该补丁时。

"Acked-by:" 不像 "Signed-off-by:" 那样正式。它记录了认可者至少审查了补丁并表示接受。因此，补丁合并者有时会手动将认可者的 "是的，看起来不错" 转换为 "Acked-by:"（但请注意，通常最好直接请求明确的认可）。

"Acked-by:" 并不一定意味着对整个补丁的认可。

例如，如果一个补丁影响了多个子系统，并且有一个来自某个子系统维护者的 "Acked-by:"，那么这通常只表示对该维护者代码部分的认可。这里需要进行判断。

当有疑问时，人们应参考邮件列表归档中的原始讨论。
如果一个人有机会对某个补丁发表评论，但没有提供这样的评论，你可以选择性地在该补丁上添加一个“Cc:”标签。
这是唯一一个可以在被标注的人没有明确行动的情况下添加的标签——但它应该表明这个人已经收到了该补丁的副本。此标签记录了潜在感兴趣的各方已经被纳入讨论中。

共同开发-by: 表明该补丁是由多名开发者共同创建的；它用于向共同作者（除了通过 From: 标签归功的作者）给予认可，当几个人合作完成一个补丁时使用。由于共同开发-by: 指示作者身份，因此每个共同开发-by: 必须立即跟上相关共同作者的已签名-by:。标准的签名流程适用，即已签名-by: 标签的顺序应尽可能反映补丁的历史时间线，无论作者是通过 From: 还是共同开发-by: 归功。值得注意的是，最后一个已签名-by: 必须始终是提交该补丁的开发者的签名。

请注意，当 From: 作者也是电子邮件头部 From: 行中列出的同一人（和邮箱地址）时，From: 标签是可选的。

共同作者提交补丁的例子：

	<变更日志>

	共同开发-by: 第一共同作者 <first@coauthor.example.org>
	已签名-by: 第一共同作者 <first@coauthor.example.org>
	共同开发-by: 第二共同作者 <second@coauthor.example.org>
	已签名-by: 第二共同作者 <second@coauthor.example.org>
	已签名-by: 主要作者 <from@author.example.org>

共同开发作者提交补丁的例子：

	主要作者: 主要作者 <from@author.example.org>

	<变更日志>

	共同开发-by: 随机共同作者 <random@coauthor.example.org>
	已签名-by: 随机共同作者 <random@coauthor.example.org>
	已签名-by: 主要作者 <from@author.example.org>
	共同开发-by: 提交共同作者 <sub@coauthor.example.org>
	已签名-by: 提交共同作者 <sub@coauthor.example.org>

使用 Reported-by:、Tested-by:、Reviewed-by:、Suggested-by: 和 Fixes:

Reported-by 标签是为了表彰那些发现并报告错误的人，并希望这能激励他们在未来继续帮助我们。该标签适用于错误；请不要将其用于表彰功能请求。该标签后面应跟上指向报告的 Closes: 标签，除非该报告不在网络上公开。如果补丁只解决了报告中的部分问题，则可以使用 Link: 标签代替 Closes:。请注意，如果错误是在私下报告的，在使用 Reported-by 标签之前，请先征得许可。

Tested-by: 标签表明该补丁已经被所命名的人在某种环境下成功测试过。此标签告知维护者已经进行了一些测试，提供了定位未来补丁测试者的手段，并确保了对测试者的认可。

而 Reviewed-by: 表明该补丁经过审查并被认为可以接受，符合审查员的声明：

审查员的监督声明

通过提供我的 Reviewed-by: 标签，我声明：

	(a) 我已经对该补丁进行了技术审查，以评估其适当性和准备情况，是否适合纳入主线内核
	(b) 与该补丁相关的任何问题、疑虑或疑问都已反馈给提交者。我对提交者对我意见的回复感到满意
	(c) 尽管这个提交可能还有改进的地方，但我认为它目前是（1）对内核有价值的修改，并且（2）没有已知的问题会反对将其纳入
	(d) 虽然我已经审查了该补丁并且相信它是可靠的，但除非另有明确说明，否则我不对此补丁将在任何给定情况下实现其声明目的或正常运行做出任何保证或担保
审阅标签（Reviewed-by）表示对补丁的看法，认为它是对内核的适当修改，并且没有遗留严重的技术问题。任何感兴趣的审阅者（已经完成这项工作的人）都可以为补丁提供一个“已审阅”标签。这个标签既用于表彰审阅者，也向维护者表明该补丁经过了多大程度的审查。当由熟知该领域并进行彻底审查的审阅者提供的“已审阅”标签通常会增加你的补丁被纳入内核的可能性。
一旦在邮件列表中从测试者或审阅者处收到“已测试”和“已审阅”标签，作者在发送下一个版本时应将这些标签添加到相应的补丁中。但是，如果补丁在后续版本中发生了重大变化，这些标签可能不再适用，因此应将其删除。
通常，移除某人的“已测试”或“已审阅”标签应在补丁变更日志中提及（在“---”分隔符之后）。
“建议者”标签表明补丁的想法是由所列人员提出的，并确保该想法的提出者得到认可。请注意，未经报告者的许可不应添加此标签，特别是当这个想法并非公开发布的情况下。话虽如此，如果我们认真地给予想法提出者以认可，他们将来可能会受到鼓舞再次帮助我们。
“修复”标签表明该补丁修复了之前提交中的一个问题。它被用来方便确定错误的起源，这有助于审核修复补丁。此标签还帮助稳定内核团队判断哪些稳定内核版本应该接受您的修复。这是指示补丁所修复的bug的首选方法。更多详情请参见 :ref:`describe_changes`。
注意：附加“修复”标签并不会绕过稳定内核规则流程，也不能免除所有稳定补丁候选都必须抄送至 stable@vger.kernel.org 的要求。更多信息，请阅读 Documentation/process/stable-kernel-rules.rst。
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
**标准的补丁格式**

本节描述了补丁本身应该如何格式化。请注意，如果你将补丁存储在一个 `git` 仓库中，可以使用 `git format-patch` 来获得正确的补丁格式。然而，工具无法创建必要的文本内容，所以请继续阅读以下说明。
标准的补丁主题行格式如下所示：

    主题: [PATCH 001/123] 子系统: 概要描述

标准的补丁消息正文包含以下内容：

  - 一条“发件人”行，指定补丁作者，后跟一个空行（仅当发送补丁的人不是作者时需要）
- 解释性正文，每行不超过75个字符，这部分内容将被复制到永久变更日志中以描述此补丁
- 一个空行
- 上文描述的 `Signed-off-by:` 行，这些行也会被加入到变更日志中。
- 一个仅包含 `---` 的标记行。
- 任何不适合放入变更日志的额外评论。
- 实际的补丁（`diff` 输出）。

主题行的格式使得按照主题行对邮件进行字母排序变得非常容易——几乎所有的邮件阅读器都支持这种功能——这是因为序列号是用零填充的，因此数值和字母排序是相同的。

邮件的主题中的 `子系统` 应该标识出内核中被修补的部分或子系统。

邮件的主题中的 `简要说明` 应该简洁地描述该邮件所含的补丁。`简要说明` 不应该是一个文件名。不要为整个补丁系列中的每个补丁使用相同的 `简要说明`（一个“补丁系列”是指一系列有序的、相关的补丁）。

请记住，你的邮件的 `简要说明` 成为了该补丁的全球唯一标识符。它会一直传播到 `git` 的变更日志中。`简要说明` 可能会在后续开发者讨论中被引用，讨论与该补丁相关的内容。人们可能想要通过谷歌搜索 `简要说明` 来阅读关于该补丁的讨论。当两三个月后，他们使用如 `gitk` 或 `git log --oneline` 这样的工具浏览可能成千上万的补丁时，这也将是他们快速看到的唯一内容。

基于以上原因，`简要说明` 必须不超过 70-75 个字符，并且必须描述补丁改变了什么，以及为什么这个补丁可能是必要的。既要简洁又要描述全面是很具挑战性的，但这就是一个好的总结应当做到的。

`简要说明` 前面可以加上方括号内的标签：“Subject: [PATCH <tag>...] <简要说明>”。这些标签不被视为 `简要说明` 的一部分，但是它们描述了如何处理这个补丁。常见的标签可能包括版本描述符，如果针对反馈发送了多个版本的补丁（例如，“v1, v2, v3”），或者 “RFC” 来表示请求评论。
如果一系列补丁中共有四个补丁，各个补丁可以这样编号：1/4、2/4、3/4、4/4。这样做可以确保开发者理解这些补丁应该按什么顺序应用，并且他们已经审查或应用了该系列中的所有补丁。
以下是一些良好的主题示例：

    主题: [PATCH 2/5] ext2: 提升位图搜索的可扩展性
    主题: [PATCH v2 01/27] x86: 修正eflags追踪问题
    主题: [PATCH v2] sub/sys: 简化后的补丁概要
    主题: [PATCH v2 M/N] sub/sys: 简化后的补丁概要

“From”行必须是消息正文的第一行，其格式为：

        From: 补丁作者 <author@example.com>

“From”行指定了在永久变更日志中将被记录为补丁作者的人。如果缺少“From”行，则会使用电子邮件头部中的“From:”行来确定变更日志中的补丁作者。
解释性正文将被提交到永久源代码变更日志中，因此应该让有能力的读者即使忘记了可能导致此补丁讨论的具体细节也能理解。包括补丁所解决故障的症状（如内核日志消息、oops消息等）对于那些可能在查找适用补丁时搜索提交日志的人来说尤其有用。文字应写得足够详细，以便几周、几个月甚至几年后阅读时，仍能给读者提供所需的信息来理解为什么创建了这个补丁。
如果一个补丁修复了一个编译错误，可能不需要包含所有的编译失败信息；只需包含足够的信息，以便有可能在搜索补丁时找到它。与“简短描述语句”一样，重要的是既要简洁又要具有描述性。
“---”标记行的主要作用是为补丁处理工具标记变更日志消息的结束位置。
在“---”标记之后的附加注释的一个良好用途是“diffstat”，以显示哪些文件发生了变化以及每份文件中插入和删除的行数。“diffstat”对于较大的补丁特别有用。如果您要在“---”标记后包含“diffstat”，请使用选项`-p 1 -w 70`，以便文件名从内核源代码树的顶部列出，不会占用太多水平空间（轻松地适应80列，也许带有一些缩进）。(``git``默认生成适当的diffstat)。

其他仅适用于当下或维护者而不适合永久变更日志的相关注释也应该放在这里。此类注释的一个好例子可能是“补丁变更日志”，它们描述了从v1版本到v2版本之间补丁的变化。
请将这些信息放在“---”分隔线**之后**。版本信息不是提交到git树中的变更日志的一部分。这是供审阅者的额外信息。如果将其放在提交标签之上，则需要手动交互来移除它。如果位于分隔线之下，则在应用补丁时会被自动移除：

  <提交消息>
  ..
Signed-off-by: 作者 <author@mail>
  ---
  V2 -> V3: 删除冗余的帮助函数
  V1 -> V2: 清理编码风格并解决了评审意见

  路径/至/文件 | 5+++--
  ..
更多关于正确补丁格式的详细信息，请参阅以下参考文献：
.. _backtraces:

提交消息中的回溯
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

回溯有助于记录导致问题的调用链。然而，并非所有回溯都有帮助。例如，早期启动时的调用链是独特的并且显而易见的。然而，逐字复制完整的dmesg输出会添加诸如时间戳、模块列表、寄存器和堆栈转储等分散注意力的信息。
因此，最有用的回溯应该从转储中提炼出相关信息，这样更容易聚焦于真正的问题所在。下面是一个经过恰当裁剪的回溯示例：

  未检查的MSR访问错误：向0xd51写入WRMSR（尝试写入0x0000000000000064）
  在rIP: 0xffffffffae059994 (native_write_msr+0x4/0x20)
  调用追踪：
  mba_wrmsr
  update_domains
  rdtgroup_mkdir

.. _明确回复至:

明确的In-Reply-To头
----------------------

在补丁中手动添加In-Reply-To:头（例如，在使用`git send-email`时）有助于将补丁与之前的讨论相关联，例如，将bug修复链接到包含bug报告的邮件。但是，对于多补丁系列，通常最好避免使用In-Reply-To:来链接到该系列的旧版本。这样可以防止多个补丁版本在邮件客户端中形成难以管理的引用森林。如果需要提供链接，你可以使用https://lore.kernel.org/重定向器（例如，在封面邮件文本中）来链接到补丁系列的早期版本。

提供基树信息
-------------------

当其他开发者收到你的补丁并开始审查过程时，他们必须知道你的工作基于哪个基本提交/分支，考虑到当前存在的大量维护者树。再次注意上面解释的MAINTAINERS文件中的**T:**条目。
这对于自动化CI流程尤其重要，这些流程试图运行一系列测试以评估你的提交质量，然后再由维护者开始审查。
如果你使用`git format-patch`来生成你的补丁，你可以通过使用`--base`标志自动在提交中包含基树信息。最简单且最方便的方法是使用专题分支：

    $ git checkout -t -b my-topical-branch master
    分支 'my-topical-branch' 设置为跟踪本地分支 'master'
已切换到新分支 'my-topical-branch'

    [执行你的编辑和提交]

    $ git format-patch --base=auto --cover-letter -o outgoing/ master
    outgoing/0000-cover-letter.patch
    outgoing/0001-First-Commit.patch
    outgoing/..
当你打开`outgoing/0000-cover-letter.patch`进行编辑时，你会注意到它将在底部有`base-commit:`尾注，这为审阅者和CI工具提供了足够的信息，以便正确地执行`git am`而无需担心冲突：

    $ git checkout -b patch-review [base-commit-id]
    已切换到新分支 'patch-review'
    $ git am patches.mbox
    应用：First Commit
    应用：..
请参阅`man git-format-patch`获取有关此选项的更多信息。
.. note::

    `--base`功能是在git版本2.9.0中引入的。
如果你不使用git来格式化你的补丁，你仍然可以包含相同的`base-commit`尾注，以指示你的工作基于的树的提交哈希值。你应该将其添加到封面信或补丁系列的第一个补丁中，并且应该放置在`---`行下方或所有其他内容的最底部，紧接在你的电子邮件签名之前。
确保基提交位于官方维护者/主线树中，而不是某些仅对你可访问的内部树中——否则它将毫无价值。
参考文献
----------

安德鲁·莫顿, “完美的补丁” (tpp) 
<https://www.ozlabs.org/~akpm/stuff/tpp.txt>

杰夫·加尔齐克, “Linux 内核补丁提交格式”
<https://web.archive.org/web/20180829112450/http://linux.yyz.us/patch-format.html>

格雷格·克罗亚-哈特曼, “如何惹恼内核子系统维护者”
<http://www.kroah.com/log/linux/maintainer.html>

  <http://www.kroah.com/log/linux/maintainer-02.html>

  <http://www.kroah.com/log/linux/maintainer-03.html>

  <http://www.kroah.com/log/linux/maintainer-04.html>

  <http://www.kroah.com/log/linux/maintainer-05.html>

  <http://www.kroah.com/log/linux/maintainer-06.html>

内核文档/process/coding-style.rst

林纳斯·托瓦兹关于标准补丁格式的邮件:
  <https://lore.kernel.org/r/Pine.LNX.4.58.0504071023190.28951@ppc970.osdl.org>

安迪·克莱恩, “关于提交内核补丁”
  一些策略以提交困难或有争议的更改
<http://halobates.de/on-submitting-patches.pdf>
