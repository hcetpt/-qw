提交补丁：将你的代码纳入内核的核心指南
================================================================================

对于希望向 Linux 内核提交更改的个人或公司而言，如果你对“整个体系”不熟悉，这个过程有时可能会令人望而生畏。本文档汇集了一系列建议，可以极大地提高你的更改被接受的可能性。本文档包含大量以相对紧凑格式呈现的建议。若想详细了解内核开发流程的工作方式，请参阅 `Documentation/process/development-process.rst`。此外，请阅读 `Documentation/process/submit-checklist.rst`，其中列出了提交代码前需要检查的项目列表。对于设备树绑定补丁，请参阅 `Documentation/devicetree/bindings/submitting-patches.rst`。本文档假设你正在使用 `git` 来准备你的补丁。如果你对 `git` 不熟悉，最好学习如何使用它，这将使你作为内核开发者的生活更加轻松。

一些子系统和维护者仓库有额外的信息来描述他们的工作流程和期望，请参阅 `Documentation/process/maintainer-handbooks.rst <maintainer_handbooks_main>`。
获取当前源码树
-----------------

如果你没有现成的包含当前内核源码的仓库，可以使用 `git` 来获取一个。你应该从主线仓库开始，可以通过以下命令抓取：

```bash
git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
```

然而，请注意，你可能并不想直接基于主线树进行开发。大多数子系统的维护者都有自己的仓库，并希望看到针对这些仓库准备的补丁。在 `MAINTAINERS` 文件中查找子系统的 **T:** 条目来找到该仓库，或者如果仓库没有在那里列出，可以直接询问维护者。

描述你的更改
------------------

描述你的问题。无论是单行的bug修复还是5000行的新特性，背后都必须有一个促使你进行这项工作的根本问题。说服评审者确实存在值得解决的问题，并且让他们觉得有必要继续阅读下去。

描述用户可见的影响。显而易见的崩溃和锁定情况是很有说服力的，但并非所有bug都是如此明显。即使问题是通过代码审查发现的，也请描述你认为这个问题对用户可能产生的影响。请记住，大多数Linux安装运行的是从次要稳定分支或是特定供应商/产品树中挑选部分上游补丁的内核，因此包括任何有助于将你的更改传递到下游的信息：触发条件、dmesg摘录、崩溃描述、性能退化、延迟峰值、锁定等。

量化优化与权衡。如果你声称在性能、内存消耗、栈空间或二进制文件大小方面有所改进，请提供支持这些说法的数据。但是也要描述那些不那么明显的成本。优化通常不是免费的，而是CPU、内存以及可读性之间的权衡；当涉及到启发式方法时，则是在不同工作负载之间的权衡。描述你优化的预期缺点，以便评审者能够权衡成本与收益。
一旦问题被确定，用技术细节描述你实际正在如何解决它。用简单的英语描述改变对于评审者验证代码是否按你的意图运行至关重要。

如果你以一种容易被拉入Linux的源代码管理系统，“git”，作为“提交日志”的形式来撰写补丁说明，维护者会感谢你。参见：:ref:`标准补丁格式`

每个补丁只解决一个问题。如果你的描述开始变长，那是一个信号，表明你可能需要将你的补丁拆分。参见：:ref:`拆分更改`

当你提交或重新提交一个补丁或补丁系列时，包括完整的补丁描述和理由。不要仅仅说这是第N版的补丁（系列）。不要指望子系统维护者会回溯到早期的补丁版本或引用的URL来查找补丁描述，并将其放入补丁中。

也就是说，补丁（系列）及其描述应该是自包含的。这有益于维护者和评审者。一些评审者可能甚至没有收到过早前版本的补丁。

以命令语气描述你的更改，例如，“让xyzzy执行frotz”而不是“[这个补丁]让xyzzy执行frotz”或“[我]改变了xyzzy让它执行frotz”，就像你在给代码库下达改变其行为的命令。

如果你想引用一个特定的提交，请不要只引用提交的SHA-1 ID。请也包括提交的一行总结，以便评审者更容易了解它是关于什么的。

示例::

    提交e21d2170f36602ae2708("视频：移除不必要的platform_set_drvdata()")移除了不必要的platform_set_drvdata()，但留下了未使用的变量"dev"，删除它。
你也应该确保至少使用SHA-1标识符的前十二个字符。内核仓库包含大量的对象，这使得较短的标识符发生冲突成为可能。请记住，即使现在你的六位字符标识符没有发生冲突，这种情况也可能在五年后发生变化。
如果相关讨论或变更背后的任何其他背景信息可以在网络上找到，请添加“链接:”标签指向它们。如果补丁是基于早期邮件列表讨论的结果或是网络上已记录的内容，请给出指向这些内容的链接。
当链接到邮件列表归档时，最好使用lore.kernel.org的消息归档服务。要创建链接URL，请使用消息“Message-ID”头的内容，去掉周围的尖括号。
例如：

    链接: https://lore.kernel.org/30th.anniversary.repost@klaava.Helsinki.FI

请检查链接以确保它确实有效并指向相关的消息。
然而，尽量让你的解释不依赖外部资源也能理解。除了提供邮件列表存档或错误报告的网址外，还应总结导致提交此补丁的相关讨论的主要观点。
如果你的补丁修复了一个错误，请使用“关闭:”标签，并附上一个链接，指向邮件列表存档或公共错误跟踪系统中的报告。例如：

    关闭: https://example.com/issues/1234

一些错误跟踪系统有能力在应用带有此类标签的提交时自动关闭问题。一些监控邮件列表的机器人也可以追踪这些标签并采取某些行动。禁止使用私人错误跟踪系统和无效的URL。
如果你的补丁修复了某个特定提交中的错误，例如你使用`git bisect`发现了问题，请使用“修复:”标签加上SHA-1标识符的前十二个字符以及一行摘要。不要将标签跨多行分开，标签不受“在第75列换行”规则的限制，以便简化解析脚本。例如：

    修复: 54a4f0239f2e ("KVM: MMU: 让kvm_mmu_zap_page()返回其实际释放的页数")

可以使用以下`git config`设置为在`git log`或`git show`命令中输出上述样式的漂亮格式：

    [核心]
        缩写 = 12
    [格式]
        修复 = 修复: %h (\"%s\")
    
一个示例调用：

    $ git log -1 --pretty=修复 54a4f0239f2e
    修复: 54a4f0239f2e ("KVM: MMU: 让kvm_mmu_zap_page()返回其实际释放的页数")

.. _分离变更:

分离你的变更
---------------------
将每个**逻辑上的变更**分别放入一个单独的补丁中。
例如，如果你的变更同时包含了针对单一驱动程序的错误修复和性能增强，请将这些变更分成两个或更多的补丁。如果你的变更包括API更新和使用该新API的新驱动程序，请将这些变更分成两个补丁。
另一方面，如果你对多个文件做了单一的变更，则将这些变更组合成一个补丁。因此，单一逻辑变更应包含在一个单独的补丁中。
需要注意的是，每个补丁都应该是一个容易理解且可以由审阅者验证的变更。每个补丁都应以其自身的优势来证明其合理性。
如果一个补丁依赖于另一个补丁才能使更改完整，这是可以接受的。只需在你的补丁描述中注明**“此补丁依赖于X补丁”**。
当你将你的更改分割成一系列补丁时，请特别注意确保内核在该系列中的每个补丁之后都能正确构建和运行。使用`git bisect`来追踪问题的开发人员可能会在任何点上拆分你的补丁系列；如果你在中间引入了错误，他们不会感谢你。
如果你无法将你的补丁集精简为更小的一组补丁，则一次只发布大约15个左右，并等待审查和集成。
检查你的更改风格
------------------

检查你的补丁是否有基本的风格违规情况，详细信息可以在文档 `Documentation/process/coding-style.rst` 中找到。
未能这样做只会浪费审查者的时间，并且你的补丁可能会被拒绝，可能甚至都不会被阅读。

一个显著的例外是在将代码从一个文件移动到另一个文件时——在这种情况下，你不应该在同一补丁中修改被移动的代码。这清楚地划分了代码移动的行为和你的更改。这极大地有助于对实际差异的审查，并允许工具更好地跟踪代码本身的历史。

提交前使用补丁风格检查器检查你的补丁（scripts/checkpatch.pl）。但是请注意，风格检查器应被视为一种指导，而不是人类判断的替代品。如果你的代码看起来违反规则但更美观，则可能最好保持原样。

检查器报告分为三个级别：
- 错误：非常可能是错误的地方
- 警告：需要仔细审查的地方
- 检查：需要思考的地方

你应该能够为你的补丁中保留的所有违规行为提供合理的解释。
选择你的补丁接收者
--------------------

对于你维护的代码，你应该始终将适当的子系统维护者和列表抄送给任何补丁；查看MAINTAINERS文件和源代码修订历史以了解这些维护者是谁。在此步骤中，脚本 `scripts/get_maintainer.pl` 可能非常有用（将补丁路径作为参数传递给 `scripts/get_maintainer.pl`）。如果你找不到你正在工作的子系统的维护者，Andrew Morton (akpm@linux-foundation.org) 可以作为最后的维护者。

默认情况下，所有补丁都应发送至 `linux-kernel@vger.kernel.org`，但由于该列表的邮件量很大，一些开发者已经不再关注它。请不要向无关的列表和无关的人发送垃圾邮件。
许多与内核相关的邮件列表都托管在 kernel.org；你可以在这里找到它们的列表：https://subspace.kernel.org。也有一些与内核相关的邮件列表托管在其他地方，不过
Linus Torvalds 是所有被接受到 Linux 内核中的更改的最终仲裁者。他的电子邮件地址是 <torvalds@linux-foundation.org>。
他收到很多邮件，而且现在很少有补丁直接通过 Linus，因此通常你应该尽量避免给他发送邮件。
如果你有一个可以修复可利用的安全漏洞的补丁，请将该补丁发送给 security@kernel.org。对于严重的漏洞，可能会短暂地保密处理以便让发行版能够将补丁分发给用户；在这种情况下，
显然不应该将补丁发送到任何公开的邮件列表。更多信息请参阅
Documentation/process/security-bugs.rst
修复已发布内核中严重漏洞的补丁应当指向稳定维护者，方法是在你的补丁签名区域添加这样一行：

  Cc: stable@vger.kernel.org

（注意，这不是邮件接收人）。你也应该阅读 Documentation/process/stable-kernel-rules.rst
除了本文档之外。
如果变更影响了用户空间-内核接口，请向 MAN-PAGES 维护者（如 MAINTAINERS 文件中所列）发送 man-pages 补丁，或者至少通知他们有关变更，以便相关信息能够被写入手册页。用户空间 API 的变更也应该抄送给
linux-api@vger.kernel.org
不要使用 MIME、不要包含链接、不要压缩、不要附加文件。只使用纯文本。

---

Linus 和其他内核开发者需要能够阅读并评论你提交的更改。对于内核开发者来说，使用标准的电子邮件工具“引用”你的更改是非常重要的，这样他们就可以对你代码的具体部分进行评论。
因此，所有的补丁都应该以邮件内联的方式提交。最简单的方法是使用 `git send-email`，这被强烈推荐。一个关于 `git send-email` 的交互式教程可以在
https://git-send-email.io 找到。
如果你选择不使用 `git send-email`：

.. warning::
  
  如果你选择复制粘贴你的补丁，请小心你的编辑器的自动换行功能可能会破坏你的补丁。
不要将补丁作为 MIME 附件（无论是否压缩）附上。
许多流行的电子邮件应用程序并不总是将MIME附件作为纯文本传输，这使得无法对你的代码进行评论。MIME附件也使Linus处理起来花费更多时间，降低了你的MIME附件更改被接受的可能性。
例外：如果你的邮件客户端在处理补丁时出现问题，可能会有人要求你使用MIME重新发送它们。
请参阅Documentation/process/email-clients.rst，获取有关如何配置电子邮件客户端以确保它原样发送你的补丁的提示。
回应评审意见
--------------

你的补丁几乎肯定会收到评审人员关于如何改进补丁的评论，形式为对你电子邮件的回复。你必须回应这些评论；忽略评审人员是让自己被忽视的好方法。你可以简单地回复他们的电子邮件来回答他们的评论。即使没有导致代码变更的评审评论或问题，也几乎肯定应该带来注释或变更日志条目，以便下一个评审人员更好地理解正在发生的事情。
一定要告诉评审人员你正在做的更改，并感谢他们的时间。代码评审是一个耗时且令人疲惫的过程，评审人员有时会变得不耐烦。即便如此，也要礼貌地回应并解决他们指出的问题。在发送下一个版本时，在封面信或单个补丁中添加“补丁变更日志”，解释与前一次提交的不同之处（参见:ref:`the_canonical_patch_format`）。
通过将评论过你补丁的人添加到补丁的抄送列表中，通知他们新版本的到来。
请参阅Documentation/process/email-clients.rst，获取有关推荐的电子邮件客户端和邮件列表礼仪的信息。
.. _interleaved_replies:

在电子邮件讨论中使用精简的交错回复
--------------------------------------
在Linux内核开发讨论中，强烈不鼓励顶部回复。交错（或“内联”）回复使对话更容易追踪。更多详情，请参阅：https://en.wikipedia.org/wiki/Posting_style#Interleaved_style

正如邮件列表中经常引用的那样::

  A: http://en.wikipedia.org/wiki/Top_post
  Q: 我在哪里可以找到关于所谓的顶部回复的信息？
  A: 因为它打乱了人们通常阅读文本的顺序
Q: 为什么顶部回复是一件坏事？
  A: 顶部回复
Q: 电子邮件中最令人恼火的事情是什么？

同样，请删除所有与你的回复无关的不必要的引用。这使得响应更容易找到，节省了时间和空间。更多详情，请参阅：http://daringfireball.net/2007/07/on_top ::

  A: 不
问：我在回复后应该附上引号吗？

.. _重发提醒:

不要气馁——也不要急躁
------------------------

提交你的更改后，请耐心等待。评审人员很忙，可能不会立即处理你的补丁。
曾经，补丁可能会无声无息地消失，但现在的开发流程比那时更加顺畅。你应该在几周内（通常为2到3周）收到反馈；如果没有发生这种情况，请确保你已将补丁发送到了正确的地方。至少等待一周后再重新提交或提醒评审人员——在合并窗口这样的繁忙时期可能需要更长时间。
同样，在几周后也可以使用“RESEND”添加到主题行中重新发送补丁或补丁系列：

   [PATCH Vx RESEND] sub/sys: 简化的补丁摘要

当你提交修改过的补丁或补丁系列时，不要加上“RESEND”——“RESEND”仅适用于未作任何修改即重新提交的补丁或补丁系列。
在主题中包含“PATCH”
------------------------------

由于Linus和linux-kernel邮件列表中的邮件流量很大，因此通常的做法是在主题行前加上[PATCH]。这样可以让Linus和其他内核开发者更容易地区分补丁和其他邮件讨论。
`git send-email`会自动为你完成这个操作。
签署你的工作——开发者的起源证书
------------------------------------------------------

为了更好地追踪谁做了什么，特别是对于那些可能通过多层维护者流转最终进入内核的补丁，我们引入了一种电子邮件传输补丁的“签名”程序。
签名是一段简单的文字，放在补丁解释的末尾，用来证明你是该补丁的作者，或者你有权将其作为开源补丁进行传播。规则相当简单：如果你可以保证以下内容：

开发者起源证书 1.1
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

通过向本项目做出贡献，我保证：

        (a) 该贡献完全或部分由我创建，并且我有权根据文件中指定的开源许可提交它；或

        (b) 该贡献基于之前的工作，据我所知，这些工作受到适当的开源许可保护，并且我有权根据该许可提交这些工作（包括我全部或部分创建的修改），除非我可以根据不同的许可提交，如文件中所示；或

        (c) 该贡献直接由其他人提供给我，此人已经认证了(a)，(b)或(c)，而我没有对其进行修改。
(d) 我理解并同意本项目及其贡献是公开的，并且贡献记录（包括我提交的所有个人信息，包括我的签名）将被永久保存，并可按照本项目或涉及的开源许可进行再分发。
那么你只需添加一行文字表示：

	Signed-off-by: 随机 J 开发者 <random@developer.example.org>

使用一个已知的身份（抱歉，不接受匿名贡献）。如果你使用`git commit -s`，这将自动为你完成。
也应当在撤销提交中包含"Signed-off-by"。`git revert -s`会帮你完成这一操作。
有些人还在末尾添加额外的标签。目前，这些标签将被忽略，但你可以这样做来标记公司内部流程或仅仅指出关于批准的一些特殊细节。

任何在作者的"Signed-off-by:"之后的进一步的SoBs（Signed-off-by:'s）都是来自处理和传输补丁的人，但他们并未参与补丁的开发。SoB链应该反映补丁在传播到维护者并最终传到Linus的过程中所经历的**真实**路径，其中第一个SoB条目表明了单个作者的主要创作权。

何时使用Acked-by:、Cc:和Co-developed-by：
-------------------------------------------

"SIGNED-OFF-BY:"标签表明签名者参与了补丁的开发，或者他/她位于补丁的传递路径中。
如果一个人并未直接参与补丁的准备或处理，但希望表明并记录他们对它的认可，则他们可以要求在补丁的更改日志中添加一个"Acked-by:"行。
当该维护者既未贡献也未转发该补丁时，受影响代码的维护者通常会使用"Acked-by:"。
"Acked-by:"不如"SIGNED-OFF-BY:"正式。它记录了确认者至少审阅了补丁并表示接受。因此，补丁合并者有时会手动将确认者的“是的，看起来不错”转换为“Acked-by:”（但请注意，通常最好请求明确的确认）。
"Acked-by:"不一定表示对整个补丁的认可。
例如，如果一个补丁影响多个子系统，并且有一个子系统的维护者提供了"Acked-by:"，那么这通常只表示对该维护者代码部分的认可。在这里应该运用判断力。
当有疑问时，人们应参考邮件列表归档中的原始讨论。
如果一个人有机会对某个补丁发表评论，但没有提供这样的评论，您可以选择性地在该补丁上添加一个“Cc:”标签。
这是唯一一个可以在被标注的人没有明确行动的情况下添加的标签 —— 但它应该表明这个人已经收到了该补丁的副本。此标签记录了可能感兴趣的各方已经被纳入讨论中。

共同开发者（Co-developed-by:）表示补丁是由多个开发者共同创建的；用于给予共同作者归属权（除了通过“From:”标签归属的作者）当几个人共同完成一个补丁时。由于“Co-developed-by:”表示作者身份，因此每个“Co-developed-by:”都必须紧接着由相关共同作者的“Signed-off-by:”签名。标准的签名程序适用，即“Signed-off-by:”标签的顺序应尽可能反映补丁的历史时间顺序，无论作者是通过“From:”还是“Co-developed-by:”标注。值得注意的是，最后一个“Signed-off-by:”总是提交补丁的开发者的签名。

请注意，“From:”标签是可选的，当“From:”作者也是电子邮件头部“From:”行中列出的人（和电子邮件地址）时。

共同作者提交补丁的例子：

	<变更日志>

	共同开发者：First Co-Author <first@coauthor.example.org>
	签署确认：First Co-Author <first@coauthor.example.org>
	共同开发者：Second Co-Author <second@coauthor.example.org>
	签署确认：Second Co-Author <second@coauthor.example.org>
	签署确认：From Author <from@author.example.org>

由共同作者提交的补丁示例：

	来自：From Author <from@author.example.org>

	<变更日志>

	共同开发者：Random Co-Author <random@coauthor.example.org>
	签署确认：Random Co-Author <random@coauthor.example.org>
	签署确认：From Author <from@author.example.org>
	共同开发者：Submitting Co-Author <sub@coauthor.example.org>
	签署确认：Submitting Co-Author <sub@coauthor.example.org>

使用“Reported-by:”，“Tested-by:”，“Reviewed-by:”，“Suggested-by:”和“Fixes:”

---------------------------------------------------------------------------------

“Reported-by”标签给予那些发现并报告错误的人以认可，并希望这能激励他们在未来继续帮助我们。此标签旨在用于错误；请不要用它来认可功能请求。该标签后面应跟着指向报告的“Closes:”标签，除非该报告不可在网上获取。“Link:”标签可用于代替“Closes:”，如果补丁仅修复了报告中的部分问题。请注意，如果错误是在私下报告的，请先获得许可再使用“Reported-by”标签。

“Tested-by:”标签表明该补丁已经在某种环境下被所提及的人成功测试过。此标签告知维护者一些测试工作已经完成，提供了寻找未来补丁测试者的途径，并确保测试者得到认可。

而“Reviewed-by:”则表示补丁已被审查，并根据评审人的声明被认定为可接受：

评审人监督声明

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

通过提供我的“Reviewed-by:”标签，我声明：

	(a) 我已对该补丁进行了技术审查，以评估其适当性和准备情况，以供纳入主干内核
(b) 与该补丁有关的所有问题、担忧或疑问均已反馈给提交者。我对提交者对我意见的回复感到满意
(c) 尽管这个提交可能有可以改进的地方，但我认为，在当前时刻，(1) 这是对内核有价值的修改，且 (2) 没有已知的问题会反对将其纳入
(d) 虽然我已经审查了该补丁并且相信它是可靠的，但我并不（除非在其他地方明确声明）对它在任何给定情况下实现其声明的目的或功能做出任何保证或担保
审阅标签（Reviewed-by）表示对补丁的主观意见，认为它是内核的适当修改，且没有遗留的重大技术问题。任何感兴趣的评审员（已完成了工作）都可以为一个补丁提供审阅标签。此标签旨在给予评审员荣誉，并告知维护者补丁已经过多少程度的评审。当由熟知主题领域并进行彻底评审的评审员提供的审阅标签（Reviewed-by:），通常会增加你的补丁被纳入内核的可能性。

一旦从测试者或评审员处通过邮件列表收到测试标签（Tested-by）和审阅标签（Reviewed-by），作者在发送下个版本时应将这些标签添加到相应的补丁中。然而，如果补丁在后续版本中发生了实质性变化，这些标签可能不再适用，因此应当移除。
通常，移除某人的测试标签或审阅标签应在补丁更改日志中提及（在‘---’分隔符之后）。

建议标签（Suggested-by：）表明补丁的想法是由被提名的人提出的，并确保此人得到想法的荣誉。请注意，未经报告者的许可不应添加此标签，尤其是如果该想法未在公共论坛上发布。话虽如此，如果我们勤奋地给我们的想法报告者以荣誉，他们将来有望再次帮助我们。

修复标签（Fixes：）表明补丁修复了前一提交中的问题。它用于方便确定bug的起源，这有助于审查bug修复。此标签还帮助稳定内核团队确定哪些稳定内核版本应该接收你的修复。这是指示补丁修复的bug的首选方法。更多细节请参阅 :ref:`describe_changes`

注意：附加修复标签（Fixes：）并不会破坏稳定内核规则流程，也不会取消所有稳定补丁候选者需抄送stable@vger.kernel.org的要求。更多信息，请阅读Documentation/process/stable-kernel-rules.rst

_标准补丁格式：

标准补丁格式

本节描述了补丁本身应该如何格式化。请注意，如果你的补丁存储在“git”仓库中，“git format-patch”可以实现适当的补丁格式化。但是，工具无法创建必要的文本，因此仍然需要阅读下面的说明。

标准的补丁主题行如下所示：

    主题：[PATCH 001/123] 子系统：摘要短语

标准的补丁消息体包含以下内容：

  - 一条“from”行，指定补丁作者，后跟一个空行（仅当发送补丁的人不是作者时需要）
- 解释的正文，每行限制在75列以内，这部分将复制到永久更改日志中，用来描述此补丁
- 一个空行
- 上文描述的“Signed-off-by:”行，这些行也会被记录在变更日志中。
- 包含简单标记“---”的分隔线。
- 不适合放入变更日志中的任何额外评论。
- 实际的补丁（“diff”输出结果）。

主题行格式使得按主题行对邮件进行字母顺序排序变得非常容易——几乎所有的邮件阅读器都支持这种排序方式——因为序列号是零填充的，所以数字和字母的排序是一致的。

邮件主题中的“子系统”应当标识出内核中被修补的区域或子系统。

邮件主题中的“摘要短语”应简洁地描述该邮件包含的补丁。摘要短语不应是一个文件名。不要对整个补丁系列中的每个补丁使用相同的摘要短语（其中“补丁系列”是指多个相关联的有序补丁序列）。

请记住，你的邮件的“摘要短语”将成为该补丁的全球唯一标识符。它会一直传播到“git”变更日志中。摘要短语可能在以后关于补丁的开发者讨论中被引用。人们将想要通过谷歌搜索摘要短语来阅读有关该补丁的讨论。当两三个月后，人们使用如“gitk”或“git log --oneline”之类的工具浏览可能成千上万的补丁时，摘要短语也可能是他们快速看到的唯一信息。

基于以上原因，摘要必须不超过70-75个字符，并且必须描述补丁改变了什么，以及为什么可能需要这个补丁。要做到既简明又描述到位是具有挑战性的，但这正是一个写得好的摘要应该做到的。

摘要短语可以由方括号内的标签前缀：“Subject: [PATCH <tag>...] <摘要短语>”。这些标签不被视为摘要短语的一部分，但描述了如何处理这个补丁。常见的标签可能包括如果针对评论发送了补丁的多个版本的版本描述符（例如，“v1，v2，v3”），或者“RFC”以表示请求评论。
如果一系列补丁中共有四个补丁，可以这样对各个补丁进行编号：1/4、2/4、3/4、4/4。这样做可以确保开发者了解这些补丁的正确应用顺序，并且已经审查或应用了该系列中的所有补丁。
以下是一些良好的主题示例：

    主题: [PATCH 2/5] ext2: 提升位图搜索的可扩展性
    主题: [PATCH v2 01/27] x86: 修正eflags追踪问题
    主题: [PATCH v2] sub/sys: 简化补丁汇总
    主题: [PATCH v2 M/N] sub/sys: 简化补丁汇总

“From”行必须是消息正文的第一行，其格式如下：

        From: 补丁作者 <author@example.com>

“From”行指定了永久变更日志中将被记为补丁作者的人。如果缺少“From”行，则将使用电子邮件头部中的“From:”行来确定变更日志中的补丁作者。
解释正文将被提交到永久源代码变更日志中，因此应当以一种方式编写，即使是一位合格的读者在很久之后忘记了导致此补丁讨论的具体细节，也能够理解。包括补丁所解决故障的症状（如内核日志消息、oops消息等）对于那些可能正在查找适用补丁的人尤其有用。文字应当详细到当数周、数月甚至数年后阅读时，仍能给读者提供足够的细节来理解创建此补丁的**原因**。
如果一个补丁修复的是编译失败，可能没有必要包含所有的编译失败信息；只需包含足够让搜索者能够找到此补丁的信息即可。与“总结短语”一样，重要的是既要简洁又要描述充分。
“---”标记行的主要作用是为补丁处理工具标记变更日志消息的结束位置。
在“---”标记之后添加额外注释的一个良好用途是“diffstat”，以显示哪些文件发生了变化，以及每个文件中插入和删除的行数。对于较大的补丁而言，“diffstat”特别有用。如果你打算在“---”标记之后加入“diffstat”，请使用选项`-p 1 -w 70`，以便文件名从内核源代码树的顶部列出，并且不会占用过多的水平空间（轻松地适应80列，也许带有一些缩进）。(``git``默认会生成适当的diffstat)。

仅适用于当前时刻或维护者、不适合永久变更日志的其他相关注释也应该放在这里。这类注释的一个好例子可能是“补丁变更日志”，它描述了从v1版本到v2版本之间的变更。
请将此信息放置在**“---”线之后**，这条线将变更日志与补丁的其余部分分隔开。版本信息不属于将被提交到git树中的变更日志的一部分。它是供审阅者的附加信息。如果将其放在提交标签之上，则需要手动交互来移除它。如果位于分隔线之下，则在应用补丁时会被自动剥离。

例如：

  <提交消息>
  ..
Signed-off-by: 作者 <author@mail>
  ---
  V2 -> V3: 移除了冗余的帮助函数
  V1 -> V2: 清理了编码风格并解决了审阅意见

  路径/至/文件 | 5+++--
  ..
更多关于适当补丁格式的详细信息，请参阅以下参考：
.. _backtraces:

变更消息中的回溯信息
^^^^^^^^^^^^^^^^^^^^^^^^^

回溯信息有助于记录导致问题的调用链。然而，并非所有的回溯信息都是有用的。例如，早期启动时的调用链是独特的且显而易见的。逐字复制完整的dmesg输出会增加一些分散注意力的信息，比如时间戳、模块列表、寄存器和堆栈转储。
因此，最有用的回溯信息应当从转储中提炼出相关信息，这有助于我们专注于真正的问题。以下是一个经过恰当裁剪的回溯示例：

  未检查的MSR访问错误：向0xd51（尝试写入0x0000000000000064）进行WRMSR
  在rIP: 0xffffffffae059994 (native_write_msr+0x4/0x20)
  调用追踪：
  mba_wrmsr
  update_domains
  rdtgroup_mkdir

.. _显式_in_reply_to:

显式的In-Reply-To头
---------------------

在补丁中手动添加In-Reply-To:头（例如，在使用`git send-email`时）以将补丁与先前的相关讨论关联起来，这可能是有帮助的，例如，将bug修复链接到包含bug报告的邮件。然而，对于一个多补丁系列，通常最好避免使用In-Reply-To:来链接到该系列的旧版本。这样可以防止多个版本的补丁在邮件客户端中变成无法管理的引用森林。如果需要链接，你可以使用https://lore.kernel.org/重定向器（例如，在封面邮件文本中），链接到该补丁系列的早期版本。

提供基树信息
------------------

当其他开发者收到你的补丁并开始审查过程时，他们绝对需要知道你的工作基于哪个基础提交/分支，考虑到当今存在的大量维护者树。再次注意上述解释的MAINTAINERS文件中的**T:**条目。
这对于自动CI流程尤其重要，这些流程试图运行一系列测试，以在维护者开始审查之前确定你提交的质量。

如果你使用`git format-patch`生成你的补丁，你可以通过使用`--base`标志自动在你的提交中包含基树信息。使用此选项最简单和最方便的方式是与主题分支结合使用：

    $ git checkout -t -b my-topical-branch master
    分支'my-topical-branch'设置为跟踪本地分支'master'
切换到新分支'my-topical-branch'

    [执行你的编辑和提交]

    $ git format-patch --base=auto --cover-letter -o outgoing/ master
    outgoing/0000-cover-letter.patch
    outgoing/0001-First-Commit.patch
    outgoing/..
当你打开`outgoing/0000-cover-letter.patch`进行编辑时，你会注意到它将在底部有`base-commit:`尾注，这为审阅者和CI工具提供了足够的信息，以便正确地执行`git am`，而不必担心冲突：

    $ git checkout -b patch-review [base-commit-id]
    切换到新分支'patch-review'
    $ git am patches.mbox
    正在应用：First Commit
    正在应用：..

请参阅`man git-format-patch`获取有关此选项的更多信息。
.. note::

    `--base`特性是在git版本2.9.0中引入的。
如果你不使用git格式化你的补丁，你仍然可以包括相同的`base-commit`尾注，以指示你的工作所基于的树的提交哈希值。你应该将其添加在封面信或系列的第一个补丁中，并且应该放在`---`行下方或所有其他内容的最底部，就在你的电子邮件签名之前。
确保基提交位于官方维护者/主线树中，而不在仅你可访问的某些内部树中——否则它将毫无价值。
参考文献
----------

安德鲁·莫顿, "完美的补丁"(tpp)
<https://www.ozlabs.org/~akpm/stuff/tpp.txt>

杰夫·加兹克, "Linux内核补丁提交格式"
<https://web.archive.org/web/20180829112450/http://linux.yyz.us/patch-format.html>

格雷格·克罗亚-哈特曼, "如何惹恼内核子系统维护者"
<http://www.kroah.com/log/linux/maintainer.html>

<http://www.kroah.com/log/linux/maintainer-02.html>

<http://www.kroah.com/log/linux/maintainer-03.html>

<http://www.kroah.com/log/linux/maintainer-04.html>

<http://www.kroah.com/log/linux/maintainer-05.html>

<http://www.kroah.com/log/linux/maintainer-06.html>

内核文档/process/coding-style.rst

林纳斯·托瓦兹关于标准补丁格式的邮件:
<https://lore.kernel.org/r/Pine.LNX.4.58.0504071023190.28951@ppc970.osdl.org>

安迪·克莱恩, "关于提交内核补丁"
一些策略以实现困难或有争议的更改
<http://halobates.de/on-submitting-patches.pdf>
