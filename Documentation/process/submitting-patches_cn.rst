提交补丁：将你的代码纳入内核的必备指南
============================================================================

对于希望向 Linux 内核提交更改的个人或公司来说，如果不熟悉“系统”，这个过程有时可能会令人望而却步。本文档收集了一系列建议，可以大大提高你的更改被接受的机会。本文档以相对简明的形式提供了大量建议。关于内核开发流程的详细信息，请参阅 `Documentation/process/development-process.rst`。此外，请阅读 `Documentation/process/submit-checklist.rst`，了解提交代码前需要检查的项目列表。对于设备树绑定补丁，请参阅 `Documentation/devicetree/bindings/submitting-patches.rst`。本文档假设你使用 `git` 来准备补丁。如果你不熟悉 `git`，最好学习如何使用它，这将使你作为内核开发者的生活更加轻松。一些子系统和维护者树有额外的工作流和期望信息，请参阅 `:ref:Documentation/process/maintainer-handbooks.rst <maintainer_handbooks_main>`。

获取当前源码树
----------------------------

如果你没有现成的包含最新内核源码的仓库，可以使用 `git` 获取一个。你应该从主分支仓库开始，可以通过以下命令获取：

```bash
git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
```

然而，请注意，你可能不想直接基于主分支进行开发。大多数子系统的维护者运行他们自己的树，并希望看到针对这些树准备的补丁。查看 `MAINTAINERS` 文件中的 **T:** 条目来找到那个树，或者直接询问维护者如果该树未列出。

描述你的更改
---------------------

描述你遇到的问题。无论你的补丁是一个单行的错误修复还是新增了 5000 行的新特性，都必须有一个潜在的问题促使你完成这项工作。说服评审者这个问题值得解决，并且让他们愿意继续阅读第一段之后的内容。

描述用户可见的影响。显而易见的崩溃和死锁是很有力的证据，但并非所有问题都这么明显。即使问题是在代码审查过程中发现的，也要描述你认为对用户可能产生的影响。请记住，大多数 Linux 安装运行的是从次级稳定树或厂商/产品特定树中挑选部分补丁的内核，因此包括任何有助于将你的更改传递到下游的信息：触发条件、 `dmesg` 的摘录、崩溃描述、性能倒退、延迟峰值、死锁等。

量化优化和权衡。如果你声称在性能、内存消耗、栈占用或二进制文件大小方面有所改进，请提供支持这些说法的数据。但也要描述不明显的成本。优化通常不是免费的，而是涉及 CPU、内存和可读性之间的权衡；或者，在涉及启发式方法时，是不同工作负载之间的权衡。描述你的优化预期会带来的负面影响，以便评审者能够权衡成本与收益。
一旦问题被确定，详细描述你实际在技术层面上所做的事情。用简单的英语描述这一改变，以便审核者能够确认代码是否按你的意图运行。

如果你以一种容易被拉入Linux源代码管理系统“git”作为“提交日志”的形式编写补丁说明，维护者会感谢你。参见 :ref:`the_canonical_patch_format`。
每个补丁只解决一个问题。如果你的描述开始变长，这表明你可能需要将补丁拆分。参见 :ref:`split_changes`。

当你提交或重新提交一个补丁或补丁系列时，请包含完整的补丁描述及其理由。不要只是说这是版本N的补丁（系列）。不要指望子系统维护者会参考早期的补丁版本或链接的URL来查找补丁描述并将其放入补丁中。

也就是说，补丁（系列）及其描述应该是自包含的。这对维护者和审核者都有好处。一些审核者可能根本没有收到早期版本的补丁。

用祈使语气描述你的更改，例如“让xyzzy执行frotz”，而不是“[这个补丁]让xyzzy执行frotz”或“[我]改变了xyzzy使其执行frotz”，就好像你在命令代码库改变其行为一样。

如果你想引用特定的提交，请不要仅提及该提交的SHA-1 ID。请同时包含提交的一行总结，以便审核者更容易了解它是什么内容。

示例::

    提交e21d2170f36602ae2708（“video: 去除不必要的platform_set_drvdata()”）去除了不必要的platform_set_drvdata()，但留下了未使用的变量“dev”，删除它。
你也应该确保使用至少前十二个字符的SHA-1 ID。内核仓库包含大量的对象，这使得使用较短ID时发生冲突的可能性变得非常真实。请记住，即使现在你的六位数ID没有发生冲突，五年后这种情况可能会改变。

如果相关的讨论或任何其他背景信息可以在网络上找到，请添加`Link:`标签指向这些内容。如果补丁是基于之前的邮件列表讨论或者网络上的文档，请指出其来源。

在链接到邮件列表归档时，最好使用lore.kernel.org的消息归档服务。创建链接URL时，使用消息头部中的`Message-ID`内容，并去掉周围的尖括号。例如：

    Link: https://lore.kernel.org/30th.anniversary.repost@klaava.Helsinki.FI

请检查链接以确保它确实有效并指向相关消息。

然而，尽量使你的解释不依赖外部资源。除了给出邮件列表归档或错误报告的URL外，还应总结导致提交该补丁的相关讨论要点。

如果你的补丁修复了一个错误，请使用`Closes:`标签，并附上邮件列表归档或公共错误跟踪器中的报告URL。例如：

    Closes: https://example.com/issues/1234

一些错误跟踪器能够在应用带有此类标签的提交时自动关闭问题。一些监控邮件列表的机器人也可以跟踪这些标签并采取某些行动。私人错误跟踪器和无效的URL是禁止使用的。

如果你的补丁修复了某个特定提交中的错误（例如你使用了`git bisect`发现了问题），请使用`Fixes:`标签，并附上前十二个字符的SHA-1 ID以及一行总结。不要将标签拆分成多行，标签不受“每行不超过75列”的规则限制，以便简化解析脚本。例如：

    Fixes: 54a4f0239f2e ("KVM: MMU: make kvm_mmu_zap_page() return the number of pages it actually freed")

可以使用以下`git config`设置来为`git log`或`git show`命令输出上述格式：

    [core]
        abbrev = 12
    [pretty]
        fixes = Fixes: %h ("%s")

示例调用：

    $ git log -1 --pretty=fixes 54a4f0239f2e
    Fixes: 54a4f0239f2e ("KVM: MMU: make kvm_mmu_zap_page() return the number of pages it actually freed")

.. _split_changes:

分隔你的更改
-------------

将每个**逻辑更改**分成单独的补丁。
例如，如果你的更改包括对单个驱动程序的错误修复和性能增强，请将这些更改分成两个或多个补丁。如果你的更改包括API更新和使用该新API的新驱动程序，请将这些分成两个补丁。
另一方面，如果你对多个文件进行了单一更改，请将这些更改合并成一个补丁。这样，一个逻辑更改就包含在一个补丁中。
需要注意的是，每个补丁都应做出易于理解且可以由审查者验证的更改。每个补丁都应凭借自身优点来证明其合理性。
如果一个补丁依赖于另一个补丁才能完成更改，这是可以的。只需在你的补丁描述中注明“此补丁依赖于补丁X”。

在将你的更改拆分成一系列补丁时，请特别注意确保每个补丁之后内核能够正确编译和运行。使用`git bisect`来追踪问题的开发者可能会在任何地方分割你的补丁系列；如果你在中间引入了错误，他们不会感谢你。

如果你无法将你的补丁集简化为更小的一组补丁，则每次只发布大约15个补丁，并等待审核和集成。

检查你的代码风格
-------------------

检查你的补丁是否存在基本的风格违规情况，具体细节可以在Documentation/process/coding-style.rst中找到。
不这样做只会浪费审阅者的时间，并且你的补丁可能会被拒绝，甚至可能根本不会被阅读。

一个重要的例外是当从一个文件移动代码到另一个文件时——在这种情况下，你不应在同一个补丁中修改所移动的代码。这清楚地划分了移动代码的行为和你的更改。这极大地有助于审查实际差异，并允许工具更好地跟踪代码本身的历史。

提交补丁之前请用补丁风格检查器进行检查（scripts/checkpatch.pl）。请注意，风格检查器应被视为一种指导工具，而不是替代人类判断的方法。如果你的代码即使有违规看起来也更好，那么最好保持原样。

检查器报告分为三个级别：
- ERROR：非常可能是错误的情况
- WARNING：需要仔细审查的情况
- CHECK：需要思考的情况

你应该能够为补丁中剩余的所有违规行为提供合理的解释。

选择你的补丁接收者
----------------------------

对于任何涉及他们维护的代码的补丁，你都应该抄送相应的子系统维护者及邮件列表；查看MAINTAINERS文件和源代码修订历史以确定这些维护者是谁。在此步骤中，脚本scripts/get_maintainer.pl非常有用（将补丁路径作为参数传递给scripts/get_maintainer.pl）。如果你找不到负责你正在工作的子系统的维护者，Andrew Morton (akpm@linux-foundation.org) 可以作为最后的维护者。

默认情况下，所有补丁都应发送至linux-kernel@vger.kernel.org，但该列表的大量邮件已导致一些开发者不再关注它。请不要向无关的列表和无关的人发送垃圾邮件。
许多与内核相关的邮件列表托管在 kernel.org；您可以在 https://subspace.kernel.org 找到这些列表。还有一些与内核相关的邮件列表托管在其他地方，不过 Linus Torvalds 是所有被接受到 Linux 内核的更改的最终仲裁者。他的电子邮件地址是 <torvalds@linux-foundation.org>。

他收到很多邮件，在现阶段，很少有补丁直接通过 Linus 处理，因此通常您应该尽量避免给他发送邮件。
如果您有一个修复了可利用的安全漏洞的补丁，请将该补丁发送到 security@kernel.org。对于严重的漏洞，可能会考虑短暂的禁令，以便发行版能够将补丁分发给用户；在这种情况下，显然不应将补丁发送到任何公开列表。详见 Documentation/process/security-bugs.rst。
如果您的补丁修复了已发布内核中的严重漏洞，请通过在补丁签名区域添加如下行来通知稳定维护者：

  Cc: stable@vger.kernel.org

（注意，这不是电子邮件接收者）。您还应阅读 Documentation/process/stable-kernel-rules.rst 和本文档。
如果变更影响到用户空间-内核接口，请向 MAN-PAGES 维护者（在 MAINTAINERS 文件中列出）发送 man-pages 补丁，或者至少通知他们变更，以便相关信息能进入手册页。用户空间 API 的变更也应抄送至 linux-api@vger.kernel.org。
不要使用 MIME、链接、压缩或附件。仅使用纯文本。
-------------------------------------------------------------------

Linus 和其他内核开发者需要能够阅读并评论您提交的变更。内核开发者需要能够使用标准的电子邮件工具“引用”您的变更，以便对您代码的具体部分发表评论。
为此，所有补丁都应以“内联”形式通过电子邮件提交。最简单的方法是使用 `git send-email`，这强烈推荐。一个交互式的 `git send-email` 教程可在 https://git-send-email.io 找到。
如果您选择不使用 `git send-email`：

.. warning::

  如果您选择剪切和粘贴补丁，请小心编辑器的自动换行功能可能会破坏您的补丁。
不要以 MIME 附件的形式附加补丁，无论是否压缩。
许多流行的电子邮件应用程序并不会总是将 MIME 附件作为纯文本传输，这使得无法对你的代码进行评论。MIME 附件也会让 Linus 处理起来花费更多时间，从而降低了你的 MIME 附件更改被接受的可能性。
例外：如果你的邮件客户端在处理补丁时出现问题，可能会有人要求你使用 MIME 重新发送。

请参阅 `Documentation/process/email-clients.rst` 中关于配置电子邮件客户端以确保其发送补丁时保持原样的提示。
回应评审意见
--------------

你的补丁几乎肯定会收到评审者的评论，这些评论会指出如何改进补丁，并以对你邮件的回复形式出现。你必须回应这些评论；忽略评审者是让自己也被忽略的好方法。你可以简单地回复他们的邮件来回答他们的问题。即使没有导致代码更改的评审评论或问题，也几乎肯定需要添加注释或更改日志条目，以便下一位评审者更好地理解情况。
一定要告诉评审者你所做的更改，并感谢他们的时间。代码评审是一个耗时且令人疲惫的过程，评审者有时会变得烦躁。即便如此，也要礼貌地回应并解决他们指出的问题。当发送新版本时，在封面信或个别补丁中添加一个“补丁更改日志”，说明与上次提交的不同之处（参见 :ref:`the_canonical_patch_format`）。
通过将评论过你补丁的人添加到补丁的抄送列表中来通知他们新版本。
请参阅 `Documentation/process/email-clients.rst` 中关于电子邮件客户端和邮件列表礼仪的建议。
.. _interleaved_replies:

在电子邮件讨论中使用修剪过的交错回复
-----------------------------------------
在 Linux 内核开发讨论中，顶部回复（Top-posting）是强烈不被鼓励的。交错回复（或称为“内联”回复）使对话更容易跟踪。更多详情参见：https://en.wikipedia.org/wiki/Posting_style#Interleaved_style

正如邮件列表中经常引用的一段话所示::

  A: http://en.wikipedia.org/wiki/Top_post
  Q: 我在哪里可以找到有关顶部回复的信息？
  A: 因为它打乱了人们通常阅读文本的顺序
  Q: 为什么顶部回复这么糟糕？
  A: 顶部回复
  Q: 电子邮件中最烦人的是什么？

同样，请修剪所有与你的回复无关的不必要的引用。这样可以使回复更容易找到，并节省时间和空间。更多详情参见：http://daringfireball.net/2007/07/on_top ::
  
  A: No
问：我在回复时需要包含引用吗？

.. _resend_reminders:

不要灰心——也不要急躁
--------------------

提交更改后，请耐心等待。评审人员通常都很忙，可能不会立即处理你的补丁。曾经，补丁可能会石沉大海、无人回应，但现在开发流程更加顺畅了。你应该会在几周内（通常为2到3周）收到反馈；如果未收到，请确保你已将补丁发送到了正确的地方。至少等待一周后再重新提交或提醒评审人员——在合并窗口等忙碌时期，可能需要更长时间。几周后可以重新发送补丁或补丁系列，并在主题行中加上“RESEND”字样：

   [PATCH Vx RESEND] sub/sys: 简要的补丁说明

当你提交修改后的补丁或补丁系列时，不要添加“RESEND”——“RESEND”仅适用于重新发送与前一次提交完全相同的补丁或补丁系列。
在主题中包含“PATCH”
-------------------

由于Linus和linux-kernel邮件列表中的邮件流量很大，通常约定在主题行前加上[PATCH]。这有助于Linus和其他内核开发者更容易地区分补丁与其他邮件讨论。“git send-email”会自动为你完成这一点。
签署你的工作——开发者的版权证明
--------------------------------

为了更好地追踪谁做了什么，特别是在补丁通过多个维护层传递到内核最终版本的过程中，我们引入了一种补丁“签署”程序。签署是一段简单的声明，位于补丁解释的最后一行，证明你是该补丁的作者或有权作为开源补丁提交它。规则很简单：如果你能证明以下内容：

开发者版权证明 1.1
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

通过向本项目贡献代码，我证明：

(a) 该贡献全部或部分由我创作，我有权以文件中指示的开源许可协议提交它；或者

(b) 该贡献基于之前的工作，据我所知，这些工作受适当的开源许可协议保护，我有权根据该许可协议提交带有修改的工作（无论该修改是否全部或部分由我完成），并以相同的开源许可协议（除非允许使用不同的许可协议）提交，具体见文件中的指示；或者

(c) 该贡献是由其他某人直接提供给我的，此人已认证(a)，(b)或(c)，且我没有对其作出任何修改。

(d) 我理解并同意本项目及其贡献是公开的，并且我的贡献记录（包括所有我提交的个人信息及签名）将被永久保存，并可能按照本项目或涉及的开源许可协议进行再分发。

那么你只需添加一行如下所示：

	Signed-off-by: Random J Developer <random@developer.example.org>

使用一个已知的身份（抱歉，不接受匿名贡献）。如果你使用`git commit -s`，这将自动完成。
回退提交也应该包含“Signed-off-by”。`git revert -s`会为你自动添加这一点。
有些人还在末尾添加额外的标签。目前这些标签会被忽略，但你可以这样做来标记公司内部流程或指出签核的一些特殊细节。
任何在作者“Signed-off-by:”之后的其他SoB（Signed-off-by:）都是处理和传输补丁的人所添加的，但他们并未参与补丁的开发。SoB链应该反映补丁传播到维护者并最终传给Linus的真实路径，第一个“Signed-off-by:”条目表示单一作者的主要贡献。

何时使用Acked-by:、Cc: 和Co-developed-by:
------------------------------------------

“Signed-off-by:”标签表明签名者参与了补丁的开发，或者他/她处于补丁的传递路径中。
如果一个人没有直接参与补丁的准备或处理，但希望表明并记录他们对补丁的认可，则可以要求在补丁的日志中添加一个“Acked-by:”行。
当维护者既未贡献也未转发该补丁时，“Acked-by:”通常由受影响代码的维护者使用。
“Acked-by:”不如“Signed-off-by:”正式。它记录了认可者至少审查过补丁并表示接受。因此，补丁合并者有时会手动将认可者的“是的，看起来不错”转换为“Acked-by:”（但请注意，通常最好请求明确的认可）。
“Acked-by:”不一定表示对整个补丁的认可。
例如，如果一个补丁影响多个子系统，并且有一个来自某个子系统维护者的“Acked-by:”，这通常只表示对该维护者代码部分的认可。在这种情况下应谨慎判断。
如果有疑问，人们应参考邮件列表存档中的原始讨论。
如果一个人有机会对某个补丁发表评论，但没有提供这样的评论，你可以选择在补丁中添加一个 `Cc:` 标签。这是唯一一个可以在该人没有明确行动的情况下添加的标签——但它应该表明此人被抄送了该补丁。此标签记录了潜在感兴趣的各方已被纳入讨论。

Co-developed-by: 表示补丁是由多位开发者共同创建的；用于在多个开发者合作完成单个补丁时给予共同作者（除了通过 From: 标签归因的作者）归因。由于 Co-developed-by: 表示作者身份，每个 Co-developed-by: 必须立即跟上相应的共同作者的 Signed-off-by:。标准签名流程适用，即无论作者是通过 From: 还是 Co-developed-by: 归因，Signed-off-by: 标签的顺序应尽可能反映补丁的历史时间顺序。值得注意的是，最后一个 Signed-off-by: 必须始终是提交补丁的开发者的签名。

请注意，当 From: 作者也是电子邮件头部 From: 行中的人员（和电子邮件地址）时，From: 标签是可选的。

From: 作者提交的补丁示例：

	<changelog>

	Co-developed-by: 第一共同作者 <first@coauthor.example.org>
	Signed-off-by: 第一共同作者 <first@coauthor.example.org>
	Co-developed-by: 第二共同作者 <second@coauthor.example.org>
	Signed-off-by: 第二共同作者 <second@coauthor.example.org>
	Signed-off-by: From 作者 <from@author.example.org>

由 Co-developed-by: 作者提交的补丁示例：

	From: From 作者 <from@author.example.org>

	<changelog>

	Co-developed-by: 随机共同作者 <random@coauthor.example.org>
	Signed-off-by: 随机共同作者 <random@coauthor.example.org>
	Signed-off-by: From 作者 <from@author.example.org>
	Co-developed-by: 提交共同作者 <sub@coauthor.example.org>
	Signed-off-by: 提交共同作者 <sub@coauthor.example.org>

使用 Reported-by:、Tested-by:、Reviewed-by:、Suggested-by: 和 Fixes:

Reported-by 标签给予发现并报告漏洞的人以认可，并希望激励他们在未来继续帮助我们。此标签适用于漏洞；请勿用于功能请求的认可。此标签后应跟随一个指向报告的 Closes: 标签，除非报告未发布在网上。如果补丁修复了部分报告的问题，则可以使用 Link: 标签代替 Closes:。请注意，如果漏洞是在私下报告的，请先征得许可再使用 Reported-by 标签。

Tested-by: 标签表示该补丁已在某种环境中被命名的人成功测试过。此标签告知维护者已经进行了某些测试，提供了寻找未来补丁测试者的途径，并确保测试者的贡献得到认可。

相反，Reviewed-by: 表示该补丁经过审查并被认为符合 Reviewer 的声明：

Reviewer 的监督声明
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

通过提供我的 Reviewed-by: 标签，我声明：

(a) 我对该补丁进行了技术审查，以评估其适当性和准备好纳入主线内核的情况。
(b) 任何与补丁相关的问题、担忧或疑问都已反馈给提交者。我对提交者对我评论的回复感到满意。
(c) 尽管这个提交可能有改进的空间，但我认为它目前（1）是对内核有价值的修改，并且（2）没有已知问题会反对将其纳入。
(d) 虽然我已经审查了该补丁并认为它是可靠的，但我并不（除非在其他地方明确声明）保证它将在任何给定情况下实现其预期目的或正常运行。
已审阅标签（Reviewed-by 标签）表示审阅者认为该补丁是对内核的适当修改，并且没有任何剩余的重大技术问题。任何感兴趣的审阅者（已经完成相关工作的）都可以为一个补丁提供已审阅标签。此标签用于表彰审阅者并向维护者告知该补丁已进行的审阅程度。当由已知了解该主题领域的审阅者提供的已审阅标签时，通常会增加你的补丁被合并到内核的可能性。

一旦测试者或审阅者在邮件列表中提供了已测试（Tested-by）或已审阅标签，作者在发送下一个版本时应将这些标签添加到适用的补丁中。但是，如果补丁在随后的版本中有实质性改变，这些标签可能不再适用，因此应该移除。通常情况下，移除某人的已测试或已审阅标签应在补丁变更日志中提及（在“---”分隔符之后）。

建议者标签（Suggested-by 标签）表示补丁的想法是由指定的人提出的，并确保对该人的贡献给予认可。请注意，未经报告者的许可不应添加此标签，特别是在想法未发布于公共论坛的情况下。也就是说，如果我们认真地表彰我们的想法提出者，他们未来可能会受到激励再次帮助我们。

修复标签（Fixes 标签）表示该补丁修复了之前提交中的一个问题。它用于方便确定一个错误的起源，这有助于审查一个错误修复。此标签也有助于稳定内核团队确定哪些稳定内核版本应接收你的修复。这是指明补丁修复的错误的首选方法。更多细节请参见 :ref:`describe_changes`。

注意：附加修复标签并不会绕过稳定内核规则流程，也不会免除在所有稳定补丁候选中抄送 stable@vger.kernel.org 的要求。更多信息，请阅读 Documentation/process/stable-kernel-rules.rst。

### 标准补丁格式

本节描述了补丁本身应该如何格式化。请注意，如果你的补丁存储在一个 `git` 仓库中，可以使用 `git format-patch` 获得正确的补丁格式。然而，工具无法创建必要的文本内容，因此请仍然阅读以下说明。

标准补丁的主题行如下所示：

```
Subject: [PATCH 001/123] 子系统: 概要描述
```

标准补丁的消息体包含以下内容：

- 一条 `from` 行，指定补丁的作者，后跟一个空行（仅当发送补丁的人不是作者时需要）
- 解释的正文部分，每行限制在 75 列内，这部分会被复制到永久变更日志中以描述此补丁
- 一个空行
- 上文所述的 ``Signed-off-by:`` 行，这些行也会被加入到变更日志中。
- 一个仅包含 ``---`` 的标记行。
- 任何不适合放入变更日志的额外评论。
- 实际的补丁（`diff` 输出）。

主题行格式使得按主题行对邮件进行字母排序变得非常容易 —— 几乎所有的电子邮件客户端都会支持这种排序方式。由于序列号是零填充的，因此数字排序和字母排序是一致的。

邮件的主题中的 ``子系统`` 应该标识出内核中被修补的具体区域或子系统。

邮件的主题中的 ``摘要短语`` 应该简明扼要地描述该邮件所包含的补丁。``摘要短语`` 不应是一个文件名。不要在一个完整的补丁系列（一个补丁系列是指多个相关联的补丁有序序列）中的每个补丁都使用相同的 ``摘要短语``。

请记住，你的邮件中的 ``摘要短语`` 成为了该补丁的全局唯一标识符。它会一直传播到 `git` 变更日志中。``摘要短语`` 可能会在后续开发者讨论中引用该补丁时使用。人们希望可以通过谷歌搜索 ``摘要短语`` 来阅读有关该补丁的讨论。当两个月或三个月后，人们通过 `gitk` 或 `git log --oneline` 等工具浏览可能数千个补丁时，这也将是他们唯一快速看到的内容。

基于这些原因，``摘要`` 必须不超过 70-75 个字符，并且必须描述补丁更改了什么以及为什么需要这个补丁。既要简洁又要描述清晰是有挑战性的，但这正是一个写得好的摘要应该做到的。

``摘要短语`` 可以在方括号中加上标签前缀：“Subject: [PATCH <tag>...] <summary phrase>”。这些标签不被视为摘要短语的一部分，但描述了如何处理该补丁。常见的标签可能包括版本描述符（如果针对评论发送了多个版本的补丁，例如“v1, v2, v3”），或者 “RFC” 以表示请求评论。
如果一个补丁系列中有四个补丁，各个补丁可以按如下方式编号：1/4、2/4、3/4、4/4。这样可以确保开发者理解补丁的正确应用顺序，并且确认或应用了补丁系列中的所有补丁。以下是一些良好的示例主题：

    主题: [PATCH 2/5] ext2: 提升位图搜索的可扩展性
    主题: [PATCH v2 01/27] x86: 修复eflags跟踪问题
    主题: [PATCH v2] sub/sys: 简化补丁摘要
    主题: [PATCH v2 M/N] sub/sys: 简化补丁摘要

`from` 行必须是消息体中的第一行，其形式为：

        来自: 补丁作者 <author@example.com>

`from` 行指定了永久变更日志中将被记为补丁作者的人。如果缺少 `from` 行，则电子邮件头部的 `From:` 行将用于确定变更日志中的补丁作者。
解释正文将被提交到永久源码变更日志中，因此应使一位有经验的读者即使忘记了可能导致此补丁讨论的具体细节也能理解。包含补丁解决的问题症状（如内核日志消息、oops消息等）对于那些在查找适用补丁时搜索提交日志的人来说特别有用。文本应该写得足够详细，以便几周、几个月甚至几年后阅读时，仍能给读者提供所需的信息以理解创建补丁的**原因**。
如果一个补丁修复了一个编译错误，可能不需要包含所有的编译错误；只需包含足够的信息，使得搜索该补丁的人能够找到它。就像在“简要说明”中一样，重要的是既要简洁又要描述清楚。
`---` 分割线标记的主要作用是为补丁处理工具标明变更日志消息的结束位置。
在 `---` 分割线之后添加的额外注释的一个良好用途是显示 `diffstat`，以展示哪些文件发生了更改以及每个文件插入和删除的行数。`diffstat` 对较大的补丁尤其有用。如果您打算在 `---` 分割线之后包含 `diffstat`，请使用选项 `-p 1 -w 70`，以便文件名从内核源代码树的顶部列出，并且不会占用太多水平空间（容易适应80列，可能带有一些缩进）。(`git` 默认生成适当的 `diffstat`。)
其他仅与当前情况或维护者相关、不适合永久变更日志的注释也应放在这里。此类注释的一个良好示例是 `补丁变更日志`，描述了从v1版本到v2版本之间的变化。
请将这些信息放在分隔变更日志和其他补丁部分的 `---` 线之后。版本信息不是提交到 `git` 树的变更日志的一部分。它是供审查者参考的附加信息。如果将其放在提交标签之上，则需要手动交互来移除它。如果位于分隔线之下，则会在应用补丁时自动去除。

<提交信息>
..
签署确认: 作者 <author@mail>
---
V2 -> V3: 移除了冗余的帮助函数
V1 -> V2: 清理了编码风格并解决了评审意见

路径/文件 | 5+++--
..

更多关于正确补丁格式的详细信息，请参见以下参考文献：
.. _回溯信息:

提交信息中的回溯信息
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

回溯信息有助于记录导致问题的调用链。然而，并非所有回溯信息都有帮助。例如，早期启动过程中的调用链是独特且显而易见的。然而，逐字复制完整的 `dmesg` 输出会增加分散注意力的信息，如时间戳、模块列表、寄存器和堆栈转储。
因此，最有用的回溯信息应该从转储中提炼出相关信息，以便更容易地专注于真正的问题。以下是一个经过良好修剪的回溯示例：

  未检查的MSR访问错误：WRMSR到0xd51（尝试写入0x0000000000000064）
  在rIP: 0xffffffffae059994 (native_write_msr+0x4/0x20)
  调用追踪：
  mba_wrmsr
  update_domains
  rdtgroup_mkdir

.. _显式_in_reply_to:

显式的In-Reply-To头
------------------------

在提交补丁时手动添加In-Reply-To:头（例如，使用`git send-email`）可以将补丁与之前的相关讨论关联起来，例如将一个bug修复链接到包含bug报告的邮件。然而，对于一个多补丁系列来说，通常最好避免使用In-Reply-To:来链接到系列的旧版本。这样可以防止多个版本的补丁在邮件客户端中变成难以管理的引用森林。如果需要链接，你可以使用https://lore.kernel.org/重定向器（例如，在封面邮件文本中）来链接到补丁系列的早期版本。

提供基树信息
-------------------

当其他开发者收到你的补丁并开始审查过程时，他们绝对需要知道你的工作基于哪个基础提交/分支，考虑到现今存在的大量维护者树。再次注意上面解释的MAINTAINERS文件中的**T:**条目。
这对于自动持续集成(CI)过程尤其重要，这些过程试图运行一系列测试以评估你的提交质量，然后维护者才开始审查。
如果你使用`git format-patch`生成你的补丁，你可以通过使用`--base`标志自动在提交中包含基树信息。使用此选项最简单且最方便的方式是使用主题分支：

    $ git checkout -t -b my-topical-branch master
    分支 'my-topical-branch' 设置为跟踪本地分支 'master'
    切换到新分支 'my-topical-branch'

    [执行你的编辑和提交]

    $ git format-patch --base=auto --cover-letter -o outgoing/ master
    outgoing/0000-cover-letter.patch
    outgoing/0001-First-Commit.patch
    outgoing/..
当你打开`outgoing/0000-cover-letter.patch`进行编辑时，你会注意到它将在底部有`base-commit:`尾注，这为审阅者和CI工具提供了足够的信息，以正确执行`git am`而不用担心冲突：

    $ git checkout -b patch-review [base-commit-id]
    切换到新分支 'patch-review'
    $ git am patches.mbox
    应用：First Commit
    应用：..

请参阅`man git-format-patch`以获取有关此选项的更多信息。
.. 注意::

    `--base`特性是在git版本2.9.0中引入的。
如果你没有使用git来格式化你的补丁，你仍然可以包含相同的`base-commit`尾注，以指示你的工作基于的树的提交哈希值。你应该将其添加到封面信或系列的第一个补丁中，并且应放在`---`行之下或所有其他内容的底部，紧接在你的电子邮件签名之前。
确保基础提交位于官方维护者/主线树中，而不是仅你可访问的内部树中——否则它将毫无价值。
参考文献
----------

Andrew Morton, “完美的补丁” (tpp)
<https://www.ozlabs.org/~akpm/stuff/tpp.txt>

Jeff Garzik, “Linux 内核补丁提交格式”
<https://web.archive.org/web/20180829112450/http://linux.yyz.us/patch-format.html>

Greg Kroah-Hartman, “如何惹恼内核子系统维护者”
<http://www.kroah.com/log/linux/maintainer.html>

<http://www.kroah.com/log/linux/maintainer-02.html>

<http://www.kroah.com/log/linux/maintainer-03.html>

<http://www.kroah.com/log/linux/maintainer-04.html>

<http://www.kroah.com/log/linux/maintainer-05.html>

<http://www.kroah.com/log/linux/maintainer-06.html>

内核文档/process/coding-style.rst

Linus Torvalds 关于标准补丁格式的邮件：
<https://lore.kernel.org/r/Pine.LNX.4.58.0504071023190.28951@ppc970.osdl.org>

Andi Kleen, “关于提交内核补丁”
一些提交困难或有争议更改的策略
<http://halobates.de/on-submitting-patches.pdf>
