.. _stable_api_nonsense:

Linux 内核驱动接口
==================

（解答你所有的问题，甚至更多）

Greg Kroah-Hartman <greg@kroah.com>

本文档旨在解释为什么 Linux **没有二进制内核接口，也没有稳定的内核接口**。
.. note::

  请注意，本文档描述的是 **内核内部** 接口，而不是内核到用户空间的接口。
  内核到用户空间的接口是应用程序使用的系统调用接口。这个接口在很长一段时间内都是非常稳定的，并且不会破坏。
  我有一些旧程序是在 0.9 某版本内核上编译的，它们在最新的 2.6 内核上仍然可以正常运行。
  这个接口是用户和应用程序程序员可以依赖的稳定接口。

简要总结
---------
你以为你需要一个稳定的内核接口，但实际上你并不需要，你自己甚至都没有意识到这一点。你真正需要的是一个稳定运行的驱动程序，
而只有当你的驱动程序位于主内核树中时，你才能得到这一点。如果你的驱动程序位于主内核树中，你还可以获得许多其他好处，
所有这些都使得 Linux 成为一个强大、稳定和成熟的操作系统，这也是你使用它的原因。

介绍
-----
只有极少数人想要编写内核驱动程序时才会担心内核内部接口的变化。对于大多数用户来说，他们既看不到这个接口，也不关心它。

首先，我不会讨论任何关于闭源、隐藏源代码、二进制模块、源代码包装器或其他描述未按 GPL 发布源代码的内核驱动程序的法律问题。
如果你有任何法律问题，请咨询律师。我是一个程序员，因此我将只描述技术问题（并不是轻视法律问题，它们是真实的，你需要时刻注意它们）。

所以，这里有两个主要话题：二进制内核接口和稳定的内核源码接口。它们彼此相关联，但我们将先讨论二进制接口以排除干扰。

二进制内核接口
-----------------------
假设我们有一个稳定的内核源码接口，那么自然也会有一个二进制接口，对吧？ 错了。请考虑以下关于 Linux 内核的事实：

  - 根据你使用的 C 编译器版本，不同的内核数据结构可能会包含不同的结构对齐方式，并且可能以不同方式包含不同的函数（内联或不内联）。单个函数组织不是很重要，但不同的数据结构填充非常重要。
  - 根据你选择的内核构建选项，内核可以假定各种不同的情况：

      - 不同的数据结构可能包含不同的字段。
      - 有些函数可能根本未实现（例如，在非 SMP 构建中，某些锁可能被编译为不存在）。
      - 内核中的内存可以根据构建选项以不同方式对齐。
  - Linux 在多种不同的处理器架构上运行。
来自一种架构的二进制驱动程序不可能在另一种架构上正常运行。

这些问题可以通过简单地为特定内核配置编译你的模块，并使用与构建内核相同的C编译器来解决。如果你想要为特定版本的特定Linux发行版提供一个模块，这样做就足够了。但将这个单一的构建乘以不同Linux发行版的数量以及这些发行版支持的不同版本数量，你很快就会面对各种不同版本的构建选项所带来的噩梦。同时要注意，每个Linux发行版的版本中都包含多个不同的内核，所有这些内核都针对不同的硬件类型（不同的处理器类型和不同的选项）进行了优化，因此即使对于单个版本，你也需要创建多个模块版本。

相信我，如果你试图支持这种发布方式，最终你会发疯的。我在很久以前就已经通过艰难的方式学到了这一点。

稳定的内核源接口

这是一个更具争议的话题，特别是当你与那些尝试维护不在主内核树中的Linux内核驱动程序的人交谈时。

Linux内核开发是连续且快速进行的，从未停下脚步减速。因此，内核开发者会发现当前接口中的bug，或者找到更好的实现方法。如果他们这样做，他们会修复当前接口以使其更好地工作。当这种情况发生时，函数名称可能会改变，结构可能会扩展或缩小，函数参数可能会被重新设计。如果这发生了，所有使用该接口的地方都会在同一时间被修复，以确保一切继续正常工作。

作为一个具体的例子，在这个子系统的生命周期中，内核中的USB接口至少经历了三次重大的重构。这些重构是为了解决多个不同的问题：

- 从同步数据流模型转变为异步模型。这减少了多个驱动程序的复杂性，并提高了所有USB驱动程序的吞吐量，使得我们现在几乎可以以最大速度运行所有USB设备。
- 在USB核心由USB驱动程序分配数据包的方式上进行了更改，以便所有驱动程序现在都需要向USB核心提供更多信息，以解决已知的死锁问题。

这与许多必须随着时间推移维护旧USB接口的闭源操作系统形成了鲜明对比。这使得新开发者有可能无意中使用旧接口并以不正确的方式做事，从而影响操作系统的稳定性。

在这两个实例中，所有开发者都认为这些是必须做出的重要更改，并且它们确实被实现了，且几乎没有痛苦。如果Linux必须保证保持一个稳定的源接口，那么将创建一个新的接口，并且必须维护旧的、有缺陷的接口，这将给USB开发者带来额外的工作。由于所有Linux USB开发者都是在自己的时间里完成工作的，要求程序员无偿做额外的工作而没有任何收益是不可能的。

安全问题对Linux来说也是非常重要的。当发现安全问题时，它会在非常短的时间内得到修复。很多次，这导致内部内核接口被重构，以防止安全问题的发生。当这种情况发生时，所有使用这些接口的驱动程序也会在同一时间被修复，以确保安全问题被解决，并且不会在未来某个时候意外重现。如果不允许内部接口发生变化，修复这种安全问题并确保其不再发生的可能性将不存在。
### 如何处理

如果你有一个不在主内核树中的Linux内核驱动程序，作为开发者，你应该怎么做呢？为每个不同的内核版本和每个发行版发布二进制驱动程序是一场噩梦，而且试图跟上不断变化的内核接口也是一个艰巨的任务。

解决方法很简单：将你的内核驱动程序加入到主内核树中（这里假设你的驱动程序是基于GPL兼容许可发布的，如果不是这种情况，祝你好运，你只能自力更生了，你这个蹭车者）。如果你的驱动程序在主内核树中，并且内核接口发生变化，最初修改内核接口的人会修复它。这样可以确保你的驱动程序始终可构建，并且长期有效，而你几乎不需要付出太多努力。

将驱动程序放入主内核树中的好处非常多：

- 驱动程序的质量会提高，因为维护成本（对原始开发者而言）会降低。
- 其他开发者会为你的驱动程序添加新功能。
- 其他人会发现并修复你驱动程序中的错误。
- 其他人会在你的驱动程序中找到优化的机会。
- 当外部接口发生变化需要更新时，其他人会为你更新驱动程序。
- 驱动程序会自动包含在所有Linux发行版中，无需请求这些发行版添加它。

由于Linux支持的设备比任何其他操作系统都要多，并且在更多的处理器架构上支持这些设备，这种经过验证的开发模式显然有其独到之处。

---

感谢Randy Dunlap、Andrew Morton、David Brownell、Hanna Linder、Robert Love和Nishanth Aravamudan对本文早期草稿的审阅和评论。
