Linux内核驱动程序接口

=============================

（解答你所有的问题，甚至更多）

Greg Kroah-Hartman <greg@kroah.com>

本文旨在解释为什么Linux**没有二进制内核接口，也没有稳定的内核接口**。

.. note::

   请注意，本文描述的是**内核内部**的接口，而不是内核到用户空间的接口。
   内核到用户空间的接口是应用程序使用的，即系统调用接口。这个接口**非常**稳定，
   随着时间推移不会损坏。我有一些在0.9版之前构建的老程序，在最新的2.6内核版本上依然运行良好。
   这个接口是用户和应用程序员可以依赖的稳定接口。

执行摘要
--------

你以为你想要一个稳定的内核接口，但实际上你并不需要，你自己都不知道这一点。
你真正需要的是一个稳定运行的驱动程序，而只有当你的驱动程序位于主内核树中时才能实现这一点。
如果驱动程序在主内核树中，你还能获得许多其他好处，这使得Linux成为一个强大、稳定和成熟的操作系统，
这也是你首先使用它的原因。

引言
----

只有极少数想要编写内核驱动程序的人才需要担心内核内部接口的变化。
对于世界上绝大多数人来说，他们既看不到这个接口，也不关心它。

首先，我不会讨论任何关于闭源、隐藏源码、二进制模块、源码包装器或任何描述未以GPL发布源码的内核驱动程序的法律问题。
如果你有任何法律疑问，请咨询律师。我是一名程序员，因此我将只描述技术问题（并不是轻视法律问题，它们确实存在，你必须时刻注意。）

所以，这里有两个主要话题：二进制内核接口和稳定的内核源码接口。它们相互依赖，但我们先讨论二进制接口，以便把这个问题处理掉。

二进制内核接口
-----------------

假设我们有一个稳定的内核源码接口，那么自然也会有一个二进制接口，对吧？不正确。
请考虑以下关于Linux内核的事实：

  - 根据你使用的C编译器版本，不同的内核数据结构可能包含不同的结构对齐方式，并且可能以不同方式包含不同的函数（内联或非内联）。
    函数的具体组织不是特别重要，但数据结构的不同填充非常重要。
- 根据你选择的内核构建选项，内核可以做出广泛的假设：

      - 不同的结构可能包含不同的字段。
      - 某些功能可能根本就没有实现（例如，在非SMP构建中，某些锁会编译为无内容）。
      - 根据构建选项，内核中的内存可以以不同的方式对齐。
- Linux运行在广泛的处理器架构上。


注：由于文本过长，最后一段并未完整翻译，实际内容应继续描述Linux在多种架构上的运行情况及其对内核接口稳定性的影响。
一种架构下的二进制驱动程序不可能在另一种架构下正常运行。
通过仅仅为确切特定的内核配置编译你的模块，并使用与构建内核时完全相同的 C 编译器，可以解决许多这些问题。如果你想要为某一特定 Linux 发行版的特定发布版本提供一个模块，这样做就足够了。但将这种单一构建乘以不同 Linux 发行版的数量以及这些发行版支持的不同版本数量，你很快就会面临不同版本中各种构建选项的噩梦。此外，请意识到每个 Linux 发行版都包含多个不同的内核，它们针对不同的硬件类型（不同的处理器类型和不同的选项）进行了优化，因此即使对于单一发行版，你也需要创建多个模块版本。
相信我，随着时间的推移，如果你试图支持这种类型的发布，你会变得抓狂，很久以前我就以惨痛的方式学到了这一课。
稳定的内核源接口
-------------------

如果你跟那些尝试保持不在主内核树中的 Linux 内核驱动程序随时间更新的人交谈，这将是一个更为“动荡”的话题。
Linux 内核开发是持续且快速进行的，从未停下脚步放慢速度。因此，内核开发者会在当前接口中发现错误，或者找到更好的做事方法。如果他们发现了这些，他们会修复当前接口以使其工作得更好。当这种情况发生时，函数名称可能会改变，结构可能会扩展或缩小，函数参数可能会被重新设计。当这种情况发生时，所有使用该接口的内核实例都会同时得到修正，以确保一切都能继续正常运作。
作为具体例子，内核中的 USB 接口在其生命周期中至少经历了三次重大的重构。这些重构是为了处理一系列不同的问题：

- 从同步数据流模型改为异步模型。这降低了多个驱动程序的复杂性，并提高了所有 USB 驱动程序的吞吐量，使我们现在几乎能以最大可能的速度运行所有的 USB 设备。
- 对 USB 核心如何由 USB 驱动程序分配数据包的方式进行了更改，以便所有驱动程序现在需要向 USB 核心提供更多信息来解决已记录的多个死锁问题。

这与一些必须长时间维护其旧 USB 接口的闭源操作系统形成了鲜明对比。这导致新开发者可能会意外地使用旧接口并以不正确的方式做事，从而影响操作系统的稳定性。
在这两种情况下，所有开发者都认为这些是需要做出的重要变更，并且相对顺利地实施了这些变更。如果 Linux 必须保证保留稳定的源接口，那么就会创建一个新的接口，而旧的、有问题的接口则必须长期维护，这会给 USB 开发者带来额外的工作。由于所有 Linux USB 开发者都是利用自己的时间完成工作的，要求程序员无偿做额外的工作是没有可能的。
对于 Linux 来说，安全问题同样非常重要。一旦发现安全问题，它会在很短的时间内得到修复。很多时候，这会导致内核内部接口被重构以防止安全问题的发生。当这种情况发生时，所有使用这些接口的驱动程序也会同时得到修复，确保安全问题被修复并且不会在未来某个时刻意外重现。如果内部接口不允许改变，修复这类安全问题并确保其不再发生是不可能的。
### 内核接口随时间清理
随着时间的推移，内核接口会被逐步清理。如果某个当前接口无人使用，则会被删除。这样做可以确保内核尽可能地精简，并且所有潜在的接口都能得到尽可能充分的测试（未使用的接口几乎不可能进行有效性测试）。

### 应该如何做
#### 如果你有一个不在主内核树中的Linux内核驱动程序，作为开发者你应该怎么办？
为每个不同的内核版本和每个发行版发布二进制驱动程序是一个噩梦，同时跟上不断变化的内核接口也是一个艰巨的任务。
解决方法很简单：让你的内核驱动程序进入主内核树（这里我们讨论的是在GPL兼容许可下发布的驱动程序，如果你的代码不属于此类别，祝你好运，你将自行解决这个问题，你这个搭便车的人）。如果你的驱动程序在树中，并且内核接口发生变化，最初进行内核更改的人会负责修复它。这确保了你的驱动程序始终可构建，并且能长时间工作，而不需要你付出太多努力。
将你的驱动程序放入主内核树中的非常积极的影响包括：

- 驱动程序的质量将提高，因为维护成本（对于原始开发者来说）将会降低。
- 其他开发者将为你的驱动程序添加功能。
- 其他人将在你的驱动程序中发现并修复错误。
- 其他人将在你的驱动程序中找到优化的机会。
- 当外部接口变更需要时，其他人会为你更新驱动程序。
- 驱动程序会自动包含在所有Linux发行版中，无需请求发行版添加它。

由于Linux支持的设备种类比任何其他操作系统都要多，并且这些设备的支持跨越了比任何其他操作系统更多的处理器架构，这种被证明有效的开发模式显然有其合理之处。

### 致谢
感谢Randy Dunlap、Andrew Morton、David Brownell、Hanna Linder、Robert Love以及Nishanth Aravamudan对本文早期草稿的审阅和意见。
