### SPDX 许可证标识符：(GPL-2.0+ 或 CC-BY-4.0)
### 请参阅本文件底部以获取额外的再分发信息
处理回归问题
++++++++++++++

*我们不引入回归问题* —— 本文档描述了“Linux 内核开发的第一原则”在实践中对开发者意味着什么。它补充了《Documentation/admin-guide/reporting-regressions.rst》，该文档从用户的角度讨论了这一主题；如果你从未阅读过那份文本，请至少先快速浏览一下，然后再继续阅读本文。

### 重要部分（即“简而言之”）

1. 确保`回归邮件列表 <https://lore.kernel.org/regressions/>`_（regressions@lists.linux.dev）的订阅者能迅速了解到任何新的回归报告：

    * 当收到一封未抄送给列表的邮件报告时，应立即通过发送一个简短的“回复所有人”，将列表加入抄送范围。
    
2. 将提交到错误追踪系统中的任何报告转发或弹回给列表。
3. 让 Linux 内核回归追踪机器人 “regzbot” 跟踪此问题（这是可选的，但推荐）：

    * 对于邮件报告，检查报告者是否包含了一行如 ``#regzbot introduced: v5.13..v5.14-rc1``。如果没有，请回复一封邮件（列表需要抄送），内容如下，告诉 regzbot 问题开始出现的时间范围：
      
      ```
      #regzbot ^introduced: 1f2e3d4c5b6a
      ```
      
    * 当从错误追踪系统转发报告至回归列表时（见上文），包含以下段落：
      
      ```
      #regzbot introduced: v5.13..v5.14-rc1
      #regzbot from: 某位 N. Ice 人士 <some.human@example.com>
      #regzbot monitor: http://some.bugtracker.example.com/ticket?id=123456789
      ```
      
4. 在提交回归修复补丁时，在补丁说明中添加“Closes:”标签指向所有报告问题的地方，如《Documentation/process/submitting-patches.rst》和 :ref:`Documentation/process/5.Posting.rst <development_posting>` 所要求的。如果你仅修复了导致回归的部分问题，则可以使用“Link:”标签。目前 regzbot 不区分两者。
5. 一旦确定了问题根源，尽快修复回归问题；大多数回归修复应在两周内合并，但有些需要在两到三天内解决。

### 关于开发者相关的 Linux 内核回归问题的所有细节

#### 更详细的基本步骤

##### 收到回归报告时应该做什么

确保 Linux 内核的回归追踪器和其他`回归邮件列表 <https://lore.kernel.org/regressions/>`_（regressions@lists.linux.dev）的订阅者能够了解到任何新报告的回归问题：

 * 如果你收到一封未抄送列表的邮件报告，应立即通过发送一个简短的“回复所有人”，将列表加入抄送范围；尽量确保在回复遗漏了列表的回复时再次将其抄送。
   
* 如果一个提交到错误追踪系统的报告出现在你的收件箱中，应将其转发或弹回给列表。考虑事先检查列表存档，以确认报告者是否已按照《Documentation/admin-guide/reporting-issues.rst》的指示转发了报告。
   
当执行上述操作时，考虑让 Linux 内核回归追踪机器人 “regzbot” 立即开始跟踪问题：

 * 对于邮件报告，检查报告者是否包含了“regzbot 命令”如 ``#regzbot introduced: 1f2e3d4c5b6a``。如果没有，请回复一封邮件（列表需要抄送），内容如下：
   
   ```
   #regzbot ^introduced: v5.13..v5.14-rc1
   ```
   
   这告诉 regzbot 问题开始出现的版本范围；你可以使用提交ID来指定范围，或者如果报告者已经进行了二分查找，可以指定单一提交ID。
   
注意 “^introduced” 前面的符号 (^)：它告诉 regzbot 将父邮件（你回复的那封邮件）视为要跟踪的回归问题的初始报告；这一点很重要，因为 regzbot 后续会寻找带有指向 lore.kernel.org 存档中报告的 “Closes:” 标签的补丁。
当转发到缺陷追踪系统中的回归问题报告时，包含一段带有以下regzbot命令的段落：

       #regzbot introduced: 1f2e3d4c5b6a
       #regzbot from: Some N. Ice Human <some.human@example.com>
       #regzbot monitor: http://some.bugtracker.example.com/ticket?id=123456789

   这样regzbot将会自动将包含指向您的邮件或提及的工单的"Closes:"标签的补丁与该报告关联起来。

修复回归问题时的重要事项
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

提交回归问题的修复时无需做任何特别的事情，只需记住按照Documentation/process/submitting-patches.rst、:ref:`Documentation/process/5.Posting.rst <development_posting>`和Documentation/process/stable-kernel-rules.rst中已经详细解释的内容去做：

 * 使用"Closes:"标签指向所有报告该问题的地方：

       Closes: https://lore.kernel.org/r/30th.anniversary.repost@klaava.Helsinki.FI/
       Closes: https://bugzilla.kernel.org/show_bug.cgi?id=1234567890

   如果您只解决了部分问题，可以使用"Link:"代替，如上述第一个文档中所述。目前regzbot将"Closes:"和"Link:"视为等效，并认为链接的报告已解决。
* 添加一个"Fixes:"标签来指定导致回归的提交
* 如果罪魁祸首是在早期开发周期合并的，则使用``Cc: stable@vger.kernel.org``标签明确标记此修复用于回退
所有这些都是修复回归问题时需要您做的重要工作，因为这些标签对于所有人（包括您自己）在未来几周、几个月甚至几年后查看这些问题时都非常重要。这些标签也是其他内核开发者或Linux发行版使用的工具和脚本的关键；其中一个工具就是regzbot，它严重依赖"Closes:"标签来将回归报告与解决它们的变化关联起来。

修复回归问题的期望和最佳实践
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

作为Linux内核开发者，您被期望尽最大努力避免由您最近的更改导致的回归问题给用户留下以下选择：

 * 运行一个存在影响使用的回归问题的内核
* 切换到较旧或较新的内核版本
* 在识别出回归问题的罪魁祸首三周多后继续运行过时且因此可能不安全的内核。理想情况下这应该少于两周。如果问题很严重或影响许多用户——无论是总体上还是在常见的环境中——则应该只需要几天时间。

如何实际实现这一点取决于各种因素。请将以下的经验法则作为指导：

一般来说：

 * 优先处理回归问题而非其他所有Linux内核工作，除非后者涉及严重问题（例如急性安全漏洞、数据丢失、硬件损坏等）。
* 加快修复最近被正式合并到主线、稳定版或长期支持版本中的回归问题（无论是直接合并还是通过回退的方式）
* 不要将当前周期内的回归问题视为可以等到周期结束时再处理的事情，因为这些问题可能会使用户和持续集成系统现在就测试主线版本变得犹豫不决或者无法进行
* 在处理过程中要格外小心，避免造成额外的或更大的损害，即使这可能意味着解决某个问题所需的时间比下面所述的时间更长
关于时间安排，一旦确定了导致回归问题的原因：

 * 如果问题是严重的或是影响了很多用户——无论是一般情况下还是在特定条件下，如特定硬件环境、发行版或稳定/长期支持系列——目标是在两到三天内将修复方案合并到主线中
* 如果导致问题的原因已经出现在最近的主线、稳定或长期支持版本中（无论是直接还是通过回退的方式），目标是在下下周日之前将修复方案合并到主线中；如果问题在一周早期被发现且容易解决，则尝试在同一周内将修复方案合并到主线中
* 对于其他回归问题，目标是在接下来三周内的最后一个周日之前将修复方案合并到主线中。如果回归问题对用户的影响较小，例如轻微的性能下降，那么在一两个星期后完成也是可以接受的
* 强烈不建议将修复回归问题的工作推迟到下一个合并窗口期，除非修复方案异常危险或者导致问题的原因是在一年前就已经合并到主线中
关于流程：

 * 始终考虑撤销引起问题的变更，因为这通常是最快且最安全的方式来修复回归问题。不必担心之后将修复后的版本合并到主线的问题：通常来说，大部分代码都已经经过了一次审查，因此这个过程应该是直截了当的
* 尽量在当前开发周期结束前解决过去十二个月内主线中引入的所有回归问题：Linus希望这些回归问题能够像当前周期内的问题一样得到处理，除非修复它们存在异常风险
* 如果一个回归问题看起来很复杂，请考虑抄送Linus参与讨论或补丁审查。在紧急或特殊情况中也要这样做——尤其是当子系统的维护者可能无法提供帮助时。同时，如果你知道这类回归问题已经出现在主线、稳定或长期支持版本中，请抄送稳定团队。
* 对于紧急的回归问题，可以考虑请求Linus直接从邮件列表中采纳修复补丁：对于没有争议的修复，他是完全接受这种做法的。不过，这类请求最好与子系统维护者协商一致或直接由他们提出。
* 如果你不确定某个修复在新主线版本发布前几天是否值得冒风险应用，请给Linus发邮件，并抄送给常规列表和相关人员；在邮件中总结情况并请求他考虑直接从列表中采纳该修复。然后他自己可以做出决定，必要时甚至推迟发布。这样的请求同样最好与子系统维护者协商一致或直接由他们提出。
关于稳定版和长期支持内核：

 * 如果回归问题从未在主线出现过或已经在主线得到修复，你可以将这些问题留给稳定团队处理。
* 如果过去十二个月内某个回归问题出现在正式的主线版本中，确保在修复补丁中标注“Cc: stable@vger.kernel.org”，因为仅使用“Fixes:”标签并不能保证回退到旧版本。如果知道引发问题的原因已经被回退到稳定或长期支持内核，请添加相同的标签。
* 当收到关于最近稳定或长期支持内核系列中回归问题的报告时，请至少简要评估该问题是否也可能发生在当前的主线版本中——如果看起来有可能，就接手处理该报告。如果有疑问，请求报告人检查主线版本。
* 如果想要迅速解决最近也出现在主线、稳定或长期支持版本中的回归问题，在主线快速修复它；适当情况下让Linus加速采纳修复（参见上述内容）。这是因为稳定团队通常不会撤销或修复导致主线出现问题的变化。
* 对于紧急的回归修复，你可能希望确保及时回退，可以在修复被合并到主线后通知稳定团队；特别是在合并窗口期间及其后不久，这样做尤其明智，否则修复可能会排在一个巨大的补丁队列末尾。
关于补丁流程：

 * 开发人员，为了达到上述提到的时间段，请记住要考虑到修复补丁被测试、审查以及被Linus合并所需的时间，理想情况下这些补丁应该至少短暂地存在于linux-next中。因此，如果修复很紧急，请明确表示以确保其他人能够适当地处理它。
* 审查人员，恳请您通过及时审查回归修复来帮助开发人员达到上述提到的时间段。
* 子系统维护者，您同样被鼓励加快处理回归修复的速度。因此，评估特定修复是否可以跳过linux-next。根据需要，考虑比平时更频繁地发送git拉取请求。并且尽量避免在周末保留回归修复——特别是当修复被标记为需要回退时。
关于回归问题，开发者应关注的更多方面
-------------------------------------------------

如何处理已知存在回归风险的变化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

评估回归的风险有多大，例如通过在Linux发行版和Git仓库中进行代码搜索。同时考虑向可能受影响的其他开发者或项目询问，让他们评估甚至测试提议的变化；如果发现问题，或许可以找到对所有人都可接受的解决方案。
如果最终回归的风险相对较小，那么继续进行变化，但要让所有相关方了解这一风险。因此，请确保你的补丁描述中明显提及这一点。一旦变化被合并，告诉Linux内核的回归追踪器和回归邮件列表关于这一风险，以便在报告逐渐出现时，每个人都能注意到这个变化。根据风险大小，你可能还想要求子系统维护者在他的主线拉取请求中提及这个问题。

关于回归问题，还有哪些需要了解？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

查阅Documentation/admin-guide/reporting-regressions.rst，它涵盖了你可能想了解的许多其他方面：

* "无回归"规则的目的
* 实际上哪些问题可以视为回归
* 谁负责查找回归的根本原因
* 如何处理棘手的情况，例如当一个回归是由安全修复引起的，或者修复一个回归可能会导致另一个问题

遇到回归问题时应该向谁寻求建议？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

向回归邮件列表(regressions@lists.linux.dev)发送邮件，并抄送给Linux内核的回归追踪器(regressions@leemhuis.info)；如果问题更适合私下解决，可以不包含列表。

更多关于回归追踪和regzbot的信息
------------------------------------------

为什么Linux内核需要回归追踪器，以及为什么使用regzbot？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

像"无回归"这样的规则需要有人确保它们得到遵守，否则它们会被无意或故意地打破。历史证明，对于Linux内核来说也是如此。这就是Thorsten Leemhuis自愿担任Linux内核的回归追踪者的原因，他偶尔会得到其他人的帮助。他们都不是为此而付费的，这就是为什么回归追踪是在尽最大努力的基础上进行的。
之前尝试手动追踪回归证明是一项令人疲惫且令人沮丧的工作，因此过了一段时间就被放弃了。为了防止这种情况再次发生，Thorsten开发了regzbot来简化工作，长期目标是尽可能自动化回归追踪，为所有涉及的人提供便利。
回归追踪与regzbot是如何工作的？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

该机器人监控已跟踪回归报告的回复。此外，它还会寻找引用此类报告的已发布或已提交的补丁，这些报告带有"Closes:"标签；此类补丁发布的回复也会被追踪。
结合这些数据，可以很好地洞察修复过程的当前状态。
regzbot试图以尽可能少的额外负担为报告者和开发者完成其任务。实际上，只有报告者承担着额外的责任：他们需要使用上面概述的`#regzbot introduced`命令告诉regzbot关于回归报告；如果他们没有这样做，其他人可以使用`#regzbot ^introduced`来处理。
对于开发者来说，通常没有额外的工作，他们只需要做一件在regzbot出现之前就期望他们做的事情：在补丁描述中添加指向所有关于所修复问题报告的链接。

我必须使用regzbot吗？
~~~~~~~~~~~~~~~~~~~~~~~~~

如果你使用的话，这对每个人都有好处，因为像Linus Torvalds这样的内核维护者在他们的工作中部分依赖于regzbot的追踪--例如在决定发布新版本或延长开发阶段时。为此，他们需要了解所有未修复的回归；要做到这一点，众所周知，Linus会查看regzbot每周发送的报告。
我是否需要向 regzbot 报告我发现的每一个回归问题？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

理想情况下是的：我们都是人，很容易忘记问题，尤其是当有更重要的事情突然出现时——例如 Linux 内核中出现了更大的问题，或者现实生活中的某些事情让我们暂时远离键盘。因此，最好向 regzbot 报告每一个回归问题，除非你立即编写了修复代码并将其提交到常规合并到受影响内核系列的树中。

如何查看 regzbot 当前跟踪哪些回归问题？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

请检查 `regzbot 的 Web 界面 <https://linux-regtracking.leemhuis.info/regzbot/>`_ 获取最新信息；或者，`搜索最新的回归报告 <https://lore.kernel.org/lkml/?q=%22Linux+regressions+report%22+f%3Aregzbot>`_，regzbot 通常会在每周日傍晚（UTC 时间）发送一次，这通常是在 Linus 发布新（预）版本之前的几个小时。

regzbot 监控哪些地方？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

regzbot 监控最重要的 Linux 邮件列表以及 linux-next、主线和稳定/长期支持版本的 Git 仓库。

regzbot 应该跟踪哪些类型的问题？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

该机器人旨在跟踪回归问题，因此请不要将常规问题牵涉进来。但是如果你使用 regzbot 来跟踪严重问题，比如挂起、数据损坏或内部错误（Panic、Oops、BUG()、warning等），对于 Linux 内核的回归追踪来说是可以接受的。

我可以将 CI 系统发现的回归问题添加到 regzbot 的跟踪列表中吗？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果特定的回归问题可能对实际应用场景产生影响，并因此可能会被用户注意到，那么你可以自由地这样做；因此，请不要为那些不太可能在现实世界使用中出现的理论性回归问题牵涉 regzbot。

如何与 regzbot 交互？
~~~~~~~~~~~~~~~~~~~~~~~~

通过在直接或间接回复包含回归报告的邮件中使用 'regzbot 命令'。这些命令需要单独成段（即：它们需要用空白行与其他邮件内容分开）。

其中一种命令是 ``#regzbot introduced: <版本号或提交记录>``, 这会使 regzbot 将你的邮件视为添加到跟踪列表的回归报告，如上所述；``#regzbot ^introduced: <版本号或提交记录>`` 是另一种命令，它会使 regzbot 将父邮件视为一个开始跟踪的回归报告。

一旦使用了上述两种命令之一，其他 regzbot 命令就可以在直接或间接回复报告中使用。你可以在 `introduced` 命令下方写入它们，或者在使用了其中一个命令或本身就是回复该邮件的邮件中进行回复：

 * 设置或更新标题：

       #regzbot title: 示例标题

 * 监控讨论或 bugzilla.kernel.org 中的工单，其中讨论了问题的其他方面或修复方法——例如发布了一个修复该回归的补丁：

       #regzbot monitor: https://lore.kernel.org/all/30th.anniversary.repost@klaava.Helsinki.FI/

   监控仅适用于 lore.kernel.org 和 bugzilla.kernel.org；regzbot 将认为该线程或工单中的所有消息都与修复过程相关。
 * 指向感兴趣的详细信息的位置，例如邮件列表帖子或 bug 跟踪器中的工单，它们与问题稍有关联但涉及不同的主题：

       #regzbot link: https://bugzilla.kernel.org/show_bug.cgi?id=123456789

 * 标记一个回归已被一个即将上游化或已落地的提交修复：

       #regzbot fix: 1f2e3d4c5d

 * 标记一个回归作为 regzbot 已经跟踪的另一个回归的重复项：

       #regzbot dup-of: https://lore.kernel.org/all/30th.anniversary.repost@klaava.Helsinki.FI/

 * 标记一个回归为无效：

       #regzbot invalid: 不是一个回归，问题一直存在

关于 regzbot 及其命令还有更多说明吗？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

关于 Linux 内核回归追踪机器人的更详细且最新的信息可以在其 `项目页面 <https://gitlab.com/knurd42/regzbot>`_ 上找到，其中包括一个 `入门指南 <https://gitlab.com/knurd42/regzbot/-/blob/main/docs/getting_started.md>`_ 和 `参考文档 <https://gitlab.com/knurd42/regzbot/-/blob/main/docs/reference.md>`_，这两部分涵盖了比上面部分更多的细节。

Linus 关于回归的言论
----------------------

下面是一些关于 Linus Torvalds 对处理回归问题的实际例子：

 * 从 `2017-10-26 (1/2) <https://lore.kernel.org/lkml/CA+55aFwiiQYJ+YoLKCXjN_beDVfu38mg=Ggg5LFOcqHE8Qi7Zw@mail.gmail.com/>`_:

       如果你破坏了现有的用户空间设置，那就是一个回归
说“但我们将会修复用户空间的设置”是不对的。
真的，这是绝对不可以的。

第一条规则是：

- 我们不造成倒退

而其推论是，当倒退确实发生时，我们承认并修复它们，而不是责怪用户空间
你显然在过去三周里一直在否认这个倒退的事实，这意味着我将回滚更改，并且我会停止合并apparmor请求，直到相关人员理解内核开发是如何进行的

* 来自 `2017年10月26日 (2/2)`
  <https://lore.kernel.org/lkml/CA+55aFxW7NMAMvYhkvz1UPbUTUJewRt6Yb51QAx5RtrWOwjebg@mail.gmail.com/>`__` ：

人们应该基本总是感觉到他们可以更新他们的内核，而无需为此担心
我拒绝引入“只有当你同时更新其他程序时才能更新内核”这种限制。如果内核以前对你有用，那么规则就是它继续对你有用
虽然有过例外，但它们寥寥无几，而且它们通常都有重大和根本的原因，基本上是不可避免的，而人们已经尽力避免它们。也许在硬件使用了几十年后，我们实际上无法再实际支持它，因为没有人再用现代内核使用它了。也许我们做事的方式存在严重的安全问题，而人们实际上依赖于那个从根本上讲已经破裂的模型。也许有某些根本性的其他破坏，只是必须有一个标志日，出于非常核心和根本的原因

请注意，这很大程度上关乎打破人们的环境
行为变化会发生，也许我们不再支持某些功能。/proc/<pid>/stat中有一系列字段被打印为零，仅仅是因为它们不再存在于内核中，或者因为显示它们是一个错误（通常是信息泄露）。但是数字被零替换，以便解析这些字段的代码仍然工作。用户可能看不到他们过去看到的所有内容，因此行为明显不同，但事情仍然工作，即使它们可能不再显示敏感（或不再相关）的信息
但如果某事真正破裂，那么变更必须得到修复或回滚。并且在内核中修复。不是说“嗯，然后修复你的用户空间”。是内核更改暴露了问题，需要由内核来修正，因为我们有“原地升级”的模式。我们没有“与新用户空间一起升级”。
并且我严肃地会拒绝接受那些不理解并尊重这条非常简单规则的人所提供的代码。
这条规则也不会改变。
是的，我意识到在这方面内核是“特殊的”。对此我感到自豪。
我见过很多项目，并可以指出它们采取了“我们必须打破某种使用案例以便取得进展”或“你依赖于未文档化的行为，对你来说这很糟糕”或“有更优秀的方式来实现你的需求，而你需要改用这种新方式”的做法，我只是不认为这些做法在非常早期的alpha版本之外是可以接受的，那些版本的实验性用户清楚他们所参与的是什么。近二十年来，内核从未处于那种情况。
我们一直在内核内部进行API破坏。我们会通过说“你现在需要执行XYZ”来解决内部问题，但这是关于内核内部的API，而做这些更改的人显然也必须修复所有内核内部该API的使用者。没有人能说“我现在破坏了你使用的API，现在你得自己去修复它”。谁破坏的东西就得由谁来修复。
我们就是不破坏用户空间。
* 来自 `2020-05-21
   <https://lore.kernel.org/all/CAHk-=wiVi7mSrsMP=fLXQrXK_UimybW=ziLOwSzFTtoXUacWVQ@mail.gmail.com/>`_ ：

       关于回归错误的规则从来都不是关于任何类型的文档化行为，或者代码位于何处的问题。
关于回归错误的规则始终是关于“打破了用户的操作流程”。
用户实际上是唯一重要的东西。
无论多少次说“你不应该使用这个”或“那种行为是未定义的，应用出问题是你自己的错”或“以前之所以能工作只是因为内核的一个bug”，这些说法都完全不相关。
现在，现实从不是完全非黑即白的。所以我们有时会遇到“严重的安全问题”等状况，这迫使我们必须做出改变，可能会破坏用户空间。但即便如此，规则是，我们实际上没有其他选择能让事情继续下去。

显然，如果用户需要几年时间才能注意到某些东西坏了，或者我们有合理的方法来规避这个问题，不会给用户带来太多麻烦（比如，“好吧，只有少数用户受影响，他们可以通过内核命令行来解决”之类的情况），我们也会稍微放宽要求。

但是，不，“那被记录为已损坏”（无论是因为代码在预发布阶段还是因为手册页说了别的）是无关紧要的。如果预发布代码如此有用以至于人们最终开始使用它，这意味着它基本上就是常规的内核代码，只是挂了个“请清理这个”的标签。

另一方面，谈论“API稳定性”的人完全错了。API根本不重要。你可以随意更改任何API——只要没人注意到。

再说一次，回归规则与文档、API或月亮的相位无关，

它完全关于“我们导致了原本工作正常的用户空间出现问题”。

* 来自 `2017年11月5日
   <https://lore.kernel.org/all/CA+55aFzUvbGjD8nQ-+3oiMBx14c_6zOj2n7KLN3UsJ-qsd4Dcw@mail.gmail.com/>`_ ：

       我们的回归规则从来不是“行为不变”
那样的话，我们将永远无法做出任何改变。

例如，我们会经常做像添加新的错误处理等工作，有时甚至会在我们的kselftest目录中为此添加测试。

所以很明显，行为一直在变化，我们并不认为这是回归本身。
回归规则对于内核来说是这样的：某些实际的用户工作流程被中断了。不是某个测试，也不是“看，我以前能做X，现在不能了”。

来自`2018年8月3日
<https://lore.kernel.org/all/CA+55aFwWZX=CXmWDTkDGb36kf12XmTehmQjbiMPCqCRG2hi9kw@mail.gmail.com/>`_：

你们遗漏了内核的头号规则：
我们不进行回归，并且之所以不回归是因为你完全错了。
而你提出自己观点的原因实际上恰恰说明了你为何错得离谱。
你的那些“正当理由”纯粹是一派胡言。
“我们不进行回归”的核心意义在于让用户可以升级内核而无需担心任何问题。
> 内核有一个已被修复的bug

这一点完全无关紧要。
各位，某个功能是否有bug并不重要。
为什么？

因为bug总会发生，这是生活的现实。认为“我们必须中断某些功能来修复一个bug”的论点完全是荒谬的。我们每天都会修复数十个bug，认为“修复一个bug”就意味着可以中断某些功能的想法根本站不住脚。
因此，bug与这个讨论根本无关。它们会发生，会被发现，会被修复，但这与“我们破坏了用户体验”毫无关系。
因为唯一重要的就是用户。
这难道很难理解吗？

任何使用“但它有漏洞”作为论据的人完全错过了重点。从用户的角度来看，它并没有什么漏洞——它对他/她来说是管用的。
也许它之所以能用是因为用户已经把漏洞考虑在内了，
也许它之所以能用是因为用户没有注意到——再说一遍，这都不重要。它对用户来说是管用的。
为了一个“漏洞”而破坏用户的使用流程绝对是你能想象到的最糟糕的理由。
这基本上就是在说“我拿了一个能用的东西，然后我把它弄坏了，
但现在它更好了”。你难道看不出这句话有多么疯狂吗？

如果没有用户，你的程序就不是程序，它只是一段毫无意义的代码，你还不如直接扔掉。
真的。这就是为什么内核开发的第一条规则是“我们不破坏用户”的原因。因为“我修复了一个漏洞”绝对不是一个论据，如果这个漏洞修复破坏了用户的设置的话。你实际上是通过“修复”一个用户显然并不在乎的问题引入了一个更大得多的漏洞。

而且见鬼的是，我们一直在升级内核而不升级其他任何程序。这是绝对必要的，因为标志日和依赖关系非常糟糕。
这也是必要的，仅仅因为我作为一个内核开发者，在开发内核时并不会去升级我不关心的其他随机工具，并且我希望我的任何用户在做同样的事情时都能感到安全。

所以不行。你的规则是完全错误的。如果你不能在不升级其他某个随机二进制文件的情况下升级内核，那么我们就存在问题。
来自`2021-06-05
<https://lore.kernel.org/all/CAHk-=wiUVqHN76YUwhkjZzwTdjMMJf_zN4+u7vEJjmEGh3recw@mail.gmail.com/>`_ ：

没有任何有效的理由来支持倒退。
诚实地讲，安全人员需要明白，“无法工作”并不是安全的成功案例。它是一个失败的情况。
是的，“无法工作”可能是安全的。但在这种情况下，这种安全性是*毫无意义的*。

来自 `2011-05-06 (1/3)
   <https://lore.kernel.org/all/BANLkTim9YvResB+PwRp7QTK-a5VNg2PvmQ@mail.gmail.com/>`_:

    二进制兼容性更为重要
如果二进制文件没有使用接口来解析格式（或者只是解析错误——请参阅最近添加UUID到/proc/self/mountinfo的例子），那么这就是一种倒退。
而倒退会被撤销，除非存在安全问题或类似情况让我们不得不承认“哦天哪，我们真的必须破坏一些东西”。
我不明白为什么这个简单的逻辑对某些内核开发者来说如此难以理解。现实很重要。你的个人愿望根本不重要。
如果你创建了一个无需解析接口描述就能使用的接口，那么我们就只能接受这个接口。理论根本不重要。
你可以帮助修复这些工具，并尝试通过这种方式避免兼容性问题。这样的问题其实并不多。

来自 `2011-05-06 (2/3)
   <https://lore.kernel.org/all/BANLkTi=KVXjKR82sqsz4gwjr+E0vtqCmvA@mail.gmail.com/>`_:

    这显然不是内部追踪点。根据定义。它被powertop所使用。

来自 `2011-05-06 (3/3)
   <https://lore.kernel.org/all/BANLkTinazaXRdGovYL7rRVp+j6HbJ7pzhg@mail.gmail.com/>`_:

    我们有一些程序依赖于这个ABI，因此如果它们出问题就是一种倒退。
* 从 `2012-07-06 <https://lore.kernel.org/all/CA+55aFwnLJ+0sjx92EGREGTWOx84wwKaraSzpTNJwPVV8edw8g@mail.gmail.com/>`_：

       > 这让我开始思考，Debian的_unstable_版本是否真的可以算作标准的用户空间发行版。
哦，如果内核破坏了一些标准的用户空间，那确实算数。很多人在运行Debian的unstable版本。

 * 从 `2019-09-15
   <https://lore.kernel.org/lkml/CAHk-=wiP4K8DRJWsCo=20hn_6054xBamGKF2kPgUzpB5aMaofA@mail.gmail.com/>`_：

       特别是最后时刻的回滚是发布前最顶层的提交（忽略版本变更本身），虽然这非常烦人，但也许也有教育意义。
关于它有教育意义的是，我回滚了一个实际上没有bug的提交。事实上，它正好完成了它的目标，并且做得非常好。事实上，它做得_如此_好，以至于它改进的I/O模式最终揭示了由于一个完全不相关领域的真实bug导致的用户可见的倒退。
这次倒退的具体细节并不是我指出这个回滚具有教育意义的原因。更多的是，这是一个例子，说明什么算是倒退，以及整个“无倒退”内核规则意味着什么。被回滚的提交没有改变任何API，也没有引入新的bug。但它最终暴露了另一个问题，因此导致用户的内核升级失败。所以它被回滚了。
这里的关键在于，我们基于用户报告的_行为_进行回滚，而不是基于“它改变了ABI”或“它导致了一个bug”的概念。
问题实际上是早已存在的，只是碰巧之前没有触发。改变带来的更好I/O模式碰巧暴露了一个旧的bug，人们已经依赖于那个旧问题之前无害的行为。
而无需担心，一旦我们决定如何处理我们与一个人们碰巧依赖其附带行为的接口之间的不良交互，我们将重新引入改善I/O模式的修复。这只是我们必须解决如何做到这一点（有三位不同开发者提出的三个不同补丁正在讨论中，可能还会有更多……）。在此期间，即使我希望它将在我们对它暴露的问题达成共识后重新引入（甚至作为稳定的补丁回溯），我还是在这个版本中回滚了暴露问题给用户的部分。
从整个事情中得到的教训是：这不在于你是否改变了内核-用户空间的ABI，或者修复了一个bug，或者老代码“本来就不应该首先工作”。关键在于某事是否打破了现有用户的工作流程。
无论如何，这是我对整个倒退问题的小插曲。因为它是“内核编程的第一法则”，我觉得也许偶尔提一下是值得的。

.
end-of-content
.
此文本依据 GPL-2.0+ 或 CC-BY-4.0 许可证提供，具体如文件顶部所述。如果您只想根据 CC-BY-4.0 分发此文本，请将 "The Linux kernel developers" 作为作者归属，并将以下链接作为来源：
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/process/handling-regressions.rst

注意：只有在 Linux 内核源码中找到的此 RST 文件内容才依据 CC-BY-4.0 提供，因为经过处理（例如由内核构建系统处理）的此文本版本可能包含来自使用更严格许可证的文件的内容。
