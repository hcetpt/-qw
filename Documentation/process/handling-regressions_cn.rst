### SPDX 许可证标识符：(GPL-2.0+ 或 CC-BY-4.0)
### 另请参阅本文件底部的附加再分发信息
处理回归问题
++++++++++++++

*我们不会导致回归问题* —— 本文档描述了“Linux 内核开发的第一原则”在实践中对开发者的含义。它补充了《Documentation/admin-guide/reporting-regressions.rst》，该文档从用户的角度讨论了这一主题；如果你从未阅读过那份文本，请至少先快速浏览一下，然后再继续阅读这里的内容。
重要部分（即“简要概括”）
========================

1. 确保`回归邮件列表 <https://lore.kernel.org/regressions/>`_ （regressions@lists.linux.dev）的订阅者能够迅速了解任何新的回归报告：

   - 当收到未抄送给列表的邮件报告时，应立即通过发送至少包含简短“回复所有人”的邮件将它加入循环，并抄送列表。
   
2. 将提交到错误追踪器中的所有报告转发或弹回到列表中。

3. 让 Linux 内核回归跟踪机器人 "regzbot" 跟踪此问题（这是可选的，但推荐）：

   - 对于邮件报告，检查报告者是否已包含一行如 ``#regzbot introduced: v5.13..v5.14-rc1`` 的内容。如果没有，发送一个回复（抄送回归列表），包含以下段落，告知 regzbot 问题开始出现的时间点：
     
     ```
     #regzbot ^introduced: 1f2e3d4c5b6a
     ```

   - 当从错误追踪器转发报告到回归列表时（参见上述），包括以下段落：
     
     ```
     #regzbot introduced: v5.13..v5.14-rc1
     #regzbot from: 某个 N. Ice 人类 <some.human@example.com>
     #regzbot monitor: http://some.bugtracker.example.com/ticket?id=123456789
     ```

4. 在提交回归问题的修复时，在补丁说明中添加“Closes:”标签指向所有报告该问题的地方，正如《Documentation/process/submitting-patches.rst》和 :ref:`Documentation/process/5.Posting.rst <development_posting>` 所要求的那样。如果你只解决了引起回归的部分问题，则可以使用“Link:”标签。目前 regzbot 不区分这两种标签。

5. 一旦确定了问题的根源，应尽快修复回归问题；大多数回归问题的修复应在两周内合并，但有些需要在两到三天内解决。

关于开发者相关的 Linux 内核回归问题的所有细节
==================================================

更详细的基本要点
-------------------

### 收到回归报告时应采取的行动

确保 Linux 内核的回归追踪器和其他`回归邮件列表 <https://lore.kernel.org/regressions/>`_（regressions@lists.linux.dev）的订阅者能迅速了解到任何新报告的回归问题：

- 如果你收到一封没有抄送列表的报告邮件，应立即通过发送至少包含简短“回复所有人”的邮件将其加入循环；尽量确保在回复遗漏列表的回复时再次抄送列表。
  
- 如果一个提交到错误追踪器的报告进入了你的收件箱，将其转发或弹回到列表中。考虑事先检查列表存档，以确认报告者是否已经按照《Documentation/admin-guide/reporting-issues.rst》中的指示进行了转发。

在进行这些操作时，考虑让 Linux 内核回归跟踪机器人 "regzbot" 立即开始跟踪该问题：

- 对于邮件报告，检查报告者是否包含了一个“regzbot 命令”，例如 ``#regzbot introduced: 1f2e3d4c5b6a``。如果没有，发送一个回复（抄送回归列表），包含如下段落：
  
  ```
  #regzbot ^introduced: v5.13..v5.14-rc1
  ```

  这告诉 regzbot 问题开始出现的版本范围；你可以使用提交 ID 来指定范围，或者如果报告者进行了二分查找定位问题根源，可以指定单一提交 ID。
  
注意在 “introduced” 前面的尖括号(^)：这告诉 regzbot 将其作为回复的邮件视为所希望跟踪的回归问题的初始报告；这一点很重要，因为 regzbot 后续会寻找带有“Closes:”标签并指向存档在 lore.kernel.org 上的报告的补丁。
当转发到缺陷追踪系统中的回归问题报告时，包含一段带有以下regzbot命令的段落：

       #regzbot introduced: 1f2e3d4c5b6a
       #regzbot from: Some N. Ice Human <some.human@example.com>
       #regzbot monitor: http://some.bugtracker.example.com/ticket?id=123456789

   这样regzbot将会自动将包含指向您的邮件或提及的工单的"Closes:"标签的补丁与该报告关联起来。

修复回归问题时的重要事项
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

提交回归问题的修复时无需做任何特别的事情，只需记住按照Documentation/process/submitting-patches.rst、:ref:`Documentation/process/5.Posting.rst <development_posting>`和Documentation/process/stable-kernel-rules.rst中已经详细解释的内容去做：

 * 使用"Closes:"标签指向所有报告该问题的地方：

       Closes: https://lore.kernel.org/r/30th.anniversary.repost@klaava.Helsinki.FI/
       Closes: https://bugzilla.kernel.org/show_bug.cgi?id=1234567890

   如果您只是修复了问题的一部分，则可以使用"Link:"代替，如上述第一份文档所述。目前regzbot对这两种标签等同处理，并认为链接的报告已得到解决。
* 添加一个"Fixes:"标签来指定导致回归的提交
* 如果罪魁祸首是在早期开发周期合并的，则使用``Cc: stable@vger.kernel.org``标签明确标记此修复以供回退
所有这些都是期望您做的，对于回归问题来说非常重要，因为这些标签对于未来几周、几个月甚至几年后可能关注此问题的每个人（包括您自己）都有很大的价值。这些标签对于其他内核开发者或Linux发行版使用的工具和脚本也是至关重要的；其中一个工具就是regzbot，它严重依赖于"Closes:"标签来将回归报告与解决它们的变化相关联。

修复回归问题的期望和最佳实践
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

作为Linux内核开发者，您被期望尽最大努力避免由于您最近的更改导致的回归问题让用户只能选择：

 * 运行一个存在影响使用的回归问题的内核
* 切换到一个较旧或较新的内核版本
* 在识别出回归问题的罪魁祸首超过三周后继续运行一个过时且因此可能存在安全风险的内核。理想情况下，这应该少于两周。如果问题是严重的或者影响了许多用户——无论是总体上还是在普遍环境中——那么这个时间应当只是一两天。

如何在实践中实现这一点取决于各种因素。以下的一些经验法则可以作为指导：
一般来说：

 * 将回归问题的工作优先于所有其他Linux内核工作，除非后者涉及一个严重的问题（例如急性安全漏洞、数据丢失、硬件损坏等）。
* 加快修复最近被正式合并到主线、稳定版或长期支持版本中的主线回归问题（无论是直接还是通过回退的方式）
* 不要将当前周期内的回归问题视为可以等到周期结束时再处理的事情，因为这些问题可能会使用户和持续集成系统现在或一般情况下测试主线变得犹豫不决或无法进行
* 在工作时保持必要的谨慎，以避免造成额外的或更大的损害，即使这样可能需要比下面概述的时间更长来解决一个问题
关于时间安排，一旦确定了回归问题的原因：

 * 如果问题严重或影响了很多用户——无论是一般情况还是在特定环境下，如某种硬件环境、发行版或稳定/长期系列——目标是在两到三天内将修复程序合并到主线
* 如果问题出现在最近的主线、稳定版或长期支持版本中（无论是直接还是通过回退的方式），目标是在下一个周日之后的一周内将修复程序合并到主线；如果问题在一个星期的早期就被发现并且很容易解决，尝试在同一个星期内将修复程序合并到主线
* 对于其他回归问题，目标是在接下来三周内最后一个周日前将修复程序合并到主线。如果回归问题对人们的生活影响不大——例如轻微的性能下降——那么在一到两周后进行也是可以接受的
* 强烈不建议将回归问题的修复推迟到下一个合并窗口期，除非该修复极其冒险或者问题原因被合并到主线已经超过一年
关于流程：

 * 始终考虑撤销引起问题的更改，因为它往往是最快且最安全的修复回归问题的方法。不必担心稍后将修复后的版本合并到主线：这通常很简单，因为大部分代码已经经过了一次审查
* 尽量在当前开发周期结束前解决过去十二个月内主线中引入的任何回归问题：Linus希望这类回归问题能像当前周期的问题一样得到处理，除非修复存在非同寻常的风险
* 如果回归问题看起来很复杂，在讨论或补丁审查时可以抄送Linus。在特别危险或紧急的情况下也应这样做——特别是如果子系统的维护者可能无法提供帮助时。当您知道这样的回归问题已经被合并到主线、稳定版或长期支持版本时，请同时抄送稳定团队。
* 对于紧急的回归问题，可以考虑请求Linus直接从邮件列表中采纳修复补丁：对于没有争议的修复，他是完全接受这种做法的。不过，这类请求最好与子系统维护者协商一致或直接由他们提出。
* 如果你不确定某个修复在新主线版本发布前几天是否值得冒风险应用，请给Linus发邮件，并抄送给常规列表和相关人员；在邮件中总结情况并请求他考虑直接从列表中采纳该修复。然后他自己可以做出决定，在必要时甚至推迟版本发布。这样的请求同样最好与子系统维护者协商一致或直接由他们提出。
关于稳定版和长期支持内核：

 * 如果回归问题从未在主线出现过或已经在主线修复，则你可以将这些问题留给稳定团队处理。
* 如果过去十二个月内某个回归问题出现在正式的主线版本中，确保在修复补丁中标注“Cc: stable@vger.kernel.org”，因为仅使用“Fixes:”标签并不能保证回退到旧版本。如果知道引发问题的变更已经回退到稳定或长期支持内核，请添加相同的标注。
* 收到最近稳定或长期支持内核系列中的回归问题报告时，请至少简要评估该问题是否也可能发生在当前主线版本中——如果看起来可能的话，请接手处理该报告。如果有疑问，要求报告者检查主线版本。
* 如果希望迅速解决最近也出现在主线、稳定或长期支持内核中的回归问题，请尽快在主线修复它；在适当的情况下让Linus加速处理该修复（见上文）。这是因为稳定团队通常不会撤销或修复在主线引起相同问题的变更。
* 对于紧急的回归修复，你可能希望确保快速回退，可以在修复被纳入主线后及时通知稳定团队；这尤其适用于合并窗口期间及其之后不久，否则该修复可能会排在一个庞大的补丁队列末尾。
关于补丁流程：

 * 开发者们，在尝试达到上述时间框架时，请记得考虑到修复补丁需要测试、审查及被Linus合并的时间，理想情况下这些补丁应该至少短暂地包含在linux-next中。因此，如果一个修复很紧急，请明确表示以确保其他人能够适当地处理它。
* 审查者们，我们恳请你们协助开发者按时达到上述时间框架，通过及时审查回归修复补丁来提供帮助。
* 子系统维护者们，我们也鼓励你们加快处理回归修复的速度。因此，请评估特定修复是否可以跳过linux-next。此外，在需要时，考虑比平常更频繁地发送git拉取请求。并且尽量避免在周末保留回归修复——特别是当修复被标记为需要回退时。
关于回归问题，开发者应关注的更多方面
----------------------------------------------------------------


如何处理已知存在回归风险的变化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

评估回归的风险有多大，例如通过在 Linux 发行版和 Git 代码库中进行代码搜索。同时考虑询问可能受影响的其他开发者或项目来评估甚至测试提议的变化；如果出现问题，或许可以找到各方都能接受的解决方案。
如果最终回归的风险相对较小，那么可以继续进行变化，但要让所有相关方了解这种风险。因此，请确保你的补丁说明明确指出这一点。一旦变更被合并，请告知 Linux 内核的回归追踪器和回归邮件列表有关该风险的信息，以便在收到报告时大家都能注意到这个变更。根据风险大小，你也可以要求子系统的维护者在他的主线拉取请求中提及这个问题。
关于回归还有哪些需要了解的？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

请参阅 `Documentation/admin-guide/reporting-regressions.rst` ，它涵盖了你可能希望了解的许多其他方面：

* “无回归”规则的目的

* 哪些问题实际上属于回归

* 谁负责查找回归的根本原因

* 如何处理棘手的情况，例如当一个回归是由安全修复引起的，或者修复一个回归可能会导致另一个回归

遇到回归问题时应该向谁寻求建议？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

发送邮件到回归邮件列表（regressions@lists.linux.dev），并抄送 Linux 内核的回归追踪器（regressions@leemhuis.info）；如果问题更适合私下处理，请随意不将邮件列表包含在内。
关于回归追踪和 regzbot 的更多信息
------------------------------------------

为什么 Linux 内核需要回归追踪器，为什么使用 regzbot？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

像“无回归”这样的规则需要有人确保它们得到遵守，否则这些规则可能会被意外或故意破坏。历史已经证明了这一点对于 Linux 内核也是如此。这就是为什么 Thorsten Leemhuis 自愿担任 Linux 内核回归追踪器的角色，他偶尔会得到其他人的帮助。他们都不是为此而获得报酬的，因此回归追踪是尽力而为的工作。
之前的尝试手动追踪回归显示这是一项令人疲惫且沮丧的工作，因此这些尝试最终被放弃了。为了避免这种情况再次发生，Thorsten 开发了 regzbot 来简化工作，并且长期目标是尽可能自动化回归追踪流程。
回归追踪与 regzbot 如何运作？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

机器人监视跟踪回归报告的回复。此外，它还会留意包含“Closes:”标签、指向此类报告的已发布或已提交的补丁；对这类补丁发布的回复也被追踪。
结合这些数据能够很好地洞察当前修复过程的状态。
regzbot 尽量减少对报告者和开发者的额外负担。事实上，只有报告者需要承担一项额外职责：使用上面概述的 `#regzbot introduced` 命令通知 regzbot 关于回归报告；如果他们没有这样做，则其他人可以使用 `#regzbot ^introduced` 来处理。
对开发者而言通常不需要额外的工作，他们只需要确保做一件在 regzbot 出现之前就已经期望的事情：在补丁描述中添加指向所有有关该问题报告的链接。
我必须使用 regzbot 吗？
~~~~~~~~~~~~~~~~~~~~~~~~~

如果你使用的话，这对每个人都有好处，因为像 Linus Torvalds 这样的内核维护者部分依赖于 regzbot 的追踪工作——例如在决定发布新版本或延长开发阶段时。为了做出这些决策，他们需要了解所有未解决的回归；为此，Linus 会查看 regzbot 每周发送的报告。
我是否需要向 regzbot 报告我发现的每一个回归问题？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

理想情况下是的：我们都是人，很容易忘记问题，尤其是当有更重要的事情突然出现时——例如 Linux 内核中出现了更大的问题，或者现实生活中的某些事情让我们暂时远离键盘。因此，最好向 regzbot 报告每一个回归问题，除非你立即编写了修复代码并将其提交到常规合并到受影响内核系列的树中。

如何查看 regzbot 当前跟踪哪些回归问题？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

请检查 `regzbot 的 Web 界面 <https://linux-regtracking.leemhuis.info/regzbot/>`_ 获取最新信息；或者，`搜索最新的回归报告 <https://lore.kernel.org/lkml/?q=%22Linux+regressions+report%22+f%3Aregzbot>`_，regzbot 通常会在每周日傍晚（协调世界时）发送一次，这通常是在 Linus 发布新的（预）版本之前的几个小时。

regzbot 监控哪些地方？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

regzbot 监视最重要的 Linux 邮件列表以及 linux-next、主线和稳定/长期维护版本的 Git 仓库。

regzbot 应该追踪哪种类型的问题？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

该机器人旨在追踪回归问题，因此请不要将 regzbot 涉及到普通问题中。但是如果你使用 regzbot 来追踪严重问题，比如关于挂起、数据损坏或内部错误（如 Panic、Oops、BUG()、warning等）的报告，则适用于 Linux 内核的回归追踪器。

我可以将持续集成系统发现的回归问题添加到 regzbot 的追踪列表中吗？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果特定的回归问题可能对实际使用场景产生影响，并且因此可能会被用户注意到，请随意这样做。因此，请不要为那些不太可能在现实使用中显现出来的理论上的回归问题涉及 regzbot。

如何与 regzbot 交互？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

通过在直接或间接回复包含回归报告邮件中使用 "regzbot 命令"。这些命令需要位于独立的段落中（也就是说，它们需要用空白行与其他邮件内容分开）。

其中一个命令是 ``#regzbot introduced: <版本或提交>``, 这会让 regzbot 将您的邮件视为添加到追踪列表的回归报告，正如上面所述；``#regzbot ^introduced: <版本或提交>`` 是另一个这样的命令，它会让 regzbot 将父邮件视为一个开始追踪的回归问题报告。

一旦使用了上述两个命令之一，其他 regzbot 命令就可以在直接或间接回复报告时使用。您可以在 `introduced` 命令下方写入这些命令，或者在使用其中一个命令或作为其回复的邮件中：

 * 设置或更新标题：

       #regzbot title: 示例

 * 监控讨论或 bugzilla.kernel.org 中关于问题的附加方面或修复方法的票证——例如，发布修复该回归问题的补丁：

       #regzbot monitor: https://lore.kernel.org/all/30th.anniversary.repost@klaava.Helsinki.FI/

   监控仅适用于 lore.kernel.org 和 bugzilla.kernel.org；regzbot 将认为该线程或票证中的所有消息都与修复过程有关。
 * 指向与问题稍有关联但属于不同主题的详情位置，例如邮件列表帖子或 bug 跟踪器中的票证：

       #regzbot link: https://bugzilla.kernel.org/show_bug.cgi?id=123456789

 * 标记一个回归问题已被一个即将或已合并到上游的提交修复：

       #regzbot fix: 1f2e3d4c5d

 * 标记一个回归问题是 regzbot 已经追踪的另一个回归问题的重复：

       #regzbot dup-of: https://lore.kernel.org/all/30th.anniversary.repost@klaava.Helsinki.FI/

 * 标记一个回归问题为无效：

       #regzbot invalid: 不是回归问题，问题一直存在

有关 regzbot 及其命令还有更多内容吗？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

关于 Linux 内核回归追踪机器人的更详细和最新的信息可以在其 `项目页面 <https://gitlab.com/knurd42/regzbot>`_ 上找到，其中包括一个 `入门指南 <https://gitlab.com/knurd42/regzbot/-/blob/main/docs/getting_started.md>`_ 和 `参考文档 <https://gitlab.com/knurd42/regzbot/-/blob/main/docs/reference.md>`_，这两份文档都涵盖了比上述部分更多的细节。

Linus 对于回归问题的观点摘录
----------------------------------

下面是一些现实生活中的例子，展示了 Linus Torvalds 对于如何处理回归问题的看法：

 * 从 `2017-10-26 (1/2)
   <https://lore.kernel.org/lkml/CA+55aFwiiQYJ+YoLKCXjN_beDVfu38mg=Ggg5LFOcqHE8Qi7Zw@mail.gmail.com/>`_：

       如果你破坏了现有的用户空间设置，那就是一个回归问题。
说“但我们将会修复用户空间的设置”是不对的。
真的，这是不对的。
[...]

第一条规则是：

- 我们不引入退化

其推论是，当退化确实发生时，我们应该承认并修复它们，而不是责怪用户空间。
你显然在过去三周里一直在否认这个退化问题，这意味着我将会撤销相关更改，并且我会停止合并 AppArmor 的请求，直到相关人员理解内核开发的基本原则。

* 来自 `2017-10-26 (2/2)
   <https://lore.kernel.org/lkml/CA+55aFxW7NMAMvYhkvz1UPbUTUJewRt6Yb51QAx5RtrWOwjebg@mail.gmail.com/>`_ ：

人们基本上应该始终感觉他们可以更新内核而无需担心任何问题。
我拒绝引入“只有在同时更新其他程序的情况下才能更新内核”这类限制。如果内核过去对你有效，那么它就应该继续有效。
虽然存在例外情况，但这些情况非常罕见，通常都有重大和根本性的原因导致，而且人们已经尽力避免了这些问题。也许我们无法再实际支持那些使用了几十年且不再与现代内核一起使用的硬件。也许我们的做法存在严重的安全问题，而人们实际上依赖于那种从根本上就存在问题的模型。也许存在某些根本性的故障，必须通过标志日(flag day)来解决。

需要注意的是，这主要是关于破坏人们的环境的问题。
行为变化会发生，也许我们不再支持某些功能。/proc/<pid>/stat 中有许多字段现在被打印为零，仅仅是因为它们在内核中已不存在，或者因为显示它们是一个错误（通常是信息泄露）。但是这些数字被零替换，以便解析这些字段的代码仍然能工作。用户可能看不到他们过去能看到的所有信息，因此行为明显不同，但事情依然能够运行，即使它们可能不再显示敏感或不再相关的数据。

但如果某些东西真正地损坏了，那么更改必须得到修复或撤销。并且这种修复是在内核中进行的。不是说“好吧，那你去修复你的用户空间”。是内核更改暴露了问题，所以需要由内核来纠正这个问题，因为我们有一个“原地升级”的模式。我们没有一个“与新的用户空间一起升级”的模式。
并且我严肃地会拒绝接受那些不理解并尊重这条非常简单规则的人所提供的代码。
这条规则也不会改变。
是的，我意识到在这方面内核是“特殊的”。我为此感到自豪。
我见过很多项目，并可以指出它们采取了这样的做法：“我们必须打破某种使用场景以便取得进展”，或者“你依赖于未文档化的行为，这对你来说很糟糕”，又或者是“有更优秀的方式来实现你的需求，而你需要去适应这种新的更优方式”，我只是不认为这种做法在非常早期的alpha版本之外是可以接受的，这些版本的用户知道他们参与的是实验性的项目。在过去二十年里，内核从未处于这种情况。
我们一直在内核内部进行API破坏。我们会通过说“你现在需要做XYZ”来解决内部问题，但这是关于内核内部的API，而这样做的人显然也需要修复所有该API在内核中的使用者。没有人能说“我现在打破了你使用的API，现在你需要自己去修复它”。谁破坏了什么，谁就需要去修复它。
而我们就是不破坏用户空间。
* 来自 `2020-05-21
   <https://lore.kernel.org/all/CAHk-=wiVi7mSrsMP=fLXQrXK_UimybW=ziLOwSzFTtoXUacWVQ@mail.gmail.com/>`_ ：

       关于回归错误的规则从来不是关于任何文档化的行为，也不是关于代码所在的位置。
关于回归错误的规则始终是关于“是否打断了用户的操作流程”。
用户实际上是唯一重要的东西。
没有任何“你不应该使用这个”或“那种行为是未定义的，应用出问题是你的责任”或“那之所以以前能工作只是因为内核的一个bug”的说法是相关的。
现在，现实永远不会完全是非黑即白的。因此我们会有像“严重的安全问题”等状况，这迫使我们必须做出可能会破坏用户空间的更改。但即便如此，规则是除了这些更改外我们实际上没有其他选择能让事情继续进行。

显然，如果用户需要几年时间才能注意到某些东西坏了，或者我们有合理的方法来规避这些问题，而这对用户来说并不造成太大麻烦（也就是说，“好的，只有少数几个用户受到影响，并且他们可以通过内核命令行来规避这个问题”这样的情况），我们的规定也会稍微宽松一些。

但是，“那已被记录为有问题”（无论是因为代码处于实验阶段还是因为手册页面上写着别的内容）都是无关紧要的。如果实验阶段的代码如此有用以至于人们最终开始使用它，这意味着它基本上就是常规的内核代码，只是标了一个“请清理这个”的标志而已。

另一方面，谈论“API稳定性”的人完全错了。API其实也不重要。你可以随意更改任何API——只要没有人注意到就行。

再次强调，回归规则不是关于文档、不是关于API，也不是关于月亮的相位。

它完全关乎“我们给曾经正常工作的用户空间带来了问题”。

* 来自 `2017年11月5日
   <https://lore.kernel.org/all/CA+55aFzUvbGjD8nQ-+3oiMBx14c_6zOj2n7KLN3UsJ-qsd4Dcw@mail.gmail.com/>`_ ：

       我们的回归规则从来都不是“行为不能改变”

那意味着我们将永远无法做出任何改动。
例如，我们会经常做诸如添加新的错误处理等工作，有时甚至会在我们的kselftest目录中为此添加测试。

所以很明显，行为一直在变化，我们并不认为这是一种回归本身。
回归规则对于内核来说是这样的：某些实际的用户工作流程被中断了。不是某个测试，也不是“看，我以前能够做X，现在不能了”。

来自`2018年8月3日
<https://lore.kernel.org/all/CA+55aFwWZX=CXmWDTkDGb36kf12XmTehmQjbiMPCqCRG2hi9kw@mail.gmail.com/>`_：

你们遗漏了内核的头号规则：
我们不进行回归，并且之所以不回归是因为你完全错了。
而你提出自己观点的原因实际上恰恰说明了为什么你是错的。
你的所谓“正当理由”完全是无稽之谈。
“我们不进行回归”的整个意义就在于让用户可以升级内核而不必担心任何问题。
> 内核有一个bug已经被修复

这一点完全无关紧要。
各位，无论某样东西是否有bug都无关紧要。
为什么？

因为bug总是会出现的，这是生活的事实。争论说“我们必须破坏某些东西因为我们正在修复一个bug”完全是疯狂的。我们每天都会修复数十个bug，认为“修复一个bug”就意味着我们可以破坏某些东西的想法根本就是不对的。
因此，bug与讨论根本无关。它们出现，被发现，然后被修复，这与“我们破坏用户使用体验”毫无关系。
因为唯一重要的就是用户。
这难道很难理解吗？

任何使用“但它有漏洞”作为论据的人完全错过了重点。从用户的角度来看，它并没有什么漏洞——它对他/她来说是管用的。
也许它之所以能用是因为用户已经把漏洞考虑在内了，
也许它之所以能用是因为用户没有注意到——再说一遍，这都不重要。它对用户来说是管用的。
为了一个“漏洞”而破坏用户的使用流程绝对是你能想象到的最糟糕的理由。
这基本上就是在说“我拿了一个能用的东西，然后我把它弄坏了，
但现在它更好了”。你难道看不出这句话有多么疯狂吗？

如果没有用户，你的程序就不是程序，它只是一段毫无意义的代码，你还不如直接扔掉。
真的。这就是为什么内核开发的头号规则是“我们不破坏用户”的原因。因为“我修复了一个漏洞”绝不是一个论据，如果这个漏洞的修复破坏了用户的配置的话。你实际上通过“修复”一个用户明显不在乎的东西引入了一个更大的漏洞。

而且，我们一直在升级内核而不升级其他任何程序。这是绝对必要的，因为标志日和依赖关系非常糟糕。
这也是必要的，仅仅因为我作为一个内核开发者，在开发内核时不会去升级我不关心的随机其他工具，并且我希望我的任何用户都能感到安全地做同样的事情。

所以不行。你的规则是完全错误的。如果你不能在不升级其他某个随机二进制文件的情况下升级内核，那么我们就有了问题。
来自`2021年6月5日
<https://lore.kernel.org/all/CAHk-=wiUVqHN76YUwhkjZzwTdjMMJf_zN4+u7vEJjmEGh3recw@mail.gmail.com/>`_ ：

没有任何合理的理由可以为倒退辩护。
诚实地讲，安全人员需要明白，“无法工作”并不是安全的成功案例。它是一个失败的情况。
是的，“无法工作”可能是安全的。但在这种情况下，这种安全性是*毫无意义的*。

来自 `2011-05-06 (1/3)
   <https://lore.kernel.org/all/BANLkTim9YvResB+PwRp7QTK-a5VNg2PvmQ@mail.gmail.com/>`_:

    二进制兼容性更为重要
如果二进制文件没有使用接口来解析格式（或者只是解析错误——请参阅最近添加UUID到/proc/self/mountinfo的例子），那么这就是一种倒退。
而倒退会被撤销，除非存在安全问题或类似情况让我们不得不承认“哦天哪，我们真的必须破坏一些东西”。
我不明白为什么这个简单的逻辑对某些内核开发者来说如此难以理解。现实很重要。你的个人愿望根本不重要。
如果你创建了一个无需解析接口描述就能使用的接口，那么我们就只能接受这个接口。理论根本不重要。
你可以帮助修复这些工具，并尝试通过这种方式避免兼容性问题。这样的问题其实并不多。

来自 `2011-05-06 (2/3)
   <https://lore.kernel.org/all/BANLkTi=KVXjKR82sqsz4gwjr+E0vtqCmvA@mail.gmail.com/>`_:

    这显然不是内部追踪点。根据定义。它被powertop所使用。

来自 `2011-05-06 (3/3)
   <https://lore.kernel.org/all/BANLkTinazaXRdGovYL7rRVp+j6HbJ7pzhg@mail.gmail.com/>`_:

    我们有一些程序依赖于这个ABI，因此如果它们出问题就是一种倒退。
* 从 `2012-07-06 <https://lore.kernel.org/all/CA+55aFwnLJ+0sjx92EGREGTWOx84wwKaraSzpTNJwPVV8edw8g@mail.gmail.com/>`_:

       > 这让我开始思考 Debian 的 _unstable_ 版本是否真的可以算作标准的用户空间发行版。
哦，如果内核破坏了一些标准用户空间，那确实算在内。很多人运行 Debian 的 unstable 版本。

* 从 `2019-09-15
   <https://lore.kernel.org/lkml/CAHk-=wiP4K8DRJWsCo=20hn_6054xBamGKF2kPgUzpB5aMaofA@mail.gmail.com/>`_:

       一个特别的、最后时刻撤销的提交是最顶部的一个（忽略版本更改本身），在发布前刚刚完成，虽然这非常烦人，但也许也有一定的教育意义。
关于它的教育意义在于，我撤销了一个实际上没有问题的提交。事实上，它完全实现了其目标，并且做得非常好。事实上，它做得如此之好以至于改善后的 I/O 模式最终揭示了另一个完全不相关的区域中的可见于用户的回归问题。
这个回归的具体细节并不是我指出这次撤销具有教育意义的原因。更重要的是，这是一个关于什么算是回归以及整个“无回归”内核规则意味着什么的例子。被撤销的提交并没有改变任何 API，也没有引入新的 bug。但它最终暴露了另一个问题，因此导致了一个用户的内核升级失败。所以它被撤销了。
关键在于我们基于用户报告的行为来撤销，而不是基于某种“改变了 ABI”或“导致了 bug”的概念。
问题实际上是预先存在的，只是之前没有触发。该变更引入的更好 I/O 模式恰好暴露了一个旧 bug，而人们已经依赖于那个旧问题之前无害的行为。
不用担心，一旦我们确定了如何处理与用户偶然依赖的界面不良交互的事实后，我们会重新引入改善 I/O 模式的修复。只是我们必须解决如何做到这一点（目前至少有三位不同开发者提出的三个不同的补丁正在讨论中，可能还会有更多……）。在此期间，即使我希望它能被重新引入（甚至作为稳定的补丁回溯），我还是为这次发布撤销了暴露问题的部分。
从这件事中学到的是：这不在于你是否更改了内核-用户空间的 ABI，或者修复了一个 bug，也不在于旧代码“本来就不应该正常工作”。而是关于某事是否打破了现有用户的正常工作流程。
无论如何，这是我对于回归问题的一点额外说明。因为它被视为“内核编程的第一条规则”，我觉得偶尔提一下也许是值得的。
本文本根据文件顶部声明的 GPL-2.0+ 或 CC-BY-4.0 许可使用。如果您希望仅根据 CC-BY-4.0 分发此文本，请将“Linux 内核开发者”作为作者归属，并将此链接作为来源：
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/process/handling-regressions.rst

注意：只有在 Linux 内核源码中找到的该 RST 文件的内容是根据 CC-BY-4.0 可用的，因为经过处理的版本（例如由内核构建系统处理）可能包含来自使用更严格许可的文件的内容。
