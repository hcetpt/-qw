SPDX 许可证标识符：(GPL-2.0+ 或 CC-BY-4.0)
..
请参阅文件底部获取额外的再分发信息
处理回归问题
++++++++++++++++++++

*我们不引入回归* -- 这份文档描述了“Linux 内核开发的第一原则”在实际中的含义。它补充了Documentation/admin-guide/reporting-regressions.rst，后者从用户的角度来讨论这个问题；如果你从未读过那份文档，请至少先快速浏览一下再继续阅读。

要点（即“TL;DR”）
==================

1. 确保`回归邮件列表 <https://lore.kernel.org/regressions/>`_（regressions@lists.linux.dev）的订阅者能够迅速得知任何新的回归报告：

    - 当收到一封未抄送该列表的邮件报告时，应立即通过发送至少一个简短的“回复所有人”，并抄送给列表来将其纳入讨论。
    
2. 将提交到错误跟踪系统中的所有报告转发或弹回给该列表。

3. 让 Linux 内核回归跟踪机器人 "regzbot" 跟踪该问题（这是可选的，但推荐）：

    - 对于邮件报告，检查报告者是否包含了一行类似“#regzbot introduced: v5.13..v5.14-rc1”的内容。如果没有，请发送一条回复（抄送给回归列表），内容如下所示，以告知 regzbot 问题开始出现的时间点：
      
      ```
      #regzbot ^introduced: 1f2e3d4c5b6a
      ```
      
    - 在将来自错误跟踪系统的报告转发到回归列表时（见上文），包括如下段落：
      
      ```
      #regzbot introduced: v5.13..v5.14-rc1
      #regzbot from: 某位 N. Ice 人类 <some.human@example.com>
      #regzbot monitor: http://some.bugtracker.example.com/ticket?id=123456789
      ```
      
4. 提交回归修复补丁时，在补丁描述中添加指向所有报告地点的“Closes:”标签，如Documentation/process/submitting-patches.rst和:ref:`Documentation/process/5.Posting.rst <development_posting>`所要求的。如果只是部分解决了引起回归的问题，可以使用“Link:”标签代替。目前 regzbot 对这两种标签没有区别对待。

5. 一旦识别出引起回归的原因，尽快修复；大多数回归修复应在两周内合并，但有些需要在两三天内解决。

有关开发者相关的 Linux 内核回归问题的所有细节
==================================================

重要基础知识的详细说明
-----------------------

如何处理收到的回归报告
~~~~~~~~~~~~~~~~~~~~~~~~~~

确保 Linux 内核的回归追踪器和其他`回归邮件列表 <https://lore.kernel.org/regressions/>`_（regressions@lists.linux.dev）的订阅者能够知晓任何新报告的回归：

 - 如果你收到一封未抄送该列表的邮件报告，应立即通过发送至少一个简短的“回复所有人”，并抄送给列表来将其纳入讨论；尽量确保在回复遗漏列表的回复时再次抄送该列表。
 
 - 如果错误跟踪系统中的报告进入了你的收件箱，请将其转发或弹回到列表。考虑事先查看列表存档，确认报告者是否已按照Documentation/admin-guide/reporting-issues.rst的指示转发了报告。

在此过程中，考虑让 Linux 内核回归跟踪机器人 "regzbot" 立即开始跟踪该问题：

 - 对于邮件报告，检查报告者是否包含了一个“regzbot 命令”，例如“#regzbot introduced: 1f2e3d4c5b6a”。如果没有，请发送一条回复（抄送给回归列表），内容如下所示：
   
   ```
   #regzbot ^introduced: v5.13..v5.14-rc1
   ```
   
   这告诉 regzbot 问题开始出现的版本范围；你可以使用提交ID指定范围，或者在报告者二分定位了原因时指定单个提交ID。

注意“introduced”前的脱字符（^）：这告诉 regzbot 将你回复的邮件视为要跟踪的回归问题的初始报告；这一点很重要，因为 regzbot 后续会查找带有指向lore.kernel.org存档中的报告的“Closes:”标签的补丁。
当转发到缺陷跟踪系统中的回归报告时，请包含一段带有以下 regzbot 命令的内容：

       #regzbot introduced: 1f2e3d4c5b6a
       #regzbot from: Some N. Ice Human <some.human@example.com>
       #regzbot monitor: http://some.bugtracker.example.com/ticket?id=123456789

这样，regzbot 将自动将包含指向你的邮件或提及的工单的 "Closes:" 标签的补丁与该报告关联。

修复回归时的重要事项
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在提交回归修复时，你不需要做任何特别的事情，只需记住按照以下文档中已经详细解释的内容来做：

 * 使用 "Closes:" 标签指向所有报告问题的地方：

       Closes: https://lore.kernel.org/r/30th.anniversary.repost@klaava.Helsinki.FI/
       Closes: https://bugzilla.kernel.org/show_bug.cgi?id=1234567890

   如果你只是部分修复了问题，可以使用 "Link:" 代替，如上述第一个文档所述。目前，regzbot 对这两种标签的处理是等同的，并认为链接的报告已解决。
* 添加一个 "Fixes:" 标签来指定导致回归的提交。
* 如果问题根源是在早期开发周期中合并的，则使用 ``Cc: stable@vger.kernel.org`` 标签明确标记此修复用于回退。

这些标签对于回归问题非常重要，因为它们对所有人（包括你自己）在未来几周、几个月甚至几年后查看问题时都非常有价值。这些标签也是其他内核开发者或 Linux 发行版使用的工具和脚本所必需的；其中一个工具就是 regzbot，它严重依赖于 "Closes:" 标签来将回归报告与解决这些问题的变更关联起来。

修复回归的期望和最佳实践
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

作为 Linux 内核开发者，你应该尽最大努力防止由于最近的变更导致的回归使用户面临以下选择：

 * 运行受回归影响的内核
* 切换到旧版本或新版本的内核系列
* 在识别出回归问题的原因后超过三周继续运行过时且可能不安全的内核。理想情况下，这个时间应少于两周。如果问题是严重的或影响了很多用户——无论是普遍情况还是在常见环境中——则应该只有几天的时间。

具体如何实现这一点取决于各种因素。请将以下经验法则作为指导：

 * 优先处理回归问题，除非其他工作涉及严重问题（例如急性安全漏洞、数据丢失、硬件损坏等）。
* 加快修复最近进入主线、稳定版或长期支持版本的主要回归问题（无论是直接进入还是通过回退）
* 不要将当前周期中的回归问题视为可以等到周期结束再处理的问题，因为这些问题可能会使用户和持续集成系统现在或总体上无法测试主线版本
* 以必要的谨慎工作，避免造成额外的或更大的损害，即使这样可能需要更长的时间来解决一个问题

在确定了回归问题的原因后的处理时间：

* 如果问题是严重的或者困扰了许多用户——无论是在一般情况下还是在特定硬件环境、发行版或稳定/长期系列中普遍存在的条件下——应在两到三天内将修复方案合并到主线
* 如果导致问题的代码已经进入了最近的主线、稳定版或长期支持版本（无论是直接进入还是通过回退），则应争取在下一个周日之前将修复方案合并到主线；如果问题是在一周的早期被发现且容易解决，则尽量在同一周内将修复方案合并到主线
* 对于其他回归问题，应在接下来三周内的最后一个周日前将修复方案合并到主线。如果回归问题对用户影响不大，例如轻微的性能下降，则可以在一两周后合并也是可以接受的
* 强烈不建议将修复方案推迟到下一个合并窗口期，除非修复方案极其危险或导致问题的代码是在一年多前合并进主线的

关于流程：

* 总是考虑撤销导致问题的代码变更，因为这通常是最快且最安全的修复方法。不必担心稍后将修复后的代码合并到主线：这应该是直截了当的，因为大部分代码已经经过了一次审查
* 尽量在当前开发周期结束前解决过去十二个月内引入的主线回归问题：林纳斯希望这些回归问题像当前周期中的问题一样得到处理，除非修复存在特殊风险
* 如果一个回归问题看起来很复杂，在讨论或补丁审查时可以抄送林纳斯。在紧急或关键情况下也应这样做——特别是当子系统维护者可能不在时。如果知道某个回归问题已经进入了主线、稳定版或长期支持版本，请抄送稳定团队
* 对于紧急的回归问题，可以考虑让林纳斯直接从邮件列表中采纳修复。对于没有争议的修复，他是完全接受的。不过，这样的请求最好与子系统维护者协商一致，或者由他们直接提出。
* 如果你不确定某个修复在新主线版本发布前几天是否值得冒险应用，请给林纳斯发一封邮件，并抄送给相关列表和人员；在邮件中总结情况，并请他考虑直接从列表中采纳该修复。然后他自己可以做出决定，必要时甚至推迟发布。这种请求同样最好与子系统维护者协商一致，或者由他们直接提出。

关于稳定版和长期支持内核：

* 如果某个回归问题从未在主线中出现或已经在主线中修复，你可以将其留给稳定团队处理。
* 如果一个回归问题在过去十二个月内出现在了一个正式的主线版本中，请确保在修复标签中加上“Cc: stable@vger.kernel.org”，因为仅使用“Fixes:”标签并不能保证回退。如果已知问题原因已经被回退到稳定版或长期支持内核，请也加上相同的标签。
* 收到关于最近稳定版或长期支持内核系列中的回归问题报告时，请至少简要评估一下该问题是否也可能出现在当前的主线版本中——如果看起来很可能，则接手该报告。如有疑问，请要求报告者检查主线版本。
* 如果希望迅速解决最近出现在主线、稳定版或长期支持内核中的回归问题，请尽快在主线中修复；适当情况下可以让林纳斯快速跟踪该修复（见上文）。这是因为稳定团队通常不会撤销或修复主线中导致相同问题的变化。
* 对于紧急的回归修复，你可能希望确保修复被及时回退，可以在修复进入主线后通知稳定团队；这在合并窗口期间及之后尤其重要，因为否则修复可能会排在一个巨大的补丁队列末尾。

关于补丁流程：

* 开发者，在尝试达到上述时间要求时，请记得考虑修复被测试、审查和合并所需的时间，理想情况下这些修复应该至少短暂地包含在linux-next中。因此，如果修复很紧急，请明确指出以确保其他人能妥善处理。
* 审查者，恳请你协助开发者达到上述时间要求，及时审查回归修复。
* 子系统维护者，也鼓励你们加快处理回归修复的速度。因此，请评估特定修复是否可以跳过linux-next。当需要时，也可以比平时更频繁地发送git拉取请求。尽量避免在周末保留回归修复——特别是当修复被标记为需要回退时。
关于回归问题，开发者应关注的更多方面
------------------------------------------------

如何处理已知存在回归风险的变化
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

评估回归的风险有多大，例如通过在Linux发行版和Git仓库中进行代码搜索。还可以考虑询问可能受影响的其他开发者或项目来评估甚至测试提议的变化；如果出现问题，或许可以找到一个各方都能接受的解决方案。
如果最终评估认为回归的风险相对较小，那么可以继续进行变化，但要让所有相关方知道这一风险。因此，请确保你的补丁说明清楚地表明这一点。一旦变化被合并，请告知Linux内核的回归追踪器和回归邮件列表有关这一风险的信息，以便在收到报告时大家都能留意到这一变化。根据风险的程度，你也可以要求子系统维护者在他的主线拉取请求中提及这个问题。

关于回归还需要了解什么？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

请查看Documentation/admin-guide/reporting-regressions.rst，它涵盖了你可能需要了解的许多其他方面：

* “无回归”规则的目的
* 哪些问题实际上可以归类为回归
* 谁负责查找回归的根本原因
* 如何处理复杂的情况，例如当回归是由安全修复引起的，或者修复一个回归可能导致另一个回归

遇到回归问题时应该向谁寻求建议？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

向回归邮件列表（regressions@lists.linux.dev）发送邮件，并抄送给Linux内核的回归追踪器（regressions@leemhuis.info）；如果问题更适合私下处理，则可以不抄送列表。

关于回归追踪和regzbot的更多信息
------------------------------------------

为什么Linux内核需要回归追踪器以及为何使用regzbot？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

“无回归”之类的规则需要有人确保其得到遵守，否则这些规则可能会被意外或故意打破。历史证明，这种情况同样适用于Linux内核。因此，Thorsten Leemhuis自愿担任Linux内核回归追踪者的角色，并偶尔得到其他人的帮助。他们都不是为此工作而获得报酬的，因此回归追踪是尽力而为的工作。
之前尝试手动追踪回归已经被证明是一项耗时且令人沮丧的工作，因此最终被放弃了。为了避免再次发生这种情况，Thorsten开发了regzbot以简化工作，并希望长期目标是尽可能自动化回归追踪工作，使所有相关人员受益。

回归追踪与regzbot是如何工作的？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

该机器人监视对已跟踪回归报告的回复。此外，它还会查找带有“Closes:”标签的已发布或提交的补丁，这些补丁引用了这些报告；对这些补丁发布的回复也会被追踪。
结合这些数据可以很好地了解当前修复过程的状态。
regzbot试图以尽可能少的开销为报告者和开发者完成其任务。事实上，只有报告者需要承担额外的任务：他们需要使用上述的``#regzbot introduced``命令告诉regzbot关于回归报告；如果他们没有这样做，其他人可以使用``#regzbot ^introduced``来处理。
对于开发者来说通常不需要额外的工作，他们只需确保做一件在regzbot出现之前就一直期望的事情：在补丁描述中添加指向所有关于所修复问题报告的链接。

我必须使用regzbot吗？
~~~~~~~~~~~~~~~~~~~~~~~~~

如果你使用regzbot，这对每个人都是有益的，因为像Linus Torvalds这样的内核维护者部分依赖于regzbot的追踪工作——例如在决定发布新版本或延长开发阶段时。为了做到这一点，他们需要了解所有未解决的回归问题；为此，Linus会查看regzbot发送的每周报告。
我是否需要向 regzbot 报告我发现的所有回归问题？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

理想情况下是的：我们都是人，很容易在遇到更重要的事情时忘记问题——例如 Linux 内核中的更大问题或者现实生活中的某些事情使我们暂时无法接触键盘。因此，最好向 regzbot 报告所有回归问题，除非你立即编写了修复并将其提交到定期合并到受影响内核系列的树中。

如何查看 regzbot 当前跟踪的回归问题？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

检查 `regzbot 的网页界面 <https://linux-regtracking.leemhuis.info/regzbot/>`_ 获取最新信息；或者，`搜索最新的回归报告 <https://lore.kernel.org/lkml/?q=%22Linux+regressions+report%22+f%3Aregzbot>`_，regzbot 通常会在每周日晚上（UTC）发送一次，这比 Linus 通常发布新（预）版本的时间提前几个小时。

regzbot 监控哪些地方？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

regzbot 监控最重要的 Linux 邮件列表以及 linux-next、主线和稳定/长期维护分支的 Git 仓库。

regzbot 应该跟踪哪些类型的问题？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

这个机器人旨在跟踪回归问题，因此请不要让 regzbot 参与常规问题。但是如果你使用 regzbot 跟踪严重问题（如挂起、数据损坏或内部错误（Panic、Oops、BUG()、warning 等）），这是可以接受的。

我可以将 CI 系统发现的回归问题添加到 regzbot 的跟踪中吗？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果特定的回归问题可能影响实际用例，并且因此可能会被用户注意到，请随意这样做；因此，请不要让 regzbot 参与那些不太可能在实际使用中出现的理论性回归问题。

如何与 regzbot 互动？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

通过在带有回归报告的邮件的直接或间接回复中使用“regzbot 命令”。这些命令需要单独成段（即需要用空行与其他内容隔开）。

一个这样的命令是 ``#regzbot introduced: <version or commit>``，这会让 regzbot 将你的邮件视为已添加到跟踪的回归报告，正如上面所述；另一个命令是 ``#regzbot ^introduced: <version or commit>``，这会让 regzbot 将父邮件视为它开始跟踪的回归报告。

一旦使用了这两个命令中的任何一个，其他 regzbot 命令可以在对报告的直接或间接回复中使用。你可以将它们写在其中一个 `introduced` 命令下方，或者回复使用了其中一个命令的邮件：

 * 设置或更新标题：

       #regzbot title: foo

 * 监控讨论或 bugzilla.kernel.org 上的工单，其中讨论了问题的其他方面或修复方法——例如提交了一个修复该回归的补丁：

       #regzbot monitor: https://lore.kernel.org/all/30th.anniversary.repost@klaava.Helsinki.FI/

   监控仅适用于 lore.kernel.org 和 bugzilla.kernel.org；regzbot 会将该线程或工单中的所有消息视为与修复过程相关的。

 * 指向包含相关信息的地点，如邮件列表帖子或略有关联但主题不同的 Bug 跟踪工单：

       #regzbot link: https://bugzilla.kernel.org/show_bug.cgi?id=123456789

 * 标记一个回归问题已被提交到上游或已经合并的修复：

       #regzbot fix: 1f2e3d4c5d

 * 标记一个回归问题是 regzbot 已经跟踪的另一个回归问题的重复：

       #regzbot dup-of: https://lore.kernel.org/all/30th.anniversary.repost@klaava.Helsinki.FI/

 * 标记一个回归问题是无效的：

       #regzbot invalid: wasn't a regression, problem has always existed

关于 regzbot 及其命令还有更多信息吗？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

更多详细且最新的关于 Linux 内核回归跟踪机器人的信息可以在其 `项目页面 <https://gitlab.com/knurd42/regzbot>`_ 找到，其中包括一个 `入门指南 <https://gitlab.com/knurd42/regzbot/-/blob/main/docs/getting_started.md>`_ 和 `参考文档 <https://gitlab.com/knurd42/regzbot/-/blob/main/docs/reference.md>`_，这两份文档都涵盖了比上述部分更多的细节。

Linus 关于回归问题的引用
----------------------------------

以下是一些实际例子，展示了 Linus Torvalds 对处理回归问题的期望：

 * 从 `2017-10-26 (1/2)
   <https://lore.kernel.org/lkml/CA+55aFwiiQYJ+YoLKCXjN_beDVfu38mg=Ggg5LFOcqHE8Qi7Zw@mail.gmail.com/>`_ ：

       如果你破坏了现有的用户空间设置，那就是一个回归问题。
说“但是我们会修复用户空间的设置”是不合适的。
真的，这是不行的。

第一条规则是：

- 我们不会引入回归

而其推论是：当出现回归时，我们要承认并修复它们，而不是归咎于用户空间。
你显然在过去三周内一直在否认这个回归，这意味着我将会撤销这些更改，并且我会停止合并 AppArmor 的请求，直到相关人员理解内核开发的方式。

来自 2017 年 10 月 26 日的消息：
<https://lore.kernel.org/lkml/CA+55aFxW7NMAMvYhkvz1UPbUTUJewRt6Yb51QAx5RtrWOwjebg@mail.gmail.com/>

人们基本上应该总是感觉可以更新他们的内核而不必担心任何问题。
我拒绝引入“只有在同时更新另一个程序的情况下才能更新内核”的这种限制。如果内核以前对你有效，那么它现在也应该继续有效。
虽然有过例外情况，但这些情况很少见，并且通常有重大和根本性的原因，这些原因是几乎不可避免的，并且人们尽力避免了这些问题。也许在硬件使用了几十年后，已经没有人再用现代内核支持它了。也许我们之前的处理方式存在严重的安全问题，而人们实际上依赖的是那个根本错误的模型。也许有一些根本性的其他问题，必须通过标志日（flag day）来解决。

请注意，这主要是关于破坏人们的环境的问题。
行为的变化会发生，也许我们不再支持某些特性。在 `/proc/<pid>/stat` 中有很多字段被打印为零，仅仅是因为这些字段在内核中已经不存在了，或者显示它们是一个错误（通常是信息泄露）。但是这些数字被零替换，以便解析这些字段的代码仍然能工作。用户可能看不到他们以前看到的所有信息，因此行为明显不同，但事情仍然能够运行，即使它们可能不再显示敏感或无关的信息。

但如果某件事情真正地破坏了，那么这个更改必须被修复或回滚。并且这个修复是在内核中完成的。不是说“好吧，你去修复你的用户空间”。这是一个由内核更改暴露出来的问题，需要由内核来修正，因为我们有一个“就地升级”的模式。我们没有一个“带新用户空间的升级”模式。
并且我严肃地拒绝接受那些不理解和尊重这条非常简单规则的人的代码。
这条规则也不会改变。
是的，我意识到内核在这方面是“特殊的”。我为此感到自豪。

我见过很多项目，并且可以指出，这些项目会说“我们必须打破某种用例以取得进展”或者“你依赖了未文档化的行为，你倒霉了”或者“有更优的方式来实现你的需求，你需要改成新的更好方式”，而我认为这种做法在非常早期的alpha版本之外是不可接受的，这些版本有实验用户，他们知道自己参与的是什么。内核在过去二十年里已经不是这种情况了。

我们确实经常在内核内部进行API破坏。我们会通过说“你现在需要做XYZ”来修复内部问题，但这是关于内核内部API的，而这样做的人员显然也需要修复所有使用该API的内核部分。没有人可以说“我现在破坏了你使用的API，现在你得自己去修复它”。谁破坏了东西，谁就得负责修复。

我们就是不会破坏用户空间。

* 来自 `2020-05-21 <https://lore.kernel.org/all/CAHk-=wiVi7mSrsMP=fLXQrXK_UimybW=ziLOwSzFTtoXUacWVQ@mail.gmail.com/>`_ ：

    关于回归的问题，从来不是关于任何文档化的行为或代码所在的位置。
    关于回归的问题，始终是关于“是否破坏了用户的操作流程”。
    用户实际上是唯一重要的事情。
    无论多少“你不应该使用这个”或“那种行为是未定义的，你自己的应用程序坏了是你自己的错”或“那以前能工作只是因为内核的一个bug”的说法都无关紧要。
现在，现实从来不是完全黑白分明的。所以我们有时候会遇到“严重的安全问题”等状况，这迫使我们必须做出一些可能会破坏用户空间的改动。但即便如此，规则仍然是我们没有其他选择能让事情继续下去。

显然，如果用户需要好几年才能注意到某些东西坏了，或者我们有合理的方法来绕过这些问题，而这些方法不会给用户带来太多麻烦（比如说，“好吧，只有少数几个用户，他们可以通过内核命令行来绕过这个问题”这样的情况），那么我们也会稍微宽松一些。

但是，“那被记录为是坏的”（无论是因为代码在测试阶段还是因为手册页上说了别的东西）都是无关紧要的。如果测试阶段的代码非常有用以至于人们最终开始使用它，这意味着它基本上就是常规的内核代码，只不过带有一个标志说“请清理一下”。

另一方面，谈论“API稳定性”的人完全是错误的。API并不重要。你可以随意对API进行任何更改——只要没有人注意到。

同样，回归规则与文档、API或月亮的相位无关。

它完全关乎“我们导致了以前能正常工作的用户空间出现问题”。

* 来自 `2017-11-05 <https://lore.kernel.org/all/CA+55aFzUvbGjD8nQ-+3oiMBx14c_6zOj2n7KLN3UsJ-qsd4Dcw@mail.gmail.com/>`_ ：

    我们的回归规则从来不是“行为不改变”。那意味着我们将永远无法做任何改动。

    例如，我们会经常添加新的错误处理等等，有时甚至会在我们的kselftest目录中添加测试。

    所以很明显，行为一直在变化，我们并不认为这种变化本身是一种回归。
回归问题的规则是某些实际用户的工作流程会中断。不是某些测试，也不是“看，我以前能做X，现在不能了”。

* 来自 `2018-08-03 <https://lore.kernel.org/all/CA+55aFwWZX=CXmWDTkDGb36kf12XmTehmQjbiMPCqCRG2hi9kw@mail.gmail.com/>`_ 的内容：

    你忽略了内核的第一条规则。
    
    我们不会出现回归，而且我们之所以不会出现回归是因为你是100%错误的。
    你提出这个观点的原因实际上正是你错的原因。
    你的“好理由”完全是垃圾。
    “我们不会出现回归”的整个重点在于人们可以升级内核而无需担心任何问题。
    > 内核有一个bug已经被修复
    
    这是完全不相关的。
    各位，某个东西是否有bug并不重要。
    为什么？
    
    bug会发生。这是生活中的事实。争论“我们必须破坏某些东西因为我们正在修复一个bug”是完全疯狂的。我们每天都会修复数十个bug，认为“修复一个bug”意味着我们可以破坏某些东西是不正确的。
    因此，bug与讨论无关。它们会发生，会被发现，会被修复，这与“我们会破坏用户”没有任何关系。
因为唯一重要的就是用户。
这有多难理解？

       任何使用“但它有漏洞”作为论据的人完全错过了重点。就用户而言，它并没有漏洞——它对他/她来说是有效的。
也许它之所以有效是因为用户已经考虑到了这个漏洞，或者是因为用户没有注意到——但这些都不重要。对用户来说，它是有效的。
为了一个“漏洞”而破坏用户的操作流程绝对是你能想象到的最糟糕的理由。
这基本上就是在说：“我拿了一个能用的东西，然后把它弄坏了，但现在更好了。”你难道看不出这句话有多荒谬吗？

       没有用户，你的程序就不是一个程序，而是一段可以扔掉的无意义代码。
认真地说，这就是内核开发的头号规则是“我们不破坏用户”的原因。因为“我修复了一个漏洞”绝对不是一个论据，如果这个漏洞修复破坏了用户的设置。你实际上是引入了一个更大的漏洞，因为你“修复”了一些用户显然并不关心的问题。
而且，我们一直在升级内核而不升级其他任何程序。这是绝对必要的，因为标志日（flag-day）和依赖关系非常糟糕。
这也是必要的，因为我作为一名内核开发者，在开发内核时不会升级那些我不关心的随机工具，我希望我的用户也能放心这样做。
所以不行。你的规则是完全错误的。如果你不能在不升级其他随机二进制文件的情况下升级内核，那我们就有一个问题。
* 从 `2021-06-05
   <https://lore.kernel.org/all/CAHk-=wiUVqHN76YUwhkjZzwTdjMMJf_zN4+u7vEJjmEGh3recw@mail.gmail.com/>`_ ：

       对于退步，没有任何有效的论据。
诚实地讲，安全人员需要理解，“无法工作”并不是安全的成功案例。这是一个失败的案例。
是的，“无法工作”可能是安全的。但这种情况下，安全性是毫无意义的。

* 从 `2011-05-06 (1/3) <https://lore.kernel.org/all/BANLkTim9YvResB+PwRp7QTK-a5VNg2PvmQ@mail.gmail.com/>`_ ：

    二进制兼容性更为重要。
    如果二进制文件不使用接口来解析格式（或者只是错误地解析了它——参见最近在/proc/self/mountinfo中添加uuid的例子），那么这就是一种倒退。
    倒退会被撤销，除非有安全问题或其他类似的问题让我们不得不承认“哦天哪，我们真的必须破坏一些东西”。

我不明白为什么这个简单的逻辑对某些内核开发者来说这么难以理解。现实很重要。你们个人的愿望根本不重要。
如果你设计了一个无需解析接口描述就能使用的接口，那么我们就只能接受这个接口。理论根本无关紧要。
你可以帮助修复工具，并尝试通过这种方式避免兼容性问题。这样的问题并不多。

从 `2011-05-06 (2/3) <https://lore.kernel.org/all/BANLkTi=KVXjKR82sqsz4gwjr+E0vtqCmvA@mail.gmail.com/>`_ ：

    显然这不是一个内部跟踪点。根据定义，它被powertop使用了。

从 `2011-05-06 (3/3) <https://lore.kernel.org/all/BANLkTinazaXRdGovYL7rRVp+j6HbJ7pzhg@mail.gmail.com/>`_ ：

    我们有一些程序依赖于这个ABI，因此如果它们无法工作，这就是一种倒退。
* 从 `2012-07-06 <https://lore.kernel.org/all/CA+55aFwnLJ+0sjx92EGREGTWOx84wwKaraSzpTNJwPVV8edw8g@mail.gmail.com/>`_ ：

       > 这让我开始怀疑 Debian _unstable_ 是否真的可以算作标准的用户空间。
       > 哦，如果内核破坏了一些标准的用户空间，那是需要考虑的。很多人在使用 Debian unstable。

* 从 `2019-09-15 <https://lore.kernel.org/lkml/CAHk-=wiP4K8DRJWsCo=20hn_6054xBamGKF2kPgUzpB5aMaofA@mail.gmail.com/>`_ ：

       最后一个特别紧急的回滚是发布前最上面的一个提交（忽略版本变更本身），虽然这非常烦人，但也可能是有教育意义的。
       之所以有教育意义是因为我回滚了一个实际上没有问题的提交。事实上，这个提交完成了它要做的事情，并且做得非常好。事实上，它做得如此之好，以至于它改进后的 I/O 模式最终揭示了一个用户可见的退化问题，这个问题是由一个完全不相关的区域中的真实错误引起的。
       这个退化问题的具体细节并不是我指出这个回滚具有教育意义的原因。更重要的是，这是一个关于什么算是退化以及整个“不允许退化”内核规则意味着什么的典型例子。被回滚的提交没有更改任何 API，也没有引入新的错误。但它最终暴露了另一个问题，因此导致用户升级内核失败。所以它被回滚了。
       关键在于我们基于用户报告的 _行为_ 来回滚，而不是基于“它改变了 ABI”或“它引起了错误”的概念。
       问题是早已存在的，只是以前没有触发。该变更引入的更好的 I/O 模式恰好暴露出一个旧的错误，而人们已经习惯了那个旧问题之前的无害行为。
       不用担心，一旦我们决定如何处理与接口不良交互的问题，我们会重新引入改进 I/O 模式的修复。只是我们需要讨论如何做到这一点（目前有三位不同的开发者提出了三个不同的补丁，可能还会有更多……）。在此期间，为了这次发布，我回滚了暴露问题的那个提交，即使我希望它能够重新引入（甚至作为稳定的补丁进行回溯）一旦我们对它暴露的问题达成共识。
       从整个事情中得到的经验教训：这不是关于你是否改变了内核-用户空间的 ABI，也不是关于你是否修复了一个错误，或者关于旧代码“本来就不应该工作”。而是关于某件事情是否破坏了现有用户的流程。
       总之，这是我对整个退化问题的一点补充。由于这是“内核编程的第一条规则”，我觉得偶尔提一下或许是值得的。

.end-of-content
本文档根据 GPL-2.0+ 或 CC-BY-4.0 许可证提供，具体如文件顶部所述。如果您只想根据 CC-BY-4.0 分发本文档，请将“Linux 内核开发者”作为作者归属，并链接以下内容作为来源：
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/process/handling-regressions.rst

注意：只有在 Linux 内核源代码中找到的该 RST 文件的内容是根据 CC-BY-4.0 可用的，因为经过处理（例如通过内核构建系统）的版本可能包含来自使用更严格许可证的文件的内容。
