SPDX 许可证标识符: GPL-2.0

.. _netdev-FAQ:

=============================
网络子系统 (netdev)
=============================

简要说明
--------

- 将您的补丁指定到某个树中 - ``[PATCH net]`` 或 ``[PATCH net-next]``
- 对于修复补丁，无论哪个树都需要使用 ``Fixes:`` 标签
- 不要发布大型系列（> 15 个补丁），请将它们拆分
- 不要在同一 24 小时内重新发布您的补丁
- 避免圣诞树式补丁

netdev
------

netdev 是一个与所有与 Linux 网络相关的邮件列表。这包括 Linux 源代码树中的 net/ 目录下的内容（例如 IPv6 的核心代码）和 drivers/net 目录下的内容（例如特定硬件的驱动程序）。请注意，一些子系统（例如无线驱动程序）由于流量较大，有其专用的邮件列表和树。和其他许多 Linux 邮件列表一样，netdev 列表托管在 kernel.org，并且可以在 https://lore.kernel.org/netdev/ 查看存档。除了上述子系统之外，所有与网络相关的 Linux 开发（即 RFC、审查、评论等）都在 netdev 上进行。

开发周期
---------

这里有一些关于 Linux 开发节奏的基本信息。每个新版本开始时都有一个为期两周的“合并窗口”，在此期间主要维护者会将他们的新内容提交给 Linus 合并到主线树中。两周后，合并窗口关闭，并标记为 ``-rc1``。在此之后不再接受新的功能，只期望对 rc1 内容进行修复。大约一周后收集完对 rc1 内容的修复，就会发布 rc2。此过程每周重复一次，直到 rc7（通常是这样；如果情况平静可能会是 rc6，如果处于频繁变动状态则可能是 rc8），并且在最后一个 vX.Y-rcN 发布的一周后，官方 vX.Y 版本发布。

要了解当前所处的开发周期阶段，请加载主线（Linus）页面：

  https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git

并注意 “标签” 部分顶部。如果是 rc1，则处于开发周期的早期。如果一周前标记了 rc7，则可能即将发布。如果最新的标签是一个最终版本标签（没有 ``-rcN`` 后缀），则我们很可能处于合并窗口期，此时 ``net-next`` 已经关闭。

git 树和补丁流程
------------------------

有两个网络树（git 仓库）在起作用。这两个树都由主要网络维护者 David Miller 驱动。一个是 ``net`` 树，另一个是 ``net-next`` 树。从名字上可以猜到，``net`` 树用于对已存在于 Linus 主线树中的现有代码进行修复，而 ``net-next`` 树则是存放未来版本的新代码的地方。您可以在以下位置找到这些树：

- https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git
- https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git

将此与内核开发联系起来：在为期两周的合并窗口开始时，``net-next`` 树将被关闭 - 不再接受新的更改/特性。过去约 10 周积累的新内容将通过拉取请求传递给主线/Linus 以生成 vX.Y 版本 —— 同时，``net`` 树将开始累积与此拉取内容相关的 vX.Y 版本的修复。

通常会在 netdev 上发送一条公告，指示 ``net-next`` 已关闭，但根据上述信息，您可以提前预测这一点。
.. warning::
  在 ``net-next`` 树关闭期间，请不要向 netdev 发送新的 ``net-next`` 内容

仅用于审查的 RFC 补丁显然随时欢迎（使用 ``--subject-prefix='RFC net-next'`` 与 ``git format-patch``）。
两周过后不久（并且发布了vX.Y-rc1），`net-next`分支重新开放，以收集下一个版本（vX.Y+1）的内容。
如果你没有订阅netdev邮件列表，或者不确定`net-next`是否已经重新开放，可以查看上面提供的`net-next` Git仓库链接中的任何新的网络相关提交。你也可以访问以下网站查看当前状态：

  https://netdev.bots.linux.dev/net-next.html

`net`分支继续收集vX.Y内容的修复，并定期（大约每周）反馈给Linus。这意味着`net`的重点在于稳定性和错误修复。
最终，vX.Y版本发布，整个周期重新开始。
netdev补丁审查
--------------

.. _patch_status:

补丁状态
~~~~~~~~~~~~

可以通过查看netdev的主要补丁队列来检查补丁的状态：

  https://patchwork.kernel.org/project/netdevbpf/list/

“状态”字段将准确告诉你你的补丁目前处于什么状态：

================== =============================================================
补丁状态            描述
================== =============================================================
新，待审查         等待审查，补丁在维护者的审查队列中；这两种状态可互换使用（取决于具体处理补丁工作的共同维护者）
已接受              补丁已被应用到相应的网络分支，这通常由pw-bot自动设置
等待确认            等待领域专家或测试者的确认
需要修改           补丁未通过审查，需要提供带有适当代码和提交信息的新版本
被拒绝              补丁已被拒绝，不期望提供新版本
不适用              补丁预计将在网络子系统之外应用
等待上游            补丁应由适当的子维护者审查并处理，然后将其发送到网络分支；在netdev补丁队列中标记为“等待上游”的补丁通常会保持此状态，无论子维护者是否请求修改、接受或拒绝了该补丁
延期                补丁需要稍后重新发布，通常是由于依赖关系或因为其发布时分支已关闭
替代                发布了补丁的新版本，通常由pw-bot设置
讨论稿（RFC）       不应应用，通常不在维护者的审查队列中，pw-bot可以根据主题标签自动将补丁设置为此状态
================== =============================================================

补丁通过电子邮件中的“Message-ID”头索引，因此如果找不到你的补丁，请将“Message-ID”的值附加到上述URL末尾。
更新补丁状态
~~~~~~~~~~~~~~~~~~~~~

贡献者和审查者没有直接在补丁队列中更新补丁状态的权限。补丁队列不提供有关补丁状态历史的很多信息，因此多人更新状态会导致混淆。
与其分配补丁队列权限，netdev使用了一个简单的邮件机器人，它会在发送到邮件列表的电子邮件中查找特定命令/行。例如，要将一系列补丁标记为“需要修改”，需要在电子邮件线程中的任何位置添加以下行：

  pw-bot: changes-requested

结果是，机器人将整个系列设置为“需要修改”状态。
当作者发现自己的系列中存在错误并希望阻止其应用时，这可能会很有用。
机器人的使用完全是可选的，如果不确定，完全可以忽略它的存在。维护者将自行分类并更新补丁状态。不应向列表发送任何主要目的是与机器人通信的电子邮件，机器人命令应被视为元数据。
机器人的使用仅限于补丁的作者（提交补丁时的“From:”头必须与命令匹配）、根据MAINTAINERS文件维护修改代码的维护者（同样，“From:”必须与MAINTAINERS条目匹配），以及少数高级审查者。
机器人记录其活动如下：

  https://netdev.bots.linux.dev/pw-bot.html

审查时间线
~~~~~~~~

一般来说，补丁会迅速得到分类（在48小时内）。但请耐心等待，如果你的补丁在补丁队列中是活跃的（即它列在项目的补丁列表上），那么它被遗漏的可能性几乎为零。
netdev 上的大量开发工作使得评审人员相对较快地从讨论中移开。在一周的沉默之后，新的评论和回复几乎不可能出现。如果补丁在 patchwork 中不再活跃，并且讨论已经停滞超过一周，请澄清下一步行动并/或发布新版本。

对于 RFC 帖子，如果一周内无人回应，则可能是评审人员错过了该帖子或没有强烈的意见。如果代码已准备好，请重新以 PATCH 形式发布。

仅发送“ping”或“bump”的邮件被认为是不礼貌的。如果你无法通过 patchwork 或讨论内容来确定补丁的状态，请描述你的最佳猜测并询问是否正确。例如：

  我不明白下一步该怎么做。X 似乎对 A 不满意，我应该做 B 并重新发布补丁吗？

.. _请求更改:

请求更改
~~~~~~~~~

被标记为 ``Changes Requested`` 的补丁需要进行修订。新版本应附带变更日志，最好包括以前发布的链接，例如：

  [PATCH net-next v3] net: 让奶牛哞叫

  即使不喝牛奶的用户也喜欢听到奶牛“哞”的声音。哞叫的数量将取决于数据包速率，因此应与昼夜周期相当吻合。
Signed-off-by: Joe Defarmer <joe@barn.org>
  ---
  v3:
    - 在提交信息中添加关于时间变化的哞叫声波动的说明
  v2: https://lore.kernel.org/netdev/123themessageid@barn.org/
    - 修复 netif_is_bovine() 中缺少的参数文档
    - 修复 netdev_register_cow() 中的内存泄漏
  v1: https://lore.kernel.org/netdev/456getstheclicks@barn.org/

提交信息应修订以回答评审人员在之前讨论中提出的问题。有时更新提交信息将是新版本中的唯一更改。

部分重发
~~~~~~~~~

请始终重发整个补丁系列，并确保你对补丁进行编号，以便明确这是最新的、可以应用的补丁集。不要尝试只重发已更改的部分补丁。

处理错误应用的补丁
~~~~~~~~~~~~~~~~~

偶尔，补丁系列在收到关键反馈前就被应用了，或者应用了错误版本的补丁。
一旦推送出去后让补丁消失是不可能的，因为 netdev 树的提交历史是不可变的。
请在合并的内容基础上发送增量版本以修复这些补丁，使其看起来像是最新补丁系列被合并后的样子。
如果需要完全撤销，则必须作为补丁提交到列表中，并在提交信息中解释撤销的提交的技术问题。只有在原始更改完全错误的情况下才应使用撤销；优选增量修复。
稳定树

过去，网络设备（netdev）提交的内容不应该带有显式的 `CC: stable@vger.kernel.org` 标签，但如今不再如此。请遵循 :ref:`Documentation/process/stable-kernel-rules.rst <stable_kernel_rules>` 中的标准稳定规则，并确保包含适当的 Fixes 标签！

安全修复

如果您认为发现了一个可能具有安全影响的漏洞，请不要直接联系网络设备维护者。当前的网络设备维护者一直要求人们使用邮件列表而不是直接联系。如果您不同意这样做，可以考虑发送邮件到 security@kernel.org 或者阅读 http://oss-security.openwall.org/wiki/mailing-lists/distros 作为可能的替代机制。

发布用户空间组件变更

用户空间代码应与内核补丁一起发布。这可以让评审者看到任何新接口是如何使用的以及其工作效果如何。当用户空间工具位于内核仓库本身时，所有变更通常应作为一个系列发布。如果系列变得过大或用户空间项目不在 netdev 上进行评审，则应提供一个公共仓库链接，以便查看用户空间补丁。

如果用户空间工具位于单独的仓库中但在 netdev 上进行评审（例如对 `iproute2` 工具的修改），则在发布到邮件列表时，内核和用户空间补丁应形成独立的系列（线程），例如：

```
[PATCH net-next 0/3] net: 某功能介绍信
└─ [PATCH net-next 1/3] net: 某功能准备
└─ [PATCH net-next 2/3] net: 某功能实现
└─ [PATCH net-next 3/3] selftest: net: 某功能测试

[PATCH iproute2-next] ip: 添加某功能支持
```

作为单个线程发布是不被鼓励的，因为这会让 Patchwork 混乱（截至 Patchwork 2.2.2 版本）。

准备变更

细节很重要。请像评审者一样重新阅读自己的工作。您可以从使用 `checkpatch.pl` 开始，甚至可以带上 `--strict` 标志。但不要盲目地机械化。如果您的变更是一个 bug 修复，请确保提交日志中指明了最终用户可见的症状、发生的原因，如有必要，解释为什么所提出的修复是最好的解决方案。不要破坏空白字符，并且不要错误缩进跨越多行的函数参数。如果是您第一次提交补丁，请先发给自己以测试应用到未打补丁的树上，确认基础设施没有破坏它。

最后，回过头来阅读 :ref:`Documentation/process/submitting-patches.rst <submittingpatches>`，以确保没有重复文档中的常见错误。

指示目标树

为了帮助维护者和 CI 机器人，您应该明确标记补丁的目标树。假设您使用 git，请使用前缀标志：

```
git format-patch --subject-prefix='PATCH net-next' start..finish
```

对于 `net` 内容的 bug 修复，请使用 `net` 而不是 `net-next`（始终小写）。

将工作拆分为补丁

请站在评审者的角度思考。每个补丁都是单独阅读的，因此应构成向您声明的目标迈出的可理解的一步。
避免发送超过15个补丁的系列。较大的系列需要更长时间来审查，因为审查者会等到有大量时间时再查看。较小的系列可以在短时间内完成审查，因此维护者会直接处理。因此，一系列较小的补丁集可以更快地合并，并且审查覆盖率更好。重新发布大型系列也会增加邮件列表的流量。

多行注释
~~~~~~~~~

网络部分和其他大部分代码树对注释风格有一些不同的约定。建议使用以下格式，而不是：

  ```
  /*
   * foobar blah blah blah
   * another line of text
   */
  ```

而是：

  ```
  /* foobar blah blah blah
   * another line of text
   */
  ```

局部变量排序（“反向圣诞树”，“RCS”）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Netdev 对函数中的局部变量声明顺序有一个约定：按照从最长到最短的顺序排列，例如：

  ```
  struct scatterlist *sg;
  struct sk_buff *skb;
  int err, i;
  ```

如果有变量之间的依赖关系导致无法按此顺序排列，则将初始化移到其他位置。

格式优先级
~~~~~~~~~

在使用非标准格式的现有代码中工作时，请使您的代码遵循最新的指南，以便最终所有 netdev 范围内的代码都采用首选格式。

重新发送后审查
~~~~~~~~~

每次发送之间至少间隔24小时。这将确保来自不同地理区域的审查者有机会发表意见。也不要等待太久（几周），因为这样会使审查者更难回忆起上下文。

确保在新的发送中解决了所有反馈。如果关于前一版本的讨论仍在进行中，除非审查者明确指示，否则不要发送新版本的代码。

新版本的补丁应作为一个单独的线程发送，而不是作为对前一发送的回复。更改日志应包含指向前一发送的链接（参见 :ref:`请求的更改`）。

测试
----

预期的测试级别
~~~~~~~~~

至少你的更改必须能够在设置 `W=1` 的情况下通过 `allyesconfig` 和 `allmodconfig` 构建，并且没有新的警告或失败。

理想情况下，你应该针对你的更改进行了运行时测试，并且补丁系列包含一组内核自测（位于 `tools/testing/selftests/net` 中）或使用 KUnit 框架。

你应当在相关的网络树（如 `net` 或 `net-next`）上测试你的更改，而不是在一个稳定的树或 `linux-next` 上。
拼接检查

拼接中的检查主要是围绕现有内核脚本的简单包装，源码可以从以下地址获取：

https://github.com/linux-netdev/nipa/tree/master/tests

**不要**仅仅为了运行检查而发布补丁。你必须确保在发布到邮件列表之前已经通过本地测试验证了你的补丁。拼接构建机器很容易过载，并且如果可以避免的话，我们真的不需要给 netdev@vger 增加更多流量。

Netdevsim
~~~~~~~~~

``netdevsim`` 是一个测试驱动程序，可以在不依赖于硬件的情况下测试驱动程序配置 API。
强烈建议在添加新 API 时使用基于 ``netdevsim`` 的模拟和测试，但 ``netdevsim`` 本身**不是**用例或用户。你还必须在真实的驱动程序中实现新的 API。
我们不保证将来不会以可能破坏通常被认为是 uAPI 的方式更改 ``netdevsim``。
``netdevsim`` 仅保留用于上游测试，因此任何新的 ``netdevsim`` 功能都必须伴随着在 ``tools/testing/selftests/`` 下的自测。

审阅者指南
-----------------

鼓励大家审阅邮件列表上的其他人的补丁，无论技术水平如何。有关一般指导和有用的提示，请参见 :ref:`development_advancedtopics_reviews`。
可以假设 netdev 维护者了解社区和审阅者的水平。审阅者不必担心他们的评论会阻碍或使补丁流程脱轨。
经验较少的审阅者被强烈鼓励对提交的内容进行更深入的审查，而不仅仅关注代码格式、标签等琐碎或主观的问题。

证词 / 反馈
-----------------------

一些公司在员工绩效评估中使用同行反馈。
请随时向网络子系统维护者请求反馈，
特别是当你花费大量时间审查代码
并积极改善共享基础设施时。
请求反馈必须由你，贡献者本人提出，并且反馈始终
会与你共享（即使你要求将其提交给你的经理）。
