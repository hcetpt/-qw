SPDX 许可证标识符：GPL-2.0

.. _netdev-FAQ:

=============================
网络子系统（netdev）
=============================

简而言之（tl;dr）
------------------

 - 指定你的补丁适用于哪个树 - ``[PATCH net]`` 或者 ``[PATCH net-next]``
 - 对于修复，无论树的类型如何，``Fixes:`` 标签都是必需的
 - 不要发布大型系列（> 15个补丁），请将它们拆分
 - 不要在24小时内重新发布你的补丁
 - 避免圣诞树式提交

netdev
------

netdev是一个邮件列表，涵盖了所有与Linux相关的网络内容。这包括在net/下找到的所有内容（例如IPv6的核心代码）和drivers/net（即特定硬件驱动程序）在Linux源代码树中。值得注意的是，一些子系统（如无线驱动程序）由于流量大，有其专门的邮件列表和树。和其他许多Linux邮件列表一样，netdev列表托管在kernel.org上，归档可以在https://lore.kernel.org/netdev/找到。除了上述子系统之外，所有与Linux网络开发相关的内容（即RFC、评审、评论等）都在netdev上进行。

开发周期
---------

这里有一些关于Linux开发节奏的背景信息。每个新版本开始时会有两周的“合并窗口”，主要维护者会将他们的新内容提交给Linus，以合并到主线树中。两周后，合并窗口关闭，并标记为``-rc1``。之后不再接受新的功能，只期望对rc1内容的修复。收集rc1内容修复的大约一周后，发布rc2。这个过程大约每周重复一次，直到rc7（通常；如果情况安静可能是rc6，如果事情正在剧烈变动可能是rc8），在最后一个vX.Y-rcN完成的一周后，官方的vX.Y版本发布。

要了解我们当前所处的开发周期阶段，请访问主线（Linus）页面：

  https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git

并注意“标签”部分的顶部。如果是rc1，那么我们处于开发周期的早期。如果一周前标记了rc7，那么可能即将发布。如果最近的标签是最终发布标签（没有``-rcN``后缀），那么我们很可能处于合并窗口期，且``net-next``已关闭。

git树和补丁流程
------------------------

有两个网络树（git仓库）在使用中。两者都由主要网络维护者David Miller驱动。一个是``net``树，另一个是``net-next``树。从名字可以猜出，``net``树用于修复已经在Linus主线树中的现有代码，而``net-next``树则是未来版本的新代码存放地。你可以在以下位置找到这些树：

- https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git
- https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git

将其与内核开发联系起来：在两周合并窗口的开始，``net-next``树将被关闭——不再接受新的更改或特性。过去约10周累积的新内容将通过拉取请求传递给主线/Linus，用于vX.Y版本。同时，``net``树将开始积累与vX.Y拉取内容相关的修复。

通常会在netdev上发送公告，指示``net-next``何时关闭，但根据以上信息，你可以提前预测这一点。
.. warning::
  在``net-next``树关闭期间，不要向netdev发送新的``net-next``内容

仅用于审查的RFC补丁随时欢迎（使用 ``--subject-prefix='RFC net-next'`` 和 ``git format-patch``）
在两周时间刚过（并且发布了vX.Y-rc1）后不久，“net-next”树重新开放，以收集下一次发布（vX.Y+1）的内容。
如果你没有订阅netdev，或者只是不确定“net-next”是否已经重新开放，只需检查上面的“net-next”git仓库链接是否有任何新的网络相关提交。你也可以通过以下网站查看当前状态：

https://netdev.bots.linux.dev/net-next.html

“net”树继续收集vX.Y内容的修复，并定期（大约每周）反馈给Linus。这意味着“net”的重点在于稳定性和bug修复。
最后，vX.Y版本被发布，整个周期重新开始。

netdev补丁审查
--------------

.. _patch_status:

补丁状态
~~~~~~~~~

可以通过查看netdev的主要patchwork队列来检查补丁的状态：

https://patchwork.kernel.org/project/netdevbpf/list/

“状态”字段将确切地告诉你你的补丁处于什么阶段：

================== =============================================================
补丁状态          描述
================== =============================================================
新，正在审查中   待审，补丁在维护者的队列中等待审查；这两种状态可互换使用（取决于当时处理patchwork的确切的共同维护者）
已接受            补丁已被应用到相应的网络树中，这通常由pw-bot自动设置
等待确认          等待领域专家或测试的确认
需要修改           补丁未通过审查，预期会有适当代码和提交信息更改的新修订版
已拒绝             补丁已被拒绝，不期待有新修订版
不适用             补丁预计将在网络子系统之外应用
等待上游           补丁应由适当的子维护者审查和处理，然后将其发送到网络树；在netdev的patchwork中设置为“等待上游”的补丁通常会保持这种状态，无论子维护者是否请求修改、接受或拒绝补丁
延期              补丁需要稍后重新发布，通常是由于依赖关系或因为它是在关闭的树上发布的
替代              补丁的新版本已被发布，通常由pw-bot设置
征求意见          不予应用，通常不在维护者的审查队列中，pw-bot可以基于主题标签自动将补丁设置为此状态
================== ==============================================================

补丁通过承载它们的邮件的“Message-ID”头索引，因此如果你找不到你的补丁，可以在上述URL后附加“Message-ID”的值。

更新补丁状态
~~~~~~~~~~~~~

贡献者和评审者无权直接在patchwork中更新补丁状态。Patchwork并不提供关于补丁状态历史的大量信息，因此让多人更新状态会导致混乱。
netdev没有委派patchwork权限，而是使用了一个简单的邮件机器人，它会查找发送到邮件列表的电子邮件中的特殊命令/行。例如，要将一系列标记为需要修改，需要在邮件线程的任何位置发送以下行：

pw-bot: changes-requested

结果，机器人会将整个系列设置为需要修改。
当作者发现自己的系列中有bug并希望阻止其应用时，这可能会很有用。
机器人的使用完全是可选的，如果不确定，完全可以忽略它的存在。维护者将自行分类和更新补丁的状态。不应向列表发送任何旨在与机器人通信的邮件，机器人命令应被视为元数据。
机器人的使用仅限于补丁的作者（提交补丁和命令时的“From:”标头必须匹配！）、根据MAINTAINERS文件修改代码的维护者（同样，“From:”必须与MAINTAINERS条目匹配），以及少数资深评审员。
机器人记录其活动在这里：

https://netdev.bots.linux.dev/pw-bot.html

审查时间线
~~~~~~~~~~

一般而言，补丁很快就会得到初步处理（在48小时内）。但请耐心等待，如果你的补丁在patchwork中是活跃的（即它列在项目的补丁列表上），那么它被遗漏的可能性接近于零。
网卡开发的高度活跃使得评审人员会相对较快地从讨论中移开。在一周的沉默之后，几乎不可能再收到新的评论或回复。如果一个补丁在Patchwork上不再处于活跃状态，并且讨论线程已闲置超过一周，请澄清下一步行动和/或发布新版本。
对于RFC发布的特别说明，如果一周内没有人回复，则可能是评审人员错过了该发布或者对此没有强烈的意见。如果代码已经准备就绪，可以作为PATCH重新发布。
仅发送“ping”或“bump”的邮件被认为是不礼貌的。如果你无法从Patchwork判断出补丁的状态或讨论的进展，请描述你认为最可能的情况并询问是否正确。例如：

  我不明白接下来的步骤是什么。X似乎对A不满意，我应该做B然后重新发布补丁吗？

.. _请求变更:

请求变更
~~~~~~~~~

被标记为``请求变更``的补丁需要进行修订。新版本应当附带变更日志，最好包括前次发布的链接，例如：

  [PATCH net-next v3] net: 让奶牛发出哞哞声

  即使那些不喝牛奶的人也会欣赏听到奶牛发出的“哞哞”声。哞哞声的数量取决于数据包率，因此与昼夜周期相当吻合。
签名确认：Joe Defarmer <joe@barn.org>
  ---
  v3:
    - 在提交信息中添加关于一天中哞哞声波动的注释
  v2: https://lore.kernel.org/netdev/123themessageid@barn.org/
    - 修复netif_is_bovine()中的内核文档缺少参数的问题
    - 修复netdev_register_cow()中的内存泄漏问题
  v1: https://lore.kernel.org/netdev/456getstheclicks@barn.org/

提交信息应当修订以回答评审人员在之前讨论中提出的所有问题。有时，更新提交信息将是新版中的唯一变化。
部分重发
~~~~~~~~~~~~~~~

请始终重发整个补丁系列，并确保编号你的补丁，以便明确这是最新且最佳的一组可应用的补丁。不要尝试只重发更改过的补丁。
处理误应用的补丁
~~~~~~~~~~~~~~~~~~~~~~~~~~~

偶尔，一个补丁系列会在收到关键反馈之前被应用，或者错误版本的系列被应用了。
一旦补丁被推送出去后，使其消失是不可能的，网卡开发树中的提交历史是不可变的。
请在已合并的内容基础上发送增量版本来修复这些补丁，就像你的最新补丁系列要被合并时它们应有的样子。
在需要完全撤销的情况下，撤销必须作为补丁提交到列表中，并附有解释被撤销提交技术问题的提交信息。撤销应作为最后手段使用，仅当原始更改完全错误时；优选的是递增修复。
### 稳定树

过去，网络子系统（netdev）的提交不应带有明确的 `CC: stable@vger.kernel.org` 标签，但现在情况已不再如此。请遵循文档 `Documentation/process/stable-kernel-rules.rst <stable_kernel_rules>` 中的标准稳定规则，并确保包含适当的 Fixes 标签！

### 安全修复

如果您认为发现了可能具有安全影响的漏洞，请不要直接给网络子系统的维护者发送邮件。
当前的网络子系统维护者一致要求人们使用邮件列表而不是直接联系。如果您不同意这种方式，可以考虑给 `security@kernel.org` 发送邮件或查阅 `http://oss-security.openwall.org/wiki/mailing-lists/distros`，作为可能的替代方案。

### 用户空间组件的变更发布

当用户空间代码在测试内核特性时，应与内核补丁一起发布。这使得评审者有机会看到新的接口如何被使用以及其效果如何。
当用户空间工具位于内核仓库中时，所有更改通常应作为一个系列提供。如果系列变得过大或者用户空间项目不在 netdev 上进行评审，则应包含一个公共仓库的链接，以便查看用户空间补丁。
如果用户空间工具位于独立的仓库但需要在 netdev 上进行评审（例如对 `iproute2` 工具的修改），内核和用户空间的补丁应在邮件列表上作为单独的系列（线程）发布，例如：

```
[PATCH net-next 0/3] net: 某个特性的介绍信
└─ [PATCH net-next 1/3] net: 某个特性的准备工作
└─ [PATCH net-next 2/3] net: 实现某个特性
└─ [PATCH net-next 3/3] selftest: net: 某个特性

[PATCH iproute2-next] ip: 添加对某个特性的支持
```

将这些作为单一主题发布是不鼓励的，因为这会让 Patchwork 混淆（截至 Patchwork 2.2.2 版本）。

### 准备变更

注意细节很重要。像评审者一样重读自己的工作。你可以从使用 `checkpatch.pl` 开始，甚至可以使用 `--strict` 标志。但不要盲目地机械化操作。
如果你的变更是一个bug修复，确保你的提交日志指示了终端用户可见的症状、其发生的原因，如有必要，解释为什么提议的修复是最好的解决方案。不要乱改空白字符，也如常见的那样，不要错误缩进跨多行的函数参数。如果是你的第一个补丁，先给自己发邮件来测试是否能在未打补丁的树上正确应用，确认基础设施没有破坏它。
最后，重新阅读 `Documentation/process/submitting-patches.rst <submittingpatches>`，以确保你没有重复文档中的常见错误。

### 标明目标树

为了帮助维护者和持续集成（CI）机器人，你应该明确标记你的补丁针对的是哪个树。假设你使用 Git，使用前缀标志：

```
git format-patch --subject-prefix='PATCH net-next' start..finish
```

对于 `net` 内容的bug修复，使用 `net` 而不是 `net-next`（始终使用小写）。

### 将工作划分为补丁

设身处地为评审者考虑。每个补丁都是单独阅读的，因此应该构成向你声明的目标前进的一个可理解的步骤。
避免发送超过15个补丁的系列。较大的系列审查时间更长，因为评审者会推迟到找到大块时间再查看。较小的系列可以在短时间内完成审查，因此维护者们就会直接处理。结果是，一系列较小的补丁集合并更快且审查覆盖率更高。重新发布大型系列也会增加邮件列表的流量。

多行注释
~~~~~~~~

网络和大部分代码树中的注释风格约定略有不同。而不是这样：

  /*
   * foobar blah blah blah
   * 另一行文字
   */

要求你使其看起来像这样：

  /* foobar blah blah blah
   * 另一行文字
   */

局部变量排序（“逆向圣诞树”，“RCS”）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

网卡设备有一套关于函数中局部变量排序的约定。
将变量声明行按从最长到最短的顺序排列，例如：

  struct scatterlist *sg;
  struct sk_buff *skb;
  int err, i;

如果变量间存在依赖关系导致无法排序，则将初始化移出当前行。

格式优先级
~~~~~~~~~~

在使用非标准格式的现有代码中工作时，使你的代码遵循最新的指导原则，以便最终所有网卡设备领域的代码都采用首选格式。

审查后重发
~~~~~~~~~~

在两次发布之间至少间隔24小时。这将确保来自全球各地的评审者有机会发表意见。但也不要等待太久（几周），否则会使评审者更难回忆起所有上下文。

确保你在新发布的版本中解决了所有反馈。除非评审者直接指示，否则不要在对前一版本的讨论仍在进行时发布新版本的代码。

新版本的补丁应作为单独的主题发布，而不是对前一次发布的回复。变更日志应包含对前一次发布的链接（参见：请求的变更）。

测试
----

预期的测试级别
~~~~~~~~~~~~~~

最起码，你的更改必须能在设置 `W=1` 的情况下通过 `allyesconfig` 和 `allmodconfig` 构建，且没有新的警告或失败。

理想情况下，你已经针对你的更改进行了运行时测试，并且补丁系列包含了一套内核自测，用于 `tools/testing/selftests/net` 或使用 KUnit 框架。

你应当在相关网络树（如 `net` 或 `net-next`）上测试你的更改，而不是在稳定树或 `linux-next` 上。
拼凑检查（Patchwork Checks）

Patchwork中的检查大多是对现有内核脚本的简单封装，其源码可从以下地址获取：

https://github.com/linux-netdev/nipa/tree/master/tests

**切勿**仅仅为了运行检查而发布你的补丁。你必须确保在邮件列表上发布前，已通过本地测试验证了补丁的正确性。Patchwork构建机器人实例很容易过载，如果可能的话，我们真的不需要给netdev@vger带来更多的流量。

Netdevsim

``netdevsim``是一个测试驱动程序，无需具备实际硬件即可用于测试驱动配置APIs。
当添加新APIs时，强烈建议基于``netdevsim``进行模拟和测试，但``netdevsim``本身**不是**使用案例或用户。你还必须在真实驱动中实现新APIs。
我们不保证``netdevsim``将来不会以会破坏通常被认为是uAPI的方式改变。
``netdevsim``仅保留用于上游测试，因此任何新的``netdevsim``功能都必须附带在``tools/testing/selftests/``下的自测。

评审者指导

鼓励评审邮件列表上的他人补丁，无论评审者的专业水平如何。对于一般性的指导和有用的提示，请参阅：:ref:`development_advancedtopics_reviews`
可以安全地假设netdev维护者了解社区和评审者的专业水平。评审者不必担心他们的评论会阻碍或使补丁流程脱轨。
鼓励经验较少的评审者对提交内容进行更深入的评审，而不应只专注于代码格式、标签等琐碎或主观问题。

证言 / 反馈

一些公司会在员工绩效评估中使用同行反馈。这可以帮助员工理解他们工作中的优点和需要改进的地方，同时也能促进团队内部的沟通和协作。通过同行的正面评价，员工可以得到认可和激励；而建设性的批评则可以帮助他们识别盲点，提升技能。这种机制鼓励开放和诚实的反馈文化，有利于个人成长和团队发展。
请随时向网络开发维护者请求反馈，
特别是当你花费大量时间审查代码
并尽力改进共享基础设施时。
反馈必须由您，即贡献者提出请求，并且始终
会与您共享（即使您要求将其提交给您的经理）。
