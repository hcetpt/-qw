### SPDX 许可证标识符: GPL-2.0

### 网络子系统 (netdev)

#### tl;dr（简要说明）

- 标记你的补丁为某个树 - `[PATCH net]` 或 `[PATCH net-next]`
- 对于修复补丁，无论哪个树都需要 `Fixes:` 标签
- 不要发布大型系列 (> 15 个补丁)，请将其拆分
- 不要在 24 小时内重新发布你的补丁
- 遵循反向圣诞树规则

### netdev

netdev 是一个用于所有与 Linux 相关的网络开发的邮件列表。这包括在 Linux 源代码中的 net/ 目录下的内容（例如 IPv6 的核心代码）以及 drivers/net/ 下的内容（例如特定硬件的驱动程序）。请注意，某些子系统（如无线驱动程序）由于流量较大而有自己的专用邮件列表和树。

像许多其他的 Linux 邮件列表一样，netdev 列表托管在 kernel.org，并且可以在 https://lore.kernel.org/netdev/ 查看归档。除了上述子系统之外，所有与 Linux 网络相关的开发活动（即 RFC、审查、评论等）都在 netdev 上进行。

#### 开发周期

这里有一些关于 Linux 开发节奏的基本信息。每个新版本开始时会有两周的“合并窗口”，在此期间主要维护者会将他们的新内容提交给 Linus 合并到主线树中。两周后，合并窗口关闭，并标记为 `-rc1`。在此之后不再合并新的功能，只接受对 `-rc1` 内容的修复。大约一周收集 `-rc1` 内容的修复后，会发布 `-rc2`。这个过程大约每周重复一次，直到 `-rc7`（通常情况下；如果一切平静有时会在 `-rc6`，如果还在大规模变动则可能到 `-rc8`），然后在最后一个 vX.Y-rcN 标签发布的一周后，正式的 vX.Y 版本就会发布。

要了解当前所处的开发周期阶段，请访问主线（Linus）页面：

  https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git

并注意 “标签” 部分顶部。如果是 `-rc1`，则处于开发周期的早期。如果一周前标记了 `-rc7`，那么可能会很快发布。如果最近的标签是最终发布标签（没有 `-rcN` 后缀），则很可能正处于合并窗口期，此时 `net-next` 已经关闭。

#### git 树和补丁流

有两个网络树（git 仓库）在使用。这两个都是由主要网络维护者 David Miller 推动的。一个是 `net` 树，另一个是 `net-next` 树。顾名思义，`net` 树是用于修复已经在 Linus 主线树中的现有代码，而 `net-next` 树则是用于存放未来版本的新代码。这些树可以在以下位置找到：

- https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git
- https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git

与内核开发相关：在为期两周的合并窗口开始时，`net-next` 树将被关闭 - 不再接受任何新的更改或功能。过去约 10 周积累的新内容将通过拉取请求传递给主线/Linus 以用于 vX.Y 版本 —— 同时，`net` 树将开始累积与此拉取内容相关的修复，这些修复与 vX.Y 版本有关。

通常会在 netdev 上发布公告，指示 `net-next` 已经关闭的时间点，但根据上述信息，你可以提前预测这一点。

**警告：**
不要在 `net-next` 树关闭期间向 netdev 发送新的 `net-next` 内容。

仅用于审查的 RFC 补丁随时都受欢迎（使用 `git format-patch --subject-prefix='RFC net-next'`）。
在两周时间过去后不久（并且发布了vX.Y-rc1），`net-next`的代码库重新开放以收集下一次发布(vX.Y+1)的内容。
如果你没有订阅netdev，或者只是不确定`net-next`是否已经重新开放，只需检查上面提供的`net-next` Git仓库链接是否有新的网络相关提交。你也可以通过以下网站查看当前状态：

  https://netdev.bots.linux.dev/net-next.html

`net`树继续收集vX.Y内容的修复，并以定期（大约每周）的频率反馈给Linus。这意味着`net`的重点在于稳定性和错误修复。
最终，vX.Y版本被发布，整个周期再次开始。
netdev补丁审查
---------------

.. _patch_status:

补丁状态
~~~~~~~~~~

可以通过查看netdev的主要补丁队列来检查补丁的状态：

  https://patchwork.kernel.org/project/netdevbpf/list/

“状态”字段将准确地告诉你你的补丁处于何种状态：

================== =============================================================
补丁状态           描述
================== =============================================================
新，审核中       等待审查，补丁在维护者的审查队列中；这两种状态可以互换使用（取决于处理补丁工作的具体共同维护者）
已接受            补丁已被应用到适当的网络树，这通常由pw-bot自动设置
等待确认         等待领域专家或测试人员的认可
需要修改          补丁未通过审查，期望有适当代码和提交信息修改的新版本
已拒绝            补丁已被拒绝，不期望有新版本
不适用            预期将在网络子系统之外应用补丁
等待上游          补丁应由适当的子维护者审查并处理，他们将会将其发送到网络树；netdev的补丁队列中设置为“等待上游”的补丁通常会保持此状态，无论子维护者是请求更改、接受还是拒绝了该补丁
延期              补丁需要稍后重新发布，通常是由于依赖关系或因为它是为关闭的树发布的
已替代            发布了补丁的新版本，通常由pw-bot设置
征求意见          不应用于，通常不在维护者的审查队列中，pw-bot可以根据主题标签自动将补丁设置为此状态
================== ==============================================================

补丁通过它们电子邮件中的`Message-ID`头进行索引，所以如果你难以找到你的补丁，可以在上述URL后面加上`Message-ID`的值。
更新补丁状态
~~~~~~~~~~~~~~

贡献者和审阅者没有直接在Patchwork中更新补丁状态的权限。Patchwork没有提供关于补丁状态历史记录的太多信息，因此让多个人更新状态会导致混乱。
而不是委派Patchwork权限，netdev使用一个简单的邮件机器人，它会在发送到邮件列表的邮件中查找特殊的命令/行。例如，要将系列标记为“需要修改”，需要在邮件线程中的任何位置发送以下行：

  pw-bot: changes-requested

结果，机器人将整个系列设置为“需要修改”。
当作者在自己的系列中发现bug并希望阻止其被应用时，这可能很有用。
机器人的使用完全是可选的，如果不确定，完全可以忽略它的存在。维护者将自行分类并更新补丁的状态。不应向列表发送任何主要目的是与机器人通信的邮件，机器人命令应被视为元数据。
机器人的使用仅限于补丁的作者（提交补丁和命令时的`From:`头必须匹配！）、根据MAINTAINERS文件修改代码的维护者（同样，`From:`必须与MAINTAINERS条目匹配）以及少数资深审阅者。
机器人记录其活动在这里：

  https://netdev.bots.linux.dev/pw-bot.html

审查时间表
~~~~~~~~~~~

一般来说，补丁很快就会被分类（不到48小时）。但请耐心等待，如果你的补丁在patchwork中是活跃的（即它列在项目的补丁列表上），那么它被遗漏的可能性几乎为零。
网卡开发的高度活跃使得评审人员会相对较快地从讨论中移开。在一周的沉默之后，几乎不可能再收到新的评论或回复。如果一个补丁在Patchwork上不再处于活跃状态，并且讨论线程已闲置超过一周，请澄清下一步行动和/或发布新版本。
对于RFC发布的特别说明，如果一周内没有人回复，则可能是评审人员错过了该发布或者对此没有强烈的意见。如果代码已经准备就绪，可以作为PATCH重新发布。
仅发送“ping”或“bump”的邮件被认为是不礼貌的。如果你无法从Patchwork判断出补丁的状态或讨论的进展，请描述你认为最可能的情况并询问是否正确。例如：

  我不明白接下来的步骤是什么。X似乎对A不满意，我应该做B然后重新发布补丁吗？

.. _请求变更:

请求变更
~~~~~~~~~

被标记为``请求变更``的补丁需要进行修订。新版本应当附带变更日志，最好包括前次发布的链接，例如：

  [PATCH net-next v3] 网络：让奶牛发出哞哞声

  即使那些不喝牛奶的用户也会欣赏听到奶牛发出“哞哞”声
哞哞声的数量将取决于数据包速率，因此应该很好地匹配昼夜周期
签署确认：Joe Defarmer <joe@barn.org>
  ---
  v3:
    - 在提交信息中增加关于一天中哞哞声波动的注释
  v2: https://lore.kernel.org/netdev/123themessageid@barn.org/
    - 修复`netif_is_bovine()`函数文档中缺失的参数
    - 修复`netdev_register_cow()`中的内存泄漏
  v1: https://lore.kernel.org/netdev/456getstheclicks@barn.org/

提交信息应修订以回答评审人员之前讨论中提出的问题。有时，更新提交信息将是新版中的唯一更改。
部分重发
~~~~~~~~~~~~~~~

请始终重发整个补丁系列，并确保编号你的补丁，以便明确这是最新且最佳的一组可应用的补丁。不要尝试只重发有变动的补丁。
处理误应用的补丁
~~~~~~~~~~~~~~~~~~~~~~~~~~~

偶尔，一个补丁系列会在收到关键反馈之前就被应用，或者错误版本的补丁系列被应用了。
一旦补丁被推送出去，就无法让它消失，网卡开发树中的提交历史是不可变的。
为了修正补丁，使其看起来像是如果最新的补丁系列被合并时的样子，请在已合并的内容之上发送增量版本。
在需要完全撤销的情况下，撤销必须作为补丁提交到列表中，并附带解释被撤销提交技术问题的提交信息。撤销应作为最后手段使用，仅当原始更改完全错误时才使用；推荐使用增量修复。
### 稳定树

过去，网络子系统（netdev）的提交不应带有明确的 `CC: stable@vger.kernel.org` 标签，但现在情况已不再如此。请遵循文档 `Documentation/process/stable-kernel-rules.rst <stable_kernel_rules>` 中的标准稳定规则，并确保包含适当的 Fixes 标签！

### 安全修复

如果您认为发现了可能具有安全影响的漏洞，请不要直接给网络子系统的维护者发送邮件。
当前的网络子系统维护者一致要求人们使用邮件列表而不是直接联系。如果您不同意这种方式，可以考虑给 `security@kernel.org` 发送邮件或查阅 `http://oss-security.openwall.org/wiki/mailing-lists/distros`，作为可能的替代方案。

### 用户空间组件的变更发布

当用户空间代码在测试内核特性时，应与内核补丁一起发布。这使得评审者有机会看到新接口如何被使用以及其效果如何。
当用户空间工具位于内核仓库中时，所有更改通常应作为一个系列提供。如果系列变得过大或者用户空间项目不在 netdev 上进行评审，则应包含一个公共仓库的链接，以便查看用户空间补丁。
如果用户空间工具位于独立的仓库但需要在 netdev 上进行评审（例如对 `iproute2` 工具的修改），内核和用户空间的补丁应在邮件列表上作为单独的系列（线程）发布，例如：

```
[PATCH net-next 0/3] net: 某个特性的介绍信
└─ [PATCH net-next 1/3] net: 某个特性的准备工作
└─ [PATCH net-next 2/3] net: 实现某个特性
└─ [PATCH net-next 3/3] selftest: net: 某个特性

[PATCH iproute2-next] ip: 添加对某个特性的支持
```

将这些作为单一主题发布是不鼓励的，因为这会让 Patchwork 混淆（截至 Patchwork 2.2.2 版本）。

### 准备变更

注意细节很重要。像评审者一样重读自己的工作。你可以从使用 `checkpatch.pl` 开始，甚至可以使用 `--strict` 标志。但不要盲目地机械化操作。
如果你的变更是一个bug修复，确保你的提交日志指示了终端用户可见的症状、其发生的原因，如有必要，解释为什么提议的修复是最好的解决方案。不要乱改空白字符，也如常见的那样，不要错误缩进跨多行的函数参数。如果是你的第一个补丁，先给自己发邮件，以便测试是否能在未打补丁的树上正确应用，以确认基础设施没有破坏它。
最后，请回过头来阅读 `Documentation/process/submitting-patches.rst <submittingpatches>`，以确保你没有重复那里记录的一些常见错误。

### 指定目标树

为了帮助维护者和 CI 机器人，你应该明确标记你的补丁针对的是哪个树。假设你使用 git，可以使用前缀标志：

```bash
git format-patch --subject-prefix='PATCH net-next' start..finish
```

对于 `net` 内容的 bug 修复，使用 `net` 而不是 `net-next`（始终使用小写字母）。

### 将工作分成补丁

设想自己处于评审者的角度。每个补丁都是分开阅读的，因此应该构成一个连贯的步骤，朝着你所陈述的目标前进。
避免发送超过15个补丁的系列。较大的系列需要更长的时间来审查，因为审查者会推迟查看，直到他们有足够的时间。一个小的系列可以在短时间内完成审查，因此维护者会直接进行审查。结果，一系列较小的系列能更快地合并，并且审查覆盖率更好。重新发布大型系列也会增加邮件列表的流量。

多行注释
~~~~~~~~~

对于网络部分和其他大部分代码树而言，注释风格约定略有不同。而不是这样：

  ```
  /*
   * foobar 一堆废话
   * 另一行文字
   */

要求你这样做：

  ```
  /* foobar 一堆废话
   * 另一行文字
   */

局部变量排序（“反向圣诞树”，“RCS”）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在网络设备中有一个关于函数中局部变量声明顺序的约定：从最长到最短排序，例如：

  ```
  struct scatterlist *sg;
  struct sk_buff *skb;
  int err, i;
  
如果变量之间存在依赖关系而无法按此顺序排列，则将初始化移到声明之外。
格式优先级
~~~~~~~~~~

在使用非标准格式的现有代码中工作时，请让你的代码遵循最新的指导原则，以便最终所有网路设备领域的代码都能采用首选格式。
审查后重新发送
~~~~~~~~~~~~~~

两次发布之间至少相隔24小时。这将确保来自所有地理区域的审查者都有机会发表意见。也不要等待太久（几周），否则会让审查者更难回忆起所有上下文。
确保你在新发布的版本中解决了所有反馈。除非审查者直接指示，否则不要在关于前一版本的讨论仍在进行时发布新版本的代码。
新版本的补丁应作为单独的主题发布，而不是作为对前一次发布的回复。更改日志应包含指向先前发布的链接（参见 :ref:`请求的更改`）。
测试
----

预期的测试级别
~~~~~~~~~~~~~~~~

最起码，你的更改必须能够通过设置 `W=1` 的 `allyesconfig` 和 `allmodconfig` 构建，而不产生新的警告或失败。
理想情况下，你应该已经进行了针对你的更改的具体运行时测试，并且补丁系列中包含了一组用于 `tools/testing/selftests/net` 或使用 KUnit 框架的内核自测。
你被期望在相关网络代码树上（如 `net` 或 `net-next`）测试你的更改，而不是在一个稳定版或 `linux-next` 上。
拼接检查 (Patchwork Checks)
~~~~~~~~~~~~~~~~~~~~~~~~~~

Patchwork 中的检查大多是对现有内核脚本的简单封装，其源代码可从以下地址获取：

https://github.com/linux-netdev/nipa/tree/master/tests

**请勿** 仅仅为了运行这些检查就发布您的补丁。您必须确保在将补丁发布到邮件列表之前已经通过本地测试验证了它们的有效性。Patchwork 构建机器人实例非常容易过载，并且如果可能的话，我们真的不需要给 netdev@vger 增加更多的流量。
Netdevsim
~~~~~~~~~

`Netdevsim` 是一个测试驱动程序，可用于在不需要具备实际硬件的情况下测试驱动程序配置 API。
强烈建议在添加新 API 时使用基于 `netdevsim` 的模拟和测试，但 `netdevsim` 本身 **不是** 使用案例或用户。您还必须在真实的驱动程序中实现新的 API。
我们不保证 `netdevsim` 不会在将来发生变化，以至于破坏通常被认为是用户空间 API 的部分。
`netdevsim` 仅保留用于上游测试使用，因此任何新的 `netdevsim` 功能都必须伴随着在 `tools/testing/selftests/` 目录下的自测代码。
评审指导
-----------------

鼓励大家积极参与邮件列表上的其他人的补丁评审工作，无论你的技术水平如何。对于一般性的指导和有用的提示，请参阅 :ref:`development_advancedtopics_reviews`
可以认为网络开发维护者了解社区和评审者的专业水平。评审者不必担心他们的评论会阻碍或使补丁流程脱轨。
鼓励经验较少的评审者对提交内容进行更深入的审查，而不仅仅是关注像代码格式、标签等这样的琐碎或主观问题。
推荐信 / 反馈
------------------

一些公司会在员工绩效评估中采用同行反馈。
请随时向网络开发维护者请求反馈，
特别是当你花费大量时间审查代码
并尽力改进共享基础设施时。
反馈必须由您，即贡献者提出请求，并且始终
会与您共享（即使您要求将其提交给您的经理）。
