.. _codingstyle:

Linux 内核编码风格
=========================

这是一个简短的文档，描述了 Linux 内核所推荐的编码风格。编码风格是非常个人化的，我不会强迫任何人接受我的观点，但对于我需要维护的所有代码，我都会采用这种风格，并且希望大多数其他代码也能如此。请至少考虑以下几点。

首先，建议打印一份 GNU 编码标准，并且不要阅读它。烧掉它，这会是一个很好的象征性举动。
无论如何，下面是具体的内容：

1) 缩进
--------------

制表符为 8 个字符，因此缩进也是 8 个字符。
有些异端运动试图将缩进设置为 4（甚至 2！）个字符，这就像试图将圆周率定义为 3 一样荒谬。
理由：缩进的主要目的是清晰地定义控制块的开始和结束位置。特别是在你连续盯着屏幕看了 20 个小时后，你会发现大缩进更容易辨识。
有些人会说，8 字符的缩进会使代码向右移动太多，使得在 80 字符宽的终端屏幕上难以阅读。对此的回答是，如果你需要超过 3 层的缩进，那你可能已经陷入了困境，应该修正你的程序。
简而言之，8 字符的缩进使代码更易于阅读，并且还有一个额外的好处，即警告你是否嵌套得太深。
请关注这一警告。
在 switch 语句中缓解多层缩进的一种推荐方法是在同一列对齐 `switch` 和其下属的 `case` 标签，而不是将 `case` 标签“双重缩进”。例如：

.. code-block:: c

	switch (suffix) {
	case 'G':
	case 'g':
		mem <<= 30;
		break;
	case 'M':
	case 'm':
		mem <<= 20;
		break;
	case 'K':
	case 'k':
		mem <<= 10;
		fallthrough;
	default:
		break;
	}

除非你有东西要隐藏，否则不要在一行上放置多个语句：

.. code-block:: c

	if (condition) do_this();
	do_something_everytime;

不要使用逗号来避免使用花括号：

.. code-block:: c

	if (condition)
		do_this(), do_that();

对于多个语句始终使用花括号：

.. code-block:: c

	if (condition) {
		do_this();
		do_that();
	}

也不要将多个赋值放在一行上。内核编码风格非常简单，避免复杂的表达式。
除了注释、文档以及 Kconfig 中之外，从不使用空格进行缩进，上述示例是故意破坏的。
1) 获取一个合适的编辑器，并且不要在行末留有空白
2) 折行长行和字符串
------------------

编码风格主要是关于可读性和可维护性，使用常见的工具。
单行长度的首选限制是80列。
超过80列的语句应被拆分成合理的块，除非超过80列能显著提高可读性并且不会隐藏信息。
子项总是明显短于父项，并且明显向右缩进。一种非常常用的做法是将子项对齐到函数的左括号。
这些相同的规则也适用于带有长参数列表的函数头。
但是，永远不要折行用户可见的字符串，例如printk消息，因为这会破坏通过grep搜索它们的能力。
3) 大括号和空格的位置
------------------------

C语言中另一个经常出现的问题是大括号的位置问题。与缩进大小不同的是，在选择一种放置策略时几乎没有技术上的原因，但根据先知Kernighan和Ritchie所示，首选的方式是将开括号放在行尾，闭括号放在行首，如下所示：

.. code-block:: c

	if (x is true) {
		we do y
	}

这适用于所有非函数的语句块（如if、switch、for、while、do）。例如：

.. code-block:: c

	switch (action) {
	case KOBJ_ADD:
		return "add";
	case KOBJ_REMOVE:
		return "remove";
	case KOBJ_CHANGE:
		return "change";
	default:
		return NULL;
	}

然而，有一个特殊情况，即函数：它们的开括号位于下一行的开头，如下所示：

.. code-block:: c

	int function(int x)
	{
		body of function
	}

世界各地的异端人士声称这种不一致性是……嗯……不一致的，但所有正直的人都知道（a）K&R是对的，（b）K&R是对的。此外，函数本身也是特殊的（在C语言中你不能嵌套函数）。
请注意，闭括号单独占一行，**除非**其后紧跟着同一语句的延续部分，例如do语句中的while或if语句中的else，如下所示：

.. code-block:: c

	do {
		body of do-loop
	} while (condition);

以及

.. code-block:: c

	if (x == y) {
		.
} else if (x > y) {
		..
} else {
		...
}

### 理由：K&R风格
此外，请注意这种大括号放置方式最大限度地减少了空行（或几乎空的行）的数量，而不损失可读性。因此，由于屏幕上的新行并不是可再生资源（想象一下只有25行的终端屏幕），你就有更多的空行可以用来添加注释。
不要在单个语句可用的情况下不必要的使用大括号。

```c
if (condition)
    action();
```

和

```c
if (condition)
    do_this();
else
    do_that();
```

如果条件语句的一个分支是单个语句，则不适用此规则；在这种情况下，应在两个分支中都使用大括号：

```c
if (condition) {
    do_this();
    do_that();
} else {
    otherwise();
}
```

此外，当循环包含多个简单语句时，也应使用大括号：

```c
while (condition) {
    if (test)
        do_something();
}
```

### 3.1 空格
***********

Linux 内核风格中空格的使用主要取决于函数与关键字的用法。大多数关键字后面应加一个空格。明显的例外是 `sizeof`、`typeof`、`alignof` 和 `__attribute__`，它们看起来有点像函数（并且通常在 Linux 中与圆括号一起使用，尽管语言本身并不强制要求这样做，例如在声明 `struct fileinfo info;` 后使用 `sizeof info`）
因此，在这些关键字后面不要加空格：

`if`, `switch`, `case`, `for`, `do`, `while`

但不要在 `sizeof`、`typeof`、`alignof` 或 `__attribute__` 后面加空格。例如：

```c
s = sizeof(struct file);
```

不要在圆括号内的表达式周围添加空格。下面的例子是错误的：

```c
s = sizeof( struct file );
```

在声明指针数据或返回指针类型的函数时，`*` 的首选位置是在数据名或函数名旁边，而不是类型名旁边。例如：

```c
char *linux_banner;
unsigned long long memparse(char *ptr, char **retptr);
char *match_strdup(substring_t *s);
```

对于大多数二元和三元运算符，两边各加一个空格，如以下任何一种：

`=`, `+`, `-`, `<`, `>`, `*`, `/`, `%`, `|`, `&`, `^`, `<=`, `>=`, `==`, `!=`, `?`, `:`

但在一元运算符后面不要加空格：

`&`, `*`, `+`, `-`, `~`, `!`, `sizeof`, `typeof`, `alignof`, `__attribute__`, `defined`

在后置增量和减量一元运算符前不要加空格：

`++`, `--`

在前置增量和减量一元运算符后不要加空格：

`++`, `--`

结构成员运算符 `.` 和 `->` 周围不要加空格。

不要在线末尾留下空白。有些具有“智能”缩进功能的编辑器会在新行的开头适当插入空白，以便你可以立即开始键入下一行代码。
然而，如果最终没有在那里放一行代码，比如留下一个空行，一些这样的编辑器不会删除这些空白，结果你会得到包含尾随空白的行。
Git 会警告你引入尾随空白的补丁，并且可以选择为你删除尾随空白；但是，如果应用一系列补丁，这可能会使后续补丁因更改上下文行而失败。

### 4) 命名
--------------

C 是一种简朴的语言，你的命名约定也应遵循这一原则。
与 Modula-2 和 Pascal 程序员不同，C 程序员不会使用像 `ThisVariableIsATemporaryCounter` 这样的可爱变量名。一个 C 程序员会把这个变量称为 `tmp`，这更容易书写，并且一点也不难理解。
然而，虽然混合大小写的变量名是不被提倡的，但全局变量的描述性命名却是必须的。将全局函数命名为 `foo` 是不可接受的。
全局变量（只有在你**真的**需要它们时才使用）需要具有描述性的名称，全局函数也是如此。如果你有一个计算活动用户数量的函数，应该将其命名为 `count_active_users()` 或类似的名称，而不应将其命名为 `cntusr()`。
将函数类型编码到名称中（所谓的匈牙利命名法）是愚蠢的——编译器本身就知道这些类型并且可以进行检查，这样做只会让程序员感到困惑。
局部变量名应该简短且直截了当。如果你有一个随机的整数循环计数器，它应该被称为 `i`。
如果这个变量没有被误解的风险，将其命名为 `loop_counter` 是不切实际的。同样地，`tmp` 可以是任何用于存储临时值的变量。
如果你担心混淆局部变量名，那你就遇到了另一个问题，这个问题被称为“函数生长激素失衡综合症”。
请参阅第 6 章（函数）。
对于符号名称和文档，应避免引入新的 “主从”（或单独的 “从属”）以及 “黑名单/白名单” 的用法。
推荐替代 “主从” 的用法如下：
- `{primary,main} / {secondary,replica,subordinate}`
- `{initiator,requester} / {target,responder}`
- `{controller,host} / {device,worker,proxy}`
- `leader / follower`
- `director / performer`

推荐替代 “黑名单/白名单” 的用法如下：
- `denylist / allowlist`
- `blocklist / passlist`

对于新用法的例外情况是为维护用户空间 ABI/API，或者在更新现有（截至 2020 年）硬件或协议规范时必须使用这些术语。对于新的规范，尽可能将其术语转换为内核编码标准。
### 类型定义（Typedefs）

请不要使用像 `vps_t` 这样的类型。

将类型定义用于结构体和指针是一个**错误**。当你在源代码中看到：

```c
vps_t a;
```

这到底是什么意思呢？
相比之下，如果代码写成：

```c
struct virtual_container *a;
```

那么你就可以明确知道 `a` 是什么了。

很多人认为类型定义能**提高可读性**。其实不然。它们只适用于以下几种情况：

(a) 完全不透明的对象（类型定义被积极用来**隐藏**对象的真正类型）
例如：`pte_t` 等不透明对象，只能通过适当的访问函数来访问。
注意：
- 不透明性和“访问函数”本身并不是好事。
我们之所以对 `pte_t` 等对象使用类型定义，是因为那里确实没有任何可以便携访问的信息。

(b) 明确的整数类型，抽象有助于避免混淆是否是 `int` 或 `long`
`u8/u16/u32` 是完全合理的类型定义，尽管它们更适合归类为 (d)。
注意：
- 再次强调，这里必须有一个**理由**。如果某个东西是 `unsigned long`，那么没有必要这样做：
```c
typedef unsigned long myflags_t;
```
但如果在某些情况下它可能是 `unsigned int`，而在其他配置下可能是 `unsigned long`，那么当然可以使用类型定义。

(c) 当你使用 `sparse` 来创建一个新的类型进行类型检查时。

这些是类型定义适用的情况。其他情况下，尽量避免使用类型定义。
(d) 在某些特殊情况下，与标准C99类型相同的新类型
尽管眼睛和大脑只需要很短的时间就能适应像 `uint32_t` 这样的标准类型，但有些人仍然反对使用这些类型。
因此，允许使用Linux特有的 `u8/u16/u32/u64` 类型及其有符号等价类型，尽管它们在你自己的新代码中不是强制性的。
当编辑已经使用了其中一种类型的现有代码时，你应该遵循该代码中已有的选择。

(e) 可以在用户空间安全使用的类型
在某些对用户空间可见的结构中，我们不能要求使用C99类型，也不能使用上述的 `u32` 形式。因此，在所有与用户空间共享的结构中，我们使用 `__u32` 和类似类型。
也许还有其他情况，但基本原则应该是：除非你能明确匹配那些规则之一，否则**永远不要**使用类型定义。
一般来说，指针或包含可以直接访问元素的结构**永远不应**被类型定义。

6) 函数
------------

函数应该简短且精炼，并且只做一件事。它们应该适合一到两屏文本（ISO/ANSI屏幕大小是80x24，众所周知），并且做好那一件事。
函数的最大长度与其复杂性和缩进级别成反比。因此，如果你有一个概念上简单的函数，只是一个长（但简单）的 `case` 语句，其中你需要为很多不同的情况做许多小事情，那么可以允许较长的函数。
然而，如果你有一个复杂的函数，并且你怀疑一个不太聪明的高中一年级学生可能根本无法理解这个函数是干什么的，那么你应该更加严格地遵守这些限制。使用具有描述性名称的帮助函数（如果你认为性能至关重要，可以要求编译器内联它们，它可能会做得比你更好）。
另一个衡量函数的标准是局部变量的数量。它们不应超过5到10个，否则说明你在做错什么。重新思考这个函数，并将其拆分成更小的部分。人脑通常能够轻松记住大约7件不同的事情，任何更多的信息都会让人感到困惑。你知道你是天才，但也许两周后你想理解自己当时做了什么。

在源文件中，用一个空行分隔函数。如果函数被导出，则其对应的 **EXPORT** 宏应该紧跟在闭合的大括号之后。例如：

```c
int system_is_up(void)
{
    return system_state == SYSTEM_RUNNING;
}
EXPORT_SYMBOL(system_is_up);
```

### 6.1) 函数原型
************************

在函数原型中，应包含参数名及其数据类型。
虽然这并不是C语言的要求，但在Linux中是首选的做法，因为它是一种简单的方式，为读者提供有价值的信息。
不要在函数声明中使用 `extern` 关键字，因为这会使行变长，而且并非严格必要。
编写函数原型时，请保持元素顺序的一致性。
例如，使用以下函数声明示例：

```c
__init void * __must_check action(enum magic value, size_t size, u8 count,
				  char *fmt, ...) __printf(4, 5) __malloc;
```

对于函数原型，推荐的元素顺序如下：

- 存储类别（如上所示，`static __always_inline`，注意 `__always_inline` 技术上是一个属性，但被视为 `inline`）
- 存储类别属性（如上所示，`__init` —— 即节区声明，但也包括 `__cold` 等）
- 返回类型（如上所示，`void *`）
- 返回类型属性（如上所示，`__must_check`）
- 函数名（如上所示，`action`）
- 函数参数（如上所示，`(enum magic value, size_t size, u8 count, char *fmt, ...)`，注意参数名应始终包含）
- 函数参数属性（如上所示，`__printf(4, 5)`）
- 函数行为属性（如上所示，`__malloc`）

请注意，在函数 **定义**（即实际函数体）中，编译器不允许在函数参数之后放置函数参数属性。在这种情况下，它们应该放在存储类别属性之后（请比较下面的 **定义** 示例中 `__printf(4, 5)` 的位置与上面的 **声明** 示例）：

```c
static __always_inline __init __printf(4, 5) void * __must_check action(enum magic value,
		size_t size, u8 count, char *fmt, ...) __malloc
{
	..
}
```

### 7) 函数集中退出
-----------------------------------

尽管有些人认为 `goto` 语句已经过时，但编译器经常以无条件跳转指令的形式使用 `goto` 语句。
当一个函数从多个位置退出并且需要做一些通用的工作（如清理）时，`goto` 语句会很有用。如果没有清理工作，则直接返回即可。
选择能说明 `goto` 所做的事情或为何存在 `goto` 的标签名称。一个好的名称示例可能是 `out_free_buffer:`，如果该 `goto` 释放了 `buffer`。
避免使用像 ``err1:`` 和 ``err2:`` 这样的 GW-BASIC 名称，因为如果你添加或删除退出路径时需要重新编号，并且这些名称使得正确性难以验证。

使用 `goto` 的理由是：

- 无条件语句更容易理解和跟踪。
- 减少了嵌套。
- 避免了在修改代码时不更新各个退出点而导致的错误。
- 节省编译器优化冗余代码的工作；)

```c
int fun(int a)
{
    int result = 0;
    char *buffer;

    buffer = kmalloc(SIZE, GFP_KERNEL);
    if (!buffer)
        return -ENOMEM;

    if (condition1) {
        while (loop1) {
            ..
        }
        result = 1;
        goto out_free_buffer;
    }
    ..

out_free_buffer:
    kfree(buffer);
    return result;
}
```

一种常见的错误类型是“单个错误”（one err bugs），如下所示：

```c
err:
    kfree(foo->bar);
    kfree(foo);
    return ret;
```

这段代码中的错误是在某些退出路径中 `foo` 是 NULL。通常解决方法是将其拆分为两个错误标签 `err_free_bar:` 和 `err_free_foo:`：

```c
err_free_bar:
    kfree(foo->bar);
err_free_foo:
    kfree(foo);
    return ret;
```

理想情况下，你应该模拟错误以测试所有退出路径。

8) 注释
-------

注释很好，但也有过度注释的危险。**永远不要**试图在注释中解释你的代码是如何工作的：最好编写易于理解的代码，解释糟糕的代码是浪费时间。
一般来说，你希望你的注释告诉别人你的代码做了什么，而不是如何做。
同时，尽量避免在函数体内部放置注释：如果函数复杂到需要单独注释其部分，则可能需要回顾第 6 章。你可以写一些小注释来标记或警告特别聪明（或丑陋）的地方，但尽量避免过多。相反，将注释放在函数头部，告诉人们它做了什么，以及为什么这样做。

当注释内核 API 函数时，请使用 kernel-doc 格式。详细信息请参阅 :ref:`Documentation/doc-guide/ <doc_guide>` 和 `scripts/kernel-doc` 文件。

对于长（多行）注释，首选风格如下：

```c
/*
 * 这是 Linux 内核源代码中多行注释的首选风格。
 * 
 */
```
* 请始终如一地使用它
*
	* 描述：左侧星号列，开头和结尾几乎空白的行

对于 net/ 和 drivers/net/ 目录下的文件，较长（多行）注释的首选风格略有不同。
.. code-block:: c

	/* 对于 net/ 和 drivers/net 目录下的文件，首选的注释风格如下所示
*
	* 这与一般首选的注释风格几乎相同，
	* 但没有最初的几乎空白的行
*/

注释数据也很重要，无论是基本类型还是派生类型。为此，请每行只声明一个数据（不要用逗号来声明多个数据）。这样可以为每个项目留出空间，以便添加简短的注释，解释其用途。
9) 你把事情搞砸了
---------------------------

没关系，我们都这样做过。你的长期 Unix 用户助手可能告诉你 `GNU emacs` 自动为你格式化 C 源代码，并且你也注意到确实如此，但是它使用的默认设置不太理想（实际上，比随机打字还糟糕——无数只猴子在 GNU emacs 上打字也永远不会写出一个好的程序）。
因此，你可以选择放弃 GNU emacs，或者更改它的设置以使用更合理的值。为了实现后者，你可以在 .emacs 文件中加入以下内容：

.. code-block:: elisp

  (defun c-lineup-arglist-tabs-only (ignored)
    "通过制表符而不是空格对齐参数列表"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (steps (floor offset c-basic-offset)))
      (* (max steps 1)
         c-basic-offset)))

  (dir-locals-set-class-variables
   'linux-kernel
   '((c-mode . (
          (c-basic-offset . 8)
          (c-label-minimum-indentation . 0)
          (c-offsets-alist . (
                  (arglist-close         . c-lineup-arglist-tabs-only)
                  (arglist-cont-nonempty
(c-lineup-gcc-asm-reg c-lineup-arglist-tabs-only))
                  (arglist-intro         . +)
                  (brace-list-intro      . +)
                  (c                     . c-lineup-C-comments)
                  (case-label            . 0)
                  (comment-intro         . c-lineup-comment)
                  (cpp-define-intro      . +)
                  (cpp-macro             . -1000)
                  (cpp-macro-cont        . +)
                  (defun-block-intro     . +)
                  (else-clause           . 0)
                  (func-decl-cont        . +)
                  (inclass               . +)
                  (inher-cont            . c-lineup-multi-inher)
                  (knr-argdecl-intro     . 0)
                  (label                 . -1000)
                  (statement             . 0)
                  (statement-block-intro . +)
                  (statement-case-intro  . +)
                  (statement-cont        . +)
                  (substatement          . +)
                  ))
          (indent-tabs-mode . t)
          (show-trailing-whitespace . t)
          ))))

  (dir-locals-set-directory-class
   (expand-file-name "~/src/linux-trees")
   'linux-kernel)

这将使 emacs 更好地适应位于 `~/src/linux-trees` 下的 C 文件的内核编码风格。
即使你在让 emacs 使用合理的格式化方面失败了，也并非一切都完了：可以使用 `indent`。
现在，再次强调，GNU indent 和 GNU emacs 一样有同样的脑残设置，这就是为什么你需要给它一些命令行选项。不过，这还不算太糟糕，因为即使 GNU indent 的开发者也承认 K&R 的权威（GNU 的人并不是邪恶的，他们只是在这个问题上严重误入歧途），因此你只需要给 indent 加上 `-kr -i8` 选项（表示 K&R 风格，8个字符缩进），或者使用 `scripts/Lindent`，后者按照最新的风格进行缩进。

`indent` 有很多选项，特别是在注释重新格式化方面，你可能需要查看手册页。但是请记住：`indent` 并不是解决糟糕编程的方法。

注意，你也可以使用 `clang-format` 工具来帮助你遵循这些规则，快速自动地重新格式化代码的一部分，并审查整个文件以发现编码风格错误、拼写错误和可能的改进。它还方便于排序 `#include` 指令，对变量/宏进行对齐，以及重排文本和其他类似任务。

详情请参阅文件 :ref:`Documentation/dev-tools/clang-format.rst <clangformat>`。

一些基本的编辑器设置，如缩进和行尾，如果使用的是兼容 EditorConfig 的编辑器，则会自动设置。更多信息请访问官方 EditorConfig 网站：https://editorconfig.org/

10) Kconfig 配置文件
----------------------

对于源码树中的所有 Kconfig* 配置文件，缩进方式有所不同。`config` 定义下的行使用一个制表符缩进，而帮助文本则额外使用两个空格进行缩进。例如：

```plaintext
config AUDIT
	bool "Auditing support"
	depends on NET
	help
	  启用可用于其他内核子系统的审计基础架构，例如 SELinux（该功能要求此日志记录 AVC 消息输出）。如果没有 CONFIG_AUDITSYSCALL，不执行系统调用审计。
```

具有危险性的功能（如某些文件系统的写支持）应在提示字符串中显著标明其危险性：

```plaintext
config ADFS_FS_RW
	bool "ADFS write support (DANGEROUS)"
	depends on ADFS_FS
	..
```

有关配置文件的完整文档，请参阅文件 `Documentation/kbuild/kconfig-language.rst`。

11) 数据结构
----------------------

在创建和销毁数据结构的单线程环境中，如果数据结构对外部可见，则应始终包含引用计数。在内核中不存在垃圾回收（而在内核之外，垃圾回收是缓慢且低效的），这意味着你绝对必须为所有用途添加引用计数。

引用计数意味着你可以避免加锁，并允许多个用户同时访问数据结构，而不必担心由于它们休眠或暂时做其他事情而导致结构突然消失。
请注意，锁定（locking）**不是**引用计数（reference counting）的替代品。锁定用于保持数据结构的一致性，而引用计数是一种内存管理技术。通常两者都需要，并且不应将它们混淆。

许多数据结构确实可以有两层引用计数，当存在不同“类别”的用户时。子类计数统计子类用户的数量，并在子类计数变为零时仅递减一次全局计数。

这种“多级引用计数”的例子可以在内存管理（`struct mm_struct`：mm_users 和 mm_count）和文件系统代码（`struct super_block`：s_count 和 s_active）中找到。

记住：如果另一个线程能够找到你的数据结构，并且你没有对其设置引用计数，那么你几乎肯定有一个bug。

12) 宏、枚举和RTL
-------------------------

定义常量和枚举中的标签的宏名称应大写。

```c
#define CONSTANT 0x12345
```

在定义多个相关常量时，建议使用枚举。

大写的宏名称是受欢迎的，但类似函数的宏可以使用小写命名。

一般来说，内联函数比类似函数的宏更可取。

具有多个语句的宏应该用 do-while 块包围：

```c
#define macrofun(a, b, c)			\
	do {					\
		if (a == 5)			\
			do_this(b, c);		\
	} while (0)
```

带有未使用的参数的函数式宏应替换为静态内联函数，以避免未使用变量的问题：

```c
static inline void fun(struct foo *foo)
{
}
```

由于历史原因，许多文件仍然采用“转换为 (void)”的方法来评估参数。然而，这种方法并不推荐。
内联函数解决了“带有副作用的表达式被多次求值”的问题，绕过了未使用的变量问题，并且通常比宏更好地进行了文档说明。

```c
/*
 * 尽可能避免这样做，而是选择静态内联函数
 */
#define macrofun(foo) do { (void) (foo); } while (0)
```

使用宏时应避免的问题：

1) 影响控制流的宏：

```c
#define FOO(x)					\
		do {					\
			if (blah(x) < 0)		\
				return -EBUGGERED;	\
		} while (0)
```

这是一个非常糟糕的做法。它看起来像一个函数调用，但实际上退出了“调用”函数；不要破坏那些阅读代码者的内部解析器。

2) 依赖于具有魔法名称的局部变量的宏：

```c
#define FOO(val) bar(index, val)
```

这看起来不错，但在阅读代码时会让人感到困惑，并且容易因看似无害的更改而破坏。

3) 使用作为左值的参数的宏：`FOO(x) = y;` 如果有人将 `FOO` 转换为内联函数，这将会带来问题。

4) 忽略优先级：使用表达式定义常量的宏必须将表达式括在圆括号中。注意类似的问题，特别是使用参数的宏。

```c
#define CONSTANT 0x4000
#define CONSTEXP (CONSTANT | 3)
```

5) 在类似于函数的宏中定义局部变量时的命名空间冲突：

```c
#define FOO(x)				\
	({					\
		typeof(x) ret;			\
		ret = calc_ret(x);		\
		(ret);				\
	})
```

`ret` 是一个常见的局部变量名——`__foo_ret` 更不容易与现有变量发生冲突。

cpp 手册详细介绍了宏。gcc 内部手册还涵盖了 RTL，这在内核中使用汇编语言时经常出现。

13) 打印内核消息
-------------------

内核开发者喜欢给人留下有学识的印象。请注意内核消息的拼写，以给人留下好印象。不要使用不正确的缩写形式（如“dont”），应使用“do not”或“don’t”。使消息简洁、清晰且明确。

内核消息不必以句号结尾。
打印带括号的数字（%d）没有增加任何价值，应避免这样做。
在 `<linux/dev_printk.h>` 中有许多驱动模型诊断宏，你应该使用这些宏来确保消息与正确的设备和驱动程序匹配，并带有正确的级别：`dev_err()`、`dev_warn()`、`dev_info()` 等。对于那些不与特定设备关联的消息，`<linux/printk.h>` 定义了 `pr_notice()`、`pr_info()`、`pr_warn()`、`pr_err()` 等。当驱动程序正常工作时，它们通常是静默的，因此除非出现问题，否则最好使用 `dev_dbg` 或 `pr_debug`。

编写良好的调试消息可能是一个挑战；一旦有了这些消息，它们对远程故障排除非常有帮助。然而，调试消息的打印方式与其他非调试消息不同。其他 `pr_XXX()` 函数会无条件地打印消息，而 `pr_debug()` 则不会；默认情况下它会被编译器删除，除非定义了 `DEBUG` 或设置了 `CONFIG_DYNAMIC_DEBUG`。这同样适用于 `dev_dbg()`，并且一个相关的约定使用 `VERBOSE_DEBUG` 将 `dev_vdbg()` 消息添加到已经由 `DEBUG` 启用的消息中。

许多子系统都有 Kconfig 调试选项来在相应的 Makefile 中启用 `-DDEBUG`；在其他情况下，特定文件会直接定义 `DEBUG`。当需要无条件打印调试消息时（例如，如果它已经在某个调试相关的 `#ifdef` 部分内），可以使用 `printk(KERN_DEBUG ...)`。

### 14) 内存分配

内核提供了以下通用内存分配器：`kmalloc()`、`kzalloc()`、`kmalloc_array()`、`kcalloc()`、`vmalloc()` 和 `vzalloc()`。关于这些函数的更多信息，请参阅 API 文档：:ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`

传递结构体大小的首选形式如下：

```c
p = kmalloc(sizeof(*p), ...);
```

另一种形式，即明确写出结构体名称，会损害可读性，并且在指针变量类型改变但传递给内存分配器的 `sizeof` 没有相应改变时引入错误的机会。将返回值（空指针）进行类型转换是多余的。从空指针转换为任何其他指针类型的转换是由 C 语言保证的。

分配数组的首选形式如下：

```c
p = kmalloc_array(n, sizeof(...), ...);
```

分配零初始化数组的首选形式如下：

```c
p = kcalloc(n, sizeof(...), ...);
```

这两种形式都会检查分配大小 `n * sizeof(...)` 是否溢出，并在发生溢出时返回 `NULL`。

这些通用分配函数在未使用 `__GFP_NOWARN` 时会在失败时输出堆栈转储，因此在返回 `NULL` 时不需要额外输出失败消息。

### 15) 内联病

似乎有一种常见的误解，认为 gcc 有一个名为 `inline` 的“让我更快”的神奇加速选项。虽然内联的使用有时是合适的（例如作为替换宏的方法，见第 12 章），但很多时候并不是。过度使用 `inline` 关键字会导致内核变得更大，进而由于更大的指令缓存（icache）占用导致整个系统变慢，以及因为可用内存减少导致页面缓存空间不足。想想看，页面缓存缺失会导致磁盘寻道，这通常需要 5 毫秒的时间。在这 5 毫秒内可以执行大量的 CPU 周期。

一个合理的经验法则是不要在超过三行代码的函数中使用 `inline`。例外情况是当参数已知为编译时常量时，结果是编译器可以在编译时优化掉大部分函数。一个很好的例子是 `kmalloc()` 的内联函数。

人们经常争论说，在静态函数只被使用一次的情况下添加 `inline` 总是好的，因为没有空间权衡。虽然从技术上讲这是正确的，但 gcc 可以自动内联这些函数而无需提示，而且当出现第二个用户时去除 `inline` 的维护问题超过了提示 gcc 做它本来就会做的事情所带来的潜在价值。
16) 函数返回值和名称
--------------------

函数可以返回多种类型的值，其中最常见的是一种表示函数成功或失败的值。这种值可以用错误代码整数表示（-Exxx 表示失败，0 表示成功），或者用布尔值表示（0 表示失败，非零值表示成功）。将这两种表示方式混淆是导致难以发现的 bug 的常见原因。如果 C 语言在整数和布尔值之间有明确的区别，编译器就能帮我们找到这些错误……但 C 语言并没有这样的机制。为了防止这类 bug，应始终遵循以下约定：

    如果函数名称是一个动作或命令，则该函数应返回一个错误代码整数。如果函数名称是一个谓词，则该函数应返回一个“成功”布尔值。

例如，“add work” 是一个命令，add_work() 函数成功时返回 0，失败时返回 -EBUSY。同样地，“PCI 设备存在” 是一个谓词，pci_dev_present() 函数在找到匹配设备时返回 1，找不到则返回 0。

所有导出（EXPORTed）的函数必须遵守此约定，所有公共函数也应如此。私有（静态）函数不必遵守，但建议这样做。

对于返回值为计算结果本身而不是表示计算是否成功的函数，不受此规则约束。通常它们通过返回一个超出范围的结果来表示失败。典型的例子是返回指针的函数；它们使用 NULL 或 ERR_PTR 机制来报告失败。

17) 使用 bool 类型
-------------------

Linux 内核中的 bool 类型是 C99 _Bool 类型的别名。bool 值只能取 0 或 1，并且隐式或显式转换为 bool 时会自动将其转换为 true 或 false。当使用 bool 类型时，不需要 !! 构造，从而消除了一个类别的 bug。

在处理 bool 值时，应使用 true 和 false 定义而不是 1 和 0。

在适当的情况下，可以随时使用 bool 类型作为函数返回类型和栈变量。鼓励使用 bool 类型以提高可读性，并且在存储布尔值时通常比使用 'int' 更好。

如果缓存行布局或值的大小很重要，则不要使用 bool 类型，因为其大小和对齐方式根据编译架构而变化。针对对齐和大小进行了优化的结构不应使用 bool 类型。

如果一个结构中有许多真/假值，考虑将它们合并到一个位字段中，每个成员占 1 位，或者使用适当的固定宽度类型，如 u8。
同样地，对于函数参数中的许多真/假值，可以合并为一个位运算的“标志”参数，并且在调用点具有裸露的真/假常量时，“标志”通常是一个更易读的选择。否则，在结构体和参数中有限使用布尔值可以提高可读性。

18) 不要重复发明内核宏
-------------------------------------

头文件 `include/linux/kernel.h` 包含了一些你应该使用的宏，而不是显式地自己编写它们的变体。例如，如果你需要计算数组的长度，可以利用以下宏：

```c
#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
```

同样地，如果你需要计算某个结构体成员的大小，可以使用：

```c
#define sizeof_field(t, f) (sizeof(((t*)0)->f))
```

还有一些 `min()` 和 `max()` 宏，如果你需要的话，它们会进行严格的类型检查。请随意浏览该头文件，看看还有什么其他已经定义的内容，不要在你的代码中重复实现它们。

19) 编辑器模行和其他冗余信息
------------------------------------

一些编辑器能够解释嵌入在源文件中的配置信息，这些信息通过特殊标记指示。例如，Emacs 解释如下标记的行：

```c
-*- mode: c -*-
```

或者像这样：

```c
/*
Local Variables:
compile-command: "gcc -DMAGIC_DEBUG_FLAG foo.c"
End:
*/
```

Vim 解释如下标记：

```c
/* vim:set sw=8 noet */
```

不要在源文件中包含任何这些信息。人们有自己的个人编辑器配置，你的源文件不应覆盖它们。这包括缩进和模式配置的标记。人们可能使用自己的自定义模式，或者可能有其他某种魔法方法来使缩进正确工作。

20) 内联汇编
-------------------

在架构特定的代码中，你可能需要使用内联汇编来与CPU或平台功能交互。当必要时，不要犹豫这样做。
然而，当C语言可以完成任务时，不要随意使用内联汇编。尽可能从C语言中操作硬件。

考虑编写简单的辅助函数来封装常见的内联汇编片段，而不是反复编写略有不同的内容。记住，内联汇编可以使用C参数。

大型、非平凡的汇编函数应该放在 `.S` 文件中，并在相应的C头文件中定义C原型。对于汇编函数的C原型，应使用 `asmlinkage`。

你可能需要将你的 asm 语句标记为 `volatile`，以防止GCC在未检测到任何副作用的情况下删除它。不过，这并不总是必需的，并且不必要地这样做可能会限制优化。
当在单个内联汇编语句中包含多个指令时，应将每个指令放在单独的引号字符串中，并在除最后一个字符串外的所有字符串末尾添加 ``\n\t`` 以正确缩进汇编输出中的下一个指令：

```c
asm ("magic %reg1, #42\n\t"
     "more_magic %reg2, %reg3"
     : /* outputs */ : /* inputs */ : /* clobbers */);
```

21) 条件编译
---------------------------

尽可能不要在 .c 文件中使用预处理条件（#if、#ifdef），这样做会使代码更难阅读且逻辑更难跟踪。相反，在定义函数的头文件中使用这些条件，并在 #else 情况下提供无操作（no-op）存根版本，然后从 .c 文件中无条件调用这些函数。编译器会避免生成存根调用的任何代码，从而产生相同的结果，但逻辑仍然容易跟踪。

优先选择编译整个函数，而不是函数的部分或表达式的一部分。与其在一个表达式中放入一个 ifdef，不如将表达式的部分或全部提取到一个单独的辅助函数中，并对该函数应用条件编译。

如果某个函数或变量可能在特定配置下未被使用，并且编译器会警告其定义未被使用，则标记该定义为 `__maybe_unused` 而不是将其包裹在预处理条件中。（然而，如果某个函数或变量总是未被使用，则应删除它。）

在代码中，尽可能使用 IS_ENABLED 宏将 Kconfig 符号转换为 C 布尔表达式，并在普通的 C 条件中使用它：

```c
if (IS_ENABLED(CONFIG_SOMETHING)) {
    ..
}
```

编译器会将条件常量折叠掉，并像 #ifdef 一样包含或排除代码块，因此这不会增加任何运行时开销。然而，这种方法仍然允许 C 编译器看到代码块内部的内容，并检查其正确性（语法、类型、符号引用等）。因此，如果代码块内部引用了在条件不满足时不存在的符号，仍然需要使用 #ifdef。

在任何非平凡的 #if 或 #ifdef 块（超过几行）的末尾，在 #endif 后放置一个注释，注明所使用的条件表达式。例如：

```c
#ifdef CONFIG_SOMETHING
..
#endif /* CONFIG_SOMETHING */
```

22) 不要使内核崩溃
---------------------------

通常情况下，决定是否使内核崩溃应由用户而非内核开发者来决定。

避免使用 panic()
*************

应谨慎使用 panic() 并且主要只在系统启动期间使用。

例如，在启动期间内存不足且无法继续时可以接受使用 panic()。

使用 WARN() 而不是 BUG()
****************************

不要添加任何使用 BUG() 变体的新代码，如 BUG()、BUG_ON() 或 VM_BUG_ON()。相反，应使用 WARN*() 变体，最好使用 WARN_ON_ONCE()，并可能带有恢复代码。如果没有合理的恢复方式，则不需要恢复代码。“我懒得做错误处理”并不是使用 BUG() 的借口。重大的内部损坏且无法继续的情况仍可使用 BUG()，但需要充分的理由。
使用 `WARN_ON_ONCE()` 而不是 `WARN()` 或 `WARN_ON()`
**************************************************

通常更倾向于使用 `WARN_ON_ONCE()`，而不是 `WARN()` 或 `WARN_ON()`，因为给定的警告条件如果发生的话，往往会多次出现。这可能会填满并循环利用内核日志，甚至会减慢系统速度，使过度的日志记录本身成为一个额外的问题。

不要轻易使用 `WARN`
*******************

`WARN*()` 用于意料之外、不应该发生的情况。`WARN*()` 宏不应用于任何在正常操作期间预期会发生的情况。例如，这些宏不是前置或后置断言。再次强调：`WARN*()` 不应用于由用户空间操作容易触发的条件。如果需要通知用户问题，`pr_warn_once()` 是一个可能的选择。

不要担心 `panic_on_warn` 用户
**************************************

关于 `panic_on_warn` 的几点说明：请记住 `panic_on_warn` 是一个可用的内核选项，并且许多用户设置了这个选项。这就是为什么上面有“不要轻易使用 `WARN`”的说明。然而，存在 `panic_on_warn` 用户并不是避免合理使用 `WARN*()` 的有效理由。这是因为启用 `panic_on_warn` 的人明确要求内核在 `WARN*()` 触发时崩溃，而这样的用户必须准备好应对系统更容易崩溃的后果。

使用 `BUILD_BUG_ON()` 进行编译时断言
**********************************************

使用 `BUILD_BUG_ON()` 是可接受并且被鼓励的，因为它是一个编译时断言，在运行时没有影响。

附录 I) 参考文献
----------------------

《C 程序设计语言（第二版）》
作者：Brian W. Kernighan 和 Dennis M. Ritchie
出版社：Prentice Hall, Inc., 1988
ISBN 0-13-110362-8（平装），0-13-110370-9（精装）

《程序设计实践》
作者：Brian W. Kernighan 和 Rob Pike
出版社：Addison-Wesley, Inc., 1999
ISBN 0-201-61586-X
GNU 手册 —— 符合 K&R 和本书的内容 —— 包括 cpp、gcc、gcc 内部原理 和 indent，均可从以下网址获取：https://www.gnu.org/manual/

WG14 是编程语言 C 的国际标准化工作组，网址：http://www.open-std.org/JTC1/SC22/WG14/

Kernel Coding Style，由 greg@kroah.com 在 2002 年的 OLS（Open Source Leadership Summit）上发表：
http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/
