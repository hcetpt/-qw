Linux 内核编程风格
=========================

这是一个简短的文档，描述了 Linux 内核首选的编程风格。编程风格是非常个人化的，我不会**强迫**我的观点给任何人，但对于任何我需要维护的代码，我都遵循这种风格，并且我也更希望大多数其他代码也采用这种风格。请至少考虑这里提出的各点。

首先，我建议打印一份 GNU 编程标准，然后**不要**去读它。把它烧掉，这将是一个伟大的象征性举动。
无论如何，下面就是具体的规则：

1) 缩进
--------------

Tab 键对应的空格数为 8 个，因此缩进也是 8 个字符。
有些异端运动试图将缩进设置为 4（甚至 2！）个字符，这相当于试图定义圆周率 π 的值为 3。
理由：缩进的基本想法是为了清晰地定义控制块的开始和结束。特别是当你连续盯着屏幕工作了 20 个小时后，你会发现如果使用较大的缩进会更容易看出其结构。
有些人会声称 8 个字符的缩进会使代码向右移动得太远，使得在 80 个字符宽的终端屏幕上难以阅读。对于这种情况的回答是：如果你需要超过 3 层的缩进，那么你的程序很可能已经存在问题，应该重新审视并改进你的程序。
简而言之，8 个字符的缩进使得代码更易于阅读，并且具有额外的好处，可以警告你是否嵌套函数过深。
请注意这个警告。
在 switch 语句中处理多层缩进的一种推荐方式是将 `switch` 和其下属的 `case` 标签对齐在同一列，而不是“双倍缩进”这些 `case` 标签。例如：

```c
switch (suffix) {
case 'G':
case 'g':
    mem <<= 30;
    break;
case 'M':
case 'm':
    mem <<= 20;
    break;
case 'K':
case 'k':
    mem <<= 10;
    /* fallthrough */
default:
    break;
}
```

除非你有想要隐藏的东西，否则不要在一行上写多个语句：

```c
if (condition) do_this();
do_something_everytime;
```

不要使用逗号来避免使用大括号：

```c
if (condition)
    do_this(), do_that();
```

对于包含多个语句的情况始终使用大括号：

```c
if (condition) {
    do_this();
    do_that();
}
```

也不要将多个赋值操作放在同一行。内核编程风格非常简单。避免使用复杂的表达式。
除了注释、文档以及 Kconfig 文件之外，在任何地方都不使用空格进行缩进，上面的例子是故意这样写的以示区别。
1) 获取一个体面的编辑器，不要在线尾留有空白
----------------------------------

2) 折行长行和字符串

编码风格关乎可读性和可维护性，利用通用工具
单行长度的首选限制是80列
超过80列的语句应当折分为合理的片段，
除非超过80列显著提升可读性且不会隐藏信息
子语句总是比父语句明显更短，
且明显向右对齐。一种非常常见的风格
是将子语句对齐到函数的左括号处
对于参数列表过长的函数头部也应用同样的规则
但是，切勿折行用户可见的字符串，例如printk消息，因为
这会破坏对其的grep搜索能力

3) 大括号和空格的放置
----------------------------

C语言风格中总会提及的另一个问题是大括号的放置。
与缩进大小不同，选择一种放置策略而非另一种在技术上几乎没有理由，
但根据先知Kernighan和Ritchie所展示的，首选的方式是
将左大括号放在行末，右大括号放在行首，如下所示：

.. code-block:: c

	if (x为真) {
		我们执行y
	}

这适用于所有非函数的语句块（如if、switch、for、while、do）。例如：

.. code-block:: c

	switch (action) {
	case KOBJ_ADD:
		return "add";
	case KOBJ_REMOVE:
		return "remove";
	case KOBJ_CHANGE:
		return "change";
	default:
		return NULL;
	}

然而，有一个特殊情况，即函数：它们的左大括号位于下一行的开头，如下：

.. code-block:: c

	int function(int x)
	{
		函数主体
	}

世界各地的异端人士声称这种不一致性是...嗯...不一致的，
但所有思想正确的人都知道(a) K&R是**正确的**，(b) K&R是正确的。
此外，函数本来就特殊（在C语言中你不能嵌套函数）
注意，除了在某些情况下紧随其后的是同一语句的延续，
如do语句中的`while`或if语句中的`else`时，
闭合的大括号单独占一行，像这样：

.. code-block:: c

	do {
		do循环的主体
	} while (条件);

以及

.. code-block:: c

	if (x等于y) {
		.
} else if (x大于y) {
		..
### 否则 {
    ...
}

**理由：** K&R
此外，请注意这种花括号放置方式也最大限度地减少了空行（或几乎空的行）的数量，而不会影响可读性。因此，考虑到屏幕上的新行并非可再生资源（想象一下只有25行的终端屏幕），你就有更多的空行可以用来添加注释。
不要在单个语句就能完成的地方不必要的使用花括号
.. code-block:: c

    如果 (条件)
        执行操作();

以及

.. code-block:: c

    如果 (条件)
        执行此操作();
    否则
        执行彼操作();

如果条件语句的一个分支是单个语句，则不适用上述规则；在这种情况下，应在两个分支中都使用花括号：

.. code-block:: c

    如果 (条件) {
        执行此操作();
        执行彼操作();
    } 否则 {
        否则执行此操作();
    }

另外，在循环包含多于一个简单语句时使用花括号：

.. code-block:: c

    当 (条件) {
        如果 (测试)
            执行某些操作();
    }

### 3.1 空格
***********

Linux内核风格中空格的使用主要取决于函数与关键字的用法。大多数关键字后面应使用空格。明显的例外是sizeof、typeof、alignof和__attribute__，它们看起来有点像函数（并且通常在Linux中与圆括号一起使用，尽管语言中不需要这样，例如：在声明 `struct fileinfo info;` 后使用 `sizeof info`）
因此这些关键字后使用空格：

如果、switch、case、for、do、while

但是不要对sizeof、typeof、alignof或__attribute__使用空格。例如，

.. code-block:: c


    s = sizeof(结构体文件);

在圆括号表达式内部（周围）不要添加空格。以下示例是**错误**的：

.. code-block:: c


    s = sizeof( 结构体文件 );

当声明指针数据或返回指针类型的函数时，推荐将`*`放在数据名或函数名旁边，而不是类型名旁边。示例：

.. code-block:: c


    char *linux_banner;
    unsigned long long memparse(char *ptr, char **retptr);
    char *match_strdup(substring_t *s);

对于大多数二元和三元运算符（如等号`=`, 加号`+`, 减号`-`, 小于号`<`, 大于号`>`, 乘号`*`, 除号`/`, 取模`%`, 或运算`|`, 与运算`&`, 异或`^`, 小于等于`<=`, 大于等于`>=`, 等于`==`, 不等于`!=`, 条件运算`?`, 冒号`:`)，在其两侧各使用一个空格，
但是一元运算符后不使用空格：

取地址`&`, 指针解引用`*`, 正号`+`, 负号`-`, 按位取反`~`, 逻辑非`!`, sizeof, typeof, alignof, __attribute__, 定义`defined`

一元后置递增和递减运算符前不加空格：

递增`++`, 递减`--`

一元前缀递增和递减运算符后不加空格：

递增`++`, 递减`--`

结构成员运算符`.` 和 `->` 周围也不加空格。

不要在线末尾留下空白。一些带有“智能”缩进功能的编辑器会在新行开始处适当插入空白，以便你可以立即开始输入下一行代码。
然而，如果你最终没有在该行放置代码（比如留下一个空行），一些这样的编辑器并不会移除这些空白，结果就是你留下了含有尾随空白的行。
Git会警告你提交的补丁中引入了尾随空白，并且可以可选地为你删除这些尾随空白；但是，如果应用一系列补丁，这可能会使后续的补丁因更改了上下文行而失败。
### 4) 命名
-------

C是一种简洁的语言，你的命名约定也应遵循这一风格。
与 Modula-2 和 Pascal 程序员不同，C 程序员不会使用诸如 `ThisVariableIsATemporaryCounter` 这样的可爱变量名。一个 C 程序员会将这个变量命名为 `tmp`，这更容易书写，并且一点也不更难理解。
然而，虽然混合大小写的变量名不被推荐，但对于全局变量来说，描述性的名称是必须的。将全局函数命名为 `foo` 是一种严重的错误。
全局变量（只有在你**真的**需要它们时才使用）和全局函数都需要有描述性的名称。如果你有一个统计活动用户数量的函数，你应该将其命名为 `count_active_users()` 或类似的名称，你不应该将其命名为 `cntusr()`。
将函数类型编码到名称中（所谓的匈牙利命名法）是愚蠢的 —— 编译器本身就了解这些类型，并可以检查它们，这样做只会让程序员感到困惑。
局部变量的名称应该简短、切题。如果你有一个随机的整数循环计数器，它可能应该被称为 `i`。如果没有任何误解的可能性，将其命名为 `loop_counter` 是没有必要的。类似地，`tmp` 可以是任何用于存储临时值的变量类型。
如果你担心混淆局部变量的名称，那么你还有另一个问题，这个问题被称为“函数生长激素失衡综合症”。
请参阅第 6 章（函数）。
对于符号名称和文档，请避免引入新的 “主从”（或仅“从属”）以及“黑名单/白名单”的用法。
建议替代 “主从” 的术语包括：
    '{主,主要} / {次,副本,下属}'
    '{发起者,请求者} / {目标,响应者}'
    '{控制器,主机} / {设备,工作者,代理}'
    '领导者 / 跟随者'
    '指挥 / 演员'

建议替代 “黑名单/白名单” 的术语包括：
    '拒绝列表 / 允许列表'
    '阻止列表 / 通过列表'

对于新用法的例外情况是为了维护用户空间的 ABI/API，或者当更新现有（截至 2020 年）硬件或协议规范要求使用这些术语时。对于新规范，在可能的情况下应将其术语转换为内核编码标准中的用法。
5) 类型定义（Typedefs）
------------------------

请不要使用诸如`vps_t`这样的命名方式。
对于结构体和指针使用类型定义(`typedef`)是一个**错误**。当你在源代码中看到

```c
vps_t a;
```

这行代码时，你可能无法立即理解它的含义。
相反，如果它写成

```c
struct virtual_container *a;
```

那么你就能清楚地知道`a`是什么。
很多人认为类型定义能**提高可读性**。其实不然。它们只适用于以下情况：

(a) 完全不透明的对象（类型定义被积极用于**隐藏**对象的真实类型）
示例：`pte_t`等不透明对象，你只能通过适当的访问函数来操作。
.. note::
       不透明性和“访问函数”本身并不是好事。
我们之所以对像`pte_t`这样的事物使用它们，是因为那里确实没有任何**可移植的、可访问的信息**。

(b) 清晰的整数类型，其中的抽象有助于避免混淆是`int`还是`long`
`u8/u16/u32`作为类型定义完全没问题，尽管它们更适合归类于(d)。
.. note::
       再次强调——这需要有**理由**。如果某物就是`unsigned long`，那么没有理由做

       ```c
       typedef unsigned long myflags_t;
       ```
但是，如果有明确的理由说明在某些情况下它可能是`unsigned int`，而在其他配置下可能是`unsigned long`，那么当然可以使用类型定义。

(c) 当你使用`sparse`来实际创建一个**新**类型以进行类型检查时。
(d) 在某些特殊情况下，与标准C99类型完全相同的新类型
尽管眼睛和大脑适应像 ``uint32_t`` 这样的标准类型只需要很短的时间，
但有些人无论如何都反对使用它们。
因此，允许使用与标准类型完全相同的Linux特有的 ``u8/u16/u32/u64`` 类型及其有符号等价类型——
尽管在你自己的新代码中，它们不是强制性的。
当编辑已经使用了其中一种或另一种类型的现有代码时，
你应该遵循该代码中已有的选择。

(e) 可以在用户空间安全使用的类型
在某些对用户空间可见的结构中，我们不能要求使用C99类型，
也不能使用上述的 ``u32`` 形式。因此，在所有与用户空间共享的结构中，
我们使用 __u32 和类似类型。
可能还有其他情况，但基本原则应该是永远不要、永远不要使用typedef，
除非你能明确地匹配上述规则之一。
一般来说，指针或具有可直接合理访问元素的结构**永远**不应该是一个typedef。

6) 函数
------------

函数应该简短而优美，只做一件事。它们应该适合在一到两屏文本上（ISO/ANSI屏幕尺寸是80x24，这是我们都知道的），
并且做好那一件事。
函数的最大长度与其复杂性和缩进级别成反比。所以，如果你有一个概念上简单的函数，
它只是一个长（但简单）的 case 语句，其中你需要为很多不同的情况做很多小事情，
在这种情况下，拥有一个更长的函数是可以接受的。
然而，如果你有一个复杂的函数，并且你怀疑一个
资质平平的高中一年级学生可能根本
不明白这个函数是关于什么的，那么你应该更加严格地遵守
最大限制。使用具有描述性名称的辅助函数（如果你认为性能至关重要，
可以要求编译器内联它们，它可能会做得比你更好）
另一个衡量函数的标准是局部变量的数量。它们
不应该超过5-10个，否则你就做错了什么。重新思考这个
函数，并将其拆分成更小的部分。人类的大脑通常可以
轻松地记住大约7件不同的事情，任何更多的东西都会让人困惑。你知道你是天才，
但也许两周后你想理解你做了什么。

在源文件中，用一个空行分隔函数。如果函数被导出，
它的**EXPORT**宏应该紧跟在闭合函数大括号的下一行。例如：

.. code-block:: c

	int system_is_up(void)
	{
		return system_state == SYSTEM_RUNNING;
	}
	EXPORT_SYMBOL(system_is_up);

6.1) 函数原型
************************

在函数原型中，包括参数名及其数据类型。
虽然这不是C语言的要求，但在Linux中是首选的，
因为它是一种简单的方式，为读者添加有价值的信息。
不要在函数声明中使用``extern``关键字，因为这会使
行变长，而且不是严格必要的。

当编写函数原型时，请保持元素的顺序规律
<https://lore.kernel.org/mm-commits/CAHk-=wiOCLRny5aifWNhr621kYrJwhfURsa0vFPeUEm8mF0ufg@mail.gmail.com/>`_
例如，使用以下函数声明示例：

 __init void * __must_check action(enum magic value, size_t size, u8 count,
				   char *fmt, ...) __printf(4, 5) __malloc;

对于函数原型，推荐的元素顺序如下：

- 存储类（下面，“static __always_inline”，注意“__always_inline”
  技术上是一个属性，但被当作“inline”处理）
- 存储类属性（这里，“__init”--即段声明，但也包括
  如“__cold”之类的东西）
- 返回类型（这里，“void *”）
- 返回类型属性（这里，“__must_check”）
- 函数名（这里，“action”）
- 函数参数（这里，“(enum magic value, size_t size, u8 count, char *fmt, ...)”,
  注意参数名应该始终包含）
- 函数参数属性（这里，“__printf(4, 5)”）
- 函数行为属性（这里，“__malloc”）

请注意，对于函数**定义**（即实际的函数体），
编译器不允许函数参数属性在函数参数之后。在这种情况下，
它们应该放在存储类属性之后（例如，注意下面
的“__printf(4, 5)”位置的变化，与上面的**声明**示例相比）：

 static __always_inline __init __printf(4, 5) void * __must_check action(enum magic value,
		size_t size, u8 count, char *fmt, ...) __malloc
 {
	..
 }

7) 集中退出函数
-----------------------------------

尽管被一些人废弃，相当于goto语句的东西
被编译器频繁地以无条件跳转指令的形式使用
当函数从多个位置退出，并且需要做一些共同的工作，如清理工作时，
goto语句会派上用场。如果没有
需要清理，那么直接返回即可。

选择能说明goto做什么或为什么存在goto的标签名。一个
好名字的例子可能是“out_free_buffer:”如果goto释放了“buffer”。
避免使用像 `GW-BASIC` 中的名称如 ``err1:`` 和 ``err2:`` 这样的标签，因为如果你需要添加或删除退出路径时必须重新编号这些标签，并且这无论如何都使得验证正确性变得困难。

使用 `goto` 的理由是：

- 无条件语句更容易理解和跟踪。
- 减少了嵌套。
- 避免了在修改代码时不更新各个退出点所导致的错误。
- 节省编译器优化冗余代码的工作 ;)

```c
int fun(int a)
{
    int result = 0;
    char *buffer;

    buffer = kmalloc(SIZE, GFP_KERNEL);
    if (!buffer)
        return -ENOMEM;

    if (condition1) {
        while (loop1) {
            ..
        }
        result = 1;
        goto out_free_buffer;
    }
    ..
out_free_buffer:
    kfree(buffer);
    return result;
}
```

一种常见的错误类型是“单一错误”（one err bugs），它们看起来像这样：

```c
err:
    kfree(foo->bar);
    kfree(foo);
    return ret;
```

这段代码中的问题是，在某些退出路径中 `foo` 是 `NULL`。通常修复这类问题的方法是将其拆分为两个错误标签 `err_free_bar:` 和 `err_free_foo:`：

```c
err_free_bar:
    kfree(foo->bar);
err_free_foo:
    kfree(foo);
    return ret;
```

理想情况下，你应该模拟错误来测试所有可能的退出路径。

### 8) 注释

注释是有益的，但过度注释也会带来问题。千万不要尝试在注释中解释你的代码是如何工作的：最好是编写出易于理解的代码，解释糟糕的代码是浪费时间。
通常来说，你希望你的注释说明代码做了什么，而不是如何做的。
同时，尽量避免在函数体内放置注释：如果函数复杂到需要单独注释其各部分，则你可能需要回到第6章学习一段时间。你可以写一些简短的注释来指出或警告某些特别巧妙（或丑陋）的地方，但应避免过多。相反，将注释放在函数头部，告诉人们这个函数的作用以及为什么这样做。

当注释内核API函数时，请使用 `kernel-doc` 格式。
详情请参阅位于 :ref:`Documentation/doc-guide/ <doc_guide>` 和 `scripts/kernel-doc` 的文件。

对于长（多行）注释，首选的风格如下：

```c
/*
 * 这是 Linux 内核源代码中多行
 * 注释的首选风格
 */
```
* 请始终如一地使用它
* 
	* 描述：左侧的星号列，
	* 开始和结束时几乎空白的行

对于 net/ 和 drivers/net/ 目录下的文件，较长（多行）注释的首选风格略有不同
.. code-block:: c

	/* 对于 net/ 和 drivers/net/ 目录下的文件，
	 * 其注释风格应如下所示
*
	 * 它与通常首选的注释风格几乎相同，
	 * 但是没有最初的几乎空白的行
*/

注释数据同样重要，无论是基本类型还是派生类型。为此，请每行只声明一个数据（不要用逗号来声明多个数据）。这样，你就有空间在每一项旁边写个小注释，解释其用途。
9) 你把它搞得一团糟
---------------------------

没关系，我们都会犯这样的错误。可能你的长期Unix用户助手已经告诉你“GNU emacs”会自动为你格式化C源代码，你也注意到确实如此，但它使用的默认设置远不如人意（实际上，比随机打字更糟糕 - 即使有无数只猴子在GNU emacs上打字，也永远编不出好程序）
因此，你可以选择放弃GNU emacs，或者改变它的设置以使用更合理的值。要做到后者，你可以在 .emacs 文件中添加以下内容：

.. code-block:: elisp

  (defun c-lineup-arglist-tabs-only (ignored)
    "通过制表符而非空格对齐参数列表"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (steps (floor offset c-basic-offset)))
      (* (max steps 1)
         c-basic-offset)))

  (dir-locals-set-class-variables
   'linux-kernel
   '((c-mode . (
          (c-basic-offset . 8)
          (c-label-minimum-indentation . 0)
          (c-offsets-alist . (
                  (arglist-close         . c-lineup-arglist-tabs-only)
                  (arglist-cont-nonempty
(c-lineup-gcc-asm-reg c-lineup-arglist-tabs-only))
                  (arglist-intro         . +)
                  (brace-list-intro      . +)
                  (c                     . c-lineup-C-comments)
                  (case-label            . 0)
                  (comment-intro         . c-lineup-comment)
                  (cpp-define-intro      . +)
                  (cpp-macro             . -1000)
                  (cpp-macro-cont        . +)
                  (defun-block-intro     . +)
                  (else-clause           . 0)
                  (func-decl-cont        . +)
                  (inclass               . +)
                  (inher-cont            . c-lineup-multi-inher)
                  (knr-argdecl-intro     . 0)
                  (label                 . -1000)
                  (statement             . 0)
                  (statement-block-intro . +)
                  (statement-case-intro  . +)
                  (statement-cont        . +)
                  (substatement          . +)
                  ))
          (indent-tabs-mode . t)
          (show-trailing-whitespace . t)
          ))))

  (dir-locals-set-directory-class
   (expand-file-name "~/src/linux-trees")
   'linux-kernel)

这将使 emacs 在 ~/src/linux-trees/ 下的 C 文件中更好地适应内核编码风格。
但即使你无法让 emacs 做出合理的格式化，也不是一切都完了：使用 `indent` 进行格式化。
现在，再次强调，GNU indent 和 GNU emacs 一样，有同样的愚蠢设置，
这就是为什么你需要给它一些命令行选项。
然而，这并不是太糟糕，因为即便是 GNU indent 的制作者们也承认 K&R 的权威（GNU 人并非邪恶，只是在这个问题上严重误入歧途），
所以你只需给 indent 设置 ``-kr -i8`` 选项（代表“K&R，8个字符的缩进”），或者使用
``scripts/Lindent``，以最新的风格进行缩进。
``indent`` 有很多选项，尤其是在评论重格式化方面，你可能想要查看手册页。但是请记住：
``indent`` 并不是修复糟糕编程的工具。

请注意，你也可以使用 ``clang-format`` 工具来帮助你遵守这些规则，快速自动地重新格式化代码的部分，
以及审查整个文件以发现编码风格错误、拼写错误和可能的改进。它对于排序 ``#include``，
对齐变量/宏，重排文本和其他类似任务也很有用。
详情请参阅文件 :ref:`Documentation/dev-tools/clang-format.rst <clangformat>`。

一些基本的编辑器设置，如缩进和行尾，如果你使用的是与 EditorConfig 兼容的编辑器，则会自动设置。
更多关于 EditorConfig 的信息，请访问其官方网站：https://editorconfig.org/

10) Kconfig 配置文件
------------------------

对于源码树中所有的 Kconfig* 配置文件，缩进略有不同。在 ``config`` 定义下的行使用一个制表符缩进，
而帮助文本则额外使用两个空格进行缩进。示例如下：

```
config AUDIT
	bool "Auditing support"
	depends on NET
	help
	  启用可与其他内核子系统（如 SELinux，其需要此功能来记录 avc 消息输出）一起使用的审计基础设施。
	  如果没有 CONFIG_AUDITSYSCALL，不会进行系统调用审计
```

特别危险的功能（如某些文件系统的写支持）应在提示字符串中显著标注：

```
config ADFS_FS_RW
	bool "ADFS write support (DANGEROUS)"
	depends on ADFS_FS
	..
```

有关配置文件的完整文档，请参阅文件 Documentation/kbuild/kconfig-language.rst

11) 数据结构
-----------------

在它们被创建和销毁的单线程环境中可见的数据结构应始终具有引用计数。
在内核中，垃圾回收不存在（而在内核外，垃圾回收既慢又低效），这意味着你绝对 **必须** 对所有使用情况进行引用计数。

引用计数意味着你可以避免锁定，并允许多个用户并行访问数据结构 —— 而不必担心由于他们休眠或暂时执行其他操作时结构突然消失。
请注意，锁定（locking）**并非**引用计数（reference counting）的替代品。锁定用于保持数据结构的一致性，而引用计数是一种内存管理技术。通常两者都需要，并且不应将它们混淆。

许多数据结构确实可以有两层引用计数，当存在不同“类别”的用户时。子类计数统计子类用户的数量，并且仅在子类计数降为零时递减全局计数一次。

这种“多级引用计数”可以在内存管理（如 `struct mm_struct`：mm_users 和 mm_count）和文件系统代码（如 `struct super_block`：s_count 和 s_active）中找到实例。

记住：如果另一个线程能够访问到你的数据结构，而你没有在它上面设置引用计数，那么你几乎肯定存在一个bug。

12) 宏、枚举和RTL
------------------------

定义常量和枚举中的标签的宏名称应使用大写字母。

```c
#define CONSTANT 0x12345
```

当需要定义多个相关常量时，建议使用枚举。

使用大写宏名称是可取的，但看起来像函数的宏可以使用小写字母命名。

一般来说，内联函数比看起来像函数的宏更可取。

具有多个语句的宏应该用 do-while 块包围：

```c
#define macrofun(a, b, c)			\
	do {					\
		if (a == 5)			\
			do_this(b, c);		\
	} while (0)
```

带有未使用的参数的函数式宏应该被静态内联函数替换，以避免未使用的变量问题：

```c
static inline void fun(struct foo *foo)
{
}
```

由于历史实践，许多文件仍然采用“转换为(void)”的方法来评估参数。然而，这种方法并不推荐。
这段文本主要讨论了C语言中宏（macros）的不当用法以及内联函数（inline functions）的优势，并且提到了编写内核消息时应注意的一些事项。下面是该段落的中文翻译：

内联函数解决了“带有副作用的表达式被多次计算”的问题，避免了未使用的变量问题，并且通常来说比宏有更好的文档说明，原因不明。
```c
/*
 * 尽可能避免这样做，而应选择静态内联函数
 */
#define macrofun(foo) do { (void) (foo); } while (0)
```

使用宏时要避免的问题：

1) 影响控制流的宏：
```c
#define FOO(x)					\
    do {					\
        if (blah(x) < 0)		\
            return -EBUGGERED;	\
    } while (0)
```
这种做法非常糟糕。它看起来像一个函数调用，但实际上退出了“调用”函数；不要破坏那些阅读代码的人的内部解析器。

2) 依赖于具有魔术名称的局部变量的宏：
```c
#define FOO(val) bar(index, val)
```
这看起来不错，但当人们阅读代码时会感到困惑，并且很容易因为看似无害的变化而破坏。

3) 使用作为左值的参数的宏：FOO(x) = y; 如果有人将 FOO 转换为内联函数，则可能会出现问题。

4) 忽略运算符优先级：使用表达式定义常量的宏必须将表达式括在圆括号中。注意类似问题，尤其是在使用参数的宏中。
```c
#define CONSTANT 0x4000
#define CONSTEXP (CONSTANT | 3)
```

5) 在类似于函数的宏中定义局部变量时的命名空间冲突：
```c
#define FOO(x)				\
    ({					\
        typeof(x) ret;			\
        ret = calc_ret(x);		\
        (ret);				\
    })
```

`ret` 是一个常见的局部变量名——`__foo_ret` 更不可能与已有的变量发生冲突。

cpp 手册全面地讲述了宏。gcc 内部手册也覆盖了 RTL，RTL 在内核中与汇编语言频繁使用。

### 13) 输出内核消息

内核开发者希望被视为有学识的人。请注意内核消息的拼写以留下好印象。不要使用错误的缩写如 `dont`；应该使用 `do not` 或者 `don't`。使消息简洁、清晰且无歧义。
内核消息不必以句点结尾。
打印带括号的数字（%d）没有增加任何价值，应当避免。
在<linux/dev_printk.h>中有一系列的驱动模型诊断宏，你应该使用它们来确保消息与正确的设备和驱动相匹配，并且标记了正确的级别：dev_err()、dev_warn()、dev_info()等。对于那些不与特定设备关联的消息，<linux/printk.h>定义了pr_notice()、pr_info()、pr_warn()、pr_err()等。当驱动程序正常工作时，它们是安静的，因此除非出现问题，否则更倾向于使用dev_dbg/pr_debug。
想出好的调试信息可能是一个相当大的挑战；一旦你有了它们，它们可以为远程故障排除提供巨大帮助。然而，处理调试信息打印与打印其他非调试信息不同。虽然其他的pr_XXX()函数无条件地打印，pr_debug()则不会；默认情况下，它会被编译掉，除非定义了DEBUG或设置了CONFIG_DYNAMIC_DEBUG。这同样适用于dev_dbg()，并且一个相关的约定使用VERBOSE_DEBUG将dev_vdbg()消息添加到已经由DEBUG启用的消息中。
许多子系统有Kconfig调试选项来在相应的Makefile中打开-DDEBUG；在其他情况下，特定文件#define DEBUG。当调试信息应该无条件打印时，例如如果它已经在调试相关的#ifdef部分内部，可以使用printk(KERN_DEBUG ...)。
14) 分配内存
--------------

内核提供了以下通用目的的内存分配器：kmalloc()、kzalloc()、kmalloc_array()、kcalloc()、vmalloc()和vzalloc()。关于它们的更多信息，请参阅API文档。:ref:`Documentation/core-api/memory-allocation.rst<memory_allocation>`
传递结构体大小的首选形式如下：

.. code-block:: c

   p = kmalloc(sizeof(*p), ...);

显式写出结构体名称的形式会损害可读性，并在指针变量类型改变但没有相应更新传递给内存分配器的sizeof时引入bug的机会。
对返回值进行类型转换，即void指针的转换是冗余的。从void指针转换为任何其他指针类型的转换是由C编程语言保证的。
分配数组的首选形式如下：

.. code-block:: c

   p = kmalloc_array(n, sizeof(...), ...);

分配零初始化数组的首选形式如下：

.. code-block:: c

   p = kcalloc(n, sizeof(...), ...);

这两种形式都会检查分配大小n * sizeof(...)的溢出，并在发生溢出时返回NULL。
这些通用的分配函数在未使用__GFP_NOWARN的情况下失败时都会发出堆栈转储，因此当返回NULL时无需再发出额外的失败消息。
15) 内联病态
--------------

似乎有一种普遍的误解，认为gcc有一个神奇的“让我更快”的加速选项叫做`inline`。虽然在某些情况下使用内联是适当的（例如，作为替换宏的一种方式，见第12章），但在很多情况下并不适当。过度使用inline关键字会导致更大的内核，反过来会使整个系统变慢，因为CPU的icache占用空间更大，而且仅仅是因为用于页缓存的内存更少。想想看；页缓存miss会导致磁盘寻道，这很容易耗费5毫秒。在这5毫秒中可以执行大量的CPU周期。
一个合理的经验法则是不要在代码超过3行的函数中使用inline。例外情况是，当一个参数已知是编译时常量，由于这个常量性，你知道编译器将在编译时优化掉你的大部分函数。对于这种特殊情况的一个好例子，参见kmalloc()的内联函数。
人们经常争辩说，在静态函数中添加inline，而这些函数只被使用一次总是有利的，因为没有空间折衷。虽然从技术上讲这是正确的，但是gcc能够自动完成这些内联操作而不需要帮助，当出现第二个用户时去除inline的维护问题超过了告诉gcc做它无论如何都会做的事情的潜在价值这一提示的价值。
16) 函数返回值与名称
-------------------------------

函数可以返回多种类型的值，其中最常见的一种是指示函数是否成功或失败的值。这种值可以用错误代码整数表示（-Exxx=失败，0=成功），或者用一个“成功”布尔值表示（0=失败，非零=成功）。
混淆这两种表示法是导致难以发现的bug的一个丰富来源。如果C语言对整数和布尔值有明确的区别，编译器就能帮我们找到这些错误……但它没有这样做。为了防止这类bug的发生，应当始终遵循以下约定：

    如果函数的名称是一个动作或命令，则该函数应返回错误代码整数。如果名称是一个判断语句，则函数应返回一个“成功”布尔值。
例如，“添加工作”是一个命令，因此add_work()函数在成功时返回0，在失败时返回-EBUSY。同样地，“PCI设备存在”是一个判断语句，因此pci_dev_present()函数在找到匹配设备时返回1，未找到时返回0。

所有EXPORTed函数必须遵守此约定，所有公共函数也应如此。对于私有（静态）函数虽然不必遵守，但建议遵守。
如果函数的返回值是计算的实际结果，而不是计算是否成功的标志，则不受此规则约束。通常，它们通过返回某个超出正常范围的结果来表示失败。典型的例子是返回指针的函数；它们使用NULL或ERR_PTR机制来报告失败。

17) 使用 bool 类型
------------------------

Linux内核中的bool类型是C99标准中_Bool类型的别名。bool值只能取0或1，并且隐式或显式地转换为bool会自动将其转换为真或假。当使用bool类型时，不需要使用!!构造，这消除了一个类别的bug。
在处理bool值时，应使用true和false定义，而不是1和0。
在适当的情况下，可以自由地使用bool作为函数返回类型或栈变量。鼓励使用bool以提高可读性，对于存储布尔值而言，它通常是比'int'更好的选择。
如果缓存行布局或值的大小很重要，则不要使用bool，因为其大小和对齐方式根据编译的目标架构而变化。对于需要优化对齐和大小的结构体，不应使用bool。
如果一个结构体包含许多真假值，可以考虑将它们整合到位字段中，成员为1位，或者使用适当的固定宽度类型，如u8。
对于函数参数中的真/假值，许多可以整合到单一的位操作‘标志’参数中，如果调用位置有裸露的真/假常量，‘标志’通常会是更易读的选择。除此之外，在结构体和参数中有限地使用布尔类型可以提高可读性。

18）不要重复发明内核宏
-------------------------------

头文件include/linux/kernel.h包含了一系列你应该使用的宏，而不是自己显式地编码它们的变体。
例如，如果你需要计算数组的长度，利用下面的宏：

.. code-block:: c

	#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

同样地，如果你需要计算某个结构体成员的大小，使用

.. code-block:: c

	#define sizeof_field(t, f) (sizeof(((t*)0)->f))

还有min()和max()宏，如果你需要它们，它们会进行严格的类型检查。自由地浏览这个头文件，看看还有什么其他已经定义好的东西，你不应该在你的代码中重复实现。

19）编辑器模线和其他垃圾信息
-------------------------------

一些编辑器能够解释嵌入在源文件中的配置信息，这些信息通过特殊标记指示。例如，emacs会解析这样的行：

.. code-block:: c

	-*- mode: c -*-

或者像这样：

.. code-block:: c

	/*
	Local Variables:
	compile-command: "gcc -DMAGIC_DEBUG_FLAG foo.c"
	End:
	*/

vim则会解析看起来像这样的标记：

.. code-block:: c

	/* vim:set sw=8 noet */

不要在源文件中包含任何这类信息。人们有自己的个人编辑器配置，你的源文件不应该覆盖它们。这包括缩进和模式配置的标记。人们可能使用他们自己的自定义模式，或者可能有其他魔法方法来使缩进正确工作。

20）内联汇编
-------------------

在架构特定的代码中，你可能需要使用内联汇编来与CPU或平台功能交互。当有必要时，不要犹豫去这样做。
然而，当C语言能完成任务时，不要无谓地使用内联汇编。尽可能地，你应该从C语言中直接操作硬件。

考虑编写简单的辅助函数，封装常用的内联汇编片段，而不是反复以细微差异的方式重写它们。记住，内联汇编可以使用C参数。

大型、非平凡的汇编函数应该放在.S文件中，并在相应的C头文件中定义C原型。对于汇编函数的C原型应该使用``asmlinkage``。

你可能需要将你的asm语句标记为volatile，以防止GCC在没有注意到任何副作用的情况下移除它。不过，你并不总是需要这样做，而不必要的这样做可能会限制优化。
### 多条指令的内联汇编
当编写包含多条指令的单个内联汇编语句时，应将每条指令放在单独的引号字符串中，并在除最后一个字符串外的所有字符串末尾加上`\n\t`来适当地缩进汇编输出中的下一条指令：

```c
asm ("magic %reg1, #42\n\t"
     "more_magic %reg2, %reg3"
     : /* outputs */ : /* inputs */ : /* clobbers */);
```

### 21) 条件编译
---------------------------

尽可能不要在`.c`文件中使用预处理条件（#if、#ifdef），这样做会使代码更难阅读，逻辑也更难追踪。相反，在一个头文件中使用这些条件定义供那些`.c`文件使用的函数，为`#else`的情况提供无操作（no-op）的存根版本，然后从`.c`文件中无条件地调用这些函数。编译器会避免生成任何对于存根调用的代码，产生相同的结果，但逻辑依然易于理解。
更倾向于编译整个函数，而不是函数的部分或表达式的部分。不要在表达式中放入`#ifdef`，而是将表达式的部分或全部提取到一个独立的帮助函数中，并对该函数应用条件。

如果有一个函数或变量可能在某种配置下未被使用，并且编译器会警告其定义未被使用，那么标记该定义为`__maybe_unused`，而不是用预处理器条件包裹它。（然而，如果一个函数或变量总是未被使用，则删除它。）

在代码中，尽可能使用`IS_ENABLED`宏将Kconfig符号转换为C布尔表达式，并将其用于正常的C条件语句中：

```c
if (IS_ENABLED(CONFIG_SOMETHING)) {
    ..
}
```
编译器会将条件语句常量化，就像`#ifdef`一样包含或排除代码块，因此这不会增加任何运行时开销。然而，这种方法仍然允许C编译器看到块内的代码，并检查其正确性（语法、类型、符号引用等）。因此，如果块内的代码引用了仅在条件满足时才存在的符号，则仍然需要使用`#ifdef`。

在任何非平凡的`#if`或`#ifdef`块（超过几行）的结尾处，在同一行的`#endif`后放置注释，指出所使用的条件表达式。例如：

```c
#ifdef CONFIG_SOMETHING
..
#endif /* CONFIG_SOMETHING */
```

### 22) 不要使内核崩溃
---------------------------

通常情况下，决定是否使内核崩溃属于用户而非内核开发者。

**避免使用panic()**
**********************

`panic()`应当谨慎使用，主要是在系统启动过程中使用。
例如，在启动过程中内存耗尽且无法继续的情况下使用`panic()`是可接受的。

**使用WARN()代替BUG()**
***************************

不要添加任何使用`BUG()`变体的新代码，如`BUG()`、`BUG_ON()`或`VM_BUG_ON()`。相反，使用`WARN*()`变体，最好是`WARN_ON_ONCE()`，并可能带有恢复代码。如果没有合理的方法至少部分恢复，则不需要恢复代码。“我懒得处理错误”不是使用`BUG()`的借口。严重的内部破坏且没有继续方法的情况仍可使用`BUG()`，但需要充分的理由。
使用 `WARN_ON_ONCE()` 而不是 `WARN()` 或 `WARN_ON()`
**************************************************

通常更倾向于使用 `WARN_ON_ONCE()` 而不是 `WARN()` 或 `WARN_ON()`，因为一旦出现警告条件，这种情况往往会多次发生。这可能会填满并循环利用内核日志，并且甚至可能使系统变慢到足以让过多的日志记录变成另一个额外的问题。

不要轻易发出警告
*******************

`WARN*()` 用于意料之外、不应该发生的情况。
`WARN*()` 宏不应用于在正常操作中预期会发生的任何情况。例如，这些宏不是用于预置断言或后置断言的。再次强调：`WARN*()` 不应用于那些很容易被触发（例如由用户空间行为导致）的条件。如果需要向用户通知问题，`pr_warn_once()` 是一个可能的选择。

不必担心启用 `panic_on_warn` 的用户
**************************************

关于 `panic_on_warn` 的一些额外说明：请记住 `panic_on_warn` 是一个可用的内核选项，许多用户设置了这个选项。这就是为什么上面有“不要轻易发出警告”的建议。但是，存在 `panic_on_warn` 用户并不是避免适当使用 `WARN*()` 的有效理由。这是因为，谁启用了 `panic_on_warn` 就是明确要求内核在 `WARN*()` 触发时崩溃，这样的用户必须准备好应对系统可能更容易崩溃的后果。

使用 `BUILD_BUG_ON()` 进行编译时间断言
**********************************************

使用 `BUILD_BUG_ON()` 是可以接受并且鼓励的，因为它是一个编译时间断言，在运行时没有任何影响。

附录 I) 参考资料
----------------------

《C 程序设计语言》第二版
作者: Brian W. Kernighan 和 Dennis M. Ritchie
出版社: Prentice Hall, Inc., 1988
ISBN 0-13-110362-8（平装本），0-13-110370-9（精装本）

《编程实践》
作者: Brian W. Kernighan 和 Rob Pike
出版社: Addison-Wesley, Inc., 1999
ISBN 0-201-61586-X 对应的中文翻译通常是指书籍的国际标准书号，但这本身不包含中文内容。不过，我可以为您翻译其他部分：

GNU手册 - 在遵循K&R（Kernighan和Ritchie的C语言教程）和本文档的情况下 - 针对cpp（预处理器）、gcc（编译器）、gcc内部结构和indent（代码格式化工具），所有这些均可从https://www.gnu.org/manual/获取。

WG14是编程语言C的国际标准化工作组，网址：http://www.open-std.org/JTC1/SC22/WG14/

Kernel CodingStyle，由greg@kroah.com在2002年OLS（Open Source Leadership Summit）上发表：
http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/

请注意，上述翻译尽可能保持了原文的专业术语和技术信息的准确性。
