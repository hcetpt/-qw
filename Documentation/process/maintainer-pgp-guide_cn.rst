标题：内核维护者PGP指南

===========================
内核维护者PGP指南
===========================

:作者: 康斯坦丁·里巴特塞夫 <konstantin@linuxfoundation.org>

本文件主要针对Linux内核开发者，尤其是子系统维护者。它包含了在Linux基金会发布的更广泛的“`保护代码完整性`_”指南中讨论的信息的子集。请阅读该文档以获取关于本指南中提及的一些主题的深入讨论。
.. _`保护代码完整性`: https://github.com/lfit/itpol/blob/master/protecting-code-integrity.md

PGP在Linux内核开发中的作用
===========================================

PGP有助于确保由Linux内核开发社区产生的代码的完整性，并且在较小程度上，通过PGP签名的电子邮件交换建立开发者之间的可信通信渠道。Linux内核源代码主要以两种格式提供：

- 分布式源仓库（git）
- 定期发布快照（tarball）

无论是git仓库还是tarball都带有官方内核发布者创建的内核开发者的PGP签名。这些签名提供了加密保证，即通过kernel.org或任何其他镜像站点可下载的版本与开发者工作站上的内容完全相同。为此：

- git仓库在所有标签上提供PGP签名
- tarball在所有下载中提供分离的PGP签名

.. _devs_not_infra:

信任开发者，而非基础设施
-------------------------------------------

自2011年核心kernel.org系统被攻破以来，内核归档项目的主要运营原则一直是假设基础设施的任何部分随时可能被攻破。因此，管理员采取了有意识的步骤来强调，信任必须始终放在开发者身上，而不是代码托管基础设施，无论后者的安全实践有多好。
上述指导原则是需要本指南的原因。我们希望确保通过将信任置于开发者身上，我们不会简单地将潜在未来安全事件的责任推给他人。
目标是为开发者提供一套指导方针，用以创建安全的工作环境并保护用于确保Linux内核本身完整性的PGP密钥。

.. _pgp_tools:

PGP工具
=========

使用GnuPG 2.2或更高版本
----------------------

你的发行版应该已经默认安装了GnuPG，你只需要验证你正在使用一个相对近期的版本。
要检查，请运行::

    $ gpg --version | head -n1

如果你的版本是2.2或以上，那么你就可以继续。如果你的版本低于2.2，那么本指南中的一些命令可能无法工作。
配置gpg-agent选项
~~~~~~~~~~~~~~~~~~~~~~~~~~~

GnuPG代理是一个辅助工具，当你使用``gpg``命令时会自动启动，并在后台运行以缓存私钥口令。有两个选项你应该了解以调整何时从缓存中过期口令：

- ``default-cache-ttl``（秒）：如果你在时间到活前再次使用相同的密钥，计数器将重置为另一个周期。默认值为600（10分钟）。
- ``max-cache-ttl``（秒）：无论你从最初输入口令以来多久使用了密钥，如果最大时间到活倒计时到期，你将不得不重新输入口令。默认值为30分钟。
如果你觉得这些默认时间太短（或太长），你可以编辑你的 ``~/.gnupg/gpg-agent.conf`` 文件来设置你自己的值：

    # 设置为30分钟作为常规ttl，2小时作为最大ttl
    default-cache-ttl 1800
    max-cache-ttl 7200

.. note::

    再也不需要在shell会话开始时手动启动gpg-agent了。
    你可能想要检查你的rc文件，移除任何为旧版本GnuPG设置的内容，
    因为它们可能不再执行正确的事情。

.. _protect_your_key:

保护你的PGP密钥
====================

本指南假设你已经有一个用于Linux内核开发的PGP密钥。如果你还没有一个，请参考前面提到的"`保护代码完整性`_"文档中的指导来创建一个新的密钥。
你也应该创建一个新的密钥，如果当前的密钥弱于2048位（RSA）。
理解PGP子密钥
-------------------------

一个PGP密钥很少仅仅由单一的密钥对组成——通常它是由一组独立的子密钥构成的，这些子密钥可以根据它们在创建时赋予的能力用于不同的目的。
PGP定义了四种密钥可以拥有的能力：

- **[S]** 密钥可用于签名
- **[E]** 密钥可用于加密
- **[A]** 密钥可用于身份验证
- **[C]** 密钥可用于认证其他密钥

具有 **[C]** 能力的密钥通常被称为“主”密钥，但这种术语容易引起误解，因为它暗示认证密钥可以替代同一链上的任何其他子密钥（就像物理上的“主”密钥可以打开为其他密钥制造的锁一样）。因为情况并非如此，本指南将称其为“认证密钥”，以避免任何混淆。
非常重要的是要完全理解以下几点：

1. 所有子密钥都是完全独立的。如果你丢失了一个私有子密钥，就不能从链条上的其他任何密钥中恢复或重新创建它。
2. 除了认证密钥之外，可以有多个具有相同能力的子密钥（例如，你可以有两个有效的加密子密钥、三个有效的签名子密钥，但只有一个有效的认证子密钥）。所有子密钥都是完全独立的——用一个 **[E]** 子密钥加密的消息不能用其他任何 **[E]** 子密钥解密。
3. 单个子密钥可能拥有多种能力（例如，你的 **[C]** 密钥也可以是你的 **[S]** 密钥）。
携带 **[C]**（认证）能力的密钥是唯一可以用来表示与其他密钥关系的密钥。只有 **[C]** 密钥可以用于：

- 添加或撤销具有 S/E/A 能力的其他密钥（子密钥）
- 添加、更改或撤销与密钥关联的身份（uids）
- 添加或更改自身的过期日期或任何子密钥的过期日期
- 为了信任网络的目的签署他人的密钥

默认情况下，GnuPG生成新密钥时会创建以下内容：

- 一个同时携带认证和签名能力的子密钥 (**[SC]**)
- 一个单独的具有加密能力的子密钥 (**[E]**)

如果你在生成密钥时使用了默认参数，那么这就是你将会有的配置。你可以通过运行 ``gpg --list-secret-keys`` 来验证，例如：

    sec   ed25519 2022-12-20 [SC] [expires: 2024-12-19]
          000000000000000000000000AAAABBBBCCCCDDDD
    uid           [ultimate] Alice Dev <adev@kernel.org>
    ssb   cv25519 2022-12-20 [E] [expires: 2024-12-19]

在 ``sec`` 条目下的长行是你密钥的指纹——当你在下面的例子中看到 ``[fpr]`` 时，指的是那个40个字符的字符串。
确保你的密码短语足够强大
----------------------------

GnuPG 使用密码短语在存储私钥到磁盘之前对其进行加密。这样一来，即使你的 ``.gnupg`` 目录被泄露或被盗取，攻击者也无法在未首先获取用于解密的密码短语的情况下使用你的私钥。
保护你的私钥具有一个强大的密码短语是绝对必要的。要设置它或更改它，请使用：

    $ gpg --change-passphrase [fpr]

创建单独的签名子密钥
----------------------------

我们的目标是通过将其移动到离线媒介来保护你的认证密钥，因此如果你只有一个组合的 **[SC]** 密钥，则应创建一个单独的签名子密钥：

    $ gpg --quick-addkey [fpr] ed25519 sign

.. note:: GnuPG 中的 ECC 支持

    如果你打算使用不支持 ED25519 ECC 密钥的硬件令牌，你应该选择 "nistp256" 而不是 "ed25519"。请参阅下面关于推荐硬件设备的部分。

为灾难恢复备份你的认证密钥
----------------------------------------------

你从其他开发者的 PGP 密钥上获得的签名越多，你就越有必要创建一个不在数字媒介上的备份版本，以备灾难恢复之需。
创建你的私钥可打印硬拷贝的最佳方式是使用专为此目的编写的 ``paperkey`` 软件。有关输出格式及其相对于其他解决方案的优势，请参见 ``man paperkey``。Paperkey 应该已经为大多数发行版打包好了。
运行以下命令来创建你的私钥的硬拷贝备份：

    $ gpg --export-secret-key [fpr] | paperkey -o /tmp/key-backup.txt

将该文件打印出来（或者直接将输出管道到 lpr），然后拿一支笔，在纸张的边缘写下你的密码短语。**强烈建议这样做**，因为密钥打印件仍然用该密码短语加密，并且如果你以后更改了它，当你需要使用备份时你可能记不起它原本是什么——这是肯定的。
将打印出的结果和手写密码放入信封中，并存放在安全、受良好保护的地方，最好远离你的家，例如你的银行金库中。
.. note::

    你的打印机可能不再是一个简单的连接到并行端口的傻瓜式设备，但由于输出仍用你的密码短语加密，即使打印到“云集成”的现代打印机也应保持相对安全的操作。

备份你的整个 GnuPG 目录
----------------------------------

.. warning::

    **!!!不要跳过这一步!!!**

在你需要恢复它们的情况下，拥有随时可用的 PGP 密钥备份非常重要。这与我们使用 ``paperkey`` 进行的灾难级别准备不同。无论何时你需要使用你的认证密钥——例如在修改你自己的密钥或在会议和峰会后签署其他人的密钥时——你也都会依赖这些外部副本。
首先获取一个小的 USB “拇指”驱动器（最好是两个！）用于备份目的。你需要使用 LUKS 对其进行加密——请参考你的发行版文档以了解如何完成这一点。
对于加密密码短语，你可以使用与你的 PGP 密钥相同的密码。
一旦加密过程完成，重新插入U盘并确保它被正确挂载。将你的整个``.gnupg``目录复制到加密的存储中：

    $ cp -a ~/.gnupg /media/disk/foo/gnupg-backup

现在你应该测试以确保一切仍然正常工作：

    $ gpg --homedir=/media/disk/foo/gnupg-backup --list-key [fpr]

如果没有出现任何错误，那么应该就可以正常使用了。卸载U盘，并明确标记它，以免下次需要使用随机U盘时误删；将其放置在一个安全的地方——但不要太远，因为你偶尔会需要使用它来编辑身份、添加或撤销子密钥，或者签署他人的密钥。
移除认证密钥从你的主目录
----------------------------------------

我们主目录中的文件并没有我们想象的那样得到很好的保护。它们可以通过多种方式泄露或被盗取：

- 通过意外地在设置新工作站时快速复制主目录
- 系统管理员的疏忽或恶意行为
- 通过不安全的备份
- 桌面应用程序（浏览器、PDF阅读器等）中的恶意软件
- 在穿越国际边界时受到强迫

用良好的口令保护你的密钥极大地有助于降低上述风险，但是口令可以通过键盘记录器、窥视肩膀或其他手段被发现。因此，推荐的做法是将你的认证密钥从主目录移除并存储在离线存储上
.. warning::

    请参阅前面的部分并确保你已经完整备份了GnuPG目录。我们将要做的会使你的密钥变得无用，除非你有一个可用的备份！

首先，识别你的认证密钥的keygrip：

    $ gpg --with-keygrip --list-key [fpr]

输出将类似于这样：

    pub   ed25519 2022-12-20 [SC] [expires: 2022-12-19]
          000000000000000000000000AAAABBBBCCCCDDDD
          Keygrip = 1111000000000000000000000000000000000000
    uid           [ultimate] Alice Dev <adev@kernel.org>
    sub   cv25519 2022-12-20 [E] [expires: 2022-12-19]
          Keygrip = 2222000000000000000000000000000000000000
    sub   ed25519 2022-12-20 [S]
          Keygrip = 3333000000000000000000000000000000000000

找到位于``pub``行下方的keygrip条目（紧接认证密钥指纹的下方）。这将直接对应于你在``~/.gnupg``目录中的一个文件：

    $ cd ~/.gnupg/private-keys-v1.d
    $ ls
    1111000000000000000000000000000000000000.key
    2222000000000000000000000000000000000000.key
    3333000000000000000000000000000000000000.key

你只需简单地移除与认证密钥keygrip对应的.key文件：

    $ cd ~/.gnupg/private-keys-v1.d
    $ rm 1111000000000000000000000000000000000000.key

现在，如果你发出``--list-secret-keys``命令，它将显示认证密钥缺失（``#``表示它不可用）：

    $ gpg --list-secret-keys
    sec#  ed25519 2022-12-20 [SC] [expires: 2024-12-19]
          000000000000000000000000AAAABBBBCCCCDDDD
    uid           [ultimate] Alice Dev <adev@kernel.org>
    ssb   cv25519 2022-12-20 [E] [expires: 2024-12-19]
    ssb   ed25519 2022-12-20 [S]

你还应移除``~/.gnupg``目录中的任何``secring.gpg``文件，这些可能是由GnuPG早期版本遗留下来的
如果你没有"private-keys-v1.d"目录
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果你没有``~/.gnupg/private-keys-v1.d``目录，则你的私有密钥仍存储在GnuPG v1使用的旧``secring.gpg``文件中。对你的密钥进行任何更改，例如更改口令或添加子密钥，都应自动将旧的``secring.gpg``格式转换为使用``private-keys-v1.d``。
一旦完成，请确保删除过时的``secring.gpg``文件，该文件仍包含你的私有密钥
.. _智能卡:

将子密钥移动到专用的密码设备
=============================================

尽管认证密钥现在不会被泄露或盗取，但子密钥仍在你的主目录中。任何人如果能够获取这些子密钥，就能够解密你的通信或伪造你的签名（如果他们知道口令的话）。此外，每次执行GnuPG操作时，密钥都会加载到系统内存中，并可能被足够先进的恶意软件（如Meltdown和Spectre）从中窃取。
完全保护你的密钥的最佳方法是将它们移动到能够执行智能卡操作的专业硬件设备上
智能卡的好处
--------------------------

智能卡包含一个能够存储私有密钥并在卡片本身上直接执行密码操作的密码芯片。由于密钥内容永远不会离开智能卡，因此当你将硬件设备插入计算机时，该计算机的操作系统无法检索私有密钥本身。这与我们之前用于备份目的的加密U盘存储设备非常不同——当该U盘插入并挂载时，操作系统能够访问私钥内容。
使用外部加密USB媒体不能替代拥有支持智能卡的设备
可用的智能卡设备
---------------------------

除非所有笔记本电脑和工作站都装有智能卡读取器，否则最简便的方法是获得一个实现智能卡功能的专门USB设备。有几个选项可供选择：

- `Nitrokey Start`_: 开放硬件和自由软件，基于FSI日本的`Gnuk`_。少数商用设备之一，支持ED25519 ECC密钥，但提供的安全特性最少（例如抵抗篡改或某些旁路攻击的能力）
`Nitrokey Pro 2`：与Nitrokey Start类似，但防篡改能力更强，并提供了更多的安全特性。Pro 2支持ECC加密（NISTP）。
- `Yubikey 5`：专有的硬件和软件，但比Nitrokey Pro便宜，并且有USB-C接口版本，这对较新的笔记本电脑更为适用。它提供了额外的安全特性，如FIDO U2F等，并且现在终于支持NISTP和ED25519 ECC密钥。

您的选择将取决于成本、您所在地区的发货可用性以及对开源/专有硬件的考虑。
.. note::

    如果您被列入MAINTAINERS名单或在kernel.org拥有账户，您有资格获得由Linux基金会提供的免费Nitrokey Start。
.. _`Nitrokey Start`: https://shop.nitrokey.com/shop/product/nitrokey-start-6
.. _`Nitrokey Pro 2`: https://shop.nitrokey.com/shop/product/nkpr2-nitrokey-pro-2-3
.. _`Yubikey 5`: https://www.yubico.com/products/yubikey-5-overview/
.. _Gnuk: https://www.fsij.org/doc-gnuk/
.. _`qualify for a free Nitrokey Start`: https://www.kernel.org/nitrokey-digital-tokens-for-kernel-developers.html

配置智能卡设备
-------------------

一旦您将智能卡插入任何现代Linux工作站，它应该能够立即正常工作。您可以通过运行以下命令来验证：

    $ gpg --card-status

如果您能看到完整的智能卡详细信息，则可以开始使用了。
不幸的是，解决可能出现的所有问题超出了本指南的范围。如果您遇到使用智能卡与GnuPG配合时的问题，请通过常规支持渠道寻求帮助。
为了配置您的智能卡，您需要使用GnuPG的菜单系统，因为没有方便的命令行选项：

    $ gpg --card-edit
    [...省略...]
    gpg/card> admin
    允许执行管理命令
    gpg/card> passwd

您应当设置用户PIN码（1）、管理员PIN码（3）以及重置代码（4）。
请确保记录并妥善保存这些信息——特别是管理员PIN码和重置代码（这允许您彻底擦除智能卡）。由于管理员PIN码很少需要使用，如果您不记录下来，几乎不可避免会忘记它。
回到主菜单后，您还可以设置其他值（例如姓名、性别、登录数据等），但这不是必需的，并且如果丢失智能卡可能会泄露有关它的信息。
.. note::

    尽管名称中带有“PIN”，但智能卡上的用户PIN码和管理员PIN码并不必须是数字。
.. warning::

    某些设备可能要求您先将子密钥移至设备上，然后才能更改密码短语。请查阅设备制造商提供的文档。
移动子密钥到您的智能卡
----------------------------------

退出卡片菜单（使用"q"键）并保存所有更改。接下来，让我们将您的子密钥移到智能卡上。对于大多数操作，您需要您的PGP密钥密码短语和卡片的管理员PIN码：

    $ gpg --edit-key [fpr]

    秘密子密钥可用
pub  ed25519/AAAABBBBCCCCDDDD
         创建日期：2022-12-20  到期日期：2024-12-19  使用：SC
         可信度：终极      有效性：终极
    ssb  cv25519/1111222233334444
         创建日期：2022-12-20  到期日期：永不       使用：E
    ssb  ed25519/5555666677778888
         创建日期：2017-12-07  到期日期：永不       使用：S
    [ultimate] (1). Alice Dev <adev@kernel.org>

    gpg>

使用``--edit-key``会再次进入菜单模式，并且您会注意到密钥列表有所不同。从这里开始，所有命令都是在菜单模式下完成的，这由``gpg>``提示符表示。首先，让我们选择要放到卡片上的密钥——通过输入``key 1``来实现（这是列表中的第一个，即**[E]**子密钥）：

    gpg> key 1

在输出中，您现在应该看到**[E]**密钥旁边的``ssb*``。这里的``*``表示当前“选中的”密钥。它是一个*切换*，意味着如果您再次输入``key 1``，``*``将会消失，密钥将不再被选中。
现在，让我们将该密钥移到智能卡上：

    gpg> keytocard
    请选择存放密钥的位置：
       (2) 加密密钥
    您的选择？2

因为这是我们的**[E]**密钥，所以将其放入加密槽是有道理的。当您提交选择后，系统将首先提示您输入PGP密钥密码短语，然后是管理员PIN码。如果命令没有错误返回，则表明密钥已移动成功。
**重要**：现在再次输入``key 1``以取消选择第一个密钥，然后输入``key 2``来选择**[S]**密钥：

    gpg> key 1
    gpg> key 2
    gpg> keytocard
    请选择存放密钥的位置：
       (1) 签名密钥
       (3) 认证密钥
    您的选择？1

您可以使用**[S]**密钥进行签名和认证，但我们希望确保它位于签名槽中，因此选择(1)。同样，如果您的命令没有错误返回，则操作成功：

    gpg> q
    是否保存更改？(y/N) y

保存更改会从您的主目录中删除您移到卡片上的密钥（但这没关系，因为我们有备份，如果需要为替换的智能卡再次执行此操作的话）
验证密钥是否已移动
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果您现在执行``--list-secret-keys``，您会看到输出中有一个细微的区别：

    $ gpg --list-secret-keys
    sec#  ed25519 2022-12-20 [SC] [到期日期：2024-12-19]
          000000000000000000000000AAAABBBBCCCCDDDD
    uid           [ultimate] Alice Dev <adev@kernel.org>
    ssb>  cv25519 2022-12-20 [E] [到期日期：2024-12-19]
    ssb>  ed25519 2022-12-20 [S]

``ssb>``输出中的``>``表示子密钥仅在智能卡上可用。如果您回到秘密密钥目录并查看其中的内容，您会注意到那里的``.key``文件已被存根替换：

    $ cd ~/.gnupg/private-keys-v1.d
    $ strings *.key | grep 'private-key'

输出应包含``shadowed-private-key``，以表示这些文件仅为存根，实际内容存储在智能卡上。
验证智能卡是否正常工作
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了验证智能卡是否按预期工作，您可以创建一个签名：

    $ echo "Hello world" | gpg --clearsign > /tmp/test.asc
    $ gpg --verify /tmp/test.asc

这将在您第一次命令时请求您的智能卡PIN码，然后在运行``gpg --verify``之后显示"有效签名"。
恭喜！您已经成功地使窃取您的数字开发者身份变得极其困难！

其他常见的GnuPG操作
-----------------------------

以下是一些与您的PGP密钥相关的常见操作的快速参考。
挂载您的安全离线存储
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

对于下面的任何操作，您都需要您的认证密钥，因此您首先需要挂载您的备份离线存储，并告诉GnuPG使用它：

    $ export GNUPGHOME=/media/disk/foo/gnupg-backup
    $ gpg --list-secret-keys

您需要确保输出中看到的是``sec``而不是``sec#``（``#``意味着密钥不可用，您仍在使用常规的主目录位置）。
延长密钥过期日期
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Certify 密钥默认从创建之日起两年后过期。这样做既出于安全考虑，也是为了使过时的密钥最终从密钥服务器上消失。
要将你的密钥的有效期从当前日期起延长一年，只需运行：

    $ gpg --quick-set-expire [fpr] 1y

你也可以使用特定的日期，如果这样更容易记住（例如你的生日、1月1日或加拿大国庆日）：

    $ gpg --quick-set-expire [fpr] 2025-07-01

记得将更新后的密钥重新发送到密钥服务器：

    $ gpg --send-key [fpr]

在进行任何更改后更新工作目录
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在使用离线存储对你的密钥进行了任何更改之后，你将希望将这些更改导入回常规的工作目录：

    $ gpg --export | gpg --homedir ~/.gnupg --import
    $ unset GNUPGHOME

通过ssh使用gpg-agent
~~~~~~~~~~~~~~~~~~~~~~~~

如果你需要在远程系统上签署标签或提交，可以将你的gpg-agent转发。请参考GnuPG wiki提供的说明：

- `通过SSH代理转发`_

如果你可以在远程端修改sshd服务器设置，这将更顺畅地工作。
.. _`通过SSH代理转发`: https://wiki.gnupg.org/AgentForwarding

.. _pgp_with_git:

与Git一起使用PGP
==================

Git的核心特性之一是其分散化性质--一旦仓库被克隆到你的系统上，你就拥有了项目的完整历史，包括所有标签、提交和分支。但是，面对数百个克隆的仓库，如何验证你的linux.git副本没有被恶意第三方篡改呢？

或者，如果代码中发现了后门，而提交中的“作者”行显示是由你完成的，而你确信自己与此“毫无关系”会怎样？
为了解决这两个问题，Git引入了PGP集成。签名的标签通过确保仓库的内容与创建该标签的开发人员工作站上的内容完全相同来证明仓库的完整性，而签名的提交使得在没有访问你的PGP密钥的情况下几乎不可能冒充你。
.. _`毫无关系`: https://github.com/jayphelps/git-blame-someone-else

配置git以使用你的PGP密钥
---------------------------------

如果你的密钥环中只有一个私钥，那么你实际上不需要做任何额外的事情，因为它会成为默认密钥。然而，如果你碰巧有多个私钥，你可以告诉git应该使用哪个密钥（``[fpr]`` 是你的密钥的指纹）：

    $ git config --global user.signingKey [fpr]

如何处理已签名的标签
----------------------------

要创建一个已签名的标签，只需向标签命令传递 ``-s`` 开关：

    $ git tag -s [tagname]

我们建议始终签署git标签，因为这允许其他开发者确保他们拉取的git仓库没有被恶意修改。
如何验证已签名的标签
~~~~~~~~~~~~~~~~~~~~~~~~~

要验证已签名的标签，只需使用 ``verify-tag`` 命令：

    $ git verify-tag [tagname]

如果你从项目仓库的另一个分支拉取标签，git应该会在你拉取的尖端自动验证签名，并在合并操作期间向你展示结果：

    $ git pull [url] tags/sometag

合并消息将包含类似以下内容：

    合并标签 'sometag' 来自 [url]

    [标签信息]

    # gpg: 签名于 [...]
    # gpg: 良好的签名来自 [...]

如果你正在验证别人的git标签，那么你需要导入他们的PGP密钥。请参阅下面的 ":ref:`verify_identities`" 部分。
配置git始终签署注释标签
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

很可能，如果你在创建注释标签，你会想要签署它。要强制git始终签署注释标签，你可以设置全局配置选项：

    $ git config --global tag.forceSignAnnotated true

如何处理已签名的提交
-------------------------------

创建已签名的提交很容易，但在Linux内核开发中使用它们却困难得多，因为它依赖于发送到邮件列表的补丁，而这种工作流程不会保留PGP提交签名。此外，当你为了匹配上游而重置你的仓库时，甚至你自己的PGP提交签名也会最终被丢弃。因此，大多数内核开发者不会费心签署他们的提交，并且会忽略他们在工作中依赖的任何外部仓库中的已签名提交。
然而，如果你的git工作树在某些git托管服务（如kernel.org、infradead.org、ozlabs.org或其他）上公开可用，则建议你签署所有git提交，即使上游开发者不会直接从中受益。
我们基于以下原因推荐这一点：

1. 如果将来需要进行代码取证或追踪代码来源，即使是外部维护的带有PGP提交签名的树也将对这些目的有价值。
2. 如果你曾经需要重新克隆你的本地仓库（例如，在磁盘故障后），这将让你在恢复工作前轻松验证仓库的完整性。
如果有人需要挑选你的提交，这允许他们在应用这些提交前快速验证其完整性。
创建签名的提交
~~~~~~~~~~~~~~

为了创建一个签名的提交，你只需在`git commit`命令中添加``-S``标志（因为与另一个标志冲突，它是大写的``-S``）：

    $ git commit -S

配置git以始终签署提交
~~~~~~~~~~~~~~~~~~~~~~

你可以告诉git始终对提交进行签名：

    git config --global commit.gpgSign true

.. note::

    在开启此功能之前，请确保你已经配置了``gpg-agent``
.. _verify_identities:

如何处理签名的补丁
------------------

可以使用你的PGP密钥来签署发送到内核开发者邮件列表的补丁。由于现有的电子邮件签名机制（PGP-Mime或PGP-inline）往往会在常规代码审查任务中造成问题，你应该使用由kernel.org为此目的创建的工具，它将加密证明签名放入消息头（类似DKIM）：

- `Patatt Patch Attestation`_

.. _`Patatt Patch Attestation`: https://pypi.org/project/patatt/

安装和配置patatt
~~~~~~~~~~~~~~~~~

Patatt已经被许多发行版打包，因此请先检查那里。你也可以使用"``pip install patatt``"从pypi进行安装。如果你已经通过git（通过``user.signingKey``配置参数）配置了你的PGP密钥，那么patatt不需要进一步的配置。你可以通过在你想使用的仓库中安装git-send-email钩子开始签署你的补丁：

    patatt install-hook

现在，任何你用``git send-email``发送的补丁都将自动使用你的加密签名进行签署。
检查patatt签名
~~~~~~~~~~~~~~

如果你正在使用``b4``来检索和应用补丁，那么它将自动尝试验证所有遇到的DKIM和patatt签名，例如：

    $ b4 am 20220720205013.890942-1-broonie@kernel.org
    [...]
    检查所有消息上的证明，可能需要一些时间..
---
      ✓ [PATCH v1 1/3] kselftest/arm64: 为SVE Z寄存器正确分配缓冲区
      ✓ [PATCH v1 2/3] arm64/sve: 文档化我们实际的ABI以清除寄存器上的系统调用
      ✓ [PATCH v1 3/3] kselftest/arm64: 强制执行SVE系统调用的实际ABI
      ---
      ✓ 签名：openpgp/broonie@kernel.org
      ✓ 签名：DKIM/kernel.org

.. note::

    Patatt和b4仍在积极开发中，你应该检查这些项目的最新文档，了解任何新功能或更新。
.. _kernel_identities:

如何验证内核开发者身份
=====================

签署标签和提交很容易，但要如何验证用于签署某物的密钥属于实际的内核开发者，而不是恶意的冒充者呢？

使用WKD和DANE配置自动密钥检索
---------------------------------

如果你不是已经拥有大量其他开发者公钥的人，那么你可以通过依赖于密钥自动发现和自动检索来启动你的密钥环。GnuPG可以利用其他委派信任技术，即DNSSEC和TLS，帮助你开始，如果从头构建自己的信任网太令人生畏的话。

在你的``~/.gnupg/gpg.conf``中添加以下内容：

    auto-key-locate wkd,dane,local
    auto-key-retrieve

DNS-Based Authentication of Named Entities（"DANE"）是一种在DNS中发布公钥并使用DNSSEC签名区域对其进行保护的方法。Web Key Directory（"WKD"）是使用https查询达到相同目的的替代方法。当使用DANE或WKD查找公钥时，GnuPG将在将自动检索的公钥添加到你的本地密钥环之前，验证DNSSEC或TLS证书。

Kernel.org为所有拥有kernel.org账户的开发者发布了WKD。一旦你在``gpg.conf``中有了上述更改，你就可以自动检索Linus Torvalds和Greg Kroah-Hartman的密钥（如果你还没有它们）：

    $ gpg --locate-keys torvalds@kernel.org gregkh@kernel.org

如果你有kernel.org账户，那么你应该`将kernel.org UID添加到你的密钥`_，以使WKD对其他内核开发者更有用。
.. _`将kernel.org UID添加到你的密钥`: https://korg.wiki.kernel.org/userdoc/mail#adding_a_kernelorg_uid_to_your_pgp_key

信任网（WOT）与首次使用信任（TOFU）
-----------------------------------

PGP包含了一种称为“信任网”的信任委托机制。本质上，这是一种尝试取代HTTPS/TLS世界中需要集中认证机构的需求。与其让各种软件制造商指定谁应该是你信任的认证实体，PGP将这一责任留给了每个用户。
不幸的是，很少有人了解信任网络（Web of Trust）的工作原理。尽管它仍然是OpenPGP规范中的一个重要方面，GnuPG的最近版本（2.2及以上）实现了一种替代机制，称为“首次使用时的信任”（TOFU）。你可以将TOFU视为“类似SSH的信任方式”。在SSH中，当你首次连接到远程系统时，其密钥指纹会被记录并记住。如果未来的某个时刻密钥发生了变化，SSH客户端会提醒你，并拒绝连接，迫使你决定是否信任更改后的密钥。同样地，当你首次导入某人的PGP密钥时，默认认为它是有效的。如果将来GnuPG遇到另一个具有相同身份的密钥，那么之前导入的密钥和新密钥都会被标记为无效，你需要手动确定保留哪一个。

我们建议你使用结合TOFU+PGP的信任模型（这是GnuPG v2的新默认设置）。要进行设置，请在`~/.gnupg/gpg.conf`文件中添加（或修改）`trust-model`设置：

    trust-model tofu+pgp

使用kernel.org的信任网络仓库
------------------------------

kernel.org维护了一个包含开发人员公钥的git仓库，以替代近年来基本废弃的密钥服务器网络。如何将该仓库设置为公钥来源的完整文档可以在这里找到：

- [Kernel开发者PGP密钥环]_

如果你是内核开发者，请考虑提交你的密钥以便加入该密钥环。
.. _[Kernel开发者PGP密钥环]: https://korg.docs.kernel.org/pgpkeys.html
