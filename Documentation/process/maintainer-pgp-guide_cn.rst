.. _pgpguide:

===========================
内核维护者 PGP 指南
===========================

:作者: Konstantin Ryabitsev <konstantin@linuxfoundation.org>

本文件旨在为 Linux 内核开发者，尤其是子系统维护者提供指导。它包含 Linux 基金会发布的更广泛的《保护代码完整性》指南中讨论的一部分信息。请阅读该文档以获取更多关于本指南中提到的一些主题的深入讨论。
.. _`Protecting Code Integrity`: https://github.com/lfit/itpol/blob/master/protecting-code-integrity.md

PGP 在 Linux 内核开发中的作用
===========================================

PGP 有助于确保由 Linux 内核开发社区产生的代码的完整性，并且在一定程度上通过 PGP 签名电子邮件交换建立开发者之间的可信通信渠道。Linux 内核源代码主要以两种格式提供：

- 分布式源代码仓库（git）
- 定期发布的快照（tarball）

git 仓库和 tarball 都带有官方内核发布者的 PGP 签名。这些签名提供了加密保证，即通过 kernel.org 或任何其他镜像站提供的可下载版本与开发人员工作站上的内容完全相同。为此：

- git 仓库为所有标签提供 PGP 签名
- tarball 为所有下载提供独立的 PGP 签名

.. _devs_not_infra:

信任开发者而非基础设施
-------------------------------------------

自 2011 年核心 kernel.org 系统被攻破以来，内核归档项目的主要运行原则是假定基础设施的任何部分都可能随时被攻破。因此，管理员采取了明确措施强调信任应始终放在开发者身上，而不是代码托管基础设施上，无论后者的安全实践有多好。

上述指导原则是需要此指南的原因。我们希望确保通过信任开发者不会简单地将未来潜在安全事件的责任推给其他人。目标是提供一组开发者可以使用的指导方针，以创建安全的工作环境并保护用于确保 Linux 内核本身完整性的 PGP 密钥。

.. _pgp_tools:

PGP 工具
=========

使用 GnuPG 2.2 或更高版本
----------------------

您的发行版应该已经默认安装了 GnuPG，您只需验证是否使用的是一个相对较新的版本即可。
要检查，请运行以下命令：

    $ gpg --version | head -n1

如果您有 2.2 或更高版本，则一切正常。如果您使用的版本低于 2.2，则本指南中的某些命令可能无法工作。

配置 gpg-agent 选项
~~~~~~~~~~~~~~~~~~~~~~~~~~~

GnuPG 代理是一个辅助工具，每次您使用 `gpg` 命令时都会自动启动并在后台运行，目的是缓存私钥口令。有两个选项您可以调整以确定何时从缓存中过期口令：

- ``default-cache-ttl``（秒）：如果您在计时期间再次使用相同的密钥，则计时器将重置为另一个周期。默认值为 600 秒（10 分钟）。
- ``max-cache-ttl``（秒）：无论您自首次输入口令以来最近使用密钥的时间有多长，如果最大计时期间到期，您都需要重新输入口令。默认值为 30 分钟。
如果你觉得这些默认时间太短（或太长），你可以编辑你的 `~/.gnupg/gpg-agent.conf` 文件来设置你自己的值：

    # 设置为 30 分钟的常规过期时间，和 2 小时的最大过期时间
    default-cache-ttl 1800
    max-cache-ttl 7200

.. note::

    现在不再需要在 shell 会话开始时手动启动 gpg-agent。你可能需要检查你的 rc 文件，移除任何针对旧版本 GnuPG 的设置，因为它们可能不再起作用。

.. _protect_your_key:

保护你的 PGP 密钥
==================

本指南假设你已经有一个用于 Linux 内核开发的 PGP 密钥。如果你还没有，请参阅前面提到的 "`保护代码完整性`_" 文档以了解如何创建一个新的密钥。
如果你当前的密钥弱于 2048 位（RSA），你也应该创建一个新密钥。

理解 PGP 子密钥
------------------

PGP 密钥很少由单一密钥对组成——通常它是一个独立子密钥的集合，可以根据它们在创建时分配的能力用于不同的用途。PGP 定义了四种密钥可以拥有的能力：

- **[S]** 密钥可用于签名
- **[E]** 密钥可用于加密
- **[A]** 密钥可用于身份验证
- **[C]** 密钥可用于认证其他密钥

具有 **[C]** 能力的密钥通常被称为“主密钥”，但这种术语容易引起误解，因为它暗示认证密钥可以替代同一链上的其他任何子密钥（就像物理“主密钥”可以打开为其他钥匙制造的锁）。由于这不是事实，因此本指南将称其为“认证密钥”以避免混淆。

重要的是要完全理解以下几点：

1. 所有子密钥都是完全独立的。如果你丢失了一个私有子密钥，无法通过链上的任何其他密钥恢复或重新创建它。
2. 除了认证密钥之外，可以有多个相同能力的子密钥（例如，你可以有两个有效的加密子密钥，三个有效的签名子密钥，但只有一个有效的认证子密钥）。所有子密钥都是完全独立的——使用一个 **[E]** 子密钥加密的消息不能用其他任何 **[E]** 子密钥解密。
3. 单个子密钥可以拥有多种能力（例如，你的 **[C]** 密钥也可以是你的 **[S]** 密钥）。

携带 **[C]**（认证）能力的密钥是唯一可以用来指示与其他密钥关系的密钥。只有 **[C]** 密钥可以：

- 添加或撤销具有 S/E/A 能力的其他密钥（子密钥）
- 添加、更改或撤销与密钥关联的身份（uids）
- 添加或更改自身的过期日期或任何子密钥的过期日期
- 为了信任网的目的签署其他人的密钥

默认情况下，GnuPG 在生成新密钥时会创建以下内容：

- 一个带有认证和签名能力的子密钥（**[SC]**）
- 一个单独的带有加密能力的子密钥（**[E]**）

如果你在生成密钥时使用了默认参数，那么这就是你所拥有的。你可以通过运行 `gpg --list-secret-keys` 来验证，例如：

    sec   ed25519 2022-12-20 [SC] [expires: 2024-12-19]
          000000000000000000000000AAAABBBBCCCCDDDD
    uid           [ultimate] Alice Dev <adev@kernel.org>
    ssb   cv25519 2022-12-20 [E] [expires: 2024-12-19]

`sec` 入口下的长行是你的密钥指纹——当你在下面的例子中看到 `[fpr]` 时，指的是这 40 个字符的字符串。
确保你的密码短语足够强
--------------------------------

GnuPG 使用密码短语在存储私钥之前对其进行加密。这样，即使你的 ``.gnupg`` 目录被泄露或窃取，攻击者也无法在未获得解密密码短语的情况下使用你的私钥。
绝对有必要确保你的私钥受到强密码短语的保护。要设置或更改它，请使用：

    $ gpg --change-passphrase [fpr]

创建一个单独的签名子密钥
--------------------------------

我们的目标是通过将认证密钥移至离线介质来保护它，因此如果你只有一个组合的 **[SC]** 密钥，则应创建一个单独的签名子密钥：

    $ gpg --quick-addkey [fpr] ed25519 sign

.. note:: GnuPG 中的 ECC 支持

    如果你打算使用不支持 ED25519 ECC 密钥的硬件令牌，则应选择“nistp256”而不是“ed25519”。请参阅下面关于推荐硬件设备的部分。

备份你的认证密钥以应对灾难恢复
----------------------------------------------

你在 PGP 密钥上从其他开发者处获得的签名越多，你就越有理由创建一个不依赖于数字媒体的备份版本，以便灾难恢复。
创建你的私钥可打印硬拷贝的最佳方式是使用专为此目的编写的 ``paperkey`` 软件。查看 ``man paperkey`` 了解有关输出格式及其相对于其他解决方案的优势的更多细节。Paperkey 应已打包到大多数发行版中。
运行以下命令以创建你的私钥的硬拷贝备份：

    $ gpg --export-secret-key [fpr] | paperkey -o /tmp/key-backup.txt

打印该文件（或将输出直接发送给 lpr），然后用笔在纸张边缘写下你的密码短语。**强烈建议这样做**，因为密钥打印仍然使用该密码短语进行加密，并且如果你更改了它，当你需要恢复备份时，几乎肯定记不住原来的密码是什么。
将打印结果和手写的密码短语放入信封中，并存放在安全且受保护的地方，最好远离你的住所，例如银行保险箱。
.. note::

    你的打印机可能不再是一个简单的连接到并行端口的设备，但由于输出仍使用你的密码短语进行加密，因此即使是打印到“云集成”的现代打印机也应相对安全。

备份整个 GnuPG 目录
----------------------------------

.. warning::

    **!!!不要跳过这一步!!!**

在你需要恢复 PGP 密钥时，有一个随时可用的备份很重要。这与我们使用 ``paperkey`` 所做的灾难级别准备不同。每当你需要使用你的认证密钥时，例如更改自己的密钥或在会议和峰会后签署他人的密钥时，你也会依赖这些外部副本。
首先获取一个小的 USB “拇指”驱动器（最好是两个！）用于备份目的。你需要使用 LUKS 对其进行加密——参考你的发行版文档了解如何实现这一点。
对于加密密码短语，你可以使用与你的 PGP 密钥相同的密码。
一旦加密过程完成，重新插入U盘并确保其正确挂载。将整个 ``.gnupg`` 目录复制到加密存储中：

    $ cp -a ~/.gnupg /media/disk/foo/gnupg-backup

现在你应该测试一下以确保一切正常：

    $ gpg --homedir=/media/disk/foo/gnupg-backup --list-key [fpr]

如果没有出现任何错误，则说明一切正常。卸载U盘，并明确标记它，以免下次需要使用随机U盘时误删。将其放在一个安全的地方——但也不要太远，因为你偶尔需要使用它来进行身份编辑、添加或撤销子密钥或签署他人的密钥。

移除认证密钥
------------------------

我们家目录中的文件并不像我们想象的那样受到很好的保护。它们可以通过多种方式泄露或窃取：

- 在快速复制家目录以设置新工作站时意外泄露
- 系统管理员疏忽或恶意行为
- 通过保护不善的备份
- 桌面应用程序（浏览器、PDF阅读器等）中的恶意软件
- 在穿越国际边境时被胁迫

使用好的密码短语大大有助于减少上述任何情况的风险，但密码短语可以通过键盘记录器、偷窥或其他手段被发现。因此，推荐的做法是将认证密钥从家目录中移除并存储在离线介质上。
.. warning::

    请参阅前一节并确保你已经完整备份了你的GnuPG目录。我们即将进行的操作如果没有任何可用备份的话，将会使你的密钥失效！

首先，识别你的认证密钥的keygrip：

    $ gpg --with-keygrip --list-key [fpr]

输出会像这样：

    pub   ed25519 2022-12-20 [SC] [expires: 2022-12-19]
          000000000000000000000000AAAABBBBCCCCDDDD
          Keygrip = 1111000000000000000000000000000000000000
    uid           [ultimate] Alice Dev <adev@kernel.org>
    sub   cv25519 2022-12-20 [E] [expires: 2022-12-19]
          Keygrip = 2222000000000000000000000000000000000000
    sub   ed25519 2022-12-20 [S]
          Keygrip = 3333000000000000000000000000000000000000

找到位于 ``pub`` 行下方的keygrip条目（紧接认证密钥指纹下方）。这将直接对应到你的 ``~/.gnupg`` 目录中的一个文件：

    $ cd ~/.gnupg/private-keys-v1.d
    $ ls
    1111000000000000000000000000000000000000.key
    2222000000000000000000000000000000000000.key
    3333000000000000000000000000000000000000.key

只需简单地移除与认证密钥keygrip对应的 `.key` 文件即可：

    $ cd ~/.gnupg/private-keys-v1.d
    $ rm 1111000000000000000000000000000000000000.key

现在，如果你发出 ``--list-secret-keys`` 命令，它将显示认证密钥已缺失（ ``#`` 表示不可用）：

    $ gpg --list-secret-keys
    sec#  ed25519 2022-12-20 [SC] [expires: 2024-12-19]
          000000000000000000000000AAAABBBBCCCCDDDD
    uid           [ultimate] Alice Dev <adev@kernel.org>
    ssb   cv25519 2022-12-20 [E] [expires: 2024-12-19]
    ssb   ed25519 2022-12-20 [S]

你还应移除 ``~/.gnupg`` 目录中的任何 ``secring.gpg`` 文件，这些文件可能是由早期版本的GnuPG遗留下来的。
如果没有 “private-keys-v1.d” 目录
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果你没有 ``~/.gnupg/private-keys-v1.d`` 目录，那么你的私钥仍然存储在GnuPG v1使用的旧 ``secring.gpg`` 文件中。对密钥进行任何更改，如更改密码短语或添加子密钥，应该自动将旧的 ``secring.gpg`` 格式转换为使用 ``private-keys-v1.d``。
完成后，请务必删除包含私钥的过时 ``secring.gpg`` 文件。
.. _智能卡:

将子密钥移动到专用的加密设备
=============================================

尽管认证密钥现在已经安全地防止泄露或窃取，但子密钥仍在你的家目录中。任何能够获取这些密钥的人都可以解密你的通信或伪造你的签名（如果他们知道密码短语）。此外，每次执行GnuPG操作时，密钥都会加载到系统内存中，并且可以通过足够先进的恶意软件（如Meltdown和Spectre）从中窃取。
完全保护你的密钥的最佳方法是将它们移到能够执行智能卡操作的专用硬件设备上。
智能卡的优势
--------------------------

智能卡包含一个能够存储私钥并在卡片本身上直接执行加密操作的加密芯片。由于密钥内容从未离开智能卡，因此插入硬件设备的计算机的操作系统无法检索私钥本身。这与我们之前用于备份目的的加密USB存储设备非常不同——当该USB设备插入并挂载时，操作系统能够访问私钥内容。
使用外部加密USB介质不能替代拥有具备智能卡功能的设备。
可用的智能卡设备
---------------------------

除非所有笔记本电脑和工作站都配备了智能卡读卡器，否则最简单的方法是获取一个实现智能卡功能的专业USB设备。有几种选择：

- `Nitrokey Start`_：开放硬件和自由软件，基于FSI日本的 `Gnuk`_。少数支持ED25519 ECC密钥的商用设备之一，但提供的安全特性最少（例如抵抗篡改或某些侧信道攻击的能力）。
`Nitrokey Pro 2`_: 与 Nitrokey Start 类似，但更防篡改，并提供更多的安全功能。Pro 2 支持 ECC 加密（NISTP）。
- `Yubikey 5`_: 使用专有硬件和软件，但比 Nitrokey Pro 更便宜，并且有 USB-C 接口版本，这在较新的笔记本电脑上更为实用。提供额外的安全功能，例如 FIDO U2F 等，并且现在终于支持 NISTP 和 ED25519 ECC 密钥。

您的选择将取决于成本、您所在地区的发货可用性以及对开放/专有硬件的考虑。
.. note::

    如果您列在 MAINTAINERS 中或在 kernel.org 上有账户，则您 `有资格获得免费的 Nitrokey Start`_，这是由 Linux 基金会提供的。
.. _`Nitrokey Start`: https://shop.nitrokey.com/shop/product/nitrokey-start-6
.. _`Nitrokey Pro 2`: https://shop.nitrokey.com/shop/product/nkpr2-nitrokey-pro-2-3
.. _`Yubikey 5`: https://www.yubico.com/products/yubikey-5-overview/
.. _Gnuk: https://www.fsij.org/doc-gnuk/
.. _`qualify for a free Nitrokey Start`: https://www.kernel.org/nitrokey-digital-tokens-for-kernel-developers.html

配置您的智能卡设备
-------------------

当您将智能卡插入任何现代 Linux 工作站时，它应该能够即插即用 (TM)。您可以通过运行以下命令来验证：

    $ gpg --card-status

如果看到完整的智能卡详细信息，则说明一切正常。
不幸的是，排查所有可能导致问题的原因超出了本指南的范围。如果您在使用 GnuPG 时遇到困难，请通过常规支持渠道寻求帮助。
要配置您的智能卡，您需要使用 GnuPG 的菜单系统，因为没有方便的命令行选项：

    $ gpg --card-edit
    [...省略...]
    gpg/card> admin
    允许执行管理员命令
    gpg/card> passwd

您应该设置用户 PIN（1）、管理员 PIN（3）和重置代码（4）。
请确保记录并安全保存这些信息——特别是管理员 PIN 和重置代码（它们允许您完全擦除智能卡）。由于很少需要使用管理员 PIN，如果您不记录下来，肯定会忘记它。
返回到主菜单，您还可以设置其他值（如姓名、性别、登录数据等），但这不是必需的，并且可能会泄露有关您的智能卡的信息，如果您丢失了它。
.. note::

    尽管名称中包含“PIN”，但智能卡上的用户 PIN 和管理员 PIN 不一定必须是数字。
.. 警告::

    某些设备可能要求您先将子密钥移动到设备上，然后才能更改密码。请查阅设备制造商提供的文档。
将子密钥移动到智能卡
----------------------

退出卡片菜单（使用“q”）并保存所有更改。接下来，我们将把您的子密钥移动到智能卡上。大多数操作都需要您的PGP密钥密码和卡片的管理员PIN码：

    $ gpg --edit-key [fpr]

    子密钥可用
pub  ed25519/AAAABBBBCCCCDDDD
         创建日期：2022-12-20  过期日期：2024-12-19  用途：SC
         信任度：终极        有效性：终极
    ssb  cv25519/1111222233334444
         创建日期：2022-12-20  过期日期：永不        用途：E
    ssb  ed25519/5555666677778888
         创建日期：2017-12-07  过期日期：永不        用途：S
    [ultimate] (1). Alice Dev <adev@kernel.org>

    gpg>

使用``--edit-key``会再次进入菜单模式，您会注意到密钥列表有所不同。从这里开始，所有命令都在这个菜单模式下完成，如``gpg>``所示。首先，选择要放到卡片上的密钥——通过输入``key 1``（这是列表中的第一个，**[E]**子密钥）：

    gpg> key 1

在输出中，您现在应该看到**[E]**键旁边的``ssb*``。星号``*``表示当前“选中”的密钥。它是一个*切换*功能，意味着如果您再次输入``key 1``，星号会消失且密钥不再被选中。
现在，将该密钥移动到智能卡上：

    gpg> keytocard
    请选择存放密钥的位置：
       (2) 加密密钥
    您的选择？2

由于这是我们**[E]**密钥，将其放入加密槽是有道理的。提交选择后，您将首先被提示输入PGP密钥密码，然后是管理员PIN码。如果命令没有错误返回，则密钥已被移动。
**重要**：现在再次输入``key 1``以取消选中第一个密钥，并输入``key 2``以选中**[S]**密钥：

    gpg> key 1
    gpg> key 2
    gpg> keytocard
    请选择存放密钥的位置：
       (1) 签名密钥
       (3) 认证密钥
    您的选择？1

您可以将**[S]**密钥用于签名和认证，但我们要确保它位于签名槽中，因此选择(1)。同样地，如果命令没有错误返回，则操作成功：

    gpg> q
    是否保存更改？(y/N) y

保存更改会从您的主目录删除已移动到卡片的密钥（但这没关系，因为我们有备份，需要时可以为替换的智能卡重做）
验证密钥是否已移动
~~~~~~~~~~~~~~~~~~~~

如果您现在执行``--list-secret-keys``，您会看到输出略有不同：

    $ gpg --list-secret-keys
    sec#  ed25519 2022-12-20 [SC] [过期日期：2024-12-19]
          000000000000000000000000AAAABBBBCCCCDDDD
    uid           [ultimate] Alice Dev <adev@kernel.org>
    ssb>  cv25519 2022-12-20 [E] [过期日期：2024-12-19]
    ssb>  ed25519 2022-12-20 [S]

输出中的``ssb>``符号表示子密钥仅在智能卡上可用。如果回到您的私钥目录查看内容，您会发现``.key``文件已被存根替换：

    $ cd ~/.gnupg/private-keys-v1.d
    $ strings *.key | grep 'private-key'

输出应包含``shadowed-private-key``，表明这些文件只是存根，实际内容在智能卡上。
验证智能卡是否正常工作
~~~~~~~~~~~~~~~~~~~~~~~~

要验证智能卡是否按预期工作，可以创建一个签名：

    $ echo "Hello world" | gpg --clearsign > /tmp/test.asc
    $ gpg --verify /tmp/test.asc

这应在第一条命令时请求您的智能卡PIN码，然后在运行``gpg --verify``后显示“良好签名”。
恭喜，您已经成功地使窃取您的数字开发者身份变得极其困难！

其他常见的GnuPG操作
---------------------

以下是一些常用操作的快速参考，您需要用PGP密钥进行操作。
挂载安全离线存储
~~~~~~~~~~~~~~~~~~

您需要Certify密钥才能执行下面的任何操作，因此首先需要挂载备份离线存储并告诉GnuPG使用它：

    $ export GNUPGHOME=/media/disk/foo/gnupg-backup
    $ gpg --list-secret-keys

您需要确保输出中看到的是``sec``而不是``sec#``（``#``表示密钥不可用，您仍在使用常规主目录位置）。
延长密钥有效期
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Certify 密钥默认的有效期为从创建日期起两年。这样做既出于安全考虑，也为了让过时的密钥最终从密钥服务器上消失。
要将你的密钥有效期从当前日期延长一年，只需运行：

    $ gpg --quick-set-expire [fpr] 1y

如果你更容易记住某个具体日期（例如生日、1月1日或加拿大国庆日），也可以使用该日期：

    $ gpg --quick-set-expire [fpr] 2025-07-01

记得将更新后的密钥发送回密钥服务器：

    $ gpg --send-key [fpr]

在任何更改后更新工作目录
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

当你使用离线存储对密钥进行任何更改后，需要将这些更改导入到常规工作目录中：

    $ gpg --export | gpg --homedir ~/.gnupg --import
    $ unset GNUPGHOME

通过 ssh 使用 gpg-agent
~~~~~~~~~~~~~~~~~~~~~~~~

如果需要在远程系统上签署标签或提交，可以转发你的 gpg-agent。请参考 GnuPG 维基提供的说明：

- `通过 SSH 转发代理`_

如果可以在远程端修改 sshd 服务器设置，则会更加顺畅。
.. _`通过 SSH 转发代理`: https://wiki.gnupg.org/AgentForwarding

.. _pgp_with_git:

使用 PGP 与 Git
==================

Git 的核心特性之一是其去中心化的特点——一旦项目仓库被克隆到你的系统中，你就拥有了该项目的完整历史记录，包括所有标签、提交和分支。然而，面对数百个克隆的仓库，如何验证自己的 linux.git 副本没有被恶意第三方篡改？

或者，如果代码中发现了一个后门，并且提交中的“作者”一栏显示是你做的，而你确信自己与此无关，该怎么办？
为了解决这两个问题，Git 引入了 PGP 集成。签名标签通过确保其内容与创建标签的开发人员工作站上的内容完全一致来证明仓库的完整性，而签名提交则使得在没有访问你的 PGP 密钥的情况下几乎不可能冒充你。
配置 Git 使用你的 PGP 密钥
---------------------------------

如果你的密钥环中只有一个私钥，则无需额外操作，因为它将成为默认密钥。但是，如果你有多个私钥，可以告诉 Git 应使用哪个密钥（``[fpr]`` 是你的密钥指纹）：

    $ git config --global user.signingKey [fpr]

如何处理已签名的标签
----------------------------

要创建一个已签名的标签，只需在标签命令中添加 ``-s`` 参数：

    $ git tag -s [tagname]

我们建议始终签署 Git 标签，因为这允许其他开发者确保他们拉取的 Git 仓库没有被恶意篡改。
如何验证已签名的标签
~~~~~~~~~~~~~~~~~~~~~~~~~

要验证已签名的标签，只需使用 ``verify-tag`` 命令：

    $ git verify-tag [tagname]

如果你从项目的另一个分支拉取标签，Git 会在拉取尖端时自动验证签名，并在合并操作期间显示结果：

    $ git pull [url] tags/sometag

合并消息将包含如下内容：

    Merge tag 'sometag' of [url]

    [标签信息]

    # gpg: 签名于 [...]
    # gpg: [签名者] 的有效签名

如果你正在验证其他人的 Git 标签，则需要导入他们的 PGP 密钥。请参阅下方的 ":ref:`verify_identities`" 部分。
配置 Git 总是签署注释标签
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果你创建的是注释标签，那么你可能会希望签署它。要强制 Git 总是签署注释标签，可以设置全局配置选项：

    $ git config --global tag.forceSignAnnotated true

如何处理已签名的提交
-------------------------------

创建已签名的提交很容易，但在 Linux 内核开发中使用它们则困难得多，因为它依赖于发送到邮件列表的补丁，而这一流程不会保留 PGP 提交签名。此外，在重新基化你的仓库以匹配上游时，即使是你的 PGP 提交签名也会丢失。因此，大多数内核开发者不签署他们的提交，并且会忽略他们在工作中依赖的外部仓库中的已签名提交。
然而，如果你的 Git 工作树公开托管在某个 Git 托管服务上（如 kernel.org、infradead.org、ozlabs.org 或其他），那么建议你签署所有 Git 提交，即使上游开发者不能直接从中受益。
我们基于以下理由推荐这样做：

1. 如果将来需要进行代码取证或追踪代码来源，即使由外部维护的带有 PGP 提交签名的树也将对此目的有价值。
2. 如果你需要重新克隆本地仓库（例如，在磁盘故障后），这使你在恢复工作前能够轻松验证仓库的完整性。
3. 如果有人需要挑选你的提交，这允许他们在应用这些提交之前快速验证其完整性。

创建签名的提交
~~~~~~~~~~~~~~

要创建一个签名的提交，只需在 `git commit` 命令中加上 `-S` 参数（注意是大写的 `-S`，因为与另一个标志冲突）：

    ```bash
    $ git commit -S
    ```

配置 Git 总是进行签名提交
~~~~~~~~~~~~~~~~~~~~~~~~~

你可以告诉 Git 总是对提交进行签名：

    ```bash
    git config --global commit.gpgSign true
    ```

.. note::

    在启用此功能之前，请确保你已经配置了 `gpg-agent`。
    
.. _verify_identities:

如何处理签名补丁
-----------------

可以使用你的 PGP 密钥来签署发送到内核开发者邮件列表中的补丁。由于现有的电子邮件签名机制（PGP-Mime 或 PGP-inline）往往会引发常规代码审查任务中的问题，你应该使用 kernel.org 创建的为此目的设计的工具，该工具将密码学证明签名放入消息头（类似 DKIM）：

- `Patatt Patch Attestation`_

.. _`Patatt Patch Attestation`: https://pypi.org/project/patatt/

安装和配置 patatt
~~~~~~~~~~~~~~~~~

Patatt 已经被许多发行版打包，因此请先检查这些包。你也可以通过 `pip install patatt` 从 PyPI 安装它。如果你已经在 Git 中配置了 PGP 密钥（通过 `user.signingKey` 配置参数），那么 patatt 不需要进一步配置。你可以通过在你想使用的仓库中安装 git-send-email 钩子开始签署你的补丁：

    ```bash
    patatt install-hook
    ```

现在任何你用 `git send-email` 发送的补丁都将自动用你的密码学签名签署。
检查 patatt 签名
~~~~~~~~~~~~~~~~

如果你正在使用 `b4` 来检索和应用补丁，那么它会自动尝试验证所有遇到的 DKIM 和 patatt 签名，例如：

    ```bash
    $ b4 am 20220720205013.890942-1-broonie@kernel.org
    [...]
    Checking attestation on all messages, may take a moment..
    ---
      ✓ [PATCH v1 1/3] kselftest/arm64: Correct buffer allocation for SVE Z registers
      ✓ [PATCH v1 2/3] arm64/sve: Document our actual ABI for clearing registers on syscall
      ✓ [PATCH v1 3/3] kselftest/arm64: Enforce actual ABI for SVE syscalls
      ---
      ✓ Signed: openpgp/broonie@kernel.org
      ✓ Signed: DKIM/kernel.org
    ```

.. note::

    Patatt 和 b4 仍在积极开发中，你应该检查这些项目的最新文档以获取任何新的或更新的功能。

.. _kernel_identities:

如何验证内核开发者的身份
==========================

签名标签和提交很容易，但如何验证用于签名的密钥确实属于实际的内核开发者而不是恶意冒充者？

使用 WKD 和 DANE 配置自动密钥检索
----------------------------------

如果你还没有大量的其他开发者的公钥集合，你可以通过依赖自动发现和自动检索来启动你的密钥环。GnuPG 可以利用其他委派信任技术，如 DNSSEC 和 TLS，来帮助你起步，如果你觉得从零开始构建自己的信任网太过令人望而却步的话。

在你的 `~/.gnupg/gpg.conf` 中添加以下内容：

    ```bash
    auto-key-locate wkd,dane,local
    auto-key-retrieve
    ```

基于 DNS 的命名实体认证（"DANE"）是一种在 DNS 中发布公钥并使用 DNSSEC 签名区域对其进行保护的方法。Web Key Directory（"WKD"）则是另一种使用 https 查找实现相同目的的方法。当使用 DANE 或 WKD 查找公钥时，GnuPG 将分别验证 DNSSEC 或 TLS 证书，然后将自动检索的公钥添加到你的本地密钥环中。

Kernel.org 为所有拥有 kernel.org 账户的开发者发布了 WKD。一旦你在 `gpg.conf` 中进行了上述更改，你可以自动检索 Linus Torvalds 和 Greg Kroah-Hartman 的密钥（如果你还没有这些密钥）：

    ```bash
    $ gpg --locate-keys torvalds@kernel.org gregkh@kernel.org
    ```

如果你有 kernel.org 账户，那么你应该 `将 kernel.org UID 添加到你的密钥中`，以便让 WKD 对其他内核开发者更有用。

.. _`将 kernel.org UID 添加到你的密钥中`: https://korg.wiki.kernel.org/userdoc/mail#adding_a_kernelorg_uid_to_your_pgp_key

信任网（WOT）与首次使用信任（TOFU）
-----------------------------------

PGP 包含一种称为“信任网”的信任委派机制。本质上，这是一种试图取代 HTTPS/TLS 世界中中心化认证机构需求的尝试。与各种软件制造商决定谁应该是你的可信认证实体不同，PGP 将这种责任留给每个用户。
不幸的是，很少有人理解信任网（Web of Trust）是如何工作的。尽管它仍然是OpenPGP规范中的一个重要方面，GnuPG的最近版本（2.2及以上）已经实现了一种替代机制，称为“首次使用信任”（TOFU）。你可以将TOFU视为“类似SSH的信任方法”。在SSH中，当你第一次连接到一个远程系统时，其密钥指纹会被记录并记住。如果未来的某个时候密钥发生变化，SSH客户端会提醒你并拒绝连接，迫使你决定是否信任新的密钥。同样地，当你第一次导入某人的PGP密钥时，默认认为它是有效的。如果将来GnuPG遇到另一个具有相同身份的密钥，则之前导入的密钥和新密钥都会被标记为无效，你需要手动确定保留哪一个。

我们建议你使用结合了TOFU+PGP的信任模型（这是GnuPG v2的新默认设置）。要设置它，请在`~/.gnupg/gpg.conf`中添加或修改`trust-model`设置：

    trust-model tofu+pgp

使用kernel.org的信任网仓库
------------------------------

kernel.org维护了一个包含开发人员公钥的git仓库，以替代近年来大部分已变得不太可用的密钥服务器网络。关于如何将该仓库设置为你公钥来源的完整文档可以在这里找到：

- [Kernel开发者PGP密钥环]_

如果你是内核开发者，请考虑提交你的密钥以便将其包含在这个密钥环中。
.. _[Kernel开发者PGP密钥环]: https://korg.docs.kernel.org/pgpkeys.html
