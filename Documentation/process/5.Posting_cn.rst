发布补丁
===============

迟早会有那么一刻，你的工作已经准备好向社区展示以供审查，并最终被合并到主线内核中。毫不意外地，内核开发社区已经形成了一套关于发布补丁的约定和程序；遵循这些约定会让所有相关人员的工作变得轻松许多。本文档将试图详细地覆盖这些期望；更多信息也可以在文件 :ref:`Documentation/process/submitting-patches.rst <submittingpatches>` 和 :ref:`Documentation/process/submit-checklist.rst <submitchecklist>` 中找到。

何时发布
------------

总有一种诱惑是，在补丁“完全准备就绪”之前避免发布它们。对于简单的补丁来说，这并没有问题。但如果所做的工作很复杂，那么在工作完成前从社区获得反馈会大有裨益。因此，你应该考虑发布仍在进行中的工作，甚至提供一个git仓库，以便感兴趣的开发者可以随时跟进你的工作进度。

当发布尚未认为可被合并的代码时，最好在发布的消息中说明这一点。同时提及任何剩余的主要工作以及已知的问题。虽然知道补丁尚未成熟的人会较少，但那些查看的人会带着帮助你推动工作的正确方向的想法来参与。

发布前的准备工作
-------------------

在你考虑向开发社区发送补丁之前，有一些事情应该完成。这些包括：

- 尽可能地测试代码。利用内核的调试工具，确保内核能在所有合理的配置选项组合下构建，使用交叉编译器为不同架构构建等。
- 确保你的代码符合内核编码风格指南。
- 你的更改是否有性能影响？如果有，你应该运行基准测试以显示你的更改带来的影响（或好处）；结果的总结应随补丁一起提交。
- 确保你有权发布该代码。如果这项工作是在雇主的要求下完成的，雇主很可能拥有该工作的权利，并且必须同意将其在GPL许可下发布。

通常来说，在发布代码之前投入一些额外思考几乎总是会在短时间内得到回报。

补丁准备
-----------------

为发布而准备补丁可能会是一项相当大量的工作，但再次强调，在这里试图节省时间通常并不明智，即使是在短期内也是如此。

补丁必须基于特定版本的内核准备。一般来说，补丁应基于Linus的git树中的当前主线版本。当基于主线时，最好从一个众所周知的发布点开始——例如稳定版或-rc版本——而不是从主线的任意位置分叉。
可能需要针对 `-mm`、`linux-next` 或子系统树制作版本，以便进行更广泛的测试和审查。根据您的补丁领域以及外部的进展情况，基于这些其他树的补丁可能需要大量工作来解决冲突并处理API变更。

只有最简单的更改应该被格式化为单一补丁；其余的一切都应该作为一系列逻辑性的更改来完成。将补丁拆分是一门艺术；一些开发者会花费很长时间来弄清楚如何按照社区期望的方式来完成这项工作。不过，有一些经验法则可以帮助你：

- 你发布的补丁系列几乎肯定不会是你工作修订控制系统中的更改系列。相反，你需要考虑你的更改在其最终形式下是什么样子，然后以有意义的方式将其拆分开。开发者感兴趣的是独立、自包含的更改，而不是你到达这些更改的过程。
- 每个逻辑上独立的更改应该被格式化为单独的补丁。这些更改可以很小（如“向这个结构添加一个字段”）或很大（例如增加一个重要的新驱动程序），但它们应该是概念上小的，并且适合用一句话描述。每个补丁都应该实现一个具体的更改，可以独立审查并验证它是否实现了所声称的功能。
- 作为对上述指导原则的另一种表述：不要在同一补丁中混合不同类型的更改。如果单个补丁修复了一个关键的安全漏洞、重新排列了一些结构并且还重新格式化了代码，那么有很大概率它会被忽略，而重要的修复会被遗漏。
- 每个补丁都应生成一个能够正常构建和运行的内核；如果你的补丁系列在中间被打断，结果仍然应该是一个可工作的内核。当使用“git bisect”工具查找回归时，部分应用补丁系列是一种常见的情况；如果结果是内核损坏，你将给从事追踪问题这一高尚工作的开发者和用户带来麻烦。
- 不要过度拆分。曾经有一个开发者将对单个文件的一组编辑拆分成500个单独的补丁——这种行为并没有让他成为内核邮件列表中最受欢迎的人。只要单个补丁仍然包含一个*逻辑性*的更改，它可以合理地较大。
- 尽量避免诱惑一次性发布一整套新的基础设施补丁，但在系列的最后一个补丁才启用整个功能。如果该系列引入了回归，二分法将会指向最后一个补丁作为问题的来源，即使真正的bug在别处。尽可能地，新增代码的补丁应该立即激活这部分代码。
创建完美的补丁系列可能是一个令人沮丧的过程，在完成了“真正的工作”之后需要花费大量的时间和思考。但是，如果做得正确，这将是值得投入的时间。

### 补丁格式和变更日志

---

现在你已经准备好了一系列完美的补丁来发布，但工作还没有完全结束。每个补丁都需要被格式化成一条消息，快速而清晰地向世界传达它的目的。为了达到这个目的，每个补丁将由以下内容组成：

- 可选的“From”行，用于指定补丁的作者。当你通过电子邮件转发别人的补丁时，这条信息是必要的，但在不确定的情况下添加它也不会有害。
- 一行描述补丁的作用。这条消息应该足够让读者即使没有任何上下文也能理解补丁的范围；这是会在“简短形式”的变更日志中出现的一行。这条消息通常格式化为相关的子系统名称在前，补丁的目的在后。例如：

  ```
  gpio: 在 CONFIG_GPIO_SYSFS=n 下修复构建
  ```

- 空行后面跟着对补丁内容的详细描述。这段描述可以尽可能长；它应该说明补丁做了什么以及为什么应该将它应用于内核。
以下是该段落的中文翻译：

至少包含一条标签行，其中必须包含来自补丁作者的一条“Signed-off-by:”签名。标签的具体用法将在下文中详细描述。
上述各项共同构成了补丁的日志记录。编写良好的日志记录是一项至关重要的技能，但却常常被忽视；值得我们花更多时间来讨论这一问题。在撰写日志记录时，请记住有许多不同的人将会阅读您的文字，
这些读者包括需要决定是否合并补丁的子系统维护者和审阅者、试图决定是否将补丁回溯到其他内核版本的分发商和其他维护者、追踪问题来源并怀疑补丁可能是问题原因的故障排查人员、想要了解内核变化情况的用户等。一个好的日志记录能够以最直接和简洁的方式向所有这些人传达所需的信息。

为此，总结行应尽可能地在一行的限制内描述变更的效果及其动机。详细的描述随后可以进一步展开这些主题，并提供任何必要的附加信息。如果补丁修复了一个错误，请引用引入此错误的提交（如果可能的话），并且请同时提供提交ID和标题（在引用提交时）。如果问题与特定的日志或编译器输出相关，请包含这些输出，以便他人在寻找相同问题的解决方案时可以参考。如果变更是为了支持后续补丁中即将引入的其他变更，请予以说明。如果内部API发生了变化，请详细说明这些变化以及其他开发者应该如何应对。一般来说，您越是能够设身处地为所有将要阅读您日志记录的人着想，那么这份日志记录（以及整个内核）就会越好。

不言而喻，日志记录应该是提交变更至版本控制系统时所使用的文本。其后将跟随：

- 采用统一("-u")格式的补丁本身。使用`diff`命令的`-p`选项可以将函数名称与变更关联起来，从而使生成的补丁更易于他人阅读。
您应当避免在补丁中包含无关文件的变化（例如由构建过程生成的文件，或者编辑器备份文件）。文档目录中的"dontdiff"文件可以帮助您在这方面进行处理；将其与`diff`命令的`-X`选项一起使用。

上面已经简要提到的标签用于提供关于补丁产生的背景信息。这些标签在《Documentation/process/submitting-patches.rst》文档中有详细描述；以下是一个简短的概述。

一种标签用于指向上游提交中引入的问题，这些问题被当前补丁修复：

```
Fixes: 1f2e3d4c5b6a ("通过前12个字符识别的SHA-1 ID对应的提交的第一行")
```

另一种标签用于链接包含额外背景信息或细节的网页，例如导致补丁产生的早期讨论或补丁实现的规范文档：

```
Link: https://example.com/somewhere.html  可选的其他信息
```

许多维护者在应用补丁时也会添加此标签以链接到补丁的最新公共评审帖子；通常这是通过像b4这样的工具或《Documentation/maintainer/configure-git.rst》中描述的git钩子自动完成的。

如果URL指向的是由补丁修复的公开漏洞报告，则应使用“Closes:”标签：

```
Closes: https://example.com/issues/1234  可选的其他信息
```

一些漏洞跟踪系统可以在应用带有此类标签的提交时自动关闭问题。监控邮件列表的一些机器人也可以追踪这些标签并采取某些行动。禁止使用私有漏洞跟踪系统和无效URL。

还有一种标签用于记录参与补丁开发的人员。每种标签都遵循这种格式：

```
tag: 全名 <电子邮件地址>  可选的其他信息
```

常用的标签包括：

- Signed-off-by: 这是开发者对其有权提交补丁以纳入内核的证明。这是对开发者原产地证书的同意，完整的文本可以在《Documentation/process/submitting-patches.rst》中找到。没有适当签核的代码不能合并到主线。
- Co-developed-by: 表明该补丁是由多位开发者共同创建的；
   用于在多个人员合作开发单个补丁时，除 From: 标签中列出的作者外，向其他合著者致谢。
   每个 Co-developed-by: 必须立即跟上对应的合著者的 Signed-off-by:。更多细节和示例请参见
   :ref:`文档/过程/提交补丁.rst <submittingpatches>`
- Acked-by: 表示另一位开发者（通常是相关代码的维护者）同意将此补丁合并到内核中
- Tested-by: 表明被提及的人已经测试过该补丁，并确认其可以正常工作
- Reviewed-by: 被提及的开发者已经审查了该补丁以确保其正确性；
   更多详细信息，请参阅 :ref:`文档/过程/提交补丁.rst <submittingpatches>` 中的审查者的声明
- Reported-by: 列出了报告此补丁所解决的问题的用户；
   此标签用于表彰那些（通常未得到足够重视的）测试我们代码并告知我们问题所在的人。
   注意：此标签后应跟上一个 Closes: 标签指向报告，除非该报告无法在网上找到。如果补丁只解决了报告中的部分问题，则可以使用 Link: 标签代替 Closes:
- Cc: 被提及的人收到了补丁的副本，并有机会对其发表评论

在给你的补丁添加标签时要小心，因为只有 Cc: 可以在没有获得被提及人明确许可的情况下添加；通常情况下使用 Reported-by: 也是可以的，但如果问题是私下报告的，请先征得许可。

发送补丁
--------

在你发送补丁之前，还有一些事情需要注意：

- 你确定你的邮件客户端不会破坏补丁吗？如果邮件客户端对补丁进行了不必要的空白字符更改或换行处理，那么接收方将无法应用这些补丁，并且可能不会对其进行详细的检查。如果有任何疑问，请先将补丁发给自己并确认它能完整无误地显示
:ref:`文档/过程/邮件客户端.rst <email_clients>` 提供了一些有助于使用特定邮件客户端发送补丁的提示。
你确定你的补丁没有愚蠢的错误吗？你应该始终运行脚本 `scripts/checkpatch.pl` 来检查补丁，并处理它提出的任何问题。请记住，尽管 `checkpatch.pl` 脚本体现了对于内核补丁应该是什么样的大量思考，但它并不比你聪明。如果修正一个 `checkpatch.pl` 的警告会让代码变得更糟，请不要做这样的修改。

补丁应始终以纯文本形式发送。请不要将它们作为附件发送；这会让评审者在回复中引用补丁的部分内容变得更加困难。相反，直接将补丁放入你的消息中即可。

发送补丁时，重要的是要向所有可能对此感兴趣的人员发送副本。与一些其他项目不同，内核鼓励人们宁愿多发副本也不要遗漏；不要假设相关人员会在邮件列表上看到你的帖子。特别地，应向以下人员发送副本：

- 受影响子系统的维护者。如前所述，《MAINTAINERS》文件是寻找这些人的第一个地方。
- 在同一领域工作的其他开发人员——特别是那些现在可能正在该领域工作的人。使用 git 查看还有谁修改了你正在工作的文件可能会有所帮助。
- 如果你是在响应一个bug报告或功能请求，请同时抄送原始发帖人。
- 向相关的邮件列表发送一份，或者如果没有适用的列表，则发送到 linux-kernel 列表。
- 如果你正在修复一个bug，请考虑此修复是否应该包含在下一个稳定版本更新中。如果是这样，`stable@vger.kernel.org` 应当收到补丁的副本。同时，在补丁本身中的标签里添加 `"Cc: stable@vger.kernel.org"`；这将在你的修复进入主线时通知稳定团队。
- 在选择补丁的收件人时，最好有个大致的想法，即你认为最终会接受并合并补丁的人是谁。虽然可以将补丁直接发送给 Linus Torvalds 并由他来合并，但通常不会这样做。Linus 很忙，而且有专门负责内核特定部分的子系统维护者。通常你会希望由这个维护者来合并你的补丁。如果没有明显的维护者，Andrew Morton 经常是最后的选择。
  
补丁需要好的主题行。补丁行的标准格式如下：

```
[PATCH nn/mm] subsys: 补丁的一行描述
```

其中 "nn" 是补丁的序号，"mm" 是系列中总补丁的数量，"subsys" 是受影响的子系统名称。显然，对于单一、独立的补丁，可以省略 nn/mm。
如果你有一系列重要的补丁，通常会发送一个介绍性描述作为第零部分。但这一惯例并非被所有人遵循；如果你采用这种方式，请记住，介绍中的信息不会被记录到内核变更日志中。因此，请确保补丁本身包含了完整的变更日志信息。
一般来说，一个多部分补丁的第二部分及后续部分应该作为对第一部分的回复发送，以便接收端可以将它们全部串联起来。像git和quilt这样的工具具有命令来正确地按顺序发送一系列补丁。但是，如果你有一长串补丁并且使用的是git，请避免使用`--chain-reply-to`选项，以防止生成异常深的嵌套结构。
