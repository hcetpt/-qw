... _development_posting:

提交补丁
===============

迟早，你的工作会准备好向社区展示以进行审查，并最终被纳入主线内核。毫不奇怪，内核开发社区已经形成了一套用于发布补丁的约定和程序；遵循这些约定将使所有相关人员的生活更加轻松。本文档将尝试详细地覆盖这些期望；更多信息也可以在文件 :ref:`Documentation/process/submitting-patches.rst <submittingpatches>` 和 :ref:`Documentation/process/submit-checklist.rst <submitchecklist>` 中找到。
何时发布
------------

一直有一种诱惑，即在补丁“完全准备就绪”之前避免发布它们。对于简单的补丁，这不是问题。然而，如果正在进行的工作是复杂的，在工作完成前从社区获取反馈将大有裨益。因此，你应该考虑发布正在进行中的工作，甚至提供一个git树，以便感兴趣的开发者可以随时跟进你的工作。
在发布被认为尚未准备好纳入的代码时，最好在发布信息中明确指出。同时提及任何剩余的主要工作以及已知的问题。虽然看那些众所周知不成熟补丁的人会少一些，但那些确实查看的人会带着帮助你推动工作朝着正确方向发展的想法来。
发布前的准备工作
-------------------

在你考虑向开发社区发送补丁之前，应该做很多事情。这些包括：

- 尽可能测试代码。利用内核的调试工具，确保内核能够用所有合理的配置选项组合构建，使用交叉编译器为不同架构构建等
- 确保你的代码符合内核编码风格指南
- 你的更改是否对性能有影响？如果有，你应该运行基准测试，显示你的更改的影响（或好处）；结果的总结应随补丁一起包含
- 确保你有权发布代码。如果这项工作是为雇主完成的，雇主很可能拥有这项工作的权利，并且必须同意在GPL下发布它
一般来说，在发布代码前投入一些额外的思考几乎总是会在短时间内得到回报。
补丁准备
-----------------

为发布准备补丁可能是一项令人惊讶的工作量，但再次强调，试图在这里节省时间通常不是明智之举，即使在短期内也是如此。
补丁必须基于特定版本的内核进行准备。一般而言，补丁应基于Linus的git树中的当前主线。当基于主线时，从一个广为人知的发布点开始——一个稳定版或-rc版本——而不是在任意位置从主线分支出去。
可能需要针对-mm、linux-next或子系统树制作版本，以便于更广泛的测试和审查。根据你的补丁领域以及外部的进展，基于这些其他树的补丁可能需要大量工作来解决冲突并处理API变更。

只有最简单的更改应被格式化为单一补丁；其他一切应作为一系列逻辑变化来制作。分割补丁是一种艺术；一些开发者花费很长时间来弄清楚如何按照社区期望的方式来做这件事。然而，有一些经验法则，可以大大帮助：

- 你发布的补丁系列几乎肯定不会是你在工作修订控制系统中找到的变化序列。相反，你需要考虑你所做的改变的最终形式，然后以有意义的方式将其拆分。开发者对离散、自包含的改变感兴趣，而不是你达到这些改变的过程。
- 每个逻辑独立的更改应被格式化为单独的补丁。这些更改可以很小（如“向此结构添加一个字段”）或很大（例如，添加一个重要的新驱动程序），但它们应该是概念上小且适合用一句话描述的。每个补丁应做出一个具体的更改，可以独立审查，并验证它确实做了它声称要做的事情。
- 作为重申上述指导原则的一种方式：不要在同一补丁中混合不同类型的更改。如果单个补丁修复了一个关键的安全漏洞，重新排列了一些结构，并重新格式化了代码，那么它很有可能被忽略，而重要的修复将丢失。
- 每个补丁都应该产生一个能够正确构建和运行的内核；如果你的补丁系列在中间被打断，结果仍然应该是一个工作的内核。部分应用补丁系列是在使用“git bisect”工具查找回归时常见的场景；如果结果是内核损坏，你将使参与追踪问题的开发者和用户的生活更加困难。
- 然而，不要过度。一位开发者曾经将对单个文件的一组编辑作为500个单独补丁发布——这一行为并没有让他成为内核邮件列表上最受欢迎的人。只要补丁仍然包含单一*逻辑*更改，单个补丁可以合理地大。
- 将整个新基础设施与一系列补丁一起添加可能会很诱人，但在系列中的最后一个补丁启用整个基础设施之前保持未使用状态。如果可能的话，应该避免这种诱惑；如果该系列引入了回归，二分法将指向最后一个补丁作为导致问题的原因，即使真正的bug在别处。尽可能地，添加新代码的补丁应该立即激活这段代码。

努力创建完美的补丁系列可能是一个令人沮丧的过程，在“真正的工作”完成后需要相当多的时间和思考。然而，当正确完成时，这是值得花时间的。

补丁格式和更改日志
--------------------

现在你已经有了一个完美的补丁系列用于发布，但工作还没有完全完成。每个补丁都需要被格式化成一条消息，快速而清晰地向世界传达其目的。为此，每个补丁将由以下内容组成：

- 可选的“From”行，命名补丁的作者。这条线仅在通过电子邮件转发他人的补丁时才必要，但在不确定时添加它永远不会伤害。
- 补丁作用的一行描述。这条消息应该足以让没有其他上下文看到它的读者了解补丁的范围；这将是出现在“简短形式”更改日志中的行。这条消息通常格式化为相关的子系统名称首先，其次是补丁的目的。例如：

   ::

	gpio: fix build on CONFIG_GPIO_SYSFS=n

- 一个空白行后跟着补丁内容的详细描述。这个描述可以尽可能长；它应该说明补丁做了什么，为什么应该将其应用于内核。
以下是该段落的中文翻译：

至少包含一条标签行，其中必须包含来自补丁作者的一条“Signed-off-by:”签名。关于标签的具体说明将在下文中详细描述。
上述各项共同构成了补丁的日志记录。编写良好的日志记录是一项至关重要的技能，但却常常被忽视；值得我们花一点时间来讨论这个问题。在编写日志记录时，应当考虑到会有不同的人群阅读你的内容，
这些人群包括需要决定是否合并补丁的子系统维护者和审阅者、试图判断补丁是否应该回溯到其他内核版本的分发商和其他维护者、追踪问题来源并怀疑补丁可能是问题原因的故障排查人员、想要了解内核变化情况的用户等。一个好的日志记录能够以最直接和简洁的方式向所有这些人传达所需的信息。

为了达到这个目的，总结行应当尽可能地描述变更的效果及其动机，同时考虑到一行文字的限制。详细描述部分则可以进一步阐述这些主题，并提供任何必要的附加信息。如果补丁修复了一个bug，请尽量引用引入该bug的提交（请同时提供提交ID和标题）。如果问题与特定的日志输出或编译器输出有关，请包含这些输出以帮助他人查找相同问题的解决方案。如果变更旨在支持后续补丁中即将引入的变化，请明确指出。如果内部API发生了变化，请详细说明这些变化以及其他开发者应该如何应对。总的来说，你越是能设身处地为所有将要阅读你日志记录的人着想，那么这份日志记录（以及整个内核）就会越好。

不言而喻，日志记录应该是提交变更到版本控制系统时所使用的文本。之后将跟随着：

- 统一格式("-u")的补丁本身。使用"diff"命令的"-p"选项可以将函数名称与变更关联起来，使得生成的补丁更易于其他人阅读。
你应该避免在补丁中包含无关文件的更改（例如构建过程中生成的文件，或者编辑器备份文件）。文档目录中的"dontdiff"文件可以帮助你在这方面；你可以通过"-X"选项将其传递给"diff"命令。

上面已经简短提到过的标签用于提供补丁产生的背景信息。这些标签在《Documentation/process/submitting-patches.rst》文档中有详细描述；以下是一个简要概述。

一个标签用来指向前置提交，该提交引入了由当前补丁修复的问题：
```
Fixes: 1f2e3d4c5b6a ("The first line of the commit specified by the first 12 characters of its SHA-1 ID")
```

另一个标签用于链接具有额外背景信息或细节的网页，比如导致补丁产生的早期讨论或补丁实现的规范文档：
```
Link: https://example.com/somewhere.html  optional-other-stuff
```

许多维护者在应用补丁时也会添加此标签来链接补丁最新公开评审的帖子；通常这可以通过像b4这样的工具或《Documentation/maintainer/configure-git.rst》中描述的git钩子自动完成。
如果URL指向的是由补丁修复的公共bug报告，则应使用"Closes:"标签：
```
Closes: https://example.com/issues/1234  optional-other-stuff
```

一些bug跟踪系统可以在应用带有此类标签的提交时自动关闭问题。一些监控邮件列表的机器人也可以追踪此类标签并采取某些行动。私人bug跟踪系统和无效的URL是禁止使用的。

还有一种类型的标签用于记录参与补丁开发的人员。这类标签遵循以下格式：
```
tag: Full Name <email address>  optional-other-stuff
```

常用的标签有：

- Signed-off-by: 这是开发者对自己有权提交补丁以纳入内核的认证。这是对开发者原创证书的同意，其全文可在《Documentation/process/submitting-patches.rst》中找到。没有适当签名的代码不能合并到主线中。
- Co-developed-by: 表明该补丁是由几位开发者共同创建的；
   用于在多位人员合作完成单个补丁时，除 From: 标签中注明的作者外，给其他合著者署名。
   每个 Co-developed-by: 必须立即跟上对应的合著者的 Signed-off-by:。更多细节和示例请参见
   :ref:`文档/过程/提交补丁.rst <submittingpatches>`
- Acked-by: 表示另一位开发者（通常是相关代码的维护者）同意此补丁适合合并到内核中
- Tested-by: 表明被提名的人已经测试过该补丁，并确认其可以正常工作
- Reviewed-by: 被提名的开发者已经审查了该补丁以确保其正确性；
   更多详细信息，请参阅 :ref:`文档/过程/提交补丁.rst <submittingpatches>` 中的审查者的声明
- Reported-by: 命名了一位报告了此补丁所修复问题的用户；此标签用于表彰那些（通常未得到足够认可的）
   测试我们的代码并在出现问题时告知我们的人。注意，此标签后面应该跟一个 Closes: 标签指向报告，
   除非该报告无法在网上找到。如果补丁只解决了报告问题的一部分，可以使用 Link: 标签代替 Closes:
- Cc: 被提名的人收到了该补丁的副本，并有机会对其发表意见
添加标签时要小心谨慎，因为只有 Cc: 可以在没有获得被提名人的明确许可的情况下添加；大多数情况下使用
Reported-by: 是没问题的，但如果问题是私下报告的，则应事先请求许可

发送补丁
--------

在您邮寄补丁之前，还有几点需要注意：

- 您确定您的邮件客户端不会破坏补丁吗？如果邮件客户端对补丁进行了不必要的空白字符更改或换行处理，
   那么接收方将无法应用这些补丁，而且通常也不会对其进行详细检查。如果有任何疑问，请先将补丁发给自己，
   确认它能够完整无误地到达。
:ref:`文档/过程/邮件客户端.rst <email_clients>` 提供了一些关于如何使特定邮件客户端适用于发送补丁的有用提示。
你确定你的补丁没有明显的错误吗？你应该始终使用 `scripts/checkpatch.pl` 来检查补丁，并解决它发现的问题。请记住，虽然 checkpatch.pl 凝聚了许多关于内核补丁应该是什么样的思考，但它并不比你聪明。如果修正一个 checkpatch.pl 的警告会使代码变得更差，请不要这样做。

补丁应始终以纯文本形式发送。请不要作为附件发送；这会使得审查者在回复中引用补丁的部分内容变得更加困难。相反，直接将补丁放入你的消息中即可。

当发送补丁时，重要的是要给可能对其感兴趣的所有人发送副本。与一些其他项目不同，内核鼓励人们倾向于多发副本；不要假设相关人员会在邮件列表上看到你的帖子。特别地，副本应该发送给：

- 受影响子系统的维护者们。如前所述，《MAINTAINERS》文件是查找这些人的首要位置。
- 在同一领域工作的其他开发者——尤其是那些现在可能正在该领域工作的人。使用 git 查看还有谁修改了你正在处理的文件可能会有所帮助。
- 如果你是响应一个bug报告或功能请求，请同时抄送原始发帖人。
- 发送到相关的邮件列表，或者如果没有适用的列表，则发送到 linux-kernel 列表。
- 如果你在修复一个bug，请考虑修复是否应该包含在下一个稳定版本更新中。如果是这样，stable@vger.kernel.org 应该收到补丁的副本。同时，在补丁本身的标签中添加 "Cc: stable@vger.kernel.org"；这将在你的修复进入主线时通知稳定团队。
  
选择补丁接收者时，最好有个大致的想法，即你认为最终会接受并合并补丁的人是谁。虽然有可能直接将补丁发送给 Linus Torvalds 并由他进行合并，但通常情况下不会这么做。Linus 很忙，而且有专门负责内核特定部分的子系统维护者。通常你会希望这个维护者来合并你的补丁。如果没有明显的维护者，Andrew Morton 经常是最后的选择目标。

补丁需要有好的主题行。标准的补丁主题格式如下：

```
[PATCH nn/mm] subsys: 补丁的一行描述
```

其中 "nn" 是补丁的序号，"mm" 是补丁系列中的总数量，"subsys" 是受影响的子系统的名称。
显然，对于单一的独立补丁，可以省略 nn/mm。
如果你有一系列重要的补丁，通常会发送一个介绍性描述作为第零部分。但这一惯例并非被所有人遵循；如果你采用这种方式，请记住，介绍中的信息不会被记录到内核变更日志中。因此，请确保补丁本身包含了完整的变更日志信息。
一般来说，一个多部分补丁的第二部分及之后的部分应该作为对第一部分的回复发送，以便接收端可以将它们全部串联起来。像git和quilt这样的工具具有命令来正确地按顺序发送一系列补丁。但是，如果你有一长串补丁并且使用的是git，请避免使用`--chain-reply-to`选项，以防止生成异常深的嵌套结构。
