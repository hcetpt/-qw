.. _开发提交：

提交补丁
===============

迟早会有那么一天，你的工作准备就绪，可以向社区展示以供审查，并最终合并到主线内核中。不出所料，内核开发社区已经形成了一套用于提交补丁的惯例和程序；遵循这些惯例会让所有参与者的工作更加轻松。本文档将尝试详细地介绍这些期望；更多相关信息可以在文件 :ref:`Documentation/process/submitting-patches.rst <submittingpatches>` 和 :ref:`Documentation/process/submit-checklist.rst <submitchecklist>` 中找到。

何时提交
------------

总是有一种诱惑，即在补丁完全“准备好”之前避免提交它们。对于简单的补丁来说，这不是问题。然而，如果正在进行的工作是复杂的，那么在工作完成之前从社区获取反馈将大有裨益。因此，你应该考虑提交未完成的工作，甚至提供一个git仓库，以便感兴趣的开发者可以随时跟进你的工作。当提交尚未被认为适合合并的代码时，在提交时说明这一点是个好主意。还应提及任何剩余的主要工作以及已知的问题。虽然看那些半成品补丁的人会少一些，但那些确实看的人会带着帮助你推动工作的正确方向的想法来。

提交补丁前的准备工作
----------------------

在你考虑向开发社区发送补丁之前，应该做很多事情。这些包括：

- 尽可能地测试代码。利用内核的调试工具，确保内核能够在所有合理的配置选项组合下编译，使用交叉编译器为不同架构构建等。
- 确保你的代码符合内核编码风格指南。
- 你的更改是否有性能影响？如果有，你应该运行基准测试，显示你的更改带来的影响（或好处）；结果的总结应随补丁一起提供。
- 确保你有权发布代码。如果这项工作是为雇主完成的，雇主可能拥有这项工作的权利，并且必须同意其在GPL下发布。
作为一般规则，提交代码之前多做一些思考几乎总能在短期内得到回报。

补丁准备
-----------------

补丁的准备工作可能会令人惊讶地繁重，但再次强调，在这里试图节省时间通常是不可取的，即使是在短期内也是如此。

补丁必须针对特定版本的内核进行准备。一般来说，补丁应该基于Linus的git树中的当前主线版本。当基于主线时，从一个知名的发布点开始——一个稳定版或-rc版本——而不是在主线的任意位置分叉。
可能需要针对 `-mm`、`linux-next` 或某个子系统树制作版本，以促进更广泛的测试和审查。根据您补丁的领域以及外部发生的情况，基于这些其他树的补丁可能需要大量工作来解决冲突并处理 API 变更。

只有最简单的更改应格式化为单个补丁；其他一切应作为一系列逻辑更改进行。拆分补丁是一项技术活；一些开发者会花费很长时间来弄清楚如何按照社区期望的方式进行拆分。不过，有一些经验法则可以帮助您：

- 您发布的补丁系列几乎肯定不会是您工作修订控制系统中的更改系列。相反，您所做的更改需要被视为最终形式，然后以有意义的方式拆分。开发者感兴趣的是离散且自包含的更改，而不是您到达这些更改的过程。
- 每个逻辑独立的更改都应格式化为单独的补丁。这些更改可以很小（例如“向此结构添加一个字段”）或很大（例如添加一个重要的新驱动程序），但它们在概念上应该是小的，并且可以用一句话描述。每个补丁应做出一个具体的更改，可以单独审查并验证其是否实现了所描述的功能。
- 重申上述指南：不要在同一补丁中混合不同类型的更改。如果一个补丁修复了一个关键的安全漏洞，重新安排了一些结构，并重新格式化了代码，那么很有可能这个补丁会被忽略，重要的修复也会丢失。
- 每个补丁应生成一个能够正常构建和运行的内核；即使您的补丁系列在中间被打断，结果也应仍然是一个工作的内核。部分应用补丁系列是在使用“git bisect”工具查找回归时的常见场景；如果结果是一个坏掉的内核，您会让参与追踪问题的开发者和用户的生活变得更加困难。
- 不要做得太过分。一位开发者曾经将对单个文件的一组编辑分成500个单独的补丁——这种行为并没有让他成为内核邮件列表中最受欢迎的人。只要仍然包含单一的*逻辑*更改，单个补丁可以合理地大。
- 尽量避免一次性添加全新的基础设施，然后在补丁系列的最后一部分才启用它。如果该系列引入了回归，“git bisect”可能会将最后一个补丁视为导致问题的补丁，即使真正的错误在别处。尽可能地，添加新代码的补丁应立即激活该代码。

努力创建完美的补丁系列可能是一个令人沮丧的过程，在完成“实际工作”之后需要花费大量的时间和思考。然而，当正确完成时，这是值得投入的时间。

补丁格式和变更日志
-------------------

现在您已经有了一个完美的补丁系列用于发布，但工作还没有完全结束。每个补丁都需要格式化成一条消息，以便快速而清晰地将其目的传达给全世界。为此，每个补丁将由以下内容组成：

- 一个可选的“From”行，命名补丁的作者。如果您通过电子邮件转发他人的补丁，则此行是必要的，但在不确定时加上它也不会有坏处。
- 补丁作用的一行描述。这条消息应该足以让看到它的读者了解补丁的范围；这将是出现在“简短形式”变更日志中的行。这条消息通常格式化为相关的子系统名称在前，补丁的目的在后。例如：

   ::

	gpio: fix build on CONFIG_GPIO_SYSFS=n

- 空行后跟着补丁内容的详细描述。这个描述可以尽可能长；它应该说明补丁做了什么以及为什么应该将其应用于内核。
一个或多个标签行，至少包含一条来自补丁作者的“Signed-off-by:”签名。标签的具体内容将在下文详细描述。

以上各项共同构成了补丁的日志记录。编写优秀的日志记录是一项至关重要的艺术，但却常常被忽视；值得花时间讨论这个问题。在编写日志记录时，你应该考虑到会有不同的人阅读你的文字：

这些读者包括子系统维护者和评审者，他们需要决定是否应该合并该补丁；分发商和其他维护者，他们试图决定是否应该将该补丁回退到其他内核版本；寻找问题根源的调试人员，他们想知道该补丁是否是导致问题的原因；以及想要了解内核变更情况的用户等。一份好的日志记录能够以最直接和简洁的方式向所有这些人传达所需信息。

为此，总结行应在一行的限制下尽可能地描述变更的效果及其动机。详细描述可以进一步扩展这些主题，并提供任何必要的附加信息。如果补丁修复了某个bug，请引用引入该bug的提交（如果可能的话），并请同时提供提交ID和标题（当引用提交时）。如果问题与特定的日志或编译器输出相关，请包含该输出，以便其他人更容易找到解决方案。如果变更旨在支持后续补丁中的其他变更，请说明这一点。如果内部API发生了变化，请详细描述这些变化以及开发者应如何应对。总的来说，你越是能设身处地为每一位将要阅读你日志记录的人着想，这份日志记录（以及整个内核）就会越好。

不用说，日志记录应该是用于提交变更到版本控制系统时所使用的文本。其后将跟随：

- 补丁本身，采用统一（"-u"）格式。使用`-p`选项进行`diff`操作时，会将函数名与变更关联起来，使生成的补丁更易于他人阅读。
- 你应该避免在补丁中包含无关文件的变化（例如由构建过程生成的文件或编辑器备份文件）。`dontdiff`文件可以帮助你在这一方面；将其传递给`diff`命令时使用`-X`选项。

前面简要提到过的标签用于提供有关补丁产生的背景信息。这些标签在《Documentation/process/submitting-patches.rst》文档中有详细描述；以下是一些简要总结：

一个标签用于指向前期引入问题的提交：

```
Fixes: 1f2e3d4c5b6a ("由前12个字符组成的SHA-1 ID指定的提交的第一行")
```

另一个标签用于链接带有额外背景或细节的网页，例如导致该补丁产生的早期讨论或实现该补丁规范的文档：

```
Link: https://example.com/somewhere.html  optional-other-stuff
```

许多维护者在应用补丁时也会添加此标签来链接补丁的最新公开评审帖子；这通常通过如`b4`工具或如《Documentation/maintainer/configure-git.rst》中所述的git钩子自动完成。

如果URL指向的是被补丁修复的公共bug报告，则使用“Closes:”标签代替：

```
Closes: https://example.com/issues/1234  optional-other-stuff
```

一些bug跟踪系统可以在应用带有此类标签的提交时自动关闭问题。一些监控邮件列表的机器人也可以追踪此类标签并采取某些行动。私人bug跟踪系统和无效URL是禁止的。

另一种类型的标签用于记录参与补丁开发的人员。每个标签的格式如下：

```
tag: 全名 <电子邮件地址>  optional-other-stuff
```

常用的标签有：

- `Signed-off-by:`：这是开发者对其有权提交补丁并将其纳入内核的认证。这是对开发者起源证书（Developer's Certificate of Origin）的同意，其全文可以在《Documentation/process/submitting-patches.rst》中找到。没有适当签名的代码无法合并到主线内核中。
- Co-developed-by: 表示该补丁是由多位开发者共同创建的；用于在多个人员参与单个补丁开发时，给予共同作者（除了 From: 标签所标注的作者）归属权。每个 Co-developed-by: 必须紧跟着一个对应的共同作者的 Signed-off-by:。详细信息和示例可以在 :ref:`Documentation/process/submitting-patches.rst <submittingpatches>` 中找到。
- Acked-by: 表示另一位开发者（通常是相关代码的维护者）同意将该补丁合并到内核中。
- Tested-by: 表示被提名的人已经测试过该补丁，并确认其有效。
- Reviewed-by: 被提名的开发者已经审查了该补丁的正确性；更多细节请参见 :ref:`Documentation/process/submitting-patches.rst <submittingpatches>` 中的审阅者的声明。
- Reported-by: 指出了一位报告了此补丁修复的问题的用户；此标签用于表彰那些测试我们代码并在出现问题时告知我们的（通常未得到足够认可的）人们。注意，此标签后面应该跟一个指向报告的 Closes: 标签，除非该报告无法在互联网上找到。如果补丁仅解决了部分报告的问题，可以使用 Link: 标签代替 Closes:。
- Cc: 被提名的人收到了该补丁的副本，并有机会对其发表评论。

在为你的补丁添加标签时要小心谨慎，因为只有 Cc: 是在没有得到被提名人的明确许可的情况下可以添加的；使用 Reported-by: 大多数时候也是可以的，但如果问题是私下报告的，请请求许可。

发送补丁
--------

在你发送补丁之前，还有一些其他的事情需要注意：

- 你确定你的邮件客户端不会破坏补丁吗？如果邮件客户端对补丁进行了不必要的空格更改或换行处理，那么在接收端将无法应用这些补丁，而且往往也不会对其进行详细检查。如果有任何疑问，请先将补丁发给自己，并确保它完好无损地到达。:ref:`Documentation/process/email-clients.rst <email_clients>` 提供了一些关于如何使特定邮件客户端适用于发送补丁的有用提示。
你确定你的补丁没有愚蠢的错误吗？你应该始终运行脚本 `scripts/checkpatch.pl` 来检查补丁，并解决其中出现的问题。请记住，虽然 `checkpatch.pl` 是经过大量思考的产物，但它并不比你聪明。如果修复一个 `checkpatch.pl` 的警告会使代码变得更糟，请不要进行该修复。

补丁应始终以纯文本形式发送。请不要将它们作为附件发送；这会让审阅者在回复中引用补丁的部分内容变得非常困难。相反，直接将补丁放入你的消息中即可。

在发送补丁时，重要的是要将副本发送给所有可能感兴趣的人。与一些其他项目不同，内核鼓励人们倾向于发送更多的副本；不要假设相关人士会在邮件列表上看到你的帖子。特别地，副本应该发送给：

- 受影响子系统的维护者。如前所述，《MAINTAINERS》文件是查找这些人的首要地方。
- 在同一领域工作的其他开发人员——特别是那些当前可能正在该领域工作的人。使用 Git 查看还有谁修改了你正在处理的文件可能会有所帮助。
- 如果你在响应一个错误报告或功能请求，请同时抄送原始发帖人。
- 发送到相关的邮件列表，或者如果没有适用的列表，则发送到 linux-kernel 列表。
- 如果你在修复一个错误，请考虑该修复是否应该包含在下一个稳定更新中。如果是这样，`stable@vger.kernel.org` 应该收到一份补丁副本。同时在补丁本身中的标签添加 `Cc: stable@vger.kernel.org`；这将在你的修复进入主线时通知稳定团队。

在选择补丁接收者时，最好有一个明确的想法，即你认为最终会接受并合并补丁的人是谁。虽然有可能直接将补丁发送给 Linus Torvalds 并由他合并，但这通常不是常规做法。Linus 很忙，而且有专门负责内核特定部分的子系统维护者。通常情况下，你会希望由那个维护者来合并你的补丁。如果没有明显的维护者，Andrew Morton 经常是最后的补丁接收目标。

补丁需要好的主题行。补丁行的标准格式如下：

```
[PATCH nn/mm] subsys: 补丁的一行描述
```

其中，“nn”是补丁的序号，“mm”是系列补丁的总数，“subsys”是受影响子系统的名称。
显然，对于单一的独立补丁，可以省略“nn/mm”。
如果你有一系列重要的补丁，通常会在第零部分发送一个介绍性的描述。然而，这一惯例并非被所有人遵循；如果你采用这种方式，请记住，介绍中的信息不会出现在内核的变更日志中。因此，请确保补丁本身包含完整的变更日志信息。

一般来说，一个多部分补丁的第二部分及之后的部分应作为对第一部分的回复发送，以便在接收端能够形成一个连续的讨论链。像 `git` 和 `quilt` 这样的工具提供了命令来正确地发送一系列补丁并保持讨论链的连续性。但是，如果你有一系列很长的补丁并且使用的是 `git`，请避免使用 `--chain-reply-to` 选项，以防止生成异常深的嵌套。
