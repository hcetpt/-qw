### SPDX 许可证标识符: GPL-2.0

#### SoC 子系统

##### 概览

SoC 子系统是特定于 SoC 代码的汇集地。该子系统的主要组成部分包括：

* 32 位和 64 位 ARM 以及 RISC-V 的设备树
* 32 位 ARM 板级文件（位于 arch/arm/mach*）
* 32 位和 64 位 ARM 的默认配置
* 跨架构的 SoC 特定驱动，尤其是针对 32 位和 64 位 ARM、RISC-V 和 Loongarch

这些“特定于 SoC 的驱动”不包括时钟、GPIO 等由其他顶级维护者负责的驱动。drivers/soc/ 目录通常用于内核内部的驱动程序，这些驱动被其他驱动所使用以提供特定于 SoC 的功能，如识别 SoC 的修订版本或与电源域进行交互。
SoC 子系统还作为对 drivers/bus、drivers/firmware、drivers/reset 和 drivers/memory 进行更改的一个中间位置。新增平台或移除现有平台通常会通过 SoC 树作为一个涉及多个子系统的专用分支。
主要的 SoC 树位于：
  https://git.kernel.org/pub/scm/linux/kernel/git/soc/soc.git/

显然，这涵盖了非常广泛的议题，单个人或一小群人都无法完全维护。相反，SoC 子系统由许多子维护者组成，他们分别负责个别平台和驱动子目录。
在此，“平台”通常指来自某个供应商的一系列 SoC，例如 Nvidia 的 Tegra SoC 系列。许多子维护者在供应商级别运作，负责多个产品线。由于各种原因（包括收购/公司内的不同业务部门），这里的情况差异很大。不同的子维护者在 MAINTAINERS 文件中有记录。
大多数这些子维护者有自己的树来暂存补丁，并向主要的 SoC 树发送拉取请求。这些树通常（但并非总是）在 MAINTAINERS 中列出。如果不存在特定平台的维护者，或者他们没有响应，可以通过别名 soc@kernel.org 联系主要的 SoC 维护者。
然而，SoC 树并不是特定架构代码更改的位置。每个架构都有自己的维护者，负责架构细节、CPU 错误等。

#### 对（新）子维护者的说明

随着新平台的出现，它们往往带来新的子维护者，其中许多人供职于硅供应商，可能不熟悉这一过程。

##### 设备树 ABI 稳定性

也许最需要强调的一点是 dt-bindings 文档描述了设备树和内核之间的 ABI。
请阅读 Documentation/devicetree/bindings/ABI.rst
如果对设备树所做的更改与旧内核不兼容，那么在驱动程序被合并或在适当的时间之后，不应应用设备树补丁。最重要的是，任何不兼容的更改都应在补丁描述和拉取请求中明确指出，包括对现有用户（如引导加载程序或其他操作系统）的预期影响。

**驱动程序分支依赖性**

一个常见的问题是同步设备驱动程序和设备树文件之间的更改。即使在两个方向上的更改都是兼容的，这也可能需要协调不同维护者树中更改的合并方式。通常包含驱动程序更改的分支也会包含对设备树绑定描述的相应更改，以确保它们实际上是兼容的。这意味着设备树分支最终可能导致“make dtbs_check”步骤中出现警告。如果设备树更改依赖于include/dt-bindings/中缺失的头文件添加，它将无法通过“make dtbs”步骤，从而不会被合并。

处理这个问题有多种方法：

* 避免在include/dt-bindings/中为可以从数据手册中推导出的硬件常量定义自定义宏——头文件中的绑定宏仅应在没有自然方式定义绑定的情况下作为最后手段使用。

* 即使需要头文件，也在设备树文件中使用字面值代替宏，并在后续版本中将其更改为命名表示。

* 将设备树更改推迟到绑定和驱动程序已经合并后的版本。

* 在用于驱动程序更改和设备树更改的基础的共享不可变分支中更改绑定。

* 在由#ifndef部分保护的设备树文件中添加重复定义，并在以后的版本中删除它们。

**设备树命名约定**

设备树文件的一般命名方案如下。平台在SoC级别设置的方面，如CPU核心，包含在名为$soc.dtsi的文件中，例如，jh7100.dtsi。集成细节，这些将从一块板到另一块板变化，将在$soc-$board.dts中描述。例如，jh7100-beaglev-starlight.dts。通常许多板是主题的变化，经常有中间文件，如jh7100-common.dtsi，位于$soc.dtsi和$soc-$board.dts文件之间，包含常见硬件的描述。

一些平台也有系统模块(System on Modules)，其中包含一个SoC，然后整合到几个不同的板中。对于这些平台，$soc-$som.dtsi和$soc-$som-$board.dts是典型的。

目录通常以SoC被纳入时的供应商名称命名，导致树中存在一些历史目录名称。

**验证设备树文件**

`make dtbs_check`可用于验证设备树文件是否符合描述ABI的dt-bindings。请阅读Documentation/devicetree/bindings/writing-schema.rst中关于设备树验证的“运行检查”部分，获取更多信息。

对于新平台或现有平台的添加，`make dtbs_check`不应添加任何新的警告。对于RISC-V和三星SoC，需要`make dtbs_check W=1`来避免添加任何新的警告。

如果对设备树更改有任何疑问，请联系设备树维护者。

**分支和拉取请求**

正如主SoC树有多个分支一样，预计子维护者也将这样做。驱动程序、defconfig和设备树更改应全部分为单独的分支，并出现在向SoC维护者提交的单独拉取请求中。每个分支应能独立使用，并避免因依赖其他分支而产生的回归问题。
小规模的补丁集也可以作为单独的邮件发送到soc@kernel.org，
按照相同的类别进行分组。
如果变更不符合常规模式，可以有额外的
顶级分支，例如，针对整个树的重构，或新增SoC
平台的加入，包括dts文件和驱动程序。
变更量大的分支可以从拆分为独立的主题分支中获益，
即使最终它们合并到SoC树的同一分支中。一个例子是：
一个分支用于修复设备树警告，一个
用于重构，另一个用于新添加的板卡。
另一种常见的变更拆分方式是在rc1和rc4之间的某个时间点发送早期的拉取请求，
包含大部分变更，随后在周期末尾发送一个或多个较小的拉取请求，
以添加晚期变更或解决在测试第一组变更时发现的问题。
虽然没有对晚期拉取请求设定截止时间，但接近合并窗口时只发送
小规模的分支会更有帮助。
对于当前版本的bug修复拉取请求，可以在任何时候发送，
但再次强调，拥有多个小规模的分支比试图将过多的补丁合并为一个拉取请求要好。
拉取请求的主题行应以"[GIT PULL]"开头，并使用签名标签而非分支。
此标签应包含简短描述，总结拉取请求中的变更。
关于发送拉取请求的更多细节，请参阅Documentation/maintainer/pull-requests.rst。

这段翻译尽可能保持了原文的技术性和专业性，同时也确保了中文表达的通顺和准确。
