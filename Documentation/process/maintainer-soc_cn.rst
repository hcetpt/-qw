SPDX 许可证标识符: GPL-2.0

=============
SoC 子系统
=============

概述
--------

SoC 子系统是特定于 SoC 代码的聚合地。该子系统的主要组件包括：

* 32 位和 64 位 ARM 以及 RISC-V 的设备树
* 32 位 ARM 板级文件（arch/arm/mach*）
* 32 位和 64 位 ARM 的 defconfigs
* 跨架构的 SoC 特定驱动程序，特别是针对 32 位和 64 位 ARM、RISC-V 和 LoongArch

这些“特定于 SoC 的驱动程序”不包括由其他顶级维护者负责的时钟、GPIO 等驱动程序。drivers/soc/ 目录通常用于内核内部驱动程序，这些驱动程序被其他驱动程序使用以提供特定于 SoC 的功能，例如识别 SoC 修订版或与电源域交互。

SoC 子系统还作为 drivers/bus、drivers/firmware、drivers/reset 和 drivers/memory 变更的中间位置。添加新平台或移除现有平台通常会通过 SoC 树作为一个涵盖多个子系统的专用分支进行处理。主要的 SoC 树位于：
  https://git.kernel.org/pub/scm/linux/kernel/git/soc/soc.git/

显然，这涵盖了相当广泛的主题，任何个人甚至一小群人都无法独自维护。相反，SoC 子系统由许多子维护者组成，他们各自负责特定平台和驱动程序子目录。
在这方面，“平台”通常指的是某个供应商的一系列 SoC，例如 Nvidia 的 Tegra SoC 系列。许多子维护者在供应商级别运作，负责多个产品线。由于收购/公司内的不同业务部门等原因，这里的情况差异很大。各种子维护者在 MAINTAINERS 文件中有详细记录。
大多数子维护者有自己的树，在那里他们准备补丁，并向主要的 SoC 树发送拉取请求。这些树通常（但并非总是）在 MAINTAINERS 中列出。如果不存在特定平台的维护者，或者他们没有响应，可以通过 soc@kernel.org 邮件别名联系主要 SoC 维护者。
然而，SoC 树并不是架构特定代码变更的位置。每个架构都有自己的维护者，负责架构细节、CPU 错误等。
对（新）子维护者的说明
------------------------------------

随着新平台的出现，它们经常带来新的子维护者，其中许多人供职于硅供应商，可能不熟悉这一过程。
设备树 ABI 稳定性
~~~~~~~~~~~~~~~~~~~~~~~~

也许最需要强调的是 dt-bindings 文档描述了设备树与内核之间的 ABI。
请阅读 Documentation/devicetree/bindings/ABI.rst
如果对设备树所做的更改与旧内核不兼容，则不应在驱动程序合并之前或适当的时间之后应用设备树补丁。最重要的是，任何不兼容的更改都应在补丁说明和拉取请求中明确指出，并说明其对现有用户（如引导加载程序或其他操作系统）的影响。

**驱动分支依赖**

一个常见的问题是同步设备驱动程序和设备树文件之间的更改。即使双向都是兼容的，这也可能需要协调不同维护者树中的更改如何合并。通常包含驱动程序更改的分支也会包含相应的设备树绑定描述更改，以确保它们实际上是兼容的。这意味着设备树分支可能会导致“make dtbs_check”步骤出现警告。如果设备树更改依赖于include/dt-bindings/目录中缺失的头文件添加，它将无法通过“make dtbs”步骤并无法被合并。处理这种情况有多种方法：

* 避免为可以从数据手册中推导出的硬件常量定义自定义宏——头文件中的绑定宏仅作为最后手段使用，如果无法自然地定义绑定时才使用。

* 即使需要头文件，在设备树文件中使用字面值代替宏，并在后续版本中将其更改为命名表示。

* 将设备树更改推迟到绑定和驱动程序已经合并后的版本。

* 在共享的不可变分支中更改绑定，该分支用作驱动程序更改和设备树更改的基础。

* 在设备树文件中使用#ifndef部分保护的重复定义，并在后续版本中删除这些定义。

**设备树命名约定**

设备树文件的一般命名方案如下：平台在SoC级别设置的方面，如CPU核心，包含在名为$soc.dtsi的文件中，例如，jh7100.dtsi。集成细节，即从一块板到另一块板会变化的部分，描述在$soc-$board.dts文件中。例如，jh7100-beaglev-starlight.dts。通常许多板是同一主题的变化，经常会有中间文件，如jh7100-common.dtsi，位于$soc.dtsi和$soc-$board.dts文件之间，包含常见硬件的描述。

一些平台还包含系统模块（System on Modules），其中包含SoC，然后集成到多个不同的板上。对于这些平台，$soc-$som.dtsi和$soc-$som-$board.dts是典型的文件名。目录通常以SoC供应商的名字命名，这导致树中有历史遗留的目录名称。

**验证设备树文件**

`make dtbs_check`可用于验证设备树文件是否符合描述ABI的dt-bindings。请阅读Documentation/devicetree/bindings/writing-schema.rst中的“运行检查”部分，了解更多关于设备树验证的信息。

对于新平台或现有平台的添加，`make dtbs_check`不应增加任何新的警告。对于RISC-V和Samsung SoC，`make dtbs_check W=1`也要求不增加任何新的警告。

如果有任何关于设备树更改的疑问，请联系设备树维护者。

**分支和拉取请求**

正如主SoC树有多个分支一样，预期子维护者也会这样做。驱动程序、defconfig和设备树的更改应分别放入单独的分支，并以单独的拉取请求提交给SoC维护者。每个分支应能够独立使用，并避免由于依赖其他分支而产生的回归问题。
小规模的补丁集也可以通过单独的邮件发送到soc@kernel.org，
并按照相同的分类进行分组。
如果变更不符合常规模式，可以增加额外的顶级分支，例如对整个树进行重构，或添加新的SoC平台（包括dts文件和驱动程序）。
包含大量变更的分支可以从拆分成单独的主题分支中获益，即使最终它们合并到同一个SoC树的分支中。一个例子是：一个分支用于修复设备树警告，一个分支用于重构，另一个分支用于新增加的板子。
另一种常见的拆分变更的方法是在rc1和rc4之间的某个时间点发送一个早期拉取请求，包含大部分变更，然后在周期结束时发送一个或多个较小的拉取请求，以添加最后的变更或解决在测试第一组变更时发现的问题。
虽然没有针对晚期拉取请求的截止时间，但在接近合并窗口时只发送较小的分支会更有帮助。
对于当前版本的bug修复拉取请求可以随时发送，但同样，多个较小的分支比尝试将过多的补丁合并为一个拉取请求更好。
拉取请求的主题行应以"[GIT PULL]"开头，并使用带有签名的标签而不是分支。此标签应包含一个简短的描述，总结拉取请求中的变更。关于发送拉取请求的更多详细信息，请参阅Documentation/maintainer/pull-requests.rst。
