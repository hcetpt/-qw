### SPDX 许可证标识符: GPL-2.0

#### 系统级芯片（SoC）子系统

##### 概览

SoC 子系统是特定于 SoC 的代码的聚合点。该子系统的主要组成部分包括：

* 32 位与 64 位 ARM 及 RISC-V 的设备树
* 32 位 ARM 板卡文件（位于 arch/arm/mach*）
* 32 位与 64 位 ARM 的默认配置
* 跨架构的 SoC 特定驱动程序，特别是针对 32 位与 64 位 ARM、RISC-V 和 Loongarch。

这些“特定于 SoC 的驱动程序”不包括时钟、GPIO 等由其他顶级维护者负责的驱动程序。drivers/soc/ 目录通常用于内核内部驱动程序，这些驱动程序被其他驱动程序使用以提供特定于 SoC 的功能，例如识别 SoC 修订版或与电源域交互。
SoC 子系统还作为对 drivers/bus、drivers/firmware、drivers/reset 和 drivers/memory 进行更改的中间位置。新增平台或移除现有平台经常通过 SoC 树作为一个涵盖多个子系统的专用分支进行。
主要的 SoC 树位于：
  https://git.kernel.org/pub/scm/linux/kernel/git/soc/soc.git/

显然，这涵盖了非常广泛的主题，不是任何一个人或者小团队能够全部维护的。相反，SoC 子系统由许多子维护者组成，每个维护者负责个别平台和驱动子目录。
在此，“平台”通常指的是来自特定供应商的一系列 SoC，例如，Nvidia 的 Tegra SoC 系列。许多子维护者在供应商级别运作，负责多个产品线。由于各种原因（包括收购/公司内部不同的业务部门），这里的情况变化很大。各个子维护者在 MAINTAINERS 文件中都有记录。
大多数这些子维护者有自己的树来暂存补丁，并向主要的 SoC 树发送拉取请求。这些树通常（但并非总是）在 MAINTAINERS 文件中有记录。如果不存在特定平台的维护者，或者他们没有响应，可以通过 soc@kernel.org 邮件列表联系主要的 SoC 维护者。
然而，SoC 树并不是架构特定代码变更的位置。每种架构都有自己的维护者，负责架构细节、CPU 错误等。
新子维护者的信息

随着新平台的出现，往往会带来新的子维护者，其中许多人是硅片供应商的员工，可能对流程不太熟悉。

##### 设备树 ABI 稳定性

需要特别强调的是 dt-bindings 文档定义了设备树与内核之间的 ABI。
请阅读 Documentation/devicetree/bindings/ABI.rst
如果对设备树所做的更改与旧内核不兼容，则不应在驱动程序合并之前或适当的时间之后应用设备树补丁。最重要的是，任何不兼容的更改都应在补丁说明和拉取请求中明确指出，并附上对现有用户（如引导加载程序或其他操作系统）预期影响的说明。

驱动分支依赖关系
~~~~~~~~~~~~~~~~~~~~~~~~~~

一个常见的问题是同步设备驱动程序和设备树文件之间的更改。即使这些更改在两个方向上都是兼容的，这也可能需要协调这些更改如何通过不同的维护者树进行合并。通常，包含驱动程序更改的分支也会包括对设备树绑定描述的相应更改，以确保它们实际上是兼容的。这意味着设备树分支最终可能会导致“make dtbs_check”步骤中的警告。如果设备树更改依赖于`include/dt-bindings/`目录中缺失的头文件添加，它将无法通过“make dtbs”步骤，因此不会被合并。

处理这个问题有多种方法：

* 避免为可以从数据手册中推导出的硬件常量在`include/dt-bindings/`中定义自定义宏——头文件中的绑定宏仅应在没有自然的方式来定义绑定时作为最后的手段使用。

* 即使需要头文件，在设备树文件中使用字面值代替宏，并在后续版本中改为命名表示。

* 将设备树更改推迟到绑定和驱动程序已经合并后的版本。

* 在一个共享的不可变分支中更改绑定，该分支用作驱动程序更改和设备树更改的基础。

* 在设备树文件中添加由`#ifndef`部分保护的重复定义，并在稍后的版本中移除它们。

设备树命名约定
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

设备树文件的一般命名方案如下：平台中在SoC级别设置的方面（如CPU核心）包含在一个名为`$soc.dtsi`的文件中，例如，`jh7100.dtsi`。集成细节，即会因板卡而异的部分，描述在`$soc-$board.dts`文件中。一个例子是`jh7100-beaglev-starlight.dts`。通常许多板卡都是基于某个主题的变体，通常存在一些中间文件，如`jh7100-common.dtsi`，位于`$soc.dtsi`和`$soc-$board.dts`文件之间，包含对常见硬件的描述。

有些平台还具有系统模块(System on Modules)，其中包含SoC，然后这些模块被集成到几个不同的板卡中。对于这些平台，`$soc-$som.dtsi`和`$soc-$som-$board.dts`通常是典型的。

目录通常根据SoC加入时的供应商名称来命名，这导致了树中一些历史性的目录名称。

验证设备树文件
~~~~~~~~~~~~~~~~~~~~~~~~~~~

可以使用`make dtbs_check`来验证设备树文件是否符合描述ABI的dt-bindings。请阅读Documentation/devicetree/bindings/writing-schema.rst中的“运行检查”部分，了解有关设备树验证的更多信息。

对于新平台或现有平台的新增部分，`make dtbs_check`不应该增加任何新的警告。对于RISC-V和Samsung SoC，需要使用`make dtbs_check W=1`来确保不增加任何新的警告。

如果对设备树的更改有任何疑问，请联系设备树维护者。

分支和拉取请求
~~~~~~~~~~~~~~~~~~~~~~~~~~

正如主要的SoC树有多个分支一样，期望子维护者也这样做。驱动程序、defconfig和设备树的更改应分别放入不同的分支并在不同的拉取请求中提交给SoC维护者。每个分支都应该是可独立使用的，并且要避免因依赖其他分支而产生的回归问题。
小规模的补丁集也可以作为单独的邮件发送到 soc@kernel.org，
按照相同的类别进行分组。
如果变更不符合常规模式，可以添加额外的顶级分支，
例如对于整个项目的重构，或者新增系统级芯片（SoC）平台，
包括设备树 (dts) 文件和驱动程序。
包含大量变更的分支可以从拆分为独立的主题分支中获益，
即使最终它们会被合并到同一个 SoC 树的分支中。一个例子是：
一个分支用于修复设备树警告，一个分支用于重构，
还有一个分支用于新增的板卡。
另一种常见的拆分变更的方法是在 rc1 和 rc4 之间某个时间点发送主要变更的大规模拉取请求，
随后在周期末尾发送一个或多个较小规模的拉取请求，
以添加后期变更或解决在测试第一组变更时发现的问题。
虽然没有对后期拉取请求设定截止时间，但随着合并窗口的临近，
只发送小规模的分支会更有帮助。
针对当前版本的bug修复的拉取请求可以在任何时候发送，
但同样，拥有多个较小规模的分支比试图将过多的补丁合并为一个拉取请求更好。
拉取请求的主题行应以 “[GIT PULL]” 开头，并使用签名标签而非分支。
此标签应包含一个简短描述，概述拉取请求中的变更。
有关发送拉取请求的更多详细信息，请参阅 Documentation/maintainer/pull-requests.rst。
