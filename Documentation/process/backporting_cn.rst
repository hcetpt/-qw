SPDX 许可证标识符: GPL-2.0

===================================
回退补丁与冲突解决
===================================

:作者: Vegard Nossum <vegard.nossum@oracle.com>

.. contents::
    :local:
    :depth: 3
    :backlinks: none

简介
============

一些开发人员可能在日常工作中很少需要处理补丁的回退、合并分支或解决冲突，因此当出现合并冲突时，可能会让人感到棘手。幸运的是，解决冲突是一种技能，有许多有用的技术可以帮助您更顺畅地完成这一过程，并提高对结果的信心。
本文档旨在提供一个全面、分步骤的指南来帮助进行补丁的回退和冲突解决。

将补丁应用到树中
============================

有时你需要回退的补丁已经作为一个 Git 提交存在，这种情况下可以直接使用 `git cherry-pick` 命令来选择性地应用它。然而，如果补丁来自邮件（对于 Linux 内核来说这种情况很常见），那么就需要使用 `git am` 命令将其应用到树中。
如果你曾经使用过 `git am`，你可能已经知道它非常挑剔补丁必须完美地应用到你的源代码树上。实际上，你可能还梦见过 `.rej` 文件以及试图编辑补丁以使其能被正确应用的情形。
强烈建议首先找到一个补丁可以干净地应用的基础版本，然后将它通过 cherry-pick 操作应用到你的目标树中，因为这样可以让 Git 输出冲突标记，并且让你可以在 Git 的帮助下使用你喜欢的其他冲突解决工具来解决问题。例如，如果你想将刚从 LKML（Linux Kernel Mailing List）收到的补丁应用到较旧的稳定内核版本上，你可以先将其应用到最近的主要内核版本上，然后再通过 cherry-pick 将其应用到较旧的稳定分支上。
通常最好使用生成补丁的确切基础版本，但只要补丁可以干净地应用并且与原始基础版本不太远，其实差别不大。如果将补丁应用到了“错误”的基础上，唯一的问题是，在将补丁通过 cherry-pick 应用到较旧分支时，可能会引入更多的无关更改到差异上下文中。
相比于 `git am`，`git cherry-pick` 更值得推荐的原因在于 Git 知道现有提交的确切历史记录，因此它能够知道代码发生了哪些移动以及行号的变化；这反过来降低了将补丁应用到错误位置的可能性（这可能导致无声的错误或复杂的冲突）。
如果你正在使用 `b4` 并且直接从邮件中应用补丁，你可以使用 `b4 am` 命令并搭配选项 `-g`/`--guess-base` 和 `-3`/`--prep-3way` 来自动执行这些操作（更多信息请参考 `b4 演示`）。但是，本文档的其余部分将假设你正在使用普通的 `git cherry-pick` 命令。
.. _b4: https://people.kernel.org/monsieuricon/introducing-b4-and-patch-attestation
.. _b4 演示: https://youtu.be/mF10hgVIx9o?t=2996

一旦你有了 Git 中的补丁，就可以继续通过 cherry-pick 将其应用到你的源代码树中。如果你想要保留补丁来源的信息，请记得使用 `-x` 选项！

注意：如果你正在为稳定版提交补丁，格式略有不同；主题行之后的第一行需要是：

    commit <上游提交> 上游

或者：

    [ 上游 commit <上游提交> ]

解决冲突
===================

哦不，cherry-pick 失败了，并显示了一个模糊威胁的消息：

    CONFLICT (内容): 合并冲突

现在该怎么办？

一般来说，冲突会在补丁的上下文（即被修改的行及其周围行）与你尝试将补丁应用到的树的内容不匹配时发生。
对于回退补丁的情况，很可能是因为你回退的分支包含了未包含在目标分支中的补丁。当然，也可能出现相反的情况。无论如何，结果都是需要解决的冲突。
如果你尝试的挑选（cherry-pick）因冲突而失败，Git会自动编辑文件以包含所谓的冲突标记，这些标记显示冲突所在位置以及两个分支是如何分叉的。解决冲突通常意味着以考虑这些其他提交的方式编辑最终结果。

解决冲突可以通过普通文本编辑器手动完成，或者使用专门的冲突解决工具。
许多人更喜欢使用他们的常规文本编辑器直接编辑冲突，因为这样可能更容易理解你在做什么，并且可以更好地控制最终结果。每种方法都有其优缺点，有时结合使用两者也有价值。

我们在这里不会详细介绍使用专门的合并工具，仅提供一些你可以使用的工具：

-  `Emacs Ediff mode <https://www.emacswiki.org/emacs/EdiffMode>`__
-  `vimdiff/gvimdiff <https://linux.die.net/man/1/vimdiff>`__
-  `KDiff3 <http://kdiff3.sourceforge.net/>`__
-  `TortoiseMerge <https://tortoisesvn.net/TortoiseMerge.html>`__
-  `Meld <https://meldmerge.org/help/>`__
-  `P4Merge <https://www.perforce.com/products/helix-core-apps/merge-diff-tool-p4merge>`__
-  `Beyond Compare <https://www.scootersoftware.com/>`__
-  `IntelliJ <https://www.jetbrains.com/help/idea/resolve-conflicts.html>`__
-  `VSCode <https://code.visualstudio.com/docs/editor/versioncontrol>`__

要配置Git与这些工具一起工作，请参阅`git mergetool --help`或官方的`git-mergetool文档`_。
.. _git-mergetool 文档: https://git-scm.com/docs/git-mergetool

前置补丁
--------

大多数冲突发生是因为你要回滚到的分支比你回滚“从”的分支缺少某些补丁。
在更一般的情况下（比如合并两个独立的分支），开发可能在这两个分支上都进行了，或者分支已经简单地分叉了——也许你的旧分支已经应用了一些其他的回滚补丁，这些补丁本身需要解决冲突，导致了分歧。
重要的是始终识别引起冲突的提交或提交集，否则你无法确信你的解决方法是正确的。作为额外的好处，特别是在你不太熟悉的领域，这些提交的变更日志往往会给你提供理解代码和潜在问题或陷阱所需的上下文。

git log
~~~~~~~

一个好的第一步是查看有冲突的文件的`git log`——当文件没有太多补丁时这通常是足够的，但如果文件很大并且经常被修改可能会变得混乱。你应该在当前检查出的分支（`HEAD`）和你正在挑选的补丁的父提交（`<commit>`）之间的提交范围内运行`git log`，即：
    
    git log HEAD..<commit>^ -- <path>

更好的做法是，如果你想将输出限制在一个特定的函数（因为那里出现了冲突），你可以使用以下语法：

    git log -L:'\<function\>':<path> HEAD..<commit>^

.. note::
     在函数名周围的``\<``和``\>``确保匹配以单词边界为锚点。这一点很重要，因为这部分实际上是一个正则表达式，Git只遵循第一个匹配，所以如果你使用`-L:thread_stack:kernel/fork.c`它可能只会给出`try_release_thread_stack_to_cache`这个函数的结果，即使该文件中还有许多其他包含字符串`thread_stack`的函数名称。
对于`git log`另一个有用的选项是`-G`，它允许你根据某些字符串出现在你列出的提交的差异中进行过滤：

    git log -G'regex' HEAD..<commit>^ -- <path>

这也是一种快速找到某个东西（例如一个函数调用或一个变量）何时被更改、添加或删除的好方法。搜索字符串是一个正则表达式，这意味着你可以潜在地搜索更具体的东西，如对特定结构体成员的赋值：

    git log -G'\->index\>.*='

git blame
~~~~~~~~~

另一种找到前置提交的方法（尽管只是针对给定冲突最近的一个）是运行`git blame`。在这种情况下，你需要针对你正在挑选的补丁的父提交和出现冲突的文件运行它，即：

    git blame <commit>^ -- <path>

此命令还接受`-L`参数（用于将输出限制到单个函数），但在此情况下，你像通常那样在命令末尾指定文件名：

    git blame -L:'\<function\>' <commit>^ -- <path>

导航到冲突发生的地方。blame输出的第一列是添加给定行代码的补丁的提交ID。
可能需要`git show`这些提交，看看它们是否可能是冲突的来源。有时会有多个这样的提交，要么是因为多个提交更改了同一冲突区域的不同行，要么是因为多个后续补丁多次更改了相同的行（或多行）。在后一种情况下，你可能需要再次运行`git blame`并指定文件的较旧版本来进一步挖掘文件的历史记录。
### 前提条件与附带补丁

找到导致冲突的补丁后，你需要判断它是你回溯补丁的前提条件还是仅仅是附带的可以跳过的补丁。附带的补丁是指触及到你正在回溯的补丁所修改的相同代码，但并未以任何实质方式改变代码含义的补丁。例如，一个仅清理空白字符（空格、换行等）的补丁是完全附带的——同样，仅仅重命名函数或变量的补丁也是附带的。另一方面，如果被修改的函数在你的当前分支中甚至不存在，那么这就绝不是附带的，你需要仔细考虑是否应该先选择性提取添加该函数的补丁。

如果你发现有必要的前提条件补丁，那么你需要停下来先选择性提取这个补丁。如果你已经在不同的文件中解决了某些冲突，并且不想再次解决，你可以创建该文件的一个临时副本。

要中断当前的选择性提取操作，可以运行 `git cherry-pick --abort`，然后使用前提条件补丁的提交ID重新开始选择性提取过程。

### 理解冲突标记

#### 综合差异

假设你决定不选择（或撤销）额外的补丁，而只是想解决冲突。Git将在你的文件中插入冲突标记。默认情况下，这看起来像这样：

    <<<<<<< HEAD
    这是你在选择性提取之前当前树中的内容
    =======
    这是补丁希望在选择性提取之后的内容
    >>>>>>> <commit>... 标题

这是你在编辑器中打开文件时看到的情况。

然而，如果你运行 `git diff` 而不带任何参数，输出会看起来像这样：

    $ git diff
    [...]
    ++<<<<<<<< HEAD
     +这是你在选择性提取之前当前树中的内容
    ++========
    + 这是补丁希望在选择性提取之后的内容
    ++>>>>>>>> <commit>... 标题

当你在解决冲突时，`git diff` 的行为与正常情况有所不同。注意有两个列的差异标记而不是通常的一列；这被称为“综合差异”，这里显示的是三路差异（或差异的差异）：

1. 当前分支（选择性提取之前）和当前工作目录之间的差异。
2. 当前分支（选择性提取之前）和应用原始补丁后的文件之间的差异。

#### 更好的差异

三路综合差异包括从你的当前分支到你从中选择性提取的分支之间文件中发生的其他所有变化。虽然这对于识别你需要考虑的其他变化很有用，但也使得 `git diff` 的输出显得有些吓人并且难以阅读。你可能更喜欢运行 `git diff HEAD`（或者 `git diff --ours`），它只显示选择性提取之前当前分支和当前工作目录之间的差异。它看起来像这样：

    $ git diff HEAD
    [...]
    +<<<<<<<< HEAD
     这是你在选择性提取之前当前树中的内容
    +========
    +这是补丁希望在选择性提取之后的内容
    +>>>>>>>> <commit>... 标题

如你所见，这就像任何其他差异一样容易阅读，并清楚地表明哪些行是在当前分支中，哪些行因为是合并冲突或选择性提取补丁的一部分而被添加进来。

#### 合并样式与 diff3

上面所示的默认冲突标记样式称为“合并”样式。还有一种可用的样式，称为“diff3”样式，看起来像这样：

    <<<<<<< HEAD
    这是你在选择性提取之前当前树中的内容
    ||||||| <commit> 的父项 (标题)
    这是补丁期望在那里找到的内容
    =======
    这是补丁希望在应用之后的内容
    >>>>>>> <commit> (标题)

如你所见，这有三个部分而不是两个，并包含了Git期望找到但实际上没有找到的内容。**强烈建议**使用这种冲突样式，因为它使你更清楚补丁实际做了什么改变——也就是说，允许你比较你正在选择性提取的提交前后的文件版本。这有助于你做出更好的决策来解决冲突。

要更改冲突标记样式，可以使用以下命令：

    git config merge.conflictStyle diff3

还有一个第三种选项，“zdiff3”，在 `Git 2.35` 中引入，具有与“diff3”相同的三个部分，但去除了共同的行，有时可以使冲突区域更小。

#### 在解决冲突的过程中迭代

解决任何冲突的第一个步骤是理解你正在回溯的补丁。对于Linux内核而言，这一点尤其重要，因为错误的改动可能导致整个系统崩溃——或者更糟糕的是，未被发现的安全漏洞。

理解补丁可能容易也可能困难，这取决于补丁本身、变更日志以及你对被改动代码的熟悉程度。
然而，对于每一次变更（或补丁中的每一部分）的一个好问题可能是：“为什么这部分变更在补丁中？” 对这些问题的回答将帮助你解决冲突。

**解决过程**

有时候最简单的方法就是只保留冲突的第一部分，使文件基本保持不变，并手动应用更改。比如，补丁可能将函数调用参数从 `0` 改为 `1`，而冲突的更改在参数列表末尾添加了一个全新的（不重要的）参数；在这种情况下，手动将参数从 `0` 改为 `1` 并让其他参数保持不变是很容易的。这种手动应用更改的技术主要在冲突引入了许多与之无关的上下文时有用，这些上下文你实际上并不需要关心。

对于有许多冲突标记的特别棘手的冲突，你可以使用 `git add` 或 `git add -i` 来选择性地提交你的解决方案，以清除障碍；这也可以让你使用 `git diff HEAD` 来始终查看还有哪些需要解决，或者使用 `git diff --cached` 来查看你的补丁目前的样子。

**处理文件重命名**

在回退补丁时最烦人的情况之一就是发现被补丁化的某个文件已经被重命名了，因为这意味着 Git 可能根本不会放置冲突标记，而是会直接放弃并说（意译）：“未合并路径！你自己来搞定吧...”

通常有几种方法可以处理这种情况。如果对重命名文件的补丁很小，例如只有一行的更改，最简单的方法就是直接手动应用更改然后结束。另一方面，如果更改很大或很复杂，你肯定不想手动进行。

作为初步尝试，你可以像下面这样做，将重命名检测阈值降低到30%（默认情况下，Git 使用 50%，意味着两个文件至少需要有50%的共同点才能被视为潜在的重命名）：

```bash
git cherry-pick -strategy=recursive -Xrename-threshold=30
```

有时正确的做法是同时回退执行重命名的补丁，但这肯定不是最常见的案例。相反，你可以暂时在你要回退到的分支中重命名文件（使用 `git mv` 并提交结果），重新开始尝试回退补丁，再把文件名改回来（再次使用 `git mv` 和提交），最后使用 `git rebase -i`（参见[回退教程](https://medium.com/@slamflipstrom/a-beginners-guide-to-squashing-commits-with-git-rebase-8185cf6e62ec)）合并结果，以便最终看起来像一个单独的提交。

**陷阱**

**函数参数**

注意函数参数的变化！很容易忽略细节，认为两行是一样的，但实际上它们在一些小细节上有所不同，比如传递给函数的变量（特别是如果两个变量都是单个字符且看起来相似，如 i 和 j）。

**错误处理**

如果你回退包含 `goto` 语句的补丁（通常是用于错误处理），绝对必须检查目标标签在你要回退到的分支中是否仍然正确。
对于新增的 `return`、`break` 和 `continue` 语句也是如此。
错误处理通常位于函数的底部，因此即使可能已被其他补丁更改也可能不会成为冲突的一部分。
确保审查错误路径的好方法是在检查更改时始终使用 `git diff -W` 和 `git show -W`（即 `--function-context`）。对于 C 代码，这将显示补丁中更改的整个函数。在回退过程中经常出错的是，在你从或回退到的任一分支中，函数中的其他内容发生了变化。通过在差异中包括整个函数，你将获得更多的上下文，并更容易发现可能被忽视的问题。
### 重构代码

经常发生的情况是，通过将一段通用的代码序列或模式“提取”到辅助函数中来进行代码重构。当需要将此类重构过的代码回退时，实际上你需要做的是相反的操作：对单个位置的补丁可能需要应用到回退版本中的多个位置。（这种情况的一个迹象是某个函数被重命名了——但这并非总是如此。）

为了避免不完整的回退，值得尝试判断该补丁修复的错误是否在多处出现。一种方法是使用`git grep`。（这实际上是一个好主意，不仅仅适用于回退的情况。）如果你确实发现其他地方也适用相同的修复方式，那么也值得查看这些地方是否存在于上游代码中——如果不存在，很可能需要调整补丁。`git log`是你的良伴，可以帮助你了解这些区域发生了什么变化，因为`git blame`不会显示已被移除的代码。
如果你在上游树中找到了相同模式的其他实例，并且不确定它是否也是一个bug，可以咨询补丁作者。在回退过程中发现新bug并不罕见！

### 验证结果

#### colordiff

在提交了一个无冲突的新补丁后，你现在可以比较你的补丁与原始补丁。强烈建议使用像`colordiff`这样的工具，它可以并排显示两个文件，并根据它们之间的差异用颜色标记它们：

```bash
colordiff -yw -W 200 <(git diff -W <upstream commit>^-) <(git diff -W HEAD^-) | less -SR
```

这里，`-y`表示并排比较；`-w`忽略空格，而`-W 200`设置了输出宽度（否则默认为130，这通常有点太小）
`rev^-`语法是`rev^..rev`的一种方便的缩写，基本上只给出那个单一提交的差异；也可以参阅官方的[git rev-parse文档]。
再次注意在`git diff`中包含`-W`；这确保你可以看到任何已更改函数的完整内容。
`colordiff`一个极其重要的功能是突出显示不同的行。例如，如果错误处理中的`goto`标签在原始和回退补丁之间发生了变化，`colordiff`将以不同的颜色并排显示这些内容。因此，很容易看出这两个`goto`语句跳转到了不同的标签。同样，那些没有被任何补丁修改但上下文中有差异的行也会被高亮显示，从而在手动检查时更加显眼。
当然，这只是视觉检查；真正的测试是构建并运行打过补丁的内核（或程序）。

#### 构建测试

我们在这里不会涵盖运行时测试，但构建仅被补丁触及的文件作为快速的合理性检查是个好主意。对于Linux内核，你可以像这样构建单个文件，假设你已经正确设置了`.config`和构建环境：

```bash
make path/to/file.o
```

请注意，这不会发现链接错误，所以在确认单个文件编译无误之后，仍然需要进行完整的构建。通过首先编译单个文件，你可以避免等待完整的构建过程，以防你在已更改的文件中有编译错误。

#### 运行时测试

即使成功的构建或启动测试也不一定足以排除某处缺失依赖的问题。尽管可能性很小，但可能存在两种独立的代码更改，它们对同一个文件进行了更改，结果没有冲突、没有编译时错误，并且只有在异常情况下才会出现运行时错误。
一个具体的例子是一对对系统调用入口代码的补丁，其中第一个补丁保存/恢复了一个寄存器，而稍后的补丁在这个序列中间使用了相同的寄存器。由于更改之间没有重叠，你可以选择第二个补丁，没有冲突，并认为一切正常，但实际上代码现在正在覆盖一个未保存的寄存器。
虽然绝大多数错误将在编译期间或通过粗略地执行代码来捕获，但真正验证回退的方法是以与你对待（或应该对待）任何其他补丁相同的严格程度审查最终的补丁。拥有单元测试、回归测试或其他类型的自动测试可以帮助增加对回退正确性的信心。
向稳定版提交回退补丁
==============================

随着稳定版维护者尝试将主线修复回退到他们的稳定内核，当遇到冲突时，他们可能会发送邮件请求回退。例如，参见：
<https://lore.kernel.org/stable/2023101528-jawed-shelving-071a@gregkh/>
这些邮件通常会包含你需要用于将补丁正确回退到相应树并提交补丁的确切步骤。
确保的一点是你的变更日志符合预期的格式：

  * 原始补丁标题
  
  * [ 上游提交 <主线修订版本> ]
  
  * 原始变更日志的其余部分
  * [ 冲突及其解决方案的概述 ]
  * 签名确认：[你的姓名和邮箱]

“上游提交”这一行有时会根据稳定版的不同而略有差异。较旧的版本使用了这样的格式：

  * 提交 <主线修订版本> 上游

在邮件主题行中指示补丁适用于哪个内核版本是最常见的做法（例如使用 `git send-email --subject-prefix='PATCH 6.1.y'`），但你也可以将其放在签名确认区域或 `---` 行下方。
稳定版维护者期望为每个活跃的稳定版本分别提交，并且每个提交都应单独进行测试。

几点最后的建议
===========================

1) 以谦逊的态度对待回退过程。
2) 理解你要回退的补丁；这意味着需要阅读变更日志和代码。
3) 在提交补丁时诚实地表达你对结果的信心程度。
4) 向相关的维护者请求明确的认可
示例
=====

上述内容大致展示了回传补丁的理想化流程。
为了提供一个更具体的例子，请参阅这个视频教程，其中有两个补丁从主线内核回传到了稳定版：
[回传Linux内核补丁](_)
.. _[回传Linux内核补丁]: https://youtu.be/sBR7R1V2FeA
