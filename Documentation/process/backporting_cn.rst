SPDX 许可声明标识符: GPL-2.0

===================================
回退补丁和冲突解决
===================================

:作者: Vegard Nossum <vegard.nossum@oracle.com>

.. contents::
    :local:
    :depth: 3
    :backlinks: none

介绍
============

一些开发人员可能在日常工作中从未真正处理过补丁的回退、合并分支或解决冲突，因此当出现合并冲突时，可能会感到棘手。幸运的是，解决冲突是一项技能，有许多有用的技巧可以帮助你使这一过程更加顺畅，并提高你对结果的信心。本文档旨在提供一个全面的、分步骤的指南来帮助进行补丁回退和冲突解决。

将补丁应用于树中
============================

有时你需要回退的补丁已经作为一个 Git 提交存在，在这种情况下，你可以直接使用 ``git cherry-pick`` 进行选择性应用。然而，如果补丁来自邮件，正如 Linux 内核开发中常见的那样，你需要使用 ``git am`` 将其应用到树中。
如果你曾经使用过 ``git am``，你可能已经知道它非常挑剔，要求补丁完美地适用于你的源代码树。事实上，你可能曾因 ``.rej`` 文件而烦恼，并尝试编辑补丁以使其能够应用。

强烈建议你首先找到一个补丁能干净应用的基础版本，然后将其 cherry-pick 到目标树中。这样可以使得 Git 输出冲突标记，并允许你借助 Git 和其他任何你喜欢的冲突解决工具来解决冲突。例如，如果你想将刚刚发布到 LKML 的补丁应用到较旧的稳定内核版本，可以先将其应用到最新的主线内核版本上，然后再将其 cherry-pick 到较旧的稳定分支。

通常最好使用与生成补丁时所用的完全相同的基础版本，但只要补丁能干净应用且与原始基础版本不相差太远，具体哪个版本并不重要。唯一的问题是，将补丁应用到“错误”的基础版本上可能会在 cherry-pick 到较旧分支时引入更多无关的变化上下文。

相比于使用 ``git am``，更推荐使用 ``git cherry-pick`` 的原因是 Git 知道现有提交的确切历史记录，因此当代码移动并更改行号时，它会知道这一点；这反过来降低了将补丁应用到错误位置的可能性（这可能导致静默错误或混乱的冲突）。

如果你正在使用 `b4` 并且直接从邮件中应用补丁，可以使用 ``b4 am`` 命令，加上选项 ``-g``/``--guess-base`` 和 ``-3``/``--prep-3way`` 来自动完成部分工作（更多信息请参见 `b4 演示`）。然而，本文档其余部分假设你在使用普通的 ``git cherry-pick``。

一旦你将补丁导入 Git 中，就可以继续将其 cherry-pick 到源代码树中。不要忘记如果需要记录补丁来源的话，记得使用 ``-x`` 选项！

注意，如果你提交的是稳定版补丁，格式略有不同；主题行后的第一行应该是：

    commit <upstream commit> upstream

或者：

    [ Upstream commit <upstream commit> ]

解决冲突
===================

哦不；cherry-pick 失败了，并且显示了一个模糊威胁的信息：

    CONFLICT (content): Merge conflict

现在该怎么办？

一般来说，冲突出现在补丁的上下文（即被更改的行和/或更改行周围的行）与你试图将补丁应用到的树中的内容不匹配时。
对于回退补丁来说，可能是由于你回退的分支包含了一些未在目标分支中存在的补丁。然而，相反的情况也有可能发生。无论如何，结果都是需要解决的冲突。
如果你尝试的挑拣提交（cherry-pick）因冲突而失败，Git 会自动编辑文件以包含所谓的冲突标记，显示冲突的位置以及两个分支是如何分歧的。解决冲突通常意味着以一种考虑到其他提交的方式编辑最终结果。

解决冲突可以通过使用常规文本编辑器手动完成，或者使用专门的冲突解决工具。许多人更喜欢使用他们的常规文本编辑器直接编辑冲突，因为这样可能更容易理解你在做什么，并且可以更好地控制最终结果。每种方法都有其优缺点，有时同时使用这两种方法也有价值。

我们在这里不会详细介绍如何使用专门的合并工具，仅提供一些可用工具的链接：

-  `Emacs Ediff mode <https://www.emacswiki.org/emacs/EdiffMode>`__
-  `vimdiff/gvimdiff <https://linux.die.net/man/1/vimdiff>`__
-  `KDiff3 <http://kdiff3.sourceforge.net/>`__
-  `TortoiseMerge <https://tortoisesvn.net/TortoiseMerge.html>`__
-  `Meld <https://meldmerge.org/help/>`__
-  `P4Merge <https://www.perforce.com/products/helix-core-apps/merge-diff-tool-p4merge>`__
-  `Beyond Compare <https://www.scootersoftware.com/>`__
-  `IntelliJ <https://www.jetbrains.com/help/idea/resolve-conflicts.html>`__
-  `VSCode <https://code.visualstudio.com/docs/editor/versioncontrol>`__

要配置 Git 与这些工具一起工作，请查看 `git mergetool --help` 或官方的 [git-mergetool文档]。
.. _git-mergetool文档: https://git-scm.com/docs/git-mergetool

先决条件补丁
-------------

大多数冲突的发生是因为你回退的目标分支相对于你回退的源分支缺少某些补丁。在更一般的情况下（例如合并两个独立分支），开发可能在这两个分支上进行过，或者分支本身已经分歧——也许你的旧分支应用了一些需要解决冲突的回退补丁，导致了分歧。

识别引起冲突的提交或提交集非常重要，否则你无法确保解决冲突的正确性。作为额外的好处，特别是在你不熟悉的领域中，这些提交的日志通常会给你提供理解代码和潜在问题或陷阱所需的上下文。

git log
~~~~~~~

一个好的第一步是查看有冲突的文件的 `git log` —— 这通常在文件没有很多补丁时就足够了，但如果文件很大并且频繁被修改，可能会变得复杂。你应该在当前检出的分支（`HEAD`）和你要挑选的补丁的父提交（`<commit>`）之间运行 `git log`，即：

    ```
    git log HEAD..<commit>^ -- <path>
    ```

更好的是，如果你想将输出限制在一个特定函数（因为这是冲突发生的地方），你可以使用以下语法：

    ```
    git log -L:'\<function\>':<path> HEAD..<commit>^
    ```

.. note::
     函数名周围的 ``\<`` 和 ``\>`` 确保匹配是在单词边界上锚定的。这一点很重要，因为这部分实际上是一个正则表达式，Git 只跟随第一个匹配项，所以如果你使用 `-L:thread_stack:kernel/fork.c`，它可能只给出 `try_release_thread_stack_to_cache` 函数的结果，即使该文件中有许多其他函数名称包含字符串 `thread_stack`。

`git log` 的另一个有用选项是 `-G`，它允许你过滤列出的提交中的 diff 中出现的某些字符串：

    ```
    git log -G'regex' HEAD..<commit>^ -- <path>
    ```

这也可以是一个快速找到某个东西（例如函数调用或变量）何时被更改、添加或删除的好方法。搜索字符串是一个正则表达式，这意味着你可以搜索更具体的东西，例如对特定结构体成员的赋值：

    ```
    git log -G'\->index\>.*='
    ```

git blame
~~~~~~~~~

另一种查找先决条件提交的方法（尽管只能找到给定冲突的最近一个提交）是运行 `git blame`。在这种情况下，你需要针对你要挑拣的补丁的父提交和冲突出现的文件运行它，即：

    ```
    git blame <commit>^ -- <path>
    ```

此命令也接受 `-L` 参数（用于将输出限制在一个特定函数），但在此情况下，你像往常一样在命令末尾指定文件名：

    ```
    git blame -L:'\<function\>' <commit>^ -- <path>
    ```

导航到冲突发生的位置。blame 输出的第一列是添加给定行代码的补丁的提交 ID。

最好查看这些提交的 `git show`，看看它们是否可能是冲突的来源。有时会有多个这样的提交，要么是因为多个提交修改了同一冲突区域的不同行，要么是因为多个后续补丁多次修改了相同的行（或行）。在后一种情况下，你可能需要再次运行 `git blame` 并指定文件的较早版本以进一步追溯文件的历史记录。
先决条件补丁与附带补丁
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

找到导致冲突的补丁后，你需要确定它是你回退补丁的先决条件，还是仅仅是附带的可以跳过的补丁。附带补丁是指修改了你正在回退补丁相同代码但并未实质性改变代码语义的补丁。例如，一个仅清理空白字符的补丁是完全附带的——同样，仅仅重命名函数或变量的补丁也是附带的。然而，如果被修改的函数在当前分支中根本不存在，那么这就不是附带的，你需要仔细考虑是否应该首先挑选（cherry-pick）添加该函数的补丁。如果你发现有一个必要的先决条件补丁，则需要停止并挑选这个补丁。如果你已经在另一个文件中解决了某些冲突且不想再解决一次，你可以创建该文件的一个临时副本。

要取消当前的挑选操作，请运行 `git cherry-pick --abort`，然后使用先决条件补丁的提交ID重新开始挑选过程。

理解冲突标记
------------------------------

组合差异
~~~~~~~~~~~~~~

假设你决定不选择（或撤销）其他补丁，只想解决冲突。Git会在你的文件中插入冲突标记。默认情况下，这看起来像这样：

    <<<<<<< HEAD
    这是在回退前当前分支的内容
    =======
    这是在回退后补丁希望它变成的样子
    >>>>>>> <commit>... 标题

这是你在编辑器中打开文件时会看到的情况。

但是，如果你运行 `git diff` 而没有任何参数，输出看起来会像这样：

    $ git diff
    [...]
    ++<<<<<<<< HEAD
     +这是在回退前当前分支的内容
    ++=======
    + 这是在回退后补丁希望它变成的样子
    ++>>>>>>>> <commit>... 标题

当你在解决冲突时，`git diff` 的行为与正常情况不同。注意有两个列的差异标记而不是通常的一列；这就是所谓的“组合差异”，这里显示的是三路差异（即差异中的差异）：

1. 当前分支（回退前）和当前工作目录之间的差异。
2. 当前分支（回退前）和原始补丁应用后的文件内容之间的差异。

更好差异
~~~~~~~~~~~~

三路组合差异包括了从当前分支到回退来源分支之间文件的所有其他变化。虽然这对于发现需要考虑的其他变化很有用，但也使得 `git diff` 的输出有些令人望而生畏且难以阅读。相反，你可能更喜欢运行 `git diff HEAD`（或 `git diff --ours`），它只显示回退前当前分支和当前工作目录之间的差异。它看起来像这样：

    $ git diff HEAD
    [...]
    +<<<<<<<< HEAD
     这是在回退前当前分支的内容
    +=======
    +这是在回退后补丁希望它变成的样子
    +>>>>>>>> <commit>... 标题

如你所见，这看起来就像任何其他差异，并清楚地表明哪些行属于当前分支，哪些行因为合并冲突或回退补丁而被添加。

合并样式和 diff3
~~~~~~~~~~~~~~~~~~~~~~

上面所示的默认冲突标记样式被称为“合并”样式。还有一种可用的样式称为“diff3”样式，如下所示：

    <<<<<<< HEAD
    这是在回退前当前分支的内容
    ||||||| <commit> 的父级 (标题)
    这是补丁期望在那里找到的内容
    =======
    这是在补丁应用后它希望变成的样子
    >>>>>>> <commit> (标题)

如你所见，这有三个部分而不是两个，并包含了Git期望找到但未找到的内容。强烈建议使用这种冲突样式，因为它更清晰地显示了补丁实际改变了什么；也就是说，它允许你比较你正在回退的提交前后文件的版本。这使你能更好地决定如何解决冲突。

要更改冲突标记样式，可以使用以下命令：

    git config merge.conflictStyle diff3

还有一个选项 `zdiff3`，在 `Git 2.35` 中引入，具有与 `diff3` 相同的三个部分，但其中常见的行已被删除，在某些情况下使冲突区域更小。

解决冲突的迭代过程
---------------------------------

解决冲突过程的第一步是理解你正在回退的补丁。对于Linux内核来说，这一点尤为重要，因为错误的更改可能导致整个系统崩溃——或者更糟，出现未被发现的安全漏洞。根据补丁本身、变更日志以及你对被修改代码的熟悉程度，理解补丁可能是容易的也可能是困难的。
然而，对于每个变更（或补丁中的每一部分）的一个好问题是：“为什么这一部分在补丁中？” 回答这些问题将有助于你的冲突解决。

**冲突解决过程**

有时候最简单的方法是只保留冲突的第一部分，使文件基本上保持不变，并手动应用更改。例如，补丁可能将函数调用参数从 ``0`` 更改为 ``1``，而另一个冲突的更改在参数列表末尾添加了一个全新的且不重要的参数；在这种情况下，手动将参数从 ``0`` 改为 ``1`` 并保留其他参数不变是相对容易的。这种手动应用更改的技术在冲突包含许多无关上下文的情况下特别有用，因为这些上下文你实际上不需要关心。

对于有大量冲突标记的特别棘手的冲突，你可以使用 ``git add`` 或 ``git add -i`` 来选择性地暂存你的解决方案以排除干扰；这还可以让你使用 ``git diff HEAD`` 查看剩余需要解决的问题，或者使用 ``git diff --cached`` 查看你目前的补丁是什么样子。

**处理文件重命名**

在回退补丁时最令人烦恼的事情之一就是发现要补丁的文件已经被重命名，因为这意味着 Git 甚至不会放入冲突标记，而是会直接放弃并说（大意）：“未合并路径！你自己动手吧...”

通常有几种方法可以应对这种情况。如果对重命名文件的补丁很小，比如只有一行更改，那么最简单的方法就是直接手动应用更改并结束。另一方面，如果更改很大或很复杂，你肯定不想手动处理。

作为初步尝试，你可以试试以下命令，这会将重命名检测阈值降低到 30%（默认情况下，Git 使用 50%，意味着两个文件至少需要有 50% 的相似度才能被视为潜在的重命名）：

```shell
git cherry-pick -strategy=recursive -Xrename-threshold=30
```

有时正确的做法是同时回退执行重命名的补丁，但这并不是最常见的做法。相反，你可以临时在你要回退的分支中重命名该文件（使用 ``git mv`` 并提交结果），重新尝试回退补丁，再将文件改回原名（再次使用 ``git mv`` 并提交），最后使用 ``git rebase -i``（参见[rebase教程](https://medium.com/@slamflipstrom/a-beginners-guide-to-squashing-commits-with-git-rebase-8185cf6e62ec)）将结果压缩成一个提交。

**陷阱**

**函数参数**

注意函数参数的变化！很容易忽略细节，认为两行代码是一样的，但实际上它们在某些小细节上有所不同，比如传递的变量（特别是当两个变量都是单个字符并且看起来相似时，如 i 和 j）。

**错误处理**

如果你回退的补丁包含一个 ``goto`` 语句（通常用于错误处理），则必须双重检查目标标签在你要回退的分支中是否仍然正确。同样适用于新增的 ``return``、``break`` 和 ``continue`` 语句。

错误处理通常位于函数底部，因此即使可能已被其他补丁更改，也可能不在冲突范围内。确保审查错误路径的一个好方法是在检查更改时始终使用 ``git diff -W`` 和 ``git show -W``（即 ``--function-context``）。对于 C 代码，这将显示整个被修改的函数。在回退过程中经常出错的地方是函数中的其他部分在你回退的任一分支上发生了变化。通过在差异中包含整个函数，你可以获得更多的上下文，并更容易发现可能被忽视的问题。
重构代码
~~~~~~~~~~~~~~~

经常发生的情况是，通过“提取”一个公共的代码序列或模式到辅助函数中来进行代码重构。当需要将补丁回退到已经进行过这种重构的地方时，实际上你需要做的是相反的操作：对单一位置的补丁可能需要应用到多个位置上。（在这种情况下的一种迹象是某个函数被重命名了——但并不总是如此。）

为了避免不完整的回退，值得尝试确定该补丁修复的错误是否在多处出现。一种方法是使用 `git grep`。（这实际上是一个好主意，不仅适用于回退补丁。）如果你确实发现其他地方也需要同样的修复，也值得查看这些地方在上游是否存在——如果不存在，那么可能需要调整补丁。`git log` 是你的朋友，可以帮你了解这些地方发生了什么，因为 `git blame` 不会显示已被删除的代码。
如果你在上游树中找到相同模式的其他实例，并且不确定它是否也是个错误，可以向补丁作者询问。在回退过程中发现新错误是很常见的！

验证结果
====================

colordiff
---------

提交了一个无冲突的新补丁后，现在可以将你的补丁与原始补丁进行比较。强烈建议你使用像 `colordiff`_ 这样的工具，它可以并排显示两个文件，并根据它们之间的差异进行着色：

```shell
colordiff -yw -W 200 <(git diff -W <upstream commit>^-) <(git diff -W HEAD^-) | less -SR
```

这里，`-y` 表示并排比较；`-w` 忽略空格，而 `-W 200` 设置输出宽度（否则默认为130，通常有点太小）。`rev^-` 语法是 `rev^..rev` 的便捷写法，基本上只给你那个单个提交的差异；参见官方的 `git rev-parse 文档`_。
.. _colordiff: https://www.colordiff.org/
.. _git rev-parse 文档: https://git-scm.com/docs/git-rev-parse#_other_rev_parent_shorthand_notations

再次注意，在 `git diff` 中包含 `-W` 参数，以确保可以看到任何已更改函数的完整内容。`colordiff` 做的一件非常重要的事情是突出显示不同的行。例如，如果错误处理的 `goto` 标签在原始补丁和回退补丁之间有所变化，`colordiff` 将并排显示这些行，但用不同颜色突出显示。因此，很容易看出这两个 `goto` 语句跳转到了不同的标签。同样，未被任何补丁修改但在上下文中不同的行也会被突出显示，从而在手动检查时显得突出。
当然，这只是视觉检查；真正的测试是构建并运行打过补丁的内核（或程序）。

构建测试
--------------

我们在这里不会涵盖运行时测试，但构建受补丁影响的文件作为快速的合理性检查是个好主意。对于 Linux 内核，你可以这样构建单个文件，假设你已经正确设置了 `.config` 和构建环境：

```shell
make path/to/file.o
```

请注意，这不会发现链接错误，所以你应该在确认单个文件编译成功后再进行完整的构建。首先编译单个文件可以避免因你修改过的文件中有编译错误而不得不等待完整的构建。

运行时测试
--------------

即使构建或引导测试成功也不一定意味着没有遗漏的依赖项。尽管概率很小，可能会有两处独立的更改在同一文件中导致没有冲突、没有编译错误，但在运行时仅在特殊情况下出错。
一个具体的例子是一对系统调用入口代码的补丁，第一个补丁保存/恢复了一个寄存器，而稍后的补丁在这段代码中间使用了同一个寄存器。由于更改之间没有重叠，可以单独选择第二个补丁，没有任何冲突，并认为一切正常，但实际上代码正在覆盖一个未保存的寄存器。
尽管绝大多数错误会在编译过程中或通过初步运行代码来捕获，真正验证回退补丁的方法是以与你对待任何其他补丁相同的严格程度审查最终补丁。拥有单元测试、回归测试或其他类型的自动测试可以帮助增加对回退补丁正确性的信心。
提交回退补丁至稳定版本
==============================

随着稳定版本维护者尝试将主线修复补丁选择性地应用到他们的稳定内核上，当遇到冲突时，他们可能会发送电子邮件请求回退补丁。例如，请参阅：<https://lore.kernel.org/stable/2023101528-jawed-shelving-071a@gregkh/>

这些电子邮件通常会包含你需要将补丁选择性地应用到正确树并提交补丁的确切步骤。需要注意的一点是，确保你的变更日志符合预期的格式：

  <原始补丁标题>
  
  [ 上游提交 <主线修订版本> ]
  
  <原始变更日志的其余部分>
  [ <冲突及其解决方案的概要> ]
  Signed-off-by: <你的姓名和电子邮件>

“Upstream commit”行有时会略有不同，具体取决于稳定版本。较旧的版本使用了以下格式：

  commit <主线修订版本> upstream

在邮件主题行中指明补丁适用的内核版本是最常见的做法（例如使用``git send-email --subject-prefix='PATCH 6.1.y'``），但你也可以将其放在Signed-off-by:区域或``---``行下方。

稳定版本维护者期望为每个活跃的稳定版本分别提交，并且每个提交也应单独进行测试。

几点最后的建议
===========================

1) 以谦逊的态度对待回退补丁的过程。
2) 理解你要回退的补丁；这意味着要阅读变更日志和代码。
3) 在提交补丁时，对你对结果的信心保持诚实。
4) 向相关维护者请求明确的确认（acks）

示例
========

上述内容大致展示了理想化的回退补丁流程。为了更具体地了解这一过程，请参阅以下视频教程，其中展示了如何将两个补丁从主线回退到稳定版：
《回退 Linux 内核补丁》_
.. _《回退 Linux 内核补丁》: https://youtu.be/sBR7R1V2FeA
