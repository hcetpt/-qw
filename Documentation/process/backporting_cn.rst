SPDX 许可证标识符: GPL-2.0

===================================
回退补丁与冲突解决
===================================

:作者: Vegard Nossum <vegard.nossum@oracle.com>

.. contents::
    :local:
    :depth: 3
    :backlinks: none

简介
============

一些开发者可能在日常工作中几乎不需要处理补丁的回退、分支合并或解决冲突，因此当合并冲突出现时，可能会感到棘手。幸运的是，解决冲突是一项技能，有许多有用的技术可以帮助您更顺畅地完成这一过程，并增强对结果的信心。
本文档旨在提供一个全面的、分步骤的指南来帮助您进行补丁的回退和冲突解决。

将补丁应用到树中
============================

有时您要回退的补丁已经作为一个git提交存在，这种情况下可以直接使用``git cherry-pick``命令进行选择性提取。然而，如果补丁是从邮件中获得的，就像Linux内核中的情况那样，您就需要使用``git am``命令将其应用到树中。
如果您曾经使用过``git am``，可能已经知道它要求补丁必须完美地应用到您的源代码树上。事实上，您可能梦见过``.rej``文件以及尝试编辑补丁以使其能够成功应用的情形。
强烈建议首先找到一个补丁能干净地应用其上的合适基版本，然后将它cherry-pick到目标树中，这样可以使得git输出冲突标记，并且让您可以在git的帮助下或者使用其他您喜欢的冲突解决工具来解决这些冲突。例如，如果您想将刚从LKML收到的一个补丁应用到一个较旧的稳定版内核上，您可以先将该补丁应用到最近的主要版本内核上，然后再将其cherry-pick到您的较旧稳定版分支上。
通常最好使用与生成补丁时所用完全相同的基版本，但只要补丁能干净地应用并且与原始基版本不太远，具体用哪个版本其实不太重要。将补丁应用到“错误”的基版本上唯一的问题是，在cherry-pick到较旧分支时可能会将更多无关的改动带入上下文中。
相比``git am``，使用``git cherry-pick``的一个很好的原因是git了解现有提交的确切历史记录，所以它会知道代码如何移动以及行号的变化；这反过来减少了将补丁应用到错误位置的可能性（这可能导致无声的错误或混乱的冲突）。
如果您正在使用`b4`_并且直接从邮件中应用补丁，您可以使用``b4 am``加上选项``-g``/``--guess-base``和``-3``/``--prep-3way``来进行自动化操作（更多信息请参见`b4演示`_）。但是，本文档的其余部分将假设您正在执行普通的``git cherry-pick``。
.. _b4: https://people.kernel.org/monsieuricon/introducing-b4-and-patch-attestation
.. _b4演示: https://youtu.be/mF10hgVIx9o?t=2996

一旦您将补丁放入git中，就可以继续将其cherry-pick到您的源代码树中。别忘了如果您希望保留补丁来源的信息，应该使用``-x``选项！

请注意，如果您提交的补丁是针对稳定版本的，格式略有不同；主题行之后的第一行需要是：

    commit <上游提交> 上游

或

    [ 上游 commit <上游提交> ]

解决冲突
===================

糟糕；cherry-pick失败了，并且显示了一个模糊而威胁的消息：

    CONFLICT (content): 合并冲突

现在该怎么办？

一般来说，冲突出现是因为补丁的上下文（即被修改的行和/或周围行）与您试图将补丁应用到的树中的内容不匹配。
对于回退补丁的情况，很可能是您回退的分支包含了一些未包含在您回退到的分支中的补丁。不过，相反的情况也有可能发生。无论如何，最终的结果是一个需要解决的冲突。
如果你尝试的挑拣（cherry-pick）因冲突而失败，git会自动编辑文件以包含所谓的冲突标记，显示冲突所在位置以及两个分支是如何分歧的。解决冲突通常意味着以一种考虑到这些其他提交的方式来编辑最终结果。

解决冲突可以通过在普通文本编辑器中手动进行，或使用专门的冲突解决工具来完成。
许多人更倾向于使用他们的常规文本编辑器直接编辑冲突，因为它可能更容易理解你在做什么，并控制最终结果。每种方法都有其优缺点，有时结合使用两者都有价值。

我们在这里不会详细讨论使用专门的合并工具，仅提供一些你可以使用的各种工具的指引：

-  `Emacs Ediff模式 <https://www.emacswiki.org/emacs/EdiffMode>`__
-  `vimdiff/gvimdiff <https://linux.die.net/man/1/vimdiff>`__
-  `KDiff3 <http://kdiff3.sourceforge.net/>`__
-  `TortoiseMerge <https://tortoisesvn.net/TortoiseMerge.html>`__
-  `Meld <https://meldmerge.org/help/>`__
-  `P4Merge <https://www.perforce.com/products/helix-core-apps/merge-diff-tool-p4merge>`__
-  `Beyond Compare <https://www.scootersoftware.com/>`__
-  `IntelliJ <https://www.jetbrains.com/help/idea/resolve-conflicts.html>`__
-  `VSCode <https://code.visualstudio.com/docs/editor/versioncontrol>`__

要配置git与这些工具一起工作，请参阅``git mergetool --help``或官方的`git-mergetool文档`_。
.. _git-mergetool 文档: https://git-scm.com/docs/git-mergetool

先决条件补丁
--------------

大多数冲突发生是因为你回退到的分支与你从之回退的分支相比缺少某些补丁。
在更一般的情况下（例如合并两个独立的分支），开发可能在这两个分支中的任何一个上进行，或者分支只是简单地分歧了——也许你的旧分支已经应用了一些其他的回退补丁，它们本身需要冲突解决，导致分歧。
识别引起冲突的提交或提交集是非常重要的，否则你无法确信你的解决方案是正确的。作为额外的好处，特别是如果补丁是在你不熟悉的区域，这些提交的更改日志经常会给你上下文来理解代码和潜在的问题或陷阱，与你的冲突解决有关。

git log
~~~~~~~

一个好的开始是查看冲突文件的`git log`——当文件没有很多补丁时，这通常是足够的，但如果文件很大并且经常被修补，可能会变得混乱。你应该在你当前签出的分支（`HEAD`）和你要挑选的补丁的父提交（`<commit>`）之间的提交范围内运行`git log`，即： 

    git log HEAD..<commit>^ -- <path>

更好的是，如果你想将此输出限制为一个单一的功能（因为这就是冲突出现的地方），你可以使用以下语法：

    git log -L:'\<function\>':<path> HEAD..<commit>^

.. note::
     功能名称周围的``\<``和``\>``确保匹配是以单词边界为锚点的。这是重要的，因为这部分实际上是一个正则表达式，git只遵循第一个匹配，所以如果你使用`-L:thread_stack:kernel/fork.c`它可能只给出`try_release_thread_stack_to_cache`函数的结果，即使该文件中有许多其他函数在其名称中含有`thread_stack`字符串。

`git log`的另一个有用选项是`-G`，它允许你过滤在你列出的提交的差异中出现的特定字符串：

    git log -G'regex' HEAD..<commit>^ -- <path>

这也是一种快速找到某个东西（例如，一个函数调用或一个变量）何时被改变、添加或删除的便捷方式。搜索字符串是一个正则表达式，这意味着你可能可以搜索更具体的东西，如对特定结构成员的赋值：

    git log -G'\->index\>.*='

git blame
~~~~~~~~~

另一种找到先决条件提交的方法（尽管仅适用于给定冲突的最近的一个）是运行`git blame`。在这种情况下，你需要针对你正在挑选的补丁的父提交和冲突出现的文件运行它，即：

    git blame <commit>^ -- <path>

此命令还接受`-L`参数（用于限制输出到单一功能），但在此情况下，你像往常一样在命令末尾指定文件名：

    git blame -L:'\<function\>' <commit>^ -- <path>

导航到冲突发生的地方。责备输出的第一列是添加给定行代码的补丁的提交ID。

可能是个好主意去`git show`这些提交，看看它们是否看起来像是冲突的来源。有时会有多个这样的提交，要么是因为多个提交改变了同一冲突区域的不同行，要么是因为多个后续补丁多次改变了相同的行（或多行）。在后一种情况下，你可能需要再次运行`git blame`并指定文件的旧版本以便进一步挖掘文件的历史。
### 前提条件与附带补丁

找到导致冲突的补丁后，你需要判断它是你回溯补丁的前提条件还是仅仅是附带的可以跳过的补丁。附带的补丁是指触及到你正在回溯的补丁所修改的相同代码，但没有以任何实质性的方式改变代码的语义。例如，空白字符清理补丁完全是附带的——同样地，仅仅重命名函数或变量的补丁也是附带的。另一方面，如果被修改的函数在你的当前分支中根本不存在，则这完全不是附带的，并且你需要仔细考虑是否应该先选择性提取添加该函数的补丁。
如果你发现有必要的前提条件补丁，那么你需要停止并选择性提取那个补丁。如果你已经在另一个文件中解决了某些冲突并且不想再解决一次，你可以创建该文件的临时副本。

为了中止当前的选择性提取，运行
``git cherry-pick --abort``，然后使用前提条件补丁的提交ID重新开始选择性提取过程。

### 理解冲突标记

#### 组合差异

假设你决定不选择（或撤销）额外的补丁，而只是想解决冲突。Git会在你的文件中插入冲突标记。默认情况下，看起来像这样：

    <<<<<<< HEAD
    这是你选择性提取之前当前树中的内容
    =======
    这是补丁希望它成为的样子，在选择性提取之后
    >>>>>>> <commit>... 标题

这是如果你在编辑器中打开文件会看到的样子。
然而，如果你运行 ``git diff`` 而不带任何参数，输出会看起来像这样：

    $ git diff
    [...]
    ++<<<<<<<< HEAD
     +这是你选择性提取之前当前树中的内容
    ++=======
    + 这是补丁希望它成为的样子，在选择性提取之后
    ++>>>>>>>> <commit>... 标题

当你在解决冲突时，``git diff`` 的行为与正常情况不同。注意有两个列的差异标记而不是通常的一个；这就是所谓的“`组合差异`”，这里显示的是三路差异（或差异的差异），即

1. 当前分支（选择性提取之前）和当前工作目录之间的差异；
2. 当前分支（选择性提取之前）和原始补丁应用后的文件样子之间的差异。

#### 更好的差异

三路组合差异包括了从你的当前分支到你从中选择性提取的分支之间发生的其他所有更改。虽然这对于注意到你需要考虑的其他更改很有用，但这也会使得 ``git diff`` 的输出有些吓人且难以阅读。你可能更倾向于运行 ``git diff HEAD``（或者 ``git diff --ours``），它只显示选择性提取之前当前分支和当前工作目录之间的差异。它看起来像这样：

    $ git diff HEAD
    [...]
    +<<<<<<<< HEAD
     这是你选择性提取之前当前树中的内容
    +=======
    +这是补丁希望它成为的样子，在选择性提取之后
    +>>>>>>>> <commit>... 标题

如你所见，这就像任何其他的差异一样，并清楚地表明哪些行在当前分支中，哪些行因为是合并冲突或正在选择性提取的补丁的一部分而被添加。

#### 合并样式和 diff3

上面显示的默认冲突标记样式称为“合并”样式。还有一种可用的样式，称为“diff3”样式，看起来像这样：

    <<<<<<< HEAD
    这是你选择性提取之前当前树中的内容
    ||||||| <commit> 的父级 (标题)
    这是补丁期望在那里找到的内容
    =======
    这是补丁希望它成为的样子，在应用之后
    >>>>>>> <commit> (标题)

如你所见，这有三个部分而不是两个，并包含了Git期望在那里找到但实际上没找到的内容。**强烈推荐**使用这种冲突样式，因为它更加清晰地说明了补丁实际上改变了什么；也就是说，它允许你比较你正在选择性提取的提交的前后版本。这可以帮助你更好地决定如何解决冲突。

要更改冲突标记样式，可以使用以下命令：

    git config merge.conflictStyle diff3

还有一个第三选项，“zdiff3”，在 `Git 2.35` 中引入，它与“diff3”有相同的三个部分，但是去除了共同的行，有时可以使冲突区域更小。

#### 在冲突解决方案上的迭代

任何冲突解决过程的第一步是理解你正在回溯的补丁。对于Linux内核来说这一点尤其重要，因为错误的更改可能会导致整个系统崩溃——或者更糟，未被检测到的安全漏洞。
理解补丁的难易程度取决于补丁本身、变更日志以及你对被修改代码的熟悉程度。
然而，对于每一次变更（或补丁的每一部分）的一个好问题可能是：“为什么这一部分在补丁中？”回答这些问题将有助于你的冲突解决。

**解决过程**

有时候最简单的事情就是只保留冲突中的第一部分内容，使文件基本保持不变，并手动应用更改。也许补丁正在将函数调用参数从`0`更改为`1`，而一个冲突的更改在参数列表末尾添加了一个全新的（且不重要的）参数；在这种情况下，手动将参数从`0`更改为`1`并让其他参数保持不变是相当容易的。这种手动应用更改的技术在冲突拉入了许多你实际上不需要关心的无关上下文时特别有用。

对于特别棘手的冲突，带有许多冲突标记的情况，你可以使用`git add`或`git add -i`来选择性地将解决方案暂存起来，以清除障碍；这也可以让你使用`git diff HEAD`始终查看剩余待解决的内容，或者使用`git diff --cached`查看你的补丁当前的样子。

**处理文件重命名**

在回传补丁时最令人恼火的事情之一就是发现其中一个被修补的文件已经被重命名，因为这意味着git甚至都不会放入冲突标记，而是会直接放弃并说（大意是）：“未合并路径！你自己去处理吧...”

通常有几种方法可以应对这种情况。如果对重命名文件的补丁很小，比如是一行更改，最容易的方法就是直接手动应用更改并完成。另一方面，如果更改很大或很复杂，你肯定不想手动去做。

作为初步尝试，你可以像这样操作，将重命名检测阈值降低到30%（默认情况下，git使用50%，意味着两个文件至少需要有50%的相似度才会被认为是潜在的重命名）：

```bash
git cherry-pick -strategy=recursive -Xrename-threshold=30
```

有时正确的事情是同时回传执行重命名的补丁，但这绝对不是最常见的案例。相反，你可以做的是，在你要回传的分支中临时重命名文件（使用`git mv`并提交结果），重新开始尝试cherry-pick补丁，再将文件名改回来（再次使用`git mv`并提交），最后使用`git rebase -i`（参见`rebase教程`_）压缩结果，以便完成后它看起来像是单个提交。

.. _rebase教程: https://medium.com/@slamflipstrom/a-beginners-guide-to-squashing-commits-with-git-rebase-8185cf6e62ec

**陷阱**

**函数参数**

注意更改函数参数！很容易忽略细节，认为两行代码相同，但实际上它们在一些小细节上不同，比如传递给参数的变量（特别是如果两个变量都是看起来相同的单个字符，如i和j）

**错误处理**

如果你cherry-pick包含`goto`语句的补丁（通常是用于错误处理），绝对必须在你回传的分支中双检查目标标签是否仍然正确

对于添加的`return`、`break`和`continue`语句也适用

错误处理通常位于函数底部，因此可能不会成为冲突的一部分，尽管它可能已被其他补丁更改

确保审查错误路径的一个好方法是在检查更改时始终使用`git diff -W`和`git show -W`（即`--function-context`）。对于C代码，这将向你展示补丁中正在更改的整个函数。在回传过程中经常出错的一点是，函数中的其他内容在你回传的任一分支上发生了变化。通过在diff中包括整个函数，你将获得更多的上下文，并能更容易地发现可能被忽视的问题。
代码重构
~~~~~~~~~~~~~~~

经常会遇到的情况是，通过“提取”出一段通用的代码序列或模式到辅助函数中来进行代码重构。当将此类重构区域的补丁回退时，实际上你需要进行逆向操作：对单一位置的补丁可能需要应用到回退版本中的多个位置。（在这种情形下的一条线索是某个函数被重命名了——但并不总是如此）

为了避免不完全的回退，尝试判断该补丁修复的bug是否在多处出现是值得的。一种方法是使用`git grep`。（这实际上是一个好主意，不仅限于回退补丁）如果你确实发现同样的修复适用于其他地方，也值得看看这些地方在上游是否存在——如果不存在，补丁可能需要调整。`git log`能帮助你了解这些区域发生了什么变化，而`git blame`则不会显示已被移除的代码。
如果你在上游树中找到同一模式的其他实例，且不确定它是否也是一个bug，询问补丁作者可能是值得的。在回退过程中发现新bug并不罕见！

验证结果
====================

colordiff
---------

在提交无冲突的新补丁后，你现在可以比较你的补丁与原始补丁。强烈推荐使用如`colordiff`_之类的工具，它可以并排显示两个文件，并根据它们之间的变化着色：
```
colordiff -yw -W 200 <(git diff -W <upstream commit>^-) <(git diff -W HEAD^-) | less -SR
```

.. _colordiff: https://www.colordiff.org/

这里，`-y`表示并排比较；`-w`忽略空白字符，而`-W 200`设置了输出宽度（否则默认为130，通常有点小）
`rev^-`语法是`rev^..rev`的便捷缩写，实质上只给你那单个提交的差异；另见官方`git rev-parse文档`_
.. _git rev-parse文档: https://git-scm.com/docs/git-rev-parse#_other_rev_parent_shorthand_notations

再次注意`git diff`中的`-W`包含；这确保你会看到任何已更改函数的完整内容
`colordiff`执行的一个极其重要的操作是突出显示不同的行。例如，如果错误处理`goto`在原始和回退补丁之间改变了标签，`colordiff`将以不同颜色并排显示这些，因此很容易看出这两个`goto`语句跳转到不同的标签。同样，未被任何补丁修改但上下文不同的行也会被突出显示，在手动检查中脱颖而出。
当然，这只是视觉检查；真正的测试是构建并运行打过补丁的内核（或程序）。

构建测试
-------------

我们在这里不会覆盖运行时测试，但作为快速的合理性检查，构建仅由补丁触及的文件是个好主意。对于Linux内核，你可以像这样构建单个文件，假设你已经正确设置了`.config`和构建环境：
```
make path/to/file.o
```

请注意，这不会发现链接错误，所以你仍然应该在确认单个文件编译无误后进行完整的构建。首先编译单个文件可以避免等待完整构建*如果*你更改的任何文件中有编译错误的话。

运行时测试
---------------

即使成功的构建或引导测试也不一定足以排除某处缺失依赖的情况。尽管可能性很小，可能会有代码变更，其中对同一文件的两个独立更改导致没有冲突、没有编译时错误，只有在异常情况下才出现运行时错误。
一个具体的例子是一对系统调用入口代码的补丁，第一个补丁保存/恢复了一个寄存器，而稍后的补丁在这一序列中间利用了同一个寄存器。由于变更之间没有重叠，可以单独选择第二个补丁，没有冲突，会认为一切正常，但实际上代码正在涂改未保存的寄存器。
虽然绝大多数错误将在编译期间或通过粗略地运行代码来捕捉，真正验证回退的唯一方法是以与你将给予（或应该给予）任何其他补丁相同程度的审查来审查最终补丁。拥有单元测试、回归测试或其他类型的自动测试可以帮助增加对回退正确性的信心。
向稳定版提交回退补丁
==============================

随着稳定版维护者尝试将主线修复回退到他们的稳定内核，当遇到冲突时，他们可能会发送邮件请求回退。例如，参见：
<https://lore.kernel.org/stable/2023101528-jawed-shelving-071a@gregkh/>
这些邮件通常会包含你需要用于将补丁正确回退到相应树并提交补丁的确切步骤。
确保的一点是你的变更日志符合预期的格式：

  * 原始补丁标题
  
  * [ 上游提交 <主线修订版本> ]
  
  * 原始变更日志的其余部分
  * [ 冲突及其解决方案的概述 ]
  * 签名确认：[你的姓名和邮箱]

“上游提交”这一行有时会根据稳定版的不同而略有差异。较旧的版本使用了以下格式：

  * 提交 <主线修订版本> 上游

在邮件主题行中指示补丁适用于哪个内核版本是最常见的做法（例如使用 `git send-email --subject-prefix='PATCH 6.1.y'`），但你也可以将其放在签名确认区域或 `---` 行下方。
稳定版维护者期望为每个活跃的稳定版本分别提交，并且每个提交都应单独进行测试。

几点最后的建议
===========================

1) 以谦逊的态度对待回退过程。
2) 理解你要回退的补丁；这意味着需要阅读变更日志和代码。
3) 在提交补丁时诚实地表达你对结果的信心程度。
4) 向相关的维护者请求明确的认可
示例
=====

上述内容大致展示了理想化的回传补丁流程。
为了提供一个更具体的例子，请参阅这个视频教程，其中展示了如何将两个补丁从主线回传到稳定版：
[回传Linux内核补丁]_
.. _回传Linux内核补丁: https://youtu.be/sBR7R1V2FeA
