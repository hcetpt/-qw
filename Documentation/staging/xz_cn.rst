XZ 数据压缩在 Linux 中的应用
============================

简介
============

XZ 是一种具有高压缩比和相对较快解压缩速度的通用数据压缩格式。主要的压缩算法（过滤器）是 LZMA2。可以使用其他过滤器进一步提高压缩比。例如，Branch/Call/Jump (BCJ) 过滤器可以改善可执行数据的压缩比。
Linux 中的 XZ 解压缩器称为 XZ Embedded。它支持 LZMA2 过滤器，并且可选地也支持 BCJ 过滤器。CRC32 支持完整性校验。XZ Embedded 的主页位于 <https://tukaani.org/xz/embedded.html>，在那里你可以找到最新版本以及如何将代码用于 Linux 内核之外的信息。
对于用户空间，XZ Utils 提供了一个类似于 zlib 的压缩库和一个类似于 gzip 的命令行工具。XZ Utils 可以从 <https://tukaani.org/xz/> 下载。
内核中的 XZ 相关组件
===================================

xz_dec 模块提供了单次调用（缓冲到缓冲）和多次调用（有状态）API 的 XZ 解压缩器。xz_dec 模块的使用方法在 include/linux/xz.h 中有详细说明。
xz_dec_test 模块用于测试 xz_dec。除非你在修改 XZ 解压缩器，否则 xz_dec_test 并没有实际用途。xz_dec_test 动态分配了一个字符设备主设备号，用户可以从用户空间写入 .xz 文件。解压后的输出会被丢弃。
注意观察 dmesg 以查看 xz_dec_test 打印的诊断信息。请参阅 xz_dec_test 的源代码以获取详细信息。
为了解压缩内核镜像、initramfs 和 initrd，lib/decompress_unxz.c 中提供了一个包装函数。其 API 与其它 decompress_*.c 文件相同，定义在 include/linux/decompress/generic.h 中。
scripts/xz_wrap.sh 是一个为从 XZ Utils 获取的 xz 命令行工具提供的包装脚本。该包装脚本设置了一些适用于压缩内核镜像的压缩选项。
对于内核的 Makefile，提供了两个命令以与 $(call if_needed) 一起使用。内核镜像应使用 $(call if_needed,xzkern) 压缩，这将使用 BCJ 过滤器和较大的 LZMA2 字典。同时还会附加一个包含文件未压缩大小的四字节尾部，这是引导代码所需要的。
其他内容应使用 `$(call if_needed, xzmisc)` 进行压缩，
这将不使用任何 BCJ 滤波器，并且使用 1 MiB 的 LZMA2 字典。
压缩选项说明
=============

由于 XZ 嵌入式仅支持没有完整性检查或 CRC32 的流，请确保在编码预期由内核解码的文件时不要使用其他类型的完整性检查。使用 liblzma 时，需要使用 LZMA_CHECK_NONE 或 LZMA_CHECK_CRC32 进行编码。使用 xz 命令行工具时，使用 --check=none 或 --check=crc32。
强烈建议使用 CRC32，除非有其他层会验证未压缩数据的完整性。重复进行完整性检查可能会浪费 CPU 周期。
请注意，头部始终具有 CRC32，该 CRC32 将由解码器验证；您只能更改实际未压缩数据的完整性检查类型（或禁用它）。
在用户空间中，LZMA2 通常使用几兆字节的字典大小。解码器需要将字典存储在 RAM 中，因此对于打算由内核解码的文件不能使用大字典。1 MiB 可能是用于内核中的最大合理的字典大小（对于 initramfs 可能可以更大）。XZ Utils 中的预设在为内核创建文件时可能不是最优的，因此请毫不犹豫地使用自定义设置。示例：

	xz --check=crc32 --lzma2=dict=512KiB inputfile

上述字典大小限制的一个例外情况是在单次调用模式下使用解码器。解压内核本身就是一个这样的例子。在单次调用模式下，内存使用量不依赖于字典大小，因此完全可以使用大的字典：为了获得最佳压缩效果，字典大小应该至少与未压缩数据一样大。

未来计划
=========

如果人们认为有用的话，可以考虑创建一个有限的 XZ 编码器。即使在最快的设置下，LZMA2 的压缩速度也比例如 Deflate 或 LZO 慢，因此尚不清楚是否需要将 LZMA2 编码器加入内核。
计划在解压代码中支持有限的随机访问读取功能。我不知道这对内核是否有用，但我知道在 Linux 内核之外的一些嵌入式项目中它是有用的。

符合 .xz 文件格式规范
========================

有一些特殊情况，为了简化处理而牺牲了尽早检测错误的能力。这些在实践中不应该有任何影响，因为它们不会导致安全问题。但在使用 XZ Utils 的测试文件测试代码时了解这一点是有好处的。

报告错误
==========

在报告错误之前，请先确认它尚未在上游修复。参见 <https://tukaani.org/xz/embedded.html> 获取最新代码。
报告错误请发邮件至 <lasse.collin@tukaani.org>，或者访问 Freenode 上的 #tukaani 频道并与 Larhzu 联系。我不定期阅读 LKML 或其他与内核相关的邮件列表，因此如果有我需要了解的事情，请直接给我发邮件或使用 IRC。

不要就内核中的 XZ 实现或 XZ Utils 向 Igor Pavlov 提问。尽管这两个实现包含了大量直接基于 Igor Pavlov 代码的关键代码，但这些实现并不是由他维护和支持的。
