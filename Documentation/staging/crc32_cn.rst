======================
CRC计算的简要教程
======================

CRC 是一种长除法的余数。您将 CRC 添加到消息中，整个东西（消息 + CRC）将是给定 CRC 多项式的倍数。要检查 CRC，您可以检查 CRC 是否与重新计算的值匹配，或者检查在消息 + CRC 上计算的余数是否为 0。后一种方法被许多硬件实现所采用，这也是为什么许多协议将帧结束标志放在 CRC 后面的原因。实际上，这和你在学校学的长除法是一样的，只是：

- 我们是在二进制下工作，所以数字只有 0 和 1，
- 在多项式除法中，没有进位。我们不是加或减，而是使用异或（XOR）。因此，我们在加法和减法之间的区别上有些马虎。

像所有的除法一样，余数总是小于除数。
为了生成一个 32 位的 CRC，除数实际上是一个 33 位的 CRC 多项式。
由于它是 33 位长，第 32 位始终会被设置，所以通常 CRC 以十六进制表示时会省略最高有效位。（如果你熟悉 IEEE 754 浮点格式，就是同样的道理。）

请注意，CRC 是在一个比特字符串上计算的，因此您需要决定每个字节内的比特的字节序。为了获得最佳的错误检测属性，这应该对应于它们实际发送的顺序。例如，标准 RS-232 串行通信是小端模式；最高有效位（有时用于奇偶校验）最后发送。当将一个 CRC 字附加到消息末尾时，您应该按照正确的顺序进行，与字节序相匹配。
就像普通的除法一样，您一次处理一个数字（位）。
每次除法步骤，您都会取一位（位）的被除数并将其附加到当前余数上。然后您确定适当的除数倍数，以便通过异或将余数恢复到范围内。在二进制中，这是很容易的——它只能是 0 或 1，并且为了使异或取消，它只是余数第 32 位的一个副本。
在计算 CRC 时，我们不关心商，所以我们丢弃商位，但用适当的多项式倍数从余数中减去，我们就回到了起点，准备好处理下一个位。
大端模式的 CRC 可以这样编码：

```c
for (i = 0; i < input_bits; i++) {
    multiple = remainder & 0x80000000 ? CRCPOLY : 0;
    remainder = (remainder << 1 | next_input_bit()) ^ multiple;
}
```

请注意，为了获取移位后的余数的第 32 位，我们需要查看移位前余数的第 31 位。
但同时请注意，我们正在移入余数的 `next_input_bit()` 位实际上在 32 位之后才影响任何决策。因此，这个循环的前 32 次迭代是非常单调的。
此外，为了在消息末尾添加CRC校验码，我们需要预留一个32位的空间，因此我们必须在每条消息的末尾增加32个周期来移入零。这些细节导致了一个常用技巧：将`next_input_bit()`的合并操作推迟到需要的时候再进行。这样，前32个周期可以预先计算，并且为CRC留出空间而合并最后32个零位的操作可以完全省略。这会改变代码如下：

```c
for (i = 0; i < input_bits; i++) {
    remainder ^= next_input_bit() << 31;
    multiple = (remainder & 0x80000000) ? CRCPOLY : 0;
    remainder = (remainder << 1) ^ multiple;
}
```

通过这种优化，小端模式下的代码特别简单：

```c
for (i = 0; i < input_bits; i++) {
    remainder ^= next_input_bit();
    multiple = (remainder & 1) ? CRCPOLY : 0;
    remainder = (remainder >> 1) ^ multiple;
}
```

余数多项式的最高系数存储在二进制“remainder”变量的最低有效位中。其他字节序的细节隐藏在CRCPOLY（必须进行位反转）和next_input_bit()中。只要next_input_bit以合理的方式返回位，我们不必等到最后一刻才合并额外的位。我们可以一次处理8位而不是1位：

```c
for (i = 0; i < input_bytes; i++) {
    remainder ^= next_input_byte() << 24;
    for (j = 0; j < 8; j++) {
        multiple = (remainder & 0x80000000) ? CRCPOLY : 0;
        remainder = (remainder << 1) ^ multiple;
    }
}
```

或者在小端模式下：

```c
for (i = 0; i < input_bytes; i++) {
    remainder ^= next_input_byte();
    for (j = 0; j < 8; j++) {
        multiple = (remainder & 1) ? CRCPOLY : 0;
        remainder = (remainder >> 1) ^ multiple;
    }
}
```

如果输入是32位的倍数，你甚至可以一次XOR一个32位的字，并将内循环计数增加到32。你也可以混合使用两种循环风格，例如对大部分消息按字节处理，并在结尾处按位处理任何剩余字节。

为了减少条件分支的数量，软件通常使用Dilip V. Sarwate推广的按字节查找表方法，“Computation of Cyclic Redundancy Checks via Table Look-Up”，Comm. ACM v.31 no.8（1998年8月）p. 1008-1013。这里，我们不是仅仅移位一位来决定正确的减法倍数，而是可以一次移位一个字节。这会产生一个40位（而不是33位）的中间余数，要减去的多项式的正确倍数是通过一个由高8位索引的256项查找表找到的。（表项仅仅是给定的一字节消息的CRC-32值。）

当空间更受限时，可以使用较小的表，例如两次4位移位后在一个16项的表中查找。
使用这种方法每次处理超过8位是不实际的，因为超过256条目的表格会占用太多内存，更重要的是，会占用太多的一级缓存（L1 cache）。

为了获得更高的软件性能，可以使用一种“切片”技术。参见《使用Intel的Slicing-by-8算法生成高性能CRC》（High Octane CRC Generation with the Intel Slicing-by-8 Algorithm），下载地址为：ftp://download.intel.com/technology/comms/perfnet/download/slicing-by-8.pdf

这种技术不会改变表查找的数量，但会增加并行性。在经典的Sarwate算法中，必须在一个表查找完成之后才能计算下一个索引。“切片2”的技术会以16位为单位移动余数，产生一个48位的中间余数。而不是在一个包含65536个条目的表中进行单次查找，而是将高两位字节分别在两个不同的256条目表中查找。每个表包含用于取消相应字节所需的余数。这些表是不同的，因为需要取消的多项式不同。一个多项式的非零系数从x^32到x^39，而另一个从x^40到x^47。

由于现代处理器可以处理许多并行的内存操作，这几乎只需要一次表查找的时间，因此其性能几乎是基本Sarwate算法的两倍。这种技术可以扩展到“切片4”，使用4个256条目的表。每一步，获取32位数据，并与CRC进行异或运算，然后将结果拆分成字节并在表中查找。由于32位移位使得中间余数的低位为零，最终的CRC仅仅是4次表查找的结果的异或。

但这仍然强制顺序执行：只有在前一组的4次表查找全部完成后，下一组表查找才能开始。因此，处理器的加载/存储单元有时会处于空闲状态。为了充分利用处理器，“切片8”技术可以并行执行8次查找。每一步，32位CRC向左移64位并与64位输入数据进行异或运算。重要的是要注意，在这8个字节中有4个字节只是输入数据的副本；它们根本不依赖于之前的CRC。因此，这4次表查找可以立即开始，无需等待前一个循环迭代。

通过始终保持4次加载操作同时进行，现代超流水线处理器可以保持忙碌状态，并充分利用其一级缓存。
关于现实世界中CRC实现的两个更多细节：

通常，向已经是某个多项式倍数的消息末尾添加零比特会产生一个更大的该多项式的倍数。因此，基本的CRC无法检测到附加的零比特（或字节）。为了让CRC能够检测这种情况，通常会在附加CRC之前对其进行反转。这使得消息+CRC的余数不是零，而是某个固定的非零值。（反转模式的CRC，即0xffffffff。）

同样的问题也适用于在消息前面添加零比特，解决方法类似。CRC计算不是从余数为0开始，而是使用全一的初始余数。只要在解码时同样开始，这不会产生影响。
