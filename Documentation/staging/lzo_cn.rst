============================================
LZO流格式，如Linux的LZO解压缩器所理解的
============================================

介绍
============

  这不是一个规范。LZO流格式似乎没有公开可用的规范。本文档描述了在Linux内核中实现的LZO解压缩器所理解的输入格式。本文档分析的对象是lib/lzo/lzo1x_decompress_safe.c文件。虽然未对压缩器或其他实现进行分析，但格式可能与标准格式一致。本文档的目的是更好地理解代码的工作方式，以便为未来的错误报告提出更有效的修复方案。

描述
============

  流由一系列指令、操作数和数据组成。指令由表示操作码的几个比特位和形成该指令操作数的比特位组成，操作数的大小和位置取决于操作码以及前一条指令复制的字节数。操作数用于指示：

    - 从字典（之前的输出缓冲区）复制数据的距离
    - 长度（从字典复制的字节数）
    - 要复制的字节数，该信息保存在变量“state”中，作为下一条指令的信息

根据操作码和操作数的不同，可能会有额外的数据跟随。这些额外数据可以是对操作数的补充（例如：更大值编码的长度或距离），或者是一个要复制到输出缓冲区的字面量。
块的第一个字节遵循与其他字节不同的编码，它似乎仅针对字面量进行了优化，因为在该字节之前还没有字典。
长度总是以可变长度编码开始，起始位数较少。如果位数不足以表示长度，则可以通过消耗更多字节最多每次增加255来累加，直到达到最大值（因此压缩比不能超过约255:1）。使用#bits进行的可变长度编码始终相同：

       `length = byte & ((1 << #bits) - 1)`
       如果`!length`：
               `length = ((1 << #bits) - 1)`
               `length += 255 * (零字节数)`
               `length += 第一个非零字节`
       `length += 常数（通常是2或3）`

对于字典引用，距离相对于输出指针。距离使用属于特定范围的少量位编码，导致多个复制指令使用不同的编码。
某些编码涉及一个额外的字节，其他编码涉及两个额外的字节形成小端序的16位数量（下面标记为LE16）。
除了大字面量复制外，在任何指令之后，会先复制0、1、2或3个字面量再开始下一条指令。复制的字面量数量可能会改变下一条指令的意义和行为。实际上，只有当复制0、少于4或更多字面量时，才需要一条指令知道这一点。此信息存储在此实现中的<state>变量中。要立即复制的字面量数量通常编码在指令的最后两位，但也可能取自一个额外操作数（例如：距离）的最后两位。
当看到距离为0的块复制时，流结束。只有一个指令可以编码这个距离（0001HLLL），它需要一个LE16操作数表示距离，因此需要3个字节。
.. 重要::

     在代码中，由于某些指令是在假设一定数量的字节将跟随的情况下调用的，因此缺少一些长度检查，因为解析指令之前已经保证了这一点。
它们只需在消耗额外字节时“补充”这种信用。这是一种与算法或编码无关的实现设计选择。
版本

0：原始版本  
1：LZO-RLE

LZO版本1实现了一个扩展，使用游程长度编码（RLE）来编码零值的序列。这对于包含大量零值的数据提高了压缩速度，这是zram中常见的情况。这以向后兼容的方式修改了位流（版本1可以正确解压版本0压缩的数据，但版本0无法读取版本1的数据）。为了最大程度地保证兼容性，两个版本分别以不同的名称提供（lzo和lzo-rle）。本文档中的编码差异会通过例如“版本1仅适用”的方式标注。

字节序列
========

第一个字节编码如下：

```
0..16   ：遵循常规指令编码，详见下文。值得注意的是代码16表示从一个空字典中复制块，在这里总是无效的。
17      ：位流版本。如果第一个字节是17，并且压缩流长度至少为5字节（最短可能的带版本号的位流长度），下一个字节将给出位流版本。（版本1仅适用）
否则，位流版本为0。
18..21  ：复制0..3个字面值
          状态 = （字节 - 17）= 0..3  [ 复制<状态>个字面值 ]
          跳过字节

22..255 ：复制字面字符串
          长度 = （字节 - 17）= 4..238
          状态 = 4 [ 不复制额外的字面值 ]
          跳过字节
```

指令编码如下：

```
0 0 0 0 X X X X  (0..15)
  取决于上一条指令复制的字面值数量
如果上一条指令没有复制任何字面值（状态 == 0），此编码将是复制4个或更多字面值，必须这样解释：

     0 0 0 0 L L L L  (0..15)  ：复制长字面字符串
     长度 = 3 + (L ?: 15 + (零字节数 * 255) + 非零字节)
     状态 = 4  （不复制额外的字面值）

如果上一条指令用于复制1到3个字面值（在指令的操作码或距离中编码），该指令是从字典中复制一个2字节的块，距离不超过1KB。需要注意的是这条指令节省的空间很少，因为它用了2字节来编码另外2个字节，但它免费编码了后续字面值的数量。必须这样解释：

     0 0 0 0 D D S S  (0..15)  ：从<=1KB距离处复制2个字节
     长度 = 2
     状态 = S （在此块之后复制S个字面值）
总是紧接着一个字节：H H H H H H H H
     距离 = (H << 2) + D + 1

如果上一条指令用于复制4个或更多字面值（通过状态 == 4 检测），该指令变成从2..3KB距离处复制一个3字节的块，必须这样解释：

     0 0 0 0 D D S S  (0..15)  ：从2..3KB距离处复制3个字节
     长度 = 3
     状态 = S （在此块之后复制S个字面值）
总是紧接着一个字节：H H H H H H H H
     距离 = (H << 2) + D + 2049

0 0 0 1 H L L L  (16..31)
  从16..48KB距离内复制块（最好少于10字节）
  长度 = 2 + (L ?: 7 + (零字节数 * 255) + 非零字节)
总是紧接着一个LE16：D D D D D D D D : D D D D D D S S
  距离 = 16384 + (H << 14) + D
  状态 = S （在此块之后复制S个字面值）
  如果距离 == 16384，则到达流的末尾
  在版本1中，为了避免与RLE情况的歧义，当((距离 & 0x803f) == 0x803f) && (261 <= 长度 <= 264)，压缩器不应发出满足这些条件的块复制
在版本1中，此指令还用于当距离 = 0xbfff 时编码零值序列，即 H = 1 且 D 位全为1
在这种情况下，它后面跟着第四个字节 X
游程长度 = ((X << 3) | (0 0 0 0 0 L L L)) + 4

0 0 1 L L L L L  (32..63)
  从16KB距离内复制小块（最好少于34字节）
  长度 = 2 + (L ?: 31 + (零字节数 * 255) + 非零字节)
总是紧接着一个LE16：D D D D D D D D : D D D D D D S S
  距离 = D + 1
  状态 = S （在此块之后复制S个字面值）

0 1 L D D D S S  (64..127)
  从2KB距离内复制3-4字节的块
  状态 = S （在此块之后复制S个字面值）
  长度 = 3 + L
总是紧接着一个字节：H H H H H H H H
  距离 = (H << 3) + D + 1

1 L L D D D S S  (128..255)
  从2KB距离内复制5-8字节的块
  状态 = S （在此块之后复制S个字面值）
  长度 = 5 + L
总是紧接着一个字节：H H H H H H H H
  距离 = (H << 3) + D + 1
```

作者
=====

本文档由Willy Tarreau（w@1wt.eu）于2014年7月19日在分析Linux 3.16-rc5中可用的解压缩代码时编写，并由Dave Rodgman（dave.rodgman@arm.com）于2018年10月30日更新，引入了游程长度编码。代码较为复杂，因此可能存在错误或忽略了一些边缘情况。无论如何，请将任何疑问、修正或建议更新报告给作者以便更新文档。
当然，请提供你需要翻译的文本。
