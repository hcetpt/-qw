== Linux 内核 SPI 支持概述 ==

2012 年 2 月 2 日

什么是 SPI？
-----------------
“串行外设接口”（SPI）是一种同步的四线串行连接，用于将微控制器连接到传感器、存储器和外围设备。
它是一个简单的“事实上的”标准，并不复杂到需要标准化机构的认可。SPI 使用主机/目标配置，
三根信号线分别承载时钟（SCK，通常为约 10 MHz）以及带有“主出、从入”（MOSI）或“主入、从出”（MISO）信号的并行数据线。（也有其他名称被使用。）
存在四种时钟模式以交换数据；模式 0 和模式 3 最常用。每个时钟周期都会移出和移入数据；除非有数据位要移位，否则时钟不会循环。
然而，并非所有数据位都被使用；并非每个协议都利用这些全双工能力。
SPI 主机使用第四条“芯片选择”线来激活特定的 SPI 目标设备，因此这三条信号线可以并行连接到多个芯片。
所有 SPI 目标都支持芯片选择；它们通常是低电平有效的信号，标记为 nCSx（例如 nCS0），针对目标 'x'。一些设备还有其他信号，通常包括向主机发送中断的信号。
与 USB 或 SMBus 等串行总线不同，即使对于 SPI 目标的低级协议，通常也无法在供应商之间实现互操作性（除了像 SPI 存储器芯片这样的通用产品）。
- SPI 可能被用于请求/响应类型的设备协议中，如触摸屏传感器和存储器芯片。
- 它也可以用来单向流式传输数据（半双工），或者同时双向传输（全双工）。
- 某些设备可能使用八位字。其他设备可能使用不同的字长，例如 12 位或 20 位数字样本的流。
- 字通常首先发送其最高有效位（MSB），但有时最低有效位（LSB）会先被发送。
- 有时 SPI 会被用来串联设备，例如移位寄存器。
同样地，SPI目标设备很少支持任何形式的自动发现/枚举协议。从给定的SPI主机控制器可访问的目标设备树通常需要手动设置，使用配置表。

SPI只是这种四线协议的一个名称，大多数控制器处理“MicroWire”（可以将其视为用于请求/响应协议的半双工SPI）、SSP（“同步串行协议”）、PSP（“可编程串行协议”）以及其他相关协议都没有问题。

有些芯片通过合并MOSI和MISO信号线来减少一条线，并在硬件级别上限制自己为半双工。实际上，有些SPI芯片具有这种信号模式作为绑定选项。这些芯片可以使用与SPI相同的编程接口进行访问，但当然它们无法处理全双工传输。您可能会发现这类芯片被描述为使用“三线”信号：SCK、数据、nCSx（该数据线有时被称为MOMI或SISO）。

微控制器经常同时支持SPI协议的主机端和目标端。本文档（以及Linux）也支持SPI交互的主机端和目标端。

谁在使用它？在什么类型的系统上？
---------------------------------------
使用SPI的Linux开发者可能正在为嵌入式系统板编写设备驱动程序。SPI用于控制外部芯片，也是每个MMC或SD存储卡所支持的协议。（更早的“DataFlash”卡，在MMC卡之前出现，但使用相同的连接器和卡片形状，仅支持SPI。）一些PC硬件使用SPI闪存来存储BIOS代码。

SPI目标芯片范围广泛，从用于模拟传感器和编解码器的数模转换器到内存，再到像USB控制器或以太网适配器这样的外围设备等。
大多数使用SPI的系统会在主板上集成几个设备。
有些提供SPI链接在扩展连接器上；在没有专用SPI控制器的情况下，可以使用GPIO引脚创建一个低速的“位敲打”适配器。很少有系统会“热插拔”SPI控制器；选择SPI的原因集中在低成本和简单操作上，如果动态重新配置很重要，那么USB通常会是更适合的低引脚数量的外设总线。

许多能够运行Linux的微控制器集成了一个或多个具有SPI模式的I/O接口。有了SPI支持，它们就可以在不需要专门的MMC/SD/SDIO控制器的情况下使用MMC或SD卡。

我感到困惑。这四种SPI“时钟模式”是什么？
-----------------------------------------------------
在这里很容易感到困惑，而您找到的供应商文档并不一定有帮助。这四种模式结合了两个模式位：

- CPOL指示初始时钟极性。CPOL=0意味着时钟开始于低电平，因此第一个（前导）边沿是上升沿，第二个（尾随）边沿是下降沿。CPOL=1意味着时钟开始于高电平，因此第一个（前导）边沿是下降沿。
CPHA 指示用于采样数据的时钟相位；CPHA=0 表示在前沿采样，而 CPHA=1 表示在后沿采样。
由于信号需要在采样前稳定下来，因此当 CPHA=0 时，意味着其数据需在第一个时钟边沿前半个时钟周期写入。芯片选择信号可能使其变得可用。
芯片规格书不一定明确指出“使用 SPI 模式 X”，但它们的定时图会清楚地展示 CPOL 和 CPHA 模式。
在 SPI 模式的编号中，CPOL 是最高位，CPHA 是最低位。因此，如果一个芯片的定时图显示时钟起始为低电平（CPOL=0），并且数据在时钟后沿稳定下来以供采样（CPHA=1），这就是 SPI 模式 1。
请注意，一旦芯片选择信号变为激活状态，时钟模式就变得相关了。因此，主机必须在选择目标之前将时钟设置为非激活状态，而目标可以通过在其选择线变激活时采样时钟电平来确定所选极性。这就是为什么许多设备支持例如模式 0 和 3：它们不关心极性，并且总是在时钟上升沿传输数据。
这些驱动编程接口是如何工作的？
--------------------------------------
`<linux/spi/spi.h>` 头文件包括内核文档注释，主源代码也包括这些注释，你当然应该阅读内核 API 文档的这一章节。这里只是一个概述，以便你在了解详细内容之前对整体情况有所了解。
SPI 请求始终进入 I/O 队列。对于给定的 SPI 设备，请求总是按照先进先出 (FIFO) 的顺序执行，并通过完成回调异步完成。还有一些简单的同步封装函数，包括针对常见事务类型如写入命令然后读取响应的封装。
有两种类型的 SPI 驱动程序，这里称为：

- 控制器驱动程序 ...
控制器可能集成在片上系统 (SoC) 处理器中，并且通常同时支持控制器和目标角色。
这些驱动程序直接操作硬件寄存器，并可能使用 DMA（直接内存访问）。
或者它们可以是 PIO 位操作器，仅需要 GPIO 引脚。
协议驱动程序...
这些驱动程序通过控制器
驱动程序与 SPI 链路另一端的目标或控制器设备进行通信。
例如，一个协议驱动程序可能与 MTD 层进行交互以将数据导出到存储在 SPI 闪存（如 DataFlash）上的文件系统；而其他驱动程序则可能控制音频接口、将触摸屏传感器作为输入接口呈现，或是在工业处理过程中监控温度和电压水平。
这些功能可能都共享同一个控制器驱动程序。
一个 "struct spi_device" 封装了这两种类型驱动程序之间的控制器侧接口。
SPI 编程接口有一个最小的核心，专注于使用驱动模型来通过由板载特定初始化代码提供的设备表连接控制器和协议驱动程序。SPI 在 sysfs 中出现在多个位置：

   /sys/devices/.../CTLR ... 给定 SPI 控制器的物理节点

   /sys/devices/.../CTLR/spiB.C ... spi_device 在总线 "B" 上，
芯片选择 C，通过 CTLR 访问
/sys/bus/spi/devices/spiB.C ... 符号链接到那个物理
.../CTLR/spiB.C 设备

   /sys/devices/.../CTLR/spiB.C/modalias ... 标识应该用于此设备的驱动程序
（用于热插拔/冷插拔）

   /sys/bus/spi/drivers/D ... 一个或多个 spi*.* 设备的驱动程序

   /sys/class/spi_master/spiB ... 符号链接到一个逻辑节点，该节点可以保存
管理总线 "B" 的 SPI 主控制器相关的类状态
所有 spiB.* 设备共享一个物理 SPI 总线段，具有 SCLK、
MOSI 和 MISO
/sys/devices/.../CTLR/slave ... 用于（注册/注销）
SPI 目标控制器的目标设备的虚拟文件
将 SPI 目标处理器的驱动程序名称写入此文件中会注册目标设备；写入 "(null)" 则会取消注册该目标设备。
从这个文件读取会显示目标设备的名称（若未注册则为 "(null)"）。
`/sys/class/spi_slave/spiB` …… 这是一个指向逻辑节点的符号链接，该节点可以保存 SPI 目标控制器在 "B" 总线上的类相关状态。当已注册时，这里存在一个 `spiB.*` 设备，可能与其它 SPI 目标设备共享物理 SPI 总线段。
目前，唯一的类特定状态是总线编号（"spiB" 中的 "B"），因此那些 `/sys/class` 条目仅用于快速识别总线。

如何通过板载特定初始化代码声明 SPI 设备？
------------------------------------------------------

Linux 需要几种不同类型的信息来正确配置 SPI 设备。这些信息通常由板载特定代码提供，即使对于支持部分自动发现/枚举功能的芯片也不例外。

声明控制器
^^^^^^^^^^^^^^^^^^^

首先需要的信息是一份存在的 SPI 控制器列表。对于基于系统级芯片 (SOC) 的板卡来说，这些通常是平台设备，并且控制器可能需要一些平台数据才能正常运行。`struct platform_device` 将包含如控制器第一个寄存器的物理地址和中断请求 (IRQ) 等资源。
平台往往会抽象化“注册 SPI 控制器”的操作，有时会与初始化引脚配置的代码相结合，以便于多个板卡的 `arch/.../mach-*/board-*.c` 文件都能共享相同的控制器设置代码。这是由于大多数 SOC 芯片有多个 SPI 控制器能力，而通常只有在特定板卡上实际可用的控制器才会被设置并注册。
例如，`arch/.../mach-*/board-*.c` 文件中可能会有类似以下的代码：

```c
#include <mach/spi.h> /* 为了获取 mysoc_spi_data */

/* 如果你的 mach-* 架构不支持可以在多种板卡上运行的内核，则 pdata 不会从 "__init" 中受益 */
```
请注意，最后一句的例子代码片段似乎缺少了实际的代码内容，但其意图在于说明如何包含特定架构的 SPI 数据。
下面是给定代码段的中文翻译：

```plaintext
// 静态结构体 mysoc_spi_data 类型的数据 pdata，用于初始化数据
static struct mysoc_spi_data pdata __initdata = { ... };

// 静态初始化函数
static __init board_init(void)
{
    ...
    // 该板只使用 SPI 控制器 #2
    mysoc_register_spi(2, &pdata);
    ...
}

SOC 特定的实用代码可能如下所示：

#include <mach/spi.h>

// 定义 SPI 控制器设备 spi2
static struct platform_device spi2 = { ... };

void mysoc_register_spi(unsigned n, struct mysoc_spi_data *pdata)
{
    struct mysoc_spi_data *pdata2;

    // 分配内存
    pdata2 = kmalloc(sizeof *pdata2, GFP_KERNEL);
    *pdata2 = *pdata;
    ...
    if (n == 2) {
        // 将平台数据设置为 pdata2
        spi2->dev.platform_data = pdata2;
        // 注册平台设备
        register_platform_device(&spi2);

        // 设置引脚模式，以便 SPI2 信号可以在相关引脚上可见。
        // 生产板上的引导加载程序可能已经完成了这项工作，
        // 但在开发板上通常需要 Linux 来完成。
    }
    ...
}

请注意，即使使用相同的 SOC 控制器，不同板子的 platform_data 也可能不同。例如，在一个板子上 SPI 可能使用外部时钟，而另一个板子则从某个主时钟的当前设置派生 SPI 时钟。

声明目标设备
^^^^^^^^^^^^^^^^^^^^^^

第二种类型的信息是一个列表，它列出了目标板上存在的 SPI 目标设备，通常还包括驱动程序正确工作的板特定数据。
通常情况下，你的 arch/.../mach-*/board-*.c 文件会提供一个小表来列出每块板上的 SPI 设备。（这通常只有少数几个。）例如：

static struct ads7846_platform_data ads_info = {
    .vref_delay_usecs     = 100,
    .x_plate_ohms         = 580,
    .y_plate_ohms         = 410,
};

static struct spi_board_info spi_board_info[] __initdata = {
    {
        .modalias         = "ads7846",
        .platform_data    = &ads_info,
        .mode             = SPI_MODE_0,
        .irq              = GPIO_IRQ(31),
        .max_speed_hz     = 120000 /* 最大采样率在 3V 下 */ * 16,
        .bus_num          = 1,
        .chip_select      = 0,
    },
};

再次注意，提供了板特定信息；每个芯片可能需要几种类型的信息。这个示例展示了通用约束（如允许的最快 SPI 时钟，此处与板电压有关），或者 IRQ 引脚如何连线，以及芯片特定约束（如由一个引脚处的电容改变的重要延迟）等。

此外还有“controller_data”，这是对控制器驱动程序有用的信息。一个例子是外围设备特定的 DMA 调优数据或芯片选择回调。这些存储在 spi_device 中。

board_info 应该提供足够的信息，使得系统能够在芯片的驱动程序未加载的情况下工作。其中最麻烦的部分可能是 spi_device.mode 字段中的 SPI_CS_HIGH 位，因为与解释芯片选择“相反”的设备共享总线是不可能的，直到基础设施知道如何取消选择它。

然后你的板初始化代码将该表注册到 SPI 基础设施中，以便在 SPI 主控制器驱动程序注册后可用：

spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));

与其他静态板特定设置一样，你不会注销这些。
```
广泛使用的“卡片”式计算机将内存、CPU及极少其他组件集成到一块可能只有大约30平方厘米大小的卡片上。在这样的系统中，你的`arch/.../mach-.../board-*.c`文件主要会提供关于插入此类卡片的主板上的设备信息。这当然包括通过卡片连接器连接的SPI设备！

### 非静态配置
^^^^^^^^^^^^^^^^^^^^^^^^^

当Linux通过SPI支持MMC/SD/SDIO/DataFlash卡时，这些配置也将是动态的。幸运的是，这些设备都支持基本的设备识别探测，因此它们应该能够正常热插拔。

### 如何编写一个“SPI协议驱动”？
----------------------------------------

大多数SPI驱动目前都是内核驱动，但也支持用户空间驱动。这里只讨论内核驱动。
SPI协议驱动有点类似于平台设备驱动：
```c
static struct spi_driver CHIP_driver = {
	.driver = {
		.name		= "CHIP",
		.pm		= &CHIP_pm_ops,
	},
	.probe		= CHIP_probe,
	.remove		= CHIP_remove,
};
```

驱动核心将自动尝试将此驱动绑定到任何其`board_info`提供了`modalias`为"CHIP"的SPI设备。你的`probe()`函数可能看起来像这样，除非你正在创建一个管理总线（出现在`/sys/class/spi_master`下）的设备：
```c
static int CHIP_probe(struct spi_device *spi)
{
	struct CHIP			*chip;
	struct CHIP_platform_data	*pdata;

	/* 假设驱动需要特定于板卡的数据： */
	pdata = &spi->dev.platform_data;
	if (!pdata)
		return -ENODEV;

	/* 为驱动程序的每个芯片状态分配内存 */
	chip = kzalloc(sizeof *chip, GFP_KERNEL);
	if (!chip)
		return -ENOMEM;
	spi_set_drvdata(spi, chip);

	... etc
	return 0;
}
```

一旦进入`probe()`函数，驱动程序就可以使用`struct spi_message`向SPI设备发出I/O请求。当`remove()`返回后，或者`probe()`失败后，驱动程序保证不再提交这样的消息。

- `spi_message`是一系列协议操作的序列，作为一个原子序列执行。SPI驱动控制包括：

  + 双向读写何时开始……由其`spi_transfer`请求序列的排列方式决定；

  + 使用哪些I/O缓冲区……每个`spi_transfer`封装了每个传输方向的缓冲区，支持全双工（两个指针，可能相同）和半双工（一个指针为NULL）传输；

  + 可选地定义传输后的短暂延迟……使用`spi_transfer.delay.value`设置（如果缓冲区长度为零，则该延迟可能是唯一的协议效果）；默认情况下，`spi_transfer.delay.unit`单位是微秒，但如果需要，可以调整为时钟周期或纳秒；

  + 芯片选择是否在传输和任何延迟后变为非活动状态……通过使用`spi_transfer.cs_change`标志；

  + 暗示下一个消息很可能发往同一设备……通过在该原子组中的最后一个传输上使用`spi_transfer.cs_change`标志，并潜在节省芯片去选择和选择操作的成本。

- 遵循标准内核规则，在消息中提供DMA安全的缓冲区。这样，使用DMA的控制器驱动程序就不必被迫进行额外的复制，除非硬件要求这样做（例如，绕过强制使用弹跳缓冲的硬件错误）。

- 基本的I/O原语是`spi_async()`。异步请求可以在任何上下文中发出（中断处理程序、任务等），并且完成情况通过与消息一起提供的回调报告。在检测到任何错误后，芯片被取消选择，并且终止处理该`spi_message`。

- 还有同步包装器如`spi_sync()`，以及`spi_read()`、`spi_write()`和`spi_write_then_read()`等包装器。这些只能在可以睡眠的上下文中发出，并且它们都是对`spi_async()`的干净（且小、“可选”）层。
`spi_write_then_read()` 调用及其便捷封装仅应用于数据量较小的情况，其中额外的复制成本可以忽略。它设计用于支持常见的RPC风格请求，例如写入一个8位命令并读取一个16位响应——`spi_w8r16()`就是其中一个封装，正好实现了这一功能。
一些驱动可能需要修改 `spi_device` 的特性，如传输模式、字长或时钟速率。这可以通过 `spi_setup()` 来完成，通常会在设备首次I/O操作前，在 `probe()` 中调用。然而，只要没有消息待处理，也可以在任何时候调用该函数。
虽然 `spi_device` 可被视为驱动程序的底层边界，但上层边界可能包括 sysfs（特别是对于传感器读数）、输入层、ALSA、网络、MTD、字符设备框架或其他Linux子系统。
需要注意的是，作为与SPI设备交互的一部分，您的驱动程序必须管理两种类型的内存：
- I/O 缓冲区遵循常规的Linux规则，并且必须是DMA安全的。
您通常会从堆或空闲页面池中分配这些缓冲区。
不要使用栈空间或声明为 "static" 的任何内容。
- 用于将这些I/O缓冲区绑定到一组协议事务中的 `spi_message` 和 `spi_transfer` 元数据。这些可以在任何方便的地方分配，包括作为其他一次性分配的驱动数据结构的一部分。初始化为零。
如果您愿意，可以使用 `spi_message_alloc()` 和 `spi_message_free()` 这些便捷函数来分配并零初始化一个带有多个传输操作的 `spi_message`。

如何编写“SPI控制器驱动”？
--------------------------------------
SPI控制器很可能注册在平台总线上；无论涉及哪个总线，都需要编写一个驱动程序来绑定到该设备。
这种类型的驱动程序的主要任务是提供一个“spi_controller”。
使用spi_alloc_host()来分配主机控制器，并使用
spi_controller_get_devdata()来获取为该设备分配的驱动私有数据：
```c
struct spi_controller	*ctlr;
struct CONTROLLER	*c;

ctlr = spi_alloc_host(dev, sizeof *c);
if (!ctlr)
	return -ENODEV;

c = spi_controller_get_devdata(ctlr);
```

驱动程序将初始化spi_controller中的字段，包括总线编号（可能与平台设备ID相同）和三种用于与SPI核心及SPI协议驱动交互的方法。它还将初始化其自身的内部状态。（关于总线编号和这些方法的详细信息请参见下文。）

初始化spi_controller后，使用spi_register_controller()将其发布到系统的其余部分。此时，将为控制器及其预声明的SPI设备创建设备节点，驱动模型核心会负责将它们绑定到驱动上。
如果你需要移除你的SPI控制器驱动，spi_unregister_controller()将会撤销spi_register_controller()的效果。
总线编号
^^^^^^^^^^^^^

总线编号非常重要，因为这是Linux识别特定SPI总线（共享SCK、MOSI、MISO）的方式。有效的总线编号从零开始。在片上系统(SoC)中，总线编号应与芯片制造商定义的编号相匹配。例如，硬件控制器SPI2的总线编号将是2，连接到它的spi_board_info中的设备将使用这个编号。
如果没有这样的硬件分配的总线编号，或者出于某种原因你无法直接分配它们，则可以提供一个负数的总线编号。这之后会被动态分配的编号所替换。那么你需要将其视为非静态配置（请参见上文）。
SPI 主机控制器方法
^^^^^^^^^^^^^^^^^^^^^^^^^^^

`ctlr->setup(struct spi_device *spi)`
- 这个方法设置设备时钟速率、SPI模式和字大小
驱动程序可能会改变board_info提供的默认值，然后调用spi_setup(spi)来调用此例程。它可能会休眠
除非每个SPI目标都有自己的配置寄存器，否则不要立即更改它们……否则驱动程序可能会破坏其他SPI设备正在进行的I/O操作
.. note::
	注意：对于某些原因，许多spi_controller驱动程序的第一个版本似乎在这个问题上出错
当你编写`setup()`函数时，请假设控制器正在为另一个设备处理传输。

``ctlr->cleanup(struct spi_device *spi)``  
你的控制器驱动程序可以使用`spi_device.controller_state`来保存与该设备动态关联的状态。如果你这样做，请确保提供`cleanup()`方法以释放该状态。

``ctlr->prepare_transfer_hardware(struct spi_controller *ctlr)``  
这将由队列机制调用，以通知驱动程序即将有一个消息到来，因此子系统要求驱动程序通过发出此调用来准备传输硬件。
此操作可能会睡眠。

``ctlr->unprepare_transfer_hardware(struct spi_controller *ctlr)``  
这将由队列机制调用，以通知驱动程序队列中没有更多待处理的消息，并且它可以放松硬件（例如，通过电源管理调用）。此操作可能会睡眠。

``ctlr->transfer_one_message(struct spi_controller *ctlr, struct spi_message *mesg)``  
子系统调用驱动程序以传输单一消息，同时排队在此期间到达的传输。当驱动程序完成这个消息后，它必须调用`spi_finalize_current_message()`，以便子系统可以发出下一个消息。
此操作可能会睡眠。

``ctrl->transfer_one(struct spi_controller *ctlr, struct spi_device *spi, struct spi_transfer *transfer)``  
子系统调用驱动程序以传输单一传输，同时排队在此期间到达的传输。当驱动程序完成这个传输后，它必须调用`spi_finalize_current_transfer()`，以便子系统可以发出下一个传输。
此操作可能会睡眠。注意：`transfer_one`和`transfer_one_message`是互斥的；如果两者都设置，则通用子系统不会调用你的`transfer_one`回调函数。

返回值：

    * 负数errno: 错误
    * 0: 传输已完成
    * 1: 传输仍在进行中

``ctrl->set_cs_timing(struct spi_device *spi, u8 setup_clk_cycles, u8 hold_clk_cycles, u8 inactive_clk_cycles)``  
此方法允许SPI客户端驱动程序请求SPI主机控制器配置特定于设备的CS设置、保持和非活动定时需求。

废弃的方法
^^^^^^^^^^^^^^^^^^

``ctrl->transfer(struct spi_device *spi, struct spi_message *message)``  
此方法不得睡眠。它的职责是安排传输发生并发出其complete()回调。这两者通常会在其他传输完成后发生，并且如果控制器处于空闲状态，则需要被启动。在队列控制器上不使用此方法，并且如果实现了`transfer_one_message()`和(un)prepare_transfer_hardware()，则必须为NULL。

SPI 消息队列
^^^^^^^^^^^^^^^^^

如果你对SPI子系统提供的标准队列机制感到满意，只需实现上述队列方法即可。使用消息队列的优点在于集中了大量的代码，并提供了纯进程上下文中的方法执行。消息队列还可以在高优先级SPI流量上调至实时优先级。
除非选择了SPI子系统中的队列机制，否则驱动程序的大部分工作将是管理由现已废弃的`transfer()`函数填充的I/O队列。
这个队列可能是纯粹概念上的。例如，仅用于低频传感器访问的驱动程序可能适合使用同步PIO（程序直接输入输出）。
但是，这个队列很可能是非常实际存在的，它会利用`message->queue`、PIO、通常还有DMA（特别是在SPI闪存中存放根文件系统的情况下），以及诸如IRQ处理程序、任务项或工作队列（如keventd）这样的执行上下文。你的驱动程序可以尽可能地复杂，也可以尽可能地简单。
这样的一种`transfer()`方法通常只是将消息添加到一个队列中，然后启动某个异步传输引擎（除非它已经在运行）。

致谢
------
参与Linux-SPI讨论的贡献者包括（按姓氏字母顺序排列）：

- 马克·布朗 (Mark Brown)
- 大卫·布朗内尔 (David Brownell)
- 拉塞尔·金 (Russell King)
- 格兰特·莱利 (Grant Likely)
- 德米特里·佩尔武辛 (Dmitry Pervushin)
- 斯蒂芬·斯特里特 (Stephen Street)
- 马克·安德伍德 (Mark Underwood)
- 安德鲁·维克托 (Andrew Victor)
- 林纳斯·瓦利 (Linus Walleij)
- 维塔利·伍尔 (Vitaly Wool)
