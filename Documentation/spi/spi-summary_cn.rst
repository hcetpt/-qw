== Linux 内核 SPI 支持概述 ==

2012 年 2 月 2 日

什么是 SPI？
-----------------
“串行外设接口”（SPI）是一种同步的四线串行连接，用于将微控制器连接到传感器、存储器和外围设备。
它是一个简单的“事实上的”标准，并未复杂到需要标准化机构的认可。SPI 使用主机/目标配置，
三根信号线分别承载时钟（SCK，通常为约 10 MHz）以及带有“主出、从入”（MOSI）或“主入、从出”（MISO）信号的并行数据线。（也有其他名称被使用。）
存在四种时钟模式以交换数据；模式 0 和模式 3 最常用。每个时钟周期都会移出和移入数据；除非有数据位要移位，否则时钟不会循环。
然而，并非所有数据位都被使用；并非每个协议都利用这些全双工能力。
SPI 主机使用第四条“芯片选择”线来激活特定的 SPI 目标设备，因此这三条信号线可以并行地连接到多个芯片上。
所有 SPI 目标都支持芯片选择；它们通常是低电平有效的信号，标记为 nCSx 对于目标 'x'（例如 nCS0）。一些设备还有其他信号，通常包括向主机发出的中断信号。
与 USB 或 SMBus 等串行总线不同，即使对于 SPI 目标的低级协议，也通常不具有供应商间的互操作性（除了像 SPI 存储器芯片这样的通用组件）。

- SPI 可能用于请求/响应风格的设备协议，如触摸屏传感器和存储器芯片。
- 它也可以用于半双工方式下双向流式传输数据，或者同时在两个方向上全双工传输数据。
- 有些设备可能使用八位字。其他设备可能会使用不同的字长，例如 12 位或 20 位数字样本的数据流。
- 字通常以最高有效位（MSB）优先的方式发送，但有时最低有效位（LSB）会优先发送。
- 有时 SPI 用于串联设备，如移位寄存器。
同样地，SPI目标设备很少支持任何形式的自动发现/枚举协议。从给定的SPI主机控制器可访问的目标设备树通常需要手动设置，使用配置表。

SPI只是这种四线协议的一个名称，大多数控制器处理“MicroWire”（可以将其视为用于请求/响应协议的半双工SPI）、SSP（“同步串行协议”）、PSP（“可编程串行协议”）以及其他相关协议都没有问题。

有些芯片通过合并MOSI和MISO信号线来减少一条线，并在硬件级别上限制自己为半双工。实际上，某些SPI芯片具有这种信号模式作为配置选项。这些芯片可以使用与SPI相同的编程接口进行访问，但当然它们无法处理全双工传输。您可能会发现这类芯片被描述为使用“三线”信号：SCK、数据、nCSx（这条数据线有时被称为MOMI或SISO）。

微控制器经常同时支持SPI协议的主机端和目标端。本文档（以及Linux）也支持SPI交互的主机端和目标端。

谁在使用它？在什么类型的系统上？
---------------------------------------
使用SPI的Linux开发者可能正在为嵌入式系统板编写设备驱动程序。SPI用于控制外部芯片，也是每个MMC或SD存储卡所支持的协议。（更早的“DataFlash”卡，在MMC卡之前出现，但使用相同的连接器和卡片形状，仅支持SPI。）一些PC硬件使用SPI闪存来存储BIOS代码。

SPI目标芯片范围广泛，从用于模拟传感器和编解码器的数模转换器到内存，再到像USB控制器或以太网适配器这样的外围设备等。
大多数使用SPI的系统会在主板上集成几个设备。
有些提供SPI链接在扩展连接器上；在没有专用SPI控制器的情况下，可以使用GPIO引脚创建一个低速的“位敲打”适配器。很少有系统会“热插拔”SPI控制器；选择SPI的原因集中在低成本和简单操作上，如果动态重新配置很重要，那么USB通常会是更适合的低引脚数量的外设总线。

许多能够运行Linux的微控制器集成了一个或多个具有SPI模式的I/O接口。有了SPI支持，它们就可以在不需要专门的MMC/SD/SDIO控制器的情况下使用MMC或SD卡。

我感到困惑。这四种SPI“时钟模式”是什么？
-----------------------------------------------------
在这里很容易感到困惑，而您找到的供应商文档并不一定有帮助。这四种模式结合了两个模式位：

- CPOL指示初始时钟极性。CPOL=0意味着时钟开始于低电平，因此第一个（前导）边沿是上升沿，第二个（后随）边沿是下降沿。CPOL=1意味着时钟开始于高电平，因此第一个（前导）边沿是下降沿
CPHA 指示用于采样数据的时钟相位；CPHA=0 表示在前沿采样，而 CPHA=1 表示在后沿采样。
由于信号需要在采样前稳定下来，因此当 CPHA=0 时，意味着其数据需在第一个时钟边沿前半个时钟周期写入。芯片选通信号可能已经使其变得可用。
芯片规格不一定明确指出“使用 SPI 模式 X”，但它们的时序图将清楚地展示 CPOL 和 CPHA 模式的设置。
在 SPI 模式的编号中，CPOL 是最高位，而 CPHA 是最低位。因此，如果一个芯片的时序图显示时钟从低电平开始（CPOL=0），且数据在时钟后沿稳定以供采样（CPHA=1），这就是 SPI 模式 1。
请注意，时钟模式一旦芯片选通信号变为活动状态就相关。因此，主机必须在选择目标之前将时钟设为非活动状态，而目标可以通过在其选通线变为活动时采样时钟电平来确定所选的极性。这就是为什么许多设备支持例如模式 0 和 3：它们不关心极性，并且总是在时钟上升沿传输数据。

这些驱动编程接口是如何工作的？
-----------------------------------
`<linux/spi/spi.h>` 头文件包括内核文档注释，主源代码也包含这些注释，你当然应该阅读内核 API 文档中的这一章节。这里只提供一个概览，以便你在深入了解细节之前对整体情况有所了解。
SPI 请求始终进入 I/O 队列。对于特定 SPI 设备的请求总是按先进先出（FIFO）顺序执行，并通过完成回调异步完成。还有一些针对这些调用的简单同步封装，包括为常见的事务类型（如写入命令然后读取其响应）提供的封装。
有两种类型的 SPI 驱动程序，在这里称为：

- 控制器驱动程序...
控制器可能被集成到片上系统（SoC）处理器中，并且通常同时支持控制器和目标角色。
这些驱动程序会直接操作硬件寄存器，并可能使用 DMA（直接内存访问）。
或者它们可以是 PIO 位操作器，仅需要 GPIO 引脚。
协议驱动程序...
这些驱动程序通过控制器
驱动程序与 SPI 链路另一端的目标或控制器设备进行通信。
例如，一个协议驱动程序可能与 MTD 层通信以将数据导出到存储在 SPI 闪存（如 DataFlash）上的文件系统；而其他驱动程序则可能控制音频接口，将触摸屏传感器呈现为输入接口，或是在工业处理过程中监控温度和电压水平。
这些功能可能都共享同一个控制器驱动程序。
一个 `struct spi_device` 封装了这两种类型驱动程序之间的控制器侧接口。
SPI 编程接口有一个最小的核心，主要关注使用驱动模型来通过由板载特定初始化代码提供的设备表连接控制器和协议驱动程序。SPI 在 sysfs 中出现在多个位置：

   `/sys/devices/.../CTLR` ... 某个 SPI 控制器的物理节点

   `/sys/devices/.../CTLR/spiB.C` ... 总线 "B" 上的 spi_device，芯片选择 C，通过 CTLR 访问
   `/sys/bus/spi/devices/spiB.C` ... 符号链接到上述物理
   `.../CTLR/spiB.C` 设备

   `/sys/devices/.../CTLR/spiB.C/modalias` ... 标识应与该设备一起使用的驱动程序（用于热插拔/冷插拔）

   `/sys/bus/spi/drivers/D` ... 一个或多个 spi*.* 设备的驱动程序

   `/sys/class/spi_master/spiB` ... 符号链接到一个逻辑节点，该节点可以保存管理总线 "B" 的 SPI 主控制器的相关状态
所有 spiB.* 设备共享一个物理 SPI 总线段，具有 SCLK、MOSI 和 MISO。
`/sys/devices/.../CTLR/slave` ... 用于（注册/注销） SPI 目标控制器的目标设备的虚拟文件
将 SPI 目标处理器的驱动程序名称写入此文件中会注册目标设备；写入 "(null)" 则会取消注册该目标设备。
从这个文件读取会显示目标设备的名称（若未注册则为 "(null)"）。
`/sys/class/spi_slave/spiB` …… 这是一个符号链接，指向一个逻辑节点，可以保存 SPI 目标控制器在 "B" 总线上的相关类状态。当已注册时，这里存在一个 `spiB.*` 设备，可能与其他 SPI 目标设备共享同一物理 SPI 总线段。
目前，唯一特定于类的状态是总线编号（"spiB" 中的 "B"），因此那些 `/sys/class` 条目仅用于快速识别总线。

特定于板卡的初始化代码如何声明 SPI 设备？
------------------------------------------------------

Linux 需要几种不同类型的信息来正确配置 SPI 设备。这些信息通常由特定于板卡的代码提供，即使对于支持部分自动发现/枚举功能的芯片也是如此。
声明控制器
^^^^^^^^^^^^^^^^^^^

首先需要的信息是一份存在的 SPI 控制器列表。对于基于系统级芯片（SOC）的板卡来说，这些通常是平台设备，并且控制器可能需要一些平台数据以便正确运行。“struct platform_device”将包括资源，例如控制器第一个寄存器的物理地址和它的中断请求（IRQ）。
平台往往会抽象出“注册 SPI 控制器”的操作，有时会与用于初始化引脚配置的代码相结合，这样不同板卡的 `arch/.../mach-*/board-*.c` 文件就可以共享相同的控制器设置代码。这是因为在大多数 SOC 上有多个 SPI 能力控制器，而通常只应设置并注册那些实际可用于给定板卡的控制器。
因此，例如 `arch/.../mach-*/board-*.c` 文件可能包含如下代码：

	```c
	#include <mach/spi.h>	/* for mysoc_spi_data */

	/* 如果你的 mach-* 架构不支持可以在多种板卡上运行的内核，则平台数据不会从 "__init" 中受益 */
	```
下面是给定代码段的中文翻译：

```plaintext
// 静态结构体 mysoc_spi_data 类型的数据 pdata，用于初始化数据
static struct mysoc_spi_data pdata __initdata = { ... };

// 静态初始化函数
static __init board_init(void)
{
    ...
    // 该板只使用 SPI 控制器 #2
    mysoc_register_spi(2, &pdata);
    ...
}

SOC 特定的实用代码可能如下所示：

#include <mach/spi.h>

// 定义 SPI 控制器设备 spi2
static struct platform_device spi2 = { ... };

void mysoc_register_spi(unsigned n, struct mysoc_spi_data *pdata)
{
    struct mysoc_spi_data *pdata2;

    // 分配内存
    pdata2 = kmalloc(sizeof *pdata2, GFP_KERNEL);
    *pdata2 = *pdata;
    ...
    if (n == 2) {
        // 设置平台数据为分配好的 pdata2
        spi2->dev.platform_data = pdata2;
        // 注册平台设备
        register_platform_device(&spi2);

        // 同时：设置引脚模式以便 SPI2 信号可以在相关引脚上可见...
        // 生产板上的引导加载程序可能已经完成了这些设置，但开发板通常需要 Linux 来完成
    }
    ...
}

请注意，对于不同的板，即使使用相同的 SOC 控制器，其 platform_data 也可能不同。例如，在一个板上 SPI 可能使用外部时钟，而在另一个板上则从当前某些主时钟的设置中派生出 SPI 时钟。
声明目标设备
^^^^^^^^^^^^^^^^^^^^^^

第二种信息类型是一个列表，列出了目标板上存在的 SPI 目标设备，通常还包括使驱动程序能够正常工作的特定于板的信息。
通常您的 arch/.../mach-*/board-*.c 文件会提供一个小表来列出每个板上的 SPI 设备。（这通常只有少数几个。）这可能如下所示：

static struct ads7846_platform_data ads_info = {
    .vref_delay_usecs      = 100,
    .x_plate_ohms          = 580,
    .y_plate_ohms          = 410,
};

static struct spi_board_info spi_board_info[] __initdata = {
    {
        .modalias        = "ads7846",
        .platform_data   = &ads_info,
        .mode            = SPI_MODE_0,
        .irq             = GPIO_IRQ(31),
        .max_speed_hz    = 120000 /* 最大采样率在 3V 时 */ * 16,
        .bus_num         = 1,
        .chip_select     = 0,
    },
};

再次注意，提供了特定于板的信息；每个芯片可能需要几种类型的信息。这个例子展示了通用约束，如允许的最快 SPI 时钟（在这种情况下取决于板电压）或中断引脚的连线方式，以及芯片特有的约束，如由某个引脚处的电容改变的重要延迟。

board_info 应该提供足够的信息，以使得系统可以在芯片的驱动程序未加载的情况下工作。其中最麻烦的方面可能是 spi_device.mode 字段中的 SPI_CS_HIGH 位，因为与解释芯片选择“反向”的设备共享总线是不可能的，直到基础设施知道如何取消选择它。
然后你的板初始化代码将注册该表到 SPI 基础设施中，以便稍后当 SPI 主控制器驱动程序被注册时可用：

spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));

与其他静态的特定于板的设置一样，你不会注销这些设置。
```
```
广泛使用的“卡片”式计算机将内存、CPU及极少其他组件集成到一块可能只有大约30平方厘米大小的卡片上。在这样的系统中，你的`arch/.../mach-.../board-*.c`文件主要会提供关于插入此类卡片的主板上的设备信息。这当然包括通过卡片连接器连接的SPI设备！

### 非静态配置
^^^^^^^^^^^^^^^^^^^^^^^^^

当Linux通过SPI支持MMC/SD/SDIO/DataFlash卡时，这些配置也将是动态的。幸运的是，这类设备都支持基本的设备识别探测，因此它们应该能够正常热插拔。

### 如何编写一个“SPI协议驱动”？
----------------------------------------

大多数SPI驱动目前都是内核驱动，但也支持用户空间驱动。这里只讨论内核驱动。
SPI协议驱动有点类似于平台设备驱动：
```c
static struct spi_driver CHIP_driver = {
	.driver = {
		.name		= "CHIP",
		.pm		= &CHIP_pm_ops,
	},
	.probe		= CHIP_probe,
	.remove		= CHIP_remove,
};
```

驱动核心将自动尝试将此驱动绑定到任何其`board_info`提供了`modalias`为"CHIP"的SPI设备。你的`probe()`函数可能看起来像这样，除非你正在创建一个管理总线（出现在`/sys/class/spi_master`下）的设备：
```c
static int CHIP_probe(struct spi_device *spi)
{
	struct CHIP			*chip;
	struct CHIP_platform_data	*pdata;

	/* 假设驱动需要特定于板卡的数据： */
	pdata = &spi->dev.platform_data;
	if (!pdata)
		return -ENODEV;

	/* 为驱动程序的每个芯片状态分配内存 */
	chip = kzalloc(sizeof *chip, GFP_KERNEL);
	if (!chip)
		return -ENOMEM;
	spi_set_drvdata(spi, chip);

	... etc
	return 0;
}
```

一旦进入`probe()`函数，驱动程序就可以使用`struct spi_message`向SPI设备发出I/O请求。当`remove()`返回后，或者`probe()`失败后，驱动程序保证不再提交这样的消息。

- `spi_message`是一系列协议操作的序列，作为一个原子序列执行。SPI驱动控制包括：

  + 双向读写何时开始……由其`spi_transfer`请求序列的排列方式决定；

  + 使用哪些I/O缓冲区……每个`spi_transfer`封装了每个传输方向的缓冲区，支持全双工（两个指针，可能相同）和半双工（一个指针为NULL）传输；

  + 可选地定义传输后的短暂延迟……使用`spi_transfer.delay.value`设置（如果缓冲区长度为零，则该延迟可能是唯一的协议效果）；默认情况下，`spi_transfer.delay.unit`单位是微秒，但如果需要，可以调整为时钟周期或纳秒；

  + 芯片选择是否在传输和任何延迟后变为非活动状态……通过使用`spi_transfer.cs_change`标志；

  + 暗示下一个消息很可能发往同一设备……通过在该原子组中的最后一个传输上使用`spi_transfer.cs_change`标志，并潜在节省芯片去选择和选择操作的成本。

- 遵循标准内核规则，在消息中提供DMA安全的缓冲区。这样，使用DMA的控制器驱动程序就不必被迫进行额外的复制，除非硬件要求这样做（例如，绕过强制使用弹跳缓冲的硬件错误）。

- 基本的I/O原语是`spi_async()`。异步请求可以在任何上下文中发出（中断处理程序、任务等），并且完成情况通过与消息一起提供的回调报告。
在检测到任何错误后，芯片被取消选择，并且终止处理该`spi_message`。

- 还有同步包装器如`spi_sync()`，以及`spi_read()`、`spi_write()`和`spi_write_then_read()`这样的包装器。这些只能在可以睡眠的上下文中发出，它们都是干净的（且小的、“可选的”）`spi_async()`层之上构建的。
`spi_write_then_read()` 调用及其便捷封装仅应用于数据量较小的情况，其中额外的复制成本可以忽略。它设计用于支持常见的RPC风格请求，例如写入一个8位命令并读取一个16位响应——`spi_w8r16()`就是其中一个封装，正好实现了这一功能。
一些驱动可能需要修改 `spi_device` 的特性，如传输模式、字长或时钟速率。这可以通过 `spi_setup()` 来完成，通常会在设备首次I/O操作前，在 `probe()` 中调用。然而，只要没有消息待处理，也可以在任何时候调用该函数。
虽然 `spi_device` 可被视为驱动程序的底层边界，但上层边界可能包括 sysfs（特别是对于传感器读数）、输入层、ALSA、网络、MTD、字符设备框架或其他Linux子系统。
需要注意的是，作为与SPI设备交互的一部分，您的驱动程序必须管理两种类型的内存：
- I/O缓冲区遵循常规的Linux规则，并且必须是DMA安全的。
通常从堆或空闲页面池中分配这些缓冲区。
不要使用栈或任何声明为“静态”的内容。
- 用于将这些I/O缓冲区粘合成一组协议事务的 `spi_message` 和 `spi_transfer` 元数据。这些可以在任何方便的地方分配，包括作为其他一次性分配的驱动程序数据结构的一部分。这些元数据应初始化为零。
如果愿意，可以使用 `spi_message_alloc()` 和 `spi_message_free()` 这些便捷函数来分配并零初始化一个包含多个传输的 `spi_message`。
如何编写“SPI控制器驱动程序”？
---------------------------------------
SPI控制器很可能注册在平台总线上；无论涉及哪个总线，都需要编写一个驱动程序来绑定到该设备。
这种类型驱动程序的主要任务是提供一个“spi_controller”。
使用spi_alloc_host()来分配主机控制器，并使用
spi_controller_get_devdata()来获取为该设备分配的驱动私有数据：
```c
struct spi_controller	*ctlr;
struct CONTROLLER	*c;

ctlr = spi_alloc_host(dev, sizeof *c);
if (!ctlr)
	return -ENODEV;

c = spi_controller_get_devdata(ctlr);
```

驱动程序将初始化spi_controller中的字段，包括总线编号（可能与平台设备ID相同）和三种用于与SPI核心及SPI协议驱动交互的方法。它还将初始化其自身的内部状态。（关于总线编号和这些方法的详细信息请参见下文。）

初始化spi_controller后，使用spi_register_controller()将其发布到系统其余部分。此时，将为控制器及其预声明的SPI设备创建设备节点，驱动模型核心会负责将它们绑定到驱动上。
如果你需要移除你的SPI控制器驱动，spi_unregister_controller()将会撤销spi_register_controller()的效果。
### 总线编号
^^^^^^^^^^^^^

总线编号非常重要，因为它是Linux识别给定SPI总线（共享SCK、MOSI、MISO）的方式。有效的总线编号从0开始。在片上系统(SoC)中，总线编号应该匹配芯片制造商定义的编号。例如，硬件控制器SPI2的总线编号应为2，而连接到它的设备的spi_board_info则会使用这个编号。
如果你没有这样的硬件指定的总线编号，或者由于某种原因无法直接分配，那么可以提供一个负数作为总线编号。这之后会被动态分配的编号所替换。这时你需要将其视为非静态配置（参见上文）。
### SPI 主机控制器方法
^^^^^^^^^^^^^^^^^^^^^^^^^^^

`ctlr->setup(struct spi_device *spi)`
- 这个方法设置设备时钟速率、SPI模式和字长
驱动程序可以改变board_info提供的默认值，然后调用spi_setup(spi)来触发这个函数。这个函数可能会睡眠
除非每个SPI目标都有自己的配置寄存器，否则不要立即改变它们... 否则驱动程序可能会破坏其他SPI设备正在进行的I/O操作
.. note::
    存在BUG：不知为何，许多spi_controller驱动程序的第一个版本似乎在这方面出错
当你编写`setup()`函数时，假设控制器正在为另一个设备处理传输。

``ctlr->cleanup(struct spi_device *spi)``  
你的控制器驱动程序可以使用`spi_device.controller_state`来保存与该设备动态关联的状态。如果你这样做，请确保提供`cleanup()`方法以释放该状态。

``ctlr->prepare_transfer_hardware(struct spi_controller *ctlr)``  
这将由队列机制调用，以通知驱动程序即将有一个消息到来，因此子系统要求驱动程序通过发出此调用来准备传输硬件。
此操作可能会睡眠。

``ctlr->unprepare_transfer_hardware(struct spi_controller *ctlr)``  
这将由队列机制调用，以通知驱动程序队列中没有更多待处理的消息，并且它可以放松硬件（例如，通过电源管理调用）。此操作可能会睡眠。

``ctlr->transfer_one_message(struct spi_controller *ctlr, struct spi_message *mesg)``  
子系统调用驱动程序以传输单个消息，同时排队等待期间到达的其他传输。当驱动程序完成此消息后，必须调用`spi_finalize_current_message()`以便子系统可以发出下一个消息。
此操作可能会睡眠。

``ctrl->transfer_one(struct spi_controller *ctlr, struct spi_device *spi, struct spi_transfer *transfer)``  
子系统调用驱动程序以传输单个数据块，同时排队等待期间到达的其他传输。当驱动程序完成此数据块后，必须调用`spi_finalize_current_transfer()`以便子系统可以发出下一个数据块。
此操作可能会睡眠。注意：`transfer_one`和`transfer_one_message`是互斥的；如果两者都设置，则通用子系统不会调用您的`transfer_one`回调函数。

返回值：

    * 负数errno: 错误
    * 0: 传输已完成
    * 1: 传输仍在进行中

``ctrl->set_cs_timing(struct spi_device *spi, u8 setup_clk_cycles, u8 hold_clk_cycles, u8 inactive_clk_cycles)``  
此方法允许SPI客户端驱动程序向SPI主机控制器请求配置特定于设备的CS设置、保持和非活动定时需求。

已弃用的方法
^^^^^^^^^^^^^^

``ctrl->transfer(struct spi_device *spi, struct spi_message *message)``  
此方法不应睡眠。它的职责是安排传输的发生及其complete()回调被触发。这两者通常会在其他传输完成后发生，并且如果控制器处于空闲状态，则需要启动。此方法在队列控制器上不使用，并且如果实现了`transfer_one_message()`和(un)prepare_transfer_hardware()则必须为NULL。

SPI消息队列
^^^^^^^^^^^^^

如果你对SPI子系统提供的标准队列机制感到满意，只需实现上述队列方法即可。使用消息队列的优点在于集中了大量的代码并提供了纯进程上下文中的方法执行。消息队列还可以在高优先级SPI流量上调至实时优先级。
除非选择了SPI子系统中的队列机制，否则驱动程序的大部分工作将是管理由现已废弃的`transfer()`函数填充的I/O队列。
这个队列可能是纯粹概念上的。例如，仅用于低频传感器访问的驱动程序可能适合使用同步PIO（程序直接输入输出）。
但是，这个队列很可能是非常实际存在的，它会使用`message->queue`、PIO、通常还有DMA（特别是在SPI闪存中存放根文件系统的情况下），以及诸如IRQ处理程序、任务项或工作队列（如keventd）这样的执行上下文。你的驱动程序可以尽可能地复杂，也可以尽可能地简单。
这样的一种`transfer()`方法通常只是将消息添加到一个队列中，然后启动某个异步传输引擎（除非它已经在运行）。

致谢
------
参与Linux-SPI讨论的贡献者包括（按姓氏字母顺序排列）：

- 马克·布朗 (Mark Brown)
- 大卫·布朗内尔 (David Brownell)
- 拉塞尔·金 (Russell King)
- 格兰特·莱利 (Grant Likely)
- 德米特里·佩尔武辛 (Dmitry Pervushin)
- 斯蒂芬·斯特里特 (Stephen Street)
- 马克·安德伍德 (Mark Underwood)
- 安德鲁·维克托 (Andrew Victor)
- 林纳斯·瓦利 (Linus Walleij)
- 维塔利·伍尔 (Vitaly Wool)
