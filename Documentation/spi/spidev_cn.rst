SPI 用户空间 API
=================

SPI 设备具有一个有限的用户空间 API，支持对 SPI 从设备进行基本的半双工读取 (`read()`) 和写入 (`write()`) 操作。通过 `ioctl()` 请求，还可以实现全双工传输和设备 I/O 配置：

```c
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/types.h>
#include <linux/spi/spidev.h>
```

您可能会选择使用这个编程接口的一些原因包括：

 * 在一个不易崩溃的环境中进行原型设计；用户空间中的错误指针通常不会使任何 Linux 系统崩溃。
 * 开发用于与作为 SPI 从设备的微控制器通信的简单协议，这些协议可能需要频繁更改。
当然，有些驱动程序永远无法在用户空间中编写，因为它们需要访问内核接口（例如中断处理程序或其他驱动堆栈层），而这些接口对用户空间是不可见的。

设备创建、驱动绑定
==================

spidev 驱动程序包含了针对不同硬件拓扑表示的 SPI 设备列表。以下是 spidev 驱动程序支持的 SPI 设备表：

- `struct spi_device_id spidev_spi_ids[]`：当使用包含匹配表中条目的 `.modalias` 字段的 `struct spi_board_info` 定义设备时，可以绑定的设备列表。
- `struct of_device_id spidev_dt_ids[]`：当使用具有匹配表中条目的兼容字符串的 Device Tree 节点定义设备时，可以绑定的设备列表。
- `struct acpi_device_id spidev_acpi_ids[]`：当使用具有匹配表中条目的 `_HID` 的 ACPI 设备对象定义设备时，可以绑定的设备列表。
如果您发现相关表格中没有您的 SPI 设备条目，我们鼓励您为您的 SPI 设备名称添加一个条目。要做到这一点，请向 linux-spi@vger.kernel.org 邮件列表提交一个 spidev 补丁。
过去支持使用 "spidev" 名称来定义 SPI 设备。
例如，像 `.modalias = "spidev"` 或 `compatible = "spidev"`。但这种方式不再被Linux内核支持，而是必须使用上述表格之一中列出的真实SPI设备名称。
如果没有真实SPI设备名称，则会导致错误信息的输出，并且spidev驱动程序无法完成探测。

Sysfs还支持用户空间驱动的绑定和解绑操作，这些操作适用于那些没有自动通过上述表格绑定的设备。
为了使spidev驱动程序绑定到这样的设备，可以使用以下方法：

    在 `/sys/bus/spi/devices/spiB.C/driver_override` 中输入 `spidev`
    在 `/sys/bus/spi/drivers/spidev/bind` 中输入 `spiB.C`

当spidev驱动程序绑定到一个SPI设备时，该设备的sysfs节点将包含一个子设备节点，该节点具有一个“dev”属性，此属性可被udev或mdev（BusyBox中的udev替代品；功能较少，但通常足够）识别。
对于位于总线B上的芯片选择C的SPI设备，你应该能看到如下内容：

    `/dev/spidevB.C ..`
字符特殊设备，主设备号为153，
	拥有动态选择的次设备号。这是用户空间程序将打开的节点，
由“udev”或“mdev”创建
`/sys/devices/.../spiB.C ..`
如同往常一样，SPI设备节点将是其SPI主控制器的子节点
`/sys/class/spidev/spidevB.C ..`
当“spidev”驱动程序绑定到该设备时创建。（是目录还是符号链接取决于你是否启用了“已弃用的sysfs文件”Kconfig选项）

不要尝试手动管理 `/dev` 目录下的字符设备特殊文件节点。
这是易于出错的，并且你需要仔细关注系统安全问题；udev/mdev 应该已经配置得足够安全了。
如果你从该设备上解除绑定“spidev”驱动程序，这两个“spidev”节点（在 sysfs 和 /dev 中）应该会自动被移除（分别由内核和 udev/mdev 完成）。你可以通过卸载“spidev”驱动模块来解除绑定，这将会影响到使用该驱动的所有设备。你也可以通过内核代码卸载 SPI 设备来解除绑定，可能的方法是移除其 SPI 控制器的驱动（使其 spi_master 消失）。
由于这是一个标准的 Linux 设备驱动程序——即使它恰好为用户空间提供了一个低级别的 API——它可以同时与任意数量的设备关联。只需为每个此类 SPI 设备提供一个 spi_board_info 记录，你就可以为每个设备获得一个 /dev 设备节点。
基础字符设备 API
=================
对 /dev/spidevB.D 文件进行正常的打开（open）和关闭（close）操作如你所预期的工作。
标准的读取（read）和写入（write）操作显然是半双工的，并且在这两个操作之间芯片选择（chipselect）会被去激活。全双工访问以及不进行芯片选择去激活的组合操作可以通过 SPI_IOC_MESSAGE(N) 请求实现。
有几个 ioctl 请求允许你的驱动读取或覆盖设备当前的数据传输参数设置：

    SPI_IOC_RD_MODE, SPI_IOC_WR_MODE ..
传递一个指向字节的指针，该指针将返回（RD）或设置（WR）SPI 传输模式。使用常量 SPI_MODE_0 到 SPI_MODE_3；或者如果你愿意，可以组合使用 SPI_CPOL（时钟极性，如果设置了这个标志则空闲时为高电平）或 SPI_CPHA（时钟相位，如果设置了这个标志则在后沿采样）标志。
需要注意的是，此请求仅限于能放入单个字节中的 SPI 模式标志。
SPI_IOC_RD_MODE32, SPI_IOC_WR_MODE32 ..
传递一个指向 uint32_t 的指针，该指针将返回（RD）或设置（WR）完整的 SPI 传输模式，不受限于一个字节所能表示的位数。
翻译如下：

SPI_IOC_RD_LSB_FIRST, SPI_IOC_WR_LSB_FIRST ...
传递一个指向字节的指针，
该指针将返回（RD）或分配（WR）用于传输SPI数据词的位顺序方式。零表示高位优先（MSB-first）；其他值表示较为少见的低位优先（LSB-first）编码方式。在这两种情况下，指定的值在每个词中都是右对齐的，这样未使用的（发送TX）或未定义的（接收RX）比特位都位于最高有效位（MSBs）。
SPI_IOC_RD_BITS_PER_WORD, SPI_IOC_WR_BITS_PER_WORD ...
传递一个指向字节的指针，
该指针将返回（RD）或分配（WR）每个SPI传输词中的比特数。零值表示八个比特。
SPI_IOC_RD_MAX_SPEED_HZ, SPI_IOC_WR_MAX_SPEED_HZ ...
传递一个指向u32的指针，
该指针将返回（RD）或分配（WR）最大SPI传输速度，单位为赫兹（Hz）。控制器不一定能够分配到该特定时钟速度。

注意事项：
- 目前没有异步I/O支持；所有操作都是纯同步的。
- 当前无法报告实际用于向/从给定设备移位数据的比特率。
- 从用户空间来看，当前无法更改芯片选择极性；这可能会破坏与其他共享SPI总线的设备之间的传输。
每个SPI设备在其未处于活动使用状态时都会被取消选择，从而允许其他驱动程序与总线上的其他设备进行通信。
每个I/O请求可以传输到SPI设备的字节数量是有限制的。默认情况下，这个限制为一页，但可以通过模块参数来更改。

由于SPI没有低级别的传输确认机制，因此在与不存在的设备通信时，通常不会看到任何I/O错误。

**全双工字符设备API**

===============================

请参阅spidev_fdx.c示例程序，它展示了全双工编程接口的一个用法。（尽管它实际上并没有执行全双工传输。）该模型与内核中spi_sync()请求所使用的模型相同；各个传输提供了与内核驱动程序可用的能力相同的特性（除了它不是异步的）。
示例展示了一个半双工的RPC风格请求和响应消息。
这些请求通常要求在请求和响应之间芯片不被取消选择。多个这样的请求可以串联成一个内核请求，甚至可以在每次响应之后允许芯片被取消选择。（其他的协议选项包括为每个传输段改变字长和比特率。）

要发起一个全双工请求，需要为同一个传输同时提供rx_buf和tx_buf。即使这两个缓冲区是同一个也没问题。
