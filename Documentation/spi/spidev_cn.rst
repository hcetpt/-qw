SPI 用户空间 API
=================

SPI 设备具有一个有限的用户空间 API，支持对 SPI 从设备进行基本的半双工读取 (`read()`) 和写入 (`write()`) 操作。通过 `ioctl()` 请求，还可以实现全双工传输和设备 I/O 配置：

```c
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/types.h>
#include <linux/spi/spidev.h>
```

您可能希望使用此编程接口的一些原因包括：

 * 在一个不易崩溃的环境中进行原型设计；用户空间中的错误指针通常不会使任何 Linux 系统崩溃。
 * 开发用于与作为 SPI 从设备的微控制器通信的简单协议，这些协议您可能需要经常更改。
当然，有些驱动程序永远无法在用户空间中编写，因为它们需要访问内核接口（例如中断处理程序或其他驱动堆栈层），而这些接口对用户空间是不可用的。

设备创建与驱动绑定
==============================

spidev 驱动程序包含了一系列支持不同硬件拓扑表示的 SPI 设备列表。以下是 spidev 驱动程序所支持的 SPI 设备表：

- `struct spi_device_id spidev_spi_ids[]`：当使用包含与表中条目匹配的 `.modalias` 字段的 `struct spi_board_info` 定义设备时，可以绑定的设备列表。
- `struct of_device_id spidev_dt_ids[]`：当使用具有与表中条目匹配的兼容字符串的设备树节点定义设备时，可以绑定的设备列表。
- `struct acpi_device_id spidev_acpi_ids[]`：当使用具有与表中条目匹配的 `_HID` 的 ACPI 设备对象定义设备时，可以绑定的设备列表。

如果您发现相关表格中还没有您 SPI 设备的条目，建议您添加一个。要做到这一点，请将 spidev 的补丁提交至 linux-spi@vger.kernel.org 邮件列表。

过去支持使用 "spidev" 名称定义 SPI 设备。
例如，像 `.modalias = "spidev"` 或 `compatible = "spidev"`。但这种方式不再被Linux内核支持，而是必须使用上面表格之一中列出的真实SPI设备名称。
如果没有真实SPI设备名称，则会导致错误信息的输出，并且spidev驱动程序无法完成探测。

Sysfs也支持用户空间驱动的绑定和解绑操作，这些操作针对那些没有自动通过上述表格中的方式绑定的设备。
要使spidev驱动程序与这样的设备绑定，请使用以下命令：

    `echo spidev > /sys/bus/spi/devices/spiB.C/driver_override`
    `echo spiB.C > /sys/bus/spi/drivers/spidev/bind`

当spidev驱动程序与SPI设备绑定时，该设备的sysfs节点将包含一个子设备节点，该节点具有“dev”属性，这可以被udev或mdev（BusyBox中的udev替代品；它的功能较少，但通常足够）理解。
对于位于总线B上的选择器C的SPI设备，您应该能看到如下内容：

    `/dev/spidevB.C ..`
字符特殊设备，主设备号为153，
	具有动态选择的次设备号。这是用户空间程序将打开的节点，
由“udev”或“mdev”创建
`/sys/devices/.../spiB.C ..`
如常，SPI设备节点将是其SPI主控制器的子节点
`/sys/class/spidev/spidevB.C ..`
在“spidev”驱动程序
	与该设备绑定时创建。（目录或符号链接，取决于
是否启用了“已弃用的sysfs文件”Kconfig选项。）

请不要尝试手动管理 `/dev` 中的字符设备特殊文件节点。
这是易于出错的，并且你需要仔细关注系统安全问题；udev/mdev 应该已经配置得足够安全。
如果你从该设备上解除“spidev”驱动，这两个“spidev”节点（在 sysfs 和 /dev 中）应该会被自动移除（分别由内核和 udev/mdev 完成）。你可以通过卸载“spidev”驱动模块来解除绑定，这将影响所有使用此驱动的设备。你也可以通过内核代码卸载 SPI 设备，这通常是通过移除其 SPI 控制器的驱动来实现（因此其 spi_master 会消失）。
由于这是一个标准的 Linux 设备驱动——尽管它恰好向用户空间暴露了一个低级别的 API——它可以同时与任意数量的设备关联。只需为每个这样的 SPI 设备提供一个 spi_board_info 记录，你就可以为每个设备获得一个 /dev 设备节点。

基本字符设备 API
==================
对 /dev/spidevB.D 文件进行常规的 open() 和 close() 操作按预期工作。
标准的 read() 和 write() 操作显然只能实现半双工通信，并且在这两个操作之间芯片选择会被禁用。全双工访问以及无需禁用芯片选择的组合操作可通过 SPI_IOC_MESSAGE(N) 请求实现。
有多个 ioctl() 请求允许你的驱动读取或覆盖设备当前的数据传输参数设置：

    SPI_IOC_RD_MODE, SPI_IOC_WR_MODE ..
传递一个指向字节的指针，该指针将返回（RD）或分配（WR）SPI 传输模式。使用常量 SPI_MODE_0 至 SPI_MODE_3；或者如果你愿意，也可以组合使用 SPI_CPOL （时钟极性，如果设置了这个标志则空闲时为高电平）或 SPI_CPHA （时钟相位，如果设置了这个标志则在后沿采样）标志
需要注意的是，此请求仅限于能放入单个字节中的 SPI 模式标志。
SPI_IOC_RD_MODE32, SPI_IOC_WR_MODE32 ..
传递一个指向 uint32_t 的指针，该指针将返回（RD）或分配（WR）完整的 SPI 传输模式，不受单字节位数限制。
翻译如下：

SPI_IOC_RD_LSB_FIRST, SPI_IOC_WR_LSB_FIRST ...
传递一个指向字节的指针，
该指针将返回（RD）或分配（WR）用于传输SPI数据词的位顺序方式。零表示高位优先（MSB-first）；其他值表示较为少见的低位优先（LSB-first）编码方式。在这两种情况下，指定的值在每个词中都是右对齐的，这样未使用的（TX）或未定义的（RX）位被放置在最高有效位（MSBs）中。
SPI_IOC_RD_BITS_PER_WORD, SPI_IOC_WR_BITS_PER_WORD ...
传递一个指向字节的指针，
该指针将返回（RD）或分配（WR）每个SPI传输词中的位数。零值表示八个位。
SPI_IOC_RD_MAX_SPEED_HZ, SPI_IOC_WR_MAX_SPEED_HZ ...
传递一个指向无符号32位整数（u32）的指针，
该指针将返回（RD）或分配（WR）最大SPI传输速度，单位为赫兹（Hz）。控制器不一定能够分配那个特定的时钟速度。

注释：
- 目前没有异步I/O支持；所有操作都是纯粹同步的。
- 当前没有方法可以报告实际用于向/从给定设备移位数据的比特率。
- 从用户空间来看，目前无法更改芯片选择极性；这可能会破坏与同一SPI总线上其他设备的数据传输。
每个SPI设备在其不处于活动使用状态时都会被取消选择，从而允许其他驱动程序与其他设备进行通信。
每个I/O请求可以传输到SPI设备的字节数量是有限制的。默认情况下，这个限制为一页，但可以通过模块参数来更改。

由于SPI没有低级别的传输确认机制，因此在与不存在的设备通信时，通常不会看到任何I/O错误。

**全双工字符设备API**

===============================

请参阅spidev_fdx.c示例程序，它展示了全双工编程接口的一个用法。（尽管它并未执行真正的全双工传输。）该模型与内核中spi_sync()请求所使用的模型相同；各个传输提供了与内核驱动程序可用的能力相同的特性（除了它不是异步的）。
示例展示了一个半双工的RPC风格请求和响应消息。
这些请求通常要求在请求和响应之间芯片不应被取消选择。多个这样的请求可以串联成一个内核请求，甚至可以在每次响应之后允许芯片被取消选择。（其他的协议选项包括为每个传输段改变字长和比特率。）

要发起一个全双工请求，需要为同一个传输同时提供rx_buf和tx_buf。即使这两个缓冲区是同一个也没问题。
