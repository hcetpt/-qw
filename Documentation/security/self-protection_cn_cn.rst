好的，以下是您提供的文本的中文翻译：

======================
内核自我保护
======================

内核自我保护是指在Linux内核中设计和实现系统与结构以防止内核本身的漏洞。这涵盖了广泛的议题，包括消除整个类别的错误、阻止安全漏洞利用方法以及主动检测攻击尝试。本文档并未涵盖所有主题，但可以作为一个合理的起点，并解答一些常见问题。（当然，欢迎提交补丁！）

在最坏的情况下，我们假设一个没有特权的本地攻击者对内核内存具有任意读写访问权限。在许多情况下，被利用的漏洞不会提供这种级别的访问权限，但通过设立防御最坏情况的系统，我们也覆盖了更有限的情况。更高的标准是保护内核免受有特权的本地攻击者的侵害，因为root用户拥有更大的攻击面。（特别是当他们能够加载任意内核模块时。）

成功的自我保护系统的目标应是有效，默认启用，无需开发人员选择加入，没有性能影响，不妨碍内核调试，并且具有测试。通常这些目标不能全部实现，但明确提及它们是有必要的，因为需要探索、处理或接受这些方面。

攻击面减少
========================

抵御安全漏洞最根本的防御措施是减少可用于重定向执行的内核区域。这包括从限制暴露给用户空间的API，到使内核内部API难以被误用，最小化可写入内核内存的区域等。

严格的内核内存权限
--------------------------------

当所有内核内存都可写入时，攻击者很容易重定向执行流程。为了减少这些目标的可用性，内核需要使用一套严格的权限来保护其内存。

可执行代码和只读数据不得可写
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

任何包含可执行内存的内核区域不得可写。这显然包括内核文本本身，但我们还必须考虑所有其他地方：内核模块、即时编译（JIT）内存等。（有一些临时例外，如支持指令替代、断点、kprobes等。如果这些必须存在于内核中，则以一种方式实现，在更新期间暂时将内存设为可写，然后恢复原始权限。）

为此提供了`CONFIG_STRICT_KERNEL_RWX`和`CONFIG_STRICT_MODULE_RWX`选项，旨在确保代码不可写，数据不可执行，并且只读数据既不可写也不可执行。
大多数架构默认启用这些选项且不可由用户选择。对于希望使这些选项可选的一些架构（如ARM），可以通过架构Kconfig选择`ARCH_OPTIONAL_KERNEL_RWX`来启用Kconfig提示。`CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT`确定当启用`ARCH_OPTIONAL_KERNEL_RWX`时的默认设置。

函数指针和敏感变量不得可写
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

大量内核内存包含函数指针，这些指针被内核查找并用于继续执行（例如描述符/向量表、文件/网络等操作结构）。这些变量的数量必须减少到绝对最少。
许多这样的变量可以通过将其标记为“const”使其存储在内核的.rodata段而不是.data段中，从而获得内核严格内存权限的保护。
对于那些在`__init`阶段一次性初始化的变量，可以标记为`__ro_after_init`属性。
剩下的是那些很少更新的变量（例如 GDT）。这些变量需要另一种基础设施（类似于上述对内核代码所做的临时异常处理），以允许它们在其生命周期的其余时间内保持只读状态。例如，在更新时，只有执行更新的 CPU 线程会被赋予不可中断的写访问权限。

### 内核内存与用户空间内存隔离

内核永远不应执行用户空间的内存。内核也永远不应在没有明确预期的情况下访问用户空间的内存。这些规则可以通过硬件限制的支持（如 x86 的 SMEP/SMAP、ARM 的 PXN/PAN）或通过仿真（如 ARM 的 Memory Domains）来强制执行。通过这种方式阻止用户空间内存，可以防止执行和数据解析被传递到易于控制的用户空间内存中，迫使攻击必须完全在内核内存中进行。

### 减少系统调用的访问

对于 64 位系统，一种简单的方法是不使用 `CONFIG_COMPAT` 来消除许多系统调用。然而，这通常不是一个可行的方案。“seccomp”系统提供了一个可供用户空间选择的功能，它提供了一种减少进程可用内核入口点数量的方法。这限制了可以到达的内核代码范围，可能减少了特定漏洞对攻击的可用性。

一个改进的方向是创建有效的方法，将对兼容性、用户命名空间、BPF 创建和性能监控等的访问仅限于受信任的过程。这将使内核入口点的范围限制在更常规的一组通常对非特权用户空间可用的范围内。

### 限制对内核模块的访问

内核不应允许非特权用户加载特定的内核模块，因为这会提供一种意外扩展可攻击面的手段。（通过预定义子系统按需加载模块，例如 MODULE_ALIAS_*，被认为是“预期”的，尽管即使对此也需要额外考虑。）例如，通过非特权套接字 API 加载文件系统模块是没有意义的：只有 root 或物理本地用户才能触发文件系统模块的加载。（即便如此，在某些情况下也存在争议。）

为了保护甚至特权用户，系统可能需要完全禁用模块加载（例如整体内核构建或 modules_disabled sysctl），或者提供签名模块（例如 `CONFIG_MODULE_SIG_FORCE` 或带有 LoadPin 的 dm-crypt），以防止 root 通过模块加载器接口加载任意内核代码。

### 内存完整性

内核中有许多内存结构经常被滥用以获取执行控制权。最常见的是栈缓冲区溢出，其中存储在栈上的返回地址被覆盖。还有其他多种类似的攻击方式，存在一些防护措施来抵御这些攻击。

#### 栈缓冲区溢出

经典的栈缓冲区溢出涉及写入超出预期的栈上变量末尾的内容，最终将一个受控值写入栈帧中存储的返回地址。最广泛使用的防御方法是在栈变量和返回地址之间放置一个栈金丝雀（`CONFIG_STACKPROTECTOR`），并在函数返回前进行验证。其他防御措施包括影子栈等。

#### 栈深度溢出

一种不太为人所知的攻击是利用漏洞触发内核消耗栈内存，通过深度函数调用或大量栈分配。通过这种攻击，可以写入内核预先分配的栈空间之外，并进入敏感结构。为了更好地保护，需要做出两个重要改变：将敏感的 thread_info 结构移到别处，并在栈底部添加一个故障内存洞以捕获这些溢出。

堆内存完整性
---------------------

用于跟踪堆空闲列表的结构可以在分配和释放期间进行检查，以确保它们不会被用来操纵其他内存区域。

计数器完整性
-----------------

内核中的许多地方使用原子计数器来跟踪对象引用或执行类似的生命周期管理。当这些计数器可以被绕过（上溢或下溢）时，这通常会暴露出一个“使用后释放”的漏洞。通过捕捉原子计数器的上溢或下溢，这类错误将消失。

大小计算溢出检测
-----------------------------------

类似于计数器溢出，整数溢出（通常是大小计算）需要在运行时被检测到，以消除这类错误，这类错误传统上会导致越界写入内核缓冲区。

概率性防御
======================

虽然许多保护措施被认为是确定性的（例如，只读内存不能被写入），但有些保护措施仅提供统计上的防御，即攻击者必须收集有关正在运行系统的足够信息才能克服这种防御。尽管不是完美的，但这些措施确实提供了有意义的防护。

哨兵、盲化和其他秘密
-------------------------------------

需要注意的是，前面讨论的栈哨兵技术从技术上讲也是统计防御措施，因为它们依赖于一个秘密值，而这些值可能会通过信息暴露漏洞被发现。
对于像即时编译器（JIT）这样的场景，其中可执行内容可能部分受用户空间控制，也需要类似的秘密值。
为了最大化其成功几率，所使用秘密值必须是独立的（例如，每个栈有不同的哨兵）且具有高熵（例如，随机数生成器是否正常工作？）。

内核地址空间布局随机化（KASLR）
-------------------------------------------------

由于内核内存的位置几乎总是成功发起攻击的关键因素，使该位置非确定性提高了利用难度。（请注意，这反过来又增加了信息暴露的价值，因为这些信息可能会被用来发现所需的内存位置。）

文本和模块基址
~~~~~~~~~~~~~~~~~~~~

通过在启动时重新定位内核的物理和虚拟基址（`CONFIG_RANDOMIZE_BASE`），可以挫败需要内核代码的攻击。此外，偏移模块加载基址意味着即使那些每次启动都加载相同模块集的系统也不会与内核文本的其余部分共享相同的基址。

栈基址
~~~~~~~~~~

如果不同进程之间的内核栈基址不同，甚至不同系统调用之间的基址也不同，则位于栈上或栈之后的目标将更难以定位。

动态内存基址
~~~~~~~~~~~~~~~~~~~

内核的大部分动态内存（如kmalloc、vmalloc等）由于启动早期初始化顺序的原因，最终布局相对确定。如果这些区域的基地址在每次启动时不同，则针对它们的攻击将受阻，需要暴露特定于该区域的信息。

结构布局
~~~~~~~~~~~~~~~~

通过对敏感结构进行构建时随机化布局，攻击者必须针对已知的内核版本进行调整，或者暴露足够的内核内存来确定结构布局，然后再对其进行操纵。

防止信息泄露
================================

由于敏感结构的位置是攻击的主要目标，因此必须防御内核内存地址和内容（因为它们可能包含内核地址或其他敏感信息，如canary值）的泄露。

内核地址
----------------

将内核地址打印到用户空间会泄露关于内核内存布局的敏感信息。使用任何打印原始地址的printk指定符时应谨慎，目前包括%px、%p[ad]（以及某些情况下%p[sSb]）。使用这些指定符写入的任何文件都应仅对特权进程可读。
4.14及更早版本的内核使用%p打印原始地址。自4.15-rc1起，使用%p指定符打印的地址在打印前会被哈希处理。

[*] 如果启用了KALLSYMS且符号查找失败，则打印原始地址。如果没有启用KALLSYMS，则打印原始地址。

唯一标识符
----------------

内核内存地址绝不能用作暴露给用户空间的标识符。相反，应使用原子计数器、idr或类似的唯一标识符。

内存初始化
---------------------

复制到用户空间的内存必须始终完全初始化。如果不显式调用memset()，则需要更改编译器以确保结构中的空洞被清除。

内存污染
----------------

释放内存时，最好污染其内容，以避免依赖旧内存内容的重用攻击。例如，在系统调用返回时清空栈（`CONFIG_GCC_PLUGIN_STACKLEAK`），在释放堆内存时擦除堆内存。这可以挫败许多未初始化变量攻击、栈内容泄露、堆内容泄露和使用后释放攻击。

目标跟踪
--------------------

为了帮助消除导致内核地址被写入用户空间的一类错误，需要跟踪写入的目标。如果缓冲区的目的地是用户空间（例如由seq_file支持的``/proc``文件），则应自动审查敏感值。

当然，请提供你需要翻译的文本。
