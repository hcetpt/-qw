SPDX 许可证标识符：GPL-2.0-only

TPM 安全性
==========

本文档旨在描述如何使内核在面对外部窥探和数据包篡改攻击（文献中称为被动和主动中间人攻击）时，使用 TPM 达到合理的健壮性。当前的安全文档是针对 TPM 2.0 的。

介绍
------------

TPM 通常是一个通过某种低带宽总线连接到 PC 的独立芯片。也有例外情况，例如 Intel PTT，它是在接近 CPU 的软件环境中运行的软件 TPM，这会受到不同的攻击。但目前，大多数加固的安全环境需要一个独立的硬件 TPM，这也是本文档讨论的用例。

针对总线的窥探和篡改攻击
-----------------------------------------------

当前最先进的窥探手段是 `TPM Genie`_ 硬件中间人设备，这是一种简单的外部设备，可以在任何系统或笔记本电脑上几秒钟内安装完成。最近成功演示了对 `Windows Bitlocker TPM`_ 系统的攻击。最近还出现了针对基于 TPM 的 Linux 磁盘加密方案的攻击。下一阶段的研究似乎是在现有总线上黑入现有设备以充当中间人，因此攻击者可能不再需要几秒钟的物理访问时间。然而，本文档的目标是在这种环境下尽可能保护 TPM 秘钥和完整性，并确保即使我们无法阻止攻击，至少能够检测到攻击。

不幸的是，包括硬件重置功能在内的大部分 TPM 功能都可以被拥有总线访问权限的攻击者控制，因此我们将讨论一些可能的干扰方式。

度量（PCR）完整性
---------------------------

由于攻击者可以向 TPM 发送自己的命令，他们可以发送任意的 PCR 扩展，从而破坏测量系统，这将是一种烦人的拒绝服务攻击。然而，还有两类更为严重的攻击，针对依赖信任测量进行密封的实体：
1. 攻击者可以拦截所有来自系统的 PCR 扩展，并完全替换自己的值，生成未被篡改状态的重放，这会导致 PCR 测量证明受信任的状态并释放秘密。
2. 在某个时间点，攻击者可以重置 TPM，清除 PCR 并发送自己的测量值，这实际上会覆盖 TPM 已经完成的启动时测量值。

第一类可以通过始终使用 HMAC 保护 PCR 扩展和读取命令来防止，这意味着没有产生可检测的 HMAC 失败响应的情况下，测量值不能被替换。然而，第二类只能通过依赖某种机制来检测，该机制会在 TPM 重置后发生变化。

秘密保护
----------------

某些进出 TPM 的信息，如密钥密封、私钥导入和随机数生成，容易被截获，HMAC 保护本身无法防止这种情况，因此对于这些类型的命令，我们必须同时采用请求和响应加密，以防止秘密信息丢失。

与 TPM 建立初始信任
---------------------------------------

为了从一开始就提供安全性，必须建立一个初始共享或非对称秘密，该秘密也必须为攻击者所不知。最明显的途径是使用认证种子和存储种子，它们可以用于派生非对称密钥。
然而，使用这些密钥是困难的，因为唯一将它们传递给内核的方法是在命令行上进行，这需要引导系统中有大量的支持，并且无法保证这两个层次不会包含某种形式的授权。
所选择的Linux内核机制是从空种子（null seed）使用标准存储种子参数派生主椭圆曲线密钥。空种子有两个优点：首先，该层次物理上不可能有授权，因此我们总是可以使用它；其次，空种子在TPM重置时会改变，这意味着如果我们一天开始时在空种子上建立信任，那么所有用派生密钥加盐的会话如果TPM重置并且种子改变的话都会失败。
显然，在没有任何其他预先共享的秘密的情况下使用空种子，我们必须创建并读取初始公钥，这当然可能被总线拦截器截获和替换。
然而，TPM有一个密钥认证机制（使用EK背书证书，创建一个证明身份密钥，并用该密钥认证空种子主密钥），这个过程太复杂而不能在内核中运行，所以我们保留了一个空主密钥名称的副本，这是通过sysfs导出的，以便用户空间在启动时可以运行完整的认证。这里的决定性保证是，如果空主密钥认证正确，你就知道从一天开始的所有TPM事务都是安全的；如果认证不成功，你就知道系统上有拦截器（以及任何启动期间使用的秘密可能已被泄露）。
信任叠加
----------

在当前的空主密钥方案下，TPM必须在传递给下一个消费者之前完全清除。然而，内核向用户空间传递的是派生空种子密钥的名称，然后可以在用户空间通过认证来验证。因此，这种名称传递链也可以用于各种引导组件之间（通过未指定的机制）。例如，grub可以使用空种子方案来确保安全，并将名称传递给引导区域中的内核。内核可以自行派生密钥及其名称，并确定地知道如果它们与传递的版本不同，则发生了篡改。这样就可以通过名称传递将任意的引导组件链接在一起（UEFI到grub再到内核），只要每个后续组件知道如何收集名称并验证其派生密钥。
会话属性
----------

内核使用的所有TPM命令都允许会话。HMAC会话可用于检查请求和响应的完整性，并且可以使用加密和解密标志来保护参数和响应。HMAC和加密密钥通常从共享授权秘密派生，但对于许多内核操作来说，这个秘密是众所周知的（通常是空的）。因此，内核必须使用空主密钥作为加盐密钥来创建每一个HMAC会话，从而为会话密钥派生提供密码学输入。因此，内核仅创建一次空主密钥（作为一个易失性TPM句柄），并将其保留在tpm_chip中存储的保存上下文中以供每次内核使用TPM时使用。目前，由于内核资源管理器缺乏去间隙功能，因此每个操作都需要创建和销毁会话，但将来可能会复用单个会话来进行内核中的HMAC、加密和解密会话。
保护类型
----------

对于每个内核操作，我们使用空主密钥加盐的HMAC来保护完整性。此外，我们还使用参数加密来保护密钥密封，并使用参数解密来保护密钥解封和随机数生成。
用户空间中的空主密钥认证
==========================

每个TPM都随附了一对X.509证书用于主背书密钥。本文档假设椭圆曲线版本的证书位于01C00002处，但同样适用于RSA证书（位于01C00001处）。
认证的第一步是使用来自《TCG EK凭证配置文件》的模板创建主密钥，这允许将生成的主密钥与证书中的密钥进行比较（公钥必须匹配）。请注意，生成EK主密钥需要EK层次密码，但预生成的EC主密钥应存在于81010002处，并且可以在不需要密钥权限的情况下执行TPM2_ReadPublic()。接下来，必须验证证书本身以追溯到制造商根证书（该证书应在制造商网站上发布）。一旦完成此操作，将在TPM内部生成一个证明密钥（AK），并使用其名称和EK公钥使用TPM2_MakeCredential加密一个秘密。TPM然后运行TPM2_ActivateCredential，只有当TPM、EK和AK之间的绑定为真时才能恢复秘密。此时生成的AK可用于认证内核导出的空主密钥名称。由于TPM2_MakeCredential/ActivateCredential有些复杂，下面描述了一个涉及外部生成私钥的简化过程。
此过程是对常规基于隐私CA的证明过程的一个简化版本。这里假设证明是由TPM所有者完成的，因此所有者只能访问所有者层次。所有者创建一个外部公钥/私钥对（此处假设为椭圆曲线），并使用内部封装过程并以EC派生存储主密钥为父密钥对私钥进行封装。使用参数解密HMAC会话对EK主密钥进行加盐的TPM2_Import()意味着内部封装密钥是加密参数，因此除非TPM拥有经过认证的EK，否则无法执行导入。如果命令成功并且返回时HMAC验证通过，我们知道我们只有一个经过认证TPM可加载的私钥副本。此密钥现在加载到TPM中，并刷新存储主密钥（以腾出空间用于生成空密钥）。
空的 EC 主密钥现在是根据《TCG TPM v2.0 配置指南》_ 中概述的存储配置文件生成的；该密钥（公有区域的哈希值）的名称会被计算并与内核在 /sys/class/tpm/tpm0/null_name 中呈现的空种子名称进行比较。如果名称不匹配，则表示 TPM 被破坏。如果名称匹配，用户使用空主密钥作为对象句柄，并使用加载的私钥作为签名句柄，提供随机化的认证数据来执行 TPM2_Certify() 操作。返回的 certifyInfo 的签名会通过加载的私钥的公有部分进行验证，并检查认证数据以防止重放攻击。如果所有这些测试都通过，用户就可以确信，在整个启动过程中，TPM 的完整性和隐私得到了保护。

.. _TPM Genie: https://www.nccgroup.trust/globalassets/about-us/us/documents/tpm-genie.pdf
.. _Windows Bitlocker TPM: https://dolosgroup.io/blog/2021/7/9/from-stolen-laptop-to-inside-the-company-network
.. _针对基于 TPM 的 Linux 磁盘加密的攻击: https://www.secura.com/blog/tpm-sniffing-attacks-against-non-bitlocker-targets
.. _TCG EK 凭证配置文件: https://trustedcomputinggroup.org/resource/tcg-ek-credential-profile-for-tpm-family-2-0/
.. _TCG TPM v2.0 配置指南: https://trustedcomputinggroup.org/resource/tcg-tpm-v2-0-provisioning-guidance/
