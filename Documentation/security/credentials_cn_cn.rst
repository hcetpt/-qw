====================
Linux中的凭证
====================

作者：David Howells <dhowells@redhat.com>

.. contents:: :local:

概述
========

当一个对象对另一个对象进行操作时，Linux执行的安全检查有几个部分：

1. 对象
对象是系统中可以直接被用户空间程序操作的实体。Linux中有多种可操作的对象，包括：
   - 任务
   - 文件/inode
   - 套接字
   - 消息队列
   - 共享内存段
   - 信号量
   - 密钥

所有这些对象的描述中都有一组凭证。这组凭证的内容取决于对象的类型。
2. 对象所有权
在大多数对象的凭证中，会有一个子集表示该对象的所有权。这用于资源核算和限制（例如磁盘配额和任务rlimit）。

在标准的UNIX文件系统中，例如，这将由inode上标记的UID定义。
3. 目标上下文
在这些对象的凭证中，还会有一个子集表示该对象的“目标上下文”。这可能与第(2)点中的集合相同或不同——在标准UNIX文件中，这由inode上标记的UID和GID定义。

目标上下文用于在对象被操作时进行安全计算的一部分。
4. 主体
主体是一个对其他对象进行操作的对象。
系统中的大多数对象是不活跃的：它们不会对系统内的其他对象产生作用。进程/任务是明显的例外：它们会执行操作；访问和操纵事物。
除了任务之外，某些情况下其他对象也可能成为主体。例如，一个打开的文件可能会使用由调用`fcntl(F_SETOWN)`的任务提供的UID和EUID向该任务发送SIGIO信号。在这种情况下，文件结构也会有一个主观上下文。
5. 主观上下文
主体对其凭证有额外的解释。其凭证的一部分形成了“主观上下文”。当主体执行操作时，主观上下文作为安全计算的一部分被使用。
例如，在Linux中，当一个任务对文件进行操作时，它具有FSUID、FSGID和补充组列表，这些与通常形成任务客观上下文的真实UID和GID是完全不同的。
6. 操作
Linux提供了一系列主体可以对对象执行的操作。可用的操作集取决于主体和对象的性质。
操作包括读取、写入、创建和删除文件；分叉或发送信号以及跟踪任务。
7. 规则、访问控制列表和安全计算
当一个主体对一个客体执行操作时，会进行一次安全计算。这涉及到将主观上下文、客观上下文以及操作行为与一个或多个规则集进行比对，以确定在给定这些上下文的情况下，该主体是否被允许以期望的方式对客体执行操作。
规则的两个主要来源是：

a. 自主访问控制（DAC）：

    有时，客体会在其描述中包含一组规则。这就是“访问控制列表”或“ACL”。一个Linux文件可能提供不止一个ACL。
    例如，传统的UNIX文件包含权限掩码，这是一个简化的ACL，具有三个固定的主体类别（“用户”、“组”和“其他”），每个类别可以被授予某些权限（如“读取”、“写入”和“执行”——具体取决于该对象）。然而，UNIX文件权限不允许任意指定主体，因此其用途有限。
    Linux文件也可能包含一个POSIX ACL。这是一个规则列表，可以向任意主体授予各种权限。

b. 强制访问控制（MAC）：

    整个系统可能有一套或多套规则，适用于所有主体和客体，无论它们的来源如何。
    SELinux和Smack就是这种控制的例子。
    在SELinux和Smack的情况下，每个对象都会在其凭证中分配一个标签。当请求执行某个操作时，它们会使用主体标签、客体标签以及操作来查找一条规则，以确定该操作是被允许还是被拒绝。

凭证类型
====================

Linux内核支持以下几种类型的凭证：

1. 传统的UNIX凭证
- 真实用户ID
- 真实组ID

    UID和GID几乎携带于所有Linux对象上，即使在某些情况下需要人为创建（例如FAT或CIFS文件，这些文件源自Windows）。这些（大部分）定义了该对象的客观上下文，任务在某些情况下略有不同。

- 有效用户ID、保存用户ID和文件系统用户ID
- 有效组ID、保存组ID和文件系统组ID
- 补充组

    这些是仅用于任务的附加凭证。通常，EUID/EGID/GROUPS会被用作主观上下文，而真实的UID/GID则被用作客观上下文。需要注意的是，对于任务来说，这种情况并不总是成立。
2. 能力
   - 允许的能力集
   - 可继承的能力集
   - 有效的能力集
   - 能力边界集

   这些只由任务携带。它们表示分配给任务的高级能力，这些能力是普通任务原本不具备的。
   这些可以通过对传统UNIX凭证的更改隐式地进行操作，也可以直接通过"capset()"系统调用进行操作。

   允许的能力是指进程可能通过"capset()"给自己授予给其有效或允许集的能力。这个可继承集可能也会受到这样的限制。

   有效的能力是任务实际上可以自行使用的那些能力。

   可继承的能力是在`execve()`操作中可能传递的能力。

   边界集限制了在`execve()`操作中可以继承的能力，尤其是在执行将作为UID 0执行的二进制文件时。

3. 安全管理标志（安全位）
   - 这些只由任务携带。它们控制了在某些操作如`execve()`中如何处理上述凭证，并且在继承过程中进行操作。它们不是直接作为客观或主观凭证使用。

4. 密钥和密钥环
这些仅由任务携带。它们携带并缓存那些无法放入其他标准UNIX凭证的安全令牌。它们的目的是使网络文件系统密钥等信息能够对进程执行的文件访问可用，而无需普通程序了解涉及的安全细节。

密钥环是一种特殊的密钥。它们携带其他密钥的集合，并且可以搜索所需的密钥。每个进程可以订阅多个密钥环：

- 每线程密钥
- 每进程密钥环
- 每会话密钥环

当一个进程访问一个密钥时，如果该密钥尚未存在，则通常会在这些密钥环之一中缓存，以便将来访问时能够找到。
关于使用密钥的更多信息，请参阅``Documentation/security/keys/*``

5. LSM（Linux 安全模块）

Linux 安全模块允许对任务可能执行的操作施加额外的控制。目前 Linux 支持几种 LSM 选项。
某些 LSM 通过标记系统中的对象，然后应用一系列规则（策略），说明具有某个标签的任务可以对具有另一个标签的对象执行哪些操作。

6. AF_KEY

这是一种基于套接字的方法，用于管理网络堆栈的凭证[RFC 2367]。本文档不讨论它，因为它并不直接与任务和文件凭证交互；而是保持系统级别的凭证。

当打开一个文件时，打开任务的部分主观上下文会被记录在创建的文件结构中。这使得使用该文件结构的操作可以使用这些凭证，而不是执行操作的任务的主观上下文。例如，在网络文件系统上打开的文件，无论实际进行读写的是谁，都应该向服务器展示打开文件的凭证。

文件标记
=========

磁盘上的文件或从网络获取的文件可能有注释，形成该文件的客观安全上下文。根据文件系统的类型，这可能包括以下一项或多项：

* UNIX 用户ID、组ID、模式；
* Windows 用户ID；
* 访问控制列表；
* LSM 安全标签；
* UNIX 执行权限提升位（SUID/SGID）；
* 文件能力执行权限提升位

这些注释会与任务的主观安全上下文进行比较，并据此允许或禁止某些操作。在执行execve()时，权限提升位起作用，可能会根据可执行文件上的注释赋予结果进程额外的权限。

任务凭证
================

在 Linux 中，所有任务的凭证都保存在（uid, gid）或通过（groups, keys, LSM security）引用计数的结构中，类型为 'struct cred'。
每个任务通过 `task_struct` 中名为 `cred` 的指针指向其凭证。一旦一组凭证被准备并提交后，除了以下例外情况外，不得对其进行修改：

1. 其引用计数可以改变；
2. 它所指向的 `group_info` 结构体的引用计数可以改变；
3. 它所指向的安全数据的引用计数可以改变；
4. 它所指向的任何密钥环的引用计数可以改变；
5. 可以撤销、过期或更改它所指向的任何密钥环的安全属性；
6. 可以更改它所指向的任何密钥环的内容（密钥环的目的是共享一组凭证，任何有适当访问权限的人都可以修改）。

为了在 `cred` 结构体中进行任何修改，必须遵循复制和替换原则。首先复制一份，然后修改该副本，最后使用 RCU 更改任务指针，使其指向新的副本。有一些辅助函数来帮助完成这个操作（见下文）。

一个任务只能修改自己的凭证；不再允许一个任务修改另一个任务的凭证。这意味着 `capset()` 系统调用不再允许传递除当前进程以外的任何 PID。同样，`keyctl_instantiate()` 和 `keyctl_negate()` 函数也不再允许请求进程将密钥附着到特定进程的密钥环上，因为创建这些密钥环的过程可能需要这样做。

不可变凭证
-------------

一旦一组凭证被公开（例如通过调用 `commit_creds()`），除了以下两个例外情况外，应将其视为不可变的：

1. 引用计数可以改变；
2. 尽管一组凭证的密钥环订阅不能更改，但已订阅的密钥环的内容可以更改。

为了在编译时捕捉意外的凭证修改，`struct task_struct` 和 `struct file` 中指向凭证集的指针是 `_const` 类型的。此外，某些函数如 `get_cred()` 和 `put_cred()` 操作的是常量指针，因此不需要进行类型转换，但需要临时去掉常量限定符以便修改引用计数。

访问任务凭证
--------------

由于任务只能修改自己的凭证，这使得当前进程能够无需任何形式的锁定就能读取或替换自己的凭证——这大大简化了事情。它只需调用：

```c
const struct cred *current_cred();
```

以获取指向其凭证结构的指针，并且之后无需释放它。

还有一些方便的包装函数用于检索任务凭证的具体方面（每次都会返回相应的值）：

```c
uid_t current_uid(void);		// 当前的实际用户 ID
gid_t current_gid(void);		// 当前的实际组 ID
uid_t current_euid(void);		// 当前的有效用户 ID
gid_t current_egid(void);		// 当前的有效组 ID
uid_t current_fsuid(void);		// 当前的文件访问用户 ID
gid_t current_fsgid(void);		// 当前的文件访问组 ID
kernel_cap_t current_cap(void);	// 当前的有效能力
struct user_struct *current_user(void); // 当前的用户账户
```

还有些方便的包装函数用于检索任务凭证的具体关联对：

```c
void current_uid_gid(uid_t *, gid_t *);
void current_euid_egid(uid_t *, gid_t *);
void current_fsuid_fsgid(uid_t *, gid_t *);
```

这些函数会通过它们的参数返回这些值对，从当前任务的凭证中检索。

此外，还有一个函数用于获取当前进程当前凭证集的引用：

```c
const struct cred *get_current_cred(void);
```

以及一些获取不在 `struct cred` 中的凭证引用的函数：

```c
struct user_struct *get_current_user(void);
struct group_info *get_current_groups(void);
```

这些函数分别获取当前进程的用户会计结构和附加组列表的引用。
一旦获得引用，必须使用 `put_cred()`、`free_uid()` 或 `put_group_info()` 适当释放。

访问另一个任务的凭证
--------------------
虽然一个任务可以无需锁定即可访问自己的凭证，但要访问另一个任务的凭证则不行。它必须使用 RCU 读锁和 `rcu_dereference()`。
`rcu_dereference()` 被封装为：
```c
const struct cred *__task_cred(struct task_struct *task);
```
这应该在 RCU 读锁内使用，例如：

```c
void foo(struct task_struct *t, struct foo_data *f)
{
    const struct cred *tcred;
    .
rcu_read_lock();
    tcred = __task_cred(t);
    f->uid = tcred->uid;
    f->gid = tcred->gid;
    f->groups = get_group_info(tcred->groups);
    rcu_read_unlock();
    .
}
```

如果需要长时间持有另一个任务的凭证，并且可能在此期间休眠，则调用者应使用以下方法获取凭证引用：
```c
const struct cred *get_task_cred(struct task_struct *task);
```
这会在内部处理所有的 RCU 魔术。调用者在使用完毕后必须调用 `put_cred()` 来释放这些凭证。
**注意：**
不要将 `__task_cred()` 的结果直接传递给 `get_cred()`，因为这可能会与 `commit_cred()` 发生竞争。

有一些方便的函数来访问另一个任务凭证的部分内容，隐藏了调用者的 RCU 魔术：
```c
uid_t task_uid(task);       // 任务的真实 UID
uid_t task_euid(task);      // 任务的有效 UID
```

如果调用者已经持有了 RCU 读锁，则应使用：
```c
__task_cred(task)->uid
__task_cred(task)->euid
```

同样地，如果需要访问任务凭证的多个方面，应使用 RCU 读锁，调用 `__task_cred()`，将结果存储在一个临时指针中，然后从该指针中调用凭证方面的内容，然后再释放锁。这可以防止潜在昂贵的 RCU 魔术被多次调用。

如果需要访问另一个任务凭证的某个单一方面，则可以使用：
```c
task_cred_xxx(task, member)
```
其中 'member' 是 `cred` 结构中的非指针成员。例如：
```c
uid_t task_cred_xxx(task, suid);
```
这会从任务中检索 `struct cred::suid`，执行相应的 RCU 魔术。对于指针成员不能使用此方法，因为它们指向的内容可能在 RCU 读锁释放时消失。

更改凭证
--------------------
如前所述，一个任务只能更改自己的凭证，而不能更改其他任务的凭证。这意味着它不需要使用任何锁定来更改自己的凭证。

要更改当前进程的凭证，函数首先应通过调用以下方法准备一组新的凭证：
```c
struct cred *prepare_creds(void);
```
这会锁定 `current->cred_replace_mutex`，然后分配并构造当前进程凭证的副本，如果成功则仍然持有互斥锁返回。如果不成功（内存不足）则返回 NULL。
互斥锁防止 `ptrace()` 在进行凭证构造和更改的安全检查时修改进程的 `ptrace` 状态，因为 `ptrace` 状态可能会影响结果，特别是在 `execve()` 的情况下。
新设置的凭证应适当修改，并执行任何安全检查和挂钩。当前和提议的凭证集均可用于此目的，因为在这一点上 `current_cred()` 仍会返回当前集。
在替换组列表时，新列表必须先排序才能添加到凭证中，因为使用二分搜索来测试成员身份。实际上，这意味着在调用 `set_groups()` 或 `set_current_groups()` 之前应该调用 `groups_sort()`。
`groups_sort()` 不得在共享的 `struct group_list` 上调用，因为它可能会作为排序过程的一部分重新排列元素，即使数组已经排序。
当凭证集准备就绪后，应通过调用以下函数将其提交到当前进程：

```c
int commit_creds(struct cred *new);
```

这将修改凭证和进程的各个方面，并给 LSM 提供机会执行相应操作，然后使用 `rcu_assign_pointer()` 将新的凭证实际提交到 `current->cred`，释放 `current->cred_replace_mutex` 以允许 `ptrace()` 运行，并通知调度程序和其他组件这些更改。
此函数保证返回 0，因此可以在诸如 `sys_setresuid()` 之类的函数末尾尾调用它。
请注意，此函数会消耗调用者对新凭证的引用。调用者不应在之后调用 `put_cred()` 来释放新凭证。
此外，一旦此函数被调用在一个新的凭证集上，这些凭证就不能进一步修改。
如果在调用 `prepare_creds()` 之后安全检查失败或发生其他错误，则应调用以下函数：

```c
void abort_creds(struct cred *new);
```

这会释放 `prepare_creds()` 获得的 `current->cred_replace_mutex` 锁，并释放新的凭证。
典型的凭证修改函数可能如下所示：

```c
int alter_suid(uid_t suid)
{
    struct cred *new;
    int ret;

    new = prepare_creds();
    if (!new)
        return -ENOMEM;

    new->suid = suid;
    ret = security_alter_suid(new);
    if (ret < 0) {
        abort_creds(new);
        return ret;
    }

    return commit_creds(new);
}
```

### 管理凭证

以下是一些用于帮助管理凭证的函数：

- `void put_cred(const struct cred *cred);`

    这个函数释放给定的一组凭证的引用。如果引用计数变为零，则这些凭证将被RCU系统安排销毁。

- `const struct cred *get_cred(const struct cred *cred);`

    这个函数获取一组活动凭证的引用，并返回指向这组凭证的指针。

- `struct cred *get_new_cred(struct cred *cred);`

    这个函数获取一组正在构建中（因此仍然可变）的凭证的引用，并返回指向这组凭证的指针。

### 文件打开时的凭证

当一个新文件被打开时，会获取打开任务的凭证的一个引用，并将其作为`f_cred`附加到文件结构上，取代`f_uid`和`f_gid`。以前访问`file->f_uid`和`file->f_gid`的代码现在应该访问`file->f_cred->fsuid`和`file->f_cred->fsgid`。

在不使用RCU或锁定的情况下访问`f_cred`是安全的，因为在文件结构的生命周期内，该指针不会改变，除非有上述例外情况（参见任务凭证部分）。

为了避免“困惑副手”特权提升攻击，在对已打开文件进行后续操作时，应使用这些凭证而不是当前进程的凭证，因为文件可能已被传递给权限更高的进程。

### 覆盖VFS使用的凭证

在某些情况下，希望覆盖VFS使用的凭证，可以通过传递不同的凭证调用如`vfs_mkdir()`等函数来实现。这在以下地方实现：

- `sys_faccessat()`
- `do_coredump()`
- `nfs4recover.c`
