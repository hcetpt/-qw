======================
内核自我保护
======================

内核自我保护是指在Linux内核中设计和实现系统与结构以防止内核本身的漏洞。这涵盖了广泛的议题，包括消除整个类别的错误、阻止安全漏洞利用方法以及主动检测攻击尝试。本文档并未涵盖所有主题，但可以作为一个合理的起点，并解答一些常见问题。（当然，欢迎提交补丁！）

在最坏的情况下，我们假设一个没有特权的本地攻击者对内核内存具有任意读写访问权限。在许多情况下，被利用的漏洞不会提供这种级别的访问权限，但通过设立防御最坏情况的系统，我们也覆盖了更有限的情况。更高的标准是保护内核免受有特权的本地攻击者的侵害，因为root用户拥有更大的攻击面。（特别是当他们能够加载任意内核模块时。）

成功的自我保护系统的目标应是有效，默认启用，无需开发人员选择加入，没有性能影响，不妨碍内核调试，并且具有测试。通常这些目标不能全部实现，但明确提及它们是有必要的，因为需要探索、处理或接受这些方面。
攻击面减少
========================

抵御安全漏洞最根本的防御措施是减少可用于重定向执行的内核区域。这包括从限制暴露给用户空间的API，到使内核内部API难以被误用，最小化可写入内核内存的区域等。
严格的内核内存权限
--------------------------------

当所有内核内存都可写入时，攻击者很容易重定向执行流程。为了减少这些目标的可用性，内核需要使用一套严格的权限来保护其内存。
可执行代码和只读数据不得可写
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

任何包含可执行内存的内核区域不得可写。这显然包括内核文本本身，但我们还必须考虑所有其他地方：内核模块、即时编译（JIT）内存等。（有一些临时例外，如支持指令替代、断点、kprobes等。如果这些必须存在于内核中，则以一种方式实现，在更新期间暂时将内存设为可写，然后恢复原始权限。）

为此提供了`CONFIG_STRICT_KERNEL_RWX`和`CONFIG_STRICT_MODULE_RWX`选项，旨在确保代码不可写，数据不可执行，并且只读数据既不可写也不可执行。
大多数架构默认启用这些选项且不可由用户选择。对于希望使这些选项可选的一些架构（如ARM），可以通过架构Kconfig选择`ARCH_OPTIONAL_KERNEL_RWX`来启用Kconfig提示。`CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT`确定当启用`ARCH_OPTIONAL_KERNEL_RWX`时的默认设置。
函数指针和敏感变量不得可写
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

大量内核内存包含函数指针，这些指针被内核查找并用于继续执行（例如描述符/向量表、文件/网络等操作结构）。这些变量的数量必须减少到绝对最少。
许多这样的变量可以通过将其标记为“const”使其存储在内核的.rodata段而不是.data段中，从而获得内核严格内存权限的保护。
对于那些在`__init`阶段一次性初始化的变量，可以标记为`__ro_after_init`属性。
剩下的是那些很少更新的变量（例如 GDT）。这些变量需要另一种基础设施（类似于上述对内核代码所做的临时异常处理），以允许它们在其生命周期的其余时间内保持只读状态。例如，在更新时，只有执行更新的 CPU 线程会被赋予不可中断的写访问权限。

### 内核内存与用户空间内存隔离

内核永远不应执行用户空间的内存。内核也永远不应在没有明确预期的情况下访问用户空间的内存。这些规则可以通过硬件限制的支持（如 x86 的 SMEP/SMAP、ARM 的 PXN/PAN）或通过仿真（如 ARM 的 Memory Domains）来强制执行。通过这种方式阻止用户空间内存，可以防止执行和数据解析被传递到易于控制的用户空间内存中，迫使攻击