== 自我保护的内核 ==
  
自我保护的内核是指在Linux内核中设计和实现系统及结构，以防范内核自身的安全漏洞。这涵盖了广泛的议题，包括消除整个类别的bug、阻止安全漏洞利用方法以及主动检测攻击尝试。本文档并未涵盖所有主题，但它应该能作为合理的起点并解答常见问题。（当然，欢迎提交补丁！）

在最坏的情况下，我们假设一个无特权的本地攻击者可以任意读取和写入内核内存。在许多情况下，被利用的bug不会提供这种级别的访问权限，但通过设立针对最坏情况的防御机制，我们也能够覆盖那些受限程度更高的情况。一个更高的要求，同时也应时刻牢记的是：保护内核免受_有特权_的本地攻击者的侵害，因为root用户具有更大范围的攻击面。（特别是当他们有能力加载任意内核模块时。）

成功的自我保护系统的预期目标是它们应当有效、默认启用、无需开发者选择加入、对性能没有影响、不阻碍内核调试并且附带有测试用例。通常很难同时满足所有这些目标，但值得明确指出它们，因为这些方面需要被探索、处理和/或接受。
攻击面减少
=============

对抗安全漏洞的最根本防御手段是减少可用于重定向执行流程的内核区域。这包括从限制可供用户空间访问的API到确保内核内部API难以被错误使用，再到最小化可写入内核内存的区域等各个方面。
严格内核内存权限
-------------------

当所有内核内存都可被写入时，攻击者重定向执行流程将变得轻而易举。为了降低这些目标的可用性，内核需要通过一套严格的权限来保护其内存。
可执行代码和只读数据不得被写入
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

任何包含可执行内存的内核区域都不应被写入。这显然包括内核文本本身，但我们还必须考虑所有其他地方：内核模块、即时编译（JIT）内存等。（对于某些特殊情况如指令替代、断点、kprobes等，存在临时例外。如果这些特性必须存在于内核中，它们会以一种方式实现在更新期间暂时使内存可写，然后恢复至原始权限。）

支持这一点的是`CONFIG_STRICT_KERNEL_RWX`和`CONFIG_STRICT_MODULE_RWX`，它们旨在确保代码不可写、数据不可执行且只读数据既不可写也不可执行。
大多数架构默认启用这些选项且不允许用户自行配置。对于希望使其可选的架构（如ARM），可以通过架构Kconfig选择`ARCH_OPTIONAL_KERNEL_RWX`以启用Kconfig提示。`CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT`确定了在启用`ARCH_OPTIONAL_KERNEL_RWX`时的默认设置。
函数指针和敏感变量不得被写入
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

大量内核内存包含函数指针，这些指针由内核查找并用于继续执行（例如描述符/向量表、文件/网络等操作结构）。这类变量的数量必须降至最低。
许多这样的变量可以通过将其标记为“const”而变为只读，以便它们存储在内核的.rodata段而不是.data段中，从而获得上述严格内存权限的保护。
对于那些仅在`__init`时间初始化一次的变量，可以使用`__ro_after_init`属性进行标记。
剩余的是一些很少更新的变量（例如GDT）。这些变量将需要另一种基础设施（类似于上述对内核代码所做的临时例外）来允许它们在其生命周期的其余部分保持只读状态。例如，在进行更新时，只有执行更新的CPU线程会被赋予不可中断的对该内存的写访问权限。

内核内存与用户空间内存的隔离
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

内核绝不能执行用户空间的内存。内核也绝不应未经明确预期就访问用户空间的内存。这些规则可以通过硬件限制的支持（如x86的SMEP/SMAP、ARM的PXN/PAN）或通过仿真（如ARM的内存域）来强制执行。通过这种方式阻止用户空间的内存，执行和数据解析就不能轻易地传递给可以被随意控制的用户空间内存，从而迫使攻击完全在内核内存中进行。

减少系统调用的访问
---------------------------

对于64位系统来说，一个简单的方法是不使用`CONFIG_COMPAT`进行构建，但这很少是一个可行的选择。
"seccomp"系统为用户空间提供了一个可选的功能，可以用来减少运行进程可用的内核入口点数量。这限制了可以触及的内核代码范围，可能减少了特定漏洞被攻击利用的可能性。
一个改进的方向是创建有效的方法，仅让受信任的进程能够访问像compat、用户命名空间、BPF创建和perf这样的功能。这样可以确保内核入口点的范围仅限于通常可供非特权用户空间使用的更常规的一组。

限制对内核模块的访问
------------------------------------

内核不应允许非特权用户加载特定的内核模块，因为这样做会提供一种意外扩展可攻击面的能力。（通过预定义的子系统按需加载模块，例如MODULE_ALIAS_*，被认为是在“预期”范围内，但即使这些情况也应该给予额外的关注。）例如，通过非特权套接字API加载文件系统模块是没有意义的：只有root或物理本地用户才应该触发文件系统模块的加载。（即便如此，在某些情况下这也值得商榷。）

为了进一步保护，系统可能需要完全禁用模块加载（例如，整体内核构建或通过modules_disabled sysctl禁用），或者提供签名模块（例如`CONFIG_MODULE_SIG_FORCE`，或dm-crypt与LoadPin一起使用），以防止root通过模块加载器接口加载任意的内核代码。

内存完整性
=================

内核中有许多内存结构经常被滥用以获取攻击中的执行控制。其中最广为人知的是栈缓冲区溢出，即覆盖存储在栈上的返回地址。还有其他多种类似的攻击方式存在，并且有一些保护措施来防御这些攻击。

栈缓冲区溢出
---------------------

经典的栈缓冲区溢出涉及向栈上存储的变量的预期末尾之外写入内容，最终将可控值写入栈帧中存储的返回地址。最广泛使用的防御方法是在栈变量和返回地址之间设置一个栈卫士（`CONFIG_STACKPROTECTOR`），并在函数返回之前验证它。其他的防御措施包括诸如影子栈等技术。

栈深度溢出
---------------------

一种不太为人所理解的攻击方式是利用一个漏洞，触发内核消耗大量的栈内存，通过深层函数调用或大容量的栈分配。在这种攻击中，有可能写出内核预先分配的栈空间的末尾，进入敏感结构。为了更好的防护，需要做出两个重要的改变：将敏感的thread_info结构移至别处，并在栈底部添加一个故障内存空洞来捕捉这些溢出。
堆内存完整性
---------------------

用于跟踪堆空闲列表的结构可以在分配和释放期间进行合理性检查，以确保它们没有被用来操纵其他内存区域。
计数器完整性
-----------------

内核中的许多地方使用原子计数器来追踪对象引用或执行类似的生命周期管理。当这些计数器可以被绕过（溢出或下溢）时，这通常会暴露出一个释放后使用的漏洞。通过捕获原子计数器的溢出，这类错误就会消失。
大小计算溢出检测
-----------------------------------

类似于计数器溢出，整数溢出（通常是大小计算）需要在运行时被检测出来以消除这类错误，这类错误传统上会导致能够写入内核缓冲区的末尾之外。
概率性防御
======================

虽然许多防护措施可以被认为是确定性的（例如，只读内存不能被写入），但有些防护措施仅提供统计上的防御，即攻击者必须收集有关正在运行系统的足够信息才能克服这种防御。虽然不是完美的，但这些措施确实提供了有意义的防护。
哨兵、混淆和其他秘密
-------------------------------------

应该注意的是，前面讨论过的像栈哨兵这样的东西从技术上讲是统计防御措施，因为它们依赖于一个秘密值，并且这些值可能通过信息暴露漏洞被发现。
对于像即时编译器（JITs）中可执行内容部分受用户空间控制的情况，需要类似的秘密值来进行混淆处理。
为了最大化它们的成功率，所使用秘密值必须是独立的（例如，每个栈具有不同的哨兵）并且具有高熵（例如，随机数生成器是否真的有效？）。
内核地址空间布局随机化（KASLR）
-------------------------------------------------

由于内核内存的位置几乎总是在发起成功的攻击中起到关键作用，使这个位置变得非确定性提高了利用的难度。（需要注意的是，这反过来又增加了信息暴露的价值，因为它们可能会被用来发现所需的内存位置。）

文本和模块基址
~~~~~~~~~~~~~~~~~~~~

通过在启动时重新定位内核的物理和虚拟基地址（`CONFIG_RANDOMIZE_BASE`），需要内核代码的攻击将受到挫败。此外，偏移模块加载基地址意味着即使系统每次启动时都加载相同的模块集合且顺序相同，也不会与内核文本的其余部分共享相同的基地址。
栈基址
~~~~~~~~~~

如果内核栈的基地址在不同进程之间不相同，甚至在不同系统调用之间也不相同，那么位于栈上或栈之后的目标就变得更难以定位。
### 动态内存基址

内核的大部分动态内存（如kmalloc、vmalloc等）由于启动早期初始化的顺序，最终布局相对确定。如果这些区域的基地址在每次启动之间不相同，则针对它们的攻击就会受阻，需要特定于该区域的信息暴露。

### 结构布局

通过针对敏感结构进行构建时的随机化处理，攻击要么必须针对已知的内核版本进行调整，要么需要暴露足够的内核内存来确定结构布局，然后才能操纵这些结构。

### 防止信息暴露

由于敏感结构的位置是攻击的主要目标，因此重要的是要防御内核内存地址和内核内存内容的暴露（因为它们可能包含内核地址或其他敏感信息，例如canary值）。

#### 内核地址

向用户空间打印内核地址会泄露关于内核内存布局的敏感信息。在使用任何打印原始地址的`printk`格式符（目前为%px、%p[ad]，以及在某些情况下%p[sSb]）时应格外小心。使用这些格式符写入的任何文件都只应该由特权进程可读。

在内核4.14及更早版本中，使用%p打印原始地址。从4.15-rc1开始，使用%p格式符打印的地址在打印前会被哈希处理。

* 如果启用了KALLSYMS并且符号查找失败，则会打印原始地址。如果未启用KALLSYMS，则也会打印原始地址。

#### 唯一标识符

内核内存地址绝不能用作暴露给用户空间的标识符。相反，应该使用原子计数器、IDR或类似的唯一标识符。

#### 内存初始化

复制到用户空间的内存必须始终完全初始化。如果没有显式调用memset()，则需要对编译器进行更改以确保结构中的空洞被清除。

#### 内存毒化

释放内存时，最好对内容进行毒化处理，以避免依赖旧内存内容的重用攻击。例如，在系统调用返回时清除栈(``CONFIG_GCC_PLUGIN_STACKLEAK``)，在释放堆内存时将其擦除。这可以有效阻止许多未初始化变量攻击、栈内容暴露、堆内容暴露以及释放后使用攻击。

#### 目的地跟踪

为了帮助消除导致内核地址被写入用户空间的错误类别，需要跟踪写操作的目的地。如果缓冲区将被写入用户空间（例如，通过seq_file支持的`/proc`文件），则应自动屏蔽敏感值。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
