======================
内核自我保护
======================

内核自我保护是指在Linux内核中设计和实现系统与结构，以防范内核本身的漏洞。这涵盖了广泛的议题，包括消除整个类别的错误、阻止安全漏洞的利用方法以及积极检测攻击尝试。本文档并非涵盖所有主题，但应作为一个合理的起点，并回答一些常见问题。（当然欢迎提交补丁！）

在最坏的情况下，我们假设一个无特权的本地攻击者可以任意读写内核内存。在许多情况下，被利用的漏洞不会提供这种级别的访问权限，但通过设立防御最坏情况的系统，我们也将覆盖那些更为有限的情况。更高的要求是保护内核免受_有特权_的本地攻击者的侵害，因为root用户具有更广阔的攻击面。（尤其是当他们能够加载任意内核模块时。）

成功的自我保护系统的目标应该是有效的，默认启用，无需开发者选择加入，没有性能影响，不妨碍内核调试，并且具有测试。通常不可能同时满足所有这些目标，但值得明确提及它们，因为这些方面需要被探讨、处理或接受。
攻击面减少
========================

抵御安全漏洞的最根本防御措施是减少可用于重定向执行的内核区域。这包括限制暴露给用户空间的API、使内核内部API难以误用、最小化可写内核内存等。
严格的内核内存权限
--------------------------------

当所有内核内存都是可写的时候，攻击者很容易重定向执行流程。为了减少这些目标的可用性，内核需要通过严格的权限集来保护其内存。
可执行代码和只读数据必须不可写
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

任何包含可执行内存的内核区域都不得可写。虽然这显然包括内核文本本身，但我们还必须考虑所有其他地方：内核模块、即时编译（JIT）内存等。（有一些临时例外情况，如指令替代、断点、kprobes等。如果这些功能必须存在于内核中，则以一种方式实现，在更新期间暂时使内存可写，然后恢复到原始权限。）

为此支持的是``CONFIG_STRICT_KERNEL_RWX``和``CONFIG_STRICT_MODULE_RWX``，它们旨在确保代码不可写、数据不可执行，并且只读数据既不可写也不可执行。
大多数架构默认启用这些选项，并且不可由用户选择。对于希望使其可选的一些架构（如ARM），架构Kconfig可以选择ARCH_OPTIONAL_KERNEL_RWX以启用Kconfig提示。``CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT``确定在启用ARCH_OPTIONAL_KERNEL_RWX时的默认设置。
函数指针和敏感变量必须不可写
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

内核内存的广大区域包含函数指针，这些指针由内核查找并用于继续执行（例如描述符/向量表、文件/网络等操作结构等）。这些变量的数量必须减少到绝对最少。
许多这样的变量可以通过将其标记为"const"使其成为只读，这样它们将存储在内核的.rodata部分而不是.data部分，从而获得上述严格内存权限的保护。
对于那些在``__init``时一次性初始化的变量，可以使用``__ro_after_init``属性进行标记。
剩下的是那些很少更新的变量（例如GDT）。这些变量需要另一种基础设施（类似于上文提到的对内核代码所做的临时异常处理），以允许它们在生命周期的其余时间内保持只读状态。例如，在更新时，只有执行更新的CPU线程会被赋予不可中断的写访问权限。

### 内核内存与用户空间内存的隔离
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

内核绝不能执行用户空间的内存。内核也绝不能在没有明确预期的情况下访问用户空间的内存。这些规则可以通过硬件支持的限制（如x86的SMEP/SMAP，ARM的PXN/PAN）或通过模拟（如ARM的Memory Domains）来实现。通过这种方式阻止用户空间的内存，可以防止执行和数据解析被传递到容易控制的用户空间内存中，从而迫使攻击只能在内核内存中进行。

### 减少系统调用的使用
-------------------------------

一种简单的方法是为64位系统构建时不包含`CONFIG_COMPAT`。然而，这在大多数情况下是不可行的。"seccomp"系统提供了一种可选功能，供用户空间使用，可以减少进程可用的内核入口点数量。这限制了可以到达的内核代码范围，可能减少了某个特定漏洞被利用的机会。

改进的一个方向是创建可行的方法，使对兼容性、用户命名空间、BPF创建和性能监控等功能的访问仅限于受信任的进程。这样可以将内核入口点的范围限制在普通用户空间通常可用的一组更常规的功能上。

### 限制对内核模块的访问
------------------------------------

内核绝不应允许非特权用户加载特定的内核模块，因为这会意外地扩展可利用的攻击面。（通过预定义子系统按需加载模块，例如MODULE_ALIAS_*，被认为是“预期”的情况，但即使是这种情况也需要进一步考虑。）例如，通过非特权套接字API加载文件系统模块是没有意义的：只有root用户或物理本地用户才能触发文件系统模块的加载。（即使在这种情况下也有争议。）

为了保护免受甚至特权用户的攻击，系统可能需要完全禁用模块加载（例如，整体内核构建或modules_disabled sysctl），或者提供签名模块（例如`CONFIG_MODULE_SIG_FORCE`，或带有LoadPin的dm-crypt），以防止root通过模块加载器接口加载任意内核代码。

### 内存完整性
=================

内核中有许多内存结构经常被滥用以获得攻击中的执行控制。最常见的是栈缓冲区溢出，其中存储在栈上的返回地址被覆盖。还有许多其他类型的此类攻击存在，并且有相应的防护措施。

#### 栈缓冲区溢出
------------------------

经典的栈缓冲区溢出涉及写入超出栈上存储的变量预期结束位置的内容，最终将一个受控值写入栈帧中存储的返回地址。最广泛使用的防御措施是在栈变量和返回地址之间放置一个栈金丝雀（`CONFIG_STACKPROTECTOR`），并在函数返回前验证它。其他防御措施包括影子栈等技术。

#### 栈深度溢出
------------------------

另一种不太为人所理解的攻击是利用导致内核消耗大量栈内存的漏洞，通过深层次的函数调用或大块的栈分配。通过这种攻击，可以写入内核预先分配的栈空间之外，进入敏感结构。为了更好地防护，需要进行两个重要更改：将敏感的thread_info结构移到别处，并在栈底部添加一个故障内存洞来捕捉这些溢出。
堆内存完整性
---------------------

用于跟踪堆空闲列表的结构可以在分配和释放期间进行检查，以确保它们不会被用来操纵其他内存区域。
计数器完整性
-----------------

内核中的许多地方使用原子计数器来跟踪对象引用或执行类似的生命周期管理。当这些计数器可以溢出（上溢或下溢）时，通常会暴露出一个“释放后使用”的漏洞。通过捕获原子溢出，这类错误将消失。
大小计算溢出检测
-----------------------------------

与计数器溢出类似，整数溢出（通常是大小计算）需要在运行时被检测出来，以消除这类可能导致越界写入内核缓冲区的漏洞。
概率性防御
======================

虽然许多防护措施可以被认为是确定性的（例如，只读内存无法被写入），但有些防护措施仅提供统计上的防御，即攻击者必须收集关于运行系统的信息以克服这种防御。尽管不完美，这些措施确实提供了有意义的防护。
哨兵、混淆和其他秘密
-------------------------------------

需要注意的是，前面讨论过的栈哨兵技术从技术上讲也是统计性防御，因为它们依赖于一个秘密值，而这些值可能会通过信息泄露漏洞被发现。
对于JIT等情况下，可执行内容可能部分受用户空间控制，也需要类似的秘密值。
为了最大化其成功率，所使用的秘密值必须是独立的（例如每个栈有不同的哨兵）且具有高熵（例如随机数生成器是否正常工作？）。
内核地址空间布局随机化（KASLR）
-------------------------------------------------

由于内核内存的位置几乎总是成功攻击的关键因素，使其位置变得不可预测可以增加利用难度。（注意，这反过来又提高了信息泄露的价值，因为它们可以用来发现所需的内存位置。）

文本和模块基址
~~~~~~~~~~~~~~~~~~~~

通过在启动时重新定位内核的物理和虚拟基地址（`CONFIG_RANDOMIZE_BASE`），需要内核代码的攻击将会受挫。此外，偏移模块加载基地址意味着即使那些每次启动都加载相同模块集的系统也不会与内核文本共享相同的基地址。
栈基址
~~~~~~~~~~

如果不同进程之间的内核栈基地址不同，甚至每次系统调用之间也不相同，则位于栈上或栈后的目标将更难以定位。
动态内存基址
~~~~~~~~~~~~~~~~~~~

内核的大部分动态内存（例如kmalloc、vmalloc等）由于早期引导初始化顺序的原因，在布局上变得相对确定。如果这些区域的基本地址在每次启动时都不相同，那么针对它们的攻击将受阻，需要暴露特定于该区域的信息。
结构布局
~~~~~~~~~~~~~~~~

通过对敏感结构进行构建时随机化处理，攻击必须要么针对已知的内核版本进行调整，要么暴露足够的内核内存以确定结构布局，然后才能对其进行操纵。
防止信息泄露
================================

由于敏感结构的位置是攻击的主要目标，因此防御内核内存地址和内核内存内容（因为它们可能包含内核地址或其他敏感信息如canary值）的泄露非常重要。
内核地址
----------------

向用户空间打印内核地址会泄露关于内核内存布局的敏感信息。使用任何打印原始地址的printk格式化字符串时应特别小心，目前为%px、%p[ad]（在某些情况下还包括%p[sSb]）。使用这些格式化字符串写入的任何文件都应仅对特权进程可读。
在4.14及更早版本的内核中，使用%p打印原始地址。从4.15-rc1开始，使用%p格式化字符串打印的地址会在打印前进行哈希处理。
[*] 如果启用了KALLSYMS且符号查找失败，则会打印原始地址；如果未启用KALLSYMS，则也会打印原始地址。
唯一标识符
------------------

内核内存地址绝不能用作暴露给用户空间的标识符。相反，应使用原子计数器、idr或类似的唯一标识符。
内存初始化
---------------------

复制到用户空间的内存必须始终完全初始化。如果不显式调用memset()，则需要更改编译器以确保清除结构中的空洞。
内存污染
---------------------

在释放内存时，最好污染其内容，以避免依赖旧内存内容的重用攻击。例如，在系统调用返回时清除栈（`CONFIG_GCC_PLUGIN_STACKLEAK`），在释放堆内存时擦除堆内存。这有助于防范许多未初始化变量攻击、栈内容泄露、堆内容泄露和使用后释放攻击。
目的地跟踪
--------------------

为了帮助消除导致内核地址被写入用户空间的bug类别，需要跟踪写入的目的地。如果缓冲区的目的地是用户空间（例如由seq_file支持的`/proc`文件），则应自动审查敏感值。
当然，请提供您需要翻译的文本。
