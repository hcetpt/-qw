凭证在 Linux 中的应用
====================

作者：David Howells <dhowells@redhat.com>

.. contents:: :local:

概述
========

Linux 在一个对象对另一个对象进行操作时执行的安全检查包含以下几个部分：

1. 对象
对象是系统中可以被用户空间程序直接操作的实体。Linux 包含多种可操作的对象，包括：
   - 任务
   - 文件/inode
   - 套接字
   - 消息队列
   - 共享内存段
   - 信号量
   - 密钥

这些对象的描述中包含了一组凭证。具体包含哪些凭证取决于对象的类型。

2. 对象所有权
大多数对象的凭证中包含一部分用于表示该对象的所有权的信息。这部分信息用于资源的核算和限制（例如磁盘配额和任务限制）。
在标准的 UNIX 文件系统中，例如，这将由 inode 上标记的 UID 来定义。

3. 目标上下文
同样，在这些对象的凭证中还有一部分用于表示该对象的“目标上下文”。这部分可能与第 2 点中的相同，也可能不同。
在标准的 UNIX 文件中，这部分由 inode 上标记的 UID 和 GID 定义。
目标上下文在对象被操作时用于安全计算的一部分。

4. 主体
主体是一个对其他对象进行操作的对象。
系统中的大多数对象是不活跃的：它们不对系统内的其他对象采取行动。进程/任务是一个明显的例外：它们执行操作；访问并操控事物。
除了任务之外，某些情况下其他对象也可能成为主体。例如，一个打开的文件可能会使用调用 `fcntl(F_SETOWN)` 的任务所提供的 UID 和 EUID 向该任务发送 SIGIO。在这种情况下，文件结构也会有一个主观上下文。
5. 主观上下文
主体对其凭证有额外的解释。其凭证的一个子集形成了“主观上下文”。当主体采取行动时，主观上下文作为安全计算的一部分被使用。
例如，在 Linux 中，当一个任务对文件进行操作时，它具有 FSUID、FSGID 和辅助组列表，这些与通常形成任务客观上下文的真实 UID 和 GID 是完全分开的。
6. 操作
主体可以在对象上执行一系列操作。可用的操作集取决于主体和对象的性质。
操作包括读取、写入、创建和删除文件；分叉或向任务发送信号以及跟踪任务。
7. 规则、访问控制列表和安全计算
当主体对客体进行操作时，会进行一次安全计算。这涉及将主观上下文、客观上下文和操作与一个或多个规则集进行比对，以确定在给定这些上下文的情况下，主体是否被授予或拒绝以期望的方式对客体进行操作。
规则主要有两个来源：

a. 自主访问控制（DAC）：

    有时客体会在其描述中包含一组规则。这就是“访问控制列表”或“ACL”。Linux 文件可以提供一个以上的ACL。
    例如，传统的UNIX文件包含一个权限掩码，这是一个简化的ACL，有三个固定的主体类别（“用户”、“组”和“其他”），每个类别都可以被授予某些权限（“读取”、“写入”和“执行”——具体取决于该对象）。然而，UNIX文件权限不允许任意指定主体，因此用途有限。
    Linux 文件也可能具有一个POSIX ACL。这是一个规则列表，为任意主体授予各种权限。

b. 强制访问控制（MAC）：

    整个系统可能有一套或多套规则应用于所有主体和客体，无论它们的来源如何。
    SELinux 和 Smack 就是这种类型的例子。
    在SELinux 和 Smack 的情况下，每个对象都会在其凭证中获得一个标签。当请求执行某个操作时，它们会根据主体标签、客体标签和操作查找一条规则，以确定此操作是被授予还是被拒绝。

凭证类型
========

Linux 内核支持以下类型的凭证：

1. 传统的UNIX凭证
   - 实际用户ID
   - 实际组ID

     这些UID和GID几乎由所有的Linux对象携带，即使在某些情况下需要创建（如FAT或CIFS文件，这些文件来自Windows）。这些（大部分）定义了该对象的客观上下文，任务在某些情况下略有不同。
   - 有效用户ID、保存用户ID和文件系统用户ID
   - 有效组ID、保存组ID和文件系统组ID
   - 补充组

     这些是仅由任务使用的附加凭证。通常，EUID/EGID/GROUPS会被用作主观上下文，而实际的UID/GID会被用作客观上下文。对于任务来说，需要注意的是，这并不总是正确的。
2. 能力（Capabilities）
- 允许的能力集
    - 可继承的能力集
    - 有效的能力集
    - 能力边界集

这些仅由任务携带。它们表示逐个授予任务的高级能力，而普通任务通常不具备这些能力。
这些可以通过对传统的UNIX凭证进行更改来隐式地操作，也可以通过`capset()`系统调用直接进行操作。
允许的能力是指进程可能通过`capset()`授予其有效或允许集的能力。这个可继承的集合也可能受到限制。
有效的能力是任务实际可以利用的能力。
可继承的能力是可以传递给`execve()`的能力。
边界集限制了通过`execve()`继承的能力，特别是在执行将作为UID 0运行的二进制文件时。

3. 安全管理标志（securebits）
这些仅由任务携带。它们控制上述凭证在某些操作（如`execve()`）中的操作和继承方式。它们不直接用作客观或主观凭证。

4. 密钥和密钥环
这些仅由任务持有。它们携带并缓存那些不符合标准UNIX凭证的安全令牌。它们的作用是使进程在执行文件访问时能够获取网络文件系统密钥，而无需普通程序了解涉及的安全细节。

密钥环是一种特殊的密钥。它们携带其他密钥集，并且可以搜索所需的密钥。每个进程可以订阅多个密钥环：

- 每线程密钥
- 每进程密钥环
- 每会话密钥环

当一个进程访问一个密钥时，如果该密钥尚未存在，则通常会在这些密钥环之一上缓存以供未来的访问查找。
更多关于使用密钥的信息，请参阅``Documentation/security/keys/*``

5. LSM（Linux 安全模块）

Linux 安全模块允许对任务可能执行的操作进行额外的控制。目前Linux支持几种LSM选项。
有些通过给系统中的对象打标签，然后应用一系列规则（策略），规定具有一个标签的任务可以对另一个标签的对象执行哪些操作。

6. AF_KEY

这是一种基于套接字的方法来管理网络堆栈的凭证[RFC 2367]。本文档不讨论它，因为它不直接与任务和文件凭证交互；而是保持系统级别的凭证。
当打开一个文件时，部分打开任务的主观上下文会被记录在创建的文件结构中。这使得使用该文件结构的操作可以使用这些凭证而不是执行操作的任务的主观上下文。例如，在网络文件系统上打开的文件，无论实际执行读或写的是谁，都应该向服务器展示打开文件的凭证。

文件标记
=========

磁盘上的文件或通过网络获取的文件可能带有注释，这些注释构成了该文件的目标安全上下文。根据文件系统的类型，这可能包括以下一项或多项内容：

* UNIX 用户ID（UID）、组ID（GID）、模式；
* Windows 用户ID；
* 访问控制列表；
* LSM 安全标签；
* UNIX 执行权限提升位（SUID/SGID）；
* 文件能力执行权限提升位

这些将与任务的主观安全上下文进行比较，并据此允许或禁止某些操作。在execve()的情况下，执行权限提升位起作用，并可能根据可执行文件上的注释赋予结果进程额外的权限。

任务凭证
==========

在Linux中，所有任务的凭证都保存在(uid, gid)或通过(groups, keys, LSM security)引用计数的“struct cred”类型的结构中。
每个任务通过其 `task_struct` 中名为 'cred' 的指针指向其凭证。一旦一组凭证被准备并提交后，除了以下几种情况外，这些凭证将不能被更改：

1. 其引用计数可以更改；
2. 它所指向的 `group_info` 结构体的引用计数可以更改；
3. 它所指向的安全数据的引用计数可以更改；
4. 它所指向的任何密钥环（keyrings）的引用计数可以更改；
5. 它所指向的任何密钥环可以被撤销、过期或更改其安全属性；
6. 它所指向的任何密钥环的内容可以被更改（密钥环的目的就是共享一套凭证，允许具有适当访问权限的任何人进行修改）。

要更改 `cred` 结构中的任何内容，必须遵循复制和替换的原则。首先复制该结构，然后更改副本，并使用 RCU 更改任务指针以指向新的副本。有一些封装函数来帮助完成这一过程（见下文）。

一个任务只能更改其自身的凭证；不再允许一个任务更改另一个任务的凭证。这意味着 `capset()` 系统调用不再允许传入除当前进程之外的任何 PID。同样，`keyctl_instantiate()` 和 `keyctl_negate()` 函数也不再允许在请求进程中连接到特定于进程的密钥环，因为实例化进程可能需要创建它们。

不可变凭证
-------------

一旦一组凭证被公开（例如，通过调用 `commit_creds()`），除了以下两种情况外，这些凭证应被视为不可变：

1. 引用计数可以更改；
2. 虽然凭证集的密钥环订阅不能更改，但已订阅的密钥环的内容可以更改。

为了在编译时捕获意外的凭证更改，`struct task_struct` 和 `struct file` 中指向其凭证集的指针为 `_const` 类型。此外，某些函数如 `get_cred()` 和 `put_cred()` 操作于常量指针，从而不需要类型转换，但需要临时去掉常量限定符以便能够更改引用计数。

访问任务凭证
--------------

由于一个任务只能更改其自身的凭证，这使得当前进程能够无需任何形式的锁来读取或替换其凭证——这大大简化了事情。它只需调用：

```c
const struct cred *current_cred();
```

以获取其凭证结构的指针，并且之后不需要释放它。

还有一些方便的封装函数用于检索任务凭证的具体方面（每次都会直接返回值）：

```c
uid_t current_uid(void);		当前的实际用户 ID
gid_t current_gid(void);		当前的实际组 ID
uid_t current_euid(void);		当前的有效用户 ID
gid_t current_egid(void);		当前的有效组 ID
uid_t current_fsuid(void);		当前的文件访问用户 ID
gid_t current_fsgid(void);		当前的文件访问组 ID
kernel_cap_t current_cap(void);	当前的有效权限
struct user_struct *current_user(void);  当前的用户账户
```

还有一些方便的封装函数用于检索任务凭证的具体关联对：

```c
void current_uid_gid(uid_t *, gid_t *);
void current_euid_egid(uid_t *, gid_t *);
void current_fsuid_fsgid(uid_t *, gid_t *);
```

这些函数会从当前任务的凭证中检索这些值对，并通过参数返回。

此外，还有一个函数用于获取当前进程当前凭证集的引用：

```c
const struct cred *get_current_cred(void);
```

以及一些获取不实际存在于 `struct cred` 中的凭证引用的函数：

```c
struct user_struct *get_current_user(void);
struct group_info *get_current_groups(void);
```

这些函数分别获取当前进程的用户记账结构和补充组列表的引用。
一旦获取到引用，必须使用 `put_cred()`、`free_uid()` 或 `put_group_info()` 适当释放。

访问另一个任务的凭证
--------------------
当一个任务可以无需锁定即可访问自己的凭证时，想要访问其他任务的凭证则不是这样。它必须使用 RCU 读锁和 `rcu_dereference()`。
`rcu_dereference()` 被封装为：

```c
const struct cred *__task_cred(struct task_struct *task);
```

这应该在 RCU 读锁内部使用，如下例所示：

```c
void foo(struct task_struct *t, struct foo_data *f)
{
    const struct cred *tcred;
    ..
    rcu_read_lock();
    tcred = __task_cred(t);
    f->uid = tcred->uid;
    f->gid = tcred->gid;
    f->groups = get_group_info(tcred->groups);
    rcu_read_unlock();
    ..
}
```

如果需要长时间持有另一个任务的凭证，并且在此期间可能进入睡眠状态，则调用者应使用以下方法获取凭证引用：

```c
const struct cred *get_task_cred(struct task_struct *task);
```

这会在内部完成所有 RCU 魔术。调用者在使用完毕后必须通过 `put_cred()` 释放这些凭证。
.. note::
   不应将 `__task_cred()` 的结果直接传递给 `get_cred()`，因为这可能会与 `commit_cred()` 发生竞争。

有一些方便的函数可以访问另一个任务凭证的部分内容，隐藏了调用者对 RCU 魔术的使用：

```c
uid_t task_uid(task)      // 任务的真实 UID
uid_t task_euid(task)     // 任务的有效 UID
```

如果调用者已经持有 RCU 读锁，则应使用：

```c
__task_cred(task)->uid
__task_cred(task)->euid
```

类似地，如果需要访问任务凭证的多个方面，则应使用 RCU 读锁，调用 `__task_cred()`，将结果存储在一个临时指针中，然后从该指针中调用凭证方面的内容，最后释放锁。这可以防止潜在昂贵的 RCU 魔术被多次调用。

如果需要访问另一个任务凭证的某个单一方面，则可以使用：

```c
task_cred_xxx(task, member)
```

其中 'member' 是 `cred` 结构中的非指针成员。例如：

```c
uid_t task_cred_xxx(task, suid);
```

将从任务中检索 `struct cred::suid`，执行适当的 RCU 魔术。这不能用于指针成员，因为它们指向的内容可能在 RCU 读锁释放时消失。

更改凭证
--------------------
如前所述，任务只能更改自己的凭证，而不能更改其他任务的凭证。这意味着它不需要使用任何锁定来更改自己的凭证。

要更改当前进程的凭证，函数应首先通过调用以下方法准备一组新的凭证：

```c
struct cred *prepare_creds(void);
```

这会锁定 `current->cred_replace_mutex` 并分配和构造当前进程凭证的副本，成功时仍持有互斥锁返回。如果不成功（内存不足），则返回 NULL。
互斥锁防止 `ptrace()` 在进行凭证构造和更改的安全检查时改变进程的 `ptrace` 状态，因为 `ptrace` 状态可能会改变结果，特别是在 `execve()` 的情况下。

新设置的凭证应适当调整，并执行任何安全检查和钩子。当前和提议的凭证集均可用于此目的，因为在这一点上 `current_cred()` 仍会返回当前的凭证集。

在替换组列表时，新列表必须先排序才能添加到凭证中，因为使用二分查找来测试成员资格。实际上，这意味着在调用 `set_groups()` 或 `set_current_groups()` 之前应该调用 `groups_sort()`。

`groups_sort()` 不得对共享的 `struct group_list` 调用，因为它可能作为排序过程的一部分重新排列元素，即使数组已经排好序。

当凭证集准备好后，应通过调用以下函数将其提交到当前进程：

```c
int commit_creds(struct cred *new);
```

这将改变凭证和进程的各个方面，并给 LSM 提供一个相应的机会，然后它将使用 `rcu_assign_pointer()` 将新的凭证实际提交到 `current->cred`，释放 `current->cred_replace_mutex` 以允许 `ptrace()` 进行，并通知调度程序和其他组件这些更改。

该函数保证返回 0，因此可以在诸如 `sys_setresuid()` 之类的函数末尾尾调用它。

请注意，此函数会消耗调用者对新凭证的引用。调用者不应在之后对新凭证调用 `put_cred()`。

此外，一旦此函数对一组新的凭证调用后，这些凭证不得进一步更改。

如果在调用 `prepare_creds()` 之后安全检查失败或发生其他错误，则应调用以下函数：

```c
void abort_creds(struct cred *new);
```

这将释放 `prepare_creds()` 获取的 `current->cred_replace_mutex` 锁，并释放新的凭证。
典型的凭证修改函数可能如下所示：

```c
int alter_suid(uid_t suid)
{
    struct cred *new;
    int ret;

    new = prepare_creds();
    if (!new)
        return -ENOMEM;

    new->suid = suid;
    ret = security_alter_suid(new);
    if (ret < 0) {
        abort_creds(new);
        return ret;
    }

    return commit_creds(new);
}
```

### 管理凭证

以下是一些帮助管理凭证的函数：

- `void put_cred(const struct cred *cred);`

    该函数释放给定凭证集的引用。如果引用计数变为零，则凭证将被RCU系统安排销毁。

- `const struct cred *get_cred(const struct cred *cred);`

    该函数获取一个活动凭证集的引用，并返回指向该凭证集的指针。

- `struct cred *get_new_cred(struct cred *cred);`

    该函数获取一个正在构建中的凭证集的引用（因此仍然是可变的），并返回指向该凭证集的指针。

### 文件打开凭证

当打开新文件时，会获取打开任务的凭证引用，并将其作为`f_cred`附加到文件结构中，以替代`f_uid`和`f_gid`。以前访问`file->f_uid`和`file->f_gid`的代码现在应该访问`file->f_cred->fsuid`和`file->f_cred->fsgid`。
由于指针在其生命周期内不会改变，且所指向的凭证结构的内容也不会改变（除了上述例外情况，请参见任务凭证部分），因此可以安全地访问`f_cred`而无需使用RCU或锁定。
为了避免“困惑副手”特权升级攻击，在对已打开文件进行后续操作时，应使用这些凭证而不是“当前”的凭证，因为文件可能已被传递给权限更高的进程。

### 覆盖VFS的凭证使用

在某些情况下，希望覆盖VFS使用的凭证，可以通过调用如`vfs_mkdir()`并传入不同的凭证集来实现。这在以下地方完成：

- `sys_faccessat()`
- `do_coredump()`
- `nfs4recover.c`
