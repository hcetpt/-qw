=== 
Linux 中的凭证
===

作者：David Howells <dhowells@redhat.com>

.. contents:: 目录
   :local:

概述
=====

Linux 在一个对象对另一个对象进行操作时执行的安全检查包含几个部分：

 1. 对象
对象是系统中的实体，可以直接被用户空间程序操作。Linux 包含多种可操作的对象，例如：

    - 任务
    - 文件/节点
    - 套接字
    - 消息队列
    - 共享内存段
    - 信号量
    - 密钥

在所有这些对象的描述中都有一组凭证。这组凭证的内容取决于对象的类型。
2. 对象所有权
大多数对象的凭证中会有一个子集来指示该对象的所有权。这个所有权用于资源的核算和限制（例如磁盘配额和任务rlimit）。
在标准的UNIX文件系统中，例如，这将由节点上标记的UID定义。
3. 目标上下文
同样在这些对象的凭证中也会有一个子集来指示该对象的“目标上下文”。这个上下文可能与第2点中的相同也可能不同——在标准的UNIX文件中，这是由节点上标记的UID和GID定义的。
目标上下文是在一个对象被操作时进行安全计算的一部分。
4. 主体
主体是一个正在对另一个对象进行操作的对象。
系统中的大多数对象是不活动的：它们不对系统内的其他对象采取行动。进程/任务是明显的例外：它们执行操作；访问并操纵事物。
除了任务之外的其他对象，在某些情况下也可能成为主体。例如，一个打开的文件可能会根据调用`fcntl(F_SETOWN)`的进程所提供的UID和EUID向该进程发送SIGIO信号。在这种情况下，文件结构也会有一个主观上下文。
5. 主观上下文
主体对其凭证有额外的解释。其凭证的一个子集形成了“主观上下文”。在主体采取行动时进行的安全计算中会使用到主观上下文。
例如，Linux任务在处理文件时具有FSUID、FSGID和补充组列表——这些与通常形成任务客观上下文的真实UID和GID是完全独立的。
6. 行动
对于主体可以在对象上执行的一系列行动，Linux提供了多种选择。可用的行动集合取决于主体和对象的性质。
这些行动包括读取、写入、创建和删除文件；以及对进程进行分叉、发送信号或跟踪。
7. 规则、访问控制列表和安全计算
当一个主体对客体执行操作时，会进行一次安全计算。这涉及到采用主观上下文、客观上下文以及操作，并搜索一套或多套规则以确定在给定这些上下文的情况下，主体是否被授予或拒绝以期望的方式对客体进行操作。规则主要有两个来源：

a. 自主访问控制（DAC）：

    有时客体的描述中会包含一套或多套规则。这就是“访问控制列表”或“ACL”。例如，在Linux文件系统中，一个文件可以包含多于一个ACL。
传统的UNIX文件包括权限掩码，这是一种简化的ACL，具有三个固定的主体类别（即“用户”，“组”和“其他”），每个类别可以被赋予特定权限（如“读取”，“写入”和“执行”——具体取决于对于该对象而言这些权限意味着什么）。然而，UNIX文件权限不允许随意指定主体，因此其用途有限。
Linux文件还可能拥有POSIX ACL。这是一个规则列表，可以为任意主体授予各种权限。

b. 强制访问控制（MAC）：

    整个系统可能有一套或多套规则应用于所有主体和客体，无论它们的来源如何。
SELinux和Smack就是这种类型的例子。
在SELinux和Smack的情况下，每个对象在其凭证中都会有一个标签。当请求执行某个操作时，它们会根据主体标签、客体标签和操作来查找相应的规则，以确定该操作是被允许还是被禁止。

### 凭证类型

#### Linux内核支持的凭证类型如下：

1. 传统的UNIX凭证
   - 实际用户ID
   - 实际组ID

     UID和GID几乎由所有的Linux对象携带，即使在某些情况下需要创建它们（例如，从Windows衍生出的FAT或CIFS文件）。这些（主要）定义了该对象的客观上下文，而对于任务来说则略有不同。

   - 有效用户ID、保存用户ID和文件系统用户ID
   - 有效组ID、保存组ID和文件系统组ID
   - 补充组

     这些额外的凭证仅用于任务。通常，EUID/EGID/GROUPS作为主观上下文使用，而实际的UID/GID作为客观上下文使用。需要注意的是，对于任务而言，情况并非总是如此。
2. 能力（权限）
- 允许的能力集
    - 可继承的能力集
    - 有效的能力集
    - 能力边界集

这些仅由任务携带。它们表示通过零碎方式授予任务的高级权限，而普通任务通常不会有这些权限。
这些可以通过对传统UNIX凭证的更改来隐式地进行操作，也可以通过`capset()`系统调用直接进行操作。
允许的能力是指进程可能通过`capset()`授予自身有效或允许集中的那些权限。这个可继承的集合也可能受到类似的限制。
有效的权限是任务实际上可以自行利用的权限。
可继承的权限是可以透过`execve()`传递的权限。
边界集限制了可以通过`execve()`继承的权限，特别是在执行UID为0的二进制文件时。

3. 安全管理标志（securebits）
这些仅由任务携带。这些标志控制上述凭证在某些操作（如`execve()`）中的操纵和继承方式。它们不是直接作为客观或主观凭证使用。

4. 密钥和密钥环
这些仅由任务持有。它们携带并缓存那些不符合标准UNIX凭证的安全令牌。它们的作用是让进程执行文件访问时能够使用诸如网络文件系统密钥之类的信息，而无需普通程序了解涉及的安全细节。
密钥环是一种特殊的密钥。它们携带其他密钥的集合，并可以被搜索以找到所需的密钥。每个进程可以订阅多个密钥环：

- 每线程密钥
- 每进程密钥环
- 每会话密钥环

当一个进程访问一个密钥时，如果该密钥尚未存在，则通常会在这些密钥环之一中被缓存起来供未来的访问查找。
有关使用密钥的更多信息，请参阅“Documentation/security/keys/*”
5. LSM（Linux安全模块）

Linux安全模块允许对任务可能执行的操作施加额外的控制。目前Linux支持几种LSM选项。
其中一些通过标记系统中的对象然后应用一组规则（策略）来工作，这些规则说明了一个标签的任务可以对另一个标签的对象执行哪些操作。
6. AF_KEY

这是一种基于套接字的方法，用于管理网络堆栈的身份凭证[RFC 2367]。本文档不讨论它，因为它并不直接与任务和文件凭证交互；相反，它维护系统级的凭证。
当打开一个文件时，打开任务的部分主观上下文会被记录在创建的文件结构中。这使得使用该文件结构的操作可以使用那些凭证，而不是执行操作的任务的主观上下文。一个例子是在网络文件系统上打开的文件，无论谁实际进行读或写操作，都应向服务器呈现打开文件的凭证。
文件标记
==========

磁盘上的文件或从网络获取的文件可能有注释，这些注释构成了文件的目标安全性上下文。根据文件系统的类型，这可能包括以下一项或多项目：

* UNIX用户ID、组ID、模式；
* Windows用户ID；
* 访问控制列表；
* LSM安全标签；
* UNIX执行权限提升位（SUID/SGID）；
* 文件能力执行权限提升位

这些将与任务的主观安全性上下文进行比较，根据结果允许或禁止某些操作。在execve()的情况下，权限提升位开始发挥作用，并可能根据可执行文件上的注释赋予产生的进程额外权限。
任务凭证
================

在Linux中，任务的所有凭证都保存在(uid, gid)或者通过(groups, keys, LSM security)这种形式的引用计数结构中，类型为'struct cred'。
每个任务通过其`task_struct`中的一个名为'cred'的指针指向它的凭证。一旦一组凭证被准备并提交，除了以下几种情况外，这些凭证不得更改：

1. 它的引用计数可以改变；

2. 它所指向的`group_info`结构的引用计数可以改变；

3. 它所指向的安全数据的引用计数可以改变；

4. 它所指向的任何密钥环的引用计数可以改变；

5. 可以撤销、使过期或更改它所指向的任何密钥环的安全属性；以及

6. 可以更改它所指向的任何密钥环的内容（密钥环的目的就是共享一组可由具有适当访问权限的任何人修改的凭证）。
要更改`cred`结构中的任何内容，必须遵循复制和替换原则。首先复制，然后更改副本，最后使用RCU来更改任务指针，使其指向新的副本。有一些封装函数可以帮助完成这一过程（参见下面）。
一个任务只能更改它自己的凭证；不再允许一个任务更改其他任务的凭证。这意味着`capset()`系统调用不再允许接受当前进程以外的任何PID。同样，`keyctl_instantiate()`和`keyctl_negate()`函数也不再允许连接到请求进程中特定于进程的密钥环，因为实例化进程可能需要创建它们。

### 不可变凭证

一旦一组凭证被公开（例如，通过调用`commit_creds()`），除了两种情况外，应认为它是不可变的：

1. 引用计数可以更改；
2. 虽然一组凭证的密钥环订阅不能更改，但所订阅的密钥环的内容可以更改。

为了在编译时捕获意外的凭证更改，`struct task_struct`和`struct file`中的凭证集指针是_const_类型的。此外，某些函数如`get_cred()`和`put_cred()`操作_const_指针，这样就不需要类型转换，但需要暂时取消_const_限定以便更改引用计数。

### 访问任务凭证

一个任务只能更改它自己的凭证，这使得当前进程可以在无需任何形式锁定的情况下读取或替换它自己的凭证——这极大地简化了事情。它可以简单地调用：

```c
const struct cred *current_cred();
```

来获取指向其凭证结构的指针，并且之后不必释放它。

还有一些方便的封装函数用于检索任务凭证的具体方面（每个情况下直接返回值）：

```c
uid_t current_uid(void);		// 当前的真实UID
gid_t current_gid(void);		// 当前的真实GID
uid_t current_euid(void);	// 当前的有效UID
gid_t current_egid(void);	// 当前的有效GID
uid_t current_fsuid(void);	// 当前的文件访问UID
gid_t current_fsgid(void);	// 当前的文件访问GID
kernel_cap_t current_cap(void);	// 当前的有效权限
struct user_struct *current_user(void);  // 当前的用户账户
```

还有方便的封装函数用于检索任务凭证的具体关联对：

```c
void current_uid_gid(uid_t *, gid_t *);
void current_euid_egid(uid_t *, gid_t *);
void current_fsuid_fsgid(uid_t *, gid_t *);
```

这些函数通过它们的参数返回这些值对，从当前任务的凭证中获取这些值。

此外，还有一个函数用于获取当前进程当前凭证集的引用：

```c
const struct cred *get_current_cred(void);
```

以及获取不属于`struct cred`的一部分的凭证的引用的函数：

```c
struct user_struct *get_current_user(void);
struct group_info *get_current_groups(void);
```

这些函数分别获取当前进程的用户会计结构和补充组列表的引用。
一旦获取了引用，必须使用`put_cred()`、`free_uid()`或`put_group_info()`适当释放。

访问其他任务的凭证
--------------------
虽然一个任务无需锁定即可访问自己的凭证，但访问另一个任务的凭证则不同。它必须使用RCU读锁和`rcu_dereference()`。
`rcu_dereference()`被以下函数封装：

```c
const struct cred *__task_cred(struct task_struct *task);
```

这应该在RCU读锁内部使用，如下例所示：

```c
void foo(struct task_struct *t, struct foo_data *f)
{
    const struct cred *tcred;
    ..
    rcu_read_lock();
    tcred = __task_cred(t);
    f->uid = tcred->uid;
    f->gid = tcred->gid;
    f->groups = get_group_info(tcred->groups);
    rcu_read_unlock();
    ..
}
```

如果需要长时间持有另一个任务的凭证，并且可能在此期间休眠，则调用者应使用以下方式获取该凭证的引用：

```c
const struct cred *get_task_cred(struct task_struct *task);
```

这在内部实现了所有RCU魔法。当完成使用时，调用者必须对所获得的凭证调用`put_cred()`。
**注意：**
不要将`__task_cred()`的结果直接传递给`get_cred()`，因为这可能会与`commit_cred()`发生竞态。

为了方便地访问其他任务凭证的部分内容，隐藏了RCU魔法，提供了一些便利函数：

```c
uid_t task_uid(task)       //任务的真实UID
uid_t task_euid(task)      //任务的有效UID
```

如果调用者已经持有RCU读锁，则应使用：

```c
__task_cred(task)->uid
__task_cred(task)->euid
```

如果需要访问任务凭证的多个方面，应使用RCU读锁，调用`__task_cred()`，将结果存储在一个临时指针中，然后从该指针中调用凭证方面的信息，在释放锁之前完成这些操作。这样可以避免多次触发可能代价高昂的RCU魔法。

如果需要访问另一个任务凭证的某个单一方面，可以使用：

```c
task_cred_xxx(task, member)
```

其中'member'是`struct cred`中的非指针成员。例如：

```c
uid_t task_cred_xxx(task, suid);
```

将从任务中检索`struct cred::suid`，并执行适当的RCU魔法。此方法不能用于指针成员，因为它们指向的内容可能在RCU读锁被释放的那一刻消失。

更改凭证
--------------------
如前所述，一个任务只能更改自己的凭证，而不能更改其他任务的凭证。这意味着它不需要使用任何锁定来更改自己的凭证。

要更改当前进程的凭证，一个函数首先应通过调用以下函数准备新的凭证集：

```c
struct cred *prepare_creds(void);
```

这会锁定`current->cred_replace_mutex`，然后分配并构造当前进程凭证的副本，如果成功则返回时仍持有互斥锁。如果不成功（内存不足）则返回NULL。
互斥锁防止 `ptrace()` 在进行凭证构造和变更的安全检查时改变进程的 `ptrace` 状态，因为 `ptrace` 状态可能会影响结果，特别是在 `execve()` 的情况下。
新设置的凭证应适当地调整，并且应完成任何安全检查和挂钩操作。当前和提议的凭证集都可用于此目的，因为在这一点上 `current_cred()` 仍会返回当前的凭证集。
在替换组列表时，新列表必须先排序才能添加到凭证中，因为使用二分查找来测试成员资格。实际上，这意味着在调用 `set_groups()` 或 `set_current_groups()` 之前应该调用 `groups_sort()`。
不应在共享的 `struct group_list` 上调用 `groups_sort()`，因为它作为排序过程的一部分可能会置换元素，即使数组已经排好序。
当凭证集准备就绪后，应通过调用以下函数将其提交给当前进程：

```c
int commit_creds(struct cred *new);
```

这将更改凭证和进程的各个方面，并给 LSM 提供相应的机会，然后它将使用 `rcu_assign_pointer()` 实际上把新的凭证提交给 `current->cred`，释放 `current->cred_replace_mutex` 以允许 `ptrace()` 进行，并通知调度器和其他实体这些变化。
该函数保证返回 0，因此可以在诸如 `sys_setresuid()` 这样的函数的末尾尾调用它。
请注意，此函数会消耗调用者对新凭证的引用。调用者之后 **不应** 对新凭证调用 `put_cred()`。
此外，一旦此函数在一个新凭证集上调用过，这些凭证就 **不得** 再做进一步修改。
如果在调用 `prepare_creds()` 之后安全检查失败或其他错误发生，则应调用以下函数：

```c
void abort_creds(struct cred *new);
```

这会释放 `prepare_creds()` 获得的 `current->cred_replace_mutex` 锁，并释放新凭证。
一个典型的凭证修改函数可能如下所示：

	```c
	int alter_suid(uid_t suid)
	{
		struct cred *new;
		int ret;

		new = prepare_creds();
		if (!new)
			return -ENOMEM;

		new->suid = suid;
		ret = security_alter_suid(new);
		if (ret < 0) {
			abort_creds(new);
			return ret;
		}

		return commit_creds(new);
	}
	```

### 管理凭证

有一些函数可以帮助管理凭证：

- `void put_cred(const struct cred *cred);`

    这个函数释放给定凭证集的引用。如果引用计数降到零，这些凭证将被RCU系统安排销毁。
- `const struct cred *get_cred(const struct cred *cred);`

    这个函数获取活动凭证集的一个引用，并返回指向该凭证集的指针。
- `struct cred *get_new_cred(struct cred *cred);`

    这个函数获取正在构建中且因此仍然可变的凭证集的一个引用，并返回指向该凭证集的指针。

### 文件打开凭证

当新文件被打开时，会获取打开任务的凭证的引用，并将其作为`f_cred`附加到文件结构中，代替`f_uid`和`f_gid`。以前使用`file->f_uid`和`file->f_gid`的代码现在应该访问`file->f_cred->fsuid`和`file->f_cred->fsgid`。
安全地访问`f_cred`无需使用RCU或锁定，因为该指针在其生命周期内不会改变，指向的`cred`结构的内容也不会改变（除了上面列出的一些特殊情况，请参阅任务凭证部分）。
为了避免“困惑副手”权限提升攻击，在对已打开文件进行后续操作时执行访问控制检查应使用这些凭证，而不是使用"当前"进程的凭证，因为文件可能已被传递给权限更高的进程。

### 覆盖VFS使用的凭证

在某些情况下，希望覆盖VFS使用的凭证，这可以通过使用不同的凭证调用诸如`vfs_mkdir()`等函数来实现。这在以下地方完成：

- `sys_faccessat()`
- `do_coredump()`
- `nfs4recover.c`
