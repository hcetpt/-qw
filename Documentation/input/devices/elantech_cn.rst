Elantech 触摸板驱动程序
========================

版权所有 (C) 2007-2008 Arjan Opmeer <arjan@opmeer.net>

硬件版本 1 的附加信息由 Steve Havelka 提供

硬件版本 2（EeePC）的支持基于来自 Xandros 的 Woody 提供的补丁，并通过 eeeuser.com 论坛用户 StewieGriffin 转发给我

.. 目录

 1. 引言
 2. 附加选项
 3. 区分硬件版本
 4. 硬件版本 1
    4.1 寄存器
    4.2 本机相对模式 4 字节数据包格式
    4.3 本机绝对模式 4 字节数据包格式
 5. 硬件版本 2
    5.1 寄存器
    5.2 本机绝对模式 6 字节数据包格式
        5.2.1 奇偶校验和数据包重新同步
        5.2.2 单指/三指触摸
        5.2.3 双指触摸
 6. 硬件版本 3
    6.1 寄存器
    6.2 本机绝对模式 6 字节数据包格式
        6.2.1 单指/三指触摸
        6.2.2 双指触摸
 7. 硬件版本 4
    7.1 寄存器
    7.2 本机绝对模式 6 字节数据包格式
        7.2.1 状态数据包
        7.2.2 头部数据包
        7.2.3 运动数据包
 8. 轨点（适用于硬件版本 3 和 4）
    8.1 寄存器
    8.2 本机相对模式 6 字节数据包格式
        8.2.1 状态数据包

引言
~~~~~~~~~~~~

目前，Linux Elantech 触摸板驱动程序支持四种不同的硬件版本，分别为版本 1、版本 2、版本 3 和版本 4。版本 1 在“较旧”的笔记本电脑中使用，每包 4 字节。版本 2 似乎是在 EeePC 中引入的，每包 6 字节，并提供了额外的功能，如双指位置和触摸宽度。硬件版本 3 每包 6 字节（对于双指是两个 6 字节数据包的拼接），并允许追踪多达 3 根手指。硬件版本 4 每包 6 字节，并可以将一个状态数据包与多个头部或运动数据包组合在一起。硬件版本 4 允许追踪多达 5 根手指。
一些硬件版本 3 和版本 4 还具有单独的数据包格式的轨点。它也是每包 6 字节。
驱动程序试图支持这两种硬件版本，并且应该与 Xorg Synaptics 触摸板驱动程序及其图形配置工具兼容。
请注意，当有轨点时，鼠标按钮也可以关联到触摸板或轨点。在 Xorg 中禁用触摸板（TouchPadOff=0）也会禁用与触摸板相关的按钮。
此外，通过调整触摸板内部寄存器的内容，可以改变触摸板的操作。这些寄存器由驱动程序表示为 /sys/bus/serio/drivers/psmouse/serio? 下的 sysfs 条目，可以从这些条目读取和写入内容。
目前，只有硬件版本 1 的寄存器被部分理解。硬件版本 2 似乎使用了一些相同的寄存器，但寄存器中的位是否代表相同的事物或可能已经改变了意义尚不清楚。
除此之外，某些寄存器设置仅在触摸板处于相对模式时有效，而不是在绝对模式下。由于 Linux Elantech 触摸板驱动程序始终将硬件置于绝对模式，因此下面提到的所有信息不能立即使用。但由于没有免费的 Elantech 文档，为了完整性，这里仍然提供了这些信息。

附加选项
~~~~~~~~~~~

目前，Linux Elantech 触摸板驱动程序在 /sys/bus/serio/drivers/psmouse/serio? 下为用户提供三个附加选项：
* debug

   打开或关闭不同级别的调试
通过向此文件写入“0”，将关闭所有调试。
目前，值为“1”将开启一些基本的调试，而值为“2”将开启数据包调试。对于硬件版本1，默认是关闭的；对于版本2，默认是“1”。
开启数据包调试会使驱动程序在处理之前将每个接收到的数据包转储到系统日志中。请注意，这可能会生成大量数据！

* paritycheck

   开启或关闭奇偶校验
通过向此文件写入“0”，将关闭奇偶校验。任何非零值都会将其打开。对于硬件版本1，默认是开启的；对于版本2，默认是关闭的。
硬件版本1通过计算每个数据包最后3个字节的奇偶位来提供基本的数据完整性验证。驱动程序可以检查这些位并拒绝任何看起来已损坏的数据包。使用这个选项，您可以绕过该检查。
硬件版本2不提供相同的奇偶位。只能进行一些基本的数据一致性检查。目前，默认情况下检查是关闭的。即使开启它，目前也不会有任何作用。

* crc_enabled

   设置 crc_enabled 为 0 或 1。尽管这不是实际的循环冗余校验，“crc_enabled”是这种完整性检查的官方名称。
根据 crc_enabled 的状态，驱动程序会在硬件版本3和4上执行某些基本的数据完整性验证。驱动程序会拒绝任何看起来已损坏的数据包。使用这个选项，可以更改 crc_enabled 的状态。
读取 crc_enabled 的值将显示当前活动的值。向此文件写入“0”或“1”将设置状态为“0”或“1”。
硬件版本区分
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了检测硬件版本，读取版本号作为param[0].param[1].param[2]：

4字节版本：（箭头后是Dell提供的驱动程序中给出的名称）
02.00.22 => EF013
02.06.00 => EF019

在实际使用中，似乎有更多的版本，例如 00.01.64、01.00.21、02.00.00、02.00.04、02.00.06：

6字节：
02.00.30 => EF113
02.08.00 => EF023
02.08.XX => EF123
02.0B.00 => EF215
04.01.XX => Scroll_EF051
04.02.XX => EF051

在实际使用中，似乎有更多的版本，例如 04.03.01、04.04.11。除了EF113之外，几乎没有任何差异，它不报告压力/宽度，并且有不同的数据一致性检查。
很可能所有 param[0] <= 01 的版本都可以认为是4字节固件1。版本 < 02.08.00（除 02.00.30 外）可以认为是4字节固件2。所有 >= 02.08.00 的版本都可以认为是6字节。

硬件版本1
~~~~~~~~~~~~~~~~~~

寄存器
-------

通过向寄存器回显一个十六进制值来更改其内容，例如：
```
echo -n 0x16 > reg_10
```

* reg_10：

   位 7 6 5 4 3 2 1 0
         B C T D L A S E

         E: 1 = 无条件启用智能边缘
         S: 1 = 拖动时启用智能边缘
         A: 1 = 绝对模式（需要4字节数据包，参见 reg_11）
         L: 1 = 启用拖动锁定（参见 reg_22）
         D: 1 = 禁用动态分辨率
         T: 1 = 禁用轻触
         C: 1 = 启用角落轻触
         B: 1 = 交换左右按钮

* reg_11：

   位 7 6 5 4 3 2 1 0
         1 0 0 H V 1 F P

         P: 1 = 启用相对模式的奇偶校验
         F: 1 = 启用原生4字节数据包模式
         V: 1 = 启用垂直滚动区域
         H: 1 = 启用水平滚动区域

* reg_20：

         单指宽度？

* reg_21：

         滚动区域宽度（小：0x40 ... 宽：0xff）

* reg_22：

         拖动锁定超时时间（短：0x14 ... 长：0xfe；
                                 0xff = 再次轻触以释放）

* reg_23：

         轻触生成超时？

* reg_24：

         轻触释放超时？

* reg_25：

         智能边缘光标速度（0x02 = 慢，0x03 = 中等，0x04 = 快）

* reg_26：

         智能边缘激活区域宽度？

原生相对模式4字节数据包格式
-----------------------------------------

字节 0：

   位 7 6 5 4 3 2 1 0
         c c p2 p1 1 M R L

         L, R, M = 当左、右、中间鼠标按钮被按下时为1
            一些模型将M作为字节 3 的奇偶校验位
         当启用奇偶校验检查（reg_11, P = 1）时：
            p1..p2 = 字节 1 和 2 的奇偶校验位
         c = 当检测到角落轻触时为1

字节 1：

   位 7 6 5 4 3 2 1 0
        dx7 dx6 dx5 dx4 dx3 dx2 dx1 dx0

         dx7..dx0 = X轴移动；正 = 右，负 = 左
         字节 1 = 当检测到角落轻触时为 0xf0

字节 2：

   位 7 6 5 4 3 2 1 0
        dy7 dy6 dy5 dy4 dy3 dy2 dy1 dy0

         dy7..dy0 = Y轴移动；正 = 上，负 = 下

字节 3：

   启用奇偶校验检查（reg_11, P = 1）：

      位 7 6 5 4 3 2 1 0
            w h n1 n0 ds3 ds2 ds1 ds0

            通常：
               ds3..ds0 = 滚轮数量和方向
                          正 = 向下或向左
                          负 = 向上或向右
            当检测到角落轻触时：
               ds0 = 当右上角被轻触时为1
               ds1 = 当右下角被轻触时为1
               ds2 = 当左下角被轻触时为1
               ds3 = 当左上角被轻触时为1
            n1..n0 = 触摸板上的手指数量
               只有固件2.x版本会报告这个，固件1.x版本似乎会直接将单指、双指和三指轻触映射到L、M和R鼠标按钮
            h = 当进行水平滚动操作时为1
            w = 当宽手指触摸时为1？

   否则（reg_11, P = 0）：

      位 7 6 5 4 3 2 1 0
           ds7 ds6 ds5 ds4 ds3 ds2 ds1 ds0

            ds7..ds0 = 垂直滚动的数量和方向
                       负 = 向上
                       正 = 向下

原生绝对模式4字节数据包格式
-----------------------------------------

EF013 和 EF019 有一个特殊行为（可能是由于固件中的一个bug？），当1个手指触摸时，前两次位置报告必须丢弃。
每当报告不同数量的手指时，此计数都会重置
字节 0：

   固件版本 1.x：

      位 7 6 5 4 3 2 1 0
            D U p1 p2 1 p3 R L

            L, R = 当左、右鼠标按钮被按下时为1
            p1..p3 = 字节 1..3 的奇偶校验位
            D, U = 当摇杆开关被按下时为1（向上、向下）

   固件版本 2.x：

      位 7 6 5 4 3 2 1 0
           n1 n0 p2 p1 1 p3 R L

            L, R = 当左、右鼠标按钮被按下时为1
            p1..p3 = 字节 1..3 的奇偶校验位
            n1..n0 = 触摸板上的手指数量

字节 1：

   固件版本 1.x：

      位 7 6 5 4 3 2 1 0
            f 0 th tw x9 x8 y9 y8

            tw = 当两指触摸时为1
            th = 当三指触摸时为1
            f = 当单指触摸时为1

   固件版本 2.x：

      位 7 6 5 4 3 2 1 0
            . . . . x9 x8 y9 y8

字节 2：

   位 7 6 5 4 3 2 1 0
        x7 x6 x5 x4 x3 x2 x1 x0

         x9..x0 = 绝对X坐标（水平）

字节 3：

   位 7 6 5 4 3 2 1 0
        y7 y6 y5 y4 y3 y2 y1 y0

         y9..y0 = 绝对Y坐标（垂直）

硬件版本2
~~~~~~~~~~~~~~~~~~

寄存器
-------

通过向寄存器回显一个十六进制值来更改其内容，例如：
```
echo -n 0x56 > reg_10
```

* reg_10：

   位 7 6 5 4 3 2 1 0
         0 1 0 1 0 1 D 0

         D: 1 = 启用拖放功能

* reg_11：

   位 7 6 5 4 3 2 1 0
         1 0 0 0 S 0 1 0

         S: 1 = 启用垂直滚动

* reg_21：

         未知（0x00）

* reg_22：

         拖放释放超时时间（短：0x70 ... 长 0x7e；
                                   0x7f = 永不，即再次轻触以释放）

原生绝对模式6字节数据包格式
-----------------------------------------

奇偶校验检查和数据包重新同步
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

没有奇偶校验检查，但是可以执行一些一致性检查
例如对于 EF113：

```
        SA1= 数据包[0];
        A1 = 数据包[1];
        B1 = 数据包[2];
        SB1= 数据包[3];
        C1 = 数据包[4];
        D1 = 数据包[5];
        if( (((SA1 & 0x3C) != 0x3C) && ((SA1 & 0xC0) != 0x80)) || // 检查字节 1
            (((SA1 & 0x0C) != 0x0C) && ((SA1 & 0xC0) == 0x80)) || // 检查字节 1（一指按压）
            (((SA1 & 0xC0) != 0x80) && ((A1 & 0xF0) != 0x00)) || // 检查字节 2
            (((SB1 & 0x3E) != 0x38) && ((SA1 & 0xC0) != 0x80)) || // 检查字节 4
            (((SB1 & 0x0E) != 0x08) && ((SA1 & 0xC0) == 0x80)) || // 检查字节 4（一指按压）
            (((SA1 & 0xC0) != 0x80) && ((C1 & 0xF0) != 0x00))  ) // 检查字节 5
        // 错误检测
```

对于其他所有的数据包，只有几个常量位：

```
        if( ((数据包[0] & 0x0C) != 0x04) ||
            ((数据包[3] & 0x0f) != 0x02) )
        // 错误检测
```

如果检测到错误，则所有数据包向后移一位（并丢弃数据包[0]）
单/三指触摸
^^^^^^^^^^^^^^^^^^^^^^

字节 0：

   位 7 6 5 4 3 2 1 0
       n1 n0 w3 w2 . . R L

         L, R = 当左、右鼠标按钮被按下时为1
         n1..n0 = 触摸板上的手指数量

字节 1：

   位 7 6 5 4 3 2 1 0
       p7 p6 p5 p4 x11 x10 x9 x8

字节 2：

   位 7 6 5 4 3 2 1 0
       x7 x6 x5 x4 x3 x2 x1 x0

         x11..x0 = 绝对X坐标（水平）

字节 3：

   位 7 6 5 4 3 2 1 0
       n4 vf w1 w0 . . . b2

       n4 = 如果超过3个手指（仅在三指模式下）
       vf = 一种标志？（仅在 EF123 上，当手指位于任一按钮上方时为0，否则为1）
       w3..w0 = 触摸的宽度（不适用于 EF113）
       b2（仅适用于 EF113，否则为0），b2.R.L 表示一个按钮被按下：
          0 = 无
          1 = 左
          2 = 右
          3 = 中间（左和右）
          4 = 前进
          5 = 后退
          6 = 另一个
          7 = 另一个

字节 4：

   位 7 6 5 4 3 2 1 0
       p3 p1 p2 p0 y11 y10 y9 y8

       p7..p0 = 压力（不适用于 EF113）

字节 5：

   位 7 6 5 4 3 2 1 0
       y7 y6 y5 y4 y3 y2 y1 y0

         y11..y0 = 绝对Y坐标（垂直）

双指触摸
^^^^^^^^^^^^

请注意，这两组坐标并不是两个手指的确切坐标，而是左下和右上坐标的组合。
因此，实际的手指可能会位于这两个点定义的正方形的另一条对角线上。
字节 0::

   位   7   6   5   4   3   2   1   0
        n1  n0  ay8 ax8  .   .   R   L

         L, R = 当左键、右键鼠标按下时为 1
         n1..n0 = 触控板上的手指数量

字节 1::

   位   7   6   5   4   3   2   1   0
        ax7 ax6 ax5 ax4 ax3 ax2 ax1 ax0

	 ax8..ax0 = 左下角手指的绝对X坐标值

字节 2::

   位   7   6   5   4   3   2   1   0
        ay7 ay6 ay5 ay4 ay3 ay2 ay1 ay0

	 ay8..ay0 = 左下角手指的绝对Y坐标值

字节 3::

   位   7   6   5   4   3   2   1   0
         .   .  by8 bx8  .   .   .

字节 4::

   位   7   6   5   4   3   2   1   0
        bx7 bx6 bx5 bx4 bx3 bx2 bx1 bx0

         bx8..bx0 = 右上角手指的绝对X坐标值

字节 5::

   位   7   6   5   4   3   2   1   0
        by7 by8 by5 by4 by3 by2 by1 by0

         by8..by0 = 右上角手指的绝对Y坐标值

硬件版本 3
~~~~~~~~~~~~~~~~~~

寄存器
---------

* reg_10::

   位   7   6   5   4   3   2   1   0
         0   0   0   0   R   F   T   A

         A: 1 = 启用绝对追踪
         T: 1 = 启用两指模式自动校正
         F: 1 = 禁用ABS位置滤波器
         R: 1 = 启用真实硬件分辨率

原生绝对模式 6 字节数据包格式
-----------------------------------------

1 指和 3 指触摸共享相同的 6 字节数据包格式，不同之处在于
3 指触摸仅报告三个手指中心的位置
固件会发送 12 字节的数据用于两指触摸
关于去抖动的说明：
在设备电源不稳定或其他电力问题的情况下，或者当手指数量发生变化时，固件会发送“去抖动数据包”以告知驱动程序硬件处于去抖动状态
去抖动数据包的签名如下：

    字节 0: 0xc4
    字节 1: 0xff
    字节 2: 0xff
    字节 3: 0x02
    字节 4: 0xff
    字节 5: 0xff

当我们遇到这种数据包时，我们直接忽略它
单指/三指触摸
^^^^^^^^^^^^^^^^^^^^^^

字节 0::

   位   7   6   5   4   3   2   1   0
        n1  n0  w3  w2   0   1   R   L

        L, R = 当左键、右键鼠标按下时为 1
        n1..n0 = 触控板上的手指数量

字节 1::

   位   7   6   5   4   3   2   1   0
        p7  p6  p5  p4 x11 x10  x9  x8

字节 2::

   位   7   6   5   4   3   2   1   0
        x7  x6  x5  x4  x3  x2  x1  x0

        x11..x0 = 绝对X坐标值（水平）

字节 3::

   位   7   6   5   4   3   2   1   0
         0   0  w1  w0   0   0   1   0

         w3..w0 = 触摸手指的宽度

字节 4::

   位   7   6   5   4   3   2   1   0
        p3  p1  p2  p0  y11 y10 y9  y8

        p7..p0 = 压力

字节 5::

   位   7   6   5   4   3   2   1   0
        y7  y6  y5  y4  y3  y2  y1  y0

        y11..y0 = 绝对Y坐标值（垂直）

两指触摸
^^^^^^^^^^^^^^^^

两指触摸的数据包格式与单指触摸完全相同，不同之处在于硬件发送两个 6 字节数据包。第一个数据包包含第一个手指的数据，第二个数据包包含第二个手指的数据。因此，对于两指触摸，总共发送 12 字节
硬件版本 4
~~~~~~~~~~~~~~~~~~

寄存器
---------

* reg_07::

   位   7   6   5   4   3   2   1   0
         0   0   0   0   0   0   0   A

         A: 1 = 启用绝对追踪

原生绝对模式 6 字节数据包格式
-----------------------------------------

v4 硬件是一个真正的多点触控触控板，能够追踪最多 5 个手指
不幸的是，由于 PS/2 的带宽限制，其数据包格式较为复杂
每当手指的数量或身份发生变化时，硬件会发送一个状态数据包来指示有多少个手指以及哪些手指位于触控板上，随后是头部数据包或运动数据包。头部数据包包含手指ID、手指位置（绝对X、Y坐标）、宽度和压力。运动数据包包含两个手指的位置差
例如，当状态数据包告知有两个手指位于触控板上时，我们可以期望接下来有两个头部数据包。如果手指状态没有变化，则接下来的数据包将是运动数据包，只发送手指位置的变化，直到我们收到一个新的状态数据包。
一个例外是单指触摸。当状态包告诉我们只有一个手指时，硬件之后只会发送头部包。

### 状态包
^^^^^^^^^^^^^

**字节 0：**

```
   位   7   6   5   4   3   2   1   0
         .   .   .   .   0   1   R   L
```

- `L, R`：左、右鼠标键按下时为 1

**字节 1：**

```
   位   7   6   5   4   3   2   1   0
         .   .   . ft4 ft3 ft2 ft1 ft0
```

- `ft4 ft3 ft2 ft1 ft0 ftn`：第 n 个手指在触摸板上时为 1

**字节 2：**

```
   不使用
```

**字节 3：**

```
   位   7   6   5   4   3   2   1   0
         .   .   .   1   0   0   0   0
```

- 恒定位

**字节 4：**

```
   位   7   6   5   4   3   2   1   0
         p   .   .   .   .   .   .
```

- `p`：手掌时为 1

**字节 5：**

```
   不使用
```

### 头部包
^^^^^^^^^^^

**字节 0：**

```
   位   7   6   5   4   3   2   1   0
        w3  w2  w1  w0   0   1   R   L
```

- `L, R`：左、右鼠标键按下时为 1
- `w3..w0`：手指宽度（跨越多少条轨迹线）

**字节 1：**

```
   位   7   6   5   4   3   2   1   0
        p7  p6  p5  p4 x11 x10  x9  x8
```

**字节 2：**

```
   位   7   6   5   4   3   2   1   0
        x7  x6  x5  x4  x3  x2  x1  x0
```

- `x11..x0`：绝对的 X 值（水平）

**字节 3：**

```
   位   7   6   5   4   3   2   1   0
       id2 id1 id0   1   0   0   0   1
```

- `id2..id0`：手指 ID

**字节 4：**

```
   位   7   6   5   4   3   2   1   0
        p3  p1  p2  p0  y11 y10 y9  y8
```

- `p7..p0`：压力

**字节 5：**

```
   位   7   6   5   4   3   2   1   0
        y7  y6  y5  y4  y3  y2  y1  y0
```

- `y11..y0`：绝对的 Y 值（垂直）

### 运动包
^^^^^^^^^^^^^

**字节 0：**

```
   位   7   6   5   4   3   2   1   0
       id2 id1 id0   w   0   1   R   L
```

- `L, R`：左、右鼠标键按下时为 1
- `id2..id0`：手指 ID
- `w`：当增量溢出（> 127 或 < -128）时为 1，在这种情况下，固件会发送我们（delta x / 5）和（delta y / 5）

**字节 1：**

```
   位   7   6   5   4   3   2   1   0
        x7  x6  x5  x4  x3  x2  x1  x0
```

- `x7..x0`：增量 X（补码）

**字节 2：**

```
   位   7   6   5   4   3   2   1   0
        y7  y6  y5  y4  y3  y2  y1  y0
```

- `y7..y0`：增量 Y（补码）

**字节 3：**

```
   位   7   6   5   4   3   2   1   0
       id2 id1 id0   1   0   0   1   0
```

- `id2..id0`：手指 ID

**字节 4：**

```
   位   7   6   5   4   3   2   1   0
        x7  x6  x5  x4  x3  x2  x1  x0
```

- `x7..x0`：增量 X（补码）

**字节 5：**

```
   位   7   6   5   4   3   2   1   0
        y7  y6  y5  y4  y3  y2  y1  y0
```

- `y7..y0`：增量 Y（补码）

- 字节 0~2 用于一个手指
- 字节 3~5 用于另一个手指

### 轨迹点（对于硬件版本 3 和 4）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#### 寄存器

没有识别出特殊的寄存器。
原生相对模式 6 字节包格式

#### 状态包
^^^^^^^^^^^^^

**字节 0：**

```
   位   7   6   5   4   3   2   1   0
         0   0  sx  sy   0   M   R   L
```

**字节 1：**

```
   位   7   6   5   4   3   2   1   0
       ~sx   0   0   0   0   0   0   0
```

**字节 2：**

```
   位   7   6   5   4   3   2   1   0
       ~sy   0   0   0   0   0   0   0
```

**字节 3：**

```
   位   7   6   5   4   3   2   1   0
         0   0 ~sy ~sx   0   1   1   0
```

**字节 4：**

```
   位   7   6   5   4   3   2   1   0
        x7  x6  x5  x4  x3  x2  x1  x0
```

**字节 5：**

```
   位   7   6   5   4   3   2   1   0
        y7  y6  y5  y4  y3  y2  y1  y0
```

- `x` 和 `y` 使用补码表示，跨越 9 位，其中 `sx/sy` 是相对最高位，而 `x7..x0` 和 `y7..y0` 是低位
- `~sx` 是 `sx` 的反值，`~sy` 是 `sy` 的反值
- `y` 的符号与输入驱动程序期望的相对移动相反
