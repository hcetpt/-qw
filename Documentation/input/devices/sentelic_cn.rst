```markdown
.. include:: <isonum.txt>

=================
Sentelic 触摸板
=================

:版权所有: |copy| 2002-2011 Sentelic Corporation
:最后更新: 2011年12月7日

智能鼠标模式（滚动轮，第4和第5个按钮）
==========================================

A) MSID 4: 滚动轮模式加上前进页（第4个按钮）和后退页（第5个按钮）

1. 设置采样率为200；
2. 设置采样率为200；
3. 设置采样率为80；
4. 发送“获取设备ID”命令（0xF2），并等待响应；
5. FSP 将响应 0x04
::

    数据包 1
    位 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
    字节  |---------------|字节 |---------------|字节|---------------|字节|---------------|
      1   |Y|X|y|x|1|M|R|L|  2  |X|X|X|X|X|X|X|X|  3 |Y|Y|Y|Y|Y|Y|Y|Y|  4 | | |B|F|W|W|W|W|
	  |---------------|     |---------------|    |---------------|    |---------------|

    字节 1: 位7 => Y 溢出
            位6 => X 溢出
            位5 => Y 符号位
            位4 => X 符号位
            位3 => 1
            位2 => 中间按钮，1 表示按下，0 表示未按下
            位1 => 右键，1 表示按下，0 表示未按下
            位0 => 左键，1 表示按下，0 表示未按下
    字节 2: X 移动（9位二进制补码整数）
    字节 3: Y 移动（9位二进制补码整数）
    字节 4: 位3～位0 => 自上次数据报告以来滚动轮的移动
            有效值范围：-8 ~ +7
            位4 => 1 = 第4个鼠标按钮被按下，向前翻一页
                  0 = 第4个鼠标按钮未被按下
            位5 => 1 = 第5个鼠标按钮被按下，向后翻一页
                  0 = 第5个鼠标按钮未被按下
```
B) MSID 6: 水平和垂直滚动

- 将寄存器 0x40 中的第 1 位置为 1

FSP 用 4 位表示滚动轮的移动，以显示水平和垂直滚动：

```
    数据包 1
    位 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
    字节 |---------------|字节|---------------|字节|---------------|字节|---------------|
      1  |Y|X|y|x|1|M|R|L|  2  |X|X|X|X|X|X|X|X|  3 |Y|Y|Y|Y|Y|Y|Y|Y|  4 | | |B|F|r|l|u|d|
      |---------------|     |---------------|    |---------------|    |---------------|

    字节 1:
        位 7 => Y 溢出
        位 6 => X 溢出
        位 5 => Y 符号位
        位 4 => X 符号位
        位 3 => 1
        位 2 => 中间按钮，1 表示按下，0 表示未按下
        位 1 => 右键，1 表示按下，0 表示未按下
        位 0 => 左键，1 表示按下，0 表示未按下
    字节 2: X 移动（9 位二进制补码整数）
    字节 3: Y 移动（9 位二进制补码整数）
    字节 4:
        位 0 => 垂直向下滚动
        位 1 => 垂直向上滚动
        位 2 => 水平向左滚动
        位 3 => 水平向右滚动
        位 4 => 1 = 第四个鼠标按钮按下，向前翻一页
                 0 = 第四个鼠标按钮未按下
```
以下是翻译：

Bit5 => 1 = 第五个鼠标按钮被按下，后退一页  
0 = 第五个鼠标按钮未被按下  
C) MSID 7  

FSP 使用 2 个数据包（8 字节）来表示绝对位置  
所以我们需要一个数据包编号来识别这些数据包  
如果数据包编号是 0，则该数据包为 Packet 1  
如果数据包编号是 1，则该数据包为 Packet 2  
请在程序中计算这个编号  
当启用 MSID 7 时，MSID6 特殊数据包也将同时启用  
STL3886-G0 的绝对位置  
================================

1. 将寄存器 0x40 中的位 2 或位 3 设置为 1  
2. 将寄存器 0x40 中的位 6 设置为 1  

```
Packet 1 (ABSOLUTE POSITION)
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  |---------------|BYTE |---------------|BYTE|---------------|BYTE|---------------|
  1   |0|1|V|1|1|M|R|L|  2  |X|X|X|X|X|X|X|X|  3 |Y|Y|Y|Y|Y|Y|Y|Y|  4 |r|l|d|u|X|X|Y|Y|
  |---------------|     |---------------|    |---------------|    |---------------|

Byte 1:
Bit7~Bit6 => 00, 普通数据包  
            => 01, 绝对坐标数据包  
            => 10, 通知数据包  
Bit5 => 有效位  
Bit4 => 1  
Bit3 => 1  
Bit2 => 中间按钮，1 表示按下，0 表示未按下  
Bit1 => 右按钮，1 表示按下，0 表示未按下
```
以下是翻译：

```
Bit0 => 左键，1 表示按下，0 表示未按下
Byte 2: X 坐标 (xpos[9:2])
Byte 3: Y 坐标 (ypos[9:2])
Byte 4: Bit1~Bit0 => Y 坐标 (xpos[1:0])
        Bit3~Bit2 => X 坐标 (ypos[1:0])
        Bit4 => 向上滚动
        Bit5 => 向下滚动
        Bit6 => 向左滚动
        Bit7 => 向右滚动

G0 通知数据包
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE |---------------|BYTE |---------------|BYTE|---------------|BYTE|---------------|
  1  |1|0|0|1|1|M|R|L|  2  |C|C|C|C|C|C|C|C|  3 |M|M|M|M|M|M|M|M|  4 |0|0|0|0|0|0|0|0|
     |---------------|     |---------------|    |---------------|    |---------------|

Byte 1: Bit7~Bit6 => 00, 正常数据包
                    => 01, 绝对坐标包
                    => 10, 通知包
        Bit5 => 0
        Bit4 => 1
        Bit3 => 1
        Bit2 => 中键，1 表示按下，0 表示未按下
        Bit1 => 右键，1 表示按下，0 表示未按下
        Bit0 => 左键，1 表示按下，0 表示未按下
Byte 2: 消息类型 => 0x5A（启用/禁用状态包）
        模式类型 => 0xA5（正常/图标模式状态）
Byte 3: 消息类型 => 0x00（禁用）
            => 0x01（启用）
        模式类型    => 0x00（正常）
            => 0x01（图标）
Byte 4: Bit7~Bit0 => 无需关注

STL3888-Ax 的绝对位置
====================

::

    数据包 1（绝对位置）
    Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
    BYTE |---------------|BYTE |---------------|BYTE|---------------|BYTE|---------------|
  1    |0|1|V|A|1|L|0|1|  2  |X|X|X|X|X|X|X|X|  3 |Y|Y|Y|Y|Y|Y|Y|Y|  4 |x|x|y|y|X|X|Y|Y|
       |---------------|     |---------------|    |---------------|    |---------------|

Byte 1: Bit7~Bit6 => 00, 正常数据包
                    => 01, 绝对坐标包
                    => 10, 通知包
                    => 11, 带有触控板点击的正常数据包
        Bit5 => 有效位，0 表示坐标无效或手指抬起
        当两个手指都抬起时，最后两个报告的有效位为零
        Bit4 => 弧形
        Bit3 => 1
        Bit2 => 左键，1 表示按下，0 表示释放
        Bit1 => 0
        Bit0 => 1
Byte 2: X 坐标 (xpos[9:2])
Byte 3: Y 坐标 (ypos[9:2])
Byte 4: Bit1~Bit0 => Y 坐标 (xpos[1:0])
        Bit3~Bit2 => X 坐标 (ypos[1:0])
        Bit5~Bit4 => y1_g
        Bit7~Bit6 => x1_g

数据包 2（绝对位置）
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE |---------------|BYTE |---------------|BYTE|---------------|BYTE|---------------|
  1  |0|1|V|A|1|R|1|0|  2  |X|X|X|X|X|X|X|X|  3 |Y|Y|Y|Y|Y|Y|Y|Y|  4 |x|x|y|y|X|X|Y|Y|
      |---------------|     |---------------|    |---------------|    |---------------|

Byte 1: Bit7~Bit6 => 00, 正常数据包
                    => 01, 绝对坐标包
                    => 10, 通知包
                    => 11, 带有触控板点击的正常数据包
        Bit5 => 有效位，0 表示坐标无效或手指抬起
        当两个手指都抬起时，最后两个报告的有效位为零
        Bit4 => 弧形
        Bit3 => 1
        Bit2 => 右键，1 表示按下，0 表示释放
```
### STL3888-Ax 通知数据包格式

#### 字节 1:
- **Bit7~Bit6**: 
  - `00`: 正常数据包
  - `01`: 绝对坐标数据包
  - `10`: 通知数据包
  - `11`: 带触控板点击的正常数据包
- **Bit5**: `1`
- **Bit4**: 在绝对坐标模式下（当 `EN_PKT_GO` 为 1 时）：
  - `0`: 触控板命令生成左键
  - `1`: 外部按钮生成左键
- **Bit3**: `1`
- **Bit2**: 中键，`1` 表示按下，`0` 表示未按下
- **Bit1**: 右键，`1` 表示按下，`0` 表示未按下
- **Bit0**: 左键，`1` 表示按下，`0` 表示未按下

#### 字节 2:
- 消息类型：`0xB7`（多指、多坐标模式）

#### 字节 3:
- **Bit7~Bit6**: 不关心
- **Bit5~Bit4**: 手指数量
- **Bit3~Bit1**: 保留位
- **Bit0**: `1` 进入手势模式；`0` 离开手势模式

#### 字节 4:
- **Bit7**: 滚动右按钮
- **Bit6**: 滚动左按钮
- **Bit5**: 滚动下按钮
- **Bit4**: 滚动上按钮
  * 注意：如果手势和附加按钮（Bit4~Bit7）同时发生，则按钮信息不会发送
- **Bit3~Bit0**: 保留位

### 多指、多坐标模式示例序列：

- 通知数据包（有效位 == 1），绝对坐标数据包 1，绝对坐标数据包 2，绝对坐标数据包 1，绝对坐标数据包 2，...，通知数据包（有效位 == 0）

### STL3888-B0 绝对位置数据包格式

#### 数据包 1（绝对位置）
```
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  |---------------|BYTE |---------------|BYTE|---------------|BYTE|---------------|
  1   |0|1|V|F|1|0|R|L|  2  |X|X|X|X|X|X|X|X|  3 |Y|Y|Y|Y|Y|Y|Y|Y|  4 |r|l|u|d|X|X|Y|Y|
      |---------------|     |---------------|    |---------------|    |---------------|
```

#### 字节 1:
- **Bit7~Bit6**: 
  - `00`: 正常数据包
  - `01`: 绝对坐标数据包
  - `10`: 通知数据包
  - `11`: 带触控板点击的正常数据包
- **Bit5**: 有效位，`0` 表示坐标无效或手指抬起。当两个手指都抬起时，最后两个报告的有效位为零。
- **Bit4**: 手指抬起/放下信息，`1` 表示手指放下，`0` 表示手指抬起。
- **Bit3**: `1`
- **Bit2**: 手指索引，`0` 是第一个手指，`1` 是第二个手指。
- **Bit1**: 右键，`1` 表示按下，`0` 表示未按下。
- **Bit0**: 左键，`1` 表示按下，`0` 表示未按下。

#### 字节 2:
- X 坐标

#### 字节 3:
- Y 坐标

#### 字节 4:
- **Bit7**: 保留位
- **Bit6**: 保留位
- **Bit5**: 保留位
- **Bit4**: 保留位
- **Bit3**: 保留位
- **Bit2**: 保留位
- **Bit1**: 保留位
- **Bit0**: 保留位

希望这些信息对你有帮助！如果有任何其他问题，请随时告诉我。
### 数据包格式说明

#### 数据包 2（绝对位置）
```
位 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
字节 |---------------|字节 |---------------|字节|---------------|字节|---------------|
  1  |0|1|V|F|1|1|R|L|  2  |X|X|X|X|X|X|X|X|  3 |Y|Y|Y|Y|Y|Y|Y|Y|  4 |r|l|u|d|X|X|Y|Y|
     |---------------|     |---------------|    |---------------|    |---------------|
```

- **字节 1**:
  - 位 7~位 6: 
    - `00`: 正常数据包
    - `01`: 绝对坐标数据包
    - `10`: 通知数据包
    - `11`: 带触控板点击的正常数据包
  - 位 5: 有效位，`0` 表示坐标无效或手指抬起
    - 当两个手指都抬起时，最后两个报告的有效位为零
  - 位 4: 手指按下/抬起信息。`1`: 手指按下，`0`: 手指抬起
  - 位 3: `1`
  - 位 2: 手指索引，`0` 是第一个手指，`1` 是第二个手指
  - 位 1: 右键，`1` 表示按下，`0` 表示未按下
  - 位 0: 左键，`1` 表示按下，`0` 表示未按下

- **字节 2**: X 坐标 (xpos[9:2])
- **字节 3**: Y 坐标 (ypos[9:2])
- **字节 4**:
  - 位 1~位 0: Y 坐标 (xpos[1:0])
  - 位 3~位 2: X 坐标 (ypos[1:0])
  - 位 4: 向下滚动按钮
  - 位 5: 向上滚动按钮
  - 位 6: 向左滚动按钮
  - 位 7: 向右滚动按钮

#### 通知数据包 (STL3888-B0)

```
位 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
字节 |---------------|字节 |---------------|字节|---------------|字节|---------------|
  1  |1|0|1|P|1|M|R|L|  2  |C|C|C|C|C|C|C|C|  3 |0|0|F|F|0|0|0|i|  4 |r|l|u|d|0|0|0|0|
     |---------------|     |---------------|    |---------------|    |---------------|
```

- **字节 1**:
  - 位 7~位 6:
    - `00`: 正常数据包
    - `01`: 绝对坐标数据包
    - `10`: 通知数据包
    - `11`: 带触控板点击的正常数据包
  - 位 5: `1`
  - 位 4: 在绝对坐标模式下（当 EN_PKT_GO 为 `1` 时）：
    - `0`: 左键由触控板命令生成
    - `1`: 左键由外部按钮生成
  - 位 3: `1`
  - 位 2: 中键，`1` 表示按下，`0` 表示未按下
  - 位 1: 右键，`1` 表示按下，`0` 表示未按下
  - 位 0: 左键，`1` 表示按下，`0` 表示未按下

- **字节 2**: 消息类型 => `0xB7`（多手指、多坐标模式）
- **字节 3**:
  - 位 7~位 6: 不关心
  - 位 5~位 4: 手指数量
  - 位 3~位 1: 保留
  - 位 0: `1`: 进入手势模式；`0`: 离开手势模式
- **字节 4**:
  - 位 7: 向右滚动按钮
  - 位 6: 向左滚动按钮
  - 位 5: 向上滚动按钮
  - 位 4: 向下滚动按钮
  - *注意：如果手势和附加按钮（位 4~位 7）同时发生，则按钮信息不会发送*
Bit3~Bit0 => 保留

多指多坐标模式的示例序列：

通知数据包（有效位 == 1），绝对位置数据包 1，绝对位置数据包 2，绝对位置数据包 1，
绝对位置数据包 2，...，通知数据包（有效位 == 0）

STL3888-Cx 和 STL3888-Dx 的绝对位置
===============================================

::

    单指绝对坐标模式（SFAC）
    Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
    BYTE  |---------------|BYTE |---------------|BYTE|---------------|BYTE|---------------|
      1   |0|1|0|P|1|M|R|L|  2  |X|X|X|X|X|X|X|X|  3 |Y|Y|Y|Y|Y|Y|Y|Y|  4 |r|l|B|F|X|X|Y|Y|
	  |---------------|     |---------------|    |---------------|    |---------------|

    字节 1:
	    Bit7~Bit6 => 00, 正常数据包
		    => 01, 绝对坐标数据包
		    => 10, 通知数据包
	    Bit5 => 坐标模式（在 SFAC 模式中始终为 0）：
		    0: 单指绝对坐标（SFAC）模式
		    1: 多指多坐标（MFMC）模式
	    Bit4 => 0: 左键由触控板命令生成（OPC）
		    1: 左键由外部按钮生成
		    默认值为 1，即使左键未按下
	    Bit3 => 始终为 1，符合 PS/2 协议规定
	    Bit2 => 中间按钮，1 表示按下，0 表示未按下
	    Bit1 => 右键，1 表示按下，0 表示未按下
	    Bit0 => 左键，1 表示按下，0 表示未按下
    字节 2: X 坐标（xpos[9:2]）
    字节 3: Y 坐标（ypos[9:2]）
    字节 4:
	    Bit1~Bit0 => Y 坐标（xpos[1:0]）
	    Bit3~Bit2 => X 坐标（ypos[1:0]）
	    Bit4 => 第四个鼠标按钮（向前翻页）
	    Bit5 => 第五个鼠标按钮（向后翻页）
	    Bit6 => 向左滚动按钮
	    Bit7 => 向右滚动按钮

    多指多坐标模式（MFMC）
    Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
    BYTE  |---------------|BYTE |---------------|BYTE|---------------|BYTE|---------------|
      1   |0|1|1|P|1|F|R|L|  2  |X|X|X|X|X|X|X|X|  3 |Y|Y|Y|Y|Y|Y|Y|Y|  4 |r|l|B|F|X|X|Y|Y|
	  |---------------|     |---------------|    |---------------|    |---------------|

    字节 1:
	    Bit7~Bit6 => 00, 正常数据包
		    => 01, 绝对坐标数据包
		    => 10, 通知数据包
	    Bit5 => 坐标模式（在 MFMC 模式中始终为 1）：
		    0: 单指绝对坐标（SFAC）模式
		    1: 多指多坐标（MFMC）模式
	    Bit4 => 0: 左键由触控板命令生成（OPC）
		    1: 左键由外部按钮生成
		    默认值为 1，即使左键未按下
	    Bit3 => 始终为 1，符合 PS/2 协议规定
	    Bit2 => 手指索引，0 表示第一个手指，1 表示第二个手指
	    如果 Bit1 和 Bit0 都为 1 且 Bit4 为 0，则表示中间外部按钮被按下
	    Bit1 => 右键，1 表示按下，0 表示未按下
以下是翻译：

Bit0 => 左键，1 表示按下，0 表示未按下  
Byte 2: X 坐标 (xpos[9:2])  
Byte 3: Y 坐标 (ypos[9:2])  
Byte 4: Bit1~Bit0 => Y 坐标 (xpos[1:0])  
Bit3~Bit2 => X 坐标 (ypos[1:0])  
Bit4 => 第四个鼠标按钮（向前翻页）  
Bit5 => 第五个鼠标按钮（向后翻页）  
Bit6 => 向左滚动按钮  
Bit7 => 向右滚动按钮  

当两个手指中的一个抬起时，设备将输出四个连续的 MFMC#0 报告包，X 和 Y 值为零，以表示第一个手指抬起；或者输出四个连续的 MFMC#1 报告包，X 和 Y 值为零，以表示第二个手指抬起。另一方面，如果两个手指都抬起，设备将输出四个连续的单指绝对坐标 (SFAC) 包，X 和 Y 值为零。

STL3888-Cx/Dx 的通知包格式如下：

    Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0  
    BYTE  |---------------|BYTE |---------------|BYTE|---------------|BYTE|---------------|  
      1   |1|0|0|P|1|M|R|L|  2  |C|C|C|C|C|C|C|C|  3 |0|0|F|F|0|0|0|i|  4 |r|l|u|d|0|0|0|0|  
	  |---------------|     |---------------|    |---------------|    |---------------|  

Byte 1: Bit7~Bit6 => 00, 正常数据包  
                    => 01, 绝对坐标包  
                    => 10, 通知包  
Bit5 => 始终为 0  
Bit4 => 0：LEFT 按钮由触控板命令 (OPC) 生成  
                    1：LEFT 按钮由外部按钮生成  
                    默认为 1，即使 LEFT 按钮未按下  
Bit3 => 1  
Bit2 => 中键，1 表示按下，0 表示未按下  
Bit1 => 右键，1 表示按下，0 表示未按下  
Bit0 => 左键，1 表示按下，0 表示未按下  
Byte 2: 消息类型：  
                    0xba => 手势信息  
                    0xc0 => 单指旋转手势  
Byte 3: 接收到的消息的第一个参数：  
                    0xba => 手势 ID（参见“手势 ID”部分）  
                    0xc0 => 区域 ID  
Byte 4: 接收到的消息的第二个参数：  
                    0xba => 无用  
                    0xc0 => 手指抬起/落下信息  

多指多坐标模式下的样本序列：

    通知包（有效位 == 1），MFMC 包 1（字节 1，位 2 == 0），MFMC 包 2（字节 1，位 2 == 1），MFMC 包 1，MFMC 包 2，...，通知包（有效位 == 0）

    即，当设备处于 MFMC 模式时，主机将接收到每个手指交错的绝对坐标包。

FSP 启用/禁用包
=========================

::

    Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0  
    BYTE  |---------------|BYTE |---------------|BYTE|---------------|BYTE|---------------|  
      1   |Y|X|0|0|1|M|R|L|  2  |0|1|0|1|1|0|1|E|  3 | | | | | | | | |  4 | | | | | | | | |  
	  |---------------|     |---------------|    |---------------|    |---------------|  

    当 FSP 收到 PS/2 启用/禁用命令时，FSP 将发送启用/禁用包。主机将接收到该包，其中中间、右键和左键将被设置。该包仅使用字节 0 和字节 1 作为原始包的模式，忽略其他字节。

Byte 1: Bit7 => 0，Y 溢出  
        Bit6 => 0，X 溢出  
        Bit5 => 0，Y 符号位  
        Bit4 => 0，X 符号位  
        Bit3 => 1  
        Bit2 => 1，中键  
        Bit1 => 1，右键  
        Bit0 => 1，左键  
Byte 2: Bit7~1 => (0101101b)  
        Bit0 => 1 = 启用  
                0 = 禁用  
Byte 3: 无需关心  
Byte 4: 无需关心（鼠标 ID 3, 4）  
Byte 5~8: 无需关心（绝对包）

PS/2 命令集
================

FSP 支持基本的 PS/2 命令集和模式，请参阅以下网址获取关于 PS/2 命令的详细信息：

http://www.computer-engineering.org/ps2mouse/

确定报文解析流程的编程顺序
========================================================

1. 通过读取设备 ID (0x00) 和版本 (0x01) 寄存器来识别 FSP。

2. 对于 FSP 版本 < STL3888 Cx，通过读取 '测试模式状态' (0x20) 寄存器来确定按钮数量：

   ```  
   buttons = reg[0x20] & 0x30  
   
   if buttons == 0x30 or buttons == 0x20:  
       # 两个/四个按钮  
       参见“触摸感应垫 PS/2 鼠标 IntelliMouse”部分 A 的报文解析细节（忽略字节 4，位 ~ 7）  
   elif buttons == 0x10:  
       # 六个按钮  
       参见“触摸感应垫 PS/2 鼠标 IntelliMouse”部分 B 的报文解析细节  
   elif buttons == 0x00:  
       # 六个按钮  
       参见“触摸感应垫 PS/2 鼠标 IntelliMouse”部分 A 的报文解析细节  
   ```

3. 对于 FSP 版本 >= STL3888 Cx：
   参见“触摸感应垫 PS/2 鼠标 IntelliMouse”部分 A 的报文解析细节（忽略字节 4，位 ~ 7）。

寄存器读写编程顺序
=================================================

寄存器反转要求：

在发送给 FSP 之前，需要对以下值进行反转（在 C 中使用 '~' 运算符）：

```
0xe8, 0xe9, 0xee, 0xf2, 0xf3 和 0xff
```
寄存器交换要求：

以下值在发送到 FSP 之前，需要将其高 4 位与低 4 位互换：

- 10, 20, 40, 60, 80, 100 和 200

寄存器读取序列：

1. 向 FSP 发送 0xf3 PS/2 命令；
2. 向 FSP 发送 0x66 PS/2 命令；
3. 向 FSP 发送 0x88 PS/2 命令；
4. 向 FSP 发送 0xf3 PS/2 命令；
5. 如果要读取的寄存器地址不需要反转（参考“寄存器反转要求”部分），转到步骤 6；

    a. 向 FSP 发送 0x68 PS/2 命令；

    b. 向 FSP 发送反转后的寄存器地址，并转到步骤 8；

6. 如果要读取的寄存器地址不需要交换（参考“寄存器交换要求”部分），转到步骤 7；

    a. 向 FSP 发送 0xcc PS/2 命令；

    b. 向 FSP 发送交换后的寄存器地址，并转到步骤 8；

7. 向 FSP 发送 0x66 PS/2 命令；

    a. 向 FSP 发送原始寄存器地址，并转到步骤 8；

8. 向 FSP 发送 0xe9（状态请求）PS/2 命令；

9. 从 FSP 读取的响应中的第四个字节应为请求的寄存器值（？？表示无关紧要的字节）：

   - 主机：0xe9
   - 3888：0xfa （？？）（？？）（val）

   * 注意：自 Cx 版本起，硬件将在状态请求结果的第三个字节返回寄存器值的一补码：

   - 主机：0xe9
   - 3888：0xfa （？？）（~val）（val）

寄存器写入序列：

1. 向 FSP 发送 0xf3 PS/2 命令；
2. 如果要写的寄存器地址不需要反转（参考“寄存器反转要求”部分），转到步骤 3；

    a. 向 FSP 发送 0x74 PS/2 命令；

    b. 向 FSP 发送反转后的寄存器地址，并转到步骤 5；

3. 如果要写的寄存器地址不需要交换（参考“寄存器交换要求”部分），转到步骤 4；

    a. 向 FSP 发送 0x77 PS/2 命令；

    b. 向 FSP 发送交换后的寄存器地址，并转到步骤 5；

4. 向 FSP 发送 0x55 PS/2 命令；

    a. 向 FSP 发送寄存器地址，并转到步骤 5；

5. 向 FSP 发送 0xf3 PS/2 命令；
6. 如果要写的寄存器值不需要反转（参考“寄存器反转要求”部分），转到步骤 7；

    a. 向 FSP 发送 0x47 PS/2 命令；

    b. 向 FSP 发送反转后的寄存器值，并转到步骤 9；

7. 如果要写的寄存器值不需要交换（参考“寄存器交换要求”部分），转到步骤 8；

    a. 向 FSP 发送 0x44 PS/2 命令；

    b. 向 FSP 发送交换后的寄存器值，并转到步骤 9；

8. 向 FSP 发送 0x33 PS/2 命令；

    a. 向 FSP 发送寄存器值；

9. 寄存器写入序列完成。

自 Cx 版本起，硬件将在状态请求结果的第三个字节返回寄存器值的一补码。主机可以在寄存器写入结束后可选地向 FSP 发送另一个 0xe9（状态请求）PS/2 命令以验证寄存器写入操作是否成功（？？表示无关紧要的字节）：

- 主机：0xe9
- 3888：0xfa （？？）（~val）（val）

页寄存器读写编程序列
======================

为了克服支持寄存器数量的最大限制，硬件将寄存器分为不同的组称为“页”。每一页可以包含多达 255 个寄存器。上电后的默认页是 0x82；因此，如果要访问寄存器 0x8301，则必须使用以下序列切换到页 0x83，然后使用前文所述的寄存器读写序列从偏移 0x01 开始读写。

页寄存器读取序列：

1. 向 FSP 发送 0xf3 PS/2 命令；
2. 向 FSP 发送 0x66 PS/2 命令；
3. 向 FSP 发送 0x88 PS/2 命令；
4. 向 FSP 发送 0xf3 PS/2 命令；
5. 向 FSP 发送 0x83 PS/2 命令；
6. 向 FSP 发送 0x88 PS/2 命令；
7. 向 FSP 发送 0xe9（状态请求）PS/2 命令；
8. 从 FSP 读取的响应应为请求的页值。

页寄存器写入序列：

1. 向 FSP 发送 0xf3 PS/2 命令；
2. 向 FSP 发送 0x38 PS/2 命令；
3. 向 FSP 发送 0x88 PS/2 命令；
4. 向 FSP 发送 0xf3 PS/2 命令；
5. 如果要写的页地址不需要反转（参考“寄存器反转要求”部分），转到步骤 6；

    a. 向 FSP 发送 0x47 PS/2 命令；

    b. 向 FSP 发送反转后的页地址，并转到步骤 9；

6. 如果要写的页地址不需要交换（参考“寄存器交换要求”部分），转到步骤 7；

    a. 向 FSP 发送 0x44 PS/2 命令；

    b. 向 FSP 发送交换后的页地址，并转到步骤 9；

7. 向 FSP 发送 0x33 PS/2 命令；

8. 向 FSP 发送页地址；

9. 页寄存器写入序列完成。

手势ID
==========

与其他设备不同，FSP 在内部处理多个手指坐标并将其转换为一个 8 位整数，即“手势ID”。以下是支持的手势ID列表：

| ID | 描述 |
| --- | --- |
| 0x86 | 两指直立 |
| 0x82 | 两指向下 |
| 0x80 | 两指向右 |
| 0x84 | 两指向左 |
| 0x8f | 两指放大 |
| 0x8b | 两指缩小 |
| 0xc0 | 两指逆时针弯曲 |
| 0xc4 | 两指顺时针弯曲 |
| 0x2e | 三指直立 |
| 0x2a | 三指向下 |
| 0x28 | 三指向右 |
| 0x2c | 三指向左 |
| 0x38 | 手掌 |

寄存器列表
================

寄存器表示为 16 位值。高 8 位代表页地址，低 8 位代表特定页内的相对偏移量。关于如何更改当前页地址，请参阅“页寄存器读写编程序列”部分。

| 偏移 | 宽度 | 默认值 | 读写 | 名称 |
| ---- | ---- | ------ | ---- | ---- |
| 0x8200 | bit7~bit0 | 0x01 | RO | 设备ID |
| 0x8201 | bit7~bit0 | RW | 版本ID | 0xc1: STL3888 Ax<br>0xd0 ~ 0xd2: STL3888 Bx<br>0xe0 ~ 0xe1: STL3888 Cx<br>0xe2 ~ 0xe3: STL3888 Dx |
| 0x8202 | bit7~bit0 | 0x01 | RO | 厂商ID |
| 0x8203 | bit7~bit0 | 0x01 | RO | 产品ID |
| 0x8204 | bit3~bit0 | 0x01 | RW | 修订ID |
| 0x820b |  | 测试模式状态1 | bit3 | 1 | RO | 0: 旋转 180 度<br>1: 不旋转<br>*仅支持 Cx 之前的硬件 |
| 0x820f |  | 寄存器文件页控制 | bit2 | 0 | RW | 1: 旋转 180 度<br>0: 不旋转<br>*自 Cx 起支持 |
|  |  |  | bit0 | 0 | RW | 1: 启用页 1 寄存器文件<br>*仅支持 Cx 之前的硬件 |
| 0x8210 |  | 系统控制 1 | bit0 | 1 | RW | 预留，必须为 1 |
|  |  |  | bit1 | 0 | RW | 预留，必须为 0 |
|  |  |  | bit4 | 0 | RW | 预留，必须为 0 |
|  |  |  | bit5 | 1 | RW | 寄存器时钟门控使能<br>0: 只读，1: 读写使能<br>（注意，以下寄存器在写入之前不需要启用时钟门控：05 06 07 08 09 0c 0f 10 11 12 16 17 18 23 2e 40 41 42 43。此外，当启用手势模式时，此位必须为 1） |
| 0x8220 |  | 测试模式状态 | bit5~bit4 | RO | 按钮数量<br>11 => 2, lbtn/rbtn<br>10 => 4, lbtn/rbtn/scru/scrd<br>01 => 6, lbtn/rbtn/scru/scrd/scrl/scrr<br>00 => 6, lbtn/rbtn/scru/scrd/fbtn/bbtn<br>*仅支持 Cx 之前的硬件 |
| 0x8231 |  | 垫上命令检测 | bit7 | 0 | RW | 垫上命令左键按下标记使能<br>0: 禁用，1: 启用<br>*仅支持 Cx 之前的硬件 |
| 0x8234 |  | 垫上命令控制 5 | bit4~bit0 | 0x05 | RW | XLO in 0s/4/1, so 03h = 0010.1b = 2.5<br>（注意位置单位为 0.5 扫描线）<br>*仅支持 Cx 之前的硬件 |
|  |  |  | bit7 | 0 | RW | 垫上轻触区域使能<br>0: 禁用，1: 启用<br>*仅支持 Cx 之前的硬件 |
| 0x8235 |  | 垫上命令控制 6 | bit4~bit0 | 0x1d | RW | XHI in 0s/4/1, so 19h = 1100.1b = 12.5<br>（注意位置单位为 0.5 扫描线）<br>*仅支持 Cx 之前的硬件 |
| 0x8236 |  | 垫上命令控制 7 | bit4~bit0 | 0x04 | RW | YLO in 0s/4/1, so 03h = 0010.1b = 2.5<br>（注意位置单位为 0.5 扫描线）<br>*仅支持 Cx 之前的硬件 |
| 0x8237 |  | 垫上命令控制 8 | bit4~bit0 | 0x13 | RW | YHI in 0s/4/1, so 11h = 1000.1b = 8.5<br>（注意位置单位为 0.5 扫描线）<br>*仅支持 Cx 之前的硬件 |
| 0x8240 |  | 系统控制 5 | bit1 | 0 | RW | FSP Intellimouse 模式使能<br>0: 禁用，1: 启用<br>*仅支持 Cx 之前的硬件 |
|  |  |  | bit2 | 0 | RW | 移动 + 绝对坐标模式使能<br>0: 禁用，1: 启用<br>（注意此功能即使位 1 未设置也有位 1 的功能。但是，格式不同于位 1。此外，当位 1 和位 2 同时设置时，位 2 将覆盖位 1。）<br>*仅支持 Cx 之前的硬件 |
|  |  |  | bit3 | 0 | RW | 仅绝对坐标模式使能<br>0: 禁用，1: 启用<br>（注意此功能即使位 1 未设置也有位 1 的功能。但是，格式不同于位 1。此外，当位 1、位 2 和位 3 同时设置时，位 3 将覆盖位 1 和 2。）<br>*仅支持 Cx 之前的硬件 |
|  |  |  | bit5 | 0 | RW | 自动切换使能<br>0: 禁用，1: 启用<br>*仅支持 Cx 之前的硬件 |
|  |  |  | bit6 | 0 | RW | G0 绝对 + 通知数据包格式使能<br>0: 禁用，1: 启用<br>（注意绝对/相对坐标输出仍取决于位 2 和 3。也就是说，如果这些位中有任何一个为 1，则主机将接收到绝对坐标；否则，主机只接收包含相对坐标的报文。）<br>*仅支持 Cx 之前的硬件 |
|  |  |  | bit7 | 0 | RW | EN_PS2_F2: PS/2 手势模式第二指报文使能<br>0: 禁用，1: 启用<br>*仅支持 Cx 之前的硬件 |
| 0x8243 |  | 垫上控制 | bit0 | 0 | RW | 垫上控制使能<br>0: 禁用，1: 启用<br>（注意如果此位被清除，位 3/5 将无效）<br>*仅支持 Cx 之前的硬件 |
|  |  |  | bit3 | 0 | RW | 垫上固定垂直滚动使能<br>0: 禁用，1: 启用<br>*仅支持 Cx 之前的硬件 |
|  |  |  | bit5 | 0 | RW | 垫上固定水平滚动使能<br>0: 禁用，1: 启用<br>*仅支持 Cx 之前的硬件 |
| 0x8290 |  | 软件控制寄存器 1 | bit0 | 0 | RW | 绝对坐标模式<br>0: 禁用，1: 启用<br>*自 Cx 起支持 |
|  |  |  | bit1 | 0 | RW | 手势 ID 输出<br>0: 禁用，1: 启用<br>*自 Cx 起支持 |
|  |  |  | bit2 | 0 | RW | 两个手指坐标输出<br>0: 禁用，1: 启用<br>*自 Cx 起支持 |
|  |  |  | bit3 | 0 | RW | 单个手指抬起报文输出<br>0: 禁用，1: 启用<br>*自 Cx 起支持 |
|  |  |  | bit4 | 0 | RW | 绝对坐标连续模式<br>0: 禁用，1: 启用<br>*自 Cx 起支持 |
|  |  |  | bit6~bit5 | 00 | RW | 手势组选择<br>00: 基础<br>01: 套件<br>10: 套件专业版<br>11: 高级<br>*自 Cx 起支持 |
|  |  |  | bit7 | 0 | RW | Bx 数据包输出兼容模式<br>0: 禁用，1: 启用<br>*自 Cx 起支持 |
| 0x833d |  | 垫上命令控制 1 | bit7 | 1 | RW | 垫上命令检测使能<br>0: 禁用，1: 启用<br>*自 Cx 起支持 |
| 0x833e |  | 垫上命令检测 | bit7 | 0 | RW | 垫上命令左键按下标记使能。仅在基于硬件的 PS/2 数据包模式下工作<br>0: 禁用，1: 启用<br>*自 Cx 起支持 |
