.. _input-event-codes:

=================
输入事件代码
=================

输入协议使用类型和代码的映射来向用户空间表达输入设备的值。本文档描述了这些类型和代码以及它们如何及何时使用。

一个硬件事件可能生成多个输入事件。每个输入事件包含单个数据项的新值。一种特殊的事件类型 EV_SYN 用于将输入事件分隔成在同一时刻发生的输入数据变化包。以下内容中，“事件”指代单个输入事件，包含类型、代码和值。

输入协议是一个有状态的协议。仅当事件代码的值发生变化时才会发出事件。然而，状态是在 Linux 输入子系统内部维护的；驱动程序不需要维护状态，并且可以尝试无害地发出未更改的值。用户空间可以通过使用在 linux/input.h 中定义的 EVIOCG* ioctl 获得事件代码值的当前状态。设备支持的事件报告也由 sysfs 在 class/input/event*/device/capabilities/ 中提供，而设备属性则在 class/input/event*/device/properties 中提供。

事件类型
========

事件类型是根据逻辑输入结构对代码进行分组。每种类型都有一组适用的代码用于生成事件。请参阅“代码”部分了解每种类型的合法代码。

* EV_SYN：

  - 用作分隔事件的标记。事件可以在时间或空间上分开，例如多点触控协议中。
* EV_KEY：

  - 用于描述键盘、按钮或其他类似按键设备的状态变化。
* EV_REL：

  - 用于描述相对轴值的变化，例如将鼠标向左移动 5 个单位。
* EV_ABS：

  - 用于描述绝对轴值的变化，例如描述触摸屏上的触摸坐标。
* EV_MSC：

  - 用于描述不符合其他类型的杂项输入数据。
* EV_SW：

  - 用于描述二进制状态输入开关。
* EV_LED:
  - 用于控制设备上的LED灯的开关
* EV_SND:
  - 用于向设备输出声音
* EV_REP:
  - 用于自动重复功能的设备
* EV_FF:
  - 用于向输入设备发送力反馈命令
* EV_PWR:
  - 一种特殊的类型，用于电源按钮和开关输入
* EV_FF_STATUS:
  - 用于接收力反馈设备的状态

事件代码
========

事件代码定义了具体的事件类型
EV_SYN
------
EV_SYN 事件值是未定义的。其使用仅由在 evdev 事件流中何时发送来定义。
* SYN_REPORT:
  - 用于同步并分离同时发生的输入数据变化事件。例如，鼠标移动可能会设置一次 REL_X 和 REL_Y 值，然后发出一个 SYN_REPORT。下一次移动会发出更多的 REL_X 和 REL_Y 值，并发送另一个 SYN_REPORT
* SYN_CONFIG:
  - 待定
* SYN_MT_REPORT:
  - 用于同步并分离触摸事件。更多信息请参见 multi-touch-protocol.txt 文档
* SYN_DROPPED：

  - 用于指示 evdev 客户端事件队列中的缓冲区溢出。
客户端应忽略所有事件直到下一个 SYN_REPORT 事件，并查询设备（使用 EVIOCG* ioctl）以获取其当前状态。

EV_KEY
------

EV_KEY 事件的形式为 KEY_<名称> 或 BTN_<名称>。例如，KEY_A 用于表示键盘上的 'A' 键。当一个键被按下时，会发出带有该键代码且值为 1 的事件。当键被释放时，会发出值为 0 的事件。某些硬件在重复按键时也会发送值为 2 的事件。通常，KEY_<名称> 用于键盘键，而 BTN_<名称> 用于其他类型的瞬时开关事件。

一些 EV_KEY 代码具有特殊含义：

* BTN_TOOL_<名称>：

  - 这些代码与输入触控板、绘图板和触摸屏一起使用。这些设备可以使用手指、笔或其他工具。当事件发生且使用了某个工具时，相应的 BTN_TOOL_<名称> 代码应设置为值 1。当工具不再与输入设备交互时，应将 BTN_TOOL_<名称> 代码重置为 0。所有触控板、绘图板和触摸屏在生成事件时都应至少使用一个 BTN_TOOL_<名称> 代码。同时，所有触控板、绘图板和触摸屏在生成事件时不应同时导出多个 BTN_TOOL_<名称>。为了不破坏现有的用户空间程序，建议不要在同一 EV_SYN 帧中切换工具，而是首先发出旧的 BTN_TOOL_<名称> 代码值为 0，然后发出一个 SYN_REPORT，最后设置新的 BTN_TOOL_<名称> 代码值为 1。

* BTN_TOUCH：

  - BTN_TOUCH 用于触碰检测。当输入工具被认为处于有意义的物理接触时，必须将此属性的值设置为 1。有意义的物理接触可以指任何接触，也可以由实现定义的属性决定。例如，触控板可能仅在触摸压力超过某个值时才将值设置为 1。BTN_TOUCH 可以与 BTN_TOOL_<名称> 代码结合使用。例如，当笔悬停在绘图板表面但未接触时，可以将 BTN_TOOL_PEN 设置为 1 而将 BTN_TOUCH 设置为 0。

注意：为了使遗留的 mousedev 模拟驱动正常工作，BTN_TOUCH 必须是同步帧中第一个发出的 evdev 代码。

注意：历史上，带 BTN_TOOL_FINGER 和 BTN_TOUCH 的触摸设备被用户空间解释为触控板，而不带 BTN_TOOL_FINGER 的类似设备则被解释为触摸屏。为了向后兼容当前用户空间，建议遵循这一区分。未来，这种区分将被弃用，设备属性 ioctl EVIOCGPROP（定义在 linux/input.h 中）将用于传达设备类型。

* BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP, BTN_TOOL_TRIPLETAP, BTN_TOOL_QUADTAP：

  - 这些代码分别表示单指、双指、三指和四指在触控板或触摸屏上的互动。例如，如果用户使用两个手指并在触控板上移动以滚动屏幕内容，则在整个移动过程中应将 BTN_TOOL_DOUBLETAP 设置为值 1。

请注意，所有 BTN_TOOL_<名称> 代码和 BTN_TOUCH 代码在目的上是正交的。由手指触摸生成的触控板事件应生成每个组中的一个代码的事件。在任何同步帧中，最多只有一个 BTN_TOOL_<名称> 代码的值为 1。
注释：历史上，一些驱动程序在同一同步帧中发出多个值为1的手指计数代码。这种用法已废弃。

注释：在多点触控驱动程序中，应使用`input_mt_report_finger_count()`函数来发出这些代码。请参阅multi-touch-protocol.txt以获取详细信息。

### EV_REL
---

`EV_REL`事件描述某个属性的相对变化。例如，鼠标可能向左移动一定数量的单位，但其在空间中的绝对位置是未知的。如果知道绝对位置，则应使用`EV_ABS`代码而不是`EV_REL`代码。

有几个`EV_REL`代码具有特殊含义：

* `REL_WHEEL`, `REL_HWHEEL`：
  
  - 这些代码分别用于垂直和水平滚轮。值表示滚轮移动的刻度数，实际大小因设备而异。对于高分辨率滚轮，这可能是基于高分辨率滚动事件的近似值，详见`REL_WHEEL_HI_RES`。这些事件代码是遗留代码，建议使用`REL_WHEEL_HI_RES`和`REL_HWHEEL_HI_RES`。
* `REL_WHEEL_HI_RES`, `REL_HWHEEL_HI_RES`：
  
  - 高分辨率滚轮数据。累积值120表示移动一个刻度。对于不提供高分辨率滚动的设备，值始终是120的倍数。对于支持高分辨率滚动的设备，值可以是120的一部分。
  
  如果垂直滚轮支持高分辨率滚动，此代码将在`REL_WHEEL`或`REL_HWHEEL`之外发出。`REL_WHEEL`和`REL_HWHEEL`可能是基于高分辨率滚动事件的近似值。无法保证在模拟`REL_WHEEL`或`REL_HWHEEL`事件时，高分辨率数据一定是120的倍数。

### EV_ABS
---

`EV_ABS`事件描述某个属性的绝对变化。例如，触摸板可能会发出触摸位置的坐标。

有几个`EV_ABS`代码具有特殊含义：

* `ABS_DISTANCE`：
  
  - 用于描述工具与交互表面的距离。此事件仅在工具悬停时发出，即在接近设备且`BTN_TOUCH`值为0的情况下。如果输入设备可以在三维空间中自由使用，请考虑使用`ABS_Z`。
  - 当工具进入可检测范围内时，应将`BTN_TOOL_<name>`设置为1；当工具离开可检测范围时，将其设置为0。
  - `BTN_TOOL_<name>`指示当前由硬件检测到的工具类型，并且独立于`ABS_DISTANCE`和`BTN_TOUCH`。
* ABS_PROFILE:

  - 用于描述多值配置文件开关的状态。只有当所选配置文件发生变化时才会发出事件，指示新选择的配置文件值。
* ABS_MT_<name>:

  - 用于描述多点触控输入事件。详情请参阅 multi-touch-protocol.txt。
* ABS_PRESSURE/ABS_MT_PRESSURE:

   - 对于触摸设备，许多设备将接触面积转换为压力。手指在压力作用下会变平，导致更大的接触面积，因此压力和接触面积直接相关。但这种情况不适用于其他设备，例如数位板和带有真实压力传感器的触控板（“压力垫”）。
   - 设备应设置轴的分辨率以表明压力是否可测量。如果分辨率为零，则压力数据为任意单位。如果分辨率为非零，则压力数据以单位/克表示。例如，分辨率为1时，值10表示10克；分辨率为1000时，值10表示10微克。

### EV_SW

EV_SW 事件用于描述有状态的二进制开关。例如，SW_LID 代码用于表示笔记本电脑盖子关闭的情况。
在绑定设备或从暂停恢复时，驱动程序必须报告当前的开关状态。这确保了设备、内核和用户空间的状态同步。
在恢复时，如果开关状态与暂停前相同，则输入子系统会过滤掉重复的开关状态报告。驱动程序不需要在任何时间保持开关状态。

### EV_MSC

EV_MSC 事件用于处理不属于其他类别的输入和输出事件。
一些 EV_MSC 代码具有特殊含义：

* MSC_TIMESTAMP:

  - 用于报告自上次重置以来的微秒数。此事件应编码为一个 uint32 值，允许循环而不产生特殊后果。假定两个连续事件之间的时间差在合理的时间尺度上（小时）是可靠的。
重置为零可能发生，在这种情况下，自上次事件以来的时间是未知的。如果设备不提供这些信息，驱动程序不应将其提供给用户空间。

### EV_LED
---

EV_LED 事件用于设置和查询设备上各种 LED 的状态。

### EV_REP
---

EV_REP 事件用于指定自动重复事件。

### EV_SND
---

EV_SND 事件用于向简单的音频输出设备发送声音命令。

### EV_FF
---

EV_FF 事件用于初始化具有力反馈功能的设备，并使其产生反馈。

### EV_PWR
---

EV_PWR 事件是一种专门用于电源管理的特殊类型事件。其用法尚未明确定义，待后续处理。

### 设备属性
---

通常，用户空间根据设备发出的数据（即事件类型）来设置输入设备。在两个设备发出相同事件类型的情况下，可以通过设备属性提供额外的信息。

#### INPUT_PROP_DIRECT + INPUT_PROP_POINTER
---

- **INPUT_PROP_DIRECT** 属性表示设备坐标应直接映射到屏幕坐标（不考虑简单的变换，如缩放、翻转和旋转）。非直接输入设备需要进行非简单的变换，例如触摸板从绝对坐标到相对坐标的转换。典型的直接输入设备：触摸屏、绘图板；非直接设备：触摸板、鼠标。
- **INPUT_PROP_POINTER** 属性表示设备不被转置到屏幕上，因此需要使用屏幕上的指针来追踪用户的移动。典型的指针设备：触摸板、绘图板、鼠标；非指针设备：触摸屏。

如果既没有设置 `INPUT_PROP_DIRECT` 也没有设置 `INPUT_PROP_POINTER`，则该属性被认为是未定义的，设备类型应通过传统方式（使用发出的事件类型）来推断。
### INPUT_PROP_BUTTONPAD

对于那些按钮位于触摸板下方的触摸板，按下触摸板时会触发按钮点击，应该设置此属性。这种设计常见于2009年及之后的Clickpad笔记本和Macbook。

最初，buttonpad属性被编码在bcm5974驱动程序的版本字段中，名为integrated button。为了保持向后兼容性，用户空间需要检查两种方法。

### INPUT_PROP_SEMI_MT

一些触摸板（最常见于2008年至2011年间）能够检测多个接触点的存在，但无法解析各个接触点的具体位置；只知道接触点的数量和一个矩形区域。对于这类触摸板，应设置SEMI_MT属性。

根据设备的不同，该矩形可能包含所有接触点，像一个包围框，或者只包含其中的一些接触点，例如最近的两个接触点。由于其多样性，该矩形的用途有限，但通常可以从其中提取一些手势。

如果未设置INPUT_PROP_SEMI_MT，则假定该设备是一个真正的多点触控（MT）设备。

### INPUT_PROP_TOPBUTTONPAD

一些笔记本电脑（尤其是Lenovo 40系列）提供了轨迹棒（trackstick）设备，但没有与之关联的物理按钮。相反，触摸板的顶部区域标示了用于轨迹棒的左、中、右按钮的视觉/触觉区域。

如果设置了INPUT_PROP_TOPBUTTONPAD，用户空间应该相应地模拟按钮。此属性不影响内核行为。

内核不会为这些设备提供按钮模拟，而是将它们视为普通的INPUT_PROP_BUTTONPAD设备处理。

### INPUT_PROP_ACCELEROMETER

此设备上的方向轴（绝对或相对的x、y、z轴）表示加速度计数据。某些设备还报告陀螺仪数据，可以通过旋转轴（绝对或相对的rx、ry、rz轴）来报告。

所有其他轴保留其原有意义。设备不应在同一事件节点上混合使用常规方向轴和加速度计轴。
### 指南
#### 

以下指南确保了单点触控和多点触控功能的正确实现。
对于多点触控功能，请参阅 multi-touch-protocol.rst 文档获取更多信息。

### 鼠标
---

当鼠标移动时，必须报告 `REL_{X,Y}`。使用 `BTN_LEFT` 报告主按钮按下。使用 `BTN_{MIDDLE,RIGHT,4,5,等}` 报告设备的其他按钮。如果有滚轮事件，应使用 `REL_WHEEL` 和 `REL_HWHEEL` 进行报告。

### 触摸屏
---

触摸位置必须通过 `ABS_{X,Y}` 进行报告。使用 `BTN_TOUCH` 报告屏幕上的触控活动。

不应将触摸接触结果报告为 `BTN_{MOUSE,LEFT,MIDDLE,RIGHT}`。尽可能使用 `BTN_TOOL_<name>` 事件进行报告。

对于新硬件，应设置 `INPUT_PROP_DIRECT`。

### 触控板
---

仅提供相对位置信息的传统触控板必须像鼠标一样报告事件。

提供绝对触摸位置的触控板必须使用 `ABS_{X,Y}` 报告触摸位置。使用 `BTN_TOUCH` 报告触控板上的触摸活动。如果有支持多指操作，应使用 `BTN_TOOL_<name>` 报告触控板上的触摸数量。

对于新硬件，应设置 `INPUT_PROP_POINTER`。

### 平板
---

当手写笔或其他工具在平板上活动时，必须报告 `BTN_TOOL_<name>` 事件。使用 `ABS_{X,Y}` 报告工具的位置。使用 `BTN_TOUCH` 报告工具与平板接触的情况。
BTN_{STYLUS,STYLUS2} 应用于报告工具本身上的按钮。平板上的按钮可以使用任何按键编码，但不包括 BTN_{MOUSE, LEFT}。BTN_{0,1,2,等等} 是适用于未标记按钮的良好通用编码。除非设备上的按钮明确标记了特定功能（如 BTN_FORWARD），否则不要使用具有特定意义的按钮编码。
对于新硬件，应同时设置 INPUT_PROP_DIRECT 和 INPUT_PROP_POINTER。
