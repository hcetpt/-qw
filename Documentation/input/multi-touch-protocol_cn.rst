```markdown
.. include:: <isonum.txt>

=========================
多点触控（MT）协议
=========================

:版权: |copy| 2009-2010 Henrik Rydberg <rydberg@euromail.se>

简介
------------

为了充分利用新型多点触控和多用户设备的全部功能，需要一种方法来报告多个接触点的详细数据，即直接与设备表面接触的对象。本文档描述了多点触控（MT）协议，该协议允许内核驱动程序报告任意数量接触点的详细信息。该协议根据硬件的能力分为两种类型。对于处理匿名接触点（类型A）的设备，该协议描述了如何将所有接触点的原始数据发送给接收方。对于能够跟踪可识别接触点（类型B）的设备，该协议描述了如何通过事件槽发送单个接触点的更新。

.. note::
   MT协议类型A已过时，所有内核驱动程序均已转换为使用类型B。

协议用法
------------

接触点的详细信息以ABS_MT事件的单独数据包形式依次发送。只有ABS_MT事件被视为接触数据包的一部分。由于这些事件被当前的单点触控（ST）应用程序忽略，因此可以在现有驱动程序中基于ST协议实现MT协议。

类型A设备的驱动程序通过在每个数据包末尾调用input_mt_sync()来分隔接触数据包。这会产生一个SYN_MT_REPORT事件，指示接收方接受当前接触的数据并准备接收另一个。

类型B设备的驱动程序通过在每个数据包开始时调用input_mt_slot()，并将槽作为参数来分隔接触数据包。这会产生一个ABS_MT_SLOT事件，指示接收方准备接收给定槽的更新。

所有驱动程序通过调用通常的input_sync()函数来标记一个多点触控传输的结束。这指示接收方对自上次EV_SYN/SYN_REPORT以来累积的事件采取行动，并准备接收新的一组事件/数据包。

无状态类型A协议与有状态类型B槽协议之间的主要区别在于使用可识别的接触点来减少发送到用户空间的数据量。槽协议要求使用ABS_MT_TRACKING_ID，该ID要么由硬件提供，要么从原始数据计算得出 [#f5]_。

对于类型A设备，内核驱动程序应生成当前表面上所有匿名接触点的任意枚举。这些数据包在事件流中的出现顺序并不重要。事件过滤和手指跟踪留给用户空间处理 [#f3]_。
```
对于类型B设备，内核驱动程序应为每个识别到的接触点分配一个槽，并使用该槽传播接触点的变化。接触点的创建、替换和销毁是通过修改相关槽的`ABS_MT_TRACKING_ID`来实现的。非负的跟踪ID表示一个接触点，值-1表示未使用的槽。新出现的跟踪ID被视为新的接触点，而消失的跟踪ID则被视为移除的接触点。由于仅传播变化信息，每个启动的接触点的完整状态需要在接收端保存。接收到MT事件时，只需更新当前槽的相应属性。

有些设备可以识别和/或跟踪比它们能报告给驱动程序更多的接触点。对于这样的设备，其驱动程序应为硬件报告的每个接触点分配一个类型B槽。每当与某个槽关联的接触点的身份发生变化时，驱动程序应通过更改其`ABS_MT_TRACKING_ID`来使该槽失效。如果硬件信号表明它正在跟踪比当前报告的更多接触点，驱动程序应使用`BTN_TOOL_*TAP`事件来通知用户空间此时硬件正在跟踪的总接触点数。驱动程序应通过显式发送相应的`BTN_TOOL_*TAP`事件并在调用`input_mt_report_pointer_emulation()`时设置`use_count`为false来完成此操作。

驱动程序只能宣传硬件能报告的槽的数量。用户空间可以通过注意到支持的最大`BTN_TOOL_*TAP`事件大于`ABS_MT_SLOT`轴的absinfo中报告的类型B槽总数来检测驱动程序能报告的总接触点多于槽的情况。

**协议示例A**

这里是一个两接触点触摸的最小事件序列示例（适用于类型A设备）：

```
ABS_MT_POSITION_X x[0]
ABS_MT_POSITION_Y y[0]
SYN_MT_REPORT
ABS_MT_POSITION_X x[1]
ABS_MT_POSITION_Y y[1]
SYN_MT_REPORT
SYN_REPORT
```

移动其中一个接触点后的序列完全相同；每次同步时都会发送所有现有接触点的原始数据。

这里是抬起第一个接触点后的序列：

```
ABS_MT_POSITION_X x[1]
ABS_MT_POSITION_Y y[1]
SYN_MT_REPORT
SYN_REPORT
```

这里是抬起第二个接触点后的序列：

```
SYN_MT_REPORT
SYN_REPORT
```

如果驱动程序除了`ABS_MT`事件之外还报告了`BTN_TOUCH`或`ABS_PRESSURE`中的一个，那么最后一个`SYN_MT_REPORT`事件可以省略。否则，输入核心将丢弃最后一个`SYN_REPORT`，导致没有零接触点事件到达用户空间。

**协议示例B**

这里是一个两接触点触摸的最小事件序列示例（适用于类型B设备）：

```
ABS_MT_SLOT 0
ABS_MT_TRACKING_ID 45
ABS_MT_POSITION_X x[0]
ABS_MT_POSITION_Y y[0]
ABS_MT_SLOT 1
ABS_MT_TRACKING_ID 46
ABS_MT_POSITION_X x[1]
ABS_MT_POSITION_Y y[1]
SYN_REPORT
```

这里是沿X方向移动接触点45后的序列：

```
ABS_MT_SLOT 0
ABS_MT_POSITION_X x[0]
SYN_REPORT
```

这里是抬起槽0中的接触点后的序列：

```
ABS_MT_TRACKING_ID -1
SYN_REPORT
```

被修改的槽已经是0，因此省略了`ABS_MT_SLOT`。这条消息解除了槽0与接触点45之间的关联，从而销毁了接触点45并释放了槽0以供其他接触点重用。

最后，这里是抬起第二个接触点后的序列：

```
ABS_MT_SLOT 1
ABS_MT_TRACKING_ID -1
SYN_REPORT
```

**事件使用**

定义了一组具有所需特性的`ABS_MT`事件。这些事件分为不同的类别，以便允许部分实现。最小的一组包括`ABS_MT_POSITION_X`和`ABS_MT_POSITION_Y`，这使得可以跟踪多个接触点。如果设备支持的话，可以使用`ABS_MT_TOUCH_MAJOR`和`ABS_MT_WIDTH_MAJOR`来提供接触区域和接近工具的大小。
TOUCH 和 WIDTH 参数具有几何解释；想象一下，你透过窗户看到一个人轻轻将手指按在玻璃上。你会看到两个区域：一个内区域是手指实际接触玻璃的部分，一个外区域是由手指边缘形成的。接触区域的中心（a）为 ABS_MT_POSITION_X/Y，接近的手指中心（b）为 ABS_MT_TOOL_X/Y。接触直径为 ABS_MT_TOUCH_MAJOR，手指直径为 ABS_MT_WIDTH_MAJOR。现在想象这个人更用力地按压手指。接触区域会增大，通常情况下，ABS_MT_TOUCH_MAJOR / ABS_MT_WIDTH_MAJOR 的比率总是小于 1，并且与接触压力有关。对于基于压力的设备，可以使用 ABS_MT_PRESSURE 来提供接触面积上的压力。具备接触悬停功能的设备可以使用 ABS_MT_DISTANCE 来指示接触点与表面之间的距离。

```
Linux MT                               Win8
__________                     _______________________
|          |                   |                       |
|            |                  |                       |
|     ____     |                 |                       |
|     /    \     |                |                       |
|     \  a  \     |               |       a               |
|     \____/      |              |                       |
|                 |             |                       |
|        b        |            |           b           |
|                 |           |                       |
|                 |          |                       |
|                 |         |                       |
|                /         |                       |
|              /          |                       |
|            /           |                       |
|__________/            |_______________________|
```

除了 MAJOR 参数外，还可以通过添加 MINOR 参数来描述接触和手指区域的椭圆形。MAJOR 和 MINOR 分别是椭圆的长轴和短轴。接触椭圆的方向可以通过 ORIENTATION 参数来描述，手指椭圆的方向由向量 (a - b) 给出。对于类型 A 设备，可以通过 ABS_MT_BLOB_ID 进一步指定触摸形状。ABS_MT_TOOL_TYPE 可用于指定触摸工具是手指、笔还是其他东西。最后，可以使用 ABS_MT_TRACKING_ID 事件来跟踪已识别的接触点随时间的变化。在类型 B 协议中，ABS_MT_TOOL_TYPE 和 ABS_MT_TRACKING_ID 由输入核心隐式处理；驱动程序应调用 input_mt_report_slot_state()。

事件语义
---------

ABS_MT_TOUCH_MAJOR
    接触点长轴的长度。长度应以表面单位给出。如果表面的分辨率为 X×Y，则 ABS_MT_TOUCH_MAJOR 的最大可能值为 sqrt(X^2 + Y^2)，即对角线长度。

ABS_MT_TOUCH_MINOR
    接触点短轴的长度。如果接触点是圆形的，可以省略此事件。

ABS_MT_WIDTH_MAJOR
    接近工具长轴的长度。这应该理解为工具本身的大小。假设接触点和接近工具的方向相同。

ABS_MT_WIDTH_MINOR
    接近工具短轴的长度。如果是圆形，可以省略。

上述四个值可用于推导关于接触点的附加信息。ABS_MT_TOUCH_MAJOR / ABS_MT_WIDTH_MAJOR 的比率近似表示压力的概念。手上的手指和手掌都有不同的特征宽度。
### ABS_MT_PRESSURE
接触区域上的压力，以任意单位表示。可用于基于压力的设备或任何具有空间信号强度分布的设备，代替TOUCH和WIDTH。
- 如果分辨率是零，则压力数据以任意单位表示。
- 如果分辨率是非零值，则压力数据以单位/克表示。详情请参阅 :ref:`input-event-codes`。

### ABS_MT_DISTANCE
接触点与表面之间的距离，以表面单位表示。零距离表示接触点正在接触表面；正数表示接触点在表面上方悬停。

### ABS_MT_ORIENTATION
接触椭圆的方向。该值应描述围绕触点中心顺时针旋转的四分之一圈的有符号值。有符号的值范围是任意的，但当椭圆与表面的Y轴（北方）对齐时应返回零；当椭圆向左转时应返回负值；当椭圆向右转时应返回正值。当椭圆与X轴正方向对齐时，应返回范围的最大值；当椭圆与X轴负方向对齐时，应返回范围的最小值（-max）。
默认情况下，接触椭圆是对称的。对于能够实现真正360度方向的设备，报告的方向必须超过范围的最大值以表示超过四分之一圈的旋转。对于倒置的手指，应返回范围最大值的两倍（range max * 2）。
如果触摸区域是圆形的，或者内核驱动程序中没有此信息，可以省略方向。如果设备能够区分两个轴，但不能唯一地识别中间的任何值，则可以支持部分方向。在这种情况下，ABS_MT_ORIENTATION的范围应为[0, 1]。

### ABS_MT_POSITION_X
接触椭圆中心的表面X坐标。

### ABS_MT_POSITION_Y
接触椭圆中心的表面Y坐标。

### ABS_MT_TOOL_X
接近工具中心的表面X坐标。如果设备无法区分预期的触点和工具本身，则可省略。
### ABS_MT_TOOL_Y
接触工具中心的表面Y坐标。如果设备无法区分预期的触摸点和工具本身，则可以省略。

四个位置值可用于将触摸位置与工具位置分开。如果两个位置都存在，主要工具轴指向触摸点[#f1]_。否则，工具轴与触摸轴对齐。

### ABS_MT_TOOL_TYPE
接近工具的类型。许多内核驱动程序无法区分不同类型的工具，例如手指或笔。在这种情况下，应省略该事件。当前协议主要支持MT_TOOL_FINGER、MT_TOOL_PEN 和 MT_TOOL_PALM [#f2]_。
对于类型B设备，此事件由输入核心处理；驱动程序应使用input_mt_report_slot_state()。在触摸设备时，一个接触的ABS_MT_TOOL_TYPE可能会随时间改变，因为固件在首次出现时可能无法确定所使用的工具。

### ABS_MT_BLOB_ID
BLOB_ID将多个数据包组合成一个任意形状的接触。这些点序列形成一个多边形，定义了接触的形状。这是类型A设备的低级匿名分组，不应与高级跟踪ID [#f5]_混淆。大多数类型A设备不具备blob功能，因此驱动程序可以安全地省略此事件。

### ABS_MT_TRACKING_ID
TRACKING_ID在整个生命周期中标识一个已启动的接触[#f5]_。TRACKING_ID的值范围应足够大，以确保在较长时间内唯一标识一个接触。对于类型B设备，此事件由输入核心处理；驱动程序应使用input_mt_report_slot_state()。

### 事件计算

不同硬件的多样性不可避免地导致某些设备更适合MT协议。为了简化和统一映射，本节提供了一些如何计算特定事件的方法。

对于报告矩形形状接触的设备，无法获得有符号的方向。假设X和Y是接触矩形的边长，以下是一个简单公式，保留尽可能多的信息：

```
ABS_MT_TOUCH_MAJOR := max(X, Y)
ABS_MT_TOUCH_MINOR := min(X, Y)
ABS_MT_ORIENTATION := bool(X > Y)
```

ABS_MT_ORIENTATION的范围应设置为[0, 1]，以表示设备可以区分沿Y轴的手指（0）和沿X轴的手指（1）。

对于具有T和C坐标的Win8设备，位置映射如下：

```
ABS_MT_POSITION_X := T_X
ABS_MT_POSITION_Y := T_Y
ABS_MT_TOOL_X := C_X
ABS_MT_TOOL_Y := C_Y
```

不幸的是，没有足够的信息来指定触摸椭圆和工具椭圆，因此必须进行近似。一种简单且与早期用法兼容的方案如下：

```
ABS_MT_TOUCH_MAJOR := min(X, Y)
ABS_MT_TOUCH_MINOR := <not used>
ABS_MT_ORIENTATION := <not used>
ABS_MT_WIDTH_MAJOR := min(X, Y) + distance(T, C)
ABS_MT_WIDTH_MINOR := min(X, Y)
```

理由：我们没有关于触摸椭圆方向的信息，因此用内切圆代替。工具椭圆应该与向量(T - C)对齐，因此直径必须随着distance(T, C)增加。最后，假设触摸直径等于工具厚度，从而得出上述公式。

### 手指追踪

手指追踪的过程，即为表面上每个启动的接触分配一个唯一的跟踪ID，是一个欧几里得二部匹配问题。每次事件同步时，实际的接触集将与上次同步的接触集匹配。完整的实现可以在[#f3]_中找到。
手势
--------

在创建手势事件的具体应用中，可以使用TOUCH和WIDTH参数来近似模拟手指的压力或区分食指和拇指。通过增加MINOR参数，还可以区分扫动的手指和指向的手指，并且通过ORIENTATION参数，可以检测手指的扭转。
注释
--------

为了与现有应用程序保持兼容性，手指数据包中报告的数据不应被识别为单点触摸事件。
对于类型A设备，所有手指数据都会绕过输入过滤，因为同一类型的后续事件指的是不同的手指。
.. [#f1] 此外，(TOOL_X - POSITION_X) 的差值可用于建模倾斜。
.. [#f2] 当然，这个列表可以扩展。
.. [#f3] mtdev项目：http://bitmath.org/code/mtdev/
.. [#f4] 请参阅事件计算部分。
.. [#f5] 请参阅手指追踪部分。
