========================================
关于强健的 futex 的描述
========================================

:发起人: Ingo Molnar <mingo@redhat.com>

背景
----------

什么是强健的 futex？要回答这个问题，我们首先需要理解 futex 是什么：普通的 futex 是一种特殊的锁类型，在没有争用的情况下可以从用户空间获取/释放而不必进入内核。futex 本质上是一个用户空间地址，例如一个 32 位的锁变量字段。如果用户空间检测到争用（锁已被占用并且还有其他进程想要获取），则会在锁上标记一个值表示“有等待者”，并使用 `sys_futex(FUTEX_WAIT)` 系统调用来等待其他进程释放锁。内核会内部创建一个“futex 队列”，以便稍后将等待者与唤醒者匹配——而它们之间无需知道对方的存在。

当持有锁的线程释放 futex 时，它会通过变量值注意到有等待者存在，并执行 `sys_futex(FUTEX_WAKE)` 系统调用来唤醒这些等待者。一旦所有等待者都获取并释放了锁，futex 就再次回到“无争用”状态，此时内核没有任何与之相关的状态信息。内核完全忘记了该地址曾有过一个 futex。这种方法使得 futex 非常轻量且可扩展。

“强健性”是指在持有锁期间处理崩溃问题：如果一个进程在持有 `pthread_mutex_t` 锁的同时意外退出（例如 yum 在持有 `pthread_mutex_t` 时发生段错误或被 `kill -9`），那么等待该锁的进程需要被通知锁的最后持有者以异常方式退出。

为了解决这类问题，“强健互斥锁”的用户空间 API 被创建出来：`pthread_mutex_lock()` 在持有者提前退出时返回错误值，新持有者可以决定被锁保护的数据是否可以安全恢复。

然而，基于 futex 的互斥锁有一个很大的概念性问题：是内核销毁了持有任务（例如由于段错误），但内核无法帮助清理：如果没有“futex 队列”（大多数情况下是没有的，因为 futex 是快速轻量级锁），内核就没有任何信息来清理持有的锁！用户空间也没有机会在锁之后进行清理——用户空间就是那个崩溃的部分，所以它没有机会进行清理。这是一个两难的问题。

实际上，当例如 yum 被 `kill -9`（或发生段错误）时，需要系统重启才能释放基于 futex 的锁。这是针对 yum 的主要 bug 报告之一。

为了解决这个问题，传统的做法是扩展 vma（虚拟内存区域描述符）的概念，使其具有“附加到该区域的待处理强健 futex”的概念。这种方法需要对 `sys_futex()` 增加三个新的系统调用变体：`FUTEX_REGISTER`、`FUTEX_DEREGISTER` 和 `FUTEX_RECOVER`。在 `do_exit()` 时，所有 vma 都会被检查是否有 `robust_head` 设置。这种方法有两个根本性的问题：

- 它具有相当复杂的锁定和竞争场景。vma 基于的方法已经拖延多年，但仍然不够可靠。
- 必须在 `sys_exit()` 时扫描每个 vma！

第二个缺点是一个真正的致命问题：`pthread_exit()` 在 Linux 上大约需要 1 微秒，但如果每个 `pthread_exit()` 都要扫描数千个（或数万个）vma，则每次 `pthread_exit()` 需要一毫秒或更长时间，还会彻底破坏 CPU 的 L1 和 L2 缓存！

即使对于正常的进程 `sys_exit_group()` 调用，这也是非常明显的：内核必须无条件地进行 vma 扫描！（这是因为内核不知道有多少强健 futex 需要清理，因为一个强健 futex 可能已在另一个任务中注册，并且 futex 变量可能只是通过 `mmap()` 映射到了当前进程的地址空间）

这种巨大的开销迫使创建了 `CONFIG_FUTEX_ROBUST`，使得普通内核可以关闭它，但更糟糕的是：这种开销使得强健 futex 对任何类型的通用 Linux 发行版都不实用。
因此，必须采取一些措施。
新的健壮futex方法
-------------------

这种新方法的核心是每个线程私有的、用户空间持有的健壮锁列表（由glibc维护）——该用户空间列表通过一个新的系统调用注册到内核[每个线程生命周期中最多注册一次]。在do_exit()时，内核会检查这个用户空间列表：是否有需要清理的健壮futex锁？

在常见情况下，在do_exit()时，并没有注册任何列表，因此健壮futex的成本只是一个简单的current->robust_list != NULL比较操作。如果线程注册了列表，则通常这个列表是空的。如果线程/进程以某种不正确的方式崩溃或终止，那么这个列表可能非空：在这种情况下，内核会仔细遍历这个列表[不信任它]，并给这个线程拥有的所有锁设置FUTEX_OWNER_DIED位，并唤醒一个等待者（如果有）。由于这个列表在do_exit()时保证是私有的且与线程绑定的，因此内核可以在无锁的情况下访问它。

不过存在一种竞态条件：因为向列表添加和从列表移除是在glibc获取futex之后进行的，所以在这几个指令执行期间，线程（或进程）可能会在此时死亡，导致futex挂起。为了防止这种情况，用户空间（glibc）还维护了一个简单的每线程'list_op_pending'字段，允许内核在获取锁后但还未将自身添加到列表之前清理线程。glibc在尝试获取futex之前设置这个list_op_pending字段，在列表添加（或移除）完成后清除它。

这就足够了——其余的健壮futex清理工作都在用户空间完成[就像之前的补丁一样]。Ulrich Drepper已经为这个新机制实现了必要的glibc支持，这完全启用了健壮互斥锁。

基于用户空间列表的方法与基于vma的方法的关键区别：

- 它快得多：在线程退出时，不需要遍历每一个vma（！），而基于VM的方法必须这样做。仅需执行一个非常简单的“列表是否为空”的操作。
- 不需要对VM进行任何更改——'struct address_space'保持不变。
- 不需要单独注册每个锁：健壮互斥锁不需要额外的每锁系统调用。健壮互斥锁因此成为一个非常轻量级的原语——因此不会迫使应用程序设计者在性能和健壮性之间做出艰难的选择——健壮互斥锁同样快速。
- 没有每锁的内核分配发生。
无需资源限制  
无需内核空间恢复调用（FUTEX_RECOVER）  
实现和加锁是“显而易见”的，并且没有与虚拟内存管理器（VM）的交互

性能
------------

我已经对内核处理包含100万个已持有的锁列表所需的时间进行了基准测试，使用新方法[在2GHz CPU上]：

- 设置了FUTEX_WAIT [有竞争的互斥锁]：130毫秒
- 未设置FUTEX_WAIT [无竞争的互斥锁]：30毫秒

我还测量了一种方法，其中glibc负责锁通知[目前它确实用于非共享的强健互斥锁]，这种方法耗时256毫秒——明显更慢，因为用户空间需要执行100万个FUTEX_WAKE系统调用。
（持有100万个锁的情况极为罕见——我们预计同时最多只有几个锁被持有。不过，知道这种方法具有良好的扩展性还是令人欣慰的。）

实现细节
----------------------

该补丁添加了两个新的系统调用：一个用于注册用户空间列表，另一个用于查询已注册的列表指针：

```c
asmlinkage long
sys_set_robust_list(struct robust_list_head __user *head,
                    size_t len);

asmlinkage long
sys_get_robust_list(int pid, struct robust_list_head __user **head_ptr,
                    size_t __user *len_ptr);
```

列表注册非常快：指针简单地存储在`current->robust_list`中。（请注意，将来如果强健futex变得广泛使用，我们可以扩展`sys_clone()`来为新线程注册强健列表头，而无需额外的系统调用。）

因此，对于不使用强健futex的任务几乎没有开销，即使对于强健futex用户，每个线程生命周期也只有一个额外的系统调用，如果发生清理操作，速度也非常快且直接。内核内部并没有区分强健futex和普通futex。

如果在退出时发现某个futex被持有，内核会设置futex字的以下位：

```c
#define FUTEX_OWNER_DIED        0x40000000
```

并唤醒下一个futex等待者（如果有）。用户空间完成其余的清理工作。

否则，强健futex通过glibc通过原子地将TID放入futex字段来获取。等待者设置FUTEX_WAITERS位：

```c
#define FUTEX_WAITERS           0x80000000
```

剩余的位用于表示TID。

测试、架构支持
-----------------------------

我在x86和x86_64上测试了新的系统调用，并确保即使列表被故意破坏，用户空间列表的解析也是强健的。
当前i386和x86_64系统调用已经连接好，并且Ulrich已经在x86_64和i386上测试了新的glibc代码，对于他的强健互斥锁测试用例有效。
所有其他架构也应该能够正常构建——但它们还没有新的系统调用。
架构需要在编写系统调用之前实现新的 futex_atomic_cmpxchg_inatomic() 内联函数。
