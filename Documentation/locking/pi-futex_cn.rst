轻量级 PI-futexes
======================

我们称其为轻量级有三个原因：

- 在用户空间的快速路径中，PI 启用的 futex 不涉及任何内核工作（或任何其他 PI 复杂性）。无需注册，无需额外的内核调用——仅在用户空间进行纯粹的快速原子操作。
- 即使在慢速路径中，系统调用和调度模式也非常类似于普通 futexes。
- 内核中的 PI 实现围绕互斥锁抽象进行了简化，并且严格遵循一些规则以保持实现相对简单：只有一个所有者可以拥有一个锁（即不支持读写锁），只有所有者可以解锁，不允许递归锁定等。

优先级继承 - 为什么？
---------------------------

简短的回答：用户空间中的 PI 帮助实现/改进用户空间应用程序的确定性。在最佳情况下，它可以有助于实现确定性和良好的延迟界限。即使在最坏的情况下，PI 也会改善与锁定相关的应用程序延迟的统计分布。
更长的回答
----------------

首先，多个任务之间共享锁是一种常见的编程技术，通常无法用无锁算法替代。正如我们在内核中看到的一样[内核本身是一个相当复杂的程序]，无锁结构是例外而不是常态——当前无锁代码与有锁代码对于共享数据结构的比例大约在 1:10 到 1:100 之间。无锁很难实现，而且无锁算法的复杂性往往威胁到对该代码进行稳健审查的能力。因此，关键实时应用程序通常选择锁结构来保护关键数据结构，而不是使用无锁算法。此外，在某些情况下（如共享硬件或其他资源限制），无锁访问在数学上是不可能实现的。
媒体播放器（如 Jack）是一个合理的设计示例，其中多个任务（具有不同优先级级别）共享短期持有的锁：例如，高优先级音频回放线程与中优先级构建音频数据线程和低优先级显示彩色内容线程相结合。加入视频和解码后，我们将有更多的优先级级别。
因此，一旦我们接受同步对象（锁）是生活中不可避免的事实，并且一旦我们接受多任务用户空间应用程序有充分的理由能够使用锁，我们就必须考虑如何向用户空间提供确定性锁定实现的选择。
大多数反对实现优先级继承的技术论点仅适用于内核空间中的锁。但用户空间中的锁是不同的，我们不能在临界区禁用中断或使任务不可抢占，因此“使用自旋锁”的论点不适用（用户空间自旋锁与其他用户空间锁定构造一样存在优先级反转问题）。事实是，目前唯一能为用户空间锁（如基于 futex 的 pthread 互斥锁）提供良好确定性的技术是优先级继承：

目前（没有 PI），如果一个高优先级任务和一个低优先级任务共享一个锁（这在大多数非平凡的实时应用中是一个相当常见的情况），即使所有的临界区都经过精心编码以确保确定性（即所有的临界区持续时间很短且只执行有限数量的指令），内核也无法保证高优先级任务的确定性执行：任何中优先级的任务都可以在低优先级任务持有共享锁并执行临界区时抢占它，并无限期地延迟它。

实现
--------------

如前所述，PI 启用的 pthread 互斥锁的用户空间快速路径完全不涉及内核工作——它们的行为非常类似于普通的基于 futex 的锁：值为 0 表示未锁定，值等于 TID 表示已锁定。（这是与基于列表的健壮 futex 使用相同的方法。）用户空间使用原子操作来锁定/解锁这些互斥锁而无需进入内核。
为了处理慢路径，我们新增了两个 futex 操作：

  - FUTEX_LOCK_PI
  - FUTEX_UNLOCK_PI

如果锁获取的快路径失败（即原子从 0 到 TID 的转换失败），则会调用 FUTEX_LOCK_PI。内核完成所有剩余的工作：如果没有 futex 队列连接到 futex 地址，则代码查找拥有该 futex 的任务[它将自己的 TID 放入 futex 值中]，并附上一个 'PI 状态' 结构到 futex 队列。pi_state 包含一个实时互斥锁（rt-mutex），这是一个内核级别的同步对象，支持优先级继承（PI）。将 '另一个' 任务设为 rt-mutex 的所有者，并在 futex 值中原子设置 FUTEX_WAITERS 标志。然后此任务尝试锁定 rt-mutex 并在此过程中阻塞。一旦返回，它就获得了该互斥锁，并将其 TID 设置为 futex 值，然后返回。用户空间没有其他工作需要执行——此时它拥有了锁，并且 futex 值包含 FUTEX_WAITERS|TID。

如果解锁的快路径成功（即用户空间成功实现了 futex 值从 TID 到 0 的原子转换），则不会触发任何内核工作。
如果解锁快路径失败（因为设置了 FUTEX_WAITERS 标志），则会调用 FUTEX_UNLOCK_PI，并且内核代表用户空间解锁 futex —— 同时也解锁附加的 pi_state->rt_mutex，从而唤醒任何潜在的等待者。
需要注意的是，在这种方案下，与之前的 PI-futex 方法不同，不需要预先“注册”PI-futex。[由于 pthread 互斥锁现有的 ABI 属性，这也是不可能的。]

此外，在这种方案下，“健壮性”和“PI”是 futex 的两个正交属性，四种组合都是可能的：futex、健壮 futex、PI futex、健壮 + PI futex。
关于优先级继承的更多细节可以在 Documentation/locking/rt-mutex.rst 中找到。
