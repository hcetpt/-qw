运行时锁正确性验证器
=====================================

由 Ingo Molnar <mingo@redhat.com> 发起

Arjan van de Ven <arjan@linux.intel.com> 增加内容

锁类
----------

验证器操作的基本对象是一个“锁类”。一个锁类是一组在锁定规则上逻辑相同的锁，即使这些锁可能有多个（可能成千上万）实例。例如，inode 结构中的一个锁是一个类，而每个 inode 都有自己的该锁类的实例。验证器跟踪锁类的“使用状态”，并跟踪不同锁类之间的依赖关系。锁的使用表示锁在其 IRQ 上下文中的使用方式，而锁的依赖可以理解为锁的顺序，其中 L1 -> L2 表示任务在持有 L1 的同时尝试获取 L2。从 lockdep 的角度来看，两个锁（L1 和 L2）不一定相关；这种依赖仅仅意味着该顺序曾经发生过。验证器持续努力证明锁的使用和依赖是正确的，否则如果错误将发出警告。

锁类的行为是由其所有实例共同构建的：当某个锁类的第一个实例在启动后被使用时，该类就会被注册，然后所有后续的实例都会映射到该类，因此它们的使用和依赖都会贡献给该类。当锁实例消失时，锁类不会消失，但如果锁类的内存空间（静态或动态）被回收，则会移除锁类，例如当模块卸载或工作队列被销毁时。

状态
-----

验证器跟踪锁类的使用历史，并将其划分为 (4 个使用 * n 状态 + 1) 类别：

其中 4 个使用可以是：

- '在 STATE 上下文中曾被持有'
- '在 STATE 上下文中曾作为读锁被持有'
- '在 STATE 启用时曾被持有'
- '在 STATE 启用时曾作为读锁被持有'

其中 n 个 STATE 在内核的 kernel/locking/lockdep_states.h 中定义，目前包括：

- hardirq
- softirq

最后 1 个类别是：

- '曾被使用'                                       [ == !unused        ]

当违反锁定规则时，这些使用位会在锁定错误消息中以大括号的形式显示，总共 2 * n STATEs 位。

一个构造的例子如下：

```
modprobe/2287 正在尝试获取锁：
(&sio_locks[i].lock){-.-.}，位置：[<c02867fd>] mutex_lock+0x21/0x24

但任务已经持有锁：
(&sio_locks[i].lock){-.-.}，位置：[<c02867fd>] mutex_lock+0x21/0x24
```

对于给定的锁，从左到右的位表示该锁及其读锁（如果存在），分别针对上面列出的每个 n STATE 的使用情况，每个位位置显示的字符表示：

   ===  ===================================================
   '.'  在 IRQ 被禁用且不在 IRQ 上下文中获取
   '-'  在 IRQ 上下文中获取
   '+'  在 IRQ 启用时获取
   '?'  在 IRQ 上下文中且 IRQ 启用时获取
   ===  ===================================================

位通过一个例子来说明：

```
(&sio_locks[i].lock){-.-.}，位置：[<c02867fd>] mutex_lock+0x21/0x24
                         ||||
                         ||| \-> softirq 被禁用且不在 softirq 上下文中
                         || \--> 在 softirq 上下文中获取
                         | \---> hardirq 被禁用且不在 hardirq 上下文中
                          \----> 在 hardirq 上下文中获取
```

对于给定的 STATE，锁是否曾在该 STATE 上下文中被获取以及该 STATE 是否启用会产生四种可能的情况，如下面表格所示。位字符能够指示锁在报告时刻的确切情况。

+--------------+-------------+--------------+
  |              | IRQ 启用 | IRQ 禁用 |
  +--------------+-------------+--------------+
  | 曾在 IRQ 中  |     '?'     |      '-'     |
  +--------------+-------------+--------------+
  | 从未在 IRQ 中 |     '+'     |      '.'     |
  +--------------+-------------+--------------+

字符 '-' 表示 IRQ 被禁用，因为如果 IRQ 启用则会显示 '?'。类似地，对于 '+' 也可以进行类似的推断。

未使用的锁（例如互斥锁）不能成为错误的原因。

单锁状态规则：
------------------------

一个锁被认为是 IRQ 安全的，意味着它曾在 IRQ 上下文中被使用过，而一个锁被认为是 IRQ 不安全的，意味着它曾在 IRQ 启用时被获取过。
一个软中断（softirq）不安全的锁类自动也是硬中断（hardirq）不安全的。以下状态必须是互斥的：对于任何基于其使用的锁类，只允许设置其中之一：

<硬中断安全> 或 <硬中断不安全>
<软中断安全> 或 <软中断不安全>

这是因为如果一个锁可以在中断上下文中使用（中断安全），那么它永远不能在中断启用的情况下获取（中断不安全）。否则，可能会发生死锁。例如，在获取这个锁但未释放之前，如果上下文被中断，则会尝试两次获取该锁，从而导致死锁，这种现象称为锁递归死锁。
验证器检测并报告违反这些单锁状态规则的锁使用情况。
多锁依赖规则：
-------------------

相同的锁类不能被获取两次，因为这可能导致锁递归死锁。
此外，两个锁不能逆序获取：

<L1> -> <L2>
<L2> -> <L1>

因为这可能导致死锁——称为锁反转死锁——因为试图获取这两个锁会形成一个循环，导致两个上下文永久等待对方。验证器可以在任意复杂度下找到这种依赖循环，即在获取锁操作之间可以有任意其他锁定序列；验证器仍然会发现这些锁是否以循环方式获取。
此外，不允许在任何两个锁类之间存在基于以下使用的锁依赖关系：

<硬中断安全> -> <硬中断不安全>
<软中断安全> -> <软中断不安全>

第一条规则的原因是，硬中断安全的锁可能被硬中断上下文获取，从而中断硬中断不安全的锁，并可能导致锁反转死锁。同样地，软中断安全的锁可能被软中断上下文获取，从而中断软中断不安全的锁。
上述规则适用于内核中发生的任何锁定序列：当获取新锁时，验证器检查新锁与已持有的锁之间是否存在任何规则违规。
当锁类改变其状态时，强制执行以下依赖规则的以下方面：

- 如果发现一个新的硬中断安全锁，我们检查它过去是否获取过任何硬中断不安全的锁。
- 如果发现一个新的软中断安全锁，我们检查它过去是否获取过任何软中断不安全的锁。
- 如果发现一个新的硬中断不安全锁，我们检查是否有任何硬中断安全的锁在过去获取过它。
- 如果发现一个新的软中断不安全锁，我们检查是否有任何软中断安全的锁在过去获取过它。
（再次，我们在中断上下文中进行这些检查，因为中断上下文可能会中断任何irq-不安全或hardirq-不安全的锁，这可能导致锁反转死锁——即使实际上该锁场景尚未触发。）

例外：嵌套的数据依赖导致的嵌套加锁
--------------------------------------

Linux 内核在某些情况下会获取同一锁类的多个实例。这种情况通常发生在同类型对象之间存在某种层次结构时。在这种情况下，两个对象之间有一种固有的“自然”顺序（由层次结构的属性定义），内核会在每个对象上按照这个固定顺序抓取锁。一个导致“嵌套加锁”的对象层次结构的例子是“整个磁盘”块设备对象和“分区”块设备对象；分区是整个设备的一部分，只要始终将整个磁盘锁作为高于分区锁的锁来获取，锁的顺序就是完全正确的。验证器不会自动检测这种自然顺序，因为这种顺序背后的加锁规则不是静态的。

为了教会验证器这种正确的使用模型，添加了新版本的各种加锁原语，允许你指定一个“嵌套级别”。例如，对于块设备互斥锁，调用如下所示：

```c
enum bdev_bd_mutex_lock_class {
       BD_MUTEX_NORMAL,
       BD_MUTEX_WHOLE,
       BD_MUTEX_PARTITION
};

mutex_lock_nested(&bdev->bd_contains->bd_mutex, BD_MUTEX_PARTITION);
```

在这种情况下，加锁是在已知为分区的 bdev 对象上进行的。验证器将这种以嵌套方式获取的锁视为验证目的的单独（子）类。注意：当更改代码以使用 _nested() 原语时，请务必小心并彻底检查层次结构是否正确映射，否则可能会得到假阳性或假阴性结果。

注解
----

可以使用两种构造来注解和检查在何处以及何时必须持有某些锁：lockdep_assert_held*(&lock) 和 lockdep_*pin_lock(&lock)。如其名称所暗示，lockdep_assert_held* 系列宏断言某个特定锁在某一时刻被持有（否则会生成一个 WARN）。这种注解在整个内核中广泛使用，例如 kernel/sched/core.c 中：

```c
void update_rq_clock(struct rq *rq)
{
   s64 delta;

   lockdep_assert_held(&rq->lock);
   [...]
}
```

其中持有 rq->lock 是安全更新 rq 的时钟所必需的。另一个宏系列是 lockdep_*pin_lock()，目前仅用于 rq->lock。尽管它们的应用有限，但这些注解如果感兴趣的锁“意外”解锁，则会生成一个 WARN。这对于调试带有回调的代码特别有帮助，其中上层假设锁保持不变，而下层认为可以释放并重新获取锁（无意中引入竞争）。lockdep_pin_lock() 返回一个 'struct pin_cookie'，然后由 lockdep_unpin_lock() 使用来检查是否有人篡改了锁，例如 kernel/sched/sched.h 中：

```c
static inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)
{
   rf->cookie = lockdep_pin_lock(&rq->lock);
   [...]
}

static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)
{
   [...]
   lockdep_unpin_lock(&rq->lock, rf->cookie);
}
```

虽然关于锁要求的注释可能提供有用的信息，但在调试锁问题时，注解执行的运行时检查是无价的，并且在检查代码时具有相同级别的细节。在不确定的情况下，总是优先使用注解！

100% 正确性的证明：
-------------------

验证器实现了完美的、数学上的“闭合”（锁正确性的证明），即对于内核生命周期中至少发生过一次的每一个简单的、独立的任务锁序列，验证器可以100%确定地证明，这些锁序列的任何组合和时机都不会导致任何类别的锁相关死锁。[1]

也就是说，复杂的多 CPU 和多任务锁场景不需要实际发生就可以证明死锁：只需要简单“组件”锁链至少发生一次（任何时候，在任何任务/上下文中）即可让验证器证明正确性。（例如，通常需要超过 3 个 CPU 和非常不可能的任务、IRQ 上下文和时机组合才能发生的复杂死锁，也可以在一个简单的、负载较轻的单 CPU 系统上被检测到！）

这极大地减少了内核锁定相关的质量保证的复杂性：在质量保证过程中需要做的是尽可能多地触发内核中的“简单”单任务锁依赖，至少一次，以证明锁的正确性——而不是必须触发每个可能的 CPU 锁交互组合，加上每个可能的硬中断和软中断嵌套场景（这在实际中是不可能做到的）。
.. [1]

    假设验证器本身是100%正确的，并且系统中的其他部分不会以任何方式破坏验证器的状态。
我们还假设所有NMI/SMM路径（这些路径可能会中断硬中断禁用的代码路径）都是正确的，并且不会干扰验证器。我们还假设系统中每个锁链的64位“链哈希”值是唯一的。此外，锁递归深度不得超过20。

性能：
-------

上述规则要求大量的运行时检查。如果我们每次获取锁或启用中断时都进行这种检查，系统将会变得几乎无法使用地慢。检查的复杂度为O(N^2)，因此即使只有几百个锁类，在每个事件中也需要进行数万次检查。
这个问题通过只对任何给定的“锁定场景”（每次连续获取锁的独特序列）进行一次检查来解决。维护一个简单的已持有的锁栈，并计算一个轻量级的64位哈希值，这个哈希值对于每个锁链都是唯一的。当首次验证该锁链时，将此哈希值放入一个哈希表中，这个哈希表可以以无锁的方式进行检查。如果以后再次出现相同的锁链，哈希表会告诉我们无需再次验证该锁链。

故障排除：
-----------

验证器跟踪最多MAX_LOCKDEP_KEYS数量的锁类。
超过这个数量将触发以下lockdep警告：

	(DEBUG_LOCKS_WARN_ON(id >= MAX_LOCKDEP_KEYS))

默认情况下，MAX_LOCKDEP_KEYS目前设置为8191，而典型的桌面系统中的锁类少于1000个，因此这个警告通常是由锁类泄漏或未能正确初始化锁引起的。以下是这两个问题的具体说明：

1. 在运行验证器时反复加载和卸载模块会导致锁类泄漏。问题在于每次加载模块都会为该模块的锁创建一个新的锁类集合，但模块卸载并不会移除旧的锁类（参见下面关于锁类重用的讨论）。
因此，如果反复加载和卸载该模块，锁类的数量最终将达到最大值。

2. 使用未显式初始化的大规模锁结构（如数组）。例如，一个有8192个桶的哈希表，每个桶都有自己的自旋锁spinlock_t，这将消耗8192个锁类——除非每个自旋锁在运行时显式初始化，例如使用运行时的spin_lock_init()，而不是编译时初始化器如__SPIN_LOCK_UNLOCKED()。未能正确初始化每个桶的自旋锁将保证锁类溢出。
相比之下，一个循环调用spin_lock_init()的代码将把所有8192个锁放入同一个锁类中。

总结来说，你应该始终显式地初始化你的锁。

有人可能认为应该修改验证器以允许重用锁类。然而，如果你倾向于提出这样的论点，请首先查看代码并思考所需的更改，同时记住要移除的锁类很可能已经链接到锁依赖图中。实际上，这样做比说起来要难得多。
当然，如果你确实用完了锁类别，下一步就是找到那些有问题的锁类别。首先，下面的命令会告诉你当前正在使用的锁类别的数量以及最大值：

```
grep "lock-classes" /proc/lockdep_stats
```

在一台配置适中的系统上，这个命令会产生如下输出：

```
lock-classes:                          748 [max: 8191]
```

如果分配的数量（如上例中的748）随着时间持续增加，那么很可能存在泄漏。以下命令可用于识别泄漏的锁类别：

```
grep "BD" /proc/lockdep
```

运行该命令并保存输出结果，然后与稍后运行此命令的输出进行比较以识别泄漏源。同样的输出还可以帮助你发现未初始化运行时锁的情况。

递归读锁：
-----------
本文档其余部分试图证明某种类型的循环等同于死锁的可能性。
有三种类型的锁持有者：写入者（即独占锁持有者，例如 `spin_lock()` 或 `write_lock()`），非递归读者（即共享锁持有者，例如 `down_read()`），以及递归读者（递归共享锁持有者，例如 `rcu_read_lock()`）。
我们在文档其余部分使用以下符号表示这些锁持有者：

- W 或 E：代表写入者（独占锁持有者）
- r：代表非递归读者
- R：代表递归读者
- S：代表所有读者（非递归 + 递归），因为两者都是共享锁持有者
- N：代表写入者和非递归读者，因为两者都不是递归锁持有者

显然，N 是 “r 或 W”，而 S 是 “r 或 R”。

递归读者，顾名思义，是指允许在其他相同锁实例的读者的关键区域内获取锁的锁持有者，换句话说，允许一个锁实例的嵌套读侧关键区域。
非递归读锁在尝试获取同一锁实例的另一个读锁的关键部分时，会导致自死锁。
递归读锁与非递归读锁的区别在于：
递归读锁仅被写锁持有者阻塞，而非递归读锁可能被写锁等待者阻塞。考虑以下示例：

    任务A：            任务B：

    read_lock(X);
                    write_lock(X);
    read_lock_2(X);

任务A首先通过read_lock()获取X上的读锁（无论是否为递归读锁）。当任务B试图获取X上的写锁时，它会被阻塞并成为X上写锁的等待者。此时，如果read_lock_2()是递归读锁，任务A将继续执行，因为写锁等待者不会阻塞递归读锁，因此没有死锁。然而，如果read_lock_2()是非递归读锁，则会被写锁等待者B阻塞，并导致自死锁。

同一锁实例上的读者和写者的阻塞条件：
-----------------------------------------
共有四种阻塞条件：

1. 写锁阻塞其他写锁。
2. 读锁阻塞写锁。
3. 写锁阻塞递归读锁和非递归读锁。
4. 读锁（无论是递归还是非递归）不会阻塞其他递归读锁，但可能会阻塞非递归读锁（由于潜在共存的写锁等待者）。

阻塞条件矩阵，Y表示行阻塞列，N表示不阻塞
+---+---+---+---+
     |   | W | r | R |
+---+---+---+---+
  | W | Y | Y | Y |
+---+---+---+---+
  | r | Y | Y | N |
+---+---+---+---+
  | R | Y | Y | N |
+---+---+---+---+

（W：写锁，r：非递归读锁，R：递归读锁）

递归读锁被当前写锁持有者阻塞，而不是写锁等待者。例如：

    任务A：            任务B：

    read_lock(X);

                    write_lock(X);

    read_lock(X);

对于递归读锁而言，这不是一个死锁，因为在任务B等待锁X时，第二个read_lock()不需要等待，因为它是一个递归读锁。但如果read_lock()是非递归读锁，则上述情况是一个死锁，因为即使任务B中的write_lock()无法获得锁，但它可以阻塞任务A中的第二个read_lock()。

需要注意的是，一个锁可以是写锁（独占锁）、非递归读锁（非递归共享锁）或递归读锁（递归共享锁），这取决于用于获取它的锁操作（更具体地说，是lock_acquire()函数中'read'参数的值）。换句话说，单个锁实例根据获取函数有三种类型的获取方式：独占、非递归读取和递归读取。

简而言之，我们将写锁和非递归读锁称为“非递归”锁，将递归读锁称为“递归”锁。递归锁之间不会互相阻塞，而非递归锁会互相阻塞（即使是两个非递归读锁也是如此）。非递归锁可以阻塞对应的递归锁，反之亦然。
涉及递归锁的死锁情况如下：

    TASK A:			TASK B:

	read_lock(X);			read_lock(Y);
	write_lock(Y);			write_lock(X);

任务 A 在等待任务 B 释放对 Y 的读锁，而任务 B 在等待任务 A 释放对 X 的读锁。
依赖类型和强依赖路径：
-----------------------------
锁依赖记录了一对锁在运行时获取顺序，由于锁持有者有三种类型，理论上存在九种锁依赖类型。但实际上，四种锁依赖类型就足以检测出死锁。对于每一种锁依赖：

	L1 -> L2

这意味着锁依赖在运行时观察到 L1 在 L2 被持有的情况下被持有。
在死锁检测中，我们关心的是在持有 L1 的情况下是否会被阻塞在 L2 上，换句话说，是否存在一个锁 L3 使得 L1 阻塞了 L3 并且 L3 又阻塞了 L2。因此，我们只关心 1）L1 阻塞了什么；2）什么阻塞了 L2。结果是，我们可以将 L1 的递归读者和非递归读者合并（因为它们阻塞相同类型的锁），并且可以将 L2 的写入者和非递归读者合并（因为它们被相同类型的锁阻塞）。
通过上述简化组合，在锁依赖图中有四种依赖边类型：

1) -(ER)->:
	    独占写入者到递归读者的依赖，“X -(ER)-> Y”意味着
	    X -> Y 且 X 是写入者，Y 是递归读者
2) -(EN)->:
	    独占写入者到非递归锁的依赖，“X -(EN)-> Y”意味着
	    X -> Y 且 X 是写入者，Y 是写入者或非递归读者
3) -(SR)->:
	    共享读者到递归读者的依赖，“X -(SR)-> Y”意味着
	    X -> Y 且 X 是读者（递归或非递归），Y 是递归读者
4) -(SN)->:
	    共享读者到非递归锁的依赖，“X -(SN)-> Y”意味着
	    X -> Y 且 X 是读者（递归或非递归），Y 是写入者或非递归读者
需要注意的是，给定两个锁，它们之间可能存在多种依赖关系，例如：

    TASK A:

	read_lock(X);			write_lock(Y);
	..
    TASK B:

	write_lock(X);			write_lock(Y);

在这种情况下，依赖图中既有 X -(SN)-> Y 也有 X -(EN)-> Y。
我们用 -(xN)-> 来表示那些或者是 -(EN)-> 或者是 -(SN)-> 的边，类似的，对于 -(Ex)->、-(xR)-> 和 -(Sx)-> 也适用。

“路径”是指图中的一系列连续依赖边。我们定义了一种“强路径”，它表明路径中的每个依赖都是强烈依赖，并且这条路径不允许有两个连续的依赖边（例如）为 -(xR)-> 和 -(Sx)->。换句话说，“强路径”是从一个锁走到另一个锁通过锁依赖的路径，并且如果路径中有 X -> Y -> Z（其中 X、Y、Z 是锁），那么从 X 到 Y 的走法如果是通过 -(SR)-> 或 -(ER)-> 依赖，那么从 Y 到 Z 的走法就不能通过 -(SN)-> 或 -(SR)-> 依赖。
在下一节我们将解释为什么这种路径被称为“强”的。
递归读死锁检测：
----------------------------------

我们现在证明两件事情：

引理 1：

如果有闭合的强路径（即强环），则存在一组锁定序列会导致死锁。也就是说，强环足以检测死锁。
引理 2：

如果没有闭合的强路径（即强环），则不存在任何锁定序列组合能够导致死锁。也就是说，强环是检测死锁所必需的。

通过这两个引理，我们可以轻易地说，闭合的强路径既是死锁的充分条件也是必要条件，因此闭合的强路径等同于可能发生死锁的可能性。由于闭合的强路径代表了一个可能导致死锁的依赖链，所以我们称其为“强”，考虑到有些依赖环不会导致死锁。

充分性的证明（引理 1）：

假设我们有一个强环：

	L1 -> L2 ... -> Ln -> L1

这意味着我们有以下依赖关系：

	L1 -> L2
	L2 -> L3
	...
	Ln-1 -> Ln
	Ln -> L1

现在我们可以构造一组导致死锁的锁定序列：

首先让一个 CPU/任务获取 L1 在 L1 -> L2 中，然后另一个获取 L2 在 L2 -> L3 中，依此类推。这样，所有的 Lx 在 Lx -> Lx+1 中都被不同的 CPU/任务持有。
然后因为有 L1 -> L2，所以持有 L1 的任务将会尝试获取 L2，在 L1 -> L2 中，但由于 L2 已经被另一个 CPU/任务持有，并且 L1 -> L2 和 L2 -> L3 不是 -(xR)-> 和 -(Sx)-> （这是强路径的定义），这意味着 L2 在 L1 -> L2 中是一个非递归锁（被任何人阻塞）或 L2 在 L2 -> L3 中是一个写锁（阻塞任何人），因此持有 L1 的任务无法获得 L2，必须等待持有 L2 的任务释放。

此外，我们对持有 L2 的任务也可以得出类似的结论：它必须等待持有 L3 的任务释放，依此类推。我们现在可以证明持有 Lx 的任务必须等待持有 Lx+1 的任务释放，并且注意 Ln+1 是 L1，因此形成了循环等待的情况，没有人能取得进展，从而导致死锁。

必要性的证明（引理 2）：

引理 2 等价于：如果存在死锁情况，则依赖图中必定存在一个强环。
根据维基百科[1]，如果存在死锁，则必须有一个循环等待的情况，即存在N个CPU/任务，其中CPU/task P1正在等待P2持有的锁，而P2正在等待P3持有的锁，... 并且Pn正在等待P1持有的锁。我们称Px等待的锁为Lx，因此由于P1正在等待L1并持有Ln，所以在依赖图中会有Ln -> L1。类似地，我们有L1 -> L2，L2 -> L3，...，Ln-1 -> Ln在依赖图中，这意味着我们有一个循环：

	Ln -> L1 -> L2 -> ... -> Ln

现在让我们证明这个循环是强循环：

对于一个锁Lx，Px贡献了依赖关系Lx-1 -> Lx，而Px+1贡献了依赖关系Lx -> Lx+1，并且由于Px正在等待Px+1释放Lx，所以不可能Lx在Px+1上是一个读取者而在Px上是一个递归读取者，因为读取者（无论是递归还是非递归）都不会阻塞递归读取者。因此，Lx-1 -> Lx 和 Lx -> Lx+1 不能是一对-(xR)-> -(Sx)->，这对循环中的任何锁都成立，因此这个循环是强循环。

参考文献：
-----------
[1]: https://en.wikipedia.org/wiki/Deadlock
[2]: Shibu, K. (2009). Intro To Embedded Systems (1st ed.). Tata McGraw-Hill
