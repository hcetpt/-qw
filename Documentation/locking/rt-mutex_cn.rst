==============================
支持优先级继承的 RT-互斥子系统
==============================

带有优先级继承功能的 RT-互斥锁用于支持 PI-futex，这使得 pthread_mutex_t 能够具有优先级继承属性（PTHREAD_PRIO_INHERIT）。[有关 PI-futex 的更多详细信息，请参阅 Documentation/locking/pi-futex.rst。]

这项技术是在 -rt 树中开发并优化以支持 pthread_mutex 的。
基本原理：
-----------

RT-互斥锁通过优先级继承协议扩展了简单互斥锁的功能。
一个低优先级的 RT-互斥锁持有者会在高优先级等待者等待该锁时继承其优先级，直到 RT-互斥锁被释放。如果临时提升优先级的持有者自身又阻塞在一个 RT-互斥锁上，它会将优先级提升传递给另一个 RT-互斥锁的持有者。一旦 RT-互斥锁解锁，优先级提升立即移除。

这种方法允许我们缩短高优先级任务在保护共享资源的互斥锁上的阻塞时间。优先级继承并不是解决设计不佳的应用程序问题的灵丹妙药，但它允许设计良好的应用程序在高优先级线程的关键部分使用用户空间锁而不丢失确定性。

等待者按照优先级顺序排队进入 RT-互斥锁等待者树。对于相同优先级的等待者，则按照 FIFO（先进先出）顺序排队。对于每个 RT-互斥锁，只有最高优先级的等待者会被加入到持有者的优先级等待者树中。这个树也按优先级顺序排队。每当任务的最高优先级等待者发生变化（例如超时或收到信号），持有任务的优先级就会重新调整。优先级排队由“pi_waiters”处理。

RT-互斥锁针对快速路径操作进行了优化，在锁定未争用的互斥锁或解锁没有等待者的互斥锁时没有内部锁定开销。优化后的快速路径操作需要 cmpxchg 支持。[如果没有 cmpxchg 支持，则使用 RT-互斥锁内部的自旋锁。]

RT-互斥锁的状态通过其结构中的 owner 字段进行跟踪：

lock->owner 持有持有者的 task_struct 指针。位 0 用于跟踪“锁有等待者”的状态：

| owner | bit0   | 备注                                                                 |
|-------|--------|----------------------------------------------------------------------|
| NULL  | 0      | 锁是空闲的（可以快速获取）                                           |
| NULL  | 1      | 锁是空闲的且有等待者，并且最高优先级的等待者即将获取锁 [1]_           |
| 任务指针 | 0      | 锁被持有（可以快速释放）                                              |
| 任务指针 | 1      | 锁被持有且有等待者 [2]_                                               |

只有当 lock->owner 的位 0 为 0 时，才能进行快速原子比较交换获取和释放操作。
.. [1] 当使用 ->wait_lock 抢占锁时，这也可能是一个过渡状态。为了防止任何快速路径的 cmpxchg 到锁，我们需要在查看锁之前设置位 0，此时 owner 可能是 NULL，因此这是一个过渡状态。
.. [2] 在位 0 被设置但没有等待者的一小段时间内，这可能会发生。当在慢路径中抢占锁时会出现这种情况。

为了防止释放锁时对 owner 进行 cmpxchg，我们需要在查看锁之前设置此位。
顺便说一句，技术上仍然存在一个“待定持有者”，只是不再这样称呼了。待定持有者是指一个没有持有者且已被唤醒以抢占锁的最高优先级等待者。
当然，请提供您需要翻译的文本。
