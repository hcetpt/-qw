====================
健壮的 futex ABI
====================

:作者: 起始于 Paul Jackson <pj@sgi.com>

健壮 futex 提供了一种机制，作为普通 futex 的补充，用于内核协助任务退出时所持有的锁的清理。有关线程持有哪些 futex 的重要数据保存在用户空间的一个链表中，在获取和释放锁时可以高效地更新这些数据，而无需内核干预。除了 futex 所需的内核干预外，健壮 futex 需要的唯一额外内核干预是：

1) 每个线程一次性调用，告诉内核其持有的健壮 futex 列表开始的位置，以及
2) 在退出时内核内部代码处理该线程所持有的任何已列出的锁。

现有的普通 futex 已经提供了一种“快速用户空间锁定”机制，它可以在不需要系统调用的情况下处理无争议的锁定，并通过在内核中维护一个等待线程列表来处理有争议的锁定。sys_futex(2) 系统调用选项支持等待特定的 futex，并唤醒特定 futex 上的下一个等待者。

为了使健壮 futex 正常工作，用户代码（通常链接到应用程序的库如 glibc）必须按照内核期望的方式管理和放置必要的列表元素。如果未能做到这一点，则在退出时未正确列出的锁将不会被清理，可能会导致其他等待相同锁的线程发生死锁或其他故障。

预期可能使用健壮 futex 的线程应首先发出系统调用：

```c
asmlinkage long
sys_set_robust_list(struct robust_list_head __user *head, size_t len);
```

指针 `head` 指向线程地址空间中的一个结构，该结构由三个词组成。每个词在 32 位架构上为 32 位，在 64 位架构上为 64 位，并且采用本地字节顺序。每个线程应有自己的私有 `head`。

如果线程在 64 位原生架构内核上以 32 位兼容模式运行，则它可以有两个这样的结构——一个使用 32 位词用于 32 位兼容模式，另一个使用 64 位词用于 64 位原生模式。如果内核支持 32 位兼容模式，则会在每次任务退出时尝试处理这两个列表，前提是相应的 `sys_set_robust_list()` 调用已设置该列表。

内存结构中的第一个词包含指向单链表的指针，该链表包含每个锁的一个“锁条目”，如下所述。如果列表为空，则指针会指向自身 `head`。最后一个“锁条目”会回指到 `head`。

第二个词称为 `offset`，指定从关联的“锁条目”的地址加或减的偏移量，从而得到所谓的“锁词”。与上述其他词不同，“锁词”始终是一个 32 位词。“锁词”在最高两位存储两个标志位，在最低 30 位存储持有该锁的线程 ID (TID)。关于标志位的描述见下文。

第三个词称为 `list_op_pending`，在列表插入和移除期间包含临时复制的“锁条目”地址，在线程在锁定或解锁操作中途退出时需要此值来正确解决竞争问题。

从 `head` 开始的单链表上的每个“锁条目”仅由一个词组成，指向下一个“锁条目”，或者如果没有更多条目则回指到 `head`。此外，在每个“锁条目”附近，根据 `offset` 字段指定的偏移量，有一个“锁词”。
'锁字'始终为32位，并且旨在与futex机制中使用的相同的32位锁变量结合使用，配合robust_futexes。内核只有在下一个等待锁的线程使用futex机制向内核注册了该'锁字'地址的情况下，才能在当前线程退出时唤醒它。对于每个当前由线程持有的futex锁，如果希望对此锁提供robust_futex支持以进行退出清理，则应在该列表上有一个'锁条目'，其关联的'锁字'位于指定的'偏移量'处。如果线程在持有任何此类锁时死亡，内核将遍历此列表，用一个标志位标记这些锁以表明其持有者已死亡，并使用futex机制唤醒等待该锁的下一个线程。

当线程调用上述系统调用来表示它预期使用robust_futexes时，内核会为该任务存储传递进来的'head'指针。任务可以通过以下系统调用稍后检索该值：

    asmlinkage long
    sys_get_robust_list(int pid, struct robust_list_head __user **head_ptr,
                        size_t __user *len_ptr);

预计线程将在较大的用户级锁定结构中嵌入robust_futexes，每个锁一个。内核的robust_futex机制不关心该结构中的其他内容，只要所有由该线程使用的robust_futexes的'锁字'的'偏移量'相同即可。线程应使用'锁条目'指针链接它当前持有的锁。它也可以有其他锁之间的链接，例如双向链表的反向侧，但这对内核来说无关紧要。

通过保持其锁以这种方式链接，在内核已知的'head'指针开始的列表中，内核可以为线程提供robust_futexes的基本服务，即帮助清理在意外退出时持有的锁。

正常的加锁和解锁操作完全由竞争线程中的用户级代码处理，并通过现有的futex机制来等待和唤醒锁。内核在robust_futexes中的唯一基本参与是记住列表'head'的位置，并在线程退出时遍历列表，处理即将离开的线程仍然持有的锁，如下所述。

在给定时间点，线程共享内存中可能存在数千个futex锁结构，分布在各种数据结构上。只有那些当前由该线程持有的锁结构应在该线程的robust_futex链接锁列表上。

用户共享内存区域中的特定futex锁结构可能在不同时间由具有访问权限的任何线程持有。当前持有此类锁（如果有）的线程会用该线程的TID在'锁字'的低30位中标记。

在添加或从其持有的锁列表中删除锁时，为了使内核能够正确处理锁清理，无论任务何时退出（也许在操作此列表的过程中意外收到信号9），用户代码必须遵守以下协议：

在插入时：
1) 将'list_op_pending'字设置为要插入的'锁条目'的地址，
2) 获取futex锁，
3) 将带有线程ID（TID）的锁条目添加到从'head'开始的链接列表中，并将线程ID（TID）放在'锁字'的低30位，
4) 清除'list_op_pending'字。

在删除时：
1) 将'list_op_pending'字设置为要删除的'锁条目'的地址，
2) 从'head'列表中删除此锁的锁条目，
3) 释放futex锁，
4) 清除'list_op_pending'字。

在退出时，内核将考虑存储在'list_op_pending'中的地址以及从'head'开始遍历时找到的每个'锁字'的地址。对于每个这样的地址，如果从该地址的'偏移量'处的'锁字'的低30位等于退出线程的TID，则内核将执行两件事：
1) 如果该字的第31位（0x80000000）被设置，则尝试在此地址上进行futex唤醒，这将唤醒下一个使用futex机制等待该地址的线程，
2) 原子地设置'锁字'中的第30位（0x40000000）。
在上述内容中，位31由等待该锁的futex等待者设置，以表示它们正在等待；而位30由内核设置，以表示持有该锁的进程已终止。

内核退出代码会在以下任何一种情况下默默地停止扫描列表：

1) 如果‘头’指针或后续的链表指针不是用户空间单词的有效地址；
2) 如果计算出的‘锁字’位置（地址加上‘偏移量’）不是一个有效的32位用户空间单词地址；
3) 如果列表包含超过1百万个元素（这一数值可能会在未来内核配置更改中调整）。

当内核看到一个其‘锁字’的低30位不包含当前线程TID的列表项时，它将不对该条目进行任何处理，并继续处理下一个条目。
