锁定课程
===============

课程1：自旋锁
====================

最基础的锁定原语是自旋锁：

```c
static DEFINE_SPINLOCK(xxx_lock);

unsigned long flags;

spin_lock_irqsave(&xxx_lock, flags);
... 关键代码段在此 ...
spin_unlock_irqrestore(&xxx_lock, flags);
```

上述代码总是安全的。它会禁用本地中断，但自旋锁本身会保证全局锁定，因此可以确保只有一个控制线程在该锁保护的区域内执行。即使在单处理器系统（UP）下也是如此，因此代码不需要担心单处理器（UP）与多处理器（SMP）之间的问题：自旋锁在这两种情况下都能正确工作。
注意！自旋锁对内存的影响在以下文档中有更详细的描述：

     `Documentation/memory-barriers.txt`

       （5）获取（ACQUIRE）操作
       （6）释放（RELEASE）操作
通常情况下，这很简单（你通常只需要一个自旋锁来处理大多数情况——使用多个自旋锁会使事情变得更加复杂甚至更慢，并且通常只适用于那些你**知道**需要拆分的操作序列：如果你不确定，请尽量避免这样做）
这是关于自旋锁真正困难的部分：一旦开始使用自旋锁，它们往往会扩展到你之前可能没有注意到的区域，因为你必须确保自旋锁能够正确地保护所有使用共享数据结构的地方。自旋锁最容易添加到那些完全独立于其他代码的地方（例如，内部驱动程序数据结构，这些数据结构其他人从未接触过）
注意！只有当你**也**使用锁本身进行跨CPU锁定时，自旋锁才是安全的，这意味着所有访问共享变量的代码都必须同意使用同一个自旋锁
---

课程2：读写自旋锁
==================

如果你的数据访问模式非常自然地倾向于主要从共享变量中读取数据，那么读写锁（rw_lock）版本的自旋锁有时是有用的。它们允许多个读者同时处于同一个关键区域，但如果有人想要修改变量，则必须获得独占写锁
注意！读写锁比简单的自旋锁需要更多的原子内存操作。除非读取的关键代码段很长，否则你最好还是使用自旋锁
这些例程看起来与上面的一样：

```c
rwlock_t xxx_lock = __RW_LOCK_UNLOCKED(xxx_lock);

unsigned long flags;

read_lock_irqsave(&xxx_lock, flags);
// .. 只读取信息的关键部分 ..
read_unlock_irqrestore(&xxx_lock, flags);

write_lock_irqsave(&xxx_lock, flags);
// .. 对信息进行读写独占访问 ..
write_unlock_irqrestore(&xxx_lock, flags);
```

上述类型的锁对于复杂的数据结构（如链表）可能很有用，特别是在不改变列表本身的情况下搜索条目。读锁允许许多并发读者。任何**更改**列表的操作都必须获得写锁。
注意！RCU更适合遍历链表，但需要仔细设计细节（参见Documentation/RCU/listRCU.rst）
另外，你不能将读锁“升级”为写锁，因此如果你在任何时候需要进行任何更改（即使不是每次都更改），你也必须从一开始就获取写锁。
注意！我们正在努力在大多数情况下移除读写自旋锁，因此请不要未经共识就添加新的自旋锁。（相反，请参阅Documentation/RCU/rcu.rst以获取完整信息。）

---

课程3：再谈自旋锁
==============================

上面的单个自旋锁原语绝不是唯一的。它们是最安全的，并且在所有情况下都能工作，但部分**因为**它们是安全的，所以也相对较慢。它们比实际需要的速度慢，因为它们确实需要禁用中断（这在x86上只是一个指令，但它是一个昂贵的指令——而在其他架构上可能会更糟）
如果你有一个需要跨多个CPU保护数据结构的情况，并且想使用自旋锁，你可以潜在地使用更便宜版本的自旋锁。如果确定自旋锁永远不会在中断处理程序中使用，则可以使用非中断版本：

```c
spin_lock(&lock);
..
spin_unlock(&lock);
```

（当然，也可以使用相应的读写版本）。自旋锁将保证同样的独占访问，并且速度会快得多。

这是有用的，如果你知道相关数据只在“进程上下文”中被操作，即不涉及中断。
你必须在有中断处理程序使用自旋锁的情况下避免使用这些版本的原因是，这样可能会导致死锁：

```c
spin_lock(&lock);
...
<--- 中断到来：
         spin_lock(&lock);
```

这里的情况是一个中断试图锁定一个已经被锁定的变量。如果另一个中断发生在另一个CPU上，这是可以接受的；但如果中断发生在持有锁的同一个CPU上，则是不可接受的，因为这个锁显然永远不会被释放（因为中断在等待锁，而持有锁的进程被中断阻塞，不会继续执行直到中断处理完成）。
这也是为什么自旋锁的中断版本只需要禁用本地中断——在其他CPU上的中断中使用自旋锁是可以的，因为另一个CPU上的中断不会打断持有锁的CPU，所以持有锁的进程可以继续并最终释放锁。
——林纳斯

---

参考信息：
======================

对于动态初始化，应使用 `spin_lock_init()` 或 `rwlock_init()` 适当初始化：

```c
spinlock_t xxx_lock;
rwlock_t xxx_rw_lock;

static int __init xxx_init(void)
{
    spin_lock_init(&xxx_lock);
    rwlock_init(&xxx_rw_lock);
    ...
}

module_init(xxx_init);
```

对于静态初始化，应使用 `DEFINE_SPINLOCK()` / `DEFINE_RWLOCK()` 或 `__SPIN_LOCK_UNLOCKED()` / `__RW_LOCK_UNLOCKED()` 进行适当初始化。
