===========================================================================
在可抢占内核下的正确锁定：保持内核代码的抢占安全
===========================================================================

:作者: Robert Love <rml@tech9.net>

简介
============

一个可抢占的内核会产生新的锁定问题。这些问题与SMP（对称多处理）环境中的问题相同：并发性和重入性。值得庆幸的是，Linux的可抢占内核模型利用了现有的SMP锁定机制。因此，内核仅在极少数情况下需要显式的额外锁定。本文档适用于所有内核开发者。在内核中开发代码时，需要保护这些情况。

规则#1：每个CPU的数据结构需要显式保护
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

会出现两个类似的问题。例如代码片段如下：

```c
struct this_needs_locking tux[NR_CPUS];
tux[smp_processor_id()] = some_value;
/* 任务在这里被抢占... */
something = tux[smp_processor_id()];
```

首先，由于数据是每个CPU的，它可能没有显式的SMP锁定，但其他情况下需要。其次，当一个被抢占的任务最终重新调度时，smp_processor_id的先前值可能不等于当前值。你必须通过禁用抢占来保护这些情况。
你也可以使用put_cpu()和get_cpu()，它们会禁用抢占。

规则#2：CPU状态必须受到保护
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在抢占模式下，CPU的状态必须受到保护。这取决于架构，但包括在上下文切换过程中未保存的CPU结构和状态。例如，在x86上，进入和退出FPU模式现在是一个关键区域，必须在禁用抢占的情况下进行。想想如果内核正在执行浮点指令然后被抢占会发生什么。
记住，内核只在用户任务中保存FPU状态。因此，在抢占时，FPU寄存器将被出售给最低出价者。因此，这样的区域周围必须禁用抢占。
注意，一些FPU函数已经是显式抢占安全的。例如，kernel_fpu_begin和kernel_fpu_end会禁用和启用抢占。

规则#3：锁的获取和释放必须由同一个任务完成
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在一个任务中获取的锁必须由同一个任务释放。这意味着你不能做一些奇怪的事情，比如获取一个锁然后去做其他事情，而另一个任务释放这个锁。如果你想做类似的事情，请在同一代码路径中获取和释放锁，并让调用者等待另一个任务的事件。

解决方案
========

在抢占模式下保护数据的方法是在关键区域期间禁用抢占。
预抢占启用（`preempt_enable()`） 减少抢占计数器的值
预抢占禁用（`preempt_disable()`） 增加抢占计数器的值
预抢占启用但不立即抢占（`preempt_enable_no_resched()`） 减少计数器，但不立即触发抢占
预抢占检查重新调度（`preempt_check_resched()`） 如有必要，进行重新调度
获取抢占计数器值（`preempt_count()`） 返回抢占计数器的值

这些函数是可嵌套调用的。换句话说，在一个代码路径中可以多次调用 `preempt_disable`，直到第 n 次调用 `preempt_enable` 才会重新启用抢占。如果未启用抢占，预抢占语句定义为空。
请注意，如果您持有任何锁或中断已禁用，则不需要显式防止抢占，因为在这些情况下抢占是隐式禁用的。
但请记住，'中断禁用' 是一种本质上不安全的禁用抢占的方式 —— 如果抢占计数器为 0，任何 `cond_resched()` 或 `cond_resched_lock()` 都可能触发重新调度。一个简单的 `printk()` 可能也会触发重新调度。因此，只有在您确定受影响的代码路径不做这些操作时才使用这种隐式的抢占禁用属性。最好的策略是仅用于小且原子性的代码，该代码由您编写且不调用复杂函数。

示例：

```c
cpucache_t *cc; /* 这是每个 CPU 的 */
preempt_disable();
cc = cc_data(searchp);
if (cc && cc->avail) {
    __free_block(searchp, cc_entry(cc), cc->avail);
    cc->avail = 0;
}
preempt_enable();
return 0;
```

请注意如何抢占语句必须包含对关键变量的所有引用。另一个例子：

```c
int buf[NR_CPUS];
set_cpu_val(buf);
if (buf[smp_processor_id()] == -1) printf(KERN_INFO "wee!\n");
spin_lock(&buf_lock);
/* ... */
```

这段代码不是抢占安全的，但看看我们只需将 `spin_lock` 上移两行就可以很容易地修复它。

通过禁用中断来防止抢占
==================

可以使用 `local_irq_disable` 和 `local_irq_save` 来防止抢占事件。请注意，在这样做时，必须非常小心不要触发会导致需要重新调度的事件。如有疑问，请依赖于锁定或显式禁用抢占。
请注意，在 2.5 版本中，中断禁用现在仅针对每个 CPU（例如本地）。
另一个需要注意的是 `local_irq_disable` 和 `local_irq_save` 的正确使用。
这些可以用来防止抢占，但是在退出时，如果可能启用抢占，则应进行是否需要抢占的测试。如果它们从自旋锁和读写锁宏调用，那么正确的处理方式已经完成。它们也可以在自旋锁保护区域内调用，但是，如果它们在该上下文之外调用，则应进行抢占测试。请注意，从中断上下文或下半部/任务中调用也受抢占锁保护，因此可以使用不检查抢占的版本。
