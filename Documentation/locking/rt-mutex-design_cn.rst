==============================
RT-mutex 实现设计
==============================

版权所有 (c) 2006 Steven Rostedt

根据 GNU 自由文档许可协议第 1.2 版授权

本文档试图描述 `rtmutex.c` 的实现设计。
本文档并不解释为什么需要 `rtmutex.c`。关于这一点，请参阅 `Documentation/locking/rt-mutex.rst`。尽管本文档确实解释了没有这段代码时会发生的问题，但这是为了理解代码实际在做什么。
本文档的目标是帮助其他人理解所使用的优先级继承（PI）算法，以及为实现 PI 而做出的决策的原因。
无界优先级反转
--------------------

优先级反转是指低优先级进程在高优先级进程想要运行时执行的情况。这种情况发生有多种原因，大多数时候无法避免。每当一个高优先级进程想要使用一个低优先级进程拥有的资源（例如互斥锁）时，高优先级进程必须等待低优先级进程完成对该资源的使用。这就是优先级反转。我们希望防止的是所谓的无界优先级反转。即高优先级进程被低优先级进程无限期地阻止运行的情况。
无界优先级反转的经典例子是有三个进程，分别称为进程 A、B 和 C，其中 A 是最高优先级的进程，C 是最低优先级的进程，B 居中。A 尝试获取 C 拥有的锁，并且必须等待 C 释放该锁。但在等待期间，B 执行了，由于 B 的优先级高于 C，因此 B 抢占了 C，但实际上却抢占了优先级更高的 A。
现在没有办法知道 A 等待 C 释放锁的时间有多长，因为从我们的角度来看，B 可能是一个占用 CPU 的进程，永远不给 C 释放锁的机会。这被称为无界优先级反转。
下面是一幅 ASCII 图来展示这个问题：

```
    获取锁 L1（由 C 拥有）
      |
  A ---+
          C 被 B 抢占
            |
  C    +----+

  B         +-------->
                  B 现在阻止 A 运行
优先级继承（PI）
-------------------------

解决这个问题有几种方法，但其他方法不在本文档的讨论范围内。这里只讨论 PI。
PI 是指当另一个进程因当前进程拥有的锁而阻塞时，当前进程继承另一个进程的优先级。为了更容易理解这一点，让我们再次使用之前的例子，涉及进程 A、B 和 C。
这次，当 A 阻塞在 C 拥有的锁上时，C 将继承 A 的优先级。因此，如果 B 可以运行，它将不会抢占 C，因为 C 现在具有 A 的高优先级。一旦 C 释放了锁，它就失去了继承的优先级，A 则可以继续使用 C 曾经拥有的资源。
术语
-----------

在此，我解释了一些用于本文档中的术语，以帮助描述实现PI设计时所用的术语。

- **PI链**：PI链是一系列有序的锁和进程，导致进程从被其中一个锁阻塞的前一个进程中继承优先级。这一点将在本文档后面的章节中详细描述。
- **互斥锁（mutex）**：为了区分实现PI的锁和PI代码中使用的自旋锁，从现在起，PI锁将被称为互斥锁（mutex）。
- **锁（lock）**：从现在起，在本文档中，当提到用于保护PI算法部分的自旋锁时，我将使用“锁”这一术语。这些锁在单处理器系统（UP）上禁用了抢占（当启用CONFIG_PREEMPT配置时），在多处理器系统（SMP）上防止多个CPU同时进入临界区。
- **自旋锁（spin lock）**：与上述锁相同。
- **等待者（waiter）**：这是一个存储在被阻塞进程栈上的结构体。由于等待者的范围仅限于进程阻塞在互斥锁上的代码内，因此将其分配在进程的栈上（局部变量）是合理的。这个结构包含指向任务的指针以及任务被阻塞的互斥锁。它还包含红黑树节点结构，用于将任务放入互斥锁的等待者红黑树中，以及互斥锁所有者任务的pi_waiters红黑树（如下所述）。
  等待者有时也用来指代正在等待互斥锁的任务。这等同于waiter->task。
- **等待者列表（waiters）**：一个被阻塞在互斥锁上的进程列表。
- **最高优先级等待者（top waiter）**：等待特定互斥锁的最高优先级进程。
- **最高优先级PI等待者（top pi waiter）**：等待某个特定进程所拥有的互斥锁之一的最高优先级进程。
注释：
任务和进程在本文档中互换使用，主要用于区分同时描述的两个进程。

PI 链
------

PI 链是一个包含可能引发优先级继承的进程和互斥锁的列表。多个链可以汇聚，但一个链不会分散，因为一个进程不能同时被阻塞在一个以上的互斥锁上。
示例：

```
进程：A、B、C、D、E
互斥锁：L1、L2、L3、L4

A 拥有：L1
        B 被 L1 阻塞
        B 拥有 L2
               C 被 L2 阻塞
               C 拥有 L3
                      D 被 L3 阻塞
                      D 拥有 L4
                             E 被 L4 阻塞
```

该链为：

```
E->L4->D->L3->C->L2->B->L1->A
```

为了显示两个链的汇聚点，我们可以添加另一个进程 F 和另一个互斥锁 L5，其中 B 拥有 L5，F 被 L5 阻塞。
F 的链为：

```
F->L5->B->L1->A
```

由于一个进程可以拥有多个互斥锁，但不会同时被多个互斥锁阻塞，因此这些链汇聚。
这里展示两个链：

```
E->L4->D->L3->C->L2-+
                    |
                    +->B->L1->A
                    |
             F->L5-+
```

为了让 PI 工作，这些链（或称链的顶部）右端的进程必须等于或高于链左端或下方的进程的优先级。
此外，由于一个互斥锁可以有多个进程被阻塞，我们可以在互斥锁处汇聚多个链。如果我们再添加一个被 L2 阻塞的进程 G：

```
G->L2->B->L1->A
```

再次展示这些汇聚的链：

```
E->L4->D->L3->C-+
                +->L2-+
                |      |
              G-+      +->B->L1->A
                        |
                F->L5-+
```

如果进程 G 是链中优先级最高的进程，则链中的所有任务（在这个例子中是 A 和 B）的优先级都必须提高到 G 的优先级。

互斥锁等待者树
----------------

每个互斥锁都会跟踪所有被自己阻塞的等待者。互斥锁使用红黑树来按优先级存储这些等待者。这棵树受位于互斥锁结构中的自旋锁保护。这个锁称为 `wait_lock`。

任务 PI 树
------------

为了跟踪 PI 链，每个进程都有自己的 PI 红黑树。这是一个包含由该进程拥有的互斥锁的所有顶级等待者的树。
注意，这棵树只包含顶级等待者，并不包含所有被该进程拥有的互斥锁阻塞的等待者。

任务的 PI 树的顶部始终是等待该任务拥有的互斥锁的最高优先级任务。因此，如果该任务继承了优先级，那么这个优先级将始终是该树顶部任务的优先级。
这棵树存储在一个进程的任务结构中，称为`pi_waiters`的红黑树（Red-Black Tree）。它受到任务结构中的自旋锁保护，这个锁称为`pi_lock`。此锁也可以在中断上下文中获取，因此在锁定`pi_lock`时必须禁用中断。

### PI 链的深度

PI 链的最大深度不是动态的，实际上是可以定义的。但要确定它非常复杂，因为它取决于所有互斥锁的嵌套关系。让我们来看一个例子，假设我们有三个互斥锁，L1、L2 和 L3，以及四个独立的函数：func1、func2、func3 和 func4。以下展示了 L1->L2->L3 的锁定顺序，但这些函数不一定直接嵌套在一起：

```c
void func1(void)
{
    mutex_lock(L1);

    /* 做一些事情 */

    mutex_unlock(L1);
}

void func2(void)
{
    mutex_lock(L1);
    mutex_lock(L2);

    /* 做一些事情 */

    mutex_unlock(L2);
    mutex_unlock(L1);
}

void func3(void)
{
    mutex_lock(L2);
    mutex_lock(L3);

    /* 做一些其他事情 */

    mutex_unlock(L3);
    mutex_unlock(L2);
}

void func4(void)
{
    mutex_lock(L3);

    /* 再做一些事情 */

    mutex_unlock(L3);
}
```

现在我们添加四个分别运行这些函数的进程：A、B、C 和 D，它们分别运行 func1、func2、func3 和 func4，并且 D 最先运行，A 最后运行。假设 D 在 func4 中的 "再做一些事情" 区域被抢占，那么我们得到如下锁定顺序：

```
D 拥有 L3
       C 被 L3 阻塞
       C 拥有 L2
              B 被 L2 阻塞
              B 拥有 L1
                     A 被 L1 阻塞
```

因此我们得到了链 A->L1->B->L2->C->L3->D。
这样我们就得到了一个 PI 深度为 4（四个进程），但单独看任何一个函数，似乎它们最多只有两个锁定深度。因此，尽管锁定深度在编译时可以定义，但仍然很难找出其可能的深度。

由于互斥锁可以由用户空间应用程序定义，我们不希望一个类似 DOS 的应用程序通过大量嵌套互斥锁来创建一个大的 PI 链，并在查看大量数据时持有自旋锁。为了防止这种情况，实现不仅限定了最大锁定深度，还限制了在遍历 PI 链时同时持有的不同锁的数量最多为两个。关于这一点，下面会有更多细节。

### 互斥锁的所有者和标志位

互斥锁结构包含指向互斥锁所有者的指针。如果互斥锁没有被任何进程拥有，则该所有者设置为 NULL。由于所有架构都至少将任务结构对齐到两个字节（如果不是这样，rtmutex.c 代码将会出错！），因此可以使用最低有效位作为标志位。第 0 位用作“有等待者”标志。每当有等待者时，该标志就会被设置。

请参阅 `Documentation/locking/rt-mutex.rst` 获取更多详细信息。

### cmpxchg 技巧

一些架构实现了原子的 `cmpxchg`（比较并交换）操作。当适用时，这种操作用于保持获取和释放互斥锁的快速路径较短。

`cmpxchg` 基本上是以下函数的原子执行：

```c
unsigned long _cmpxchg(unsigned long *A, unsigned long *B, unsigned long *C)
{
    unsigned long T = *A;
    if (*A == *B) {
        *A = *C;
    }
    return T;
}
#define cmpxchg(a,b,c) _cmpxchg(&a,&b,&c)
```

这是因为它可以让你仅在变量是你预期的值时才更新它。你可以通过检查返回值（即 A 的旧值）是否等于 B 来判断是否成功。
宏 `rt_mutex_cmpxchg` 用于尝试锁定和解锁互斥锁。如果架构不支持 CMPXCHG，则该宏将始终设置为失败。但如果支持 CMPXCHG，则这将极大地帮助保持快速路径的简短。
使用带有所有者字段中的标志的 `rt_mutex_cmpxchg` 可以优化支持它的架构上的系统。这将在本文档后面的章节中进一步解释。

优先级调整
------------

在 `rtmutex.c` 中实现的 PI 代码有多个地方需要进程调整其优先级。通过使用进程的 `pi_waiters`，可以很容易地知道需要调整的内容。
实现任务调整功能的函数是 `rt_mutex_adjust_prio` 和 `rt_mutex_setprio`。`rt_mutex_setprio` 仅在 `rt_mutex_adjust_prio` 中使用。
`rt_mutex_adjust_prio` 检查任务的优先级以及等待任务所拥有的任意互斥锁的最高优先级进程。由于一个任务的 `pi_waiters` 包含了该任务所拥有所有互斥锁的顶级等待者的优先级排序列表，我们只需比较最高的 `pi_waiter` 与它自身的正常/截止优先级，并取较高的值。
然后调用 `rt_mutex_setprio` 来将任务的优先级调整到新的优先级。请注意，`rt_mutex_setprio` 在 `kernel/sched/core.c` 中定义，用于实现实际的优先级更改。

注意：
	对于 `task_struct` 中的 “prio” 字段，数字越小，优先级越高。“prio” 为 5 的优先级高于“prio” 为 10 的。

值得注意的是，`rt_mutex_adjust_prio` 可以增加或降低任务的优先级。例如，如果一个更高优先级的进程刚刚阻塞在一个由任务拥有的互斥锁上，`rt_mutex_adjust_prio` 将会提高/提升任务的优先级。但如果有更高优先级的任务因某种原因离开了互斥锁（超时或信号），这个相同的函数将会降低/取消提升任务的优先级。这是因为 `pi_waiters` 始终包含正在等待任务所拥有互斥锁的最高优先级任务，所以我们只需要比较那个最高 `pi_waiter` 的优先级与给定任务的正常优先级即可。

PI 链遍历的高级概述
--------------------------

PI 链遍历由函数 `rt_mutex_adjust_prio_chain` 实现。
其实现经历了几次迭代，并最终达到了我们认为的最佳状态。它通过每次最多获取两个锁来遍历 PI 链，并且非常高效。
`rt_mutex_adjust_prio_chain` 可以用来提升或降低进程的优先级。

`rt_mutex_adjust_prio_chain` 被调用时，会检查一个任务是否需要进行 PI（优先级继承）提升或降低（被某个进程阻塞的互斥锁所有者），还包括一个用于检测死锁的标志、该任务拥有的互斥锁、指向该进程阻塞在互斥锁上的等待者结构的指针（尽管在降低优先级时此参数可以为 NULL）、指向任务被阻塞的互斥锁的指针以及作为互斥锁顶级等待者的 `top_task`。

为了便于理解，这里不提死锁检测。解释将尽量保持在较高层次。

当调用此函数时，没有任何锁被持有。这也意味着，在进入此函数时，所有者和锁的状态可能会发生变化。

在调用此函数之前，已经对任务执行了 `rt_mutex_adjust_prio`。这意味着任务已经被设置为其应有的优先级，但任务等待者结构中的红黑树节点尚未更新新的优先级，并且此任务可能不在其被阻塞的 `pi_waiters` 和 `waiters` 树中正确的位置。此函数解决了这些问题。

此函数的主要操作由 Thomas Gleixner 在 `rtmutex.c` 中进行了总结。请参阅“链表遍历基础与保护范围”的注释以获取更多详细信息。

获取互斥锁（遍历过程）
----------------------

现在让我们看看获取互斥锁时发生的详细过程。

首先尝试快速获取互斥锁。这是在我们启用了 CMPXCHG 的情况下完成的（否则快速获取自动失败）。只有当互斥锁的所有者字段为 NULL 时，才能通过 CMPXCHG 获取锁，此时无需做其他事情。

如果锁存在竞争，则进入慢路径 (`rt_mutex_slowlock`)。

慢路径函数中会在栈上创建任务的等待者结构。这是因为等待者结构仅在此函数的作用域内需要。等待者结构包含用于存储任务的红黑树节点，以及在必要时存储在所有者 `pi_waiters` 树中的节点。
互斥锁的`wait_lock`在解锁的慢路径中已经被获取。
然后我们调用`try_to_take_rt_mutex`。对于不实现CMPXCHG指令集架构，如果不存在竞争，则会始终获取该锁。
`try_to_take_rt_mutex`用于任务每次尝试在慢路径中获取互斥锁时。首先在这里进行的是对互斥锁所有者字段中的“Has Waiters”标志的原子设置。通过现在设置这个标志，当前争夺中的互斥锁的所有者无法释放互斥锁而不进入慢解锁路径，并且需要获取当前代码持有的`wait_lock`。因此，设置“Has Waiters”标志迫使当前所有者与这段代码同步。
如果以下条件为真，则获取锁：

1. 锁没有所有者
2. 当前任务优先级高于其他所有等待此锁的任务

如果任务成功获取了锁，则将该任务设置为锁的所有者，并且如果锁仍然有等待者，则最高优先级的等待者（top_waiter）会被添加到此任务的`pi_waiters`树中。
如果`try_to_take_rt_mutex()`未能获取锁，则调用`task_blocks_on_rt_mutex()`函数。这会将任务添加到锁的等待树中，并传播锁以及锁所有者的`pi_waiters`树。这将在下一节中描述。
任务阻塞在互斥锁上
--------------------

互斥锁和进程的会计操作是通过进程的`waiter`结构完成的。“task”字段被设置为进程，“lock”字段被设置为互斥锁。`waiter`的红黑树节点被初始化为进程的当前优先级。
由于在慢锁入口处已经获取了`wait_lock`，我们可以安全地将等待者添加到任务等待树中。如果当前进程是当前等待此互斥锁的最高优先级进程，则从所有者的`pi_waiters`中移除之前的顶级等待者（如果存在），并将当前进程添加到该树中。由于所有者的`pi_waiter`已更改，我们将调用`rt_mutex_adjust_prio`来查看所有者是否应相应调整其优先级。
如果所有者也被阻塞在一个锁上，并且其`pi_waiters`已更改（或启用了死锁检查），我们将解锁互斥锁的`wait_lock`并运行`rt_mutex_adjust_prio_chain`，如前所述。
现在所有锁都被释放了，如果当前进程仍被一个互斥锁阻塞（`waiter`的“task”字段不为空），则我们进入睡眠状态（调用`schedul`e）。
循环中的唤醒
-----------------------

任务可能会因为以下原因之一而醒来：
1. 前一个锁所有者释放了锁，并且当前任务成为了顶级等待者
2. 我们收到了信号或超时

在这两种情况下，任务都会再次尝试获取锁。如果成功，则将其从等待者树中移除，并将其恢复到`TASK_RUNNING`状态。
### 第一种情况
如果锁在当前任务获取之前已被其他任务获取，那么它将返回睡眠状态并等待再次被唤醒。

### 第二种情况
第二种情况仅适用于那些在获取互斥锁前可能会由于信号或超时而被唤醒的任务（即使用 `rt_mutex_timed_futex_lock()`）。当被唤醒时，它会再次尝试获取锁。如果成功，则任务将持有锁返回；否则，如果任务因信号被唤醒，则返回 `-EINTR`；如果超时，则返回 `-ETIMEDOUT`。

### 解锁互斥锁
-------------------

解锁互斥锁也有一个快速路径，对于支持 `CMPXCHG` 指令的架构尤其适用。由于在有竞争的情况下获取互斥锁总是会设置互斥锁所有者的“有等待者”标志，我们利用这一点来判断是否需要采用慢速路径解锁。如果没有等待者，互斥锁的所有者字段应等于当前进程，并且可以通过将所有者字段设置为 `NULL` 来解锁。

如果所有者字段设置了“有等待者”标志（或者不支持 `CMPXCHG`），则采取慢速解锁路径。

慢速解锁路径的第一步是获取互斥锁的 `wait_lock`。这同步了互斥锁的加锁和解锁操作。

接下来检查互斥锁是否有等待者。对于不支持 `CMPXCHG` 的架构，这是互斥锁所有者确定是否需要唤醒等待者的位置。对于支持 `CMPXCHG` 的架构，这一检查在快速路径中进行，但在慢速路径中也需要。如果在所有者快速路径 `CMPXCHG` 检查失败和获取 `wait_lock` 之间，一个等待者因为信号或超时而被唤醒，那么互斥锁可能没有等待者，因此所有者仍需进行此检查。如果没有等待者，则将互斥锁所有者字段设置为 `NULL`，释放 `wait_lock`，无需进一步操作。

如果有等待者，则需要唤醒其中一个。

在唤醒代码中，首先获取当前所有者的 `pi_lock`。找到并移除锁的顶级等待者，从互斥锁的等待者树和当前所有者的 `pi_waiters` 树中删除该等待者。标记 “有等待者” 标志以防止低优先级任务抢占锁。

最后，解锁待处理所有者的 `pi_lock` 并唤醒它。

### 联系方式
-------------------

如有更新，请发邮件至 Steven Rostedt <rostedt@goodmis.org>。

### 致谢
-------------------

**作者：**
Steven Rostedt <rostedt@goodmis.org>

**更新者：**
Alex Shi <alex.shi@linaro.org> —— 2017年7月6日

**原始审阅者：**
Ingo Molnar, Thomas Gleixner, Thomas Duetsch, Randy Dunlap

**更新审阅者（2017年7月6日）：**
Steven Rostedt 和 Sebastian Siewior

### 更新记录
-------------------

本文档最初为 2.6.17-rc3-mm1 版本编写，并于 4.12 版本进行了更新。
