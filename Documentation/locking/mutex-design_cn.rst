=======================
通用互斥子系统
=======================

发起人：Ingo Molnar <mingo@redhat.com>

更新人：Davidlohr Bueso <davidlohr@hp.com>

什么是互斥锁？
-----------------

在Linux内核中，互斥锁指的是特定的锁定原语，它在共享内存系统中强制执行序列化，并不仅仅指学术界或类似理论书籍中所提到的“互斥”这一通用术语。互斥锁是一种睡眠锁，其行为类似于二进制信号量，并于2006年[1]作为二进制信号量的一种替代方案引入。这种新的数据结构提供了许多优势，包括更简单的接口，以及当时更小的代码（见缺点）。
[1] https://lwn.net/Articles/164802/

实现
--------------

互斥锁由`struct mutex`表示，定义在`include/linux/mutex.h`中，并在`kernel/locking/mutex.c`中实现。这些锁使用一个原子变量（`->owner`）来跟踪锁在其生命周期中的状态。字段`owner`实际上包含指向当前锁持有者的`struct task_struct *`，因此如果没有当前持有者，则为NULL。由于`task_struct`指针至少对齐到L1_CACHE_BYTES，低几位（3位）用于存储额外的状态（例如，如果等待队列非空）。在最基本的形式下，它还包括一个等待队列和一个对其进行序列化的自旋锁。此外，在`CONFIG_MUTEX_SPIN_ON_OWNER=y`系统中使用一个MCS自旋锁（`->osq`），如下(ii)所述。

当获取互斥锁时，根据锁的状态，有三种可能的路径：

(i) 快速路径：尝试通过`cmpxchg()`将所有者与当前任务进行原子性获取。这仅在无竞争的情况下有效（`cmpxchg()`检查是否为0UL，因此上述3个状态位都必须为0）。如果锁有竞争，则进入下一个可能的路径。
(ii) 中间路径：即乐观自旋，尝试在锁持有者正在运行且没有其他更高优先级的任务准备运行（`need_resched`）时自旋以获取锁。原理是如果锁持有者正在运行，则很可能很快就会释放锁。MCS锁用于排队这些自旋器，以便只有一个自旋器可以竞争互斥锁。
MCS锁（由Mellor-Crummey和Scott提出）是一个简单的自旋锁，具有公平性和每个CPU尝试获取锁时自旋本地变量的特性。它避免了常见的测试并设置自旋锁实现中产生的昂贵的缓存线跳跃。MCS样式的锁特别适合于睡眠锁实现中的乐观自旋。定制的MCS锁的一个重要特性是自旋器能够在需要重新调度时退出MCS自旋锁队列。这进一步有助于避免MCS自旋器在需要重新调度时继续等待互斥锁所有者，而一旦获得MCS锁就直接进入慢速路径。
(iii) 慢速路径：最后的选择，如果仍然无法获取锁，任务将被添加到等待队列并休眠直到被解锁路径唤醒。正常情况下，它会以`TASK_UNINTERRUPTIBLE`方式阻塞。

虽然从形式上内核互斥锁是可睡眠的锁，但路径(ii)使其在实践中更像是一种混合类型。通过简单地不中断任务并在几个周期内忙等而不是立即休眠，该锁的性能已被证明能够显著提高多种工作负载。需要注意的是，这种技术也用于读写信号量。

语义
---------

互斥子系统检查并强制以下规则：

- 一次只能有一个任务持有互斥锁
- 只有持有者才能解锁互斥锁
- 不允许多次解锁
以下是翻译：

- 不允许进行递归加锁/解锁
- 互斥锁必须仅通过API进行初始化（详见下文）
- 持有互斥锁的任务不得退出
- 存储已持有锁的内存区域不得被释放
- 已持有的互斥锁不得被重新初始化
- 互斥锁不得在硬件或软件中断上下文中使用，例如任务和定时器

当启用`CONFIG_DEBUG_MUTEXES`时，这些语义将得到完全强制。

此外，互斥锁调试代码还实现了许多其他功能，使锁定调试更加容易和快速：

    - 在调试输出中打印互斥锁的符号名称
- 获取点跟踪，函数名称的符号查找，系统中所有已持有锁的列表，打印它们
- 持有者跟踪
检测自递归锁并打印所有相关信息  
检测多任务循环死锁并打印所有受影响的锁和任务（仅这些任务）

互斥锁（mutexes）——以及大多数其他睡眠锁（如rwsems）——不提供其占用内存的隐式引用，该引用在`mutex_unlock()`时释放。
[ 这与`spin_unlock()` [或`completion_done()`]不同，这些API可以保证在`spin_unlock()`/`completion_done()`释放锁之后，锁的实现不再触碰该内存。]

`mutex_unlock()`可能在内部已经释放锁后仍访问互斥锁结构——因此另一个上下文获取互斥锁并假设`mutex_unlock()`上下文不再使用该结构是不安全的。
互斥锁用户必须确保在释放操作尚未完成时互斥锁不被销毁——换句话说，`mutex_unlock()`的调用者必须确保互斥锁在`mutex_unlock()`返回之前保持有效。
接口
------
静态定义互斥锁：

   `DEFINE_MUTEX(name);`

动态初始化互斥锁：

   `mutex_init(mutex);`

获取互斥锁，不可中断：

   `void mutex_lock(struct mutex *lock);`
   `void mutex_lock_nested(struct mutex *lock, unsigned int subclass);`
   `int mutex_trylock(struct mutex *lock);`

获取互斥锁，可中断：

   `int mutex_lock_interruptible_nested(struct mutex *lock, unsigned int subclass);`
   `int mutex_lock_interruptible(struct mutex *lock);`

当计数器减至0时，可中断地获取互斥锁：

   `int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock);`

解锁互斥锁：

   `void mutex_unlock(struct mutex *lock);`

测试互斥锁是否已被获取：

   `int mutex_is_locked(struct mutex *lock);`

缺点
------

与最初的设想和用途不同，`struct mutex`是内核中最大的锁之一。例如：在x86-64上它的大小为32字节，而`struct semaphore`为24字节，`rw_semaphore`为40字节。较大的结构意味着更多的CPU缓存和内存占用。

何时使用互斥锁
-------------------

除非互斥锁的严格语义不适合和/或关键区域阻止锁被共享，否则应始终优先选择互斥锁而不是任何其他锁定原语。
