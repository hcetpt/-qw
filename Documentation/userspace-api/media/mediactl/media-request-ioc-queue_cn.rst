SPDX 许可证标识符：GPL-2.0 或 GFDL-1.1-no-invariants-or-later
C 命名空间：MC

.. _media_request_ioc_queue:

*******************************
ioctl MEDIA_REQUEST_IOC_QUEUE
*******************************

名称
====

MEDIA_REQUEST_IOC_QUEUE - 队列化请求

概要
========

.. c:macro:: MEDIA_REQUEST_IOC_QUEUE

``int ioctl(int request_fd, MEDIA_REQUEST_IOC_QUEUE)``

参数
=========

``request_fd``
    由 :ref:`MEDIA_IOC_REQUEST_ALLOC` 返回的文件描述符

描述
===========

如果媒体设备支持 :ref:`请求 <media-request-api>`，则可以使用此 ioctl 请求来队列化一个先前分配的请求。
如果请求成功队列化，则可以通过 :ref:`poll <request-func-poll>` 文件描述符来等待请求完成。
如果请求之前已经被队列化，则返回 ``EBUSY``。
如果请求内容包含无效或不一致的数据，则可能会返回其他错误，请参阅下一节中的常见错误代码列表。在发生错误时，请求和驱动程序状态保持不变。
一旦请求被队列化，驱动程序必须优雅地处理将请求应用于硬件时发生的错误。唯一的例外是 ``EIO`` 错误，它表示一个需要应用程序停止流传输以重置硬件状态的致命错误。
不允许混合使用直接队列化请求与直接队列化缓冲区（没有请求）。如果第一个缓冲区直接队列化，而随后尝试队列化一个请求，或者反过来，则会返回 ``EBUSY``。
一个请求必须至少包含一个缓冲区，否则此 ioctl 将返回 ``ENOENT`` 错误。

返回值
============

成功时返回 0，出错时返回 -1，并且设置 ``errno`` 变量为相应的值。通用错误代码在 :ref:`通用错误代码 <gen-errors>` 章节中描述。
EBUSY
    请求已被队列化，或者应用程序直接队列化了第一个缓冲区，但后来试图使用请求。不允许混合使用这两个 API。
ENOENT
请求中未包含任何缓冲区。所有请求都必须至少包含一个缓冲区。如果请求中缺少某些必需的配置，也可能返回此错误。

ENOMEM
分配此请求的内部数据结构时内存不足。

EINVAL
请求中的数据无效。

EIO
硬件状态异常。为了恢复，应用程序需要停止流传输以重置硬件状态，然后再尝试重新开始流传输。
