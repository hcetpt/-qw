SPDX 许可证标识符: GFDL-1.1-no-invariants-or-later

.. _overlay:

***********************
视频叠加接口
***********************

**也称为帧缓冲区叠加或预览。**

视频叠加设备能够将（电视）视频信号与显卡的（VGA）视频信号进行同步锁定，或将捕获的图像直接存储在显卡的视频内存中，通常带有裁剪功能。这比通过其他手段捕获和显示图像要高效得多。在只有核电站需要冷却塔的时代，这是将实时视频放入窗口中的唯一方法。视频叠加设备通过与 :ref:`视频捕获 <capture>` 设备相同的字符特殊文件访问。
.. note::

   默认情况下，``/dev/video`` 设备的功能是视频捕获。只有在调用了 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` ioctl 后，叠加功能才可用。
驱动程序可能支持使用读写和流式 I/O 方法同时进行叠加和捕获。如果支持，则无法保证以视频标准的标称帧率运行。某些帧可能会从叠加转向捕获，或者在一个场用于叠加而另一个场用于捕获（如果捕获参数允许的话）。应用程序应为捕获和叠加使用不同的文件描述符。所有能够同时进行捕获和叠加的驱动程序必须支持这一点。可选地，这些驱动程序也可以允许使用单个文件描述符进行捕获和叠加，以便与 V4L 和早期版本的 V4L2 兼容。[#f1]_

两个文件描述符的常见应用是 X11 的 :ref:`Xv/V4L <xvideo>` 接口驱动程序和一个 V4L2 应用程序。当 X 服务器控制视频叠加时，应用程序可以利用内存映射和 DMA。

查询功能
=====================

支持视频叠加接口的设备会在通过 :ref:`VIDIOC_QUERYCAP` ioctl 返回的 :c:type:`v4l2_capability` 结构体的 ``capabilities`` 字段中设置 ``V4L2_CAP_VIDEO_OVERLAY`` 标志。必须支持下面指定的叠加 I/O 方法。调谐器和音频输入是可选的。

补充功能
======================

视频叠加设备应按需支持 :ref:`音频输入 <audio>`、:ref:`调谐器`、:ref:`控制 <control>`、:ref:`裁剪和缩放 <crop>` 和 :ref:`流参数 <streaming-par>` ioctl。所有视频叠加设备必须支持 :ref:`视频输入 <video>` 和 :ref:`视频标准 <standard>` ioctl。

设置
=====

*注意：此支持已被移除。*
在开始叠加之前，应用程序必须使用帧缓冲区参数配置驱动程序，即帧缓冲区的地址和大小以及图像格式（例如 RGB 5:6:5）。:ref:`VIDIOC_G_FBUF <VIDIOC_G_FBUF>` 和 :ref:`VIDIOC_S_FBUF <VIDIOC_G_FBUF>` ioctl 可用于获取和设置这些参数。:ref:`VIDIOC_S_FBUF <VIDIOC_G_FBUF>` ioctl 是特权操作，因为它允许设置物理内存中的 DMA，绕过内核的内存保护机制。只有超级用户才能更改帧缓冲区的地址和大小。用户不应以 root 或设置了 SUID 位的方式运行电视应用程序。一个小的辅助应用程序应具有适当的权限，在适当的时间查询图形系统并编程 V4L2 驱动程序。
一些设备将视频覆盖层添加到显卡的输出信号中。在这种情况下，视频设备不会修改帧缓冲区，因此驱动程序不需要帧缓冲区地址和像素格式。`:ref:`VIDIOC_S_FBUF <VIDIOC_G_FBUF>` ioctl 操作无需特权。应用程序可以通过调用`:ref:`VIDIOC_G_FBUF <VIDIOC_G_FBUF>` ioctl 来检测这种类型的设备。

驱动程序可以支持五种剪裁/混合方法中的任何一种（或不支持任何一种）：

1. 色键显示仅在主图形表面上的像素呈现特定颜色时显示覆盖图像。
2. *注意：对该功能的支持已被移除。* 可以指定一个位图，其中每个位对应覆盖图像中的一个像素。当该位被设置时，相应的视频像素会被显示，否则会显示图形表面的一个像素。
3. *注意：对该功能的支持已被移除。* 可以指定一个剪裁矩形列表。在这些区域中*不*显示视频，因此可以看到图形表面。
4. 帧缓冲区有一个alpha通道，可用于剪裁或与视频混合。
5. 可以指定一个全局alpha值来将帧缓冲区内容与视频图像混合。

当硬件支持同时捕捉和覆盖，并且禁止不同的图像和帧缓冲区格式时，请求的第一个格式具有优先权。尝试捕捉 (:ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>`) 或覆盖 (:ref:`VIDIOC_S_FBUF <VIDIOC_G_FBUF>`) 可能会因 `EBUSY` 错误代码失败，或者返回相应修改后的参数。

覆盖窗口
=========

覆盖图像由裁剪和覆盖窗口参数确定。前者选择视频画面中要捕获的区域，后者定义如何覆盖图像及应用剪裁。至少需要重置裁剪初始化参数为默认值。一个示例见 :ref:`crop`。

覆盖窗口由一个结构体 :c:type:`v4l2_window` 描述。它定义了图像的大小、其在图形表面上的位置以及要应用的剪裁。为了获取当前参数，应用程序需要将结构体 :c:type:`v4l2_format` 的 `type` 字段设置为 `V4L2_BUF_TYPE_VIDEO_OVERLAY` 并调用 :ref:`VIDIOC_G_FMT <VIDIOC_G_FMT>` ioctl。驱动程序会填充名为 `win` 的子结构体 :c:type:`v4l2_window`。无法检索先前编程的剪裁列表或位图。
为了编程覆盖窗口应用程序，需要将 `struct :c:type:'v4l2_format'` 的 `type` 字段设置为 `V4L2_BUF_TYPE_VIDEO_OVERLAY`，初始化 `win` 子结构，并调用 ioctl :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>`。驱动程序会根据硬件限制调整参数，并返回实际的参数，就像 :ref:`VIDIOC_G_FMT <VIDIOC_G_FMT>` 所做的那样。与 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` 类似，ioctl :ref:`VIDIOC_TRY_FMT <VIDIOC_G_FMT>` 可以在不改变驱动程序状态的情况下了解其功能。与 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` 不同的是，在覆盖启用后这个命令也有效。覆盖图像的比例因子由 `struct :c:type:'v4l2_window'` 中给出的宽度和高度以及裁剪矩形的大小决定。更多信息请参阅 :ref:`crop`

当同时支持捕获和覆盖，并且硬件禁止不同的图像和窗口尺寸时，首先请求的尺寸优先。尝试捕获或覆盖（:ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>`）可能会因 `EBUSY` 错误代码而失败，或者返回相应的修改后的参数。
.. c:type:: v4l2_window

`struct v4l2_window`
-------------------

``struct v4l2_rect w``
    窗口相对于帧缓冲区左上角的位置和大小，通过 :ref:`VIDIOC_S_FBUF <VIDIOC_G_FBUF>` 定义。窗口可以超出帧缓冲区的宽度和高度，`x` 和 `y` 坐标可以是负数，并且它可以完全位于帧缓冲区之外。驱动程序会相应地裁剪窗口，或者如果无法实现，则修改其大小和/或位置。
``enum v4l2_field field``
    应用程序设置此字段来确定要覆盖哪个视频场，通常是 `V4L2_FIELD_ANY`（0），`V4L2_FIELD_TOP`，`V4L2_FIELD_BOTTOM` 或 `V4L2_FIELD_INTERLACED`。驱动程序可能必须选择不同的场顺序并在此处返回实际设置。
``__u32 chromakey``
    当通过 :ref:`VIDIOC_S_FBUF <VIDIOC_G_FBUF>` 协商了色键时，应用程序设置此字段为目标色键像素值。格式与帧缓冲区的像素格式相同（`struct :c:type:'v4l2_framebuffer' fmt.pixelformat` 字段），字节顺序为主机顺序。例如，对于 :ref:`V4L2_PIX_FMT_BGR24 <V4L2-PIX-FMT-BGR32>`，在小端序主机上该值应为 0xRRGGBB，在大端序主机上应为 0xBBGGRR。
``struct v4l2_clip * clips``
    *注意：对此的支持已被移除。*
    当没有协商色键并且 :ref:`VIDIOC_G_FBUF <VIDIOC_G_FBUF>` 表示此功能时，应用程序可以设置此字段指向一个裁剪矩形数组。
像窗口坐标 w 一样，裁剪矩形相对于帧缓冲区左上角定义。然而，裁剪矩形不得超出帧缓冲区的宽度和高度，并且它们不得重叠。如果可能的话，应用程序应该合并相邻的矩形。是否必须创建 x-y 或 y-x 带状区域，或者矩形的顺序是什么，并未定义。当不支持裁剪列表时，驱动程序忽略此字段。调用 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` 后的内容是不确定的。
``__u32 clipcount``
    *注意：对此的支持已被移除。*
    当应用程序设置了 `clips` 字段时，此字段必须包含列表中裁剪矩形的数量。当不支持裁剪列表时，驱动程序忽略此字段，调用 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` 后的内容是不确定的。当支持裁剪列表但不需要裁剪时，此字段必须设为零。
``void * bitmap``
    *注意：对此的支持已被移除。*
    当没有协商色键并且 :ref:`VIDIOC_G_FBUF <VIDIOC_G_FBUF>` 表示此功能时，应用程序可以设置此字段指向裁剪位掩码。
它必须与窗口大小相同，即 `w.width` 和 `w.height`。
每一位对应于叠加图像中的一个像素，只有当该位被 *设置* 时才会显示。像素坐标转换为位的方式如下：

```c
((__u8 *) bitmap)[w.width * y + x / 8] & (1 << (x & 7))
```

其中 `0` ≤ x < `w.width` 且 `0` ≤ y < `w.height`。[#f2]_

当不支持裁剪位掩码时，驱动程序会忽略此字段，在调用 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` 后其内容是未定义的。当支持位掩码但不需要裁剪时，此字段必须设置为 `NULL`。
应用程序不必创建裁剪列表或位掩码。当它们同时传递两者，或者尽管协商了色键（chroma-keying），结果是未定义的。
无论选择哪种方法，硬件的裁剪能力在数量或质量上可能是有限的。超出这些限制的结果是未定义的。[#f3]_

``__u8 global_alpha``
    如果已协商全局 alpha 混合（`V4L2_FBUF_FLAG_GLOBAL_ALPHA`，参见 :ref:`VIDIOC_S_FBUF <VIDIOC_G_FBUF>` 和 :ref:`framebuffer-flags`），用于混合帧缓冲区和视频图像的全局 alpha 值。
.. note::

   这个字段是在 Linux 2.6.23 中添加的，扩展了结构。然而，:ref:`VIDIOC_[G|S|TRY]_FMT <VIDIOC_G_FMT>` ioctl 操作，它们接受指向带有填充字节的 :c:type:`v4l2_format` 父结构的指针，并不受影响。

.. c:type:: v4l2_clip

struct v4l2_clip [#f4]_
-----------------------

``struct v4l2_rect c``
    裁剪矩形的坐标，相对于帧缓冲区的左上角。只有所有裁剪矩形之外的窗口像素才会被显示。
``struct v4l2_clip * next``
    指向下一个裁剪矩形的指针，当这是最后一个矩形时为 `NULL`。驱动程序忽略此字段，不能用于传递裁剪矩形的链表。

.. c:type:: v4l2_rect

struct v4l2_rect
----------------

``__s32 left``
    矩形左上角的水平偏移量，以像素为单位。
``__s32 top``
    矩形左上角的垂直偏移量，以像素为单位。
偏移量向右和向下增加。
``__u32 width``
矩形的宽度，以像素为单位。

``__u32 height``
矩形的高度，以像素为单位。

启用覆盖层
===========

要启动或停止帧缓冲区覆盖层应用程序，需要调用 `VIDIOC_OVERLAY` ioctl。
.. [#f1]
   在设计此API的设计者看来，任何努力支持同时捕获和覆盖层的驱动程序编写者都不会通过要求使用单个文件描述符来限制这种能力，如V4L和早期版本的V4L2。将此功能设为可选意味着依赖两个文件描述符的应用程序需要备份例程以兼容所有驱动程序，这比在不使用两个文件描述符的应用程序中使用更多工作。此外，两个文件描述符符合每个逻辑流一个文件描述符的一般概念。因此，作为复杂性权衡，驱动程序必须支持两个文件描述符，并且可以选择支持单个文件描述符操作。
.. [#f2]
   我们是否应该要求 `w.width` 是8的倍数？

.. [#f3]
   当图像写入到帧缓冲区内存时，如果驱动程序裁剪的像素少于预期，这是不可取的，因为应用程序和图形系统不知道这些区域需要刷新。驱动程序应裁剪更多的像素或根本不写入图像。
.. [#f4]
   X Window系统定义了“区域”，它是 `struct BoxRec { short x1, y1, x2, y2; }` 的向量，其中 `width = x2 - x1` 和 `height = y2 - y1`，因此不能直接传递X11裁剪列表。
