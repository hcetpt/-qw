.. 许可证标识符：GFDL-1.1-no-invariants-or-later
.. C命名空间:: V4L

.. _format:

************
数据格式
************

数据格式协商
=======================

不同的设备与应用程序交换不同类型的数据，例如视频图像、原始或切片的VBI数据、RDS数据报。即使在同一类型中，也存在许多不同的格式，特别是图像格式种类繁多。尽管驱动程序必须提供一个默认值，并且选择会在关闭和重新打开设备时保持不变，但应用程序在进行数据交换之前应始终协商数据格式。协商意味着应用程序请求特定的格式，而驱动程序选择并报告硬件能满足该请求的最佳方案。当然，应用程序也可以查询当前的选择。

存在一种单一机制来使用聚合结构 :c:type:`v4l2_format` 和 ioctl :ref:`VIDIOC_G_FMT <VIDIOC_G_FMT>` 以及 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` 来协商所有数据格式。此外，ioctl :ref:`VIDIOC_TRY_FMT <VIDIOC_G_FMT>` 可用于检查硬件能够实现的功能，而不实际选择新的数据格式。V4L2 API 支持的数据格式在 :ref:`devices` 中的相应设备部分有所介绍。关于图像格式的详细信息，请参阅 :ref:`pixfmt`

ioctl :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` 是初始化序列中的一个重要转折点。在此之前，多个面板应用程序可以同时访问同一设备以选择当前输入、更改控制或修改其他属性。第一个 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` 将逻辑流（如视频数据、VBI数据等）专属于一个文件描述符。

“专有”意味着没有其他应用程序，更准确地说是其他文件描述符，可以抓取此流或更改与协商参数不一致的设备属性。例如，视频标准的变化，当新标准使用不同数量的扫描线时，可能会使所选图像格式失效。因此，只有拥有该流的文件描述符才能做出无效变更。相应地，抓取不同逻辑流的多个文件描述符会阻止彼此干扰其设置。例如，在视频覆盖即将开始或正在进行时，可能限制同时进行视频捕获到相同的裁剪和图像大小。

当应用程序省略 ioctl :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` 时，其锁定副作用将由下一步隐含，即通过 ioctl :ref:`VIDIOC_REQBUFS` 选择I/O方法或通过第一个 :c:func:`read()` 或 :c:func:`write()` 调用隐含。

通常，一个文件描述符只能分配一个逻辑流，例外情况是允许使用同一文件描述符同时进行视频捕获和覆盖的驱动程序，以兼容 V4L 和早期版本的 V4L2。通过关闭和重新打开设备可以切换逻辑流或返回到“面板模式”。驱动程序 *可能* 支持使用 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` 进行切换。

所有与应用程序交换数据的驱动程序必须支持 ioctl :ref:`VIDIOC_G_FMT <VIDIOC_G_FMT>` 和 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>`。实现 ioctl :ref:`VIDIOC_TRY_FMT <VIDIOC_G_FMT>` 高度推荐但可选。

图像格式枚举
========================

除了通用格式协商功能外，还有一个特殊的 ioctl 用于枚举视频捕获、覆盖或输出设备支持的所有图像格式。[#f1]_

ioctl :ref:`VIDIOC_ENUM_FMT` 必须由所有与应用程序交换图像数据的驱动程序支持。
.. 重要提示::

    驱动程序不应在内核空间中转换图像格式
它们只能枚举硬件直接支持的格式。
如果有必要，驱动程序编写者应发布一个示例转换例程或库以集成到应用程序中。

.. [#f1]
   列举应用程序事先不知道的格式（否则它可以显式请求这些格式，无需枚举）看似无用，但有些应用程序作为驱动程序和实际视频应用程序之间的代理，这种功能是有用的。
