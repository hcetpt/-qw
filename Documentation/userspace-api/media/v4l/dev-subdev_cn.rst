SPDX 许可证标识符: GFDL-1.1-no-invariants-or-later

.. _subdev:

********************
子设备接口
********************

V4L2 设备的复杂性在于硬件通常由多个需要以受控方式相互作用的集成电路组成，这导致了复杂的 V4L2 驱动程序。驱动程序通常在软件中反映硬件模型，并将不同的硬件组件建模为称为子设备的软件块。V4L2 子设备通常是仅内核的对象。如果 V4L2 驱动程序实现了媒体设备 API，则它们会自动继承媒体实体。应用程序能够通过枚举媒体实体、端口和链接来发现子设备并了解硬件拓扑结构。

除了使子设备可被发现之外，驱动程序还可以选择让应用程序直接配置这些子设备。当子设备驱动程序和 V4L2 设备驱动程序都支持这一点时，子设备将具有一个字符设备节点，可以通过 ioctl 调用来：

- 查询、读取和写入子设备控制信息
- 订阅和取消订阅事件以及检索事件
- 在单个端口上协商图像格式
- 检查和修改同一实体内的端口之间的内部数据路由

子设备字符设备节点通常命名为 `/dev/v4l-subdev*`，使用主设备号 81。

驱动程序可以选择限制子设备字符设备仅暴露不修改设备状态的操作。在这种情况下，子设备被称为“只读”，在本文档的其余部分中会详细说明相关限制，并在各个 ioctl 中进行记录。

控制
=====

大多数 V4L2 控制是由子设备硬件实现的。驱动程序通常合并所有控制并通过视频设备节点进行暴露。应用程序可以通过单一接口控制所有子设备。

复杂的设备有时会在不同的硬件部件中实现相同的控制功能。这种情况在嵌入式平台上很常见，传感器和图像处理硬件都会实现相同的功能，如对比度调整、白平衡或故障像素校正。

由于 V4L2 控制 API 不支持在一个设备中有多个相同的控制，因此除了一个控制外，其他相同的控制会被隐藏。应用程序可以通过子设备节点使用 V4L2 控制 API（见 :ref:`control`）访问这些隐藏的控制。ioctl 的行为与在 V4L2 设备节点上调用时相同，只是它们仅处理子设备中实现的控制。

根据驱动程序的不同，这些控制也可能通过一个（或多个）V4L2 设备节点进行暴露。
事件
======

V4L2 子设备可以通知应用程序有关事件的信息，具体描述参见 :ref:`event`。该 API 在使用时与在 V4L2 设备节点上的行为相同，唯一的区别是它只处理由子设备生成的事件。根据不同的驱动程序，这些事件也可能在一个（或多个）V4L2 设备节点上报告。

.. _pad-level-formats:

端口级格式
=================

.. warning::

    端口级格式仅适用于那些非常复杂的设备，这些设备需要向用户空间暴露低级别的格式配置。通用的 V4L2 应用程序*不需要*使用本节中描述的 API。
.. note::

    在本节中，术语 *格式* 指的是媒体总线数据格式、帧宽度和帧高度的组合。
图像格式通常通过 `format` 和 :ref:`selection <VIDIOC_SUBDEV_G_SELECTION>` 的 ioctl 调用来协商视频采集和输出设备的格式。驱动程序负责根据管道输入和/或输出请求的格式来配置视频管道中的每个模块。

对于复杂的设备（例如嵌入式系统中常见的设备），可以通过不同的硬件配置实现管道输出端相同的图像尺寸。一个这样的例子如 :ref:`pipeline-scaling` 中所示，在视频传感器和主机图像处理硬件上都可以进行图像缩放。

.. _pipeline-scaling:

.. kernel-figure:: pipeline.dot
    :alt:   pipeline.dot
    :align: center

    图像格式在管道上的协商

    高质量和高速度的管道配置

传感器缩放器通常比主机缩放器质量差，但在传感器上进行缩放是为了实现更高的帧率。根据使用场景（质量与速度之间的权衡），管道必须以不同的方式配置。应用程序需要显式地在管道的每个点上配置格式。

实现了 :ref:`media API <media-controller-intro>` 的驱动程序可以向应用程序暴露端口级图像格式配置。当它们这样做时，应用程序可以使用 :ref:`VIDIOC_SUBDEV_G_FMT <VIDIOC_SUBDEV_G_FMT>` 和 :ref:`VIDIOC_SUBDEV_S_FMT <VIDIOC_SUBDEV_G_FMT>` 的 ioctl 来按端口协商格式。

应用程序负责在整个管道上配置一致的参数，并确保连接的端口具有兼容的格式。在 :ref:`VIDIOC_STREAMON <VIDIOC_STREAMON>` 时会检查管道的格式不匹配情况，如果配置无效，则返回 ``EPIPE`` 错误代码。

可以通过在端口 0 上调用 :ref:`VIDIOC_SUBDEV_G_FMT` ioctl 来测试端口级图像格式配置支持。如果驱动程序返回 ``EINVAL`` 错误代码，则表示子设备不支持端口级格式配置。
格式协商
------------------

在视频处理垫（pads）上可接受的格式（通常）依赖于一些外部参数，如其他垫上的格式、活动链接甚至是控制。在一个视频管道中找到所有垫上的格式组合，并且这些组合要被应用程序和驱动程序同时接受，仅仅依靠格式枚举是不够的。需要一种格式协商机制。

格式协商机制的核心是获取/设置格式的操作。当使用 ``which`` 参数调用 :ref:`V4L2_SUBDEV_FORMAT_TRY <VIDIOC_SUBDEV_G_FMT>` 时，:ref:`VIDIOC_SUBDEV_G_FMT <VIDIOC_SUBDEV_G_FMT>` 和 :ref:`VIDIOC_SUBDEV_S_FMT <VIDIOC_SUBDEV_G_FMT>` ioctl 操作会作用于一组与硬件配置无关的格式参数。修改这些“尝试”格式不会影响设备状态（这适用于驱动程序中的软件状态和设备本身中的硬件状态）。

虽然不作为设备状态的一部分存储，但尝试格式存储在子设备文件句柄中。:ref:`VIDIOC_SUBDEV_G_FMT <VIDIOC_SUBDEV_G_FMT>` 调用将返回在同一子设备文件句柄上设置的最后一个尝试格式。因此，多个应用程序同时查询同一个子设备时不会相互干扰。

为了确定特定格式是否受设备支持，应用程序使用 :ref:`VIDIOC_SUBDEV_S_FMT <VIDIOC_SUBDEV_G_FMT>` ioctl。驱动程序会验证并根据设备要求更改请求的 `format` 并返回可能已修改的值。应用程序可以选择尝试不同的格式或接受返回的值并继续。

在一次协商迭代过程中，驱动程序返回的格式保证被设备支持。特别是，驱动程序保证如果将返回的格式原封不动地传递给 :ref:`VIDIOC_SUBDEV_S_FMT <VIDIOC_SUBDEV_G_FMT>` 调用（只要外部参数，如其他垫上的格式或链接配置没有改变），该格式不会进一步更改。

驱动程序会在子设备内部自动传播格式。当在一个垫上设置尝试或活动格式时，驱动程序可以修改同一子设备上其他垫上的相应格式。驱动程序可以根据设备需求自由修改格式，但应尽可能遵守以下规则：

- 格式应从接收垫传播到发送垫。修改发送垫上的格式不应影响任何接收垫上的格式。
- 使用可变缩放因子缩放帧的子设备应在修改接收垫格式时重置缩放因子为默认值。如果支持1:1的缩放比例，则意味着发送垫上的格式应重置为接收垫上的格式。

格式不会跨链接传播，因为这涉及从一个子设备文件句柄传播到另一个。因此，应用程序必须显式地用兼容的格式配置每个链接的两端。链接两端相同的格式保证是兼容的。驱动程序可以自由接受符合设备要求的不同格式作为兼容格式。

:ref:`sample-pipeline-config` 展示了 :ref:`pipeline-scaling` 中描述的管道的一个示例配置序列（表列列出了实体名称和垫编号）。
```latex
\begingroup
\scriptsize
\setlength{\tabcolsep}{2pt}
```

.. tabularcolumns:: |p{2.0cm}|p{2.1cm}|p{2.1cm}|p{2.1cm}|p{2.1cm}|p{2.1cm}|p{2.1cm}|

.. _sample-pipeline-config:

.. flat-table:: 示例管道配置
    :header-rows:  1
    :stub-columns: 0
    :widths: 5 5 5 5 5 5 5

    * -
      - Sensor/0

        格式
      - Frontend/0

        格式
      - Frontend/1

        格式
      - Scaler/0

        格式
      - Scaler/0

        组合选择矩形
      - Scaler/1

        格式
    * - 初始状态
      - 2048x1536

        SGRBG8_1X8
      - (默认)
      - (默认)
      - (默认)
      - (默认)
      - (默认)
    * - 配置前端接收格式
      - 2048x1536

        SGRBG8_1X8
      - *2048x1536*

        *SGRBG8_1X8*
      - *2046x1534*

        *SGRBG8_1X8*
      - (默认)
      - (默认)
      - (默认)
    * - 配置缩放器接收格式
      - 2048x1536

        SGRBG8_1X8
      - 2048x1536

        SGRBG8_1X8
      - 2046x1534

        SGRBG8_1X8
      - *2046x1534*

        *SGRBG8_1X8*
      - *0,0/2046x1534*
      - *2046x1534*

        *SGRBG8_1X8*
    * - 配置缩放器接收组合选择
      - 2048x1536

        SGRBG8_1X8
      - 2048x1536

        SGRBG8_1X8
      - 2046x1534

        SGRBG8_1X8
      - 2046x1534

        SGRBG8_1X8
      - *0,0/1280x960*
      - *1280x960*

        *SGRBG8_1X8*

```latex
\endgroup
```

1. 初始状态。传感器源端口格式设置为其本机的3MP尺寸和V4L2_MBUS_FMT_SGRBG8_1X8媒体总线码。主机前端和缩放器接收及源端口的格式具有默认值，以及缩放器接收端口上的组合矩形。
2. 应用程序将前端接收端口格式的大小设置为2048x1536，并将其媒体总线码设置为V4L2_MBUS_FMT_SGRBG_1X8。驱动程序将该格式传播到前端源端口。
3. 应用程序将缩放器接收端口格式的大小设置为2046x1534，并将媒体总线码设置为V4L2_MBUS_FMT_SGRBG_1X8以匹配前端源端口的大小和媒体总线码。接收端口上的媒体总线码设置为V4L2_MBUS_FMT_SGRBG_1X8。驱动程序将大小传播到缩放器接收端口上的组合选择矩形，并将格式传播到缩放器源端口。
4. 应用程序将缩放器接收端口组合选择矩形的大小设置为1280x960。驱动程序将该大小传播到缩放器源端口格式。

当应用程序对尝试结果满意时，可以通过将 `which` 参数设置为 `V4L2_SUBDEV_FORMAT_ACTIVE` 来设置活动格式。驱动程序会以与尝试格式完全相同的方式更改活动格式。为了避免在格式协商过程中修改硬件状态，应用程序应首先协商尝试格式，然后使用上一次协商迭代中返回的尝试格式来修改活动设置。这保证了活动格式将被驱动程序按原样应用而不会被修改。

.. _v4l2-subdev-selections:

选择：裁剪、缩放和组合
-----------------------------

许多子设备支持在其输入或输出端口（甚至可能同时在两者上）进行帧裁剪。裁剪用于选择图像中的兴趣区域，通常是在图像传感器或视频解码器上。它也可以作为数字变焦实现的一部分，用于选择要放大的图像区域。
裁剪设置由一个裁剪矩形定义，并通过 `v4l2_rect` 结构体中的左上角坐标和矩形大小表示。坐标和大小均以像素为单位。
对于端口格式，驱动程序存储选择目标的尝试和活动矩形 :ref:`v4l2-selections-common`。
在接收端口上，裁剪是相对于当前端口格式应用的。
垫格式表示子设备从管道前一阶段接收到的图像大小，裁剪矩形则表示将在子设备内部进一步处理的子图像。

缩放操作通过将图像缩放到新尺寸来改变图像的大小。缩放比例并未明确指定，而是根据原始图像和缩放后的图像大小推断得出。这两种尺寸都由 `struct v4l2_rect` 表示。

缩放支持是可选的。当一个子设备支持缩放时，其输入垫上的裁剪矩形会缩放到使用 `VIDIOC_SUBDEV_S_SELECTION` IOCTL（使用 `V4L2_SEL_TGT_COMPOSE` 选择目标）配置的大小。如果子设备支持缩放但不支持组合，则顶部和左侧值不会被使用，并且必须始终设置为零。

在输出垫上，裁剪与输入垫类似，不同之处在于裁剪执行所基于的源大小是输入垫上的 COMPOSE 矩形。在输入和输出垫上，裁剪矩形必须完全包含在源图像大小内才能进行裁剪操作。

驱动程序应始终使用用户请求的所有选择目标中最接近的可能矩形，除非有特别说明。可以使用 `V4L2_SEL_FLAG_GE` 和 `V4L2_SEL_FLAG_LE` 标志来对图像大小进行向上或向下取整。请参阅 :ref:`v4l2-selection-flags`。

选择目标类型
--------------

实际目标
^^^^^^^^^^^^^^

实际目标（没有后缀）反映了任何时刻的实际硬件配置。每个实际目标都有一个对应的 BOUNDS 目标。

BOUNDS 目标
^^^^^^^^^^^^^^

BOUNDS 目标是最小的包含所有有效实际矩形的矩形。然而，可能无法将实际矩形设置为与 BOUNDS 矩形一样大。这可能是由于例如传感器的像素阵列不是矩形而是十字形或圆形。最大尺寸也可能小于 BOUNDS 矩形。

格式配置和传播顺序
-------------------------------

在子设备内部，图像处理步骤的顺序总是从输入垫到输出垫。这也反映在用户必须按照的配置顺序：所做的更改会被传递到后续阶段。如果不需要这种行为，用户必须设置 `V4L2_SEL_FLAG_KEEP_CONFIG` 标志。此标志导致在任何情况下都不允许更改传播。这也可能导致访问的矩形被驱动程序调整，具体取决于底层硬件的特性。

每一步的坐标总是指前一步的实际大小。唯一的例外是输入垫的组合矩形，它指的是输入垫的组合边界矩形——如果硬件支持的话。

1. 输入垫格式。用户配置输入垫格式。此格式定义了实体通过该垫接收以供进一步处理的图像参数。
2. 水槽端口实际裁剪选择。水槽端口裁剪定义了对水槽端口格式执行的裁剪。
3. 水槽端口实际合成选择。水槽端口合成矩形的大小定义了相对于水槽端口裁剪矩形大小的比例。合成矩形的位置指定了水槽合成边界矩形中实际水槽合成矩形的位置。
4. 源端口实际裁剪选择。源端口上的裁剪定义了在水槽合成边界矩形中的图像上执行的裁剪。
5. 源端口格式。源端口格式定义了子设备的输出像素格式以及其他参数（不包括图像的宽度和高度）。宽度和高度由源端口实际裁剪选择的大小定义。

访问子设备不支持的上述任何矩形将返回 `EINVAL`。任何引用先前不支持矩形坐标的矩形将改为引用先前支持的矩形。例如，如果水槽裁剪不被支持，则合成选择将参照水槽端口格式的尺寸。

.. _subdev-image-processing-crop:

.. kernel-figure:: subdev-image-processing-crop.svg
    :alt:   subdev-image-processing-crop.svg
    :align: center

    **图 4.5. 子设备中的图像处理：简单的裁剪示例**

在上述示例中，子设备支持在其水槽端口上进行裁剪。为了配置它，用户设置了子设备水槽端口上的媒体总线格式。现在可以在水槽端口上设置实际裁剪矩形——该矩形的位置和大小反映了从水槽格式中裁剪出的矩形的位置和大小。水槽裁剪矩形的大小也将是子设备源端口格式的大小。

.. _subdev-image-processing-scaling-multi-source:

.. kernel-figure:: subdev-image-processing-scaling-multi-source.svg
    :alt:   subdev-image-processing-scaling-multi-source.svg
    :align: center

    **图 4.6. 子设备中的图像处理：多源缩放**

在此示例中，子设备能够首先对两个源端口分别从结果缩放图像中进行裁剪，然后缩放并最终再次裁剪。在水槽合成目标中忽略了缩放图像在裁剪图像中的位置。两个源裁剪矩形的位置都指向水槽缩放矩形，独立地从其指定的位置裁剪一个区域。

.. _subdev-image-processing-full:

.. kernel-figure:: subdev-image-processing-full.svg
    :alt:    subdev-image-processing-full.svg
    :align:  center

    **图 4.7. 子设备中的图像处理：多水槽和多源的缩放与合成**

子设备驱动支持两个水槽端口和两个源端口。来自两个水槽端口的图像分别被裁剪，然后缩放，并进一步在合成边界矩形上进行合成。从中，两个独立的流被裁剪并通过源端口发送出子设备。

.. toctree::
    :maxdepth: 1

    subdev-formats

.. _subdev-routing:

流、多路复用媒体端口和内部路由
------------------------------------

简单的 V4L2 子设备不支持多个无关的视频流，并且只有一个流可以通过媒体链路和媒体端口。因此，每个端口包含针对该单一流程的格式和选择配置。子设备可以进行流处理并将一个流拆分为两个或合成两个流为一个，但子设备的输入和输出仍然是每个端口一个流。
一些硬件，例如MIPI CSI-2，支持多路复用流，也就是说，多个数据流可以通过同一总线传输，这通过一个媒体链路来表示，该链路连接发送器的源端口与接收器的接收端口。例如，摄像头传感器可以生成两个不同的流：像素流和元数据流，这些流通过多路复用数据总线传输，该总线由一条媒体链路表示，该链路连接单个传感器的源端口与接收器的接收端口。流感知接收器将解复用接收到的流，并允许将其单独路由到其源端口之一。

支持多路复用流的子设备驱动程序与不支持多路复用流的子设备驱动程序兼容。然而，如果链路接收端的驱动程序不支持流，则只能捕获源端的第0个流。可能存在针对接收设备的其他限制。

理解流
^^^^^^^^^^^^^^^^^^^^^

流是一种内容（例如像素数据或元数据）从源头（例如传感器）流向最终接收端（例如SoC中的接收器和解复用器）的过程。每个媒体链路承载从链路一端到另一端的所有启用的流，子设备具有路由表，描述了如何将来自接收端口的流入流路由到源端口。

流ID是流在媒体端口上的本地标识符。相同流的流ID在链路两端必须相等。换句话说，特定的流ID必须存在于媒体链路的两侧，但在子设备的另一侧可以使用另一个流ID表示相同的流。

在媒体管道中的某个特定点上，流由子设备及其（端口，流）对来标识。对于不支持多路复用流的子设备，‘流’字段始终为0。

路由、流、格式和选择之间的交互
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

将流添加到V4L2子设备接口后，子设备的格式和选择从端口转移到（端口，流）对。除了通常的端口外，设置格式和选择时还需要提供流ID。沿着流配置格式和选择的顺序与没有流时相同（参见 :ref:`format-propagation`）。

不再需要在整个子设备范围内将所有接收端口的流合并到所有源端口，每个路由的数据流是独立的。允许任何数量的从接收端口的流到源端口的流的路由，具体取决于驱动程序的支持。但是，对于源端口上的每个流，只允许有一个路由。

端口内流的任何配置（如格式或选择）与其他流上的类似配置是独立的。这在未来可能会发生变化。

设备类型和路由设置
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

不同类型的子设备在路由激活方面的行为有所不同，这取决于硬件。然而，在所有情况下，只有设置了`V4L2_SUBDEV_STREAM_FL_ACTIVE`标志的路由才是活跃的。
生成流的设备可能允许启用和禁用某些路由，或者具有固定的路由配置。如果这些路由可以被禁用，则在`VIDIOC_SUBDEV_S_ROUTING`中不声明这些路由（或声明时未设置`V4L2_SUBDEV_STREAM_FL_ACTIVE`标志）将会禁用这些路由。即使禁用了路由，`VIDIOC_SUBDEV_S_ROUTING`仍然会在路由数组中返回这些路由，并且`V4L2_SUBDEV_STREAM_FL_ACTIVE`标志位会被清除。

传输流的设备几乎总是具有更多的路由可配置性。通常情况下，子设备的输入端口和输出端口之间的任何路由都是可能的，并且多个路由（通常限于一定数量）可以同时激活。对于此类设备，驱动程序不会创建任何路由，并且当调用`VIDIOC_SUBDEV_S_ROUTING`时，用户创建的路由将被完全替换。新创建的路由将具有设备的默认格式和选择矩形配置。

配置流
^^^^^^^^^^^^^^^^^^^

流的配置是针对每个子设备单独进行的，并且在管道启动时会验证子设备之间的流的有效性。
配置流有三个步骤：

1. 设置连接。使用 :ref:`Media Controller API <media_controller>` 在子设备之间连接端口。

2. 配置流。通过设置子设备的路由表来声明并配置流，使用 :ref:`VIDIOC_SUBDEV_S_ROUTING <VIDIOC_SUBDEV_G_ROUTING>` ioctl。注意，设置路由表将重置子设备中的格式和选择为默认值。

3. 配置格式和选择。每个流的格式和选择分别进行配置，具体文档参见 :ref:`format-propagation` 中对普通子设备的描述。流ID设置为与通过 :ref:`VIDIOC_SUBDEV_S_ROUTING <VIDIOC_SUBDEV_G_ROUTING>` ioctl配置的路由相关的输入或输出端口相同的流ID。

多路复用流设置示例
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

一个多路复用流设置的简单示例如下：

- 两个相同的传感器（Sensor A 和 Sensor B）。每个传感器有一个输出端口（端口0），该端口传输像素数据流。
- 多路复用桥接器（Bridge）。桥接器有两个输入端口，分别连接到传感器（端口0、1），以及一个输出端口（端口2），该端口输出两条流。
- SoC中的接收器（Receiver）。接收器有一个输入端口（端口0），连接到桥接器，并有两个输出端口（端口1-2），连接到DMA引擎。接收器将输入的流解复用到输出端口。
- SoC中的DMA引擎（DMA Engine），每个流一个。每个DMA引擎连接到接收器的一个输出端口。

传感器、桥接器和接收器被建模为V4L2子设备，通过/dev/v4l-subdevX设备节点暴露给用户空间。DMA引擎被建模为V4L2设备，通过/dev/videoX节点暴露给用户空间。
为了配置此管道，用户空间必须采取以下步骤：

1. 在实体之间建立媒体连接：将传感器连接到桥接器，桥接器连接到接收器，接收器再连接到DMA引擎。这一步与正常的非多路复用媒体控制器设置并无不同。

2. 配置路由

.. flat-table:: 桥接器路由表
    :header-rows:  1

    * - 下游端口/流
      - 上游端口/流
      - 路由标志
      - 注释
    * - 0/0
      - 2/0
      - V4L2_SUBDEV_ROUTE_FL_ACTIVE
      - 来自Sensor A的像素数据流
    * - 1/0
      - 2/1
      - V4L2_SUBDEV_ROUTE_FL_ACTIVE
      - 来自Sensor B的像素数据流

.. flat-table:: 接收器路由表
    :header-rows:  1

    * - 下游端口/流
      - 上游端口/流
      - 路由标志
      - 注释
    * - 0/0
      - 1/0
      - V4L2_SUBDEV_ROUTE_FL_ACTIVE
      - 来自Sensor A的像素数据流
    * - 0/1
      - 2/0
      - V4L2_SUBDEV_ROUTE_FL_ACTIVE
      - 来自Sensor B的像素数据流

3. 配置格式和选择

   在配置路由之后，下一步是为各个流配置格式和选择。这与不带流的情况类似，只有一个例外：需要将“stream”字段赋值为流ID的值。
   
   常见的做法是从传感器开始，并沿着流向接收器传播配置，使用 :ref:`VIDIOC_SUBDEV_S_FMT <VIDIOC_SUBDEV_G_FMT>` ioctl 来在每个子设备中配置每个流的端点。
