.. 许可证标识符: GFDL-1.1-no-invariants-or-later
.. C 命名空间:: V4L

.. _open:

***************************
打开和关闭设备
***************************

.. _v4l2_hardware_control:

通过 V4L2 控制硬件外设
==========================================

使用 V4L2 用户空间 API 支持的硬件通常由多个设备或外设组成，每个设备都有自己的驱动程序。桥接驱动程序会暴露一个或多个 V4L2 设备节点（参见 :ref:`v4l2_device_naming`）。还有其他驱动程序提供对硬件其他组件的支持，这些组件也可能暴露设备节点，称为 V4L2 子设备。

当暴露了这样的 V4L2 子设备时，它们允许控制其他硬件组件——通常是通过串行总线（如 I²C、SMBus 或 SPI）连接的。根据桥接驱动程序的不同，这些子设备可以通过桥接驱动程序间接控制，也可以通过 :ref:`Media Controller <media_controller>` 和 :ref:`V4L2 子设备 <subdev>` 明确控制。需要使用 :ref:`Media Controller <media_controller>` 的设备称为**MC-centric**设备。完全通过 V4L2 设备节点控制的设备称为**video-node-centric**。

用户空间可以通过调用 :ref:`VIDIOC_QUERYCAP` 并检查 :ref:`device_caps 字段 <device-capabilities>` 来判断 V4L2 硬件外设是否为 MC-centric。如果设备在 `device_caps` 中返回 `V4L2_CAP_IO_MC` 标志，则它是 MC-centric 的，否则是 video-node-centric 的。

对于 MC-centric 驱动程序，必须通过 :ref:`media controller API <media_controller>` 识别 V4L2 子设备并配置管道。此外，子设备的配置应通过 :ref:`sub-device API <subdev>` 进行控制。

.. note::

   video-node-centric 设备仍然可以提供 media-controller 和 sub-device 接口。
然而，在这种情况下，媒体控制器和子设备接口是只读的，仅提供有关设备的信息。实际的配置是通过视频节点完成的。

.. _v4l2_device_naming:

V4L2 设备节点命名
=======================

V4L2 驱动程序实现为内核模块，由系统管理员手动加载或在首次发现设备时自动加载。这些驱动程序模块会插入到 `videodev` 内核模块中。该模块提供了辅助函数和本文件中指定的通用应用程序接口。
每个加载的驱动程序会注册一个或多个主设备号为 81 的设备节点。次设备号是动态分配的，除非内核编译时启用了内核选项 `CONFIG_VIDEO_FIXED_MINOR_RANGES`。在这种情况下，次设备号根据设备节点类型分配。

Video4Linux 子系统支持的设备节点如下：

======================== ====================================================
默认设备节点名称         用途
======================== ====================================================
``/dev/videoX``          视频和元数据（用于捕获/输出设备）
``/dev/vbiX``            垂直空白数据（例如字幕、电传视讯）
``/dev/radioX``          收音机调谐器和调制器
``/dev/swradioX``        软件定义无线电调谐器和调制器
``/dev/v4l-touchX``      触摸传感器
``/dev/v4l-subdevX``     视频子设备（用于传感器和其他硬件外设组件）\ [#]_
======================== ====================================================

其中 `X` 是一个非负整数。

.. note::
   
   1. 实际的设备节点名称取决于系统，因为可能会应用 udev 规则。
   2. 没有保证 `X` 对于相同的设备保持不变，因为该数字取决于设备驱动程序的探测顺序。
   如果需要唯一名称，udev 默认规则会在 `/dev/v4l/by-id/` 和 `/dev/v4l/by-path/` 目录中生成链接，可以用来唯一标识一个 V4L2 设备节点：

	```
	$ tree /dev/v4l
	/dev/v4l
	├── by-id
	│   └── usb-OmniVision._USB_Camera-B4.04.27.1-video-index0 -> ../../video0
	└── by-path
	    └── pci-0000:00:14.0-usb-0:2:1.0-video-index0 -> ../../video0
	```

.. [#] **V4L2 子设备节点**（例如 `/dev/v4l-subdevX`）使用不同的系统调用集，具体详见 :ref:`subdev`。

许多驱动程序支持 `"video_nr"`、`"radio_nr"` 或 `"vbi_nr"` 模块选项来选择特定的视频/收音机/vbi 节点编号。这允许用户请求设备节点被命名为 `/dev/video5` 而不是随机分配。当驱动程序支持多种类型的设备时，可以分配多个设备节点编号，中间用逗号分隔：

.. code-block:: none

   # modprobe mydriver video_nr=0,1 radio_nr=0,1

在 `/etc/modules.conf` 中可以这样写：

```
options mydriver video_nr=0,1 radio_nr=0,1
```

如果没有给定设备节点编号作为模块选项，则驱动程序会提供一个默认值。
通常情况下，udev 会自动在 `/dev` 目录下为您创建设备节点。如果未安装 udev，则需要启用内核选项 `CONFIG_VIDEO_FIXED_MINOR_RANGES`，以便能够正确地将次设备号映射到设备节点编号。也就是说，您需要确保次设备号 5 映射到设备节点名称 `video5`。通过这个内核选项，不同类型的设备具有不同的次设备号范围。这些范围列在 :ref:`devices` 中。

创建字符特殊文件（使用 `mknod`）是一种特权操作，并且无法通过主设备号和次设备号打开设备。这意味着应用程序不能可靠地扫描已加载或已安装的驱动程序。用户必须输入设备名称，或者应用程序可以尝试使用常规设备名称。

.. _related:

相关设备
=========

设备可以支持多种功能。例如视频捕捉、VBI 捕捉和无线电支持。
V4L2 API 为每种功能创建不同的 V4L2 设备节点。
最初设计 V4L2 API 的初衷是一个设备节点可以支持所有功能。然而，在实践中这从未实现：此“特性”从未被应用程序使用，许多驱动程序也不支持它，即使它们支持也从未经过测试。此外，仅当使用流式 I/O API 时，才能在不同功能之间切换设备节点，而使用 :c:func:`read()`/:c:func:`write()` API 时则不行。
如今，每个 V4L2 设备节点只支持单一功能。
除了视频输入或输出外，硬件还可能支持音频采样或播放。如果是这样，这些功能将作为 ALSA PCM 设备实现，可选地附带 ALSA 音频混音器设备。
所有这些设备的一个问题是 V4L2 API 没有提供任何机制来查找这些相关的 V4L2 设备节点。一些复杂的硬件使用了媒体控制器（见 :ref:`media_controller`），可用于此目的。但许多驱动程序并未使用它，虽然存在一些使用 sysfs 发现相关 V4L2 设备节点的代码（见 `v4l-utils <http://git.linuxtv.org/cgit.cgi/v4l-utils.git/>`__ git 仓库中的 libmedia_dev），但目前尚无库能提供一个统一的 API 同时支持基于媒体控制器的设备和不使用媒体控制器的设备。如果您想在这方面进行工作，请给 linux-media 邮件列表写信：`https://linuxtv.org/lists.php <https://linuxtv.org/lists.php>`__

多重打开
=========

V4L2 设备可以被多次打开。[#f1]_ 当驱动程序支持这一点时，用户可以启动一个“面板”应用来更改诸如亮度或音频音量等控制项，同时另一个应用捕捉视频和音频。换句话说，面板应用类似于 ALSA 音频混音器应用。仅仅打开一个 V4L2 设备不应改变该设备的状态。[#f2]_

一旦某个应用分配了用于流数据所需的内存缓冲区（通过调用 :ref:`VIDIOC_REQBUFS` 或 :ref:`VIDIOC_CREATE_BUFS` ioctl，或隐式地通过调用 :c:func:`read()` 或 :c:func:`write()` 函数），该应用（文件句柄）就成为了该设备的所有者。此时不允许更改影响缓冲区大小的操作（如调用 :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` ioctl），其他应用也不允许分配缓冲区或开始或停止流式传输。将返回 EBUSY 错误码。

仅仅打开一个 V4L2 设备并不会授予独占访问权限。[#f3]_
然而，一旦开始数据交换，则赋予该文件描述符读取或写入请求类型的数据以及更改相关属性的权利。应用程序可以通过 :ref:`app-pri` 中描述的优先级机制请求额外的访问权限。
共享数据流
===================

V4L2 驱动程序不应通过复制缓冲区、时间复用或类似手段支持多个应用程序在同一设备上读取或写入相同的数据流。这种情况更适合由用户空间中的代理应用程序来处理。

函数
=========

为了打开和关闭 V4L2 设备，应用程序使用 `open()` 和 `close()` 函数。设备的编程使用 `ioctl()` 函数（如以下章节所述）进行。
.. [#f1]
   仍有一些旧的和不常见的驱动程序尚未更新以允许多次打开。这意味着对于这些驱动程序，当设备已在使用时，`open()` 可能返回一个 `EBUSY` 错误代码。
.. [#f2]
   不幸的是，在许多驱动程序中，打开一个无线电设备通常会将设备的状态切换到无线电模式。这种行为最终应该得到修正，因为它违反了 V4L2 规范。
.. [#f3]
   驱动程序可以识别 `O_EXCL` 打开标志。目前这并不是必需的，因此应用程序无法知道它是否真正起作用。
