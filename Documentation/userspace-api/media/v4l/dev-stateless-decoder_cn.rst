SPDX 许可证标识符: GPL-2.0

.. _stateless_decoder:

**************************************************
内存到内存的无状态视频解码器接口
**************************************************

无状态解码器是一种在处理帧之间不保留任何状态的解码器。这意味着每个帧独立于任何前一帧和后一帧进行解码，并且客户端负责维护解码状态，并在每次解码请求时将其提供给解码器。这与有状态视频解码器接口形成对比，在有状态视频解码器接口中，硬件和驱动程序维护解码状态，客户端只需提供原始编码流并在显示顺序中出队已解码的帧。

本节描述了用户空间（“客户端”）如何与无状态解码器通信以成功解码编码流。与有状态编解码器相比，解码器/客户端序列更简单，但这种简单性的代价是客户端的额外复杂性，客户端负责维护一致的解码状态。

无状态解码器利用了 :ref:`media-request-api`。一个无状态解码器必须在其 `OUTPUT` 队列上暴露 `V4L2_BUF_CAP_SUPPORTS_REQUESTS` 能力，当调用 :c:func:`VIDIOC_REQBUFS` 或 :c:func:`VIDIOC_CREATE_BUFS` 时。

根据解码器支持的编码格式，单个解码帧可能是多个解码请求的结果（例如，每帧有多个片的 H.264 流）。支持此类格式的解码器还必须在其 `OUTPUT` 队列上暴露 `V4L2_BUF_CAP_SUPPORTS_M2M_HOLD_CAPTURE_BUF` 能力。

查询能力
=====================

1. 为了枚举解码器支持的编码格式集，客户端在 `OUTPUT` 队列上调用 :c:func:`VIDIOC_ENUM_FMT`
   * 驱动程序必须始终返回所有支持的 `OUTPUT` 格式，无论当前在 `CAPTURE` 队列上设置的是什么格式
   * 同时，驱动程序必须限制由编解码器特定功能控制返回的值集（如 H.264 档案），使其仅限于硬件实际支持的范围

2. 为了枚举支持的原始格式集，客户端在 `CAPTURE` 队列上调用 :c:func:`VIDIOC_ENUM_FMT`
   * 驱动程序必须仅返回 `OUTPUT` 队列当前活动格式所支持的格式
* 根据当前设置的 ``OUTPUT`` 格式，支持的原始格式可能依赖于某些编解码器相关控制项的值。
  客户端负责在查询 ``CAPTURE`` 队列之前确保这些控制项已设置。如果未这样做，则会使用这些控制项的默认值，并且返回的格式集可能无法用于客户端试图解码的媒体。
* 客户端可以使用 :c:func:`VIDIOC_ENUM_FRAMESIZES` 来检测给定格式支持的分辨率，通过将所需的像素格式传递给 :c:type:`v4l2_frmsizeenum` 的 ``pixel_format``。
* 对于当前 ``OUTPUT`` 格式，如果适用，可以通过各自的控制项使用 :c:func:`VIDIOC_QUERYCTRL` 查询支持的配置文件和级别。

初始化
=======

1. 通过 :c:func:`VIDIOC_S_FMT` 在 ``OUTPUT`` 队列上设置编码格式。
* **必需字段：**

     ``type``
         一个适用于 ``OUTPUT`` 的 ``V4L2_BUF_TYPE_*`` 枚举值。
``pixelformat``
         编码像素格式。
``width``, ``height``
         从流中解析出的编码宽度和高度。
其他字段
         遵循标准语义。
.. 注意::

      更改 ``OUTPUT`` 格式可能会更改当前设置的 ``CAPTURE`` 格式。驱动程序将根据设置的 ``OUTPUT`` 格式推导出一个新的 ``CAPTURE`` 格式，包括分辨率、色彩参数等。如果客户端需要特定的 ``CAPTURE`` 格式，则必须在之后进行调整。
2. 调用 :c:func:`VIDIOC_S_EXT_CTRLS` 来设置 ``OUTPUT`` 格式所需的全部控制项（解析的头文件等），以便枚举 ``CAPTURE`` 格式。

3. 调用 :c:func:`VIDIOC_G_FMT` 对于 ``CAPTURE`` 队列，以获取从字节流中解析/解码的目标缓冲区格式。
   
   * **必需字段：**
     
     ``type``
         适用于 ``CAPTURE`` 的 `V4L2_BUF_TYPE_*` 枚举值。
   * **返回字段：**
     
     ``width``, ``height``
         解码帧的帧缓冲分辨率。
     ``pixelformat``
         解码帧的像素格式。
     ``num_planes`` （仅对于 _MPLANE 类型）
         像素格式的平面数量。
     ``sizeimage``, ``bytesperline``
         按照标准语义；匹配帧缓冲格式。
   
   .. note::
   
      ``pixelformat`` 的值可以是基于硬件能力支持的任何 ``OUTPUT`` 格式的像素格式。建议驱动程序根据当前配置选择首选/最优格式。例如，如果需要额外的转换步骤，则 YUV 格式可能比 RGB 格式更优。

4. *[可选]* 通过在 ``CAPTURE`` 队列上使用 :c:func:`VIDIOC_ENUM_FMT` 枚举 ``CAPTURE`` 格式。客户端可以使用此 ioctl 发现当前 ``OUTPUT`` 格式支持的备选原始格式，并通过 :c:func:`VIDIOC_S_FMT` 选择其中一个。
   
   .. note::
   
      即使解码器通常可能支持更多的格式，驱动程序也只会返回当前选定的 ``OUTPUT`` 格式和当前设置的控制项所支持的格式。
例如，解码器可能支持1920x1088及以下分辨率的YUV和RGB格式，但对于更高分辨率只支持YUV（由于硬件限制）。设置1920x1088或更低的分辨率为“OUTPUT”格式后，:c:func:`VIDIOC_ENUM_FMT`可能会返回一组YUV和RGB像素格式，但在设置高于1920x1088的分辨率后，驱动程序将不会返回RGB像素格式，因为该分辨率不支持这些格式。

5. *[可选]* 通过在“CAPTURE”队列上使用:c:func:`VIDIOC_S_FMT`选择与建议的不同“CAPTURE”格式。客户端可以选择与驱动程序在:c:func:`VIDIOC_G_FMT`中选择/建议的不同格式。
* **必需字段：**

      ``type``
          适用于“CAPTURE”的``V4L2_BUF_TYPE_*``枚举值
``pixelformat``
          原始像素格式
``width``, ``height``
         解码流的帧缓冲区分辨率；通常保持不变（与:c:func:`VIDIOC_G_FMT`返回的一致），但如果硬件支持组合和/或缩放，则可能不同
完成此步骤后，客户端必须再次执行步骤3，以获取有关缓冲区大小和布局的最新信息。

6. 通过在“OUTPUT”队列上使用:c:func:`VIDIOC_REQBUFS`分配源（字节流）缓冲区
* **必需字段：**

      ``count``
          请求分配的缓冲区数量；大于零
``type``
          适用于“OUTPUT”的``V4L2_BUF_TYPE_*``枚举值
``memory``
          遵循标准语义
* **返回字段：**

      ``count``
          实际分配的缓冲区数量

* 如果需要，驱动程序将调整 ``count`` 使其等于或大于给定格式和请求数量所需的最小 ``OUTPUT`` 缓冲区数量。客户端必须在 ioctl 返回后检查此值以获取实际分配的缓冲区数量。
7. 通过在 ``CAPTURE`` 队列上调用 :c:func:`VIDIOC_REQBUFS` 分配目标（原始格式）缓冲区
* **必需字段：**

      ``count``
          请求分配的缓冲区数量；大于零。客户端负责推断流正确解码所需的最小缓冲区数量（例如考虑参考帧），并传递一个相等或更大的数量
``type``
          适用于 ``CAPTURE`` 的 ``V4L2_BUF_TYPE_*`` 枚举
``memory``
          遵循标准语义。``V4L2_MEMORY_USERPTR`` 不支持用于 ``CAPTURE`` 缓冲区
* **返回字段：**

      ``count``
          调整为分配的缓冲区数量，如果编解码器需要比请求更多的缓冲区

* 驱动程序必须根据当前格式、流配置和请求的数量调整 ``count`` 至所需 ``CAPTURE`` 缓冲区的最小数量。客户端必须在 ioctl 返回后检查此值以获取分配的缓冲区数量。
8. 通过 :c:func:`MEDIA_IOC_REQUEST_ALLOC` 在媒体设备上分配请求（可能每个 ``OUTPUT`` 缓冲区一个）
9. 通过 :c:func:`VIDIOC_STREAMON` 启动 ``OUTPUT`` 和 ``CAPTURE`` 队列上的流传输
解码
========

对于每一帧，客户端需要负责提交至少一个请求，并附带以下内容：

* 编码数据量，这是根据当前配置的编解码器所需的编码数据量，作为提交给“OUTPUT”队列的缓冲区。通常，这对应于一帧的编码数据，但某些格式可能允许（或要求）每单位有不同的数据量。
* 解码所需的所有元数据，以与正在解码的格式相关的控制形式提供。

源“OUTPUT”缓冲区的数据量和内容以及必须在请求上设置的控制项取决于活动的编码像素格式，并且可能会受到特定编解码器扩展控制的影响，具体请参见每种格式的文档。

如果解码的帧有可能需要在当前请求之后再进行一个或多个解码请求才能生成，则客户端必须在“OUTPUT”缓冲区上设置“V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF”标志。这将导致（部分地）解码的“CAPTURE”缓冲区不会被释放用于出队，并在下一个“OUTPUT”缓冲区的时间戳没有改变的情况下用于下一个解码请求。

典型的一帧会按照以下序列进行解码：

1. 使用:c:func:`VIDIOC_QBUF`函数排队一个包含一个编码字节流数据单元的“OUTPUT”缓冲区用于解码请求。
* **必需字段：**

    - `index`
        被排队的缓冲区的索引
    - `type`
        缓冲区的类型
    - `bytesused`
        缓冲区中编码数据帧所占的字节数
    - `flags`
        必须设置`V4L2_BUF_FLAG_REQUEST_FD`标志。此外，如果我们不确定当前的解码请求是否是生成完全解码帧所需的最后一个请求，则还必须设置`V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF`标志
    - `request_fd`
        必须设置为解码请求的文件描述符
``timestamp`` 必须为每一帧设置一个唯一的值。这个值将被传播到解码帧的缓冲区中，也可以用于将此帧作为另一个帧的参考。如果每帧使用多个解码请求，则给定帧的所有 ``OUTPUT`` 缓冲区的时间戳必须相同。如果时间戳发生变化，则当前持有的 ``CAPTURE`` 缓冲区将被释放以供出队，并且当前请求将在一个新的 ``CAPTURE`` 缓冲区上工作。

2. 使用 :c:func:`VIDIOC_S_EXT_CTRLS` 设置解码请求的编解码器特定控制。
* **必需字段：**

      ``which``
          必须是 ``V4L2_CTRL_WHICH_REQUEST_VAL``
      ``request_fd``
          必须设置为解码请求的文件描述符
      其他字段
          当设置控制时，其他字段按常规设置。``controls`` 数组必须包含解码一帧所需的所有编解码器特定控制。

.. note::

      可以在不同的 :c:func:`VIDIOC_S_EXT_CTRLS` 调用中指定控制，或者只要正确设置了 ``request_fd`` 和 ``which``，就可以覆盖之前设置的控制。提交请求时的控制状态将是最终采用的状态。

.. note::

      第 1 步和第 2 步的顺序可以互换。

3. 通过在请求文件描述符上调用 :c:func:`MEDIA_REQUEST_IOC_QUEUE` 来提交请求。
如果提交请求时没有附带 ``OUTPUT`` 缓冲区，或者请求缺少某些必需的控制，则 :c:func:`MEDIA_REQUEST_IOC_QUEUE` 将返回 ``-ENOENT``。如果排队了多个 ``OUTPUT`` 缓冲区，则返回 ``-EINVAL``。

:c:func:`MEDIA_REQUEST_IOC_QUEUE` 返回非零值意味着此请求不会生成任何 ``CAPTURE`` 缓冲区。
``CAPTURE`` 缓冲区不应成为请求的一部分，并且独立地进行排队。它们按照解码顺序返回（即与编码帧提交到 ``OUTPUT`` 队列的顺序相同）。运行时解码错误会通过带有 ``V4L2_BUF_FLAG_ERROR`` 标志的出队 ``CAPTURE`` 缓冲区来指示。如果一个解码参考帧有错误，那么所有引用它的后续解码帧也会被设置为 ``V4L2_BUF_FLAG_ERROR`` 标志，尽管解码器仍会尝试生成（可能已损坏的）帧。

解码过程中的缓冲区管理
======================
与状态化解码器不同，无状态解码器不执行任何形式的缓冲区管理：它仅保证出队的 ``CAPTURE`` 缓冲区可以在再次入队之前由客户端使用。这里的“使用”包括将缓冲区用于合成或显示。

一个出队的捕获缓冲区也可以作为另一个缓冲区的参考帧。
要指定一个帧作为参考帧，需要将其时间戳转换为纳秒，并存储在编码相关的控制结构的相关成员中。应使用 :c:func:`v4l2_timeval_to_ns` 函数来进行此转换。一旦某个帧的所有编码数据单元成功提交到 ``OUTPUT`` 队列，其时间戳即可用于引用该帧。

包含参考帧的解码缓冲区在所有引用它的帧被解码之前不应被重用作为解码目标。实现这一点最安全的方法是在所有引用该参考帧的解码帧出队之后再入队参考缓冲区。然而，如果驱动程序可以保证 ``CAPTURE`` 队列中的缓冲区按入队顺序处理，则用户空间可以利用这一保证，在满足以下条件时入队参考缓冲区：

1. 所有受参考帧影响的帧的请求均已入队；
2. 已经入队了足够数量的 ``CAPTURE`` 缓冲区以覆盖所有引用该参考帧的解码帧。

当入队解码请求时，驱动程序会增加与参考帧相关资源的引用计数。这意味着客户端例如可以在不需要这些缓冲区之后关闭参考帧缓冲区的 DMABUF 文件描述符。

寻址
====
为了寻址，客户端只需提交对应于新流位置的输入缓冲区即可。然而，它必须意识到分辨率可能已经改变，并在这种情况下遵循动态分辨率变化序列。此外，根据使用的编解码器，图像参数（例如 H.264 的 SPS/PPS）可能已改变，客户端负责确保向解码器发送有效的状态。

然后，客户端可以自由忽略来自寻址前位置的所有返回的 ``CAPTURE`` 缓冲区。
暂停
=======

为了暂停，客户端只需停止将缓冲区排队到“OUTPUT”队列。没有源字节流数据，就没有可处理的数据，编解码器将保持空闲状态。

动态分辨率更改
=========================

如果客户端检测到流中的分辨率变化，则需要使用新的分辨率重新执行初始化序列：

1. 如果最后一次提交的请求导致一个“CAPTURE”缓冲区被“V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF”标志持有，则最后一帧不可用在“CAPTURE”队列上。在这种情况下，应发送“V4L2_DEC_CMD_FLUSH”命令。这会使驱动程序取消排队的“CAPTURE”缓冲区。
2. 等待所有提交的请求完成，并取消排队相应的输出缓冲区。
3. 对“OUTPUT”和“CAPTURE”队列调用:c:func:`VIDIOC_STREAMOFF`。
4. 通过在“CAPTURE”队列上调用:c:func:`VIDIOC_REQBUFS`并将缓冲区数量设置为零来释放所有“CAPTURE”缓冲区。
5. 再次执行初始化序列（除了分配“OUTPUT”缓冲区之外），并在“OUTPUT”队列上设置新的分辨率。
请注意，由于分辨率限制，“CAPTURE”队列可能需要选择不同的格式。

排空
=====

如果最后一次提交的请求导致一个“CAPTURE”缓冲区被“V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF”标志持有，则最后一帧不可用在“CAPTURE”队列上。在这种情况下，应发送“V4L2_DEC_CMD_FLUSH”命令。这会使驱动程序取消排队的“CAPTURE”缓冲区。
之后，在无状态解码器上排空流，客户端只需等待所有提交的请求完成即可。
