========================================================
OpenCAPI（开放一致性加速器处理器接口）
========================================================

OpenCAPI 是处理器与加速器之间的接口。其目标是实现低延迟和高带宽。该规范由 `OpenCAPI 联盟 <http://opencapi.org/>`_ 开发。它允许加速器（可能是 FPGA、ASIC 等）使用虚拟地址一致地访问主机内存。一个 OpenCAPI 设备也可以拥有自己的内存，这部分内存可以从主机访问。

在 Linux 中，OpenCAPI 被称为 'ocxl'，它是 'cxl'（IBM CAPI 接口的 powerpc 驱动程序）的一种开放且与处理器无关的演变版本，命名为此是为了避免与 ISDN CAPI 子系统混淆。
高级视图
===============

OpenCAPI 定义了数据链路层（DL）和事务层（TL），它们需要基于物理链路实现。任何实现了 DL 和 TL 的处理器或设备都可以开始共享内存：
::

  +-----------+                         +-------------+
  |           |                         |             |
  |           |                         | 加速功能单元 |
  | 处理器    |                         |  (AFU)      |  +--------+
  |           |  +--------+             |             |--| 内存   |
  |           |--| 内存   |             +-------------+  +--------+
  +-----------+                         +-------------+
       |                                       |
  +-----------+                         +-------------+
  |    TL     |                         |    TLX      |
  +-----------+                         +-------------+
       |                                       |
  +-----------+                         +-------------+
  |    DL     |                         |    DLX      |
  +-----------+                         +-------------+
       |                                       |
       |                   物理层               |
       +---------------------------------------+

设备发现
================

OpenCAPI 依赖于设备上实现的一个类似 PCI 的配置空间，因此主机可以通过查询配置空间来发现 AFU。Linux 中的 OpenCAPI 设备被视为 PCI 设备（有一些例外）。固件预计会将硬件抽象为 PCI 链接。现有的许多 PCI 基础设施被重用：设备在标准 PCI 枚举期间进行扫描并分配 BAR。因此，可以使用诸如 'lspci' 这样的命令查看可用的设备。

配置空间定义了物理适配器上可以找到的 AFU（如其名称、它可以处理多少个内存上下文、其 MMIO 区域的大小等）。
MMIO
====

OpenCAPI 为每个 AFU 定义了两个 MMIO 区域：

* 全局 MMIO 区域，包含与整个 AFU 相关的寄存器
* 每个进程的 MMIO 区域，每个上下文都有固定的大小
AFU 中断
==============

OpenCAPI 包括了一个 AFU 向主机进程发送中断的可能性。这是通过事务层中的 'intrp_req' 完成的，该请求定义了一个 64 位对象句柄，以标识中断。
### 驱动程序允许进程分配中断并获取其64位对象句柄，该句柄可以传递给AFU

#### 字符设备
驱动程序为物理设备上的每个AFU创建一个字符设备。一个物理设备可能有多个功能，每个功能可以有多个AFU。不过，在撰写本文时，仅测试了只导出一个AFU的设备。字符设备可以在 `/dev/ocxl/` 中找到，并命名为：
```
/dev/ocxl/<AFU名称>.<位置>.<索引>
```

其中 `<AFU名称>` 是一个最长20个字符的名字，如在AFU的配置空间中找到的那样。
`<位置>` 是由驱动程序添加的，当系统中有多个相同的OpenCAPI设备实例时，可以帮助区分这些设备。
`<索引>` 也是为了在不太可能的情况下帮助区分同一设备中的多个相同AFU。

#### Sysfs类
为表示AFU的设备添加了一个 `ocxl` 类。参见 `/sys/class/ocxl`。布局在 `Documentation/ABI/testing/sysfs-class-ocxl` 中描述。

### 用户API

#### 打开（open）
根据在配置空间中定义的AFU，AFU可能支持与多个内存上下文一起工作，在这种情况下，相关的字符设备可以被不同的进程多次打开。

#### ioctl
##### OCXL_IOCTL_ATTACH
将调用进程的内存上下文附加到AFU，以便AFU可以访问其内存。

##### OCXL_IOCTL_IRQ_ALLOC
分配一个AFU中断并返回一个标识符。

##### OCXL_IOCTL_IRQ_FREE
释放之前分配的AFU中断。

##### OCXL_IOCTL_IRQ_SET_FD
将一个事件文件描述符关联到AFU中断，以便用户进程在AFU发送中断时能够得到通知。
OCXL_IOCTL_GET_METADATA:
  
  从卡中获取配置信息，例如 MMIO 区域的大小、AFU 版本以及当前上下文的 PASID。

OCXL_IOCTL_ENABLE_P9_WAIT:

  允许 AFU 唤醒正在执行 'wait' 的用户空间线程。返回信息到用户空间，以便其配置 AFU。注意，这仅在 POWER9 上可用。

OCXL_IOCTL_GET_FEATURES:

  报告哪些影响 OpenCAPI 的 CPU 特性可以从用户空间使用。

mmap
----

进程可以通过 mmap 映射每个进程的 MMIO 区域以与 AFU 进行交互。
