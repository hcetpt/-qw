### unshare 系统调用

#### 文档描述
本文档描述了新的系统调用 `unshare()`。文档提供了该功能的概述、为何需要它、如何使用它、接口规范、设计、实现以及如何测试。

#### 版本记录
- **版本 0.1**：初始文档，Janak Desai (janak@us.ibm.com)，2006年1月11日

#### 目录
1. 概述
2. 好处
3. 成本
4. 需求
5. 功能规范
6. 高级设计
7. 低级设计
8. 测试规范
9. 未来工作

#### 1. 概述
大多数传统的操作系统内核支持进程内的线程抽象，即多个执行上下文。这些内核提供了特殊资源和机制来维护这些“线程”。Linux 内核以一种巧妙而简单的方式，并不区分进程和“线程”。内核允许进程共享资源，因此它们可以在不需要内核中额外的数据结构和机制的情况下实现传统意义上的“线程”行为。这种实现线程的方式不仅因为其简洁性，还因为它允许应用程序程序员在传统线程的资源共享限制之外工作。在 Linux 中，当使用 `clone` 系统调用创建线程时，应用程序可以选择要在线程之间共享哪些资源。
`unshare()` 系统调用为 Linux 线程模型添加了一个原语，使线程能够选择性地“取消共享”它们创建时共享的任何资源。`unshare()` 是由 Al Viro 在 2000 年 8 月的 Linux-Kernel 邮件列表讨论中提出的，作为关于 Linux 上 POSIX 线程讨论的一部分。`unshare()` 增强了希望控制共享资源而不创建新进程的应用程序对 Linux 线程的实用性。`unshare()` 是 Linux 中实现进程/线程概念的一组可用原语中的自然补充。

#### 2. 好处
`unshare()` 对于大型应用框架（如 PAM）非常有用，在这些框架中，创建新进程来控制进程资源的共享/取消共享是不可能的。由于使用 `fork` 或 `clone` 创建新进程时默认会共享命名空间，因此即使对于非线程化应用程序，如果它们需要脱离默认共享的命名空间，`unshare()` 也能带来好处。以下列出了两个可以使用 `unshare()` 的用例：

##### 2.1 按安全上下文隔离的命名空间
`unshare()` 可以利用内核的每个进程命名空间机制来实现多实例目录。例如，每个用户或每个安全上下文的 `/tmp`、`/var/tmp` 或用户家目录的多实例化可以隔离用户进程在这些目录中的操作。使用 `unshare()`，PAM 模块可以在登录时轻松设置用户的私有命名空间。
多实例目录对于获得带有标签系统保护配置文件的通用标准认证是必需的。然而，随着 Linux 内核中共享树功能的可用性，即使是普通的 Linux 系统也可以从登录时设置私有命名空间并多实例化 `/tmp`、`/var/tmp` 和其他由系统管理员认为适当的目录中受益。

##### 2.2 取消共享虚拟内存和/或打开的文件
考虑一个客户端/服务器应用程序，其中服务器通过创建共享虚拟内存和打开文件等资源的进程来处理客户端请求。如果没有 `unshare()`，服务器必须在创建服务请求的进程时决定要共享什么。`unshare()` 允许服务器在处理请求期间取消部分上下文的关联。对于大型复杂的中间件应用框架，这种在进程创建后取消共享的能力非常有用。

#### 3. 成本
为了不重复代码并处理 `unshare()` 作用于活动任务（而 `clone` 和 `fork` 作用于新分配的非活动任务），`unshare()` 必须对 `clone` 和 `fork` 系统调用使用的 `copy_*` 函数进行一些小的重组。
修改现有的、经过充分测试且稳定的代码来实现一个可能一开始不会广泛使用的功能是有成本的。然而，通过适当的设计和代码审查以及为 LTP 创建 `unshare()` 测试，这个新功能的好处可以超过其成本。

#### 4. 需求
`unshare()` 反转了使用 `clone(2)` 系统调用完成的共享，因此 `unshare()` 应具有与 `clone(2)` 类似的接口。也就是说，既然 `clone(int flags, void *stack)` 中的标志指定了要共享的内容，那么 `unshare(int flags)` 中的类似标志应指定要取消共享的内容。不幸的是，这可能会使标志的意义与在 `clone(2)` 中使用时相反。
然而，并没有一个简单的解决方案既能减少混淆，又能在未来无需更改ABI的情况下实现增量上下文分离。`unshare()`接口应该能够适应未来可能新增的上下文标志，而无需重新编译旧应用程序。如果和何时新增了上下文标志，`unshare()`的设计应该允许按需逐步分离这些资源。

### 功能规范
---------------------------

**名称**
  unshare —— 分离进程执行上下文的部分内容

**概要**
  #include <sched.h>

  int unshare(int flags);

**描述**
  `unshare()`允许一个进程分离其当前与其他进程共享的部分执行上下文。默认情况下，当使用`fork(2)`创建新进程时，某些部分（如命名空间）是共享的，而其他部分（如虚拟内存、打开的文件描述符等）则是在使用`clone(2)`创建进程时根据明确请求进行共享的。
  
  `unshare()`的主要用途是允许进程控制其共享执行上下文，而无需创建新进程。
  
  `flags`参数指定了以下常量中的一个或多个（通过按位或运算组合）：
  
  **CLONE_FS**
    如果设置了`CLONE_FS`，则将调用者的文件系统信息从共享文件系统信息中分离出来。
    
  **CLONE_FILES**
    如果设置了`CLONE_FILES`，则将调用者的文件描述符表从共享文件描述符表中分离出来。
    
  **CLONE_NEWNS**
    如果设置了`CLONE_NEWNS`，则将调用者的命名空间从共享命名空间中分离出来。
    
  **CLONE_VM**
    如果设置了`CLONE_VM`，则将调用者的虚拟内存从共享虚拟内存中分离出来。
### 返回值
成功时返回0。失败时返回-1，并设置errno。

### 错误
- `EPERM`：指定了`CLONE_NEWNS`，但进程不是root用户（没有`CAP_SYS_ADMIN`权限）
- `ENOMEM`：无法分配足够的内存来复制需要分离的部分
- `EINVAL`：指定了无效的标志作为参数

### 遵循标准
`unshare()`调用是Linux特有的，在编写希望跨平台的程序时不应使用。

### 参见
`clone(2)`，`fork(2)`

### 6）高级设计
--------------------

根据`flags`参数，`unshare()`系统调用分配适当的进程上下文结构，填充当前共享版本中的值，将新复制的结构关联到当前的任务结构并释放相应的共享版本。`clone`的辅助函数（`copy_*`）不能直接被`unshare()`使用，原因如下：
1. `clone`操作于一个新分配但尚未激活的任务结构，而`unshare()`则操作于当前活跃的任务。因此，`unshare()`在关联新复制的上下文结构之前必须进行适当的`task_lock()`锁定。
2. `unshare()`必须在关联新的上下文结构和释放旧的共享结构之前分配并复制所有要分离的上下文结构。否则，在尝试回退时可能会产生竞争条件或错误。例如同时分离虚拟内存和命名空间，如果在成功分离虚拟内存后，分配新的命名空间结构时遇到错误，则错误返回码必须撤销虚拟内存的分离。作为撤销的一部分，系统调用必须回到旧的、共享的虚拟内存结构，而该结构可能已不存在。
因此，从`copy_*`函数中将分配和复制当前上下文结构的代码移动到了新的`dup_*`函数中。现在，`copy_*`函数调用`dup_*`函数来分配和复制适当的上下文结构，然后将其与正在构建的任务结构关联。另一方面，`unshare()`系统调用执行以下步骤：
1. 检查标志以强制缺少但隐含的标志。
2. 对于每个上下文结构，如果`flags`参数中设置了相应的位，则调用相应的`unshare()`辅助函数来分配和复制新的上下文结构。
3. 如果分配和复制没有错误并且有新的上下文结构，则锁定当前任务结构，将新的上下文结构与当前任务结构关联，并释放当前任务结构的锁。
4. 适当地释放旧的共享上下文结构。

### 7）低级设计
-------------------
`unshare()`的实现可以分为以下四个不同的部分：

a) 现有`copy_*`函数的重组

b) `unshare()`系统调用的服务函数

c) 每个不同进程上下文的`unshare()`辅助函数

d) 不同架构下的系统调用编号注册

#### 7.1) `copy_*`函数的重组
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
每个`copy_*`函数，如`copy_mm`、`copy_namespace`、`copy_files`等，大致有两个组件。第一个组件负责分配和复制相应的结构，第二个组件将它链接到作为参数传递给`copy`函数的任务结构。第一个组件被拆分成一个独立的函数。
### 7.2) unshare() 系统调用服务函数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   * 检查标志
     - 强制隐含的标志。如果设置了 CLONE_THREAD，则强制设置 CLONE_VM。
     - 如果设置了 CLONE_VM，则强制设置 CLONE_SIGHAND。
     - 如果设置了 CLONE_SIGHAND 并且信号也被共享，则强制设置 CLONE_THREAD。
     - 如果设置了 CLONE_NEWNS，则强制设置 CLONE_FS。

   * 对于每个上下文标志，使用传递给系统调用的标志和指向新未共享结构的指针引用，调用相应的 unshare_* 辅助例程。

   * 如果任何新的结构是由 unshare_* 辅助例程创建的，则获取当前任务的任务锁（task_lock），修改适当的上下文指针，并释放任务锁。

   * 对于所有新未共享的结构，释放对应的旧的、共享的结构。

### 7.3) unshare_* 辅助函数
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

对于与 CLONE_SYSVSEM、CLONE_SIGHAND 和 CLONE_THREAD 相关的 unshare_* 辅助函数，返回 -EINVAL，因为它们尚未实现。

对于其他情况，检查标志值以确定是否需要对该结构进行未共享操作。如果需要，则调用相应的 dup_* 函数来分配并复制该结构，并返回指向它的指针。

### 7.4) 最后
~~~~~~~~~~~~

适当修改架构特定代码以注册新的系统调用。

### 8) 测试规范
---------------------

unshare() 的测试应包括以下内容：

  1) 有效标志：测试以确保对于未实现未共享功能的信号和信号处理程序的克隆标志，返回 -EINVAL。

  2) 缺失/隐含标志：测试以确保在未指定文件系统未共享的情况下未共享命名空间时，正确地未共享命名空间和文件系统信息。
3) 对于支持的四种（命名空间、文件系统、文件和虚拟内存）unshare操作，验证系统调用是否正确地分离了相应的结构。验证分别单独以及组合使用这些选项时是否按预期工作。

4) 并发执行：使用共享内存段和shm段中的地址上的futex来同步大约10个线程的执行。让几个线程执行execve，几个线程执行_exit，其余线程以不同的标志组合进行unshare。验证unshare是否按预期执行，并且没有出现oops或挂起的情况。

9) 未来工作
--------------

当前的unshare()实现不允许分离信号和信号处理器。信号本身就已十分复杂，而分离当前运行进程的信号和/或信号处理器则更为复杂。如果将来有特定的需求允许分离信号和/或信号处理器，可以在不影响使用unshare()的传统应用程序的情况下逐步添加到unshare()中。
