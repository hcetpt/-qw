=============
Ioctl 编号
=============

1999 年 10 月 19 日

Michael Elizabeth Chastain
<mec@shout.net>

如果你正在向内核中添加新的 ioctl，你应该使用在 `<linux/ioctl.h>` 中定义的 `_IO` 宏：

    ====== == ============================================
    _IO    没有参数的 ioctl
    _IOW   具有写入参数的 ioctl（从用户空间复制数据到内核）
    _IOR   具有读取参数的 ioctl（从内核复制数据到用户空间）
    _IOWR  同时具有写入和读取参数的 ioctl
    ====== == ============================================

“写入”和“读取”是从用户的角度来看的，就像系统调用 `write` 和 `read` 一样。例如，一个 `SET_FOO` ioctl 将被标记为 `_IOW`，尽管内核实际上是从用户空间读取数据；一个 `GET_FOO` ioctl 将被标记为 `_IOR`，尽管内核实际上是将数据写入用户空间。

`_IO`, `_IOW`, `_IOR`, 或 `_IOWR` 的第一个参数是一个标识字母或数字，来自下表。由于驱动程序数量庞大，许多驱动程序与其他驱动程序共享部分字母。
如果你正在编写一个新的设备驱动程序并且需要一个字母，请选择一个足够扩展的空间：32 到 256 个 ioctl 命令。
你可以通过修补此文件并提交补丁给 Linus Torvalds 来注册这个块。或者你可以给我发邮件 <mec@shout.net>，我会为你注册一个。

`_IO`, `_IOW`, `_IOR`, 或 `_IOWR` 的第二个参数是一个序列号，用于区分不同的 ioctl。`_IOW`, `_IOR`, 或 `_IOWR` 的第三个参数是进入内核或从内核出来的数据类型（例如 `'int'` 或 `'struct foo'`）。注意！不要使用 `sizeof(arg)` 作为第三个参数，因为这样会导致你的 ioctl 认为它传递了一个类型为 `size_t` 的参数。

一些设备使用其主设备号作为标识符；这是可以的，只要它是唯一的。有些设备不遵循任何约定，而是特例处理。

遵循这个约定是有益的，因为：

1. 保持 ioctl 的全局唯一性有助于错误检查：如果一个程序在一个错误的设备上调用了 ioctl，它会得到一个错误，而不是某种意外的行为。
2. `strace` 构建过程会自动找到使用 `_IO`, `_IOW`, `_IOR`, 或 `_IOWR` 定义的 ioctl 号码。
3. 当号码是唯一的时，`strace` 可以将这些号码解码回有用的名称。
