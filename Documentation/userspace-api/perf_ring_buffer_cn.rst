SPDX 许可声明标识符: GPL-2.0

================
Perf 环形缓冲区
================

.. 目录

    1. 引言

    2. 环形缓冲区实现
    2.1 基本算法
    2.2 不同追踪模式下的环形缓冲区
    2.2.1 默认模式
    2.2.2 按线程模式
    2.2.3 按CPU模式
    2.2.4 系统范围模式
    2.3 访问缓冲区
    2.3.1 生产者-消费者模型
    2.3.2 环形缓冲区的属性
    2.3.3 向缓冲区写入样本
    2.3.4 从缓冲区读取样本
    2.3.5 内存同步

    3. AUX 环形缓冲区机制
    3.1 AUX 和普通环形缓冲区之间的关系
    3.2 AUX 事件
    3.3 快照模式


1. 引言
===============

环形缓冲区是一种基本的数据传输机制。`perf` 使用环形缓冲区将事件数据从内核传输到用户空间，另一种称为辅助（AUX）环形缓冲区也在硬件追踪（如 Intel PT、Arm CoreSight 等）中发挥重要作用。
环形缓冲区的实现至关重要，但这也是一项极具挑战性的工作。一方面，内核和用户空间中的 `perf` 工具使用环形缓冲区交换数据并将其存储到数据文件中，因此环形缓冲区需要以高吞吐量传输数据；另一方面，环形缓冲区管理应避免显著的负载干扰性能分析结果。
本文档深入探讨了 `perf` 环形缓冲区的细节，分为两部分：首先解释 `perf` 环形缓冲区的实现，然后讨论 AUX 环形缓冲区机制。

2. 环形缓冲区实现
=============================

2.1 基本算法
-------------------

一般来说，一个典型的环形缓冲区由一个头部指针和一个尾部指针管理；头部指针由写入者操作，尾部指针由读取者更新。
:: 

        +---------------------------+
        |   |   |***|***|***|   |   |
        +---------------------------+
                `-> 尾部    `-> 头部

        * : 被写入者填充的数据
图 1. 环形缓冲区

`perf` 使用相同的方式管理其环形缓冲区。在实现过程中，有两个关键的数据结构组合在一起，位于一组连续页面中：控制结构和环形缓冲区本身。包含控制结构的页面被称为“用户页面”。由于它们被保存在连续的虚拟地址中，这简化了定位环形缓冲区地址，它位于用户页面之后的页面中。
控制结构名为 `perf_event_mmap_page`，它包含一个头部指针 `data_head` 和一个尾部指针 `data_tail`。当内核开始将记录填充到环形缓冲区时，它会更新头部指针以预留内存，以便稍后可以安全地将事件存储到缓冲区中。另一方面，当用户页面是可写的映射时，`perf` 工具有权限在从环形缓冲区消费数据后更新尾部指针。另一种情况是用户页面的只读映射，将在 :ref:`writing_samples_into_buffer` 部分进行讨论。
:: 

          用户页面                          环形缓冲区
    +---------+---------+   +---------------------------------------+
    |data_head|data_tail|...|   |   |***|***|***|***|***|   |   |   |
    +---------+---------+   +---------------------------------------+
        `          `----------------^                   ^
         `----------------------------------------------|

              * : 被写入者填充的数据
图 2. `perf` 环形缓冲区

使用 `perf record` 工具时，我们可以使用选项 `-m` 或 `--mmap-pages=` 指定环形缓冲区大小，给定的大小将向上舍入为页大小的倍数的二的幂。虽然内核一次性分配所有内存页面，但它延迟到 `perf` 工具从用户空间访问缓冲区时才将页面映射到 VMA 区域。
换句话说，在 `perf` 工具首次从用户空间访问缓冲区页面时，会触发一个页面错误的数据异常，并且内核利用这个机会将页面映射到进程 VMA（参见 `perf_mmap_fault()`），从而使 `perf` 工具可以在返回异常后继续访问该页面。
2.2 不同追踪模式下的环形缓冲区
-------------------------------------------

`perf` 工具以不同的模式对程序进行剖析：默认模式、按线程模式、按 CPU 模式以及系统范围模式。本节描述了这些模式及其环形缓冲区如何满足它们的需求。最后，我们将回顾这些模式带来的竞态条件。

### 2.2.1 默认模式
^^^^^^^^^^^^^^^^^^^

通常我们执行 `perf record` 命令并后跟一个剖析程序的名称，如下所示：

```sh
perf record test_program
```

此命令没有指定任何关于 CPU 和线程模式的选项，因此 `perf` 工具会在 `perf` 事件上应用默认模式。它将系统中的所有 CPU 和被剖析程序的 PID 映射到该事件，并启用继承模式，使得子任务可以继承事件。结果是 `perf` 事件的属性如下：

```sh
evsel::cpus::map[]    = { 0 .. _SC_NPROCESSORS_ONLN-1 }
evsel::threads::map[] = { pid }
evsel::attr::inherit  = 1
```

这些属性最终会反映在环形缓冲区的部署上。如图所示，`perf` 工具为每个 CPU 分配单独的环形缓冲区，但仅启用被剖析程序的事件，而不是系统中所有线程的事件。*T1* 线程代表 `test_program` 的线程上下文，而 *T2* 和 *T3* 是系统中的无关线程。`perf` 样本只收集 *T1* 线程的数据，并存储在与 *T1* 线程运行所在的 CPU 相关联的环形缓冲区中。

```
              T1                      T2                 T1
            +----+              +-----------+          +----+
    CPU0    |xxxx|              |xxxxxxxxxxx|          |xxxx|
            +----+--------------+-----------+----------+----+-------->
              |                                          |
              v                                          v
            +-----------------------------------------------------+
            |                  Ring buffer 0                      |
            +-----------------------------------------------------+

                   T1
                 +-----+
    CPU1         |xxxxx|
            -----+-----+--------------------------------------------->
                    |
                    v
            +-----------------------------------------------------+
            |                  Ring buffer 1                      |
            +-----------------------------------------------------+

                                        T1              T3
                                      +----+        +-------+
    CPU2                              |xxxx|        |xxxxxxx|
            --------------------------+----+--------+-------+-------->
                                        |
                                        v
            +-----------------------------------------------------+
            |                  Ring buffer 2                      |
            +-----------------------------------------------------+

                              T1
                       +--------------+
    CPU3               |xxxxxxxxxxxxxx|
            -----------+--------------+------------------------------>
                              |
                              v
            +-----------------------------------------------------+
            |                  Ring buffer 3                      |
            +-----------------------------------------------------+

	T1: 线程 1; T2: 线程 2; T3: 线程 3
	x: 线程处于运行状态

	图 3. 默认模式下的环形缓冲区
```

### 2.2.2 按线程模式
^^^^^^^^^^^^^^^^^^^

通过在 `perf` 命令中指定 `--per-thread` 选项，例如：

```sh
perf record --per-thread test_program
```

`perf` 事件不映射到任何 CPU，而是仅绑定到被剖析的过程，因此 `perf` 事件的属性如下：

```sh
evsel::cpus::map[0]   = { -1 }
evsel::threads::map[] = { pid }
evsel::attr::inherit  = 0
```

在这种模式下，为被剖析的线程分配一个单一的环形缓冲区；如果该线程调度到某个 CPU 上，则该 CPU 上的事件会被启用；如果线程从该 CPU 调度出去，则该 CPU 上的事件会被禁用。当线程从一个 CPU 迁移到另一个 CPU 时，之前的 CPU 上的事件会被禁用，新的 CPU 上的事件会被启用。

```
              T1                      T2                 T1
            +----+              +-----------+          +----+
    CPU0    |xxxx|              |xxxxxxxxxxx|          |xxxx|
            +----+--------------+-----------+----------+----+-------->
              |                                           |
              |    T1                                     |
              |  +-----+                                  |
    CPU1      |  |xxxxx|                                  |
            --|--+-----+----------------------------------|---------->
              |     |                                     |
              |     |                   T1            T3  |
              |     |                 +----+        +---+ |
    CPU2      |     |                 |xxxx|        |xxx| |
            --|-----|-----------------+----+--------+---+-|---------->
              |     |                   |                 |
              |     |         T1        |                 |
              |     |  +--------------+ |                 |
    CPU3      |     |  |xxxxxxxxxxxxxx| |                 |
            --|-----|--+--------------+-|-----------------|---------->
              |     |         |         |                 |
              v     v         v         v                 v
            +-----------------------------------------------------+
            |                  Ring buffer                        |
            +-----------------------------------------------------+

	T1: 线程 1
	x: 线程处于运行状态

	图 4. 按线程模式下的环形缓冲区
```

当 `perf` 在按线程模式下运行时，会为被剖析线程 *T1* 分配一个环形缓冲区。该环形缓冲区专用于 *T1* 线程，如果 *T1* 线程正在运行，则 `perf` 事件会被记录到环形缓冲区中；当线程睡眠时，所有相关事件都会被禁用，因此不会有任何跟踪数据被记录到环形缓冲区中。

### 2.2.3 按 CPU 模式
^^^^^^^^^^^^^^^^^^^

使用 `-C` 选项来收集指定 CPU 列表上的样本，例如以下 `perf` 命令接收 `-C 0,2` 选项：

```sh
perf record -C 0,2 test_program
```

它将 `perf` 事件映射到 CPU 0 和 CPU 2，并且事件不关联任何 PID。因此 `perf` 事件的属性设置如下：

```sh
evsel::cpus::map[0]   = { 0, 2 }
evsel::threads::map[] = { -1 }
evsel::attr::inherit  = 0
```

这导致 `perf record` 会收集 CPU0 和 CPU2 上的所有线程的样本，并一直持续到 `test_program` 退出。即使有任务在 CPU1 和 CPU3 上运行，由于缺少对应的环形缓冲区，这两个 CPU 上的任何活动都会被忽略。一种用法是结合按线程模式和按 CPU 模式的选项，例如同时指定 `-C 0,2` 和 `--per-thread` 选项，只有当被剖析的线程调度到指定的 CPU 上时才会记录样本。

```
              T1                      T2                 T1
            +----+              +-----------+          +----+
    CPU0    |xxxx|              |xxxxxxxxxxx|          |xxxx|
            +----+--------------+-----------+----------+----+-------->
              |                       |                  |
              v                       v                  v
            +-----------------------------------------------------+
            |                  Ring buffer 0                      |
            +-----------------------------------------------------+

                   T1
                 +-----+
    CPU1         |xxxxx|
            -----+-----+--------------------------------------------->

                                        T1              T3
                                      +----+        +-------+
    CPU2                              |xxxx|        |xxxxxxx|
            --------------------------+----+--------+-------+-------->
                                        |               |
                                        v               v
            +-----------------------------------------------------+
            |                  Ring buffer 1                      |
            +-----------------------------------------------------+

                              T1
                       +--------------+
    CPU3               |xxxxxxxxxxxxxx|
            -----------+--------------+------------------------------>

	T1: 线程 1; T2: 线程 2; T3: 线程 3
	x: 线程处于运行状态

	图 5. 按 CPU 模式下的环形缓冲区
```

### 2.2.4 系统范围模式
^^^^^^^^^^^^^^^^^^^

使用 `-a` 或 `--all-cpus` 选项，`perf` 收集所有 CPU 上所有任务的样本，我们称之为系统范围模式，命令如下：

```sh
perf record -a test_program
```

类似于按 CPU 模式，`perf` 事件不绑定到任何 PID，并映射到系统中的所有 CPU：

```sh
evsel::cpus::map[]    = { 0 .. _SC_NPROCESSORS_ONLN-1 }
evsel::threads::map[] = { -1 }
evsel::attr::inherit  = 0
```

在系统范围模式下，每个 CPU 都有自己的环形缓冲区，在线程处于运行状态时对其进行监控，并将样本记录到发生事件的 CPU 所属的环形缓冲区中。

```
              T1                      T2                 T1
            +----+              +-----------+          +----+
    CPU0    |xxxx|              |xxxxxxxxxxx|          |xxxx|
            +----+--------------+-----------+----------+----+-------->
              |                       |                  |
              v                       v                  v
            +-----------------------------------------------------+
            |                  Ring buffer 0                      |
            +-----------------------------------------------------+

                   T1
                 +-----+
    CPU1         |xxxxx|
            -----+-----+--------------------------------------------->
                    |
                    v
            +-----------------------------------------------------+
            |                  Ring buffer 1                      |
            +-----------------------------------------------------+

                                        T1              T3
                                      +----+        +-------+
    CPU2                              |xxxx|        |xxxxxxx|
            --------------------------+----+--------+-------+-------->
                                        |               |
                                        v               v
            +-----------------------------------------------------+
            |                  Ring buffer 2                      |
            +-----------------------------------------------------+

                              T1
                       +--------------+
    CPU3               |xxxxxxxxxxxxxx|
            -----------+--------------+------------------------------>
                              |
                              v
            +-----------------------------------------------------+
            |                  Ring buffer 3                      |
            +-----------------------------------------------------+

	T1: 线程 1; T2: 线程 2; T3: 线程 3
	x: 线程处于运行状态

	图 6. 系统范围模式下的环形缓冲区
```

### 2.3 访问缓冲区
--------------------

基于对不同模式下环形缓冲区分配的理解，本节解释了如何访问环形缓冲区。

#### 2.3.1 生产者-消费者模型
^^^^^^^^^^^^^^^^^^^^^^^^^

在 Linux 内核中，PMU 事件会产生样本并将其存储到环形缓冲区中；用户空间中的 `perf` 命令通过读取环形缓冲区中的数据来消费这些样本，并最终将数据保存到文件中以供后期分析。这是一个典型的生产者-消费者模型。

`perf` 进程轮询 PMU 事件并在没有事件到来时休眠。为了防止内核和用户空间之间频繁交换数据，内核事件核心层引入了一个水印（watermark），存储在 `perf_buffer::watermark` 中。当样本记录到环形缓冲区时，如果使用的缓冲区超过水印，则内核会唤醒 `perf` 进程以从环形缓冲区中读取样本。
### 图7. 环形缓冲区的写入和读取

当内核事件核心层通知用户空间时，由于多个事件可能共享同一个环形缓冲区来记录样本，因此核心层会遍历与该环形缓冲区相关的每个事件，并唤醒等待在这些事件上的任务。这是通过内核函数`ring_buffer_wakeup()`实现的。

在`perf`进程被唤醒后，它开始逐个检查环形缓冲区。如果发现任何包含样本的环形缓冲区，它将读出这些样本进行统计或保存到数据文件中。由于`perf`进程可以在任何CPU上运行，这可能导致环形缓冲区同时被多个CPU访问，从而导致竞态条件。竞态条件的处理将在 :ref:`memory_synchronization` 部分描述。

#### 2.3.2 环形缓冲区的特性
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Linux 内核支持两种环形缓冲区的写入方向：前向和后向。前向写入从环形缓冲区的开头保存样本，后向写入则以相反的方向从环形缓冲区的末尾存储数据。`perf`工具确定写入方向。

此外，该工具可以将缓冲区以读写模式或只读模式映射到用户空间。
- 在读写模式下，环形缓冲区使用属性`PROT_READ | PROT_WRITE`进行映射。具有写权限时，`perf`工具更新`data_tail`以指示数据起始位置。结合指针`data_head`（作为当前数据的结束位置），`perf`工具可以轻松知道从哪里读取数据。
- 在只读模式下，只有内核会更新`data_head`，而用户空间由于映射属性`PROT_READ`无法访问`data_tail`。

因此，下面的矩阵展示了不同方向和映射特性的各种组合。`perf`工具使用其中的两种组合来支持两种缓冲区类型：不可覆盖缓冲区和可覆盖缓冲区。

.. list-table::
   :widths: 1 1 1
   :header-rows: 1

   * - 映射模式
     - 前向
     - 后向
   * - 读写
     - 不可覆盖环形缓冲区
     - 未使用
   * - 只读
     - 未使用
     - 可覆盖环形缓冲区

不可覆盖环形缓冲区使用前向写入的读写映射。它从环形缓冲区的开头开始保存数据，在溢出时循环返回，通常用于普通环形缓冲区的读写模式。当消费者跟不上生产者时，可能会丢失一些数据，内核会记录丢失了多少条记录，并在下次找到环形缓冲区中的空闲空间时生成`PERF_RECORD_LOST`记录。

可覆盖环形缓冲区使用后向写入的只读模式。它从环形缓冲区的末尾保存数据，`data_head`保持当前数据的位置，`perf`始终知道从哪里开始读取直到环形缓冲区的末尾，因此不需要`data_tail`。在这种模式下，不会生成`PERF_RECORD_LOST`记录。
.. _writing_samples_into_buffer:

2.3.3 将样本写入缓冲区
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

当一个样本被采集并保存到环形缓冲区时，内核会根据样本类型准备样本字段；然后它会准备用于写入环形缓冲区的信息，这些信息存储在结构 ``perf_output_handle`` 中。最后，内核将样本输出到环形缓冲区，并更新用户页中的头部指针，以便 perf 工具能够看到最新的值。
结构 ``perf_output_handle`` 作为临时上下文来跟踪与缓冲区相关的信息。它的优点是允许不同事件并发地向缓冲区写入数据。例如，软件事件和硬件 PMU 事件都启用以进行性能分析时，两个实例的 ``perf_output_handle`` 分别作为软件事件和硬件事件的独立上下文。这使得每个事件可以为其记录数据预留自己的内存空间。

2.3.4 从缓冲区读取样本
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在用户空间中，perf 工具使用 ``perf_event_mmap_page`` 结构来处理缓冲区的头部和尾部。它还使用 ``perf_mmap`` 结构来维护环形缓冲区的上下文，这个上下文包括缓冲区的起始和结束地址信息。此外，掩码值可用于计算即使发生溢出情况下的环形缓冲区指针。
类似于内核，用户空间中的 perf 工具首先从环形缓冲区读取记录的数据，然后更新缓冲区的尾部指针 ``perf_event_mmap_page::data_tail``。

.. _memory_synchronization:

2.3.5 内存同步
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

现代具有宽松内存模型的 CPU 无法保证内存顺序，这意味着访问环形缓冲区和 ``perf_event_mmap_page`` 结构可能会出现乱序。为了确保访问 perf 环形缓冲区时的特定顺序，使用内存屏障来保证数据依赖关系。内存同步的原理如下所示：

```
内核                          用户空间

if (LOAD ->data_tail) {         LOAD ->data_head
                   (A)            smp_rmb()        (C)
    STORE $data                   LOAD $data
    smp_wmb()      (B)            smp_mb()         (D)
    STORE ->data_head             STORE ->data_tail
  }
```

`tools/include/linux/ring_buffer.h` 中的注释很好地描述了为什么以及如何使用内存屏障，这里提供一种替代解释：

- (A) 是一个控制依赖关系，使 CPU 确保检查指针 ``perf_event_mmap_page::data_tail`` 和将样本填充到环形缓冲区之间的顺序；
- (D) 与 (A) 配对。 (D) 将读取环形缓冲区数据与写入指针 ``data_tail`` 分开，perf 工具先消费样本，然后再告诉内核数据块已被释放。由于读取操作后跟写入操作，因此 (D) 是一个完整的内存屏障；
- (B) 是两个写入操作之间的写入屏障，确保记录样本必须先于更新头部指针；
- (C) 与 (B) 配对。 (C) 是读取内存屏障，以确保在读取样本之前获取头部指针。

为了实现上述算法，内核中的 ``perf_output_put_handle()`` 函数和用户空间中的两个辅助函数 ``ring_buffer_read_head()`` 和 ``ring_buffer_write_tail()`` 被引入，它们依赖于上面描述的内存屏障来确保数据依赖性。
一些架构支持单向渗透屏障（one-way permeable barrier），具有 load-acquire 和 store-release 操作，这些屏障较为宽松，性能损失较小。因此，(C) 和 (D) 可以优化为使用 `smp_load_acquire()` 和 `smp_store_release()` 这两个屏障。如果某个架构在其内存模型中不支持 load-acquire 和 store-release，则会退回到传统的内存屏障操作。在这种情况下，`smp_load_acquire()` 封装了 `READ_ONCE()` + `smp_mb()`，由于 `smp_mb()` 的开销较大，`ring_buffer_read_head()` 不调用 `smp_load_acquire()` 而是使用 `READ_ONCE()` + `smp_rmb()` 这些屏障。

3. AUX 环形缓冲区的机制
======================

在本章中，我们将解释 AUX 环形缓冲区的实现。第一部分将讨论 AUX 环形缓冲区与普通环形缓冲区之间的联系；第二部分将探讨 AUX 环形缓冲区如何与普通环形缓冲区协同工作，以及 AUX 环形缓冲区为采样机制引入的额外功能。

3.1 AUX 与普通环形缓冲区的关系
---------------------------------

通常而言，AUX 环形缓冲区是普通环形缓冲区的辅助部分。普通环形缓冲区主要用于存储事件样本，每个事件格式都遵循 `perf_event` 联合体中的定义；而 AUX 环形缓冲区用于记录硬件跟踪数据，跟踪数据格式取决于硬件 IP。

AUX 环形缓冲区的一般用途和优点在于它是由硬件直接写入的，而不是由内核写入的。例如，普通配置文件样本写入普通环形缓冲区时会触发中断。跟踪执行需要大量的样本，使用中断会对普通环形缓冲区机制造成巨大负担。拥有 AUX 缓冲区可以提供一个更独立于内核的内存区域，并且由硬件直接写入。

AUX 环形缓冲区复用了普通环形缓冲区的缓冲区管理算法。控制结构 `perf_event_mmap_page` 扩展了新的字段 `aux_head` 和 `aux_tail`，分别作为 AUX 环形缓冲区的头指针和尾指针。

在初始化阶段，除了通过 mmap 映射的普通环形缓冲区外，perf 工具还会在 `auxtrace_mmap__mmap()` 函数中调用第二个系统调用来映射 AUX 缓冲区，并带有非零文件偏移量。内核中的 `rb_alloc_aux()` 分配相应的页面，这些页面将在处理页错误时延迟映射到 VMA，这与普通环形缓冲区的懒惰机制相同。

AUX 事件和 AUX 跟踪数据是两回事。让我们看一个例子：

```sh
perf record -a -e cycles -e cs_etm/@tmc_etr0/ -- sleep 2
```

上述命令启用了两个事件：一个是来自 PMU 的 *cycles* 事件，另一个是来自 Arm CoreSight 的 AUX 事件 *cs_etm*。这两个事件都会保存到普通环形缓冲区中，而 CoreSight 的 AUX 跟踪数据则存储在 AUX 环形缓冲区中。

因此，我们可以看到普通环形缓冲区和 AUX 环形缓冲区是成对分配的。默认模式下，perf 为每个 CPU 分配一个普通环形缓冲区和一个 AUX 环形缓冲区，这与系统范围模式相同。但是，默认模式仅记录被剖析程序的样本，而后者模式记录系统中所有程序的样本。对于每线程模式，perf 工具为整个会话分配一个普通环形缓冲区和一个 AUX 环形缓冲区。对于每 CPU 模式，perf 为由选项 `-C` 指定的选定 CPU 分配两种类型的环形缓冲区。

下面的图示展示了系统范围模式下的缓冲区布局；如果有任何活动在一个 CPU 上发生，AUX 事件样本和硬件跟踪数据将被记录到该 CPU 专用的缓冲区中。
### 图8. 系统范围模式下的AUX环形缓冲区

T1: 线程1；T2: 线程2；T3: 线程3
x: 线程处于运行状态

```
              T1                      T2                 T1
            +----+              +-----------+          +----+
    CPU0    |xxxx|              |xxxxxxxxxxx|          |xxxx|
            +----+--------------+-----------+----------+----+-------->
              |                       |                  |
              v                       v                  v
            +-----------------------------------------------------+
            |                  Ring buffer 0                      |
            +-----------------------------------------------------+
              |                       |                  |
              v                       v                  v
            +-----------------------------------------------------+
            |               AUX Ring buffer 0                     |
            +-----------------------------------------------------+

                   T1
                 +-----+
    CPU1         |xxxxx|
            -----+-----+--------------------------------------------->
                    |
                    v
            +-----------------------------------------------------+
            |                  Ring buffer 1                      |
            +-----------------------------------------------------+
                    |
                    v
            +-----------------------------------------------------+
            |               AUX Ring buffer 1                     |
            +-----------------------------------------------------+

                                        T1              T3
                                      +----+        +-------+
    CPU2                              |xxxx|        |xxxxxxx|
            --------------------------+----+--------+-------+-------->
                                        |               |
                                        v               v
            +-----------------------------------------------------+
            |                  Ring buffer 2                      |
            +-----------------------------------------------------+
                                        |               |
                                        v               v
            +-----------------------------------------------------+
            |               AUX Ring buffer 2                     |
            +-----------------------------------------------------+

                              T1
                       +--------------+
    CPU3               |xxxxxxxxxxxxxx|
            -----------+--------------+------------------------------>
                              |
                              v
            +-----------------------------------------------------+
            |                  Ring buffer 3                      |
            +-----------------------------------------------------+
                              |
                              v
            +-----------------------------------------------------+
            |               AUX Ring buffer 3                     |
            +-----------------------------------------------------+
```

### 3.2 AUX事件

与普通环形缓冲区中 `perf_output_begin()` 和 `perf_output_end()` 的工作方式类似，`perf_aux_output_begin()` 和 `perf_aux_output_end()` 用于处理硬件跟踪数据的AUX环形缓冲区。一旦硬件跟踪数据存储到AUX环形缓冲区中，PMU驱动程序将通过调用 `pmu::stop()` 回调停止硬件跟踪。类似于普通环形缓冲区，AUX环形缓冲区也需要应用在 :ref:`memory_synchronization` 节中讨论的内存同步机制。由于AUX环形缓冲区由PMU驱动程序管理，因此需要在PMU驱动程序中实现屏障（B），这是一个写屏障，确保跟踪数据在更新头指针之前对外部可见。然后 `pmu::stop()` 可以安全地调用 `perf_aux_output_end()` 函数来完成以下两件事情：

- 它会在普通环形缓冲区中填充一个 `PERF_RECORD_AUX` 事件，该事件传递了一段已存储到AUX环形缓冲区中的硬件跟踪数据的起始地址和数据大小信息；
- 由于硬件跟踪驱动程序已将新的跟踪数据存储到AUX环形缓冲区中，参数 *size* 表示硬件跟踪消耗了多少字节，因此 `perf_aux_output_end()` 更新头指针 `perf_buffer::aux_head` 来反映最新的缓冲区使用情况。最后，PMU驱动程序将重新启动硬件跟踪。在这短暂的暂停期间，它会丢失硬件跟踪数据，这将在解码阶段引入不连续性。

`PERF_RECORD_AUX` 事件表示一个在内核中处理的AUX事件，但它缺乏保存AUX跟踪数据到perf文件的信息。当perf工具从AUX环形缓冲区复制跟踪数据到perf数据文件时，它会合成一个 `PERF_RECORD_AUXTRACE` 事件，这不是内核ABI，而是由perf工具定义的，用于描述AUX环形缓冲区中的哪部分数据被保存。之后，perf工具根据 `PERF_RECORD_AUXTRACE` 事件从perf文件中读取AUX跟踪数据，并使用 `PERF_RECORD_AUX` 事件按时间顺序解码一段数据。

### 3.3 快照模式

perf支持AUX环形缓冲区的快照模式，在这种模式下，用户仅在特定的时间点记录AUX跟踪数据，这些时间点是用户感兴趣的。例如，下面是一个如何以1秒间隔使用Arm CoreSight进行快照的例子：

```sh
perf record -e cs_etm/@tmc_etr0/u -S -a program &
PERFPID=$!
while true; do
    kill -USR2 $PERFPID
    sleep 1
done
```

快照模式的主要流程如下：

- 在拍摄快照之前，AUX环形缓冲区处于自由运行模式。在此模式下，perf不会记录任何AUX事件和跟踪数据；
- 一旦perf工具接收到 *USR2* 信号，它将触发回调函数 `auxtrace_record::snapshot_start()` 来停用硬件跟踪。然后内核驱动程序将硬件跟踪数据填充到AUX环形缓冲区，并将 `PERF_RECORD_AUX` 事件存储在普通环形缓冲区中；
- 然后perf工具拍摄快照，`record__read_auxtrace_snapshot()` 从AUX环形缓冲区中读取硬件跟踪数据并将其保存到perf数据文件中；
- 快照完成后，`auxtrace_record::snapshot_finish()` 重启PMU事件以继续AUX跟踪。
perf在快照模式下只访问头指针 `perf_event_mmap_page::aux_head` 并且不触碰尾指针 `aux_tail`，这是因为AUX环形缓冲区可以在自由运行模式下溢出，此时尾指针无用。此外，引入了回调 `auxtrace_record::find_snapshot()` 以决定AUX环形缓冲区是否已被绕回，并最终修复用于计算跟踪数据大小的AUX缓冲区的头部。

我们知道，缓冲区可以部署为每线程模式、每CPU模式或系统范围模式，快照可以应用于这些模式中的任何一种。以下是系统范围模式下拍摄快照的一个例子。
当然，以下是翻译：

```
快照已获取
       |
       v
+------------------------+
|  AUX 环形缓冲区 0     | <- aux_head
+------------------------+
       v
+--------------------------------+
|          AUX 环形缓冲区 1     | <- aux_head
+--------------------------------+
       v
+--------------------------------------------+
|                      AUX 环形缓冲区 2     | <- aux_head
+--------------------------------------------+
       v
+---------------------------------------+
|                 AUX 环形缓冲区 3     | <- aux_head
+---------------------------------------+

图 9. 全系统模式下的快照
```
