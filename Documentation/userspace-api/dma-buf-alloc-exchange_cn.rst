SPDX 许可声明标识符: GPL-2.0  
版权 2021-2023 Collabora Ltd  
========================  
交换像素缓冲区  
========================  

最初设计时，Linux 图形子系统在进程、设备和子系统之间共享像素缓冲区分配的支持极为有限。现代系统需要在这三个类别之间进行广泛的集成；本文档详细说明了应用程序和内核子系统应如何处理二维图像数据的这种共享。本文档参考了GPU和显示设备的DRM子系统、媒体设备的V4L2以及用户空间支持中的Vulkan、EGL和Wayland，但其他任何子系统也应遵循此设计和建议。  
术语表  
==================  

.. 术语表::  

    image:  
      概念上是一个二维像素数组。这些像素可以存储在一个或多个内存缓冲区中。具有以像素为单位的宽度和高度、像素格式和修饰符（隐式或显式）。  
    row:  
      在单个y轴值上的跨度，例如从坐标(0,100)到(200,100)。  
    scanline:  
      行的同义词。  
    column:  
      在单个x轴值上的跨度，例如从坐标(100,0)到(100,100)。  
    memory buffer:  
      用于存储（部分）像素数据的一段内存。具有以字节为单位的步长和大小，并且在某个API中至少有一个句柄。可能包含一个或多个平面。  
    plane:  
      包含图像的部分或全部颜色通道和alpha通道值的二维数组。  
    pixel:  
      一个图像元素。具有一个由一个或多个颜色通道值定义的颜色值，例如R、G和B或Y、Cb和Cr。还可能具有作为额外通道的alpha值。
像素数据：
      表示像素或图像的部分或全部颜色/Alpha通道值的字节或位。根据格式和修饰符，一个像素的数据可能会分布在多个平面或内存缓冲区中。
颜色值：
      一组数字，表示一种颜色。该组中的每个元素都是一个颜色通道值。
颜色通道：
      颜色模型中的一个维度。例如，RGB模型有R、G和B三个通道。有时也将Alpha通道视为颜色通道之一。
像素格式：
      描述像素数据如何表示像素的颜色和Alpha值。
修饰符：
      描述像素数据在内存缓冲区中的布局方式。
Alpha：
      表示像素中颜色覆盖度的一个值。有时也用于表示透明度。
步幅（Stride）：
      表示像素位置坐标与字节偏移量之间关系的一个值。通常用于作为垂直连续的瓷砖块开始处两个像素之间的字节偏移量。对于线性布局，表示两个垂直相邻像素之间的字节偏移量。对于非线性格式，步幅必须以一致的方式计算，通常是假设布局为线性的来进行计算。
Pitch：
      步幅的同义词。

格式和修饰符
=============
每个缓冲区必须有一个底层格式。这个格式描述了每个像素提供的颜色值。尽管每个子系统都有自己的格式描述（例如V4L2和fbdev），但应尽可能复用“DRM_FORMAT_*”标记，因为它们是用于交换的标准描述。这些标记在“drm_fourcc.h”文件中进行了描述，该文件是DRM的uAPI的一部分。
每个 ``DRM_FORMAT_*`` 标记描述了图像中的像素坐标与其内存缓冲区中包含的颜色值之间的转换。这些标记描述了颜色通道的数量和类型：它们是RGB还是YUV，整数还是浮点数，每个通道的大小及其在像素内存中的位置，以及颜色平面之间的关系。

例如，``DRM_FORMAT_ARGB8888`` 描述了一种格式，其中每个像素在内存中有一个32位的值。Alpha、红色、绿色和蓝色颜色通道分别以每通道8位的精度存在，并且按照小端存储方式从最高有效位到最低有效位进行排序。``DRM_FORMAT_*`` 不受CPU或设备字节序的影响；内存中的字节模式始终如格式定义中所述，通常是小端字节序。

作为一个更复杂的例子，``DRM_FORMAT_NV12`` 描述了一种格式，在这种格式中亮度（luma）和色度（chroma）的YUV样本分别存储在不同的平面上，其中色度平面以两个维度的一半分辨率存储（即每个2x2像素组存储一个U/V色度样本）。

格式修饰符描述了每个像素内存样本与实际内存存储之间的转换机制。最简单的修饰符是 ``DRM_FORMAT_MOD_LINEAR``，它描述了一个方案，其中每个平面按行顺序排列，从左上角到右下角。

这被认为是基准交换格式，对CPU访问最为方便。

现代硬件使用更复杂的访问机制，通常利用分块访问和压缩。例如，``DRM_FORMAT_MOD_VIVANTE_TILED`` 修饰符描述了一种内存存储方式，其中像素以4x4块的形式按行主序排列存储，即一个平面上的第一个块存储(0,0)到(3,3)的像素，第二个块存储(4,0)到(7,3)的像素。

一些修饰符可能会改变图像所需的平面数量；例如，``I915_FORMAT_MOD_Y_TILED_CCS`` 修饰符为RGB格式添加了一个额外的平面，用于存储每个块的状态数据，包括该块是否完全填充了像素数据，或者可以从单个纯色扩展。

这些扩展布局高度依赖于供应商，并且对于每个供应商的不同代际或配置也是特定的。因此，为了确保兼容性和最优的处理管道，所有用户必须明确枚举并协商支持的修饰符，如下文所述。

尺寸和大小
==========

每个像素缓冲区必须伴随有逻辑像素尺寸。这指的是可以从底层内存存储中提取或存储的独特样本数量。例如，即使一个1920x1080的 ``DRM_FORMAT_NV12`` 缓冲区具有包含1920x1080样本的亮度平面和960x540样本的U和V组件，整个缓冲区仍然被描述为具有1920x1080的尺寸。

缓冲区在内存中的存储并不保证立即从底层内存的基本地址开始，也不保证内存存储紧密裁剪到任一维度。
每个平面必须用一个“偏移量”（以字节为单位）来描述，该偏移量将在执行任何逐像素计算之前加上内存存储的基本地址。这可以用来将多个平面组合到单个内存缓冲区中；例如，“DRM_FORMAT_NV12”可以存储在一个单独的内存缓冲区中，其中亮度平面的存储从缓冲区开始处立即开始，偏移量为0，并且色度平面的存储在同一缓冲区内从该平面的字节偏移量开始。

每个平面还必须有一个“步幅”（以字节为单位），表示两个连续行之间的内存偏移量。例如，一个尺寸为1000x1000的“DRM_FORMAT_MOD_LINEAR”缓冲区可能被分配为1024x1000，以便允许对齐访问模式。在这种情况下，缓冲区仍将被描述为宽度为1000，但是步幅将是“1024 * bpp”，表明在x轴正极端有24个像素值不重要。

缓冲区也可以在y方向上进一步填充，只需分配比通常所需的更大的区域即可。例如，许多媒体解码器无法原生输出高度为1080的缓冲区，而是需要有效高度为1088像素。在这种情况下，缓冲区继续被描述为高度为1080，但每个缓冲区的内存分配会增加以考虑额外的填充。

枚举
====

每个像素缓冲区的用户都必须能够枚举一组支持的格式和修饰符，这些格式和修饰符一起描述。在KMS中，这是通过每个DRM平面的“IN_FORMATS”属性实现的，列出支持的DRM格式及其每个格式支持的修饰符。在用户空间中，这是通过EGL的`EGL_EXT_image_dma_buf_import_modifiers`_扩展入口、Vulkan的`VK_EXT_image_drm_format_modifier`_扩展以及Wayland的`zwp_linux_dmabuf_v1`_扩展来支持的。

所有这些接口都允许用户查询一组支持的格式+修饰符组合。

协商
====

用户空间负责为其使用情况协商一个可接受的格式+修饰符组合。这是通过简单的列表交集完成的。例如，如果用户希望使用Vulkan渲染一个图像并在KMS平面上显示，则必须：

- 查询KMS以获取给定平面的“IN_FORMATS”属性。
- 查询Vulkan以获取其物理设备支持的格式，确保传递与预期渲染用途对应的“VkImageUsageFlagBits”和“VkImageCreateFlagBits”。
- 交集这些格式以确定最合适的格式。
- 对于此格式，交集KMS和Vulkan支持的修饰符列表，以获得该格式最终可接受的修饰符列表。

这种交集必须针对所有使用情况进行。例如，如果用户还希望将图像编码为视频流，则必须查询其打算用于编码的媒体API支持的一组修饰符，并进一步与此列表进行交集。

如果所有列表的交集为空，则无法以这种方式共享缓冲区，必须考虑其他策略（例如，使用CPU访问例程在不同用途之间复制数据，伴随相应的性能开销）。

结果的修饰符列表是未排序的；顺序并不重要。

分配
====

一旦用户空间确定了一个合适的格式及其相应的可接受修饰符列表，它必须分配缓冲区。由于内核或用户空间层面没有通用的缓冲区分配接口，客户端必须任意选择一个分配接口，如Vulkan、GBM或一个媒体API。

每次分配请求至少需要：像素格式、可接受的修饰符列表以及缓冲区的宽度和高度。每个API可能会以不同的方式扩展这一属性集，例如允许多于两维的分配、预期的使用模式等。
组件在分配缓冲区时会根据请求的分配、所需的填充以及底层内存缓冲区的其他属性（例如它们是否存储在系统或设备特定的内存中，它们是否物理上连续，以及它们的缓存模式）从可接受的列表中任意选择其认为“最佳”的修饰符。然而，这些内存缓冲区的属性对用户空间是不可见的。`dma-heaps` API 是为了解决这一问题所做的努力。

分配后，客户端必须查询分配器以确定实际选择的缓冲区修饰符，以及每平面的偏移量和步幅。分配器不允许更改正在使用的格式，不允许选择可接受列表之外的修饰符，也不允许更改像素尺寸，除非通过偏移量、步幅和大小表达的填充。

传递额外的约束（如步幅或偏移量的对齐，放置在特定内存区域等）超出了 `dma-buf` 的范围，并且不能通过格式和修饰符令牌来解决。

### 导入

为了在不同的上下文、设备或子系统中使用缓冲区，用户将这些参数（格式、修饰符、宽度、高度以及每平面的偏移量和步幅）传递给导入 API。每个内存缓冲区由一个缓冲区句柄引用，该句柄可能在图像内是唯一的或重复的。例如，`DRM_FORMAT_NV12` 缓冲区可以通过每平面的偏移量参数将亮度和色度缓冲区合并到单个内存缓冲区中，或者它们可以在内存中完全独立地分配。因此，每个导入和分配 API 必须为每个平面提供单独的句柄。

每个内核子系统都有自己的缓冲区管理类型和接口。DRM 使用 GEM 缓冲区对象（BO），V4L2 有它自己的引用等。这些类型在不同上下文、进程、设备或子系统之间不可移植。

为了解决这个问题，`dma-buf` 句柄用作缓冲区的通用交换形式。子系统的特定操作用于将本地缓冲区句柄导出为 `dma-buf` 文件描述符，并将这些文件描述符导入为本地缓冲区句柄。`dma-buf` 文件描述符可以在不同上下文、进程、设备和子系统之间传输。
例如，Wayland 媒体播放器可能使用 V4L2 解码视频帧到一个 `DRM_FORMAT_NV12` 缓冲区。这将导致两个内存平面（亮度和色度）由用户从 V4L2 中取出。然后这些平面被导出为每个平面一个 dma-buf 文件描述符，这些描述符连同元数据（格式、修饰符、宽度、高度、每平面的偏移量和步长）发送给 Wayland 服务器。Wayland 服务器随后会将这些文件描述符导入为通过 EGL/OpenGL（ES）、Vulkan 或 KMS 帧缓冲对象使用的 EGLImage 或 VkImage；每次导入操作都会采用相同的元数据，并将 dma-buf 文件描述符转换为其本机缓冲句柄。

支持的修饰符之间有非空交集并不保证能够成功导入所有消费者；它们可能有超出修饰符所暗示的约束条件需要满足。

隐式修饰符
===========

修饰符的概念晚于上述所有子系统出现。因此，它已经被反向集成到所有这些 API 中，并为了确保向后兼容性，需要支持不（还）支持修饰符的驱动程序和用户空间。

作为一个例子，GBM 用于分配要在 EGL 渲染和 KMS 显示之间共享的缓冲区。它有两个分配缓冲区的入口点：`gbm_bo_create` 只接受格式、宽度、高度和一个用途令牌，而 `gbm_bo_create_with_modifiers` 扩展了这一功能，可以提供修饰符列表。

在后一种情况下，分配如上所述，提供了一组可接受的修饰符供实现选择（如果无法在这些约束条件下分配则失败）。而在前一种没有提供修饰符的情况下，GBM 实现必须自行决定什么是“最佳”的布局。这种选择完全取决于实现：有些实现可能会根据其认为合适的任何启发式方法内部使用不可 CPU 访问的平铺布局。实现的责任是确保这一选择是适当的。

为了支持这种布局未知的情况（因为没有意识到修饰符的存在），定义了一个特殊的 `DRM_FORMAT_MOD_INVALID` 标记。这个伪修饰符声明布局未知，并且驱动程序应该使用自己的逻辑来确定底层布局是什么。

.. note:: 

  `DRM_FORMAT_MOD_INVALID` 是一个非零值。修饰符值为零的是 `DRM_FORMAT_MOD_LINEAR`，这是显式的保证图像具有线性布局。需要注意确保零作为默认值不会与没有修饰符或线性修饰符混淆。此外，在某些 API 中，无效修饰符值是通过带外标志指定的，例如在 `DRM_IOCTL_MODE_ADDFB2` 中。

此标记可以在以下四种情况中使用：
  - 在枚举过程中，接口可能会返回 `DRM_FORMAT_MOD_INVALID`，要么作为修饰符列表中的唯一成员，以声明不支持显式修饰符，要么作为更大列表的一部分，以声明可以使用隐式修饰符；
  - 在分配过程中，用户可以提供 `DRM_FORMAT_MOD_INVALID`，要么作为修饰符列表中的唯一成员（等同于根本不提供修饰符列表），以声明不支持显式修饰符且不应使用，要么作为更大列表的一部分，以声明可以接受使用隐式修饰符进行分配；
  - 在分配后的查询中，实现可能会返回 `DRM_FORMAT_MOD_INVALID` 作为已分配缓冲区的修饰符，以声明底层布局是由实现定义的，并且没有显式修饰符描述；根据上述规则，只有当用户包含 `DRM_FORMAT_MOD_INVALID` 作为可接受修饰符列表的一部分，或者没有提供列表时，才能返回；
  - 在导入缓冲区时，用户可以提供 `DRM_FORMAT_MOD_INVALID` 作为缓冲区修饰符（或不提供修饰符），以指示由于某种原因修饰符未知；这仅在缓冲区未用显式修饰符分配时才可接受。

由此得出结论，对于任何单个缓冲区，由生产者和所有消费者形成的完整操作链必须完全是隐式的或完全是显式的。例如，如果用户希望为 GPU、显示和媒体分配一个缓冲区，但媒体 API 不支持修饰符，则用户 **不得** 使用显式修饰符分配缓冲区，并尝试在没有任何修饰符的情况下将缓冲区导入媒体 API，而是应使用隐式修饰符进行分配，或单独为媒体使用分配缓冲区并在这两个缓冲区之间复制内容。

作为例外，分配可以从隐式修饰符“升级”到显式修饰符。例如，如果使用 `gbm_bo_create`（不接受修饰符）分配缓冲区，用户可以通过 `gbm_bo_get_modifier` 查询修饰符，如果返回有效修饰符，则可以将其用作显式修饰符标记。

当为不同用户之间交换分配缓冲区且没有可用修饰符时，强烈建议实现使用 `DRM_FORMAT_MOD_LINEAR` 进行分配，因为这是交换的通用基线。然而，不能保证这会导致正确解释缓冲区内容，因为隐式修饰符操作仍可能受驱动程序特定的启发式方法影响。
任何希望交换缓冲区的新用户——包括用户空间程序和协议、内核子系统等——必须通过 `dma-buf` 文件描述符提供内存平面的互操作性，使用 DRM 格式令牌来描述格式，使用 DRM 格式修饰符来描述内存布局，并至少提供宽度和高度作为尺寸信息，以及每个内存平面的偏移量和步幅。

.. _zwp_linux_dmabuf_v1: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml
.. _VK_EXT_image_drm_format_modifier: https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_drm_format_modifier.html
.. _EGL_EXT_image_dma_buf_import_modifiers: https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt
