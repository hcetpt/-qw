SPDX 许可证标识符: GPL-2.0

=============
多代 LRU
=============

多代 LRU 是一种替代的 LRU 实现，优化了页面回收并在内存压力下提高了性能。页面回收决定了内核的缓存策略和过度分配内存的能力。它直接影响了 kswapd 的 CPU 使用率和 RAM 效率。

设计概述
===============

目标
----------
设计目标包括：

* 良好的访问最近性表示
* 尝试从空间局部性中获益
* 快速路径以做出显而易见的选择
* 简单的自我纠正启发式方法

访问最近性的表示是所有 LRU 实现的核心。在多代 LRU 中，每一代代表一组具有相似访问最近性的页面。各代建立了一个（基于时间的）共同参考框架，从而有助于做出更好的选择，例如，在一台计算机上的不同 memcg 之间或数据中心内的不同计算机之间（用于作业调度）。

利用空间局部性提高了收集访问位时的效率。rmap 遍历针对单个页面，并不试图从发现年轻的页表项（PTE）中获益。页表遍历可以扫描地址空间中的所有年轻 PTE，但地址空间可能过于稀疏而无法从中获益。关键是优化这两种方法并结合使用它们。

快速路径减少了代码复杂性和运行时开销。未映射的页面不需要 TLB 刷新；干净的页面不需要回写。这些事实只有在其他条件（如访问最近性）相似时才有帮助。有了各代作为共同的参考框架，其他因素就更加突出。但是显而易见的选择未必是最好的选择，因此需要自我纠正。

简单自我纠正启发式方法的好处是显而易见的。再次，有了各代作为共同的参考框架，这变得可行。具体来说，同一代中的页面可以根据其他因素进行分类，反馈循环可以统计比较这些类别之间的重故障百分比，并推断哪些类别是更好的选择。

假设
-----------
热页面的保护和冷页面的选择基于页面访问渠道和模式。有两个访问渠道：

* 通过页表访问
* 通过文件描述符访问

前者渠道的设计保护更强，原因如下：

1. 前者渠道的访问模式确定的不确定性更高，因为访问位的近似值存在误差。
2. 前者渠道的驱逐成本更高，因为需要 TLB 刷新且有可能遇到脏位。
3. 对前者渠道保护不足的代价更高，因为应用程序通常不会像处理阻塞 I/O 那样为重大页故障做准备。例如，GUI 应用程序通常使用专用的 I/O 线程来避免阻塞渲染线程。
访问模式也有两种：

* 展现时间局部性的访问
* 不展现时间局部性的访问

基于上述原因，除非存在 ``VM_SEQ_READ`` 或 ``VM_RAND_READ``，否则假定前者通道遵循前者模式；除非观察到异常的重新故障（refault），否则假定后者通道遵循后者模式。

工作流程概述
=============
可驱逐页面被划分为多个代，每个 ``lruvec`` 都如此。最年轻的代号存储在 ``lrugen->max_seq`` 中，适用于匿名和文件类型，因为它们以相同的方式老化。最老的代号分别存储在 ``lrugen->min_seq[]`` 中，针对匿名和文件类型，因为干净的文件页面可以不受交换限制地被驱逐。这三个变量是单调递增的。

为了适应 ``folio->flags`` 中的代计数器，代号被截断为 ``order_base_2(MAX_NR_GENS+1)`` 位。每个截断后的代号是 ``lrugen->folios[]`` 的索引。滑动窗口技术用于跟踪至少 ``MIN_NR_GENS`` 和最多 ``MAX_NR_GENS`` 代。当页面位于 ``lrugen->folios[]`` 之一时，代计数器存储一个在 ``[1, MAX_NR_GENS]`` 范围内的值；否则，它存储零。

每个代被进一步划分为多个层级。通过文件描述符访问了 ``N`` 次的页面处于层级 ``order_base_2(N)``。与代不同，层级没有专门的 ``lrugen->folios[]``。与跨代移动需要 LRU 锁不同，跨层级移动仅涉及对 ``folio->flags`` 的原子操作，因此成本极低。基于PID控制器模型的反馈环路监控来自匿名和文件类型的各个层级的重新故障，并决定从哪些类型和层级驱逐或保护页面。预期效果是在匿名和文件类型之间按交换级别比例平衡重新故障百分比。

有两个概念上独立的过程：老化和驱逐。它们形成一个闭环系统，即页面回收。

老化
-----
老化产生年轻代。给定一个 ``lruvec``，当 ``max_seq-min_seq+1`` 接近 ``MIN_NR_GENS`` 时，它会递增 ``max_seq``。当发现页面通过页表被访问时，老化将热门页面提升到最年轻的代；当递增 ``max_seq`` 时，冷页面则被降级。老化使用页表遍历和 rmap 遍历来查找年轻的 PTE。对于前者，它遍历 ``lruvec_memcg()->mm_list`` 并用此列表上的每个 ``mm_struct`` 调用 ``walk_page_range()`` 来扫描 PTE，在每次迭代后递增 ``max_seq``。对于后者，当驱逐过程遍历 rmap 并找到一个年轻的 PTE 时，老化扫描相邻的 PTE。在这两种情况下，找到一个年轻的 PTE 时，老化清除其访问位并更新该 PTE 映射的页面的代计数器为 ``(max_seq%MAX_NR_GENS)+1``。

驱逐
----
驱逐消耗旧代。给定一个 ``lruvec``，当 ``lrugen->folios[]`` 中由 ``min_seq%MAX_NR_GENS`` 索引的数组为空时，它会递增 ``min_seq``。选择要驱逐的类型和层级时，它首先比较 ``min_seq[]`` 来选择较旧的类型。如果两个类型同样老旧，则选择其第一层级具有较低重新故障百分比的那个。第一层级包含单次使用的未映射干净页面，这是最佳选择。如果老化发现页面通过页表被访问并更新了其代计数器，驱逐根据其代计数器对页面进行排序。如果页面通过文件描述符多次被访问且反馈环路检测到该层级有异常重新故障，则将页面移动到下一代，即 ``min_seq+1``。为此，反馈环路使用第一层级作为基线，如前所述。

工作集保护
----------------------
每个代在其诞生时都会被打上时间戳。如果设置了 ``lru_gen_min_ttl``，则当某个 ``lruvec`` 的最老代诞生于 ``lru_gen_min_ttl`` 毫秒内时，该 ``lruvec`` 将受到保护不被驱逐。换句话说，这防止了 ``lru_gen_min_ttl`` 毫秒的工作集被驱逐。如果这个工作集无法保留在内存中，则触发 OOM 杀手。

这种方法有以下优点：

1. 更容易配置，因为它与应用程序和内存大小无关。
### 更可靠的原因是直接连接到 OOM 杀手的 `mm_struct` 列表

#### `mm_struct` 列表
每个 memcg 都维护一个 `mm_struct` 列表，当任务迁移时，其 `mm_struct` 也会跟随该任务移动到新的 memcg。
页表遍历器会遍历 `lruvec_memcg()->mm_list` 并对列表中的每个 `mm_struct` 调用 `walk_page_range()` 来扫描 PTE。当多个页表遍历器遍历相同的列表时，每个遍历器都会获得一个唯一的 `mm_struct`，因此它们可以并行运行。
页表遍历器会忽略任何错位的页面，例如，如果 `mm_struct` 已经迁移，当前 memcg 在回收过程中会忽略前一个 memcg 中遗留的页面。类似地，页表遍历器还会忽略除正在回收节点之外其他节点上的页面。
此基础设施还会跟踪上下文切换之间的 `mm_struct` 使用情况，以便页表遍历器可以跳过自上次迭代以来一直处于睡眠状态的进程。

#### Rmap/PT 遍历反馈
在 LRU 列表上的每个页面上搜索映射这些页面的 rmap（以测试和清除访问位）可能会很昂贵，因为不同 VMA（物理地址空间）的页面对 rmap（虚拟地址空间）来说并不友好。对于主要使用映射页面的工作负载，搜索 rmap 可能在回收路径中产生最高的 CPU 成本。
`lru_gen_look_around()` 利用空间局部性来减少进入 rmap 的次数。它扫描年轻 PTE 的相邻 PTE 并提升热点页面。如果扫描是缓存行高效的，它会将指向 PTE 表的 PMD 入口添加到布隆过滤器中。这形成了驱逐与老化之间的反馈环路。

#### 布隆过滤器
布隆过滤器是一种空间和内存高效的数据结构，用于集合成员测试，即测试元素是否不在集合中或可能在集合中。
在驱逐路径中，特别是在 `lru_gen_look_around()` 函数中，如果 PMD 包含足够数量的热点页面，则将其地址放入过滤器中。在老化路径中，集合成员意味着将扫描 PTE 范围以查找年轻页面。
请注意，布隆过滤器在集合成员测试中是概率性的。如果测试出现假阳性，成本是一次额外的 PTE 范围扫描，这仍然可能发现热点页面。过滤器本身的参数可以在一定程度上控制假阳性的发生率。
PID控制器
--------------
基于比例-积分-微分（PID）控制器模型的反馈环监控不同类型的内存故障，并在两种类型同时出现在同一代时决定应驱逐哪种类型。PID控制器使用代数而不是实际时间，因为CPU在不同的内存压力下可以以不同的速度扫描页面。为了防止陷入次优状态，它为每一代计算一个移动平均值。

Memcg LRU
---------
Memcg LRU 是每个节点的 memcg 的最近最少使用（LRU）列表。它也是一个 LRU 列表的 LRU，因为每个节点和 memcg 组合都有一个 folio 的 LRU（参见 `mem_cgroup_lruvec()`）。其目标是提高全局回收的可扩展性，这对于数据中心中的系统级内存过度分配至关重要。请注意，memcg LRU 仅适用于全局回收。

可以通过类比活跃/非活跃 LRU（folio 的）来理解 memcg LRU 的基本结构：

1. 它有年轻和老的一代，即活跃和非活跃的对应部分；
2. `max_seq` 的增加触发提升，即激活的对应部分；
3. 其他事件触发类似的操作，例如离线 memcg 触发降级，即非激活的对应部分。

就全局回收而言，它有两个显著特点：

1. 分片机制，允许每个线程从老一代中的随机 memcg 开始，从而提高并行性；
2. 最终公平性，允许直接回收随时退出，减少延迟而不影响一段时间内的公平性。

就全局回收期间遍历 memcg 而言，它将最佳情况复杂度从 O(n) 提高到 O(1)，并且不影响最坏情况下的复杂度 O(n)。因此，平均情况下它的复杂度是亚线性的。

总结
-------
多代 LRU（folio 的）可以拆解为以下几个部分：

* 代
* Rmap 遍历
* 通过 `mm_struct` 列表进行的页表遍历
* 用于 rmap/PT 遍历反馈的布隆过滤器
* 用于故障反馈的 PID 控制器

老化和驱逐形成了一种生产者-消费者模型；具体来说，后者通过滑动窗口在各代之间驱动前者。在老化过程中，rmap 遍历通过将热点密集页面表插入布隆过滤器来驱动页表遍历。在驱逐过程中，PID 控制器使用故障作为反馈来选择要驱逐的类型和要保护的层级。
