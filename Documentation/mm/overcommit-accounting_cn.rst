过度提交会计
===============

Linux 内核支持以下几种过度提交处理模式：

0
    启用启发式过度提交处理。显而易见的地址空间过度提交将被拒绝。适用于典型的系统。它确保了极端情况下的内存分配失败，同时允许适度的过度提交以减少交换区的使用。这是默认设置。
1
    始终允许过度提交。适用于某些科学应用。一个典型例子是使用稀疏数组的代码，并且完全依赖于虚拟内存几乎全部由零页构成。
2
    不允许过度提交。系统的总地址空间提交不得超过交换区加上可配置的数量（默认为物理RAM的50%）。根据你使用的数量，在大多数情况下这意味着进程在访问页面时不会被杀死，但在适当的内存分配时会收到错误。
    对于希望保证未来内存分配可用而不必初始化每一页的应用程序非常有用。

过度提交策略通过 sysctl 的 `vm.overcommit_memory` 进行设置。
过度提交的比例可以通过 `vm.overcommit_ratio`（百分比）或 `vm.overcommit_kbytes`（绝对值）进行设置。这些设置仅在 `vm.overcommit_memory` 设置为2时生效。
当前的过度提交限制和已提交的数量可以在 `/proc/meminfo` 中查看，分别为 CommitLimit 和 Committed_AS。
注意事项
=======

C语言中的栈增长会隐式调用 mremap。如果你需要绝对的保证并接近极限运行，则必须为你认为可能需要的最大栈大小分配内存。对于典型的栈使用情况，这并不重要，但如果你确实非常关心这一点，这是一个特殊情况。

在模式2中，MAP_NORESERVE 标志会被忽略。
工作原理
============

过度提交基于以下规则：

对于文件支持的映射：
    | 共享或只读 - 没有成本（文件本身就是映射而不是交换区）
    | 私有可写 - 每个实例映射的大小

对于匿名或 `/dev/zero` 映射：
    | 共享 - 映射的大小
    | 私有只读 - 没有成本（但用途不大）
    | 私有可写 - 每个实例映射的大小

额外的会计：
    | 通过 mmap 创建的可写拷贝页面
    | 来自同一池的 shmfs 内存

状态
======

* 我们会计入 mmap 内存映射
* 我们会计入 mprotect 改变后的提交
* 我们会计入 mremap 改变后的大小
* 我们会计入 brk
* 我们会计入 munmap
* 我们在 /proc 中报告提交状态
* 在 fork 时进行会计和检查
* 审查栈处理/构建于 exec
* SHMfs 会计
* 实现实际的限制执行

待办事项
=====
* 计入 ptrace 页面（这很困难）
