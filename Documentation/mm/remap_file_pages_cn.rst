==============================
remap_file_pages() 系统调用
==============================

remap_file_pages() 系统调用用于创建非线性映射，即文件的页面以非顺序的方式映射到内存中。与反复使用mmap(2)相比，使用remap_file_pages()的优势在于前者不需要内核创建额外的VMA（虚拟内存区域）数据结构。

支持非线性映射需要在内核虚拟内存子系统中实现大量的非平凡代码，包括热点路径。此外，为了让非线性映射工作，内核需要一种方法来区分普通的页表项和带有文件偏移量的页表项（pte_file）。为此目的，内核在PTE（页表条目）中预留了一个标志位。PTE标志位是一种稀缺资源，特别是在某些CPU架构上。如果能够将这个标志位用于其他用途，将会很好。

幸运的是，实际中使用remap_file_pages()的情况并不多。已知的唯一一个用例是某个企业级RDBMS实现，在32位系统上使用该系统调用来映射无法线性地放入32位虚拟地址空间的大文件。然而，这一用例现在已经不那么关键了，因为64位系统已经广泛可用。

该系统调用已被弃用，并通过仿真取代。仿真会创建新的VMA而不是非线性映射。虽然这会让少数remap_file_pages()用户感到速度变慢，但ABI保持不变。

仿真的一个副作用（除了性能之外）是用户更容易碰到vm.max_map_count限制，因为增加了额外的VMA。有关此限制的更多详细信息，请参阅DEFAULT_MAX_MAP_COUNT的注释。
