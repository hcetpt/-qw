=========  
活动的内存管理（Active MM）  
=========  

注意，在内核配置项 `CONFIG_MMU_LAZY_TLB_REFCOUNT=n` 的情况下，`mm_count` 引用计数可能不再包括“懒惰”用户（即运行的任务中 `->active_mm == mm && ->mm == NULL`）。获取和释放这些懒惰引用必须使用 `mmgrab_lazy_tlb()` 和 `mmdrop_lazy_tlb()` 辅助函数，这些函数抽象了这个配置选项。

```
邮件列表：linux-kernel
主题：关于 active_mm 的讨论
发件人：Linus Torvalds <torvalds () transmeta ! com>
日期：1999-07-30 21:36:24

抄送至 linux-kernel，因为我并不经常写解释性的文章，
当写的时候我希望更多的人能看到。
1999 年 7 月 30 日，David Mosberger 写道：
>
> 是否有地方简要描述了 task_struct 中 "mm" 与 "active_mm" 的使用方式？
> （如果这个问题已经在邮件列表中讨论过，请原谅我，因为我刚从假期回来，没有跟上 linux-kernel 的讨论）
基本上，新的设置如下：

- 我们有“真实的地址空间”和“匿名地址空间”。两者的区别在于匿名地址空间完全不关心用户级页表，因此当我们切换到一个匿名地址空间时，我们会保留前一个地址空间为活动状态。
匿名地址空间的一个明显用途是那些不需要任何用户映射的线程。所有内核线程都属于这一类，但即使是“真实”的线程也可以暂时声明在某段时间内它们对用户空间不感兴趣，并且调度器可以尽量避免浪费时间在切换虚拟内存状态上。目前只有旧式的 bdflush 同步机制会这样做。

- `tsk->mm` 指向“真实的地址空间”。对于匿名进程，`tsk->mm` 将为 NULL，因为逻辑上匿名进程实际上并没有一个真实的地址空间。
然而，我们显然需要跟踪我们为这种匿名用户“借用”的地址空间。为此，我们有 `tsk->active_mm`，它显示当前活动的地址空间。
规则是对于具有真实地址空间的进程（即 `tsk->mm` 非 NULL），`active_mm` 显然总是与真实的地址空间相同。
对于匿名进程，`tsk->mm == NULL`，而 `tsk->active_mm` 是匿名进程运行时“借用”的 mm。当匿名进程被调度出去时，借用的地址空间将被归还并清空。
为了支持这一切，`struct mm_struct` 现在有两个计数器：一个是 `mm_users` 计数器，表示有多少个“真实地址空间用户”，另一个是 `mm_count` 计数器，表示有多少个“懒惰”用户（即匿名用户）加上如果有任何真实用户则加一。
```
通常至少有一个真实的用户，但有可能在懒惰用户仍然活跃时，真实用户在另一个CPU上退出了，因此确实会出现地址空间仅被懒惰用户使用的场景。这通常是一个短暂的状态，因为一旦该线程为了给真实线程让路而被调度走，“僵尸”内存管理结构（mm）就会因为“mm_count”变为零而被释放。

另外，新的规则是任何人都不会再将“init_mm”作为真实的内存管理结构（MM）。应该认为“init_mm”只是在没有其他上下文可用时的“懒惰上下文”，实际上它主要是在启动时使用，那时还没有创建任何真实的虚拟内存。因此，以前检查

    if (current->mm == &init_mm)

的代码现在一般应该改为

    if (!current->mm)

这样做更有意义——这个测试本质上是判断“我们是否有用户上下文”，通常是由缺页处理程序等完成的。

无论如何，我刚刚在ftp.kernel.org上放了一个预补丁版本2.3.13-1，因为它稍微改变了接口以适应Alpha架构（没想到Alpha最终会有最丑陋的上下文切换代码——与其他架构不同，其中MM和寄存器状态是分开的，Alpha的PALcode将两者结合在一起，你需要一起切换它们）。

（来源：http://marc.info/?l=linux-kernel&m=93337278602211&w=2）
