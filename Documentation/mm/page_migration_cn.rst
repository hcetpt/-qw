页面迁移
==========

页面迁移允许在NUMA系统中进程运行时移动页面的物理位置。这意味着进程看到的虚拟地址不会改变，但系统会重新安排这些页面的物理位置。
有关将页面迁移到或从设备私有内存迁移的信息，请参阅Documentation/mm/hmm.rst。
页面迁移的主要目的是通过将页面移动到访问该内存的处理器附近来减少内存访问延迟。
页面迁移允许进程通过设置新的内存策略并通过mbind()使用MF_MOVE和MF_MOVE_ALL选项手动重新定位其页面所在的节点。也可以通过调用sys_migrate_pages()函数从另一个进程中重新定位进程的页面。migrate_pages()函数调用接受两组节点，并将位于源节点上的进程页面移动到目标节点。
页面迁移功能由Andi Kleen提供的numactl包提供（需要0.9.3以上版本。可从https://github.com/numactl/numactl.git获取）。numactl提供了libnuma，它为页面迁移提供了与其他NUMA功能相似的接口。查看`/proc/<pid>/numa_maps`可以轻松了解进程页面的位置。详情请参阅proc(5)手册页中的numa_maps文档。
如果调度器将进程重新定位到远端节点上的处理器，则手动迁移是有用的。批处理调度器或管理员可能会检测到这种情况并将进程页面移动到新处理器附近。内核本身仅提供手动页面迁移支持。自动页面迁移可以通过用户空间进程实现。一个特殊的函数调用“move_pages”允许在进程内部移动单个页面。
例如，NUMA分析器可以获得显示频繁跨节点访问的日志，并利用结果将页面移动到更有利的位置。
大型安装通常使用cpuset将系统划分为节点部分。Paul Jackson为cpuset配备了当任务移动到另一个cpuset时移动页面的功能（参见:ref:`CPUSETS <cpusets>`）。
cpuset允许自动化进程局部性。如果任务移动到新的cpuset，则所有页面也会随之移动，以防止性能大幅下降。同样地，如果更改了cpuset允许的内存节点，则也会移动其中的进程页面。
页面迁移允许保留一组节点内页面的相对位置，适用于所有迁移技术，即使在迁移进程后也能保持特定的内存分配模式。这是为了保持内存延迟。
进程在迁移后将具有相似的性能
页面迁移分为几个步骤。首先是对那些试图从内核中使用 migrate_pages() 的人提供的高层次描述（用户空间的使用请参见上面提到的 Andi Kleen 的 numactl 包），然后是关于低层次细节如何工作的详细描述。
在内核中使用 migrate_pages()
================================

1. 从LRU列表中移除页面
待迁移的页面列表是通过扫描页面并将它们放入列表中生成的。这是通过调用 isolate_lru_page() 实现的。
调用 isolate_lru_page() 增加了对页面的引用计数，以防止在页面迁移过程中页面消失。
它还阻止了交换器或其他扫描遇到该页面。
2. 我们需要一个类型为 new_folio_t 的函数，它可以传递给 migrate_pages()。这个函数应该能够根据旧的 folio 分配正确的新的 folio。
3. 调用 migrate_pages() 函数，尝试进行迁移。对于每个需要移动的 folio，它会调用分配新 folio 的函数。

migrate_pages() 的工作原理
=========================

migrate_pages() 对其页面列表进行多次遍历。如果在某一时刻页面的所有引用都可以被移除，则页面会被移动。页面已经通过 isolate_lru_page() 从LRU列表中移除，并且引用计数已增加，以防止在页面迁移过程中页面被释放。
步骤：

1. 锁定要迁移的页面
2. 确保回写操作完成。
3. 锁定我们要迁移到的新页面。这样可以确保在迁移过程中，对该页面（尚未更新）的访问会立即被阻塞。
4. 将所有指向该页面的页表引用转换为迁移条目。这会减少页面的地图计数(mapcount)。如果最终的地图计数不为零，则不进行页面迁移。所有尝试访问该页面的用户空间进程现在会等待页面锁或等待迁移页表条目被移除。
5. 获取 `i_pages` 锁。这将导致所有试图通过映射访问该页面的进程被阻塞在自旋锁上。
6. 检查页面的引用计数(refcount)，如果有引用仍然存在，则退出操作。否则，我们知道我们是唯一引用该页面的实体。
7. 检查基数树(radix tree)，如果它不包含指向该页面的指针，则退出操作，因为其他实体修改了基数树。
8. 用旧页面的一些设置来准备新页面，以便对新页面的访问能够发现一个具有正确设置的页面。
9. 修改基数树，使其指向新页面。
10. 由于地址空间的引用已消失，降低旧页面的引用计数。建立对新页面的引用，因为新页面现在由地址空间引用。
11. 释放 `i_pages` 锁。这样一来，映射中的查找再次成为可能。进程将从自旋锁变为在新页上睡眠。
12. 将页内容复制到新页。
13. 将剩余的页标志复制到新页。
14. 清除旧页的标志，以表示该页不再提供任何信息。
15. 触发对新页的排队写回。
16. 如果在页表中插入了迁移条目，则用实际的 PTE（页表项）替换它们。这样做将使用户空间进程能够访问这些页，而不需要等待页锁。
17. 释放旧页和新页上的页锁。等待页锁的进程将重新触发他们的页错误，并到达新页。
18. 新页被移到 LRU 列表中，可以再次被交换器扫描等。

非 LRU 页迁移
===============
尽管迁移最初旨在减少 NUMA 系统中内存访问的延迟，但压缩也使用迁移来创建高阶页。为了压缩的目的，能够移动非 LRU 页也是有用的，例如 zsmalloc 和 virtio-balloon 页。
如果一个驱动程序希望使其页面可移动，它应该定义一个 `movable_operations` 结构体。然后，它需要对其可能移动的每个页面调用 `__SetPageMovable()`。这会使用 `page->mapping` 字段，因此该字段不能被驱动程序用于其他目的。

### 监控迁移

以下事件（计数器）可用于监控页面迁移：
1. **PGMIGRATE_SUCCESS**：普通页面迁移成功。每次计数表示一个页面被迁移了。如果页面是非透明大页（THP）且非巨页（hugetlb），则该计数器增加1。如果页面是THP或巨页，则该计数器增加THP或巨页子页的数量。
   - 例如，迁移一个包含4KB大小子页的2MB THP将使此计数器增加512。
2. **PGMIGRATE_FAIL**：普通页面迁移失败。与 PGMIGRATE_SUCCESS 的计数规则相同：如果页面是THP或巨页，则计数器增加子页的数量。
3. **THP_MIGRATION_SUCCESS**：THP在未被拆分的情况下被迁移。
4. **THP_MIGRATION_FAIL**：THP无法被迁移，也无法被拆分。
5. **THP_MIGRATION_SPLIT**：THP被迁移了，但不是以整体的形式：首先，THP必须被拆分。拆分后，对子页进行了迁移重试。

THP_MIGRATION_* 事件还会更新相应的 PGMIGRATE_SUCCESS 或 PGMIGRATE_FAIL 事件。例如，THP迁移失败将导致 THP_MIGRATION_FAIL 和 PGMIGRATE_FAIL 都增加。

Christoph Lameter，2006年5月8日
金敏灿，2016年3月28日
.. kernel-doc:: include/linux/migrate.h

请注意，这段文字中的“Minchan Kim”看起来像是一个人名，但在这个上下文中可能需要进一步确认其含义或背景。如果你确定这是一个作者的名字，则上述翻译是正确的。如果需要更具体的上下文信息，请提供更多的细节。
