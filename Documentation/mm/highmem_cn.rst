高内存处理
=============

作者：Peter Zijlstra <a.p.zijlstra@chello.nl>

.. contents:: 目录

什么是高内存？
================

当物理内存的大小接近或超过虚拟内存的最大容量时，就会使用高内存（highmem）。在这种情况下，内核无法一直映射所有可用的物理内存。这意味着内核需要对想要访问的部分物理内存使用临时映射。未被永久映射覆盖的部分（物理）内存就是我们所说的“高内存”。各种架构对此边界的确切位置有不同的限制。

例如，在i386架构中，我们将内核映射到每个进程的虚拟内存空间中，以避免在进入和退出内核时进行完整的TLB（转换查找缓冲区）无效操作。这意味着可用的虚拟内存空间（在i386上为4GiB）必须在用户空间和内核空间之间进行划分。

传统的划分方法是3:1，即3GiB用于用户空间，顶部的1GiB用于内核空间：

		+--------+ 0xffffffff
		| 内核   |
		+--------+ 0xc0000000
		|        |
		| 用户   |
		|        |
		+--------+ 0x00000000

这意味着内核最多可以同时映射1GiB的物理内存，但由于我们需要虚拟地址空间来处理其他事务（包括临时映射以访问剩余的物理内存），实际的直接映射通常会更少（通常约为896MiB）。

其他具有mm上下文标记TLB的架构可以有独立的内核和用户映射。然而，一些硬件（如某些ARM设备）在使用mm上下文标签时，虚拟空间有限。

临时虚拟映射
=================

内核中有几种创建临时映射的方法。以下列表按照优先级顺序展示了这些方法：
* kmap_local_page()，kmap_local_folio() — 这些函数用于创建短期映射。它们可以从任何上下文（包括中断）调用，但映射只能在其获取该映射的上下文中使用。这两个函数之间的唯一区别在于前者接受指向struct page的指针，而后者接受指向struct folio的指针以及folio中的字节偏移量来标识页面。
这些函数应该始终使用，而kmap_atomic()和kmap()已被弃用。
这些映射是线程本地和CPU本地的，意味着映射只能从该线程中访问，并且在映射激活期间该线程绑定到特定CPU。虽然这个函数不会禁用抢占，但在映射未被处置之前，系统不能通过CPU热插拔将CPU从系统中移除。
如果获取本地映射的上下文允许，那么在本地kmap区域中引发页错误是有效的；否则，在其他原因下该上下文不允许这样做。
如前所述，页面错误（pagefaults）和抢占（preemption）从不被禁用。无需禁用抢占，因为在上下文切换到另一个任务时，会保存即将退出的任务的映射，并恢复新进入任务的映射。

`kmap_local_page()` 以及 `kmap_local_folio()` 总是返回有效的虚拟内核地址，并假定 `kunmap_local()` 永远不会失败。

在 `CONFIG_HIGHMEM=n` 的内核中，对于低内存页面，它们返回直接映射的虚拟地址。只有真正的高内存页面会被临时映射。因此，用户可以为已知不属于 `ZONE_HIGHMEM` 的页面调用普通的 `page_address()`。然而，使用 `kmap_local_{page,folio}()` 和 `kunmap_local()` 始终是安全的。

虽然它们比 `kmap()` 快得多，但在高内存情况下，它们对指针的有效性有严格的限制。与 `kmap()` 映射不同，本地映射仅在调用者的上下文中有效，不能传递给其他上下文。这意味着用户必须确保返回地址的使用仅限于映射它的线程。

大多数代码可以设计为使用线程局部映射。因此，用户应尽量设计他们的代码以避免使用 `kmap()`，而是在同一线程中映射地址，并优先使用 `kmap_local_page()` 或 `kmap_local_folio()`。

`kmap_local_page()` 和 `kmap_atomic()` 映射可以在一定程度上嵌套（最多到 `KMAP_TYPE_NR`），但它们的调用必须严格有序，因为映射实现基于栈。有关如何管理嵌套映射的详细信息，请参阅 `kmap_local_page()` 的文档（包含在“函数”部分）。

* `kmap_atomic()`。此函数已被弃用；请使用 `kmap_local_page()`。
  
注意：转换为 `kmap_local_page()` 时，必须遵循对 `kmap_local_page()` 施加的映射限制。此外，在 `kmap_atomic()` 和 `kunmap_atomic()` 之间的代码可能隐式依赖原子映射的副作用，即禁用页面错误或抢占，或两者兼而有之。

在这种情况下，必须显式调用 `pagefault_disable()` 或 `preempt_disable()` 或两者，与使用 `kmap_local_page()` 结合起来使用。

[过时文档]

这允许非常短时间地映射单个页面。由于映射仅限于发出映射的 CPU，其性能很好，但发出任务必须保持在该 CPU 上直到完成，否则其他任务可能会替换其映射。
kmap_atomic() 也可以被中断上下文使用，因为它不会睡眠，并且调用者在调用 kunmap_atomic() 之前也不会睡眠。
每次在内核中调用 kmap_atomic() 都会创建一个不可抢占的段并禁用页错误。这可能会导致不必要的延迟。因此，用户应优先选择 kmap_local_page() 而不是 kmap_atomic()。
假定 k[un]map_atomic() 不会失败。
* kmap()。此函数已被弃用；请使用 kmap_local_page()。
注意：转换为 kmap_local_page() 必须遵循 kmap_local_page() 强加的映射限制。特别是，必须确保内核虚拟内存指针仅在获取它的线程中有效。
[遗留文档]

此功能应用于对单个页面进行短时间映射，没有关于抢占或迁移的限制。它带有一定的开销，因为映射空间受到限制并且由全局锁保护以实现同步。当不再需要映射时，必须通过 kunmap() 释放页面映射到的地址。
映射更改必须传播到所有 CPU。kmap() 在 kmap 的池循环时也需要全局 TLB 无效，并且在映射空间完全利用直到有空槽可用时可能会阻塞。因此，kmap() 只能在可抢占上下文中调用。
如果映射需要持续相对较长的时间，则上述工作都是必要的。但在内核中的大量高内存映射是短暂存在的，并且只在一个地方使用。这意味着在这些情况下 kmap() 的成本大多被浪费了。kmap() 并不适用于长期映射，但它已经朝这个方向发展，并且在新代码中强烈不建议使用该函数，应优先使用前面所述的一组函数。
在 64 位系统上，由于 64 位地址空间足以寻址所有永久映射的物理内存，因此调用 kmap_local_page()、kmap_atomic() 和 kmap() 实际上不需要执行任何工作。
* vmap()。这可用于将多个物理页面映射到连续的虚拟空间中。取消映射需要全局同步。
临时映射的成本
==========================

创建临时映射的成本可能相当高。架构需要操作内核的页表、数据TLB和/或MMU的寄存器。如果未设置`CONFIG_HIGHMEM`，则内核将尝试通过简单的算术运算将页面结构地址转换为指向页面内容的指针，而不是频繁地调整映射。在这种情况下，取消映射操作可能是空操作。如果未设置`CONFIG_MMU`，则不会有临时映射和高内存（highmem）。在这种情况下，也将使用算术方法。

i386 PAE
========

在某些情况下，i386架构允许你在32位机器中安装最多64GiB的RAM。这会产生一系列后果：

* Linux需要为系统中的每个页面提供一个页框结构，并且这些页框需要位于永久映射中，这意味着：
* 最多可以有896M / sizeof(struct page)个页框；如果struct page为32字节，则大约为112G的页面；然而，内核还需要在这段内存中存储其他信息。
* PAE会使你的页表变大——这会降低系统的速度，因为需要访问更多数据来进行TLB填充等操作。PAE的一个优点是它有更多的PTE位，可以提供诸如NX和PAT等高级特性。

一般建议是在32位机器上不要使用超过8GiB的内存——尽管更多的内存可能对你和你的工作负载有效，但你基本上是自己负责——不要指望内核开发者会在事情出现问题时特别关心。

函数
=========

.. kernel-doc:: include/linux/highmem.h  
.. kernel-doc:: mm/highmem.c  
.. kernel-doc:: include/linux/highmem-internal.h
