版权所有 2020 DisplayLink (UK) Ltd
===================
用户空间接口
===================

DRM 核心导出了多个接口供应用程序使用，通常通过对应的 libdrm 包装函数来访问。此外，驱动程序还通过 ioctl 和 sysfs 文件为用户空间驱动和设备感知应用程序导出了特定于设备的接口。外部接口包括：内存映射、上下文管理、DMA 操作、AGP 管理、垂直同步控制、围栏管理、内存管理和输出管理。
在此处介绍通用的 ioctl 和 sysfs 布局。我们只需要高级信息，因为手册页面应该涵盖其余内容。
libdrm 设备查找
====================

.. kernel-doc:: drivers/gpu/drm/drm_ioctl.c
   :doc: getunique 和 setversion 的故事


.. _drm_primary_node:

主节点、DRM 主控和认证
============================================

.. kernel-doc:: drivers/gpu/drm/drm_auth.c
   :doc: 主控和认证

.. kernel-doc:: drivers/gpu/drm/drm_auth.c
   :export:

.. kernel-doc:: include/drm/drm_auth.h
   :internal:


.. _drm_leasing:

DRM 显示资源租赁
============================

.. kernel-doc:: drivers/gpu/drm/drm_lease.c
   :doc: drm 租赁

开源用户空间要求
==================

DRM 子系统对新 uAPI 用户空间的要求比大多数其他内核子系统更为严格。本节解释了这些要求的具体内容及其存在的原因。
简而言之，任何新增的 DRM uAPI 都需要相应的开源用户空间补丁，并且这些补丁必须经过审查并准备好合并到合适的上游项目中。
图形设备（包括显示和渲染/GPU 部分）是非常复杂的硬件，用户空间和内核必须紧密合作。渲染和模式设置接口必须非常广泛和灵活，因此几乎不可能精确定义所有可能的边缘情况。这反过来使得区分用户空间所需的行为与不能改变以避免回归的行为变得实际不可行。
如果没有访问所有用户空间用户的完整源代码，这意味着无法更改实现细节，因为用户空间可能会依赖当前实现的偶然行为。没有源代码调试这种回归几乎是不可能的。结果是：

- Linux 内核的“无回归”政策实际上仅适用于 DRM 子系统的开源用户空间。DRM 开发者完全接受用户空间中的闭源 blob 驱动使用相同的 uAPI，但它们必须以与开源驱动相同的方式使用。
创造性地（滥用）使用接口将导致问题，过去也经常发生这种情况。
- 任何新的用户空间接口都必须有一个开源实现作为演示工具。
要求开源用户空间的另一个原因是 uAPI 审查。由于 GFX 栈中的内核和用户空间部分必须紧密协作，代码审查只有同时查看这两部分才能评估新接口是否达到目标。确保接口确实完全覆盖使用场景会带来一些额外的要求：

- 开源用户空间不应是玩具/测试应用程序，而应是实际的应用程序。具体来说，它需要处理所有常见的错误和边缘情况。这些往往是新 uAPI 失效的地方，因此对于评估提议接口的有效性至关重要。
- 用户空间部分必须按照该用户空间项目的标准进行全面审查和测试。例如，在 Mesa 中这意味着要有 Piglit 测试用例，并在邮件列表上进行审查。这同样是为了确保新的接口实际上能够完成任务。用户空间方面的审查者还应在内核 uAPI 补丁上提供一个 Acked-by，表明他们认为提议的 uAPI 是合理的、充分文档化且经过验证的，适用于用户空间。
- 用户空间补丁必须基于官方上游版本，而不是某个厂商的分支版本。这是为了确保没有人通过快速分叉来逃避审查和测试要求。
- 只有在满足上述所有要求后，内核补丁才能被合并，但它 **必须** 在用户空间补丁落地之前合并到 drm-next 或 drm-misc-next。uAPI 总是从内核流向用户空间，反之则可能导致 uAPI 定义和头文件的分歧。
这些要求虽然很高，但它们是在多年对仓促添加 uAPI 的痛苦和经验基础上形成的，几乎总是很快就会后悔。GFX 设备变化非常快，每几年就需要一次范式转变和全新的 uAPI 接口集。再加上 Linux 内核保证现有用户空间能运行 10 年以上，这对 DRM 子系统来说已经相当痛苦了，因为存在多个不同的 uAPI 接口共存的情况。如果我们每年再增加几个完全错误的接口，那将变得完全无法管理。

.. _drm_render_node:

渲染节点
========

DRM 核心提供了多个字符设备供用户空间使用。根据打开的是哪个设备，用户空间可以执行不同的操作（主要是 ioctl）。主节点始终会被创建并命名为 card<num>。此外，还会创建一个当前未使用的控制节点，称为 controlD<num>。主节点提供了所有遗留的操作，并且历史上是唯一被用户空间使用的接口。随着 KMS 的引入，控制节点也被引入。然而，计划中的 KMS 控制接口从未编写出来，因此控制节点至今未被使用。
随着离屏渲染器和 GPGPU 应用程序的日益普及，客户端不再需要运行合成器或图形服务器即可利用 GPU。但由于 DRM API 要求无特权客户端在获得 GPU 访问权限前进行 DRM-Master 认证。为了避免这个步骤，并授予客户端无需认证即可访问 GPU 的权限，引入了渲染节点。渲染节点仅服务于渲染客户端，即不允许在渲染节点上进行模式设置或特权 ioctl。只允许非全局渲染命令。如果驱动支持渲染节点，则必须通过 DRIVER_RENDER DRM 驱动能力进行宣传。如果不支持，则渲染客户端必须使用主节点并结合 legacy drmAuth 认证过程。
如果一个驱动程序宣传支持渲染节点，DRM 核心将创建一个名为 `renderD<num>` 的独立渲染节点。每个设备将有一个渲染节点。除了与 PRIME 相关的 ioctl 外，此节点上不允许执行任何其他 ioctl。特别是 GEM_OPEN 将被明确禁止。关于可以在渲染节点上使用的完整的与驱动无关的 ioctl 列表，请参见 `drm_ioctl.c` 中标记为 `DRM_RENDER_ALLOW` 的 ioctl。渲染节点的设计目的是避免客户端在传统接口上猜测 flink 名称或 mmap 偏移量导致的缓冲区泄漏问题。此外，在这个基本接口之外，驱动程序必须将其依赖于驱动的渲染专用 ioctl 标记为 `DRM_RENDER_ALLOW`，以便渲染客户端可以使用它们。驱动程序作者必须小心不要在渲染节点上允许任何特权 ioctl。

通过渲染节点，用户空间现在可以通过基本的文件系统访问模式来控制对渲染节点的访问。不再需要运行图形服务器来验证特权主/传统节点上的客户端身份。相反，客户端可以直接打开渲染节点并立即获得 GPU 访问权限。客户端（或服务器）之间的通信通过 PRIME 进行。从渲染节点到传统节点的 FLINK 不受支持。新客户端不得使用不安全的 FLINK 接口。

除了删除所有模式设置/全局 ioctl 外，渲染节点还取消了 DRM-Master 概念。没有理由将渲染客户端与 DRM-Master 关联，因为它们独立于任何图形服务器。此外，无论如何它们都必须在没有任何运行中的主对象的情况下工作。如果驱动程序支持渲染节点，则必须能够在没有主对象的情况下运行。另一方面，如果驱动程序需要在客户端之间共享对用户空间可见且超出文件打开范围可访问的状态，则无法支持渲染节点。

设备热拔插
===========

.. note::
   以下为计划。实现尚未完成（截至 2020 年 5 月）
图形设备（显示和/或渲染）可能通过 USB（例如显示器适配器或扩展坞）或 Thunderbolt（例如外置显卡）连接。最终用户可以在使用这些设备时热拔插，期望至少机器不会崩溃。热拔插 DRM 设备造成的损坏需要尽可能地限制，并且用户空间必须有机会处理这种情况。理想情况下，拔掉一个 DRM 设备仍然可以让桌面继续运行，但这需要整个图形堆栈中的显式支持：从内核和用户空间驱动程序，通过显示服务器，到窗口系统协议，再到应用程序和库。
其他应该导致相同结果的情况包括：不可恢复的 GPU 故障、PCI 设备从总线上消失或强制卸载驱动程序与物理设备的绑定。
换句话说，从用户空间的角度来看，一切都需要继续或多或少正常工作，直到用户空间停止使用消失的 DRM 设备并完全关闭它。用户空间将从设备移除的 uevent、ioctl 返回 `ENODEV`（或驱动程序特定的 ioctl 返回驱动程序特定的内容），或 `open()` 返回 `ENXIO` 得知设备消失。
只有在用户空间关闭所有相关的 DRM 设备和 dma 缓冲区文件描述符并移除所有 mmap 后，DRM 驱动程序才能拆除不再存在的设备实例。如果同一物理设备在此期间以某种方式重新出现，它应当被视为一个新的 DRM 设备。
类似于PIDs，chardev次设备号不会立即回收。一个新的DRM设备总是选择比之前分配的次设备号更大的下一个可用次设备号，并在次设备号耗尽时循环使用。

这至少对内核和驱动程序提出了以下要求：

### 对KMS用户API的要求
-------------------------
- KMS连接器必须将其状态更改为断开。
- 传统的模式设置、页面翻转以及原子提交（包括实际的和TEST_ONLY），以及其他ioctl调用要么返回ENODEV错误，要么模拟成功。
- 待处理的非阻塞KMS操作应传递用户空间期望的DRM事件。这也适用于模拟成功的ioctl调用。
- 在底层设备已消失的设备节点上调用open()将返回ENXIO错误。
- 尝试在一个已消失的DRM设备上创建DRM租约将返回ENODEV错误。现有的DRM租约保持不变并按上述方式工作。

### 对渲染和跨设备用户API的要求
---------------------------------------------

- 所有无法继续运行的GPU任务必须强制发送围栏信号以避免导致用户空间挂起。相关的错误代码为ENODEV。
- 一些用户空间API已经定义了当设备消失时的行为（例如OpenGL/GL ES中的`GL_KHR_robustness`；Vulkan中的VK_ERROR_DEVICE_LOST等）。DRM驱动程序可以自由地按照它们认为最合适的方式实现这种行为，例如在特定于驱动程序的ioctl调用中返回失败并在用户空间驱动程序中处理这些失败，或者依赖于uevents等。
- 指向已消失内存的 dmabuf 在导入时将因 ENODEV 失败，或者如果在内存消失前能够成功，则继续成功导入。有关已导入 dmabuf 的内存映射，请参见下文。
- 尝试将 dmabuf 导入已消失的设备将因 ENODEV 失败，或者如果没有消失则会成功。
- 对底层设备已消失的设备节点执行 open() 调用将因 ENXIO 失败。
.. _GL_KHR_robustness: https://www.khronos.org/registry/OpenGL/extensions/KHR/KHR_robustness.txt
.. _Vulkan: https://www.khronos.org/vulkan/

内存映射的要求
----------------------

内存映射对现有映射及设备消失后创建的新映射有进一步的要求。如果底层内存消失，映射会被创建或修改以使得读写操作仍能完成，但结果是未定义的。这适用于用户空间通过 mmap() 映射的内存和由 dmabuf 指向的内存（可能映射到其他设备的跨设备 dmabuf 导入）。引发 SIGBUS 不是一个可行的选项，因为用户空间无法实际处理这种情况。信号处理器是全局的，这使得像 Mesa 这样的库中的信号处理器正确使用极其困难。信号处理器不具备组合性，你不能为不同厂商的不同 GPU 设定不同的处理器，也不能为常规文件的 mmap 设置第三个处理器。线程也会给信号处理带来额外的麻烦。

设备重置
==========

GPU 栈非常复杂，并且容易出错，从硬件缺陷、故障应用程序到各层之间的任何问题都可能导致错误。某些错误需要重置设备才能使设备再次可用。本节描述了当设备重置时 DRM 和用户模式驱动程序的预期行为以及如何传播重置状态。设备重置无法禁用，否则会导致内核被污染，进而可能通过 shrinkers/mmu_notifiers 挂起整个内核。用户空间在设备重置中的作用是将消息传播给应用程序并应用任何针对故障应用程序的特殊策略（如果有）。推论是调试挂起的 GPU 上下文需要硬件支持，以便能够在该上下文停止时抢占它。

内核模式驱动程序
------------------

KMD 负责检查设备是否需要重置，并按需执行重置。通常，当一个作业卡住时会被检测到挂起。KMD 应跟踪重置情况，因为用户空间可以随时查询特定上下文的重置状态。这是为了通知堆栈其余部分重置已发生。目前，每个驱动程序分别实现这一点，没有统一的 DRM 接口。理想情况下，这应该在 DRM 调度器中进行适当集成，为所有驱动程序提供一个共同的基础。重置后，KMD 应拒绝受影响上下文的新命令提交。
用户模式驱动程序 (User Mode Driver)
----------------

在命令提交后，UMD 应检查提交是否被接受或拒绝。重置后，KMD 应该拒绝提交，并且 UMD 可以向 KMD 发出 ioctl 来检查重置状态；如果 UMD 需要的话，可以更频繁地检查此状态。检测到重置后，UMD 将继续通过适当的 API 错误代码将重置报告给应用程序，如下面关于鲁棒性的部分所述。

鲁棒性
----------

在设备重置后尝试保持图形 API 上下文正常工作的唯一方法是确保其符合所使用的图形 API 的鲁棒性方面。图形 API 提供了让应用程序处理设备重置的方法。然而，并不能保证应用程序能够正确使用这些特性，而且如果用户空间不支持鲁棒接口（例如非鲁棒的 OpenGL 上下文或像 libva 这样没有鲁棒性支持的 API），则整个鲁棒性处理完全依赖于用户空间驱动程序。在这种情况下，用户空间驱动程序应如何处理尚无明确的社区共识，因为所有合理的处理方式都有明显的缺点。

OpenGL
~~~~~~

使用 OpenGL 的应用程序应该使用可用的鲁棒性接口，例如扩展 ``GL_ARB_robustness``（对于 OpenGL ES 则为 ``GL_EXT_robustness``）。此接口会告知是否发生了重置，如果是，则认为上下文状态已丢失，应用程序需要重新创建新的上下文。如果不使用鲁棒性接口，目前没有共识应如何处理。

Vulkan
~~~~~~

使用 Vulkan 的应用程序应在提交时检查 ``VK_ERROR_DEVICE_LOST`` 错误码。此错误码意味着设备已经重置，需要重新创建上下文以继续运行。

报告重置原因
--------------------------

除了通过堆栈传播重置信息以便应用程序恢复外，对于驱动开发者来说，了解导致重置的根本原因也非常重要。DRM 设备应利用 devcoredump 存储有关重置的相关信息，以便这些信息可以添加到用户的错误报告中。

.. _drm_driver_ioctl:

设备节点上的 IOCTL 支持
=============================

.. kernel-doc:: drivers/gpu/drm/drm_ioctl.c
   :doc: driver specific ioctls

推荐的 IOCTL 返回值
-------------------------------

理论上，驱动程序的 IOCTL 回调只能返回少量特定的错误码。实际上，合理地滥用一些其他错误码也是好的做法。以下是在 DRM 子系统中的常见实践：

- ENOENT：
  严格来说，这仅当文件不存在时使用，例如调用 open() 系统调用。我们重用此错误码来表示任何类型的对象查找失败，例如未知的 GEM 缓冲对象句柄、未知的 KMS 对象句柄等类似情况。
- ENOSPC：
  一些驱动程序使用此错误码来区分“内核内存不足”和“VRAM 不足”。有时也适用于其他用于渲染的有限 GPU 资源（例如特殊有限压缩缓冲区）。
  有时，在命令提交 IOCTL 中遇到的资源分配/预留问题也会通过 EDEADLK 错误码来表示。
仅仅耗尽内核/系统内存会通过 ENOMEM 信号来表示。

EPERM/EACCES：
    对于一个有效但需要更多权限的操作，将返回此错误。
    例如，仅限root或更常见的是，仅限DRM主的操作在被非特权客户端调用时会返回此错误。EACCES和EPERM之间没有明确的区别。

ENODEV：
    设备不再存在或者尚未完全初始化。

EOPNOTSUPP：
    驱动不支持某项特性（如PRIME、modesetting、GEM）。

ENXIO：
    远程失败，可能是一个硬件事务（如I2C），但也用于共享dma-buf或fence的导出驱动不支持所需功能的情况。

EINTR：
    DRM驱动假设用户空间会重启所有ioctl调用。任何DRM ioctl都可以返回EINTR，在这种情况下应该重新尝试该ioctl调用，参数保持不变。

EIO：
    显卡已死且无法通过复位复活。模式设置中的硬件故障会通过“链接状态”连接器属性来指示。

EINVAL：
    捕获所有无效参数组合的情况，这些组合无法正常工作。

ioctl还会使用其他错误代码，如ETIME、EFAULT、EBUSY、ENOTTY，但它们的使用与常见的含义一致。上述列表试图记录DRM特有的模式。注意，ENOTTY具有稍微反直觉的意义，即“此ioctl不存在”，在DRM中也确实如此使用。
``kernel-doc:: include/drm/drm_ioctl.h``
   :internal:

``kernel-doc:: drivers/gpu/drm/drm_ioctl.c``
   :export:

``kernel-doc:: drivers/gpu/drm/drm_ioc32.c``
   :export:

测试与验证
==========

用户空间API的测试要求
----------------------

对于新的跨驱动程序用户空间接口扩展（如新的IOCTL、新的KMS属性、sysfs中的新文件或任何构成API更改的内容），如果可以通过IGT针对目标硬件合理地进行此类测试，则应在IGT中为该功能提供与特定驱动程序无关的测试用例。

使用IGT验证更改
------------------

有一系列测试旨在覆盖DRM驱动程序的全部功能，并可用于检查对DRM驱动程序或内核核心的更改是否导致现有功能的倒退。此测试套件称为IGT，其代码和构建及运行说明可以在 https://gitlab.freedesktop.org/drm/igt-gpu-tools/ 找到。

使用VKMS测试DRM API
-------------------

VKMS是一种仅限软件的KMS驱动模型，适用于测试和运行合成器。VKMS旨在实现无需硬件显示能力的虚拟显示。这些特性使得VKMS成为验证DRM核心行为的理想工具，并且还支持合成器开发人员。VKMS使我们能够在没有显示器的虚拟机中测试DRM函数，简化了某些核心更改的验证。

要使用VKMS验证DRM API中的更改，请首先设置内核：确保启用VKMS模块；使用启用VKMS的内核编译并将其安装在目标机器上。VKMS可以在虚拟机（如QEMU、virtme或类似）中运行。建议使用KVM，并且至少配备1GB内存和四个核心。

可以在虚拟机中以两种方式运行IGT测试：

1. 在虚拟机内部使用IGT。
2. 从主机机器使用IGT并将结果写入共享目录。

以下是一个使用带有主机共享目录的虚拟机来运行igt-tests的例子。这个例子使用virtme：

```
$ virtme-run --rwdir /path/for/shared_dir --kdir=path/for/kernel/directory --mods=auto
```

在虚拟机中运行IGT测试。这个例子运行'kms_flip'测试：

```
$ /path/for/igt-gpu-tools/scripts/run-tests.sh -p -s -t "kms_flip.*" -v
```

在这个例子中，不是构建igt_runner，而是使用Piglit（-p选项）。它会创建一个HTML格式的测试结果摘要，并将其保存在“igt-gpu-tools/results”文件夹中。它只执行匹配-t选项的igt-tests。

显示CRC支持
------------

``kernel-doc:: drivers/gpu/drm/drm_debugfs_crc.c``
   :doc: CRC ABI

``kernel-doc:: drivers/gpu/drm/drm_debugfs_crc.c``
   :export:

Debugfs支持
------------

``kernel-doc:: include/drm/drm_debugfs.h``
   :internal:

``kernel-doc:: drivers/gpu/drm/drm_debugfs.c``
   :export:

sysfs支持
==========

``kernel-doc:: drivers/gpu/drm/drm_sysfs.c``
   :doc: overview

``kernel-doc:: drivers/gpu/drm/drm_sysfs.c``
   :export:

垂直空白事件处理
=================

DRM内核提供了两个与垂直空白相关的ioctl命令：

:c:macro:`DRM_IOCTL_WAIT_VBLANK`
    此命令需要一个drm_wait_vblank结构作为参数，并用于在指定的垂直空白事件发生时阻塞或请求信号。

:c:macro:`DRM_IOCTL_MODESET_CTL`
    这个ioctl主要用于模式设置更改期间允许内核更新垂直空白中断。因为在许多设备上，在模式设置过程中某个时刻垂直空白计数器会被重置为0。现代驱动程序不应再调用此ioctl，因为对于内核模式设置来说它是无操作的。

用户空间API结构
================

``kernel-doc:: include/uapi/drm/drm_mode.h``
   :doc: overview

.. _crtc_index:

CRTC索引
--------

CRTC具有对象ID和索引，它们不是同一个东西。
索引在需要密集标识符的地方使用，例如CRTC的位掩码。`drm_mode_get_plane`结构体中的`possible_crtcs`成员就是一个例子。
:c:macro:`DRM_IOCTL_MODE_GETRESOURCES` 会用一个CRTC ID的数组填充一个结构体，而CRTC索引则是它在这个数组中的位置。

.. kernel-doc:: include/uapi/drm/drm.h
   :internal:

.. kernel-doc:: include/uapi/drm/drm_mode.h
   :internal:

DMA-BUF互操作性
================

请参阅Documentation/userspace-api/dma-buf-alloc-exchange.rst，了解DMA-BUF如何在DRM中集成和暴露的相关信息。
