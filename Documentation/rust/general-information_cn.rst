SPDX 许可证标识符: GPL-2.0

通用信息
===================

本文件包含在内核中使用 Rust 支持时需要了解的一些有用信息。

代码文档
------------------

Rust 内核代码使用 ``rustdoc`` 进行文档化，这是其内置的文档生成器。
生成的 HTML 文档包括集成搜索、链接项（例如类型、函数、常量）、源代码等。可以在以下位置查看这些文档（待主线合并并在其他文档旁一并生成）：

	http://kernel.org/

也可以在本地轻松生成和阅读这些文档。这非常快速（与编译代码本身的时间相当），并且不需要任何特殊工具或环境。这样还有一个额外的好处，即它们将针对所使用的特定内核配置进行定制。要生成它们，请使用与编译相同的调用方式加上 ``rustdoc`` 目标，例如：

	make LLVM=1 rustdoc

要在本地浏览器中阅读文档，请运行如下命令：

	xdg-open Documentation/output/rust/rustdoc/kernel/index.html

关于如何编写文档，请参阅 `coding-guidelines.rst`。

额外的 lint 工具
-------------------

尽管 ``rustc`` 是一个非常有用的编译器，但还可以通过 ``clippy``（一个 Rust linter）获得一些额外的 lint 和分析功能。要启用它，请向用于编译的相同调用传递 ``CLIPPY=1``，例如：

	make LLVM=1 CLIPPY=1

请注意，Clippy 可能会改变代码生成，因此在构建生产内核时不应启用它。

抽象 vs. 绑定
-------------------------

抽象是 Rust 代码封装内核的 C 侧功能。
为了使用 C 侧的函数和类型，需要创建绑定。
绑定是 C 侧那些函数和类型的 Rust 声明。
例如，可以编写一个 Rust 的 ``Mutex`` 抽象，该抽象包装了 C 侧的 ``struct mutex`` 并通过绑定调用其函数。
并非所有的内核内部 API 和概念都有对应的抽象，但计划随着时间推移扩展覆盖范围。“叶”模块（如驱动程序）不应直接使用 C 绑定。相反，子系统应根据需要提供尽可能安全的抽象。

.. code-block::

	                                                rust/bindings/
	                                               (rust/helpers.c)

	                                                   include/ -----+ <-+
	                                                                 |   |
	  drivers/              rust/kernel/              +----------+ <-+   |
	    fs/                                           | bindgen  |       |
	   .../            +-------------------+          +----------+ --+   |
	                   |    Abstractions   |                         |   |
	+---------+        | +------+ +------+ |          +----------+   |   |
	| my_foo  | -----> | | foo  | | bar  | | -------> | Bindings | <-+   |
	| driver  |  Safe  | | sub- | | sub- | |  Unsafe  |          |       |
	+---------+        | |system| |system| |          | bindings | <-----+
	     |             | +------+ +------+ |          |  crate   |       |
	     |             |   kernel crate    |          +----------+       |
	     |             +-------------------+                             |
	     |                                                               |
	     +------------------# FORBIDDEN #--------------------------------+

主要思想是将所有直接与内核 C API 交互的部分封装到经过仔细审查和文档化的抽象中。这样，只要满足以下条件，使用这些抽象的用户就不会引入未定义行为（UB）：

1. 抽象是正确的（“sound”的）。
#. 任何 ``unsafe`` 块遵守调用块内操作所需的安全契约。同样，任何 ``unsafe impl`` 也遵守实现该特质所需的安全契约。

绑定
~~~~~~

通过将 ``include/`` 目录中的 C 头文件包含到 ``rust/bindings/bindings_helper.h`` 中，``bindgen`` 工具会自动生成所包含子系统的绑定。构建后，请参阅 ``rust/bindings/`` 目录中的 ``*_generated.rs`` 输出文件。
对于 ``bindgen`` 无法自动生成的 C 头文件部分（例如 C 的 ``inline`` 函数或复杂的宏），可以在 ``rust/helpers.c`` 中添加一个小的包装函数，以便在 Rust 端也可使用。

抽象
~~~~~~

抽象是绑定与内核用户之间的层。它们位于 ``rust/kernel/`` 目录下，其作用是将对绑定的不安全访问封装进一个尽可能安全的 API 中，并将其暴露给用户。抽象的用户包括用 Rust 编写的驱动程序或文件系统等。

除了安全性方面外，抽象还应该具有“易用性”，即它们将 C 接口转换为“惯用”的 Rust 代码。基本的例子包括将 C 资源获取和释放转换为 Rust 的构造函数和析构函数，或将 C 的整型错误码转换为 Rust 的 ``Result`` 类型。

条件编译
---------

Rust 代码可以根据内核配置进行条件编译：

.. code-block:: rust

	#[cfg(CONFIG_X)]       // 已启用               (`y` 或 `m`)
	#[cfg(CONFIG_X="y")]   // 作为内置启用         (`y`)
	#[cfg(CONFIG_X="m")]   // 作为模块启用         (`m`)
	#[cfg(not(CONFIG_X))]  // 未启用
