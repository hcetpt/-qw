======  
usbmon  
======  

简介
============  

"usbmon"（小写）指的是内核中的一项功能，用于收集USB总线上的I/O跟踪记录。这一功能类似于被诸如tcpdump(1)或Ethereal这样的网络监控工具所使用的包套接字。同样地，预期会有一种工具如usbdump或USBMon（大写字母）用来查看由usbmon产生的原始跟踪记录。  
usbmon报告外围设备特定驱动程序向主机控制器驱动程序（HCD）发出的请求。因此，如果HCD存在问题，usbmon报告的跟踪记录可能不会精确对应于总线上的交易。这与tcpdump的情况相同。  
目前实现了两种API：“文本”和“二进制”。二进制API可通过/dev命名空间中的字符设备访问，并且是一种应用程序二进制接口（ABI）。  
文本API自2.6.35版本起已废弃，但为了方便仍然可用。  
如何使用usbmon来收集原始文本跟踪记录
============================================  

与包套接字不同，usbmon有一个提供文本格式跟踪记录的接口。这用于两个目的。首先，它作为工具间通用的跟踪交换格式，而更复杂的格式还在最终确定中。其次，在没有工具可用的情况下，人类可以阅读这些记录。  
要收集原始文本跟踪记录，请执行以下步骤：  
1. 准备
----------

挂载debugfs（必须在你的内核配置中启用），并加载usbmon模块（如果它是作为一个模块构建的）。如果usbmon是构建到内核中的，则跳过第二步：  

```bash
# mount -t debugfs none /sys/kernel/debug
# modprobe usbmon
# 
```

验证总线套接字是否存在：  

```bash
# ls /sys/kernel/debug/usb/usbmon
0s  0u  1s  1t  1u  2s  2t  2u  3s  3t  3u  4s  4t  4u
#
```

现在你可以选择使用套接字'0u'（捕获所有总线上的数据包），并跳到步骤#3，或者通过步骤#2找到你设备所在的总线。这样可以过滤掉那些持续通信的烦人设备。
2. 确定连接目标设备的总线
--------------------------------

运行"cat /sys/kernel/debug/usb/devices"，并找到对应于该设备的T行。通常你可以通过查找供应商字符串来做到这一点。如果你有很多类似的设备，可以拔掉一个然后比较两次/sys/kernel/debug/usb/devices输出。T行将包含一个总线编号。例如：  

```bash
T:  Bus=03 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=12  MxCh= 0
D:  Ver= 1.10 Cls=00(>ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
P:  Vendor=0557 ProdID=2004 Rev= 1.00
S:  Manufacturer=ATEN
S:  Product=UC100KM V2.00
```

"Bus=03"表示这是总线3。或者，你可以查看"lsusb"的输出，并从相应的行获取总线编号。示例：

```bash
Bus 003 Device 002: ID 0557:2004 ATEN UC100KM V2.00
```

3. 开始'cat'
--------------

```bash
# cat /sys/kernel/debug/usb/usbmon/3u > /tmp/1.mon.out
```

监听单个总线，或者，要监听所有总线，输入：  

```bash
# cat /sys/kernel/debug/usb/usbmon/0u > /tmp/1.mon.out
```

此过程将持续读取直到被终止。当然，输出可以重定向到所需位置。这是优选的做法，因为输出将会非常长。
4. 在USB总线上执行所需的操作
-----------------------------------------------

在此步骤中，您需要进行一些操作以产生数据传输：例如插入闪存盘、复制文件、控制网络摄像头等。
5. 终止cat程序
-----------

通常通过键盘中断（如 Control-C）来完成。
此时可以保存输出文件（在本例中为 /tmp/1.mon.out），通过电子邮件发送，或者使用文本编辑器查看。如果是使用文本编辑器查看，请确保文件大小不会超出您常用编辑器的处理范围。
原始文本数据格式
====================

目前支持两种格式：原始格式（或称为‘1t’格式）和‘1u’格式。在内核版本2.6.21中，‘1t’格式已被弃用。‘1u’格式添加了一些字段，例如ISO帧描述符、间隔等。这使得每行数据稍长一些，但除此之外，它完全兼容于‘1t’格式。
如果希望在程序中区分这两种格式，可以查看“地址”字（见下文），其中‘1u’格式增加了一个总线编号。如果存在两个冒号，则表示为‘1t’格式；否则为‘1u’格式。
任何文本格式的数据都由一系列事件组成，如URB提交、URB回调、提交错误等。每个事件都是一行文本，由空格分隔的单词构成。单词的数量或位置可能取决于事件类型，但是有一组单词是所有类型的共有的。
以下是这些单词的列表，从左至右：

- URB 标签。用于标识URB，通常是URB结构在内核中的地址（以十六进制表示），也可以是一个序列号或其他任何合理的唯一字符串。
- 微秒级别的时间戳，一个十进制数字。时间戳的精度取决于可用的时钟源，因此实际上可能会比微秒级差很多（例如，如果实现使用了滴答计数）。
- 事件类型。此处的类型是指事件的格式，而不是URB的类型。
可用的类型包括：S - 提交，C - 回调，E - 提交错误
- "地址"一词（以前称为“管道”）。它由四个字段组成，用冒号分隔：URB 类型和方向、总线编号、设备地址、端点编号。
类型和方向用两个字节以以下方式编码：

    == ==   =============================
    Ci Co   控制输入和输出
    Zi Zo   同步输入和输出
    Ii Io   中断输入和输出
    Bi Bo   大批量输入和输出
    == ==   =============================

总线编号、设备地址以及端点编号是十进制数字，但为了便于人类阅读，它们可能会有前导零。
- URB 状态词。这可以是一个字母或几个用冒号分隔的数字：URB 状态、间隔、开始帧数、错误计数。与“地址”词不同，除了状态以外的所有字段都是可选的。仅在中断和同步URB中打印间隔。仅在同步URB中打印开始帧数。仅在同步回调事件中打印错误计数。
状态字段是一个有时为负数的十进制数字，代表URB的状态字段。此字段对于提交而言没有意义，但仍存在以帮助脚本进行解析。当发生错误时，该字段包含错误代码。
在提交控制数据包的情况下，此字段包含Setup Tag而非一组数字。很容易判断Setup Tag是否存在，因为它永远不会是一个数字。因此，如果脚本在此词中找到一组数字，则继续读取数据长度（除了同步URB之外）；
如果他们发现其他内容，如一个字母，则先读取设置数据包，然后再读取数据长度或同步描述符。
- 如果存在，设置数据包由5个词组成：分别为bmRequestType、bRequest、wValue、wIndex、wLength，具体由USB规范2.0指定。
这些词可以在Setup Tag为's'时安全解码。否则，设置数据包存在但未被捕获，字段中包含填充信息。
- 同步帧描述符的数量及其本身。
如果一个等时传输事件有一组描述符，则首先打印在URB中的这些描述符的总数，然后每个描述符打印一个词，最多打印5个。这个词由3个以冒号分隔的十进制数字组成，分别表示状态、偏移量和长度。对于提交，报告初始长度。对于回调，报告实际长度。
- 数据长度。对于提交，这是请求的长度。对于回调，这是实际长度。
- 数据标签。即使长度非零，`usbmon`也不一定总是捕获数据。只有当此标签为'='时，数据词才存在。
- 数据词以大端十六进制格式跟随。请注意，它们不是机器词，而是真正只是按词分割的字节流，以便于阅读。因此，最后一个词可能包含从1到4个字节。
收集的数据长度是有限的，并且可以小于“数据长度”词中报告的数据长度。在等时输入（Zi）完成的情况下，如果接收到的数据在缓冲区中稀疏分布，则收集的数据长度可以大于数据长度值（因为数据长度仅计算接收到的字节数，而数据词包含整个传输缓冲区）。
示例：

获取端口状态的输入控制传输示例：

```
d5ea89a0 3575914555 S Ci:1:001:0 s a3 00 0000 0003 0004 4 <
d5ea89a0 3575914560 C Ci:1:001:0 0 4 = 01050000
```

向地址为5的存储设备发送SCSI命令0x28（READ_10）的输出批量传输，在31字节批量包装中：

```
dd65f0e8 4128379752 S Bo:1:005:2 -115 31 = 55534243 ad000000 00800000 80010a28 20000000 20000040 00000000 000000
dd65f0e8 4128379808 C Bo:1:005:2 0 31 >
```

二进制格式和API
=================

API的整体架构与上述相似，只是事件是以二进制格式传递的。每个事件都以以下结构发送（其名称是编造的，以便我们能够引用它）：

```c
struct usbmon_packet {
  u64 id;          /*  0: URB ID - from submission to callback */
  unsigned char type;  /*  8: 同文本；可扩展。 */
  unsigned char xfer_type; /*    等时 (0)，中断，控制，批量 (3) */
  unsigned char epnum;   /*     端点编号和传输方向 */
  unsigned char devnum;  /*     设备地址 */
  u16 busnum;        /* 12: 总线编号 */
  char flag_setup;   /* 14: 同文本 */
  char flag_data;    /* 15: 同文本；二进制零也是有效的。 */
  s64 ts_sec;        /* 16: gettimeofday */
  s32 ts_usec;       /* 24: gettimeofday */
  int status;        /* 28: */
  unsigned int length;  /* 32: 数据长度（提交或实际） */
  unsigned int len_cap; /* 36: 交付长度 */
  union {           /* 40: */
    unsigned char setup[SETUP_LEN]; /* 仅用于控制S型 */
    struct iso_rec {      /* 仅用于ISO */
      int error_count;
      int numdesc;
    } iso;
  } s;
  int interval;     /* 48: 仅用于中断和ISO */
  int start_frame;  /* 52: 仅用于ISO */
  unsigned int xfer_flags; /* 56: URB的transfer_flags的副本 */
  unsigned int ndesc;     /* 60: 实际的ISO描述符数量 */
};                  /* 64 总长度 */
```

可以通过使用read(2)、ioctl(2)或通过mmap访问缓冲区来从字符设备接收这些事件。然而，由于兼容性原因，read(2)仅返回前48字节。
通常，该字符设备被称为/dev/usbmonN，其中N是USB总线编号。编号零(/dev/usbmon0)是特殊的，意味着“所有总线”。
请注意，具体的命名策略由您的Linux发行版设置。
如果您手动创建/dev/usbmon0，请确保它属于root并且模式为0600。否则，非特权用户将能够窥探键盘流量。
以下 ioctl 调用可用，其魔法值 MON_IOC_MAGIC 为 0x92：

- MON_IOCQ_URB_LEN，定义为 _IO(MON_IOC_MAGIC, 1)

此调用返回下一个事件中的数据长度。请注意，大多数事件不包含数据，因此如果此调用返回零，并不意味着没有可用的事件。
- MON_IOCG_STATS，定义为 _IOR(MON_IOC_MAGIC, 3, struct mon_bin_stats)

参数是指向以下结构体的指针：

```c
  struct mon_bin_stats {
	u32 queued;
	u32 dropped;
  };
```

成员 "queued" 指的是当前在缓冲区中排队的事件数量（而不是自上次重置以来处理过的事件数量）。成员 "dropped" 是自上次调用 MON_IOCG_STATS 以来丢失的事件数量。
- MON_IOCT_RING_SIZE，定义为 _IO(MON_IOC_MAGIC, 4)

此调用设置缓冲区大小。参数是以字节为单位的大小。
所请求的大小可能会向下舍入到最近的块（或页）。如果请求的大小超出了内核的未指定范围，则调用会以 -EINVAL 错误失败。
- MON_IOCQ_RING_SIZE，定义为 _IO(MON_IOC_MAGIC, 5)

此调用返回当前缓冲区的大小（以字节为单位）。
- MON_IOCX_GET，定义为 _IOW(MON_IOC_MAGIC, 6, struct mon_get_arg)
- MON_IOCX_GETX，定义为 _IOW(MON_IOC_MAGIC, 10, struct mon_get_arg)

这些调用会在内核缓冲区中没有事件时等待事件到来，然后返回第一个事件。参数是指向以下结构体的指针：

```c
  struct mon_get_arg {
	struct usbmon_packet *hdr;
	void *data;
	size_t alloc;       /* 数据的长度（可以为零） */
  };
```

调用之前，hdr、data 和 alloc 应该被填充。返回时，hdr 所指向的区域包含了下一个事件的结构，而数据缓冲区则包含了数据（如果有）。事件将从内核缓冲区移除。
MON_IOCX_GET 将 48 字节复制到 hdr 区域，而 MON_IOCX_GETX 复制 64 字节。
- MON_IOCX_MFETCH，定义为 _IOWR(MON_IOC_MAGIC, 7, struct mon_mfetch_arg)

当应用程序通过 mmap(2) 访问缓冲区时，主要使用此 ioctl。它的参数是指向以下结构体的指针：

```c
  struct mon_mfetch_arg {
	uint32_t *offvec;   /* 获取事件的偏移量向量 */
	uint32_t nfetch;    /* 需要获取的事件数（返回实际获取的事件数） */
	uint32_t nflush;    /* 需要清除的事件数 */
  };
```

ioctl 分三个阶段操作：
首先，它从内核缓冲区中移除并丢弃最多 nflush 个事件。
实际被丢弃的事件数量存储在 `nflush` 中。
其次，如果伪设备不是以 `O_NONBLOCK` 方式打开，则它会等待缓冲区中有事件出现。
第三，它最多提取 `nfetch` 个偏移量到 `mmap` 缓冲区中，并将它们存储到 `offvec` 中。实际的事件偏移量数量则存储到 `nfetch` 中。
`MON_IOCH_MFLUSH` 被定义为 `_IO(MON_IOC_MAGIC, 8)`。

此调用从内核缓冲区中移除一定数量的事件。其参数是要移除的事件数量。如果缓冲区中的事件少于请求的数量，则会移除所有存在的事件，并且不会报告错误。
即使没有可用的事件时这也适用。
`FIONBIO`

`FIONBIO` 的 `ioctl` 可能在将来实现，如果有需要的话。
除了 `ioctl(2)` 和 `read(2)`，二进制API的特殊文件还可以通过 `select(2)` 和 `poll(2)` 进行轮询。但是 `lseek(2)` 不起作用。
* 对二进制 API 的内核缓冲区进行内存映射访问

基本思想很简单：

首先，通过获取当前大小并使用 `mmap(2)` 来映射缓冲区。
然后，执行一个类似于下面伪代码所示的循环：

```c
   struct mon_mfetch_arg fetch;
   struct usbmon_packet *hdr;
   int nflush = 0;
   for (;;) {
      fetch.offvec = vec; // 包含 N 个32位字
      fetch.nfetch = N;   // 或者少于 N
      fetch.nflush = nflush;
      ioctl(fd, MON_IOCX_MFETCH, &fetch);   // 处理错误等
      nflush = fetch.nfetch;       // 完成时要丢弃这么多的数据包
      for (i = 0; i < nflush; i++) {
         hdr = (struct usbmon_packet *)(&mmap_area[vec[i]]);
         if (hdr->type == '@')     // 填充数据包
            continue;
         caddr_t data = &mmap_area[vec[i]] + 64;
         process_packet(hdr, data);
      }
   }
```

因此，主要的想法是在 N 个事件中只执行一次 `ioctl`。
尽管缓冲区是循环的，但返回的头部和数据不会跨越缓冲区的结尾，所以上述伪代码不需要任何数据收集处理。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
