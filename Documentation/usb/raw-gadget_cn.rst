=================
USB 原始设备
=================

USB 原始设备是一个设备驱动程序，它为用户空间提供了对设备通信过程的低级别控制。
与其他设备驱动程序一样，原始设备通过 USB 设备 API 实现 USB 设备。与大多数设备驱动程序不同的是，原始设备本身不实现任何具体的 USB 功能，而是要求用户空间来完成这些功能。目前，原始设备严格来说仅作为一个调试特性，不应该在生产环境中使用。建议使用 GadgetFS。
启用 CONFIG_USB_RAW_GADGET 配置项
与 GadgetFS 的比较
~~~~~~~~~~~~~~~~~~~~~~

原始设备与 GadgetFS 类似，但为用户空间提供了更直接访问 USB 设备层的方式。主要区别在于：

1. 原始设备将每个 USB 请求传递给用户空间以获取响应，而 GadgetFS 会根据提供的描述符对某些 USB 请求进行内部响应。需要注意的是，USB 设备控制器（UDC）驱动可能会自行响应某些请求，并且不会将这些请求转发到设备层。
2. 原始设备允许提供任意数据作为对 USB 请求的响应，而 GadgetFS 对提供的 USB 描述符执行合理性检查。
这使得原始设备适用于通过提供错误的数据作为对 USB 请求的响应来进行模糊测试。
3. 原始设备提供了一种选择绑定的 UDC 设备/驱动程序的方法，而 GadgetFS 目前只会绑定到第一个可用的 UDC。这样可以实现在不同的 UDC 上绑定多个原始设备实例。
4. 原始设备明确地暴露了关于端点地址和能力的信息。这使得用户能够编写与 UDC 无关的设备。
5. 原始设备使用基于 ioctl 的接口，而不是基于文件系统的接口。
用户空间接口
~~~~~~~~~~~~~~

用户可以通过打开 `/dev/raw-gadget` 并发出 ioctl 调用来与 Raw Gadget 进行交互；有关详细信息，请参阅 `include/uapi/linux/usb/raw_gadget.h` 中的注释。可以同时使用多个 Raw Gadget 实例（绑定到不同的 UDC）。Raw Gadget 的典型使用场景如下：

1. 通过打开 `/dev/raw-gadget` 创建一个 Raw Gadget 实例
2. 通过 `USB_RAW_IOCTL_INIT` 初始化该实例
3. 使用 `USB_RAW_IOCTL_RUN` 启动该实例
4. 在循环中发出 `USB_RAW_IOCTL_EVENT_FETCH` 来接收来自 Raw Gadget 的事件，并根据需要实现的 USB 设备类型作出反应
请注意，某些 UDC 驱动程序为端点分配了固定地址，因此不能在描述符中使用任意端点地址。尽管如此，Raw Gadget 提供了一种与 UDC 无关的方式来编写 USB 设备。一旦通过 `USB_RAW_IOCTL_EVENT_FETCH` 收到 `USB_RAW_EVENT_CONNECT` 事件，就可以使用 `USB_RAW_IOCTL_EPS_INFO` 来获取 UDC 驱动程序所支持的端点信息。基于这些信息，用户空间必须为设备选择合适的 UDC 端点，并在相应的端点描述符中分配地址。

Raw Gadget 的使用示例和测试套件：

https://github.com/xairy/raw-gadget

内部细节
~~~~~~~~~

每个 Raw Gadget 端点的读/写 ioctl 都会提交一个 USB 请求并等待其完成。这样做是特意为之，目的是通过单个系统调用就能完全处理一个 USB 请求，从而有助于基于覆盖度的模糊测试。这一特性必须在实现中保留。

潜在的未来改进
~~~~~~~~~~~~~~~~

- 支持 `O_NONBLOCK` I/O。这将是一种新的运行模式，在这种模式下，Raw Gadget 不会等待每个 USB 请求的完成。
- 支持USB 3功能（在启用端点时接受SS端点伴侣描述符；允许为批量传输提供`stream_id`）
- 支持ISO传输功能（为已完成的请求暴露`frame_number`）
