EHCI 驱动
==========

2002年12月27日

EHCI 驱动用于与高速 USB 2.0 设备通信，这些设备使用的是支持 USB 2.0 的主机控制器硬件。USB 2.0 标准与 USB 1.1 标准兼容。它定义了三种传输速度：

    - “高速” 480 Mbit/秒（60 M字节/秒）
    - “全速” 12 Mbit/秒（1.5 M字节/秒）
    - “低速” 1.5 Mbit/秒

USB 1.1 只涉及全速和低速。高速设备可以在 USB 1.1 系统上使用，但它们会降速到 USB 1.1 的速度。USB 1.1 设备也可以在 USB 2.0 系统上使用。当插入 EHCI 控制器时，它们会被交给 USB 1.1 “伴生” 控制器处理，这通常是一个 OHCI 或 UHCI 控制器，用于处理此类设备。当 USB 1.1 设备插入 USB 2.0 集线器时，它们通过集线器中的“事务转换器”(TT) 与 EHCI 控制器交互，将低速或全速的事务转换为高速的“分段事务”，以避免浪费传输带宽。

到目前为止，此驱动已知可以与来自以下厂商的 EHCI 实现一起工作（按字母顺序排列）：Intel、NEC、Philips 和 VIA。其他厂商也提供了其他的 EHCI 实现；您应该期望此驱动也能与它们兼容。

尽管自 2001 年中期以来已有 USB 存储设备可用（在该驱动的 2.4 版本上运行得相当快），但集线器直到 2001 年末才开始出现，而其他类型的高速设备似乎要等到更多系统内置 USB 2.0 后才会普及。这样的新系统自 2002 年初就已面世，并且在 2002 年下半年变得更加普遍。

请注意，USB 2.0 支持不仅仅涉及到 EHCI。它还需要对 Linux-USB 核心 API 进行其他更改，包括集线器驱动程序，但是这些更改不需要真正改变对 USB 设备驱动程序公开的基本“usbcore”API。

- David Brownell
  <dbrownell@users.sourceforge.net>

功能
======

此驱动定期在 x86 硬件上进行测试，并且也在 PPC 硬件上使用过，因此大端/小端问题应该已经被解决。据信，它能够正确地执行所有必要的 PCI 魔术操作，使得 I/O 即使在具有复杂 DMA 映射问题的系统上也能正常工作。

传输类型
-----------

目前，该驱动应该能够舒适地处理所有的控制、批量和中断传输，包括通过 USB 2.0 集线器中的事务转换器 (TT) 对 USB 1.1 设备的请求。不过，您可能会发现一些 bug。
高速等时（ISO）传输支持也是可用的，但在本文档撰写之时，尚无 Linux 驱动程序使用该支持。通过事务转换器实现的全速等时传输支持目前还不可用。请注意，对于 ISO 传输的分割事务支持无法与高速 ISO 传输的代码共享太多，因为 EHCI 使用不同的数据结构来表示这些内容。因此，目前大多数 USB 音频和视频设备都无法连接到高速总线上。

### 驱动行为

所有类型的传输都可以排队。这意味着来自一个接口（或通过 usbfs）的一个驱动程序的控制传输不会干扰另一个驱动程序的控制传输，并且中断传输可以利用一帧中的某个周期，而不用担心因中断处理开销导致的数据丢失。

EHCI 根集线器代码将 USB 1.1 设备交给其配套控制器处理。此驱动程序不需要了解那些驱动程序；已经工作的 OHCI 或 UHCI 驱动程序不需要因为 EHCI 驱动程序的存在而做出改变。

存在一些电源管理方面的问题；挂起/恢复功能目前表现得不太正确。

此外，在调度周期性事务（中断和等时传输）时采取了一些捷径。这限制了可调度的周期性事务的数量，并且阻止了使用小于一帧的轮询间隔。

### 使用方法

假设你有一个 EHCI 控制器（位于 PCI 卡或主板上），并且已将此驱动程序编译为模块，你可以像下面这样加载它：

```
# modprobe ehci-hcd
```

移除它的方式是：

```
# rmmod ehci-hcd
```

你还应该拥有一个“配套控制器”的驱动程序，例如 “ohci-hcd” 或 “uhci-hcd”。如果遇到任何 EHCI 驱动程序的问题，可以移除它的模块，然后该配套控制器的驱动程序将以较低的速度接管之前由 EHCI 驱动程序处理的所有设备。

### 模块参数（传递给“modprobe”）

- `log2_irq_thresh`（默认值 0）：
  默认中断延迟的日志值（以微帧为单位）。默认值为 0，表示 1 微帧（125 微秒）。最大值为 6，表示 2^6 = 64 微帧。这控制了 EHCI 控制器发出中断的频率。

如果你在 2.5 内核中使用此驱动程序，并且启用了 USB 调试支持，你会在任何 EHCI 控制器的“sysfs”目录下看到三个文件：

- `"async"`
  显示异步调度，用于控制和批量传输。显示每个活动的 QH 和待处理的 QTD，通常每个 URB 有一个 QTD。（当 usb-storage 进行磁盘 I/O 时查看它；观察请求队列！）
- `"periodic"`
  显示周期性调度，用于中断和等时传输。不显示 QTD。
- `"registers"`
  显示控制器寄存器的状态，

这些文件的内容可以帮助识别驱动程序问题。
设备驱动程序不应该关心它们是否运行在EHCI上，
但它们可能想要检查 "usb_device->speed == USB_SPEED_HIGH"
高速设备可以做一些全速（或低速）设备无法做的事情，
例如“高带宽”周期性（中断或ISO）传输。
此外，当以高速运行时，设备描述符中的一些值（如周期性传输的轮询间隔）
使用不同的编码方式。
然而，请务必通过USB 2.0集线器测试设备驱动程序。
这些集线器在使用交易转换器时会以不同的方式报告一些故障，例如断开连接；
有些驱动程序在看到与OHCI或UHCI报告的不同错误时表现不佳。

性能
=====

USB 2.0的吞吐量受到两个主要因素的限制：主机控制器处理请求的速度以及设备响应请求的速度。
所有设备都遵守480 Mbps的“原始传输速率”，但总体吞吐量也受到诸如高速数据包之间的延迟、驱动程序智能和整体系统负载等因素的影响。延迟也是一个性能问题。
批量传输主要用于关注吞吐量的场景。需要注意的是，批量传输始终是以512字节的数据包进行，且在一个USB 2.0微帧内最多能容纳13个这样的数据包。八个USB 2.0微帧组成一个USB 1.1帧；一个微帧为1毫秒/8 = 125微秒。
因此，当硬件和设备驱动软件允许的情况下，批量传输可以获得超过50 MB/秒的速度。周期性传输模式（等时性和中断）允许更大的数据包大小，这使得接近480 Mbps的传输率成为可能。

硬件性能
---------

目前，单个USB 2.0设备的传输率通常达到约20 MB/秒。这当然可能会发生变化；
一些设备现在可以更快，而另一些则更慢。
最初的NEC EHIC实现似乎在大约28 MB/秒的总传输率处存在硬件瓶颈。虽然这对于单一20 MB/秒的设备来说已经足够，但将三个这样的设备放在同一总线上并不能得到60 MB/秒的传输率。问题似乎在于控制器硬件不能同时执行USB和PCI访问，
因此每个微帧仅尝试六次（或者可能是七次）USB事务，而不是十三次。（对于一款领先市场一年以上的产品而言，这似乎是合理的折衷！）

预计新的实现将在这方面有所改进，通过投入更多的硅资源来解决问题，以便新的主板芯片组能够更接近60 MB/秒的目标。这包括来自NEC的更新实现以及其他供应商的硅产品。
主机从EHCI控制器接收中断指示请求完成的最小延迟为一个微帧（125 微秒）。该延迟是可以调整的；有一个模块选项。默认情况下，ehci-hcd 驱动程序使用最小延迟，这意味着如果你发出控制或批量请求，通常可以在不到 250 微秒的时间内（取决于传输大小）得知请求已完成。
### 软件性能

为了达到甚至超过 20 MB/秒的传输速率，Linux-USB 设备驱动程序需要保持 EHCI 队列满载。这意味着需要发出大的请求，或者如果需要发出一系列小请求，则使用批量队列。当驱动程序没有这样做时，其性能结果就会受到影响。
在典型情况下，一个使用 usb_bulk_msg() 循环写入 4 KB 数据块的过程会浪费超过一半的 USB 2.0 带宽。在 I/O 完成与驱动程序发出下一个请求之间的延迟将比 I/O 时间更长。如果这个循环使用 16 KB 的数据块，情况会有所改善；而使用 128 KB 数据块序列则会大大减少浪费。
但与其依赖如此大的 I/O 缓冲区来提高同步 I/O 的效率，更好的做法是向主机控制器队列中添加多个（批量）请求，并等待所有请求完成（或在出错时取消）。
这种 URB 队列处理方式也适用于所有的 USB 1.1 主机控制器驱动程序。
在 Linux 2.5 内核中，定义了新的 usb_sg_*() API 调用；它们可以将来自分散列表的所有缓冲区进行队列化。它们还使用分散列表 DMA 映射（可能应用 IOMMU）和中断降低，这些都将有助于高速传输以最快的速度运行。
#### 待定：
   - 中断和 ISO 传输性能问题。这些周期性传输是完全调度的，因此主要问题可能是如何触发“高带宽”模式。
#### 待定：
   - 可通过 sysfs 中的 uframe_periodic_max 参数分配超过标准 80% 的周期性带宽。对此进行描述。
