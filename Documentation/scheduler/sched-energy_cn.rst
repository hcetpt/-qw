=======================
节能调度
=======================

1. 引言
---------------

节能调度（或称EAS）赋予调度器预测其决策对CPU能耗影响的能力。EAS依赖于CPU的能源模型（EM），选择每个任务的能效最高的CPU，同时对吞吐量的影响最小。本文档旨在介绍EAS的工作原理、其主要设计决策，并详细说明如何运行它。
在进一步讨论之前，请注意，在撰写本文时：

   /!\ EAS不支持具有对称CPU拓扑结构的平台 /!\

EAS仅在异构CPU拓扑结构（如Arm big.LITTLE）上运行，因为这是通过调度节省能源潜力最大的地方。
实际使用的EM不由调度器维护，而是由专用框架维护。有关该框架及其提供的功能的详细信息，请参阅其文档（见Documentation/power/energy-model.rst）。

2. 背景与术语
--------------

首先明确以下定义：
 - 能源 = [焦耳]（如电池等供电设备上的资源）
 - 功率 = 能源/时间 = [焦耳/秒] = [瓦特]

EAS的目标是在完成任务的同时尽量减少能耗。也就是说，我们希望最大化：

	性能 [指令/秒]
	--------------------
	    功率 [瓦]

这相当于最小化：

	能耗 [焦耳]
	-----------
	指令

同时仍保持“良好”的性能。这基本上是调度器当前仅关注性能目标的一个替代优化目标。这个替代目标考虑了两个目标：能效和性能。
引入EM的想法是让调度器能够评估其决策的影响，而不是盲目应用可能仅在某些平台上有效的节能技术。同时，EM必须尽可能简单以最小化调度器延迟的影响。
简而言之，EAS改变了CFS任务分配给CPU的方式。当调度器需要决定任务应在何处运行（在唤醒时），EM用于打破几个合适CPU候选者之间的平衡，并选择预测能耗最低且不影响系统吞吐量的CPU。EAS所做的预测依赖于关于平台拓扑结构的特定知识，包括CPU的“容量”及其各自的能耗成本。

3. 拓扑信息
-------------

EAS（以及调度器的其余部分）使用“容量”的概念来区分具有不同计算吞吐量的CPU。“容量”表示CPU在其最高频率下运行时所能吸收的工作量，相对于系统中最强大的CPU。容量值被归一化为1024范围，并且与通过Per-Entity Load Tracking（PELT）机制计算的任务和CPU利用率信号可比较。借助容量和利用率值，EAS能够估计任务/CPU的大小/繁忙程度，并在评估性能与能耗权衡时考虑这一点。CPU的容量通过架构特定代码通过arch_scale_cpu_capacity()回调提供。
EAS使用的其余平台知识直接从EM框架读取。一个平台的EM由系统中每个“性能域”的功耗成本表组成（有关性能域的更多详细信息，请参见Documentation/power/energy-model.rst）。
当构建或重新构建调度域时，调度器在拓扑代码中管理EM对象的引用。对于每个根域（rd），调度器维护一个与当前rd->span相交的所有性能域的单链表。列表中的每个节点包含指向由EM框架提供的struct em_perf_domain的指针。
这些列表附加到根域，以便处理独占cpuset配置。由于独占cpuset的边界不一定与性能域的边界匹配，因此不同根域的列表可以包含重复元素。
示例 1
假设一个平台有 12 个 CPU，分为 3 个性能域（pd0、pd4 和 pd8），其组织结构如下：

		CPUs:   0 1 2 3 4 5 6 7 8 9 10 11
		PDs:   |--pd0--|--pd4--|---pd8---|
		RDs:   |----rd1----|-----rd2-----|

现在，假设用户空间决定将系统分割为两个互斥的 cpuset，从而创建了两个独立的根域，每个根域包含 6 个 CPU。这两个根域在上图中分别标记为 rd1 和 rd2。由于 pd4 与 rd1 和 rd2 都有交集，因此它会出现在连接到它们各自链表中的 '->pd' 中：

       * rd1->pd: pd0 -> pd4
       * rd2->pd: pd4 -> pd8

请注意，调度器会为 pd4 创建两个重复的列表节点（每个列表一个）。然而，这两个节点都指向同一个 EM 框架共享的数据结构。
由于这些列表可能会与热插拔和其他操作并发访问，因此它们受到 RCU 的保护，就像调度器操作的其他拓扑结构一样。
EAS 还维护一个静态键（sched_energy_present），当至少有一个根域满足所有启动 EAS 的条件时，该键被启用。这些条件在第 6 节中有概述。
4. 能效感知的任务放置
--------------------------------

EAS 覆盖了 CFS 任务唤醒平衡代码。它使用平台的 EM 和 PELT 信号，在唤醒平衡期间选择一个能效高的目标 CPU。当 EAS 启用时，select_task_rq_fair() 会调用 find_energy_efficient_cpu() 来做放置决策。此函数会在每个性能域中寻找具有最高空闲容量（CPU 容量 - CPU 利用率）的 CPU，因为这将使我们能够保持最低的频率。然后，该函数检查将任务放置在那里是否比将其留在 prev_cpu 上更节能，即任务在其前一次激活时运行的 CPU。
find_energy_efficient_cpu() 使用 compute_energy() 来估计如果唤醒任务迁移后系统将消耗的能量。compute_energy() 查看当前的 CPU 利用率分布，并对其进行调整以“模拟”任务迁移。EM 框架提供了 em_pd_energy() API，该 API 可计算给定利用率分布下每个性能域预期的能量消耗。
下面详细说明了一个能效优化的任务放置决策示例。
示例 2
假设一个（假想的）平台有两个独立的性能域，每个域包含两个 CPU。CPU0 和 CPU1 是小核；CPU2 和 CPU3 是大核。
调度器必须决定如何放置一个任务 P，其 util_avg = 200 且 prev_cpu = 0。
当前CPU的利用率情况如下面图表所示：
```
CPU利用率
1024                 - - - - - - -              能量模型
                                               +-----------+-------------+
                                               |  Little   |     Big     |
                                               +-----+-----+------+------+
                                               | 容量 | 功率 | 容量 | 功率 |
                                               +-----+-----+------+------+
       768                 =============       | 170  | 50  | 512  | 400  |
                             ##     ##         | 341  | 150 | 768  | 800  |
       512  ===========    - ##- - - - -       | 512  | 300 | 1024 | 1700 |
                             ##     ##         +-----+-----+------+------+
       341  -PP - - - -      ##     ##
             PP              ##     ##
       170  -## - - - -      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3

当前OPP: =====       其他OPP: - - -     平均利用率（每项为100）: ##
```

`find_energy_efficient_cpu()` 首先会在两个性能域中寻找具有最大空闲容量的CPU。在这个例子中，是CPU1和CPU3。然后它会估计如果将P放置在其中任何一个CPU上系统的能量消耗，并检查这是否会比将P留在CPU0上节省能量。EAS假设OPP跟随利用率（这与schedutil CPUFreq调度器的行为一致，详见第6节）。

**案例1. 将P迁移到CPU1**：

```
      1024                 - - - - - - -

                                            能量计算：
       768                 =============     * CPU0: 200 / 341 * 150 = 88
                                             * CPU1: 300 / 341 * 150 = 131
                                             * CPU2: 600 / 768 * 800 = 625
       512  - - - - - -    - ##- - - - -     * CPU3: 500 / 768 * 800 = 520
                             ##     ##          => 总能量 = 1364
       341  ===========      ##     ##
                    PP       ##     ##
       170  -## - - PP-      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3
```

**案例2. 将P迁移到CPU3**：

```
      1024                 - - - - - - -

                                            能量计算：
       768                 =============     * CPU0: 200 / 341 * 150 = 88
                                             * CPU1: 100 / 341 * 150 = 43
                                    PP       * CPU2: 600 / 768 * 800 = 625
       512  - - - - - -    - ##- - -PP -     * CPU3: 700 / 768 * 800 = 729
                             ##     ##          => 总能量 = 1485
       341  ===========      ##     ##
                             ##     ##
       170  -## - - - -      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3
```

**案例3. P保持在prev_cpu / CPU0上**：

```
      1024                 - - - - - - -

                                            能量计算：
       768                 =============     * CPU0: 400 / 512 * 300 = 234
                                             * CPU1: 100 / 512 * 300 = 58
                                             * CPU2: 600 / 768 * 800 = 625
       512  ===========    - ##- - - - -     * CPU3: 500 / 768 * 800 = 520
                             ##     ##          => 总能量 = 1437
       341  -PP - - - -      ##     ##
             PP              ##     ##
       170  -## - - - -      ##     ##
             ##     ##       ##     ##
           ------------    -------------
            CPU0   CPU1     CPU2   CPU3
```

从这些计算结果来看，案例1具有最低的总能量。因此从能效角度来看，CPU1是最好的候选者。
大核心通常比小核心更耗电，主要在任务无法适应小核心时使用。然而，小核心并不总是比大核心更节能。对于某些系统来说，小核心的高OPP可能比大核心的最低OPP更不节能。因此，如果小核心在某个特定时间有足够的利用率，此时唤醒的一个小任务可能会更适合在大核心上执行以节省能量，即使它可以适应小核心。
即使在所有大核心的OPP都比小核心更不节能的情况下，特定条件下使用大核心执行小任务仍然可能节省能量。确实，将任务放在小核心上会导致整个性能域的OPP提高，从而增加已经在运行的任务的成本。如果唤醒的任务被放置在大核心上，其自身的执行成本可能比在小核心上更高，但不会影响其他小核心上的任务，这些任务将继续以较低的OPP运行。因此，在考虑CPU的总能耗时，将该任务放在大核心上的额外成本可能小于提高小核心OPP对其他任务的影响。

上述示例几乎不可能在不了解系统中所有CPU在不同OPP下的运行成本的情况下通用地解决。得益于基于EM的设计，EAS应该能够正确处理这些问题而不会遇到太多麻烦。然而，为了确保在高利用率场景下对吞吐量的最小影响，EAS还实现了另一种机制称为“过载”。

### 5. 过载
从总体上看，EAS最能帮助的用例涉及轻度至中度的CPU利用率。每当运行长时间的CPU密集型任务时，它们将需要所有可用的CPU容量，而调度器几乎无法在不影响吞吐量的情况下节省能量。为了避免EAS影响性能，一旦CPU使用超过80%的计算能力，就会将其标记为“过载”。只要根域中的任何CPU不过载，负载均衡就会被禁用，EAS会覆盖唤醒均衡代码。如果这样做不会损害吞吐量，EAS可能会使系统中最节能的CPU比其他CPU承担更多的负载。因此，禁用负载均衡器以防止其破坏EAS找到的能效任务分配。当系统不过载时这样做是安全的，因为低于80%的阈值意味着：

a. 所有CPU上都有空闲时间，因此EAS使用的利用率信号很可能准确地表示系统中各种任务的“大小”；
b. 所有任务都应该已经获得了足够的CPU容量，无论它们的优先级值如何；
c. 由于存在多余的容量，所有任务必须定期阻塞/休眠，因此在唤醒时进行平衡就足够了。

一旦某一个CPU超过80%的阈值，至少其中一个假设变得不正确。在这种情况下，整个根域的“过载”标志会被触发，EAS被禁用，负载均衡器重新启用。这样，调度器在CPU受限条件下退回到基于负载的算法进行唤醒和负载均衡。这更好地尊重了任务的优先级值。
由于过载的概念很大程度上依赖于检测系统中是否存在空闲时间，因此必须考虑被更高（比CFS）调度类（以及IRQ）“窃取”的CPU容量。因此，过载检测不仅考虑了CFS任务所使用的容量，还考虑了其他调度类和IRQ所使用的容量。
6. 依赖项和要求
----------------

能源感知调度（EAS）依赖于系统中的CPU具有特定的硬件属性，并且内核的其他特性需要被启用。本节列出了这些依赖项，并提供了如何满足这些依赖项的提示。

6.1 - 不对称的CPU拓扑结构
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

如引言中所述，目前EAS仅支持不对称CPU拓扑结构的平台。此要求在构建调度域时通过检查SD_ASYM_CPUCAPACITY_FULL标志的存在来验证。
有关设置此标志所需条件的详细信息，请参阅Documentation/scheduler/sched-capacity.rst。
请注意，EAS本质上与SMP并不兼容，但在SMP平台上尚未观察到显著的节能效果。如果未来证明这一限制可以放宽，则可能会进行调整。

6.2 - 能量模型存在
^^^^^^^^^^^^^^^^^^^^^^^^^^^

EAS使用平台的能量模型（EM）来估算调度决策对能耗的影响。因此，您的平台必须向能量模型框架提供功耗成本表，以便启动EAS。具体做法请参考独立的能量模型框架文档Documentation/power/energy-model.rst。
请注意，在启动EAS之前，需要在注册了EM之后重新构建调度域。
EAS利用EM进行能耗预测决策，因此它更关注任务放置时可能选项之间的差异。对于EAS而言，EM功率值是用毫瓦还是“抽象尺度”表示并不重要。

6.3 - 能量模型复杂度
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

EAS不施加任何关于PDs/OPPs/CPU数量的复杂度限制，但为了防止在能量估算过程中溢出，将CPU的数量限制为EM_MAX_NUM_CPUS。

6.4 - Schedutil调速器
^^^^^^^^^^^^^^^^^^^^^^^^

EAS试图预测CPU在不久的将来将以哪个OPP运行，从而估算其能耗。为此，假设CPU的OPP与其利用率相关。
尽管实际上很难提供关于这一假设准确性的硬性保证（因为硬件可能不会按照指令行事），但与其它CPUFreq调速器相比，schedutil至少会根据利用率信号请求计算频率。
因此，唯一与EAS一起使用的合理的调度器是schedutil，
因为它是唯一一个在频率请求和能耗预测之间提供一定程度一致性的调度器。
使用EAS与除schedutil之外的任何其他调度器都不受支持。

6.5 不随比例变化的利用率信号
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

为了在所有CPU和所有性能状态下进行准确预测，EAS需要频率不变和CPU不变的PELT信号。这些可以通过架构定义的arch_scale{cpu,freq}_capacity()回调函数来获得。
在没有实现这两个回调函数的平台上使用EAS不受支持。

6.6 多线程（SMT）
^^^^^^^^^^^^^^^^^^^^^^^^

当前形式下的EAS不支持超线程技术，并且无法利用多线程硬件来节省能源。EAS将线程视为独立的CPU，这实际上可能会对性能和能耗产生反作用。
在支持SMT的系统上使用EAS不受支持。
