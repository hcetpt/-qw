.. _sched_design_CFS:

=============
完全公平调度器
=============

1. 概述
============

CFS 代表 “完全公平调度器”，是由 Ingo Molnar 实现的新“桌面”进程调度器，并在 Linux 2.6.23 中合并。它是对之前默认调度器 SCHED_OTHER 交互性代码的替代。
CFS 设计的 80% 可以用一句话来概括：CFS 基本上是在真实硬件上模拟一个“理想的精确多任务 CPU”。
“理想的多任务 CPU”是一个不存在的 CPU，它具有 100% 的物理功率，并且可以并行地以精确相等的速度运行每个任务，每个任务都以 1/nr_running 的速度运行。例如：如果有两个任务在运行，则它们各自以 50% 的物理功率运行——即实际并行运行。
在真实的硬件上，我们一次只能运行一个任务，因此我们必须引入“虚拟运行时间”的概念。任务的虚拟运行时间指定了它在上述理想多任务 CPU 上下一次时间片开始执行的时间。实际上，任务的虚拟运行时间是其实际运行时间除以正在运行的任务总数。

2. 部分实现细节
==============================

在 CFS 中，虚拟运行时间通过每个任务的 p->se.vruntime（纳秒单位）值来表示和跟踪。这样可以准确地记录和测量任务应该获得的“预期 CPU 时间”。
小细节：在“理想”的硬件上，任何时候所有任务的 p->se.vruntime 值都是相同的——即任务同时执行，没有任务会从“理想”的 CPU 时间份额中“失衡”。
CFS 的任务选择逻辑基于这个 p->se.vruntime 值，因此非常简单：它总是尝试运行 p->se.vruntime 值最小的任务（即到目前为止执行最少的任务）。CFS 总是尽可能地将 CPU 时间分割成接近“理想多任务硬件”的方式。
CFS 设计的其余部分主要由这个非常简单的概念决定，还有一些附加功能，如优先级、多处理器支持以及各种算法变体来识别睡眠任务。

3. RBTREE
==============

CFS 的设计相当激进：它不使用旧的运行队列数据结构，而是使用按时间排序的红黑树来构建未来任务执行的时间线，因此没有“数组切换”现象（之前的默认调度器和 RSDL/SD 都存在这种问题）。
CFS 还维护了 rq->cfs.min_vruntime 值，这是一个单调递增的值，用于追踪运行队列中所有任务的最小虚拟运行时间。系统完成的工作总量通过 min_vruntime 跟踪；该值用于尽可能地将新激活的实体放置在树的左侧。
运行队列中活动任务的总数通过 `rq->cfs.load` 值来计算，该值是排队在运行队列中的任务权重之和。
CFS 维护一个按时间顺序排列的红黑树（rbtree），其中所有可运行的任务都按照 `p->se.vruntime` 键进行排序。CFS 从这棵树中选择最“左边”的任务，并坚持使用它。
随着系统的进展，已执行的任务被逐步放置到树的更右侧——尽管缓慢但确实地给每个任务成为“最左边任务”的机会，从而在确定的时间内获得 CPU 的使用权。
总结一下，CFS 的工作方式如下：它运行一个任务一段时间，当任务调度（或调度器发生一次时钟中断）时，任务的 CPU 使用情况会被“记录”：该任务刚刚使用的（短小的）物理 CPU 时间会被加到 `p->se.vruntime` 上。一旦 `p->se.vruntime` 变得足够高，使得另一个任务成为其维护的时间有序红黑树中最“左边”的任务（加上相对于最左边任务的一点点“粒度”距离，以避免过度调度任务并破坏缓存），那么就会选择新的最左边任务，并抢占当前任务。

### 4. CFS 的一些特性
========================

CFS 使用纳秒级精度的计数，并不依赖于任何 jiffies 或其他 HZ 细节。因此，与之前的调度器不同，CFS 调度器没有“时间片”的概念，也没有任何启发式算法。只有一个中心可调参数（需要开启 CONFIG_SCHED_DEBUG）：

```
/sys/kernel/debug/sched/base_slice_ns
```

这个参数可以用来调整调度器以适应“桌面”（即低延迟）或“服务器”（即良好的批处理）的工作负载。默认设置适合桌面工作负载。SCHED_BATCH 也由 CFS 调度器模块处理。
如果 CONFIG_HZ 导致 `base_slice_ns` 小于 `TICK_NSEC`，则 `base_slice_ns` 的值对工作负载的影响很小甚至没有影响。
由于其设计，CFS 调度器不容易受到目前针对默认调度器启发式算法的各种“攻击”：fiftyp.c、thud.c、chew.c、ring-test.c 和 massive_intr.c 都能正常工作，并且不会影响交互性，表现出预期的行为。
CFS 调度器对 nice 级别和 SCHED_BATCH 的处理比之前的默认调度器更强：这两种类型的工作负载被更严格地隔离。
SMP 负载均衡已经进行了重构/清理：负载均衡代码中不再包含运行队列遍历假设，而是使用了调度模块的迭代器。结果，平衡代码变得更加简单。

### 5. 调度策略
======================

CFS 实现了三种调度策略：

  - SCHED_NORMAL（传统上称为 SCHED_OTHER）：用于普通任务的调度策略
### SCHED_BATCH：不会像普通任务那样频繁抢占，从而允许任务运行更长时间并更好地利用缓存，但代价是降低了交互性。这对于批处理作业非常合适。

### SCHED_IDLE：这比nice值为19的任务还要弱，但它不是一个真正的空闲定时器调度程序，以避免出现优先级反转问题，从而导致系统死锁。

SCHED_FIFO/_RR 在 sched/rt.c 中实现，并遵循 POSIX 规范。

util-linux-ng 2.13.1.1 版本中的命令 `chrt` 可以设置这些调度策略，除了 SCHED_IDLE。

### 6. 调度类别
======================

新的 CFS 调度程序设计了一种“调度类别”的机制，这是一种可扩展的调度模块层次结构。这些模块封装了调度策略的细节，并由调度核心处理，而核心代码不对其假设太多内容。

- `sched/fair.c` 实现了上述的 CFS 调度程序。
- `sched/rt.c` 实现了 SCHED_FIFO 和 SCHED_RR 的语义，比之前的普通调度程序更为简单。它使用了100个运行队列（针对所有100个实时优先级级别，而不是之前的140个），并且不需要过期数组。

调度类别通过 `sched_class` 结构体来实现，该结构体包含了在发生有趣事件时需要调用的函数钩子。

以下是部分钩子列表：

- `enqueue_task(...)`

  当一个任务进入可运行状态时被调用。
  它将调度实体（任务）放入红黑树中，并递增 nr_running 变量。
- `dequeue_task(...)` 

   当一个任务不再可运行时，此函数会被调用以使相应的调度实体不在红黑树中。它会递减`nr_running`变量。

- `yield_task(...)` 

   此函数基本上只是一个出队列操作后跟着一个入队列操作，除非`compat_yield` sysctl被启用；在这种情况下，它将调度实体放置在红黑树的最右侧。

- `wakeup_preempt(...)` 

   此函数检查进入可运行状态的任务是否应该抢占当前正在运行的任务。

- `pick_next_task(...)` 

   此函数选择下一个最适合运行的任务。

- `set_next_task(...)` 

   此函数在任务更改其调度类、更改其任务组或被调度时调用。

- `task_tick(...)` 

   此函数主要由时间滴答函数调用；它可能会导致进程切换。这推动了运行中的抢占。

7. CFS 的组调度器扩展
======================

通常，调度器针对单个任务进行操作，并努力为每个任务提供公平的CPU时间。有时，可能希望将任务分组，并为每个这样的任务组提供公平的CPU时间。例如，首先为系统上的每个用户提供公平的CPU时间，然后为属于该用户的每个任务提供公平的CPU时间可能是可取的。
`CONFIG_CGROUP_SCHED`旨在实现这一目标。它允许将任务分组，并在这些组之间公平地分配CPU时间。
`CONFIG_RT_GROUP_SCHED`允许对实时任务（即SCHED_FIFO和SCHED_RR）进行分组。
`CONFIG_FAIR_GROUP_SCHED`允许对CFS任务（即SCHED_NORMAL和SCHED_BATCH）进行分组。
这些选项需要定义 `CONFIG_CGROUPS`，并允许管理员使用 “cgroup” 伪文件系统创建任意的任务组。关于这个文件系统的更多信息，请参阅 `Documentation/admin-guide/cgroup-v1/cgroups.rst`。

当定义了 `CONFIG_FAIR_GROUP_SCHED` 时，会为使用伪文件系统创建的每个组创建一个名为 “cpu.shares” 的文件。下面是一个示例步骤，展示如何创建任务组并使用 “cgroups” 伪文件系统修改它们的 CPU 分配：

```
# 挂载临时文件系统到 cgroup_root
# mount -t tmpfs cgroup_root /sys/fs/cgroup

# 创建 cpu 目录
# mkdir /sys/fs/cgroup/cpu

# 将 cpu 子系统挂载到 cgroup/cpu
# mount -t cgroup -o cpu none /sys/fs/cgroup/cpu

# 进入 cpu 目录
# cd /sys/fs/cgroup/cpu

# 创建“multimedia”任务组
# mkdir multimedia

# 创建“browser”任务组
# mkdir browser

# 配置“multimedia”组以获得比“browser”组多两倍的 CPU 带宽
# echo 2048 > multimedia/cpu.shares
# echo 1024 > browser/cpu.shares

# 启动 Firefox 并将其移动到“browser”组
# firefox &
# echo <firefox_pid> > browser/tasks

# 启动 gmplayer（或您喜欢的电影播放器）
# echo <movie_player_pid> > multimedia/tasks
```
