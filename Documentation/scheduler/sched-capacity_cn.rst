容量感知调度
=========================

1. CPU 容量
===============

1.1 引言
----------------

传统的、同构的SMP平台由完全相同的CPU组成。而异构平台则由具有不同性能特性的CPU组成——在这样的平台上，并非所有CPU都等同。
CPU容量是对CPU能够达到的性能的一种度量，以系统中最高性能的CPU为基准进行归一化。异构系统也称为不对称CPU容量系统，因为它们包含具有不同容量的CPU。
最大可实现性能（即最大CPU容量）的差异源于两个因素：

- 并非所有CPU都具有相同的微架构（μarch）
- 由于动态电压和频率缩放（DVFS），并非所有CPU都能物理上达到更高的操作性能点（OPP）
ARM big.LITTLE系统就是一个例子。big CPU比LITTLE CPU更注重性能（更多的流水线阶段、更大的缓存、更智能的预测器等），并且通常可以达到比LITTLE CPU更高的OPP。
CPU性能通常用每秒百万条指令（MIPS）来表示，也可以表示为每赫兹可达到的给定数量的指令，从而得出：

  capacity(cpu) = work_per_hz(cpu) * max_freq(cpu)

1.2 调度术语
-------------------

在调度程序中使用了两种不同的容量值。一个CPU的“原始容量”是其最大可实现的容量，即其最高可实现的性能水平。此原始容量由函数arch_scale_cpu_capacity()返回。一个CPU的“容量”是其“原始容量”减去一些可用性能的损失（例如处理IRQ的时间）。
需要注意的是，一个CPU的“容量”仅用于CFS类，而“原始容量”与类无关。为了简洁起见，本文档其余部分将交替使用“容量”和“原始容量”这两个术语。

1.3 平台示例
---------------------

1.3.1 相同的OPP
~~~~~~~~~~~~~~~~~~~~

假设一个双核不对称CPU容量系统，其中：

- work_per_hz(CPU0) = W
- work_per_hz(CPU1) = W/2
- 所有CPU都以相同的固定频率运行

根据上述容量定义：

- capacity(CPU0) = C
- capacity(CPU1) = C/2

为了与ARM big.LITTLE进行对比，CPU0是一个big，而CPU1是一个LITTLE。
对于周期性执行固定工作量的工作负载，你将得到如下执行轨迹：

 CPU0 工作 ^
           |     ____                ____                ____
           |    |    |              |    |              |    |
           +----+----+----+----+----+----+----+----+----+----+-> 时间

 CPU1 工作 ^
           |     _________           _________           ____
           |    |         |         |         |         |
           +----+----+----+----+----+----+----+----+----+----+-> 时间

CPU0拥有系统中最高的容量（C），并在T个时间单位内完成固定工作量W。另一方面，CPU1的容量是CPU0的一半，因此在相同时间内只能完成W/2的工作量。

1.3.2 不同的最大OPP
~~~~~~~~~~~~~~~~~~~~~~~~

通常，具有不同容量值的CPU也具有不同的最大OPP。考虑上面相同的CPU（即相同的work_per_hz()），但：

- max_freq(CPU0) = F
- max_freq(CPU1) = 2/3 * F

这将导致：

- capacity(CPU0) = C
- capacity(CPU1) = C/3

执行与1.3.1中描述的相同工作负载，每个CPU以最大频率运行的结果如下：

 CPU0 工作 ^
           |     ____                ____                ____
           |    |    |              |    |              |    |
           +----+----+----+----+----+----+----+----+----+----+-> 时间

                          CPU1上的工作负载
 CPU1 工作 ^
           |     ______________      ______________      ____
           |    |              |    |              |    |
           +----+----+----+----+----+----+----+----+----+----+-> 时间

1.4 表示注意事项
-------------------------

值得注意的是，用单个值来表示CPU性能的差异是一个有些争议的问题。两个不同微架构之间的相对性能差异可能在整数运算上为X%，浮点运算上为Y%，分支上为Z%，等等。然而，使用这种简单方法的结果至今令人满意。
2. 任务利用率
===================

2.1 引言
----------------

容量感知调度需要表达任务对CPU容量的要求。每个调度类可以以不同的方式表达这一点，而虽然任务利用率是CFS特有的，但在这里描述它有助于引入更通用的概念。任务利用率是一个百分比，旨在代表任务的吞吐量需求。一个简单的近似值是任务的工作周期，即：

  task_util(p) = duty_cycle(p)

在一个具有固定频率的SMP系统上，100%的利用率表明该任务是一个忙循环。相反，10%的利用率则暗示这是一个睡眠时间多于执行时间的小型周期性任务。可变的CPU频率和不对称的CPU容量使这一情况变得复杂；以下部分将对此进行详细说明。

2.2 频率不变性
------------------------

需要考虑的一个问题是工作负载的工作周期直接受到当前运行的OPP（Operating Performance Point）的影响。考虑在给定频率F下运行一个周期性工作负载：

  CPU 工作 ^
           |     ____                ____                ____
           |    |    |              |    |              |    |
           +----+----+----+----+----+----+----+----+----+----+-> 时间

这会导致 duty_cycle(p) == 25%
现在，考虑在同一频率F/2下运行相同的任务：

  CPU 工作 ^
           |     _________           _________           ____
           |    |         |         |         |         |
           +----+----+----+----+----+----+----+----+----+----+-> 时间

这会导致 duty_cycle(p) == 50%，尽管任务在这两次执行中的行为完全相同（即执行相同数量的工作）。
任务利用率信号可以通过以下公式使其与频率无关：

  task_util_freq_inv(p) = duty_cycle(p) * (curr_frequency(cpu) / max_frequency(cpu))

将此公式应用于上述两个示例，得出频率不变的任务利用率为25%。

2.3 CPU不变性
------------------

类似地，CPU容量也会影响任务利用率，因为在不同容量的CPU上运行相同的工作负载会产生不同的工作周期。考虑1.3.2节中描述的系统，即：

- capacity(CPU0) = C
- capacity(CPU1) = C/3

在每个CPU的最大频率下执行给定的周期性工作负载会得到如下结果：

 CPU0 工作 ^
           |     ____                ____                ____
           |    |    |              |    |              |    |
           +----+----+----+----+----+----+----+----+----+----+-> 时间

 CPU1 工作 ^
           |     ______________      ______________      ____
           |    |              |    |              |    |
           +----+----+----+----+----+----+----+----+----+----+-> 时间

换句话说，

- 如果p在最大频率下的CPU0上运行，则 duty_cycle(p) == 25%
- 如果p在最大频率下的CPU1上运行，则 duty_cycle(p) == 75%

任务利用率信号可以通过以下公式使其与CPU无关：

  task_util_cpu_inv(p) = duty_cycle(p) * (capacity(cpu) / max_capacity)

其中 `max_capacity` 是系统中最高的CPU容量值。将此公式应用于上述示例，得出CPU不变的任务利用率为25%。

2.4 不变量任务利用率
------------------------------

为了获得真正不变的任务利用率信号，需要同时应用频率不变性和CPU不变性。对于给定任务p，其既频率不变又CPU不变的任务利用率的伪公式为：

                                     curr_frequency(cpu)   capacity(cpu)
  task_util_inv(p) = duty_cycle(p) * ------------------- * -------------
                                     max_frequency(cpu)    max_capacity

换句话说，不变的任务利用率描述了任务仿佛是在系统中最高容量的CPU上、以最大频率运行的行为。
后续章节中提到的任务利用率均指其不变形式。

2.5 利用率估计
--------------------------

没有水晶球，无法准确预测任务首次变为可运行时的行为（以及任务利用率）。CFS类通过基于Per-Entity Load Tracking (PELT)机制维护了一些CPU和任务信号，其中一个信号产生的是平均利用率（而非瞬时利用率）。
这意味着虽然容量感知调度标准将基于“真实”的任务利用率（使用一种预见性方法）进行编写，但实现时只能使用这种利用率的估计值。

3. 容量感知调度要求
=========================

3.1 CPU容量
----------------

目前Linux无法自行计算出CPU容量，因此需要提供这些信息。为此，架构必须定义`arch_scale_cpu_capacity()`。
ARM、ARM64和RISC-V架构直接将此映射到架构拓扑驱动器的CPU缩放数据，该数据源自`capacity-dmips-mhz` CPU绑定；详见`Documentation/devicetree/bindings/cpu/cpu-capacity.txt`。

3.2 频率不变性
------------------------

如第2.2节所述，容量感知调度需要频率不变的任务利用率。为此，架构必须定义`arch_scale_freq_capacity(cpu)`。
实现此功能需要确定每个CPU运行在哪个频率上。一种实现方式是利用硬件计数器，其增量速率与CPU当前频率成比例（x86上的APERF/MPERF，ARM64上的AMU）。另一种方式是直接挂钩到cpufreq频率转换，在内核知道切换后的频率时（也被ARM/ARM64所采用）。

4. 调度器拓扑
=====================

在构建调度域期间，调度器将判断系统是否表现出不对称的CPU容量。如果存在不对称情况：

- 将启用`sched_asym_cpucapacity`静态键。
- 在覆盖所有唯一CPU容量值的最低级别的调度域中设置`SD_ASYM_CPUCAPACITY_FULL`标志。
- 对于跨越任何范围不对称性的CPU的任何调度域，将设置`SD_ASYM_CPUCAPACITY`标志。

`sched_asym_cpucapacity`静态键旨在保护针对不对称CPU容量系统的代码段。然而需要注意的是，该键是系统范围内的。设想如下使用cpuset的设置：

```
容量      C/2          C
       ________    ________
      /        \  /        \
CPU    0  1  2  3  4  5  6  7
       \__/  \______________/
cpuset   cs0         cs1
```

可以通过以下命令创建：
```sh
mkdir /sys/fs/cgroup/cpuset/cs0
echo 0-1 > /sys/fs/cgroup/cpuset/cs0/cpuset.cpus
echo 0 > /sys/fs/cgroup/cpuset/cs0/cpuset.mems

mkdir /sys/fs/cgroup/cpuset/cs1
echo 2-7 > /sys/fs/cgroup/cpuset/cs1/cpuset.cpus
echo 0 > /sys/fs/cgroup/cpuset/cs1/cpuset.mems

echo 0 > /sys/fs/cgroup/cpuset/cpuset.sched_load_balance
```

由于系统中存在CPU容量不对称性，`sched_asym_cpucapacity`静态键将被启用。然而，0-1号CPU的调度域层次结构仅跨越单个容量值：在该层次结构中不会设置`SD_ASYM_CPUCAPACITY`标志，它描述了一个SMP岛，并应相应处理。

因此，保护针对不对称CPU容量系统的代码路径的“规范”模式是：

- 检查`sched_asym_cpucapacity`静态键。
- 如果已启用，则还需检查调度域层次结构中是否存在`SD_ASYM_CPUCAPACITY`标志（如果相关，即代码路径针对特定CPU或一组CPU）。

5. 容量感知调度实现
===========================

5.1 CFS
-------

5.1.1 容量适应性
~~~~~~~~~~~~~~~~~~~~~~

CFS的主要容量调度标准为：

```
task_util(p) < capacity(task_cpu(p))
```

这通常称为容量适应性标准，即CFS必须确保任务在其CPU上“适合”。如果违反了这一标准，任务将需要完成比其CPU所能提供的更多的工作：它将成为CPU受限。
此外，uclamp 允许用户空间为任务指定最小和最大利用率值，可以通过 `sched_setattr()` 或者通过 cgroup 接口（见文档 `Documentation/admin-guide/cgroup-v2.rst`）。顾名思义，这可以用于限制前面标准中的 `task_util()`。

5.1.2 唤醒时的 CPU 选择
~~~~~~~~~~~~~~~~~~~~~~~~~~

CFS 任务唤醒时的 CPU 选择遵循上述的容量适应性标准。除此之外，uclamp 用于限制任务的利用率值，从而让用户空间对 CFS 任务的 CPU 选择有更多的控制权。换句话说，CFS 唤醒时的 CPU 选择会寻找一个满足以下条件的 CPU：

```
clamp(task_util(p), task_uclamp_min(p), task_uclamp_max(p)) < capacity(cpu)
```

通过使用 uclamp，用户空间可以让一个繁忙循环（100% 利用率）在任何 CPU 上运行，只需给它设置一个较低的 `uclamp.max` 值。相反地，也可以通过给一个小周期性任务（例如 10% 利用率）设置一个较高的 `uclamp.min` 值，强制其在最高性能的 CPU 上运行。
.. 注意::
  
  CFS 中的唤醒 CPU 选择可能会被能效感知调度（EAS）所覆盖，详见 `Documentation/scheduler/sched-energy.rst`。

5.1.3 负载均衡
~~~~~~~~~~~~~~~~~~~~

在唤醒 CPU 选择中存在一种极端情况，即任务很少甚至从不休眠——因此它也很少甚至从不唤醒。考虑如下情况：

```
w == 唤醒事件

capacity(CPU0) = C
capacity(CPU1) = C / 3
```

**CPU0 上的工作负载**

```
CPU 工作 ^
          |     _________           _________           ____
          |    |         |         |         |         |
          +----+----+----+----+----+----+----+----+----+----+-> 时间
               w                   w                   w
```

**CPU1 上的工作负载**

```
CPU 工作 ^
          |     ____________________________________________
          |    |
          +----+----+----+----+----+----+----+----+----+----+-> 时间
               w
```

这个工作负载应该运行在 CPU0 上，但如果任务：
- 一开始就被错误地调度（初始利用率估计不准确）
- 一开始被正确调度，但突然需要更多的处理能力

那么它可能会变得 CPU 绑定，即 `task_util(p) > capacity(task_cpu(p))`；违反了 CPU 容量调度标准，并且可能不会有更多的唤醒事件通过唤醒 CPU 选择来修复这种情况。

处于这种情况的任务被称为“不合适”任务，处理这种任务的机制也同名。不合适任务迁移利用了 CFS 负载均衡器，特别是活跃负载均衡部分（负责迁移当前正在运行的任务）。当负载均衡发生时，如果一个不合适任务可以迁移到具有更大容量的 CPU 上，就会触发一次活跃负载均衡。

5.2 实时（RT）
--------------

5.2.1 唤醒时的 CPU 选择
~~~~~~~~~~~~~~~~~~~~~~~~~~

实时任务唤醒时的 CPU 选择会寻找一个满足以下条件的 CPU：

```
task_uclamp_min(p) <= capacity(task_cpu(cpu))
```

同时仍然遵循通常的优先级约束。如果候选的 CPU 都不能满足这一容量标准，则会遵循严格的基于优先级的调度，并忽略 CPU 容量。

5.3 死线（DL）
--------------

5.3.1 唤醒时的 CPU 选择
~~~~~~~~~~~~~~~~~~~~~~~~~~

死线任务唤醒时的 CPU 选择会寻找一个满足以下条件的 CPU：

```
task_bandwidth(p) < capacity(task_cpu(p))
```

同时仍然遵循通常的带宽和截止时间约束。如果候选的 CPU 都不能满足这一容量标准，则该任务将保留在当前的 CPU 上。
