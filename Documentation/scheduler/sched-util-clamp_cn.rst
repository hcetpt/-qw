SPDX 许可证标识符: GPL-2.0

====================
利用率限制
====================

1. 引言
===============

利用率限制（util clamp 或 uclamp）是一种调度器特性，允许用户空间帮助管理任务的性能需求。它在 v5.3 版本中引入。CGroup 支持则是在 v5.4 中合并的。
uclamp 是一种提示机制，使调度器能够理解任务的性能需求和限制，从而帮助调度器做出更好的决策。当使用 schedutil CPU 频率调节器时，uclamp 也会影响 CPU 频率的选择。
由于调度器和 schedutil 均由 PELT（util_avg）信号驱动，uclamp 通过将信号限制到某个点来实现其目标；因此得名。也就是说，通过限制利用率，我们使系统在某个特定性能点上运行。
正确的看待 uclamp 的方式是将其视为请求或提示性能约束的一种机制。它包含两个可调参数：

    * UCLAMP_MIN，设置下限
    * UCLAMP_MAX，设置上限

这两个界限确保任务在系统的这一性能范围内运行。UCLAMP_MIN 意味着提升任务，而 UCLAMP_MAX 则意味着限制任务。
可以告诉系统（调度器），某些任务需要一个最低性能点以提供预期的用户体验。或者可以告诉系统，某些任务应被限制在过度消耗资源，并且不应超过特定性能点。从用户空间的角度来看，将 uclamp 值视为性能点而非利用率是一种更好的抽象。
举个例子，游戏可以使用利用率限制与其感知的每秒帧数（FPS）形成反馈环路。它可以动态增加显示管线所需的最小性能点，以确保不丢帧。如果它知道接下来几百毫秒内将会出现计算密集型场景，它还可以动态地“预热”这些任务。
对于设备能力差异较大的移动硬件，这种动态反馈环提供了极大的灵活性，以确保任何系统都能提供最佳用户体验。
当然，静态配置也是可能的。具体用法取决于系统、应用程序和预期结果。
另一个例子是在 Android 系统中，任务被分类为后台、前台、顶级应用等。利用 Util clamp 可以限制后台任务消耗的资源量，通过限制它们所能运行的性能点来实现。这种限制有助于为重要的任务（如当前活动应用的任务）预留资源（属于顶级应用组）。此外，这还有助于限制它们消耗的电量。在异构系统（例如 Arm big.LITTLE 架构）中，这一点更为明显；限制会帮助将后台任务偏向于运行在小核心上，从而确保：

1. 大核心可以立即运行顶级应用任务。顶级应用任务是用户当前正在交互的任务，因此是系统中最重要任务。
2. 即使这些任务是 CPU 密集型任务，也不会运行在耗电大的核心上，从而避免电池快速耗尽。

.. note::
  **小核心**：
    容量 < 1024 的 CPU

  **大核心**：
    容量 = 1024 的 CPU

通过发出这些 uclamp 性能请求（或提示），用户空间可以确保系统资源得到最佳利用，以提供尽可能好的用户体验。
另一个使用场景是帮助克服调度器利用率信号计算中的固有延迟问题。
另一方面，如果某个繁忙任务需要以最大性能点运行，则调度器需要大约 200 毫秒的时间（PELT HALF LIFE = 32 毫秒）才能意识到这一点。这已知会影响移动设备上的游戏工作负载，由于响应时间慢导致无法及时选择更高的频率完成任务，从而导致帧率下降。设置 UCLAMP_MIN=1024 将确保此类任务在开始运行时始终获得最高性能水平。
总体可见效果不仅限于更好的用户体验/性能提升，还能有效地帮助实现更优的整体性能/功耗比。
用户空间还可以与热子系统形成反馈循环，以确保设备不会过热到需要降频的程度。
SCHED_NORMAL/OTHER 和 SCHED_FIFO/RR 都会遵守 uclamp 请求/提示。
在 SCHED_FIFO/RR 情况下，uclamp 提供了让实时任务（RT tasks）以任意性能点运行的选项，而不是一直绑定在最大频率上。这对运行在电池供电设备上的通用系统非常有用。
请注意，根据设计，实时任务没有每个任务的 PELT 信号，并且必须始终以恒定频率运行，以对抗不确定性的 DVFS 加速延迟。
请注意，使用 `schedutil` 总是意味着在实时任务唤醒时有一个单一的延迟来修改频率。这个成本不会因为使用 `uclamp` 而改变。`Uclamp` 只有助于选择请求哪个频率，而不是像 `schedutil` 总是为所有实时任务请求 `MAX`。
详情请参阅 :ref:`第 3.4 节<uclamp-default-values>` 中关于默认值的内容，以及 :ref:`3.4.1<sched-util-clamp-min-rt-default>` 关于如何更改实时任务的默认值。
2. 设计
=======

利用率限制（Util clamp）是系统中每个任务的一个属性。它设置了其利用率信号的边界；作为一种偏置机制，影响调度器中的某些决策。
实际上，任务的实际利用率信号从未被限制。如果你在任何时间点检查 PELT 信号，你会看到它们保持不变。限制仅在必要时发生，例如：当一个任务唤醒并且调度器需要选择一个合适的 CPU 供其运行时。
由于利用率限制的目标是允许请求任务运行所需的最小和最大性能点，因此它必须能够影响频率选择和任务放置，以达到最佳效果。这两者都对 CPU 运行队列（简称 rq）层面的利用率值有影响，这带来了主要的设计挑战。
当一个任务在一个 rq 上唤醒时，该 rq 的利用率信号将受到所有排队任务的 uclamp 设置的影响。例如，如果一个任务请求以 `UTIL_MIN = 512` 运行，则该 rq 的利用率信号需要尊重此请求以及其他所有排队任务的请求。
为了能够汇总所有附属于 rq 的任务的利用率限制值，`uclamp` 必须在每次入队/出队时进行一些维护工作，这是调度器的热点路径。因此必须小心处理，因为任何减速都会对许多用例产生重大影响，并可能妨碍其实用性。
处理这个问题的方法是将利用率范围划分为桶（`struct uclamp_bucket`），这使我们能够将搜索空间从 rq 上的每个任务减少到仅顶部桶中的子集任务。
当一个任务入队时，匹配桶中的计数器会增加，在出队时则减少。这使得跟踪 rq 层面的有效 uclamp 值变得容易得多。
随着任务的入队和出队，我们会跟踪当前有效的 rq 的 uclamp 值。详情请参阅 :ref:`第 2.1 节<uclamp-buckets>` 了解具体的工作原理。
### 2.1 桶

---

```
                           [struct rq]

  （底部）                                                      （顶部）

    0                                                          1024
    |                                                           |
    +-----------+-----------+-----------+----   ----+-----------+
    |  桶 0     |  桶 1     |  桶 2     |    ...    |  桶 N     |
    +-----------+-----------+-----------+----   ----+-----------+
       :           :                                   :
       +- p0       +- p3                               +- p4
       :                                               :
       +- p1                                           +- p5
       :
       +- p2
```

---

.. note::
  上图是一个示意图，而不是内部数据结构的真实表示。

为了减少在任务入队和出队时确定请求队列（rq）的有效 uclamp 值的搜索范围，整个利用率范围被划分为 N 个桶，其中 N 是通过设置 `CONFIG_UCLAMP_BUCKETS_COUNT` 在编译时配置的。默认情况下，N 设置为 5。

每个 rq 都有一个针对每个 uclamp_id 可调参数的桶：[UCLAMP_MIN, UCLAMP_MAX]。

每个桶的范围是 1024/N。例如，默认值为 5 时，将有 5 个桶，每个桶覆盖以下范围：

```
        DELTA = round_closest(1024/5) = 204.8 ≈ 205

        桶 0: [0:204]
        桶 1: [205:409]
        桶 2: [410:614]
        桶 3: [615:819]
        桶 4: [820:1024]
```

当一个具有以下可调参数的任务 p 被入队到 rq 中时：

```
        p->uclamp[UCLAMP_MIN] = 300
        p->uclamp[UCLAMP_MAX] = 1024
```

桶 1 将会为 UCLAMP_MIN 增加计数，桶 4 将会为 UCLAMP_MAX 增加计数，以反映 rq 中存在这个范围内的任务。

然后，rq 会跟踪其当前每个 uclamp_id 的有效 uclamp 值。
当任务 p 被加入队列时，rq 的值会变为：

```c
// 更新桶的逻辑放在这里
rq->uclamp[UCLAMP_MIN] = max(rq->uclamp[UCLAMP_MIN], p->uclamp[UCLAMP_MIN])
// 对 UCLAMP_MAX 重复相同的操作
```

同样地，当 p 从队列中移除时，rq 的值会变为：

```c
// 更新桶的逻辑放在这里
rq->uclamp[UCLAMP_MIN] = search_top_bucket_for_highest_value()
// 对 UCLAMP_MAX 重复相同的操作
```

当所有桶都为空时，rq 的 uclamp 值将重置为系统默认值。有关默认值的详细信息，请参见 :ref:`第 3.4 节 <uclamp-default-values>`。

### 2.2 最大聚合

利用限制（util clamp）被调整以满足需要最高性能点的任务请求。
当多个任务连接到同一个 rq 时，利用限制必须确保需要最高性能点的任务能够获得所需性能，即使有另一个任务不需要或不允许达到该性能点。
例如，如果有多个任务连接到同一个 rq，并且具有以下值：

```c
p0->uclamp[UCLAMP_MIN] = 300
p0->uclamp[UCLAMP_MAX] = 900

p1->uclamp[UCLAMP_MIN] = 500
p1->uclamp[UCLAMP_MAX] = 500
```

假设 p0 和 p1 都被加入到同一个 rq 中，则 UCLAMP_MIN 和 UCLAMP_MAX 变为：

```c
rq->uclamp[UCLAMP_MIN] = max(300, 500) = 500
rq->uclamp[UCLAMP_MAX] = max(900, 500) = 900
```

如 :ref:`第 5.1 节 <uclamp-capping-fail>` 所述，这种最大聚合是使用利用限制时的一个限制因素，特别是在用户空间希望节省电力的情况下，尤其对于 UCLAMP_MAX 提示。

### 2.3 层次聚合

如前所述，利用限制是系统中每个任务的属性。但是实际应用的有效值可能不仅受任务本身或代表其设置的中间件库的影响。
任何任务的有效利用限制值受到如下限制：

1. 如果任务连接到 cgroup CPU 控制器，则受其定义的 uclamp 设置限制。
2. 在 (1) 中的受限值进一步受到系统范围内的 uclamp 设置限制。

:ref:`第 3 节 <uclamp-interfaces>` 讨论了接口，并将进一步展开说明。
目前可以理解的是，如果一个任务发出请求，其实际有效值将不得不遵守由 cgroup 和系统范围设置施加的一些限制。
系统仍然会接受请求，即使实际上该请求超出了约束条件。但是，一旦任务转移到不同的cgroup或系统管理员修改了系统设置，请求只有在符合新的约束条件下才会被满足。

换句话说，这种聚合不会在任务改变其uclamp值时导致错误，而是系统可能无法根据这些因素来满足请求。

### 2.4 范围
-------------

Uclamp性能请求的范围是0到1024（包括两端）。
对于cgroup接口使用百分比（即0到100，包括两端）。
和其他cgroup接口一样，你可以用'max'代替100。

.. _uclamp-interfaces:

### 3. 接口
============

#### 3.1 每任务接口
-----------------------

`sched_setattr()` 系统调用被扩展以接受两个新字段：

* `sched_util_min`：请求当此任务运行时系统应运行的最小性能点。或者最低性能界限。
* `sched_util_max`：请求当此任务运行时系统应运行的最大性能点。或者最高性能界限。

例如，以下场景中有40%到80%的利用率约束：

```
    attr->sched_util_min = 40% * 1024;
    attr->sched_util_max = 80% * 1024;
```

当任务 @p 运行时，**调度器应尽量确保它从40%的性能水平开始**。如果任务运行足够长时间，使其实际利用率超过80%，则利用率或性能水平将被限制。

特殊值-1用于将uclamp设置重置为系统默认值。
需要注意的是，使用-1将uclamp值重置为系统默认值与手动设置uclamp值为系统默认值不同。这一区别很重要，因为如我们在系统接口中所见，默认值可能会发生变化。SCHED_NORMAL/OTHER将来也可能获得类似的调整旋钮。
3.2. cgroup 接口
---------------------

在 CPU cgroup 控制器中有两个与 uclamp 相关的值：

* cpu.uclamp.min
* cpu.uclamp.max

当一个任务被附加到 CPU 控制器时，其 uclamp 值将受到以下影响：

* `cpu.uclamp.min` 是一种保护机制，如 :ref:`cgroup v2 文档第 3-3 节 <cgroupv2-protections-distributor>` 所述。如果任务的 uclamp_min 值低于 `cpu.uclamp.min`，则该任务将继承 cgroup 的 `cpu.uclamp.min` 值。
  在 cgroup 层次结构中，有效的 `cpu.uclamp.min` 是子节点和父节点的最大值（child, parent）中的较大者。
* `cpu.uclamp.max` 是一种限制机制，如 :ref:`cgroup v2 文档第 3-2 节 <cgroupv2-limits-distributor>` 所述。如果任务的 uclamp_max 值高于 `cpu.uclamp.max`，则该任务将继承 cgroup 的 `cpu.uclamp.max` 值。
  在 cgroup 层次结构中，有效的 `cpu.uclamp.max` 是子节点和父节点的最大值（child, parent）中的较小者。

例如，给定以下参数：

```
p0->uclamp[UCLAMP_MIN] = // 系统默认值；
p0->uclamp[UCLAMP_MAX] = // 系统默认值；

p1->uclamp[UCLAMP_MIN] = 40% * 1024；
p1->uclamp[UCLAMP_MAX] = 50% * 1024；

cgroup0->cpu.uclamp.min = 20% * 1024；
cgroup0->cpu.uclamp.max = 60% * 1024；

cgroup1->cpu.uclamp.min = 60% * 1024；
cgroup1->cpu.uclamp.max = 100% * 1024；
```

当 p0 和 p1 被附加到 cgroup0 时，值变为：

```
p0->uclamp[UCLAMP_MIN] = cgroup0->cpu.uclamp.min = 20% * 1024；
p0->uclamp[UCLAMP_MAX] = cgroup0->cpu.uclamp.max = 60% * 1024；

p1->uclamp[UCLAMP_MIN] = 40% * 1024； // 不变
p1->uclamp[UCLAMP_MAX] = 50% * 1024； // 不变
```

当 p0 和 p1 被附加到 cgroup1 时，这些值变为：

```
p0->uclamp[UCLAMP_MIN] = cgroup1->cpu.uclamp.min = 60% * 1024；
p0->uclamp[UCLAMP_MAX] = cgroup1->cpu.uclamp.max = 100% * 1024；

p1->uclamp[UCLAMP_MIN] = cgroup1->cpu.uclamp.min = 60% * 1024；
p1->uclamp[UCLAMP_MAX] = 50% * 1024； // 不变
```

请注意，cgroup 接口允许 `cpu.uclamp.max` 值低于 `cpu.uclamp.min`。其他接口不允许这种情况。

3.3. 系统接口
---------------------

3.3.1 `sched_util_clamp_min`
-----------------------------

系统范围内的 UCLAMP_MIN 允许范围限制。默认设置为 1024，这意味着任务的有效 UCLAMP_MIN 范围是 [0:1024]。通过将其更改为 512，范围会减少到 [0:512]。这有助于限制任务能够获取的加速程度。
来自任务的超出此值的请求仍然会成功，但直到其大于 p->uclamp[UCLAMP_MIN] 时才会生效。
该值必须小于或等于 `sched_util_clamp_max`

3.3.2 `sched_util_clamp_max`
-----------------------------

系统范围内的允许的 UCLAMP_MAX 范围限制。默认设置为 1024，这意味着任务允许的有效 UCLAMP_MAX 范围是 [0:1024]。例如，如果将其更改为 512，则有效允许的范围将减少到 [0:512]。这意味着没有任何任务可以超过 512 运行，这也就意味着所有请求（rqs）也受到限制。换句话说，整个系统的性能被限制在其性能容量的一半。
这对于限制系统的整体最大性能是有用的。
例如，在电池电量低时限制性能或者在系统空闲状态或屏幕关闭时限制访问更多耗能的性能级别时，这一点非常有用。
任务请求超出这个限值的值仍然会成功，但它们不会得到满足，除非它大于 `p->uclamp[UCLAMP_MAX]`。
该值必须大于或等于 `sched_util_clamp_min`。

.. _uclamp-default-values:

3.4 默认值
--------------

默认情况下，所有 SCHED_NORMAL/SCHED_OTHER 任务初始化为：

::

        p_fair->uclamp[UCLAMP_MIN] = 0
        p_fair->uclamp[UCLAMP_MAX] = 1024

也就是说，默认情况下它们被提升到以最大性能运行，并且可以在启动或运行时更改。目前还没有关于为什么应该提供此功能的论据，但可以在未来添加。

对于 SCHED_FIFO/SCHED_RR 任务：

::

        p_rt->uclamp[UCLAMP_MIN] = 1024
        p_rt->uclamp[UCLAMP_MAX] = 1024

也就是说，默认情况下它们被提升到系统的最大性能点，保留了实时任务的历史行为。
可以通过 sysctl 在启动或运行时修改 RT 任务的默认 uclamp_min 值。请参阅下面的部分。
### 3.4.1 `sched_util_clamp_min_rt_default`

在电池供电的设备上，以最大性能运行实时任务（RT tasks）是昂贵的，并且没有必要。为了使系统开发人员能够在不将性能推至最大值的情况下为这些任务提供良好的性能保证，此sysctl旋钮允许调整最佳的提升值，以满足系统需求，而无需一直以最大性能运行从而消耗大量电力。
应用开发者被鼓励使用每个任务的util clamp接口，以确保他们对性能和功耗有所了解。理想情况下，此旋钮应由系统设计者设置为0，并将管理性能需求的任务留给应用程序。

### 4. 如何使用util clamp

#### 4.1 提升重要且对DVFS延迟敏感的任务

一个GUI任务在唤醒时可能并不繁忙到需要将频率调高。然而，它需要在特定的时间窗口内完成其工作，以提供预期的用户体验。它在唤醒时所需的正确频率将取决于系统。在一些性能不足的系统上，这个频率会很高；而在其他性能过剩的系统上，这个频率会很低或为0。
此任务每次错过截止时间时都可以增加其`UCLAMP_MIN`值，以确保在下次唤醒时以更高的性能运行。它应该尝试接近在任何特定系统上能够满足其截止时间的最低`UCLAMP_MIN`值，从而实现该系统的最佳性能/功耗比。
在异构系统中，对于此类任务来说，在更快的CPU上运行可能是重要的。
**通常建议将输入视为性能级别或点，这将意味着任务放置和频率选择**

4.2. 限制后台任务
-------------------------

如介绍中对Android情况的解释，任何应用程序都可以将UCLAMP_MAX降低，用于一些不关心性能但可能会变得繁忙并消耗系统上不必要的系统资源的后台任务。

4.3. 节能模式
-------------------

可以使用sched_util_clamp_max系统范围接口来限制所有任务运行在较高的性能点上，这些点通常是能源效率较低的。这不仅限于uclamp，也可以通过降低cpufreq管理器的最大频率来实现相同的目标。它可以被视为一个更方便的替代接口。

4.4. 每个应用程序的性能限制
-------------------------------

中间件/实用程序可以为用户提供选项，在每次执行应用程序时设置UCLAMP_MIN/MAX，以保证最低性能点，并/或限制其耗电，从而牺牲这些应用程序的性能。如果你想防止笔记本电脑在外出时编译内核导致发热，并愿意牺牲性能以节省电力，但仍希望保持浏览器性能完好，uclamp使这成为可能。

5. 限制
=============

.. _uclamp-capping-fail:

5.1. 在某些条件下使用uclamp_max进行频率限制会失败
---------------------------------------------------------------------

如果任务p0被限制在512运行：

::

        p0->uclamp[UCLAMP_MAX] = 512

并且它与p1共享rq，而p1可以自由地在任何性能点上运行：

::

        p1->uclamp[UCLAMP_MAX] = 1024

由于最大值聚合，rq将被允许达到最大性能点：

::

        rq->uclamp[UCLAMP_MAX] = max(512, 1024) = 1024

假设p0和p1的UCLAMP_MIN均为0，则rq的频率选择将取决于任务的实际利用率值。如果p1是一个小任务，而p0是一个CPU密集型任务，那么由于它们在同一rq上运行，即使p1被允许在任何性能点上运行但实际上并不需要那个频率，p1也会导致rq的频率限制失效。

5.2. UCLAMP_MAX 可能破坏PELT（util_avg）信号
------------------------------------------------

PELT假定随着信号的增长，频率总是增加，以确保CPU上总有空闲时间。但是有了UCLAMP_MAX，这种频率增长将会被阻止，这可能导致某些情况下没有空闲时间。当没有空闲时间时，任务会陷入繁忙循环，导致util_avg为1024。结合下面描述的问题，这可能导致严重受限的任务与未受限的小任务共享rq时出现不必要的频率突变。
例如，如果任务 p 具有以下属性：

::

        p0->util_avg = 300
        p0->uclamp[UCLAMP_MAX] = 0

当它在一个空闲的 CPU 上唤醒时，它将以该 CPU 能够达到的最低频率（Fmin）运行。最高 CPU 频率（Fmax）在这里也很重要，因为它决定了完成该任务工作所需的最短计算时间。

::

        rq->uclamp[UCLAMP_MAX] = 0

如果 Fmax/Fmin 的比例为 3，则最大值将是：

::

        300 * (Fmax/Fmin) = 900

这表示 CPU 仍然会有空闲时间，因为 900 小于 1024。实际的 `util_avg` 不会是 900，而是在 300 到 900 之间。只要存在空闲时间，`p->util_avg` 的更新就会有一定的偏差，但不会与 Fmax/Fmin 成正比。

::

        p0->util_avg = 300 + small_error

现在如果 Fmax/Fmin 的比例为 4，最大值变为：

::

        300 * (Fmax/Fmin) = 1200

这高于 1024，并表示 CPU 没有空闲时间。这时，实际的 `util_avg` 将变为：

::

        p0->util_avg = 1024

如果任务 p1 在这个 CPU 上唤醒，并且具有以下属性：

::

        p1->util_avg = 200
        p1->uclamp[UCLAMP_MAX] = 1024

根据最大聚合规则，CPU 的有效 UCLAMP_MAX 将为 1024。但由于受限制的任务 p0 正在运行并被严重节流，因此 `rq->util_avg` 将为：

::

        p0->util_avg = 1024
        p1->util_avg = 200

        rq->util_avg = 1024
        rq->uclamp[UCLAMP_MAX] = 1024

这会导致频率突增，因为如果没有对 p0 进行节流，我们本应得到：

::

        p0->util_avg = 300
        p1->util_avg = 200

        rq->util_avg = 500

并且在这个 CPU 的中间性能点附近运行，而不是 Fmax。

5.3. Schedutil 响应时间问题
------------------------------

Schedutil 存在三个局限性：

1. 硬件响应任何频率变化请求需要非零的时间。在某些平台上可能需要几毫秒。
2. 对于非快速切换系统，需要一个工作线程在规定时间内唤醒并执行频率变化，这增加了可测量的开销。
3. `schedutil rate_limit_us` 在此 `rate_limit_us` 窗口期间丢弃所有请求。

如果一个相对较小的任务在唤醒并开始运行时执行关键任务并需要一定的性能点，那么这些局限性将阻止它在预期的时间范围内获得所需性能。

这一局限不仅在使用 uclamp 时产生影响，在不再逐渐提升或降低频率的情况下会更加明显。我们可能会根据任务唤醒的顺序及其各自的 uclamp 值在不同频率之间跳跃。

我们认为这是底层系统能力的局限性。
对于 `schedutil rate_limit_us` 的行为还有改进的空间，但对于 1 和 2 来说，它们被认为是系统的硬性限制。
当然，请提供您需要翻译的文本。
