=====================
CFS 带宽控制
=====================

.. note::
   本文档仅讨论 SCHED_NORMAL 的 CPU 带宽控制。SCHED_RT 情况在文档 Documentation/scheduler/sched-rt-group.rst 中有所覆盖。

CFS 带宽控制是 CONFIG_FAIR_GROUP_SCHED 扩展的一部分，允许指定组或层级的最大可用 CPU 带宽。组的带宽通过配额（quota）和周期（period）来指定。在每个给定的“周期”（微秒）内，任务组可以分配到最多“配额”的 CPU 时间（微秒）。当 cgroup 中的线程变为可运行时，该配额会被切分为每个 CPU 运行队列中的份额。一旦所有配额都被分配完毕，任何额外的配额请求将导致这些线程被节流。被节流的线程将无法再次运行，直到下一个周期开始时重新补充配额。

组的未分配配额会全局跟踪，并在每个周期边界刷新回 cfs_quota 单位。随着线程消耗这些带宽，它们会根据需求转移到 CPU 局部的“筒仓”中。每次更新时转移的数量是可调的，称为“切片”。

**突发功能**
--------------
此功能通过借用未来的未用时间来实现，代价是增加对其他系统用户的干扰。所有这些都在可控范围内。

传统的 UP-EDF 带宽控制类似于：

  (U = \Sum u_i) <= 1

这保证了每个截止日期都能满足并且系统稳定。毕竟，如果 U > 1，则对于每一秒的物理时间，我们必须运行超过一秒的程序时间，显然会错过截止日期，而下一个截止日期会更远，永远没有时间赶上，从而导致无限失败。

突发功能观察到工作负载并不总是执行完整的配额；这使得我们可以将 u_i 描述为一个统计分布。例如，设 u_i = {x, e}_i，其中 x 是 p(95)，而 x + e 是 p(100)（传统 WCET）。这有效地允许 u 更小，提高效率（我们可以将更多任务塞进系统），但代价是在所有概率对齐时可能会错过截止日期。然而，它仍然保持了稳定性，因为每次超时都必须与一次未用时间配对，只要我们的 x 高于平均值。

也就是说，假设我们有两个任务，它们都指定了 p(95) 值，那么我们有 p(95) * p(95) = 90.25% 的概率两个任务都在其配额内，一切顺利。同时，我们有 p(5) * p(5) = 0.25% 的概率两个任务同时超出配额（保证错过截止日期）。在这两者之间，有一个阈值，其中一个任务超出配额，而另一个任务未能足够补偿未用时间；这取决于具体的累积分布函数（CDFs）。

同时，我们可以认为最糟糕的情况是截止日期错过，即 \Sum e_i；也就是说，有一个有限的延迟（假设 x + e 确实是 WCET）。
使用突发时的干扰通过错过截止时间和平均WCET（最坏情况执行时间）的可能性来评估。测试结果显示，当存在许多cgroup或CPU利用率较低时，干扰是有限的。更多细节可见：
https://lore.kernel.org/lkml/5371BD36-55AE-4F71-B9D7-B86DC32E3D2B@linux.alibaba.com/

管理
----------
配额、周期和突发是在cgroupfs中通过cpu子系统进行管理的。
.. note::
   本节中描述的cgroupfs文件仅适用于cgroup v1。对于cgroup v2，请参阅
   :ref:`Documentation/admin-guide/cgroup-v2.rst <cgroup-v2-cpu>`

- cpu.cfs_quota_us：在周期内按运行时间补充（以微秒为单位）
- cpu.cfs_period_us：周期的长度（以微秒为单位）
- cpu.stat：导出节流统计信息[进一步解释见下文]
- cpu.cfs_burst_us：最大累积运行时间（以微秒为单位）

默认值如下：

```
cpu.cfs_period_us=100ms
cpu.cfs_quota_us=-1
cpu.cfs_burst_us=0
```

cpu.cfs_quota_us的值为-1表示该组没有带宽限制，这种组被称为无带宽限制组。这代表了CFS的传统工作保护行为。
写入任何（有效）正值（不小于cpu.cfs_burst_us）将实施指定的带宽限制。配额或周期允许的最小配额为1ms。周期长度也有一个上限，即1s。
在分层使用带宽限制时，还存在其他限制，具体内容将在下面详细说明。
向cpu.cfs_quota_us写入任何负值将移除带宽限制，并使该组恢复到无限制状态。
cpu.cfs_burst_us的值为0表示该组不能累积任何未使用的带宽。这使得CFS的传统带宽控制行为不变。向cpu.cfs_burst_us写入任何（有效）正值（不大于cpu.cfs_quota_us）将实施对未使用带宽累积的上限。
对组的带宽规范的任何更新都将使其在受限制状态下变为不受限制。
系统范围设置
--------------------
为了提高效率，运行时间以批量方式在全局池和CPU本地“筒仓”之间转移。这大大减少了大型系统中的全局会计压力。每次需要此类更新时所转移的数量称为“切片”。
此值可通过procfs进行调整：

```
/proc/sys/kernel/sched_cfs_bandwidth_slice_us （默认=5ms）
```

较大的切片值将减少转移开销，而较小的值则允许更细粒度的消耗。
统计信息
----------
一个组的带宽统计信息通过 cpu.stat 中的五个字段导出：
cpu.stat：

- nr_periods：已过去的执行间隔数量
- nr_throttled：该组被限制的次数
- throttled_time：该组实体被限制的总时长（以纳秒为单位）
- nr_bursts：突发发生的周期数
- burst_time：在各个周期内，任何 CPU 超过配额所使用的累计时间（以纳秒为单位）

此接口为只读。

分层考虑
---------------------------
该接口强制规定单个实体的带宽始终可达到，即：max(c_i) <= C。然而，在总体情况下允许超额订阅，以便在层级结构中启用工作保护语义：

  例如 \Sum (c_i) 可能超过 C

[ 其中 C 是父级的带宽，而 c_i 是其子级 ]

一个组可能被限制的两种方式：

a. 在一个周期内完全消耗了自身的配额
b. 父级在一个周期内完全消耗了其配额

在情况 b) 中，即使子级仍有运行时间剩余，也不会被允许运行，直到父级的运行时间刷新为止。

CFS 带宽配额注意事项
---------------------------
一旦将切片分配给某个 CPU，它就不会过期。但是，如果该 CPU 上的所有线程都变得不可运行，则除了 1 毫秒之外，其余的切片可能会返还给全局池。这由编译时的 min_cfs_rq_runtime 变量配置。这是一个性能调整，有助于防止对全局锁增加竞争。

由于本地 CPU 切片不会过期，这导致了一些需要注意的特殊情况。
对于受cgroup CPU限制的应用程序，如果它们受到CPU限制，这一点相对无关紧要，因为它们自然会消耗其配额以及每个周期内每个CPU本地切片的全部内容。因此，预计`nr_periods`大致等于`nr_throttled`，并且在每个周期中`cpuacct.usage`的增长量大致等于`cfs_quota_us`。对于高度线程化且不受CPU限制的应用程序，这种不自动过期的细节允许应用程序通过每个CPU上未使用的切片短暂地超出其配额限制（通常每个CPU最多为1毫秒或由`min_cfs_rq_runtime`定义）。这种轻微的突发仅适用于在先前周期中已分配给CPU但未完全使用或返回的配额。这个突发量不会在核心之间转移。

因此，该机制仍然严格限制任务组的平均使用量不超过配额，尽管这个限制的时间窗口比单个周期长。这也限制了每个CPU上的突发能力不超过1毫秒。这为高线程化应用程序提供了更好的、更可预测的用户体验，特别是在高核心数机器上具有小配额限制的情况。它还消除了在同时使用小于配额的CPU量时对这些应用程序进行节流的可能性。换句话说，通过允许切片的未使用部分在周期间保持有效，我们减少了在不需要完整切片CPU时间的CPU本地切片上浪费地过期配额的可能性。

还应考虑受CPU限制和非CPU限制交互式应用程序之间的相互作用，尤其是在单核使用率达到100%时。如果你给这两个应用程序各分配半个CPU核心，并且它们都调度在同一CPU上，在理论上非CPU限制的应用程序可能会在某些周期内额外使用最多1毫秒的配额，从而阻止受CPU限制的应用程序使用相同数量的配额。在这种情况下，将由CFS算法（参见`sched-design-CFS.rst`）决定选择哪个应用程序运行，因为它们都将可运行并且有剩余配额。这种运行时间差异将在后续周期中当交互式应用空闲时得到弥补。

示例
------
1. 限制一个组的运行时间为1个CPU的时间：

    如果周期是250毫秒且配额也是250毫秒，则该组每250毫秒可以获得1个CPU的时间。
    ```
    # echo 250000 > cpu.cfs_quota_us /* 配额 = 250ms */
    # echo 250000 > cpu.cfs_period_us /* 周期 = 250ms */
    ```

2. 在多CPU机器上限制一个组的运行时间为2个CPU的时间

    通过设置500毫秒的周期和1000毫秒的配额，该组每500毫秒可以获得2个CPU的时间：
    ```
    # echo 1000000 > cpu.cfs_quota_us /* 配额 = 1000ms */
    # echo 500000 > cpu.cfs_period_us /* 周期 = 500ms */
    ```

    较大的周期允许增加突发容量。

3. 限制一个组的运行时间为1个CPU的20%

    通过设置50毫秒的周期，10毫秒的配额相当于1个CPU的20%：
    ```
    # echo 10000 > cpu.cfs_quota_us /* 配额 = 10ms */
    # echo 50000 > cpu.cfs_period_us /* 周期 = 50ms */
    ```

    通过使用较小的周期，我们确保了一致的延迟响应，代价是减少了突发容量。

4. 限制一个组的运行时间为1个CPU的40%，并允许累积最多额外1个CPU的20%

    通过设置50毫秒的周期，20毫秒的配额相当于1个CPU的40%：
10毫秒的突发量将相当于1个CPU的20%：

	# echo 20000 > cpu.cfs_quota_us /* 配额 = 20毫秒 */
	# echo 50000 > cpu.cfs_period_us /* 周期 = 50毫秒 */
	# echo 10000 > cpu.cfs_burst_us /* 突发量 = 10毫秒 */

更大的缓冲区设置（不大于配额）允许更大的突发容量。
