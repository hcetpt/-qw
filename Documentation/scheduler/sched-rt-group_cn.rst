实时组调度
==========================

.. 目录

   0. 警告
   1. 概览
     1.1 问题
     1.2 解决方案
   2. 接口
     2.1 系统范围设置
     2.2 默认行为
     2.3 任务分组依据
   3. 未来计划

0. 警告
======

调整这些设置可能导致系统不稳定。这些选项仅限root用户使用，并假定root用户了解其操作。
值得注意的是：

 * 在`sched_rt_period_us`中设置非常小的值，当周期小于可用的高精度定时器（hrtimer）分辨率或处理预算刷新所需的时间时，可能导致系统不稳定。
 * 在`sched_rt_runtime_us`中设置非常小的值，当运行时间如此之短以至于系统难以向前推进时，可能导致系统不稳定（注意：迁移线程和kstopmachine都是实时进程）。

1. 概览
===========

1.1 问题
---------------

实时调度的关键在于确定性，一个组必须能够依赖于带宽（例如，CPU时间）的一致性。为了调度多个实时任务组，每个组必须分配到固定比例的可用CPU时间。如果没有最低保证，实时组显然会不足。模糊的上限是没有用的，因为它无法被依赖。这使我们只能选择单一的固定部分。

1.2 解决方案
----------------

通过指定在一个给定周期内可以使用的CPU时间来划分CPU时间。我们为每个实时组分配这个“运行时间”，其他实时组将不允许使用这部分时间。
任何未分配给实时组的时间将用于执行普通优先级任务（SCHED_OTHER）。任何未使用的已分配运行时间也将由SCHED_OTHER接管。
让我们考虑一个例子：一个帧固定的实时渲染器必须每秒交付25帧，这意味着每帧的周期为0.04秒。假设它还需要播放一些音乐并响应输入，留给图形处理的时间大约是80%的CPU时间。我们可以给这个组分配0.8 * 0.04秒 = 0.032秒的运行时间。
这样，图形组将有一个0.04秒的周期和0.032秒的运行时间限制。如果音频线程需要每隔0.005秒填充DMA缓冲区，但只需要大约3%的CPU时间来完成，那么它可以分配0.03 * 0.005秒 = 0.00015秒。因此，这个组可以以0.005秒的周期和0.00015秒的运行时间进行调度。
剩余的CPU时间将用于用户输入和其他任务。由于实时任务明确分配了它们执行任务所需的CPU时间，可以消除图形或音频中的缓冲区欠载。
注意：上述示例尚未完全实现。我们仍然缺乏一个EDF调度器来使非均匀周期变得可用。
### 2. 接口

#### 2.1 系统范围的设置

系统范围的设置配置在 `/proc` 虚拟文件系统下：

```
/proc/sys/kernel/sched_rt_period_us：
  相当于100% CPU带宽的调度周期。
/proc/sys/kernel/sched_rt_runtime_us：
  实时调度可以使用的全局时间限制。这总是小于或等于 `period_us`，因为它表示从 `period_us` 中分配给实时任务的时间。即使没有启用 `CONFIG_RT_GROUP_SCHED`，这也会限制分配给实时进程的时间。如果启用 `CONFIG_RT_GROUP_SCHED=y`，它表示所有实时组可用的总带宽。
* 时间以微秒（us）为单位指定，因为接口是s32。这提供了从1us到大约35分钟的操作范围。
* `sched_rt_period_us` 的取值范围是从1到INT_MAX。
* `sched_rt_runtime_us` 的取值范围是从-1到 `sched_rt_period_us`。
* 运行时间为-1表示运行时间等于周期，即没有限制。
```

#### 2.2 默认行为

`sched_rt_period_us` 的默认值为1000000（或1秒），`sched_rt_runtime_us` 的默认值为950000（或0.95秒）。这给了 `SCHED_OTHER`（非实时任务）0.05秒的使用时间。这些默认值的选择是为了防止失控的实时任务导致系统锁定，并留出一点时间来恢复系统。通过将运行时间设置为-1，可以恢复旧的行为。

默认情况下，所有带宽都分配给根组，新组从 `/proc/sys/kernel/sched_rt_period_us` 获取周期并获得0的运行时间。如果你想要将带宽分配给其他组，请减少根组的带宽，并将差额的一部分或全部分配给其他组。

实时组调度意味着你需要在接收实时任务之前为该组分配一部分总CPU带宽。因此，在你这样做之前，任何用户（即使是具有运行实时优先级进程权限的用户）都无法运行实时任务。

#### 2.3 任务分组的基础

启用 `CONFIG_RT_GROUP_SCHED` 可让你显式地为任务组分配实际的CPU带宽。

这使用了cgroup虚拟文件系统和 `<cgroup>/cpu.rt_runtime_us` 来控制每个控制组预留的CPU时间。
关于如何处理控制组的更多信息，请阅读 Documentation/admin-guide/cgroup-v1/cgroups.rst。

在检查组设置时，会根据以下限制进行验证，以确保配置可调度：

   \Sum_{i} runtime_{i} / global_period <= global_runtime / global_period

目前，这可以简化为以下内容（但请参阅未来计划）：

   \Sum_{i} runtime_{i} <= global_runtime

3. 未来计划
===============

正在进行的工作是使每个组的调度周期（"<cgroup>/cpu.rt_period_us"）也变得可配置。
周期的约束条件是子组的周期必须小于或等于其父组的周期。但在现实中，如果没有截止时间调度，这样做还不是很实用。
考虑两个兄弟组 A 和 B；它们都有 50% 的带宽，但 A 的周期是 B 的两倍：
* 组 A：周期=100000微秒，运行时间=50000微秒

    - 每 0.1 秒运行一次，持续 0.05 秒

* 组 B：周期=50000微秒，运行时间=25000微秒

    - 每 0.1 秒内运行两次，每次 0.025 秒（或每 0.05 秒运行一次）
这意味着当前情况下，在 A 中的一个 while (1) 循环将运行整个 B 的周期，并且可能导致 B 的任务（假设优先级较低）在一个完整周期内得不到调度。
下一个项目将是实现 SCHED_EDF（最早截止时间优先调度），以将完整的截止时间调度引入 Linux 内核。对上述组进行截止时间调度，并将周期结束视为一个截止时间，可以确保它们都能获得分配的时间。
实现 SCHED_EDF 可能需要一段时间才能完成。优先级继承是最大的挑战，因为当前的 Linux 优先级继承基础设施仅适用于有限的静态优先级级别 0-99。有了截止时间调度，你需要进行截止时间继承（因为优先级与截止时间差值（deadline - now）成反比）。
这意味着整个优先级继承机制需要重新设计——而这正是我们所拥有的最复杂的代码之一。
