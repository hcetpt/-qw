=====================
调度器的Nice级别设计
=====================

本文解释了新版Linux调度器中经过改进和精简的nice级别实现的思考过程。

在Linux中，nice级别一直相对较弱，人们不断要求我们让nice +19的任务消耗更少的CPU时间。遗憾的是，在旧调度器下实现这一点并不容易（否则我们早就这么做了），因为nice级别的支持历史上与时间片长度耦合，并且时间片单位由HZ滴答驱动，因此最小的时间片是1/HZ。

在2003年的O(1)调度器中，我们将负nice级别调整得比2.4版本更强（人们对这一变化感到满意），并且我们有意将线性时间片规则校准为nice +19级别恰好为1个jiffies。为了更好地理解这一点，时间片图如下所示（请见谅，这是ASCII艺术图）：

```
                   A
             \     | [时间片长度]
              \    |
               \   |
                \  |
                 \ |
                  \|___100毫秒
                   |^ . _
                   |      ^ . _
                   |            ^ . _
 -*----------------------------------*-----> [nice级别]
 -20               |                +19
                   |
                   |
```

这样，如果有人想要真正降低任务优先级，+19将会比普通的线性规则带来更大的影响。（通过更改ABI来扩展优先级的方案被早早地放弃了。）

这种方法在一段时间内部分有效，但后来当HZ=1000时，1个jiffies变成了1毫秒，这意味着0.1%的CPU使用率，我们认为这有些过分。不是因为它太小，而是因为它导致每毫秒一次的重新调度过于频繁（从而破坏缓存等）。要知道，这是很久以前硬件较弱且缓存较小的时代，人们正在以nice +19运行数值计算应用。

因此，在HZ=1000的情况下，我们将nice +19改为5毫秒，因为这似乎是合适的最小粒度——这相当于5%的CPU使用率。但nice +19对HZ敏感的基本属性仍然存在，我们从未收到关于nice +19在CPU使用率方面太弱的投诉，只收到它仍然太强的投诉。

总结来说：我们一直希望使nice级别更加一致，但在HZ、jiffies及其与时间片和粒度之间糟糕的设计耦合的限制下，这是不可行的。

关于Linux的nice级别支持的第二个（不那么常见但仍定期出现的）抱怨是其在原点周围的不对称性（如上图所示），更准确地说，nice级别的行为取决于其绝对nice级别，而nice API本质上是“相对”的：

```c
int nice(int inc);
asmlinkage long sys_nice(int increment)
```

第一个是glibc API，第二个是系统调用API。请注意，“inc”是相对于当前nice级别的。像bash的“nice”命令这样的工具也反映了这种相对API。

对于旧调度器，例如，如果你启动了一个nice +1的任务和另一个nice +2的任务，这两个任务之间的CPU分配取决于父shell的nice级别——如果父shell处于nice -10，则CPU分配不同于处于+5或+10的情况。

对Linux的nice级别支持的第三个抱怨是负nice级别不够“有力”，因此很多人不得不将音频（和其他多媒体）应用程序放在实时优先级如SCHED_FIFO下运行。但这带来了其他问题：SCHED_FIFO不具备防饥饿机制，一个有bug的SCHED_FIFO应用程序可能会永久锁定系统。

v2.6.23中的新调度器解决了所有三种类型的抱怨：

为了解决第一个抱怨（nice级别不够“有力”），调度器从“时间片”和HZ概念中解耦（并将粒度作为与nice级别分开的概念），从而能够实现更好且更一致的nice +19支持：在新调度器中，nice +19任务获得独立于HZ的1.5%，而不是旧调度器中可变的3%-5%-9%范围。
为了解决第二个抱怨（nice级别不一致），新调度器使得nice(1)对任务具有相同的CPU使用效果，无论它们的绝对nice级别如何。因此，在新调度器上运行nice +10和nice 11任务之间的CPU使用“分割”与运行nice -5和nice -4任务相同。（一个会获得55%的CPU，另一个获得45%。）这就是为什么nice级别被改为“乘法”（或指数）方式——这样无论你从哪个nice级别开始，相对结果始终相同。
第三个投诉（关于负的nice值不够“有力”，并迫使音频应用程序在更危险的SCHED_FIFO调度策略下运行）几乎被新调度器自动解决了：更强的负nice值是nice值动态范围重新校准的自然副作用。
