=============

什么是udlfb？

=============

这是一个用于DisplayLink USB 2.0时代图形芯片的驱动程序。
DisplayLink芯片提供了一些带有压缩功能的简单水平线（hline）和块传输（blit）操作，并且在USB线另一端有一个硬件帧缓冲区（16MB）。这个硬件帧缓冲区能够驱动VGA、DVI或HDMI显示器，直到像素需要改变时才需要CPU的介入。CPU或其他本地资源完成所有的渲染工作；可选地，将结果与远程硬件帧缓冲区的本地副本进行比较，以识别最小的已更改像素集；然后逐行压缩并通过USB批量传输发送这些像素。
由于批量传输的高效性以及一个无需确认（acks）的协议层——其效果是非常低的延迟，可以支持令人惊讶的高分辨率，并且对于非游戏和非视频应用具有良好的性能。
模式设置、EDID读取等是其他批量或控制传输。模式设置非常灵活，几乎可以设置任何定时模式。

USB图形的一般优势：

 * 能够向任何支持USB 2.0的系统添加几乎任意数量的显示器。在Linux中，显示器的数量受限于fbdev接口（目前FB_MAX为32）。当然，所有在同一主机控制器上的USB设备共享相同的480Mbps USB 2.0接口。

支持DisplayLink芯片的内核帧缓冲接口的优势：

 * DisplayLink芯片的实际硬件功能几乎完全匹配fbdev接口，使得驱动程序相对于提供的功能来说非常小且紧密。
 * X服务器和其他应用程序可以从用户模式使用标准的fbdev接口与设备通信，而无需了解任何关于USB或DisplayLink协议的信息。“displaylink”X驱动程序和稍作修改的“fbdev”X驱动程序已经实现了这一点。

劣势：

 * fbdev的mmap接口假定映射了一个真实的硬件帧缓冲区。在USB图形的情况下，它只是一个分配的（虚拟）缓冲区。
写操作需要被CPU检测并编码为USB批量传输。
准确的损坏/更改区域通知可以解决这个问题。
未来，希望fbdev能够增强一个小的标准接口，允许mmap客户端报告损坏情况，以利于虚拟或远程帧缓冲区。

* fbdev在客户端对帧缓冲区的所有权仲裁方面表现不佳。
* fbcon假定找到的第一个帧缓冲区应该用于控制台。
* 鉴于KMS/DRM的兴起，fbdev的未来尚不明确。

如何使用？
==============

当作为模块加载时，udlfb将匹配所有USB 2.0时代的DisplayLink芯片（Alex和Ollie系列）。然后它会尝试读取显示器的EDID，并根据DisplayLink设备和显示器能力设置最佳通用模式。
如果DisplayLink设备成功，它会显示一个“绿屏”，这意味着从硬件和fbdev软件的角度来看，一切正常。
此时，将存在一个/dev/fb?接口供用户模式应用程序打开并开始使用标准fbdev调用写入DisplayLink设备的帧缓冲区。需要注意的是，默认情况下，如果使用mmap()，用户模式应用程序必须发送损坏通知来触发更改区域的重绘。或者，可以通过启用实验性的defio支持重新编译udlfb，以支持基于页面故障的检测机制，从而无需显式通知即可工作。
最常见的udlfb客户端是xf86-video-displaylink或修改过的xf86-video-fbdev X服务器。这些服务器没有真正的DisplayLink特定代码。它们写入标准帧缓冲区接口，并依赖udlfb完成其功能。它们的一个额外功能是能够通过udlfb的损坏接口将X DAMAGE协议扩展中的矩形报告给udlfb（这有望成为所有需要损坏信息的虚拟帧缓冲区的标准）。这些损坏通知使udlfb能够高效地处理更改的像素。
模块选项
==============

通常不需要对 udlfb 进行特殊配置。不过，确实有一些选项：

从命令行传递选项给 modprobe ：

```
modprobe udlfb fb_defio=0 console=1 shadow=1
```

或者通过编辑 `/sys/module/udlfb/parameters/PARAMETER_NAME` 动态更改选项 ：

```
cd /sys/module/udlfb/parameters
ls # 查看参数名称列表
sudo nano PARAMETER_NAME
# 在原地更改参数，并保存文件
```

拔掉并重新插入 USB 设备以应用新的设置。

或者为了永久应用选项，可以创建一个 modprobe 配置文件，如 `/etc/modprobe.d/udlfb.conf` ，内容如下：

```
options udlfb fb_defio=0 console=1 shadow=1
```

接受的布尔选项：

=============== ================================================================
fb_defio     使用 fb_defio（CONFIG_FB_DEFERRED_IO）内核模块通过页面错误跟踪帧缓冲区中改变的区域。
标准的 fbdev 应用程序使用 mmap 但不报告损坏时，启用此选项应该能正常工作。
在运行支持通过 ioctl 报告改变区域的 X 服务器时禁用此选项，因为这种方法更简单、更稳定且性能更高。
默认值：fb_defio=1

console     允许 fbcon 附加到 udlfb 提供的帧缓冲区。
如果 fbcon 和其他客户端（例如带有 --shared-vt 的 X 服务器）发生冲突，可以禁用此选项。
默认值：console=1

shadow     分配第二个帧缓冲区来镜像当前跨 USB 总线在设备内存中的内容。如果任何像素未改变，则不传输。使用主机内存来节省 USB 传输。
默认启用。仅在内存非常低的系统上禁用。
=============== ==============================================================
默认值：shadow=1
=============== ================================================================

Sysfs 属性
================

Udlfb 在 /sys/class/graphics/fb? 中创建了多个文件，其中 ? 是特定 DisplayLink 设备的顺序帧缓冲 ID。

======================== ========================================================
edid			 如果将一个有效的 EDID 数据块写入此文件（通常
			 由 udev 规则完成），则 udlfb 将使用此 EDID 作为备份，
			 以防读取连接到 DisplayLink 设备的显示器实际 EDID 失败。
			 这对于那些无法通过 EDID 通信其功能的固定面板等特别有用。
			 读取此文件会返回连接显示器的当前 EDID（或上次写入的备份值）。
			 这有助于获取连接显示器的 EDID，并可以传递给像 parse-edid 这样的工具。
metrics_bytes_rendered	 渲染像素字节数的 32 位计数

metrics_bytes_identical  32 位计数，表示这些字节中有多少被发现未改变，
			 基于影子帧缓冲检查

metrics_bytes_sent	 传输更改后的像素所需的字节数的 32 位计数，
			 包括通过 USB 通信的压缩和协议开销

metrics_cpu_kcycles_used  处理上述像素所使用的 CPU 周期数的 32 位计数
			 （以千个周期为单位）
metrics_reset		 只写。向此文件写入任何内容都会将所有上述指标重置为零。
			 注意，上述 32 位计数器很快就会溢出。为了获得可靠的结果，
			 设计性能测试时应确保测试开始和结束在一个非常短的时间内（一分钟或更短是安全的）。
======================== ========================================================

Bernie Thompson <bernie@plugable.com>
