=======================
帧缓冲设备
=======================

最后修订：2001年5月10日

0. 引言
---------------

帧缓冲设备为图形硬件提供了一种抽象。它表示某些视频硬件的帧缓冲区，并允许应用程序通过一个明确定义的接口访问图形硬件，因此软件不需要了解任何关于低级（硬件寄存器）的信息。该设备通过位于 `/dev` 目录中的特殊设备节点进行访问，例如 `/dev/fb*`。

1. 用户视角下的 `/dev/fb*`
--------------------------

从用户的角度来看，帧缓冲设备就像 `/dev` 中的任何其他设备一样。它是一个主设备号为29的字符设备；次设备号指定了帧缓冲的编号。
按照惯例，使用以下设备节点（数字表示设备的次设备号）：

```
0 = /dev/fb0 第一个帧缓冲
1 = /dev/fb1 第二个帧缓冲
...
31 = /dev/fb31 第32个帧缓冲
```

为了向后兼容，你可能希望创建以下符号链接：

```
/dev/fb0current -> fb0
/dev/fb1current -> fb1
```

以此类推。
帧缓冲设备也是“正常”的内存设备，这意味着你可以读取和写入它们的内容。例如，你可以通过以下命令来制作屏幕快照：

```
cp /dev/fb0 myfile
```

同时可以存在多个帧缓冲设备，例如如果你有一个内置硬件之外的显卡。相应的帧缓冲设备（如 `/dev/fb0` 和 `/dev/fb1` 等）独立工作。
使用帧缓冲设备的应用程序（如X服务器）默认会使用 `/dev/fb0`（旧软件使用 `/dev/fb0current`）。你可以通过设置环境变量 `$FRAMEBUFFER` 来指定替代的帧缓冲设备，例如（对于 `sh/bash` 用户）：

```
export FRAMEBUFFER=/dev/fb1
```

或者（对于 `csh` 用户）：

```
setenv FRAMEBUFFER /dev/fb1
```

这样之后，X服务器将使用第二个帧缓冲设备。

2. 程序员视角下的 `/dev/fb*`
--------------------------------

正如你已经知道的，帧缓冲设备是一个像 `/dev/mem` 一样的内存设备，并且具有相同的功能。你可以读取、写入它，在其中定位并使用 `mmap()`（主要用途）。不同之处在于，特殊文件中出现的内存不是整个内存，而是某些视频硬件的帧缓冲区。
`/dev/fb*` 还允许执行多个 `ioctl` 操作，通过这些操作可以查询和设置大量关于硬件的信息。颜色映射处理也通过 `ioctl` 实现。查看 `<linux/fb.h>` 以获取更多关于存在的 `ioctl` 及其操作的数据结构的信息。这里仅做一个简要概述：

- 你可以请求关于硬件的不可更改信息，例如名称、屏幕内存组织（平面、打包像素等）以及屏幕内存的地址和长度。
- 你可以请求并更改关于硬件的可变信息，例如可见几何、虚拟几何、深度、颜色映射格式、定时等。
如果你尝试更改这些信息，驱动程序可能会对某些值进行四舍五入以满足硬件的能力（如果无法实现则返回EINVAL）。

你可以获取和设置颜色映射的一部分。通信使用每种颜色部分（红色、绿色、蓝色、透明度）16位来支持所有现有硬件。驱动程序会执行所有必要的计算以应用到硬件（可能将其向下取整为更少的位数，甚至丢弃透明度）。

这种硬件抽象使得应用程序的实现更加简单和便携。例如，X服务器完全基于/dev/fb*工作，因此不需要知道具体硬件的颜色寄存器是如何组织的。XF68_FBDev是一个用于位图、未加速视频硬件的通用X服务器。应用程序需要内置的部分只有屏幕组织（位平面或块像素等），因为它直接在帧缓冲区图像数据上工作。

未来计划是将图形卡和其他设备的帧缓冲区驱动程序作为内核模块在运行时加载。这样的驱动程序只需调用register_framebuffer()并提供一些函数。独立编写和分发这些驱动程序将节省很多麻烦。

3. 帧缓冲区分辨率维护
------------------------

帧缓冲区分辨率使用工具`fbset`进行维护。它可以更改帧缓冲区设备的视频模式属性。主要用途是在启动过程中（例如，在你的/etc/rc.*或/etc/init.d/*文件中）更改当前视频模式。

Fbset使用存储在配置文件中的视频模式数据库，因此你可以轻松添加自己的模式，并通过简单的标识符引用它们。

4. X服务器
------------

X服务器（XF68_FBDev）是帧缓冲区设备最显著的应用程序。从XFree86 3.2版本开始，X服务器成为XFree86的一部分，并具有两种模式：

- 如果/etc/XF86Config文件中`fbdev`驱动程序的`Display`子节包含如下行：
  
  Modes "default"
  
  则X服务器将使用上述方案，即它将以/dev/fb0（或设置了$FRAMEBUFFER）确定的分辨率启动。你仍然需要指定颜色深度（使用Depth关键字）和虚拟分辨率（使用Virtual关键字）。这是XFree86提供的配置文件的默认设置。这是一种最简单的配置，但有一些限制。
- 因此，也可以在/etc/XF86Config文件中指定分辨率。这允许在保留相同虚拟桌面大小的情况下动态切换分辨率。使用的帧缓冲区设备仍然是/dev/fb0current（或$FRAMEBUFFER），但可用的分辨率由/etc/XF86Config定义。缺点是你需要以不同的格式指定时序（但`fbset -x`可以帮助你）。

要调整视频模式，你可以使用fbset或xvidtune。请注意，xvidtune与XF68_FBDev并不完全兼容：报告的时钟值总是不正确的。
5. 视频模式时序
---------------------

显示器通过使用电子束（彩色显示器为3束，单色显示器为1束）在屏幕上绘制图像。屏幕的正面覆盖着由像素组成的彩色荧光粉图案。当荧光粉被电子击中时，它会发射一个光子并变得可见。电子束从左到右、从屏幕顶部到底部绘制水平线（扫描线）。通过调节电子束的强度，可以显示不同颜色和亮度的像素。每条扫描线之后，电子束必须返回到屏幕的左侧和下一行：这称为水平回扫。整个屏幕（帧）绘制完成后，电子束返回到屏幕的左上角：这称为垂直回扫。在水平回扫和垂直回扫期间，电子束会被关闭（消隐）。

电子束绘制像素的速度由显卡上的点时钟决定。例如，对于28.37516 MHz（每秒百万个周期）的点时钟，每个像素持续时间为35242皮秒：

    1/(28.37516E6 Hz) = 35.242E-9 秒

如果屏幕分辨率为640x480，则绘制640个（xres）像素所需的时间为：

    640 * 35.242E-9 秒 = 22.555E-6 秒

但水平回扫也需要时间（例如272个“像素”），因此完整的扫描线需要：

    (640 + 272) * 35.242E-9 秒 = 32.141E-6 秒

我们可以说水平扫描频率约为31 kHz：

    1/(32.141E-6 秒) = 31.113E3 Hz

整个屏幕包含480（yres）行，但还必须考虑垂直回扫（例如49行）。因此，完整的屏幕需要：

    (480 + 49) * 32.141E-6 秒 = 17.002E-3 秒

垂直扫描频率约为59 Hz：

    1/(17.002E-3 秒) = 58.815 Hz

这意味着屏幕数据每秒刷新大约59次。为了获得稳定的图像且没有明显的闪烁，VESA建议至少使用72 Hz的垂直扫描频率。但是，感知到的闪烁非常依赖于个人：有些人可以在50 Hz下毫无问题地使用，而我在低于80 Hz时就能察觉。

由于显示器不知道新扫描线何时开始，显卡将为每条扫描线提供一个同步脉冲（水平同步或hsync）。类似地，它为每一帧提供一个同步脉冲（垂直同步或vsync）。图像在屏幕上的位置受同步脉冲发生时刻的影响。

下图总结了所有时序。水平回扫时间是左边距、右边距和hsync长度之和，而垂直回扫时间是上边距、下边距和vsync长度之和：

  +----------+---------------------------------------------+----------+-------+
  |          |                ↑                            |          |       |
  |          |                |upper_margin                |          |       |
  |          |                ↓                            |          |       |
  +----------###############################################----------+-------+
  |          #                ↑                            #          |       |
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |   left   #                |                            #  right   | hsync |
  |  margin  #                |       xres                 #  margin  |  len  |
  |<-------->#<---------------+--------------------------->#<-------->|<----->|
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |          #                |yres                        #          |       |
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |          #                |                            #          |       |
  |          #                ↓                            #          |       |
  +----------###############################################----------+-------+
  |          |                ↑                            |          |       |
  |          |                |lower_margin                |          |       |
  |          |                ↓                            |          |       |
  +----------+---------------------------------------------+----------+-------+
  |          |                ↑                            |          |       |
  |          |                |vsync_len                   |          |       |
  |          |                ↓                            |          |       |
  +----------+---------------------------------------------+----------+-------+

帧缓冲设备期望所有水平时序以点时钟数量表示（皮秒，1E-12秒），垂直时序以扫描线数量表示。

6. 将XFree86时序值转换为帧缓冲设备时序
--------------------------------------------------------------------

XFree86模式行由以下字段组成：

 "800x600"     50      800  856  976 1040    600  637  643  666
 < 名称 >     DCF       HR  SH1  SH2  HFL     VR  SV1  SV2  VFL

帧缓冲设备使用的字段如下：

  - pixclock: 像素时钟（皮秒）
  - left_margin: 同步到图像的时间
  - right_margin: 图像到同步的时间
  - upper_margin: 同步到图像的时间
  - lower_margin: 图像到同步的时间
  - hsync_len: 水平同步的长度
  - vsync_len: 垂直同步的长度

1) 像素时钟：

   XFree86: MHz

   帧缓冲设备: 皮秒（ps）

   pixclock = 1000000 / DCF

2) 水平时序：

   left_margin = HFL - SH2

   right_margin = SH1 - HR

   hsync_len = SH2 - SH1

3) 垂直时序：

   upper_margin = VFL - SV2

   lower_margin = SV1 - VR

   vsync_len = SV2 - SV1

VESA时序的好例子可以在XFree86源代码树中的“xc/programs/Xserver/hw/xfree86/doc/modeDB.txt”找到。

7. 参考资料
-------------

有关帧缓冲设备及其应用程序的更多信息，请参阅Linux-fbdev网站：

    http://linux-fbdev.sourceforge.net/

以及以下文档：

  - fbset的手册页：fbset(8)，fb.modes(5)
  - XFree86的手册页：XF68_FBDev(1)，XF86Config(4/5)
  - 强大的内核源代码：

      - linux/drivers/video/
      - linux/include/linux/fb.h
      - linux/include/video/

8. 邮件列表
---------------

有一个与帧缓冲设备相关的邮件列表位于kernel.org：
linux-fbdev@vger.kernel.org
请访问http://sourceforge.net/projects/linux-fbdev/获取订阅信息和存档浏览。

9. 下载
--------------

所有必要的文件都可以在以下位置找到：

    ftp://ftp.uni-erlangen.de/pub/Linux/LOCAL/680x0/

及其镜像站点。
最新版本的 fbset 可以在以下网址找到：

    http://www.linux-fbdev.org/

10. 鸣谢
--------

本说明文件由 Geert Uytterhoeven 撰写，部分基于 Roman Hodek 和 Martin Schaller 的原始 `X-framebuffer.README`。第 6 节由 Frank Neumann 提供。
帧缓冲设备抽象由 Martin Schaller 设计。
