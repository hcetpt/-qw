### 延迟 IO
### 

延迟 IO 是一种推迟并重新利用 IO 的方法。它使用主机内存作为缓冲区，并利用 MMU 页面错误作为执行设备 IO 的预触发条件。以下示例可能有助于解释这种设置的工作原理：

- 用户空间应用程序（如 Xfbdev）映射帧缓冲区
- 延迟 IO 和驱动程序设置页面错误和 page_mkwrite 处理程序
- 用户空间应用程序尝试写入映射的虚拟地址
- 触发页面错误并到达错误处理程序
- 错误处理程序找到并返回物理页
- 在 page_mkwrite 中，我们将此页添加到列表中
- 计划一个工作队列任务，在延迟后运行
- 应用程序继续写入该页，无需额外成本。这是关键优势
- 工作队列任务启动并清理列表中的页面，然后完成更新帧缓冲区的相关工作。这是实际与设备通信的工作
- 应用程序尝试写入已被清理的地址
- 触发页面错误，上述序列再次发生

从上面可以看出，其中一个好处是允许突发帧缓冲区写入以最低成本进行。然后在一段时间后（希望此时事情已经平静），我们真正更新帧缓冲区，这是一个相对更昂贵的操作。对于某些类型的非易失性高延迟显示器，所需的图像是最终图像而不是中间阶段，这就是为什么可以不为每次写入更新的原因。这也可能适用于其他场景。Paul Mundt 提到了一个案例，即根据页面计数决定是否合并并发出 SG DMA 或进行内存突发。另一种情况可能是，如果设备帧缓冲区采用特殊格式（例如对角线偏移的 RGB），这可能是允许应用程序假装拥有正常帧缓冲区并在垂直同步时基于已触及的页面列表重新排列的一种机制。

如何使用它：（针对应用程序）
---------------------------------
无需任何更改。像平常一样映射帧缓冲区并使用它。

如何使用它：（针对 fbdev 驱动程序）
----------------------------------
以下示例可能有所帮助：
1. 设置您的结构。例如：
   ```
   static struct fb_deferred_io hecubafb_defio = {
       .delay = HZ,
       .deferred_io = hecubafb_dpy_deferred_io,
   };
   ```

   延迟是 page_mkwrite 触发发生与调用延迟 IO 回调之间的最小延迟。延迟 IO 回调如下所述。
2. 设置您的延迟 IO 回调。例如：
   ```
   static void hecubafb_dpy_deferred_io(struct fb_info *info,
                                        struct list_head *pagelist)
   ```

   延迟 IO 回调是您执行所有显示设备 IO 的地方。您会收到页面列表，这是在延迟期间被写入的页面列表。您不得修改此列表。此回调是从工作队列调用的。
3. 调用 `init`：

```c
info->fbdefio = &hecubafb_defio;
fb_deferred_io_init(info);
```

4. 调用 `cleanup`：

```c
fb_deferred_io_cleanup(info);
```
