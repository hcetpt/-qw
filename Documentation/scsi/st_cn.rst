```spdx
许可协议标识符: GPL-2.0

====================
SCSI 磁带驱动程序
====================

此文件包含关于 SCSI 磁带驱动程序的简要信息。
该驱动程序目前由 Kai Mäkisara 维护（电子邮件：Kai.Makisara@kolumbus.fi）

最后修改时间：2016年2月9日星期二 21:54:16 由 kai.makisara

基础
======

该驱动程序是通用的，即它不包含任何针对特定磁带驱动器的代码。磁带参数可以通过以下三种方法之一进行指定：

1. 每个用户可以直接通过 ioctl 指定他们想要使用的磁带参数。这是一种非常简单且灵活的方法，适用于单用户工作站。然而，在多用户环境中，下一个用户会发现磁带参数仍处于前一个用户设置的状态。
2. 系统管理员（root）可以定义一些磁带参数（如块大小和密度）的默认值，使用 MTSETDRVBUFFER ioctl。这些参数可以在新磁带加载到驱动器时或在磁带开头开始写入时生效。如果磁带驱动器能够很好地自动检测磁带格式（如某些 QIC 驱动器），则第二种方法适用。这样，任何磁带都可以被读取，可以继续使用现有的格式进行写入，并且如果从头开始重写磁带（或首次写入新磁带）时将使用默认格式。如果驱动器无法很好地自动检测格式，并且设备有一种“合理”的模式，则可以使用第一种方法。例如，仅在可变块模式下使用的 DAT 驱动器（我不知道这是否合理 :-)
用户可以覆盖系统管理员定义的参数。这些更改将持续到默认值再次生效。
3. 默认情况下，最多可以定义四种模式，并使用次设备号（位5和6）进行选择。模式的数量可以通过更改 st.h 中的 ST_NBR_MODE_BITS 来调整。模式 0 对应于上述默认值。其他模式在被系统管理员（root）定义之前处于休眠状态。当定义新模式时，模式 0 的配置用于为新定义提供起点。
使用模式允许系统管理员给用户提供对一些缓冲参数的选择权（缓冲写入和异步写入）。模式还允许在多磁带操作中选择不同的格式（显式覆盖的参数会在加载新磁带时重置）。
如果使用多个模式，所有模式都应该包含相同参数集的定义。
许多 Unix 系统包含内部表，将不同模式与支持的设备关联起来。Linux SCSI 磁带驱动程序不包含这样的表（将来也不会包含）。相反，可以编写一个实用程序来获取设备发送的查询数据，扫描其数据库，并使用 ioctl 设置模式。另一种选择是编写一个小脚本，使用 mt 设置适合系统的默认值。
该驱动程序支持固定和可变块大小（在缓冲区限制内）。自动倒带（次设备号等于设备号）和非倒带设备（次设备号为 128 加设备号）均已实现。
```
在可变块模式下，`write()` 中的字节数决定了磁带上物理块的大小。读取时，驱动程序读取下一个磁带块，并将数据返回给用户，如果 `read()` 的字节数至少等于块大小。否则，返回错误 `ENOMEM`。

在固定块模式下，驱动程序和磁盘之间的数据传输是块大小的倍数。`write()` 的字节数必须是块大小的倍数。读取时不需要这样做，但为了可移植性，建议这样做。

提供了更改磁带分区和使用一个或两个分区对磁带进行分区的支持。默认情况下，每个驱动程序禁用了对分区磁带的支持，可以通过 `ioctl` 命令 `MTSETDRVBUFFER` 启用。

默认情况下，驱动程序在关闭设备后写入一个文件标记（filemark），并且最后一个操作是写操作。可以可选地写入两个文件标记。在这两种情况下，通过连续两次读取零字节来表示数据结束。

在 SCSI 命令块中未设置立即位（immediate bit）的情况下写入文件标记作为同步点，即，在命令返回之前，从驱动程序缓冲区写入所有剩余的数据。这确保了在此处捕获写入错误，但这需要时间。在某些应用程序中，需要快速连续写入多个文件。`MTWEOFI` 操作可用于在不刷新驱动程序缓冲区的情况下写入文件标记。在 `close()` 时写入文件标记始终会刷新驱动程序缓冲区。但是，如果上一个操作是 `MTWEOFI`，则 `close()` 不会写入文件标记。如果程序希望在文件之间关闭/打开磁带设备并希望跳过等待，可以使用此功能。

如果执行了回绕（rewind）、离线（offline）、向后搜索（bsf）或定位（seek）操作，并且之前的磁带操作是写操作，则在移动磁带前写入一个文件标记。

编译选项定义在文件 `linux/drivers/scsi/st_options.h` 中。

如果使用了 `O_NONBLOCK` 打开选项，即使驱动程序未准备好，打开也会成功。如果没有使用 `O_NONBLOCK`，驱动程序会等待驱动程序准备好。如果在 `ST_BLOCK_SECONDS` 秒内没有发生这种情况，打开会失败，并返回错误码 `EIO`。使用 `O_NONBLOCK` 时，即使驱动器中有写保护的磁带，也可以打开设备以进行写入（尝试写入的命令会返回错误）。

次要编号
========

磁带驱动程序目前支持最多 2^17 个驱动器，如果为每个驱动器使用 4 种模式的话。
次要编号由以下位字段组成：

```
dev_upper non-rew mode dev-lower
20 -  8     7    6 5  4      0
```

非回绕位始终是位 7（最低字节中的最高位）。定义模式的位在非回绕位之下。其余位定义磁带设备号。这种编号与仅使用 8 位次要编号时的编号方式向后兼容。
Sysfs 支持
=============

驱动程序创建目录 `/sys/class/scsi_tape` 并填充与现有磁带设备对应的子目录。对于每种模式，都有自动回绕和非回绕条目。名称为 `stxy` 和 `nstxy`，其中 `x` 是磁带编号，`y` 是一个对应于模式的字符（无、l、m、a）。例如，第一个磁带设备的目录（假设四种模式）是：`st0` `nst0` `st0l` `nst0l` `st0m` `nst0m` `st0a` `nst0a`
每个目录包含以下条目：`default_blksize` `default_compression` `default_density` `defined` `dev` `device` `driver`。文件 `defined` 包含 1（如果该模式已定义）或 0（如果没有定义）。文件 `default_*` 包含用户设置的默认值。值 `-1` 表示未设置默认值。文件 `dev` 包含与此设备对应的设备号。链接 `device` 和 `driver` 指向 SCSI 设备和驱动程序条目。每个目录还包含条目 `options`，显示当前启用的驱动程序和模式选项。文件中的值是一个位掩码，其位定义与使用 `MTSETDRVBUFFER` 设置选项时相同。

一个名为 `tape` 的链接从 SCSI 设备目录指向模式 0 自动回绕设备（例如 `st0`）对应的类目录。

Sysfs 和磁带设备的统计信息
=====================================

`st` 驱动程序在 sysfs 文件系统中维护磁带驱动器的统计信息。
以下方法可用于定位可用的统计信息（假设 sysfs 挂载在 `/sys`）：

1. 对目录 `/sys/class/scsi_tape` 使用 `opendir(3)`。
2. 使用 `readdir(3)` 读取目录内容。
3. 使用 `regcomp(3)/regexec(3)` 将目录条目与扩展正则表达式 `"^st[0-9]+$"` 进行匹配。
4. 从 `/sys/class/scsi_tape/<match>/stats` 目录访问统计信息（其中 `<match>` 是来自 `/sys/class/scsi_tape` 的与扩展正则表达式匹配的目录条目）。

采用这种方法的原因是所有指向同一磁带驱动器的字符设备都使用相同的统计信息。这意味着 `st0` 和 `nst0` 会有相同的统计信息。

目录包含以下统计信息文件：

1. `in_flight`  
   - 当前正在处理的针对此设备的 I/O 数量。
2. `io_ns`  
   - 等待所有 I/O 完成所花费的时间（以纳秒为单位），包括读写操作。这还包括磁带移动命令，如在文件或集合标记之间寻道以及使用自动回绕功能关闭磁带设备时的隐式磁带移动。
3. `other_cnt`  
   - 发送给磁带驱动器的除读写命令之外的其他 I/O 命令数量。完成这些命令所需时间的计算公式为 `io_ms - read_ms - write_ms`。
4. `read_byte_cnt`  
   - 从磁带驱动器读取的字节数。
5. read_cnt  
   - 发出到磁带驱动器的读取请求次数

6. read_ns  
   - 等待读取请求完成所花费的时间（以纳秒为单位）

7. write_byte_cnt  
   - 写入磁带驱动器的字节数

8. write_cnt  
   - 发出到磁带驱动器的写入请求次数

9. write_ns  
   - 等待写入请求完成所花费的时间（以纳秒为单位）

10. resid_cnt  
    - 在读取或写入过程中发现残留量不为零的次数。这意味着程序发出的读取请求大于磁带上的块大小。对于写入，表示并非所有数据都已写入磁带。

注意：

- 当 I/O 开始时，in_flight 值会递增，但直到 I/O 完成后才会将该 I/O 添加到统计信息中。
- read_cnt、write_cnt 和 other_cnt 的总和可能与设备级别的 iodone_cnt 不一致。磁带统计信息仅计算通过 st 模块发出的 I/O。
- 当 I/O 正在进行时，读取的统计信息可能在时间上不一致。各个值是原子地读取和写入的，但在通过 sysfs 读取它们时，可能会在开始 I/O 或完成 I/O 时处于更新过程中。
- in_flight 显示的值会在任何统计信息更新之前递增，并在更新统计信息后 I/O 完成时递减。
当由 st 驱动程序发出的 I/O 请求未完成时，`in_flight` 的值为 0。磁带统计信息不包括通过 sg 设备执行的任何 I/O 操作。

### BSD 和 Sys V 语义

用户可以通过定义符号 `ST_SYSV` 的值来选择磁带驱动程序的这两种行为之一。在关闭正在读取的文件时，语义有所不同。BSD 语义会将磁带留在当前的位置，而 Sys V 语义会在刚越过文件标记的情况下将磁带移动到下一个文件标记之后。
默认情况下采用的是 BSD 语义。

### 缓冲

驱动程序尝试直接从用户空间进行数据传输。如果这不可能，则使用运行时分配的驱动缓冲区。如果整个传输过程中无法实现直接 I/O，也会使用驱动缓冲区（即，不会为单个页面使用跳转缓冲区）。直接 I/O 可能因为多种原因无法实现，例如：

- 一个或多个页面位于 HBA 无法访问的地址上；
- 转移中的页面数量超过了 HBA 允许的散/聚段的数量；
- 一个或多个页面无法锁定在内存中（在合理的情况下不应发生）。

驱动缓冲区的大小至少为一个磁带块。在固定块模式下，最小缓冲区大小（以 1024 字节为单位）由 `ST_FIXED_BUFFER_BLOCKS` 定义。对于小块大小，这允许缓冲多个块，并使用一次 SCSI 读或写来传输所有块。如果 `ST_BUFFER_WRITES` 非零且未使用直接 I/O，则允许在固定块模式下跨写调用进行数据缓冲。
缓冲区分配使用大小为 2^n * （页大小）的内存块。因此，实际缓冲区大小可能大于最小允许的缓冲区大小。

请注意，如果使用直接 I/O，则小写操作不会被缓冲。这可能会导致从 2.4 版本迁移到 2.6 版本时出现问题。在 2.4 版本中，小写操作（例如，未指定 `-b` 选项的 tar）可能具有良好的吞吐量，但在 2.6 版本中则不再如此。可以通过关闭直接 I/O 来解决此问题，但更好的解决方案是使用更大的 `write()` 字节数（例如，tar -b 64）。

### 异步写入

启动将缓冲区内容写入磁带的操作，并立即返回写调用。在下次磁带操作时检查状态。异步写入不会在直接 I/O 或固定块模式下进行。

在某些罕见情况下，如果在早期警告标记后没有足够的空间来刷新驱动缓冲区，缓冲写入和异步写入可能会在多卷操作中引起问题。

### 固定块模式下的预读（`ST_READ_AHEAD`）

即使用户不想在这次读命令中获取所有数据，也尝试填充缓冲区。对于不喜欢文件标记截断读请求或不喜欢回退的驱动器，应禁用该功能。

### 散/聚缓冲区

如果无法分配连续缓冲区，则使用散/聚缓冲区（由物理内存中非连续的块组成）。为了支持所有 SCSI 适配器（包括不支持散/聚的适配器），缓冲区分配使用以下三种类型的块：

1. 初始段，用于所有 SCSI 适配器，包括不支持散/聚的适配器。如果系统可以提供这个大小的块（并且不大于 `ST_BUFFER_BLOCKS` 指定的缓冲区大小），则该缓冲区的大小为 `(PAGE_SIZE << ST_FIRST_ORDER)` 字节。如果这个大小不可用，驱动程序将大小减半并再次尝试，直到一页的大小为止。`st_options.h` 中的默认设置使驱动程序尝试一次性分配整个缓冲区。
2. 为了填充指定的缓冲区大小，分配了尽可能多的散/聚段（scatter/gather segments），但这些段的数量不会超过ST_FIRST_SG。

3. 剩余的段数在ST_MAX_SG（或模块参数max_sg_segs）与第1和第2阶段中使用的段数之间，如果有必要，可以在运行时扩展缓冲区。如果SCSI适配器允许的散/聚段数量小于规定的最大散/聚段数量，则不会超过这个限制。如果SCSI适配器允许的最大段数小于第1和第2阶段中使用的段数，则扩展缓冲区将总是失败。

介质结束时写入的行为
==========================

当遇到介质提前结束警告时，当前写操作完成，并返回字节数。下一次写操作将返回-1，并且errno设置为ENOSPC。为了允许写入尾部数据，允许进行下一次写操作，并且如果成功，则返回字节数。之后，-1和字节数将交替返回，直到遇到物理介质末尾（或其他错误）为止。

模块参数
=================

当驱动程序作为模块加载时，可以配置缓冲区大小、写入阈值和最大分配缓冲区数量。关键字如下：

========================== ===========================================
buffer_kbs=xxx             固定块模式下的缓冲区大小设置为xxx千字节
write_threshold_kbs=xxx    写入阈值设置为xxx千字节
max_sg_segs=xxx            最大散/聚段数量
try_direct_io=x            如果非零，则尝试直接从用户缓冲区到磁带驱动器传输
========================== ===========================================

注意，如果更改了缓冲区大小但未设置写入阈值，则写入阈值将设置为新的缓冲区大小减去2千字节。

启动时配置
=======================

如果驱动程序编译到内核中，也可以使用LILO命令行等方式设置相同的参数。首选语法是使用加载模块时使用的相同关键字，但在前面加上'st.'。例如，要设置最大散/聚段数量，应使用参数'st.max_sg_segs=xx'（xx是散/聚段的数量）。

为了兼容早期2.5和2.4内核版本，仍然支持旧的语法。可以使用加载模块时的相同关键字。如果设置了多个参数，则关键字-值对用逗号分隔（不允许有空格）。可以使用冒号代替等号。定义前加上字符串st=。以下是一个示例：

```
st=buffer_kbs:64,write_threshold_kbs:60
```

旧内核版本使用的以下语法也支持：

```
st=aa[,bb[,dd]]
```

其中：
  - aa是固定块模式下的缓冲区大小，单位为1024字节
  - bb是写入阈值，单位为1024字节
  - dd是最大散/聚段数量

IOCTLs
======

通过在mtio.h中定义的ioctl来定位磁带并设置驱动器参数。磁带控制程序'mt'使用这些ioctl。尽量找到一个支持所有Linux SCSI磁带ioctl并在修改磁带内容时打开设备以供写入的mt（可以在Linux FTP站点上查找包mt-st*；GNU mt不支持写入，例如擦除）。
支持的ioctl如下：

以下使用结构mtop：

MTFSF
  向前跳过count个文件标记。磁带定位在文件标记后
MTFSFM
  如上，但磁带定位在文件标记前
MTBSF
  向后跳过count个文件标记。磁带定位在文件标记前
MTBSFM
  如上，但磁带定位在文件标记后
MTFSR  
向前移动指定记录数

MTBSR  
向后移动指定记录数

MTFSS  
向前移动指定设定标记数

MTBSS  
向后移动指定设定标记数

MTWEOF  
写入指定数量的文件标记

MTWEOFI  
写入指定数量的文件标记并立即设置（即，不等待数据写入磁带）

MTWSM  
写入指定数量的设定标记

MTRW  
回绕磁带

MTOFFL  
将设备设置为离线状态（通常是回绕并弹出磁带）

MTNOP  
除了刷新缓冲区外不做任何操作

MTRETEN  
重新张紧磁带
MTEOM  
磁带末尾空闲空间

MTERASE  
擦除磁带。如果参数为零，则使用短擦除命令；对于其他所有参数值，使用长擦除命令

MTSEEK  
定位到磁带块计数。对于SCSI-1驱动器使用Tandberg兼容的寻道（QFA），对于SCSI-2驱动器使用SCSI-2寻道。寻道后状态中的文件和块号无效

MTSETBLK  
设置驱动器的块大小。设置为零则将驱动器置于可变块模式（如果适用）

MTSETDENSITY  
设置驱动器密度代码为参数值。请参阅驱动器文档以获取可用的代码

MTLOCK 和 MTUNLOCK  
显式锁定/解锁磁带驱动器门

MTLOAD 和 MTUNLOAD  
显式加载和卸载磁带。如果命令参数x在MT_ST_HPLOADER_OFFSET + 1到MT_ST_HPLOADER_OFFSET + 6之间，数字x将被发送给驱动器，并选择HP C1553A换带机中使用的磁带槽

MTCOMPRESSION  
使用SCSI模式页15设置压缩或解压缩驱动器模式。注意某些驱动器使用其他方法来控制压缩。一些驱动器（如Exabytes）使用密度代码来控制压缩。一些驱动器使用其他模式页，但该页面尚未在驱动程序中实现。没有压缩功能的一些驱动器将无错误地接受任何压缩模式

MTSETPART  
在下一次磁带操作时将磁带移动到由参数指定的分区。除非下一次磁带操作是MTSEEK，在这种情况下磁带将直接移动到由MTSEEK指定的块，否则磁带定位的块将是新激活分区内磁带先前定位的块。除非设置了MT_ST_CAN_PARTITIONS，否则MTSETPART无效

MTMKPART  
格式化磁带为一个分区（参数为零）或两个分区（非零参数）。如果参数为正数，则指定分区1的大小（以兆字节为单位）。对于DDS驱动器和一些早期驱动器，这是磁带上物理上的第一个分区。如果参数为负数，则其绝对值指定分区0的大小（以兆字节为单位）。这是许多后期驱动器（如LTO-5及以后的LTO驱动器）物理上的第一个分区。驱动器必须支持由发起者指定大小的分区。除非设置了MT_ST_CAN_PARTITIONS，否则无效
`MTSETDRVBUFFER` 用于多种目的。该命令通过带有 `MT_SET_OPTIONS` 掩码的计数获得，低字节用作参数。

此命令仅允许超级用户（root）使用。子命令如下：

* 0
    将驱动器缓冲区选项设置为参数值。零表示不启用缓冲。
* `MT_ST_BOOLEANS`
    设置缓冲区选项。位表示以下选项的新状态（括号内指明了选项是全局的还是可以针对每种模式单独指定）：

    - `MT_ST_BUFFER_WRITES`
        写入缓冲（模式）
    - `MT_ST_ASYNC_WRITES`
        异步写入（模式）
    - `MT_ST_READ_AHEAD`
        预读（模式）
    - `MT_ST_TWO_FM`
        写入两个文件标记（全局）
    - `MT_ST_FAST_EOM`
        使用SCSI到EOD的间隔（全局）
    - `MT_ST_AUTO_LOCK`
        自动锁定驱动器门（全局）
    - `MT_ST_DEF_WRITES`
        默认设置仅适用于写入（模式）
    - `MT_ST_CAN_BSR`
        可以在后退超过一个记录时用于重新定位磁带（全局）
    - `MT_ST_NO_BLKLIMS`
        驱动程序不从驱动器请求块限制（只能将块大小更改为可变）（全局）
    - `MT_ST_CAN_PARTITIONS`
        启用对分区磁带的支持（全局）
    - `MT_ST_SCSI2LOGICAL`
        对于SCSI-2驱动器，在`MTSEEK`和`MTIOCPOS`中使用逻辑块编号而不是设备依赖地址。建议设置此标志，除非有使用旧格式的磁带（全局）
    - `MT_ST_SYSV`
        设置SYSV语义（模式）
    - `MT_ST_NOWAIT`
        对某些命令启用立即模式（即不等待命令完成）（例如，倒带）
    - `MT_ST_NOWAIT_EOF`
        对写入文件标记启用立即模式（即写入文件标记时不等待其完成）。请参阅关于`MTWEOFI`的基本注意事项，了解写入即时文件标记可能带来的危险
    - `MT_ST_SILI`
        在可变块模式下读取时，在SCSI命令中设置SILI位，以提高读取短于字节数量的块时的性能；仅当确认驱动器支持SILI且HBA正确返回传输剩余时才设置此位
    - `MT_ST_DEBUGGING`
        调试（全局；调试必须编译到驱动程序中）

* `MT_ST_SETBOOLEANS`, `MT_ST_CLEARBOOLEANS`
    设置或清除选项位
* `MT_ST_WRITE_THRESHOLD`
    将此设备的写入阈值设置为由最低位指定的千字节
* `MT_ST_DEF_BLKSIZE`
    定义自动设置的默认块大小。值`0xffffff`表示不再使用默认值
* `MT_ST_DEF_DENSITY`, `MT_ST_DEF_DRVBUFFER`
    用于设置或清除密度（8位）和驱动器缓冲区状态（3位）。如果值为`MT_ST_CLEAR_DEFAULT`（`0xfffff`），则不再使用默认值。否则，值的最低位包含参数的新值
* `MT_ST_DEF_COMPRESSION`
    如果最低字节的值为`0xff`，则不使用压缩默认值。否则，最低位包含新的默认值。如果第8-15位设置为非零数字，并且该数字不是`0xff`，则该数字作为压缩算法使用。可以使用`MT_ST_CLEAR_DEFAULT`来清除压缩默认值
* `MT_ST_SET_TIMEOUT`
    设置此设备的正常超时时间（秒）。默认值为900秒（15分钟）。超时时间应足够长，以便设备在读/写过程中进行重试
* `MT_ST_SET_LONG_TIMEOUT`
    设置用于已知耗时较长的操作的长超时时间。默认值为14000秒（3.9小时）。对于擦除操作，此值会进一步乘以八。
* MT_ST_SET_CLN  
使用参数的最低24位来设置清洁请求解释参数。如果从扩展感觉数据中找到清洁请求位模式，驱动程序可以设置通用状态位GMT_CLN。许多磁带在需要清洁时会在扩展感觉数据中设置一个或多个位。这些位是设备相关的。驱动程序会得到感觉数据字节的编号（参数的最低八位；必须>= 18，值1-17保留），一个用于选择相关位的掩码（位9-16），以及位模式（位17-23）。如果位模式为零，则掩码下的一个或多个位表示清洁请求。如果模式非零，则该模式必须与掩码后的感觉数据字节匹配。（无论MT_ST_SET_CLN的设置如何，只要看到附加感觉代码和限定符00h 17h，就会设置清洁位。）

以下ioctl使用结构mtpos：

MTIOCPOS  
从驱动器读取当前位置。对于SCSI-1驱动器使用Tandberg兼容的QFA，对于SCSI-2驱动器使用SCSI-2命令。

以下ioctl使用结构mtget返回状态：

MTIOCGET  
返回一些状态信息。文件号和文件内的块号也会被返回。如果无法确定块号（例如，在MTBSF之后），则块号为-1。驱动器类型为MTISSCSI1或MTISSCSI2。自上次状态调用以来恢复的错误数量存储在字段mt_erreg的低位字中。当前块大小和密度代码存储在字段mt_dsreg中（子字段的移位分别为MT_ST_BLKSIZE_SHIFT和MT_ST_DENSITY_SHIFT）。GMT_xxx状态位反映了驱动器的状态。GMT_DR_OPEN表示驱动器中没有磁带。GMT_EOD表示已到达记录数据的末尾或磁带的末尾。GMT_EOT表示磁带的末尾。

杂项编译选项
==============

如果定义了ST_RECOVERED_WRITE_FATAL，则认为恢复的写入错误是致命的。磁带设备的最大数量由ST_MAX_TAPES决定。如果在驱动程序初始化时检测到更多的磁带，则最大数量会相应调整。
立即返回磁带定位 SCSI 命令可以通过定义 ST_NOWAIT 来启用。如果定义了这个宏，用户应确保在前一个磁带操作完成之前不要启动下一个操作。驱动器和 SCSI 适配器应该能够优雅地处理这种情况，但已知某些驱动器/适配器组合会导致 SCSI 总线挂起。

MTEOM 命令默认实现为跨越 32767 个文件标记的空间。使用这种方法时，状态中的文件编号是正确的。用户可以通过设置 ST_FAST_EOM 为 1（或使用 MT_ST_OPTIONS ioctl）请求直接定位到文件结束位置（EOD）。在这种情况下，文件编号将无效。

当使用预读取或缓冲写入时，在文件关闭后，文件内的位置可能不正确（正确的定位可能需要回退超过一个记录）。如果在编译时定义了 ST_IN_FILE_POS 或通过 ioctl 设置驱动器的 MT_ST_CAN_BSR 位，则可以获得文件内的正确位置。（驱动程序总是在用户没有请求那么远的数据时回退到被预读取跨越的文件标记。）

调试提示
=========

调试代码现在默认编译进内核模块中，但调试功能默认是关闭的，内核模块参数 debug_flag 默认值为 0。调试功能仍然可以通过 ioctl 开启和关闭。要启用模块加载时的调试，可以在模块加载选项中添加 debug_flag=1，调试输出不会太多。也可以通过向 sysfs 文件 `/sys/bus/scsi/drivers/st/debug_flag` 写入 '0'（禁用）或 '1'（启用）来开启或关闭调试。

如果磁带似乎挂起，我很想知道驱动程序正在等待的位置。通过命令 `ps -l` 可以查看使用磁带的进程的状态。如果状态为 D，表示进程正在等待某事。字段 WCHAN 显示驱动程序正在等待的位置。如果你有当前的 System.map 文件并且放在正确的位置（在我的 procps 中是在 /boot 目录下），或者更新了 /etc/psdatabase（对于 kmem ps），`ps` 命令会在 WCHAN 字段中显示函数名称。如果没有，你需要从 System.map 文件中查找该函数。

请注意，相比其他大多数驱动程序，超时时间非常长。这意味着 Linux 驱动程序可能看起来像是挂起了，而实际上是因为磁带固件出现了混乱。
