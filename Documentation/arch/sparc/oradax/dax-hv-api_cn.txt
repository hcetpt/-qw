摘自 UltraSPARC 虚拟机规范  
编译自版本 3.0.20+15  
出版日期 2017-09-25 08:21  
版权所有 © 2008, 2015 Oracle 及/或其关联公司。保留所有权利  
通过 "pdftotext -f 547 -l 572 -layout sun4v_20170925.pdf" 提取  
作者：  
    Charles Kunzman  
    Sam Glidden  
    Mark Cianchetti  

第 36 章. 协处理器服务  
以下 API 通过虚拟机监控程序提供对硬件辅助数据处理功能的访问。这些 API 可能仅由某些平台提供，并且即使在支持的平台上，也可能并非对所有虚拟机都可用。为了支持实时迁移和其他系统管理活动，可能会对使用这些 API 施加限制。  
36.1. 数据分析加速器  
数据分析加速器（DAX）功能是一系列硬件协处理器的集合，提供针对数据库中心操作的高速处理。这些协处理器可能支持以下一个或多个数据查询操作：搜索、提取、压缩、解压缩和转换。所提供的功能可能因虚拟机实现而异。  
对于 sun4v 客户端而言，DAX 是一个虚拟设备，支持的数据操作由虚拟设备兼容性属性指示。通过 ccb_submit API 函数提交命令控制块 (CCB) 来访问功能。这些操作是异步处理的，通过与每个 CCB 相关的完成区域报告提交的操作的状态。每个 CCB 都有一个单独的完成区域，并且除非通过使用串行条件标志明确限制执行顺序，否则提交的 CCB 的执行顺序是任意的。同样，给定 CCB 的完成时间从不保证。  
客户软件可以对 CCB 操作实施软件超时，如果超过了超时，则可以通过 ccb_kill API 函数取消或终止该操作。建议客户软件实施软件超时以应对某些 RAS 错误可能导致 CCB 丢失的情况。建议此类实现使用 ccb_info API 函数检查 CCB 的状态，在终止它之前确定 CCB 是否仍在队列中，或者是否可能由于 RAS 错误而丢失。  
虚拟机中客户软件可以排队的未完成 CCB 数量没有固定限制，但是虚拟机内部资源限制可能导致 CCB 提交被暂时拒绝为 EWOULDBLOCK。在这种情况下，客户端应继续尝试提交直到成功；等待一个未完成的 CCB 完成不是必需的，也不能保证未来的提交会成功。  
DAX 协处理器命令服务的可用性由客户机 MD 中存在 DAX 虚拟设备节点指示（第 8.24.17 节，“数据库分析加速器 (DAX) 虚拟设备节点”）。  
36.1.1. DAX 兼容性属性  
查询功能可能基于虚拟设备的兼容性属性而有所不同：  

36.1.1.1. "ORCL,sun4v-dax" 设备兼容性  
可用的 CCB 命令：  

• 无操作/同步  

• 提取  

• 扫描值  

• 反向扫描值  

• 扫描范围  

• 反向扫描范围  

• 转换  

• 反向转换  

• 选择  

参见第 36.2.1 节，“查询 CCB 命令格式”，了解相应的 CCB 输入和输出格式。  
只有版本 0 的 CCB 可用。  

页码：509
36.1.1.2. "ORCL,sun4v-dax-fc" 设备兼容性
        "ORCL,sun4v-dax-fc" 与 "ORCL,sun4v-dax" 接口兼容，并包含额外的 CCB
        位字段和控制项。

36.1.1.3. "ORCL,sun4v-dax2" 设备兼容性
        可用的 CCB 命令：

        • 无操作/同步（No-op/Sync）

        • 提取（Extract）

        • 扫描值（Scan Value）

        • 反向扫描值（Inverted Scan Value）

        • 扫描范围（Scan Range）

        • 反向扫描范围（Inverted Scan Range）

        • 转换（Translate）

        • 反向转换（Inverted Translate）

        • 选择（Select）

        有关对应的 CCB 输入和输出格式，请参阅第 36.2.1 节，“查询 CCB 命令格式”
版本 0 和 1 的 CCB 都可用。只有版本 0 的 CCB 可以使用霍夫曼编码数据，而只有版本 1 的 CCB 可以使用 OZIP。
36.1.2. DAX 虚拟设备中断
        DAX 虚拟设备有多个与之相关的中断，如果需要的话，这些中断可以被客户机使用。客户机可以使用的设备中断数量在客户机 MD 中的虚拟设备节点中指示（第 8.24.17 节，“数据库分析加速器（DAX）虚拟设备节点”）。如果设备节点表明有 N 个可用中断，客户机可以在 CCB 中的中断编号字段中使用任何从 0 到 N-1（含）的值。使用此范围之外的值将导致 CCB 因无效字段值而被拒绝。
可以通过标准的 sun4v 设备中断 API 来绑定和管理这些中断（第 16 章，设备中断服务）。Sysino 中断对于 DAX 设备不可用。
36.2. 协处理器控制块（CCB）
        CCB 的长度为 64 字节或 128 字节，具体取决于操作类型。CCB 的确切内容是命令特定的，但所有 CCB 至少包含一个内存缓冲区地址。所有由 CCB 引用的内存位置都必须被固定在内存中，直到 CCB 完成执行或通过 ccb_kill API 调用被终止。提交 CCB 后发生的虚拟地址映射更改不一定可见，因此所有虚拟地址更新都需要与 CCB 执行同步。
所有 CCB 都以一个通用的 32 位头部开始。
表 36.1. CCB 头部格式
比特位 | 字段描述
[31:28] | CCB 版本。对于 API 版本 2.0：如果 CCB 使用 OZIP 编码，则设置为 1；如果 CCB 使用霍夫曼编码，则设置为 0；否则可以是 0 或 1。对于 API 版本 1.0：始终设置为 0
[27] | 当协商 API 版本 2.0 时，这是 Pipeline 标志 [512]。在 API 版本 1.0 中保留
[26] | 长 CCB 标志 [512]
[25] | 条件同步标志 [512]
[24] | 串行同步标志
[23:16] | CCB 操作代码：
             0x00        无操作（No-op）或同步（Sync）
             0x01        提取（Extract）
             0x02        扫描值（Scan Value）
             0x12        反向扫描值（Inverted Scan Value）
             0x03        扫描范围（Scan Range）
             0x13        反向扫描范围（Inverted Scan Range）
             0x04        转换（Translate）
             0x14        反向转换（Inverted Translate）
             0x05        选择（Select）
[15:13] | 保留
[12:11] | 表地址类型
             0b'00       无地址
             0b'01       替代上下文虚拟地址
             0b'10       实际地址
             0b'11       主上下文虚拟地址
[10:8] | 输出/目标地址类型
             0b'000      无地址
             0b'001      替代上下文虚拟地址
             0b'010      实际地址
             0b'011      主上下文虚拟地址
             0b'100      保留
             0b'101      保留
             0b'110      保留
             0b'111      保留
[7:5] | 辅助源地址类型
             0b'000       无地址
             0b'001       替代上下文虚拟地址
             0b'010       实际地址
             0b'011       主上下文虚拟地址
             0b'100       保留
             0b'101       保留
             0b'110       保留
             0b'111       保留
[4:2] | 主源地址类型
             0b'000       无地址
             0b'001       替代上下文虚拟地址
             0b'010       实际地址
             0b'011       主上下文虚拟地址
             0b'100       保留
             0b'101       保留
             0b'110       保留
             0b'111       保留
[1:0] | 完成区域地址类型
             0b'00        无地址
             0b'01        替代上下文虚拟地址
             0b'10        实际地址
             0b'11        主上下文虚拟地址

长 CCB 标志表示提交的 CCB 是否为 64 字节或 128 字节长；值为 0 表示 64 字节，值为 1 表示 128 字节。
串行和条件标志允许简单的 CCB 之间的相对顺序。任何设置了串行标志的 CCB 将相对于在同一 CCB 提交中的先前同样标记为串行的 CCB 顺序执行。没有设置串行标志的 CCB 独立执行，即使它们位于带有串行标志的 CCB 之间。仅带有串行标志的 CCB 在上一个串行 CCB 完成后执行，无论该 CCB 的完成状态如何。条件标志允许 CCB 根据最近带有串行标志的 CCB 成功执行来有条件地执行。
一个CCB（命令控制块）只能有条件地依赖于另一个确切的CCB，但是，一个CCB可以被标记为“条件”和“串行”，以允许执行链式操作。这些标志不允许扇出链式操作，即不允许基于另一个CCB完成而多个CCB并行执行。

管道标志是一种优化手段，它指导将一个CCB（“源”CCB）的输出直接传递到下一个CCB（“目标”CCB）的输入中。因此，目标CCB无需从内存读取输入数据。管道标志是建议性的，可能被忽略。

源CCB必须同时设置管道和串行位。目标CCB必须设置条件位。恰好有一个CCB必须有条件地依赖于源CCB；要么没有目标CCB，要么有两个目标CCB都是无效的。然而，管道可以扩展到两个以上的CCB：序列会从一个设置了管道和串行位的CCB开始，然后通过一系列同时设置了管道、串行和条件位的CCB，最终在设置了条件位但未设置管道位的CCB处终止。

512

目标CCB的输入必须在源CCB输出后的64字节内开始，否则管道标志将被忽略。管道中的所有CCB都必须在同一调用`ccb_submit`时提交。

各种地址类型字段指示了CCB中使用的各种地址值应如何由虚拟机解释。并非指定的所有类型都会被每种CCB格式使用。对于不适用于特定CCB命令的类型，应将其指示为类型0（无地址）。在CCB中使用的虚拟地址必须在提交虚拟处理器的TLB或配置的TSB中具有转换条目。虚拟机无法转换的虚拟地址将导致CCB提交被拒绝，并且会指出原因所在的虚拟地址。插入转换后，可以重新提交CCB，或者地址可以通过来宾软件进行转换，并使用实际地址重新提交。

36.2.1. 查询CCB命令格式

36.2.1.1. 支持的数据格式、元素大小和偏移量

查询命令的数据可以采用多种可能的格式进行编码。数据查询命令使用一组通用的值来指示正在处理的数据的编码格式。某些编码格式需要多条数据流进行处理，这需要指定主要数据格式（已编码的数据）和辅助数据流（已编码数据的元数据）。

36.2.1.1.1. 主要输入格式

主要输入格式代码是一个4位字段，当其被使用时。共有10种主要输入格式可用。
非打包格式不是端序无关的。未列出的代码值保留。

代码 | 格式 | 描述
-----|------|------
0x0  | 固定宽度字节打包 | 最多16字节
0x1  | 固定宽度比特打包 | 最多15比特（CCB版本0）或23比特（CCB版本1）；字节内的比特是从最高有效位读取到最低有效位
0x2  | 变长宽度字节打包 | 必须提供长度数据流作为辅助输入
0x4  | 带运行长度编码的固定宽度字节打包 | 最多16字节；必须提供运行长度数据流作为辅助输入
0x5  | 带运行长度编码的固定宽度比特打包 | 最多15比特（CCB版本0）或23比特（CCB版本1）；字节内的比特是从最高有效位读取到最低有效位；必须提供运行长度数据流作为辅助输入
0x8  | 带霍夫曼（CCB版本0）或OZIP（CCB版本1）编码的固定宽度字节打包 | 编码前最多16字节；压缩流中的比特是从最高有效位读取到最低有效位；必须提供编码表指针
0x9  | 带霍夫曼（CCB版本0）或OZIP（CCB版本1）编码的固定宽度比特打包 | 最多15比特（CCB版本0）或23比特（CCB版本1）；压缩流中的比特是从最高有效位读取到最低有效位；必须提供编码表指针
0xA  | 带霍夫曼（CCB版本0）或OZIP（CCB版本1）编码的变长宽度字节打包 | 编码前最多16字节；压缩流中的比特是从最高有效位读取到最低有效位；必须提供长度数据流作为辅助输入；必须提供编码表指针
0xC  | 带运行长度编码随后是霍夫曼（CCB版本0）或OZIP（CCB版本1）编码的固定宽度字节打包 | 编码前最多16字节；压缩流中的比特是从最高有效位读取到最低有效位；必须提供运行长度数据流作为辅助输入；必须提供编码表指针
0xD  | 带运行长度编码随后是霍夫曼（CCB版本0）或OZIP（CCB版本1）编码的固定宽度比特打包 | 最多15比特（CCB版本0）或23比特（CCB版本1）；压缩流中的比特是从最高有效位读取到最低有效位；必须提供运行长度数据流作为辅助输入；必须提供编码表指针

如果使用OZIP编码，则编码表中不得有保留字节。

36.2.1.1.2. 主要输入元素大小

对于具有固定大小元素的主要输入数据流，必须在CCB命令中指示元素大小。该大小以位数或字节数减一的形式编码。此字段的有效值范围取决于所选的输入格式，如上表所示。
36.2.1.1.3. 辅助输入格式

对于需要辅助输入流的主输入数据流，辅助输入流始终以固定宽度、位打包的格式进行编码。位从字节中的最高有效位读取到最低有效位。辅助输入流数据元素有两种编码选项，这取决于是否需要值为0：

辅助 输入描述
格式代码
0                           元素存储为值减去1（0转换为1，1转换为2等）
1                           元素存储为值

36.2.1.1.4. 辅助输入元素大小

辅助输入元素大小用两个比特字段进行编码：

辅助输入大小描述
代码
0x0                        1位
0x1                        2位
0x2                        4位
0x3                        8位

36.2.1.1.5. 输入元素偏移

按位输入的数据流可以在基地址字节内的任何位置对齐。偏移量，从最高有效位到最低有效位指定，对于每种输入类型提供一个固定的3位字段。值为0表示第一个输入元素从第一个字节的最高有效位开始，而值为7表示它从最低有效位开始。
对于任何字节级的主输入数据流，此字段应为零。

36.2.1.1.6. 输出格式

查询命令支持多种输出数据流的大小和编码方式。有四种可能的输出编码方式，并且每种编码最多支持四种元素大小。并非所有输出编码都适用于每个命令。格式由CCB中的4位字段指示：

输出格式代码        描述
0x0                       字节对齐，1字节元素
0x1                       字节对齐，2字节元素
0x2                       字节对齐，4字节元素
0x3                       字节对齐，8字节元素
0x4                       16字节对齐，16字节元素
0x5                       预留
0x6                       预留
0x7                       预留
0x8                       单位元素的打包向量
0x9                       预留
0xA                       预留
0xB                       预留
0xC                       预留
0xD                       2字节元素，其中每个元素是来自位向量中值为1的位的索引值
0xE                       4字节元素，其中每个元素是来自位向量中值为1的位的索引值
0xF                       预留

36.2.1.1.7. 应用数据完整性(ADI)

在支持ADI的平台上，可以为CCB命令中使用的每个单独内存访问类型指定ADI版本号。ADI检查仅在读取数据时发生。写入数据时，指定的ADI版本号会覆盖内存中存在的任何ADI值。
ADI版本值为0或0xF表示该数据访问禁用了ADI检查，即使内存中已启用也是如此。通过设置CCB_SUBMIT（第36.3.1节，“ccb_submit”）中的适当标志，也可以选择在此次超调用调用期间提交的所有CCB上禁用所有通过虚拟地址访问的输入的ADI检查。
仅保证在每次数据访问的前64字节检查ADI值。后续数据块的不匹配可能不会被检测到，因此客户端软件应注意使用页面大小检查来防止缓冲区溢出。

36.2.1.1.8. 页面大小检查

CCB命令中使用的所有数据访问必须限定在一个单一的内存页内。当使用虚拟地址提供地址时，用于检查的页面大小从该虚拟地址的TTE中提取。使用实际地址时，客户端必须在同一字段中提供页面大小和地址值。页面大小必须是底层虚拟机支持的一种大小。使用不受支持的值可能会导致CCB提交被拒绝或生成完成区域中的CCB解析错误。

36.2.1.2. 提取命令

将一种格式的输入向量转换为另一种格式的输出向量。支持所有输入格式类型。
支持的唯一输出格式是一种填充的、字节对齐的输出流，使用输出代码0x0至0x4。
