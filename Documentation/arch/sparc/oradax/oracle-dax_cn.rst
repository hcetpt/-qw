Oracle 数据分析加速器 (DAX)
=======================================

DAX 是一个协处理器，位于 SPARC M7（DAX1）和 M8（DAX2）处理器芯片上，并且可以直接访问 CPU 的 L3 缓存以及物理内存。它可以对具有各种输入和输出格式的数据流执行多种操作。驱动程序提供了一种传输机制，并对各种操作码和数据格式有一定的了解。用户空间库提供了高级服务，并将这些服务转换为低级命令，然后传递给驱动程序，进而传递给虚拟机监控程序和协处理器。库是应用程序使用协处理器的推荐方式，而驱动程序接口并非用于一般用途。本文档描述了驱动程序的一般流程、其结构及其编程接口。它还提供了足够的示例代码来编写使用 DAX 功能的用户或内核应用程序。
用户库是开源的，可从以下网址获取：

    https://oss.oracle.com/git/gitweb.cgi?p=libdax.git

协处理器与虚拟机监控程序之间的接口在随附文档 dax-hv-api.txt 中进行了详细说明，该文档是从（Oracle 内部）“UltraSPARC 虚拟机规范”版本 3.0.20+15（日期为 2017-09-25）摘录的纯文本。
高级概述
===================

协处理器请求由命令控制块 (CCB) 描述。CCB 包含操作码和各种参数。操作码指定了要执行的操作，而参数指定了选项、标志、大小和地址。CCB（或 CCB 数组）被传递给虚拟机监控程序，后者负责排队和调度到可用的协处理器执行单元的请求。返回的状态码表明请求是否成功提交或是否出现错误。每个 CCB 中给出的一个地址是指向“完成区域”的指针，这是一个 128 字节的内存块，由协处理器写入以提供执行状态。完成时不会生成中断；必须通过软件轮询完成区域来确定交易何时结束，但 M7 及以后的处理器提供了一种机制，可以暂停虚拟处理器直到协处理器更新了完成状态。这是通过受监视的加载和 mwait 指令完成的，这些指令将在后面进行更详细的描述。设计 DAX 协处理器的目的在于，在提交请求之后，内核不再参与其处理。轮询是在用户级别完成的，这样就导致从请求完成到请求线程恢复执行之间几乎零延迟。
寻址内存
=================

在 Sun4v 架构中，内核无法访问物理内存，因为存在额外一层内存虚拟化。这一中间层被称为“实际”内存，内核将其视为物理内存。虚拟机监控程序负责处理实际内存与物理内存之间的转换，以便每个逻辑域 (LDOM) 都可以拥有与其他 LDOM 隔离的物理内存分区。当内核设置虚拟映射时，它会指定虚拟地址和应映射到的实际地址。
DAX 协处理器只能操作物理内存，所以在将请求传递给协处理器之前，CCB 中的所有地址都必须转换为物理地址。内核无法做到这一点，因为它无法查看物理地址。因此，CCB 可能包含缓冲区的虚拟或实际地址，或者这两者的组合。对于 CCB 中可能提供的每个地址，都有一个“地址类型”字段。在所有情况下，虚拟机监控程序都会在分发到硬件之前将所有地址转换为物理地址。地址转换是使用发起请求的进程的上下文完成的。
驱动程序 API
==============

应用程序通过 write() 系统调用向驱动程序发出请求，并通过 read() 获取结果（如果有的话）。通过 mmap() 可以访问完成区域，并且对于应用程序来说是只读的。
请求可以是即时命令，也可以是要提交给硬件的 CCB 数组。
设备的每个打开实例都是独占的，仅限于打开它的线程使用，并且必须由该线程执行所有后续操作。驱动程序的打开函数为线程创建一个新的上下文并对其进行初始化以便使用。此上下文中包含驱动程序内部用于跟踪已提交请求的指针和值。还会分配完成区域缓冲区，并且这个缓冲区足够大，可以容纳许多并发请求的完成区域。当关闭设备时，任何未决交易都将被清除，并清理上下文。
在 DAX1 系统（M7）上，该设备将被称为 "oradax1"，而在 DAX2 系统（M8）上它将是 "oradax2"。如果一个应用程序需要其中一个设备，它应该尝试打开相应的设备。在任何给定的系统上仅存在一个设备，因此可以通过名称来确定平台支持哪个设备。

即时命令包括 CCB_DEQUEUE、CCB_KILL 和 CCB_INFO。对于所有这些命令，成功执行由 `write()` 函数返回的字节数等于调用中给出的字节数表示。否则返回 `-1` 并设置 `errno`。

**CCB_DEQUEUE**

通知驱动程序清理与过去请求相关的资源。由于请求完成时不会生成中断，因此必须告诉驱动程序何时可以回收资源。没有进一步的状态信息返回，因此用户不应随后调用 `read()`。

**CCB_KILL**

在执行过程中终止 CCB。一旦此调用成功返回，保证 CCB 不会继续执行。成功后，必须调用 `read()` 来获取动作的结果。

**CCB_INFO**

检索有关当前正在执行的 CCB 的信息。注意某些 Hypervisors 当 CCB 处于 'inprogress' 状态时可能会返回 'notfound'。为了确保处于 'notfound' 状态的 CCB 永远不会被执行，必须对该 CCB 调用 CCB_KILL。成功后，必须调用 `read()` 来获取动作的详细信息。

**CCB 数组的提交以供执行**

长度为 CCB 大小倍数的 `write()` 被视为提交操作。文件偏移量被视为要使用的完成区域索引，并可通过 `lseek()` 或使用 `pwrite()` 系统调用来设置。如果返回 `-1`，则设置 `errno` 以指示错误。否则，返回值是协处理器实际接受的数组长度。如果接受的长度等于请求的长度，则提交完全成功，无需进一步的状态信息；因此，用户不应随后调用 `read()`。CCB 数组的部分接受由小于请求长度的返回值表示，必须调用 `read()` 来检索进一步的状态信息。状态将反映第一个未被接受的 CCB 引起的错误，在某些情况下 `status_data` 将提供额外的数据。

**MMAP**

`mmap()` 函数提供了对驱动程序中分配的完成区域的访问。注意完成区域不可由用户进程写入，且 `mmap` 调用不应指定 `PROT_WRITE`。

**请求的完成**

每个完成区域的第一个字节是命令状态，由协处理器硬件更新。软件可以利用新的 M7/M8 处理器功能来高效地轮询此状态字节。首先，通过带有 ASI 0x84（ASI_MONITOR_PRIMARY）的从备用空间加载指令（ldxa、lduba 等）实现“受监控的加载”。其次，通过 mwait 指令（写入 %asr28）实现“受监控的等待”。此指令类似于 pause，它根据给定的纳秒数暂停虚拟处理器的执行，但除此之外还会在发生几个事件之一时提前终止。如果包含受监控位置的数据块被修改，则 mwait 终止。这使得软件在事务完成后立即恢复执行（无需上下文切换或内核到用户态转换）。因此，事务完成和恢复执行之间的延迟可能仅为几纳秒。

**DAX 提交的应用生命周期**

- 打开 DAX 设备
- 调用 `mmap()` 获取完成区域地址
- 分配一个 CCB 并填写 opcode、标志、参数、地址等
通过`write()`或`pwrite()`提交CCB（命令控制块）。
- 进入循环执行受监控的负载加上受监控的等待，并在命令状态指示请求完成时终止（可根据需要随时使用`CCB_KILL`或`CCB_INFO`）
- 执行一个`CCB_DEQUEUE`
- 对完成区域调用`munmap()`以完成操作
- 关闭DAX设备

内存限制
=========

DAX硬件仅基于物理地址进行操作。因此，它并不了解虚拟内存映射及其可能导致的物理内存中不连续的情况。没有I/O TLB或任何散列/聚集机制。所有的缓冲区，无论是输入还是输出，都必须位于物理上连续的内存区域。Hypervisor（虚拟机监视器）将CCB中的所有地址转换为物理地址，在将CCB传递给DAX之前。Hypervisor确定每个给定虚拟地址对应的虚拟页大小，并以此来设置每个地址的大小限制。这防止了协处理器读取或写入超出虚拟页的边界，尽管它是直接访问物理内存。简单来说就是DAX操作永远不会“跨越”虚拟页边界。如果使用的是8KB的虚拟页，则数据严格限制在8KB内。如果用户的缓冲区大于8KB，则必须使用更大的页大小，或者交易大小将被截断至8KB。
- 大页。用户可以使用标准接口分配大页。位于大页上的内存缓冲区可用于实现更大的DAX交易大小，但仍需遵守规则，且任何交易都不会跨越页边界，即使大页也不例外。需要注意的一个重要问题是，Linux在Sparc架构上提供了8MB作为大页尺寸之一。然而，Sparc实际上并没有提供8MB的硬件页大小，而是通过组合两个4MB的页来模拟这个大小。这样做有历史原因，但这也带来了问题：在任何特定的DAX请求中，8MB页实际上只能使用其中的一半，必须是前一半或后一半；不能是中间的4MB，因为这会跨越硬件页边界。需要注意的是，这个问题可能被更高层次的库所隐藏。

CCB结构
--------

CCB是一个包含8个64位字的数组。其中一些字提供命令操作码、参数、标志等信息，其余的则是完成区域、输出缓冲区和各种输入的地址：

```c
struct ccb {
    u64   control;
    u64   completion;
    u64   input0;
    u64   access;
    u64   input1;
    u64   op_data;
    u64   output;
    u64   table;
};
```

请参见`libdax/common/sys/dax1/dax1_ccb.h`以获取这些字段的详细描述，并参见`dax-hv-api.txt`以获取针对来宾操作系统（即Linux内核）可用的Hypervisor API的完整描述。
驱动程序会检查第一个字（control）：
- CCB版本，必须与硬件版本一致；
- 操作码，必须是文档中列出的允许使用的命令之一；
- 地址类型，必须设置为“虚拟”，以确保应用程序只能访问它拥有的内存。

示例代码
=========

DAX对用户空间代码和内核代码都是可访问的。内核代码可以直接发出超调用，而用户空间代码则必须使用由驱动程序提供的包装器。CCB的设置对于两者来说几乎相同；唯一的区别在于完成区域的准备。现在给出用户空间代码的示例，随后给出内核代码的示例。
为了使用驱动程序API编程，必须包含文件`arch/sparc/include/uapi/asm/oradax.h`。
首先，必须打开正确的设备。对于M7，它将是`/dev/oradax1`；对于M8，它将是`/dev/oradax2`。最简单的步骤是尝试打开两者，因为只有一个会成功：

```c
int fd = open("/dev/oradax1", O_RDWR);
if (fd < 0)
    fd = open("/dev/oradax2", O_RDWR);
if (fd < 0)
    /* 没有找到DAX */
```

接下来，必须映射完成区域：

```c
void *completion_area = mmap(NULL, DAX_MMAP_LEN, PROT_READ, MAP_SHARED, fd, 0);
```

所有的输入和输出缓冲区必须完全包含在一个硬件页内，因为如前所述，DAX严格受到虚拟页边界的约束。此外，输出缓冲区必须64字节对齐，其大小必须是64字节的倍数，因为协处理器以缓存行单位写入。

本示例演示了DAX扫描命令，该命令以向量和匹配值作为输入，并产生一个位图作为输出。对于每个与值匹配的输入元素，相应的位将在输出中被设置。在这个示例中，输入向量由一系列单比特组成，匹配值为0。因此，输入中的每个0比特将在输出中产生一个1，反之亦然，从而产生一个反转后的输入位图作为输出。
以下是提供的英文内容翻译成中文：

有关此CCB中使用的所有参数和位的详细信息，请参阅DAX Hypervisor API文档第36.2.1.3节，该节详细描述了Scan命令：

	ccb->control =       /* 表36.1, CCB头格式 */
		  (2L << 48)     /* 命令 = 扫描值 */
		| (3L << 40)     /* 输出地址类型 = 主虚拟 */
		| (3L << 34)     /* 主输入地址类型 = 主虚拟 */
		             /* 第36.2.1节, 查询CCB命令格式 */
		| (1 << 28)     /* 36.2.1.1.1 主输入格式 = 固定宽度位打包 */
		| (0 << 23)     /* 36.2.1.1.2 主输入元素大小 = 0（1位） */
		| (8 << 10)     /* 36.2.1.1.6 输出格式 = 位向量 */
		| (0 <<  5)	/* 36.2.1.3 第一个扫描标准大小 = 0（1字节） */
		| (31 << 0);	/* 36.2.1.3 禁用第二个扫描标准 */

	ccb->completion = 0;    /* 完成区域地址，由驱动程序填充 */

	ccb->input0 = (unsigned long) input; /* 主输入地址 */

	ccb->access =       /* 第36.2.1.2节, 数据访问控制 */
		  (2 << 24)    /* 主输入长度格式 = 位 */
		| (nbits - 1); /* 主输入流中的位数减一 */

	ccb->input1 = 0;       /* 辅助输入地址，未使用 */

	ccb->op_data = 0;      /* 扫描标准（要匹配的值） */

	ccb->output = (unsigned long) output;	/* 输出地址 */

	ccb->table = 0;	       /* 表地址，未使用 */

提交CCB是通过向驱动程序发出write()或pwrite()系统调用来完成的。如果调用失败，则必须使用read()来检索状态：

	if (pwrite(fd, ccb, 64, 0) != 64) {
		struct ccb_exec_result status;
		read(fd, &status, sizeof(status));
		/* 退出处理 */
	}

成功提交CCB后，可以通过轮询完成区域来确定DAX何时完成。关于完成区域内容的详细信息可以在DAX HV API文档的第36.2.2节找到：

	while (1) {
		/* 监控加载 */
		__asm__ __volatile__("lduba [%1] 0x84, %0\n"
				     : "=r" (status)
				     : "r"  (completion_area));

		if (status)	     /* 0表示命令正在进行中 */
			break;

		/* MWAIT */
		__asm__ __volatile__("wr %%g0, 1000, %%asr28\n" ::);    /* 1000纳秒 */
	}

完成区域状态为1表示CCB成功完成并且输出位图有效，可以立即使用
所有其他非零值都表示错误条件，这些条件在第36.2.2节中有描述：

	if (completion_area[0] != 1) {	/* 第36.2.2节, 1=命令运行并成功 */
		/* completion_area[0]包含完成状态 */
		/* completion_area[1]包含错误代码，参见36.2.2 */
	}

处理完完成区域后，必须通知驱动程序它可以释放与请求相关的任何资源。这是通过出队操作来完成的：

	struct dax_command cmd;
	cmd.command = CCB_DEQUEUE;
	if (write(fd, &cmd, sizeof(cmd)) != sizeof(cmd)) {
		/* 退出处理 */
	}

最后，应进行正常的程序清理工作，例如解除映射完成区域、关闭dax设备、释放内存等。
内核示例
----------

在内核代码中使用DAX的唯一区别在于对完成区域的处理。与用户应用程序通过mmap驱动程序分配的完成区域不同，内核代码必须为其自己的完成区域分配内存，并且此地址及其类型必须在CCB中给出：

	ccb->control |=      /* 表36.1, CCB头格式 */
	        (3L << 32);     /* 完成区域地址类型 = 主虚拟 */

	ccb->completion = (unsigned long) completion_area;   /* 完成区域地址 */

直接通过超调用提交dax。ccb_submit调用中使用的标志在DAX HV API文档的第36.3.1节中有记录：

  #include <asm/hypervisor.h>

	hv_rv = sun4v_ccb_submit((unsigned long)ccb, 64,
				 HV_CCB_QUERY_CMD |
				 HV_CCB_ARG0_PRIVILEGED | HV_CCB_ARG0_TYPE_PRIMARY |
				 HV_CCB_VA_PRIVILEGED,
				 0, &bytes_accepted, &status_data);

	if (hv_rv != HV_EOK) {
		/* hv_rv是一个错误代码，status_data包含 */
		/* 潜在的附加状态，参见36.3.1.1 */
	}

提交之后，完成区域的轮询代码与用户空间中的相同：

	while (1) {
		/* 监控加载 */
		__asm__ __volatile__("lduba [%1] 0x84, %0\n"
				     : "=r" (status)
				     : "r"  (completion_area));

		if (status)	     /* 0表示命令正在进行中 */
			break;

		/* MWAIT */
		__asm__ __volatile__("wr %%g0, 1000, %%asr28\n" ::);    /* 1000纳秒 */
	}

	if (completion_area[0] != 1) {	/* 第36.2.2节, 1=命令运行并成功 */
		/* completion_area[0]包含完成状态 */
		/* completion_area[1]包含错误代码，参见36.2.2 */
	}

当完成状态指示成功时，输出位图即可立即使用。
摘自UltraSPARC虚拟机规范

 .. include:: dax-hv-api.txt
    :literal:
