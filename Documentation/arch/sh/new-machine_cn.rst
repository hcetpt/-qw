### SPDX 许可证标识符：GPL-2.0

=============================
向 LinuxSH 添加新板卡
=============================

               Paul Mundt <lethal@linux-sh.org>

本文档旨在概述在新的 2.5 和 2.6 内核下为 LinuxSH 端口添加对新板卡支持所需的步骤。此外，本文档还试图概述 2.4 版本与 2.5/2.6 版本之间的一些显著变化。

1. 新的目录结构
==========================

首先需要注意到的是新的目录结构。在 2.4 版本中，除了 stboards 之外，大多数特定于板卡的代码都直接位于 arch/sh/kernel/ 目录下，而特定于板卡的头文件则位于 include/asm-sh/ 下。对于新内核，这些内容按照板卡类型、伴生芯片类型和 CPU 类型进行划分。查看该目录层次的树状视图如下所示：

特定于板卡的代码:
|-- arch
    |   `-- sh
    |       `-- boards
    |           |-- adx
    |           |   `-- 特定于板卡的文件
    |           |-- bigsur
    |           |   `-- 特定于板卡的文件
    |           |
    |           ... 更多板卡在此 ...
|
    `-- include
	`-- asm-sh
	    |-- adx
	    |   `-- 特定于板卡的头文件
	    |-- bigsur
	    |   `-- 特定于板卡的头文件
	    |
	    .. 更多板卡在此 ...

接下来，对于伴生芯片:
`-- arch
	`-- sh
	    `-- cchips
		`-- hd6446x
		    `-- hd64461
			`-- 特定于伴生芯片的文件

... 以此类推。伴生芯片的头文件处理方式与特定于板卡的头文件相同。因此，include/asm-sh/hd64461 包含所有特定于 hd64461 的头文件。
最后，CPU 家族的支持也被抽象出来:
|-- arch
    |   `-- sh
    |       |-- kernel
    |       |   `-- cpu
    |       |       |-- sh2
    |       |       |   `-- SH-2 通用文件
    |       |       |-- sh3
    |       |       |   `-- SH-3 通用文件
    |       |       `-- sh4
    |       |           `-- SH-4 通用文件
    |       `-- mm
    |           `-- 这也按 CPU 家族进行了划分，以便每个家族可以有自己的缓存/TLB 函数集
|
    `-- include
	`-- asm-sh
	    |-- cpu-sh2
	    |   `-- SH-2 特定的头文件
	    |-- cpu-sh3
	    |   `-- SH-3 特定的头文件
	    `-- cpu-sh4
		`-- SH-4 特定的头文件

需要注意的是，CPU 子类型并未被抽象化。因此，这些仍然需要通过特定于 CPU 家族的代码来处理。
2. 添加新板卡
=====================

首先需要确定的是您要添加的板卡是否是孤立的，或者它是否会成为一系列板卡的一部分，这一系列板卡可以在较小差异的情况下共享大部分相同的特定于板卡的代码。
在第一种情况下，这仅仅是为你的板卡在 `arch/sh/boards/` 下创建一个目录，并添加规则以将你的板卡与构建系统关联（关于这一点将在下一节中详细讨论）。然而，对于板卡家族来说，更合理的做法是在顶层拥有一个共同的 `arch/sh/boards/` 目录，然后用该家族每个成员的子目录填充它。Solution Engine 和 hp6xx 板卡都是这种做法的例子。在你设置好新的 `arch/sh/boards/` 目录后，请记得你也应该在 `include/asm-sh/` 中为特定于这块板卡的头文件添加一个目录（如果它们不止一个的话）。为了与构建系统无缝协作，最好让这个目录名称与 `arch/sh/boards/` 的目录名称相同。但是如果你的板卡是某个家族的一部分，构建系统有办法处理这种情况（通过 `incdir-y` 重载），你可以自由地以家族成员本身命名该目录。

每块板卡都需要在 `arch/sh/boards` 和 `include/asm-sh/` 这两个层级提供一些内容。为了更好地解释这一点，我们使用一些例子来介绍如何添加一个假设的板卡。对于初始化代码，我们至少需要提供 `get_system_type()` 和 `platform_setup()` 的定义。对于我们的假设板卡，这可能看起来像这样：

```c
/*
* arch/sh/boards/vapor/setup.c - 假设板卡的初始化代码
*/
#include <linux/init.h>

const char *get_system_type(void)
{
	return "FooTech Vaporboard";
}

int __init platform_setup(void)
{
	/*
	* 如果我们的硬件确实存在，我们在这里会做一些实际的
	* 初始化工作。不过即使这里为空也是合理的，
	* 如果这块板卡没有需要做的实际初始化工作
*/

	/* 启动假设的 PCI ... */

	/* 以及其他任何必要的操作 ... */

	return 0;
}
```

我们的新假设板卡还需要与 `machvec` 关联才能发挥作用。
`machvec` 函数可以分为几个类别：

- I/O 函数用于访问 I/O 内存（如 `inb` 等）和 PCI/主内存（如 `readb` 等）
- I/O 映射函数（如 `ioport_map`, `ioport_unmap` 等）
- 一个“心跳”函数
- PCI 和中断初始化例程
- 一致分配器（对于需要特殊分配器的板卡，特别是那些需要从某些板卡特有的 SRAM 中分配 DMA 句柄的板卡）
随着时间的推移，不断增加和删除了与机器向量（machvec）相关的函数，因此务必始终查阅`include/asm-sh/machvec.h`以了解当前的机器向量状态。内核会在启动时自动为未定义的机器向量函数指针封装通用例程，因为大多数代码树中无条件地引用了机器向量函数。有些板子具有非常稀疏的机器向量（例如Dreamcast和SH03），而其他板子则必须定义几乎所有东西（如rts7751r2d）。

添加新机器相对简单（以Vapor为例）：

如果特定于板子的定义相当精简，正如绝大多数板子的情况那样，仅仅有一个特定于板子的头文件就足够了。
- 添加一个新文件`include/asm-sh/vapor.h`，其中包含任何特定于机器的I/O函数原型，这些函数名称前缀为机器名，例如`vapor_inb`。在填充机器向量时需要这些函数。
请注意，这些原型可以通过将`__IO_PREFIX`设置为合理的值自动生成。一个典型的示例是：

	```c
	#define __IO_PREFIX vapor
	#include <asm/io_generic.h>
	```

在特定于板子的头文件中的某个地方放置上述内容。任何正在移植并且仍然有旧版io.h的板子应当完全移除它，并切换到新模式。
- 在板子的`setup.c`中添加机器向量定义。至少，这必须被定义为如下所示：

	```c
	struct sh_machine_vector mv_vapor __initmv = {
		.mv_name = "vapor",
	};
	ALIAS_MV(vapor)
	```
- 最后，添加一个文件`arch/sh/boards/vapor/io.c`，其中包含特定于机器的I/O函数定义（如果有足够的函数需要定义的话）。

### 3. 构建系统的集成
=======================

现在我们已经设置了相应的目录，并且所有特定于板子的代码都已就位，接下来是时候看看如何让整个系统融入构建系统了。

构建系统的大部分现在完全是动态的，只需要适当的位置添加适当的条目即可完成工作。

首先要做的是在`arch/sh/Kconfig`中“系统类型”菜单下添加一个条目：

    ```makefile
    config SH_VAPOR
	    bool "Vapor"
	    help
	    select Vapor if configuring for a FooTech Vaporboard
    ```

然后，需要将此条目添加到`arch/sh/Makefile`中。所有板子都需要一个`machdir-y`条目才能进行构建。这个条目需要是位于`arch/sh/boards`目录下的板子目录名称，即使它位于子目录中（在这种情况下，`arch/sh/boards/`下的所有父目录都需要列出）。对于我们的新板子，这个条目可以如下所示：

    ```makefile
    machdir-$(CONFIG_SH_VAPOR)	+= vapor
    ```

前提是我们已将所有内容放在`arch/sh/boards/vapor/`目录中。
接下来，构建系统假设你的 include/asm-sh 目录也将具有相同的名称。如果不是这种情况（例如，对于属于同一家族的多个板子），则需要将目录名隐式地附加到 incdir-y。现有的代码已经为 Solution Engine 和 hp6xx 板子处理了这一点，因此可以参考这些作为示例。
处理完这一点后，接下来就是为机器类型添加一个条目。
这是通过在 arch/sh/tools/mach-types 列表末尾添加条目来完成的。如何操作这一点是显而易见的，所以我们在这里就不赘述。完成后，如果你在通用代码中的某处需要对你的板子进行隐式检查，你就可以使用它，例如：

	/* 确保我们是在 FooTech Vaporboard 上 */
	if (!mach_is_vapor())
		return -ENODEV;

同时请注意，无论 mach-types 条目都是大写， mach_is_boardname() 的检查都将被隐式地强制为小写。如果你确实关心，可以阅读脚本，但它非常丑陋，所以你可能不想这样做。
现在剩下要做的就是为你的新板子提供一个 defconfig。这样，得到这块板子的其他人就可以直接使用这个配置作为参考，而不是试图猜测应该使用哪些设置。
此外，一旦你为新板子复制了一个示例 .config（假设为 arch/sh/configs/vapor_defconfig），你也可以直接将其用作构建目标，并且它将在帮助文本中被隐式列出。
查看 'make help' 输出，你现在应该能看到类似的内容：

特定于架构的目标 (sh)：

  =======================   =============================================
  zImage                    压缩的内核映像 (arch/sh/boot/zImage)
  adx_defconfig             构建 adx
  cqreek_defconfig          构建 cqreek
  dreamcast_defconfig       构建 dreamcast
  ..
vapor_defconfig            构建 vapor
  =======================   =============================================

这允许你执行如下操作：

    $ make ARCH=sh CROSS_COMPILE=sh4-linux- vapor_defconfig vmlinux

这将反过来复制该板子的 defconfig，通过 oldconfig 运行（提示你自创建以来的新选项），并开始构建适用于你的新板子的功能性内核。
