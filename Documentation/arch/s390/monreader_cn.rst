### z/VM 监控记录的 Linux API 读取访问

======================================
Linux API for read access to z/VM Monitor Records
======================================

**日期**：2004年11月26日

**作者**：Gerald Schaefer (geraldsc@de.ibm.com)

---

#### 描述
本项目提供了一个新的 Linux API，形式为杂项字符设备，可以在用户空间中使用，并允许读取由 z/VM 的 `*MONITOR` 系统服务收集的 z/VM 监控记录。

---

#### 用户需求
要访问此 API 的 z/VM 客户机需要配置以允许与 `*MONITOR` 服务建立 IUCV 连接，即客户机的用户条目中需要有 IUCV `*MONITOR` 语句。如果要使用的监控 DCSS 受限（可能如此），您还需要 NAMESAVE <DCSS NAME> 语句。
此项目将使用 IUCV 设备驱动程序来访问 z/VM 服务，因此您需要一个支持 IUCV 的内核。您还需要 z/VM 版本 4.4 或 5.1。
有两种方法可以加载监控 DCSS（示例假设监控 DCSS 从 144 MB 开始，到 152 MB 结束）。您可以使用特权 CP 命令 Q NSS MAP 查询监控 DCSS 的位置（BEGPAG 和 ENDPAG 的值以 4KB 页为单位给出）。
有关 DEF STOR 和 Q NSS MAP 命令的更多信息，请参阅“CP 命令和实用工具参考”（SC24-6081-00）；有关 DCSS 的更多信息，请参阅“已保存段规划和管理”（SC24-6116-00）。
**第一种选择**：
-----------------
您可以使用 CP 命令 DEF STOR CONFIG 在您的客户机虚拟存储中定义一个“内存空洞”，位于 DCSS 地址范围附近。
示例：DEF STOR CONFIG 0.140M 200M.200M

这定义了两块存储区域，第一块大小为 140MB 并从地址 0MB 开始，第二块大小为 200MB 并从地址 200MB 开始，总共提供了 340MB 的存储空间。请注意，第一块应始终从 0 开始且至少为 64MB 大小。
**第二种选择**：
-----------------
您的客户机虚拟存储必须在 DCSS 起始地址以下结束，并且您需要在 parmfile 中指定 “mem=” 内核参数，其值大于 DCSS 的结束地址。
示例：

	DEF STOR 140M

这为客户机定义了 140MB 的存储空间大小，“mem=160M” 参数被添加到 parmfile 中。

---

#### 用户界面
该字符设备实现为名为“monreader”的内核模块，可以通过 modprobe 命令加载，或者可以将其编译入内核。有一个可选的模块（或内核）参数 “mondcss”，用于指定监控 DCSS 的名称。如果将模块编译入内核，则可以在 parmfile 中指定内核参数 “monreader.mondcss=<DCSS NAME>”。
默认的 DCSS 名称是 "MONDCSS"，如果未指定其他名称。如果已有其他用户连接到 `*MONITOR` 服务（例如性能工具包），则监控 DCSS 已经被定义，您必须使用相同的 DCSS。通过 CP 命令 Q MONITOR（E 级权限）可以查看已定义的监控 DCSS 名称以及连接到 `*MONITOR` 服务的用户。
若您的 z/VM 尚未创建监控 DCSS，请参考 "z/VM 性能" 书籍（SC24-6109-00）了解如何创建监控 DCSS，定义和保存 DCSS 需要 E 级权限。
示例：
------

::
  
  modprobe monreader mondcss=MYDCSS

这将加载模块并将 DCSS 名称设置为 "MYDCSS"。
注意：
-----
此 API 不提供控制 `*MONITOR` 服务的接口，例如指定收集哪些数据。这些可以通过 CP 命令 MONITOR（E 级权限）完成，详情请参阅 "CP 命令和实用程序参考"。
使用 udev 的设备节点：
----------------------
加载模块后，会创建一个字符设备及其对应的设备节点 /<udev 目录>/monreader。
不使用 udev 的设备节点：
------------------------
如果您使用的发行版不支持 udev，则不会自动创建设备节点，您需要在加载模块后手动创建它。
因此，您需要知道该设备的主要和次要编号。这些编号可以在 /sys/class/misc/monreader/dev 中找到。
输入 `cat /sys/class/misc/monreader/dev` 可以看到类似 `<主要>:<次要>` 的输出。设备节点可通过 mknod 命令创建，命令格式为 `mknod <名称> c <主要> <次要>`，其中 `<名称>` 是要创建的设备节点名称。
示例：
------

::
  
  # modprobe monreader
  # cat /sys/class/misc/monreader/dev
  10:63
  # mknod /dev/monreader c 10 63

这将加载模块并使用默认的监控 DCSS（MONDCSS），同时创建设备节点。
文件操作：
-----------
支持以下文件操作：打开、释放、读取、轮询
有两种读取方法可供选择：一种是非阻塞式读取与轮询结合使用，另一种是阻塞式读取而不进行轮询。不支持 IOCTL 操作。

读取：
------
从设备中读取会提供一个 12 字节的监视器控制元素 (MCE)，随后是一组一个或多个连续的监视记录（类似于 CMS 实用程序 MONWRITE 的输出，但没有 4K 控制块）。MCE 包含了关于接下来记录集类型（样本/事件数据）、该记录集中包含的监视域以及记录集在监视 DCSS 中的起始和结束地址的信息。可以使用起始和结束地址来确定记录集的大小；结束地址即为数据的最后一字节的地址。起始地址用于正确处理“帧尾”记录（域 1，记录 13），也就是说，它可用于确定相对于 4K 页（帧）边界的记录起始偏移量。

请参阅“z/VM 性能”文档中的“附录 A: `*MONITOR`”，以获取监视器控制元素布局的描述。监视记录的布局可在此处找到（z/VM 5.1）：https://www.vm.ibm.com/pubs/mon510/index.html

monreader 设备提供的数据流布局如下所示：

	..
<0 字节读取>
	<第一个 MCE>              \
	<第一组记录>              |
	...                        |- 数据集
	<最后一个 MCE>             |
	<最后一组记录>            /
	<0 字节读取>
	..

一个数据集中可能包含多组 MCE 及其对应的记录集组合，并且每个数据集的结尾都由成功读取并返回值为 0（0 字节读取）表示。
除非完整地读取了一整套数据（包括闭合的 0 字节读取），否则接收的所有数据均视为无效。因此，在处理数据之前，应当始终将整套数据读入缓冲区中。
数据集的最大尺寸可以等于监视 DCSS 的大小，因此，请适当设计缓冲区或使用动态内存分配。
加载模块后，监视 DCSS 的大小将会被记录到系统日志中。您也可以使用（Class E 特权）CP 命令 Q NSS MAP 列出所有可用段及其相关信息。
如同大多数字符设备一样，错误条件通过返回负数表示读取字节数来指示。在这种情况下，errno 变量指出了错误条件：

EIO:
    回复失败，读取的数据无效，应用程序
    应当丢弃自上次成功读取以来的所有已读取数据（0 大小读取）
EFAULT:
`copy_to_user`失败，读取的数据无效，应用程序应当
丢弃自上次成功读取（大小为0）以来读取的所有数据

EAGAIN:
在非阻塞读取时如果当前没有可用数据则会发生此错误。这并不意味着数据丢失或损坏，而是应当
再次尝试读取或更倾向于使用轮询来进行非阻塞读取

EOVERFLOW:
消息限制已达到，自上次成功读取（大小为0）以来所读取的数据是有效的，但随后的记录可能缺失

在最后一种情况（EOVERFLOW）中可能存在缺失数据，在前两种情况
（EIO, EFAULT）中将有缺失数据。由应用程序决定是否继续读取后续数据或直接退出

打开：
------
只允许一个用户打开该字符设备。如果已被占用，则
打开函数将会失败（返回负值）并将errno设置为EBUSY
如果无法建立与`*MONITOR`服务的IUCV连接，打开函数也可能失败。此时errno会被设置为EIO，并且会在系统日志中打印出带有IPUSER SEVER代码的错误信息。IPUSER SEVER代码在"z/VM性能"一书中附录A有所描述

注意事项：
------
一旦设备被打开，就会开始接收消息并且这些消息会计算在消息限制内，也就是说，如果不从已打开的设备读取数据，最终会引发“消息限制已达到”的错误（EOVERFLOW错误码）。
