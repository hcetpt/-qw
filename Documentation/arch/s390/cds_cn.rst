===========================
S/390 和 zSeries 上的 Linux
===========================

通用设备支持 (CDS)
设备驱动程序 I/O 支持例程

作者:
	- Ingo Adlung
	- Cornelia Huck

版权所有，IBM 公司 1999-2002

简介
============

本文档描述了 Linux/390 的通用设备支持例程。
与其他硬件架构不同，ESA/390 定义了一种统一的 I/O 访问方法。这为设备驱动程序提供了便利，因为它们不必处理不同的总线类型、轮询与中断处理、共享与非共享中断处理、DMA 与端口 I/O (PIO) 以及其他更多硬件特性。但是，这也意味着要么每个单独的设备驱动程序都需要自己实现硬件 I/O 连接功能，要么操作系统提供一种统一的方法来访问硬件，提供每个单独的设备驱动程序本应提供的所有功能。
本文档并不打算详细解释 ESA/390 硬件架构。这些信息可以从 ESA/390 工作原理手册（IBM 表单号：SA22-7201）中获得。
为了构建适用于 ESA/390 I/O 接口的通用设备支持，引入了一个功能层，该层向硬件提供了通用的 I/O 访问方法。
通用设备支持层包括下面定义的 I/O 支持例程。其中一些实现了通用的 Linux 设备驱动程序接口，而另一些则具有 ESA/390 平台特有的性质。

注意：
  为了编写 S/390 的驱动程序，您还需要查阅 Documentation/arch/s390/driver-model.rst 中描述的接口。

对于从 2.4 版本移植驱动程序的说明：

主要变化如下：

* 函数使用 ccw_device 而不是 irq (子通道)
* 所有驱动程序必须定义一个 ccw_driver（参见 driver-model.txt）及其相关函数
* 不再由驱动程序执行 request_irq() 和 free_irq()
* oper_handler 被 ccw_driver 中的 probe() 和 set_online() 函数（某种程度上）取代
* not_oper_handler在某种程度上被ccw_driver中的remove()和set_offline()函数所替代
* 通道设备层已被移除
* 中断处理器必须适应以ccw_device作为参数使用
此外，它们不再返回devstat，而是返回irb
* 在启动I/O之前，必须通过ccw_device_set_options()设置选项
* 驱动程序不再调用read_dev_chars()/read_conf_data()，而是发出通道程序并自行处理中断
ccw_device_get_ciw()
   从扩展感觉数据中获取命令
ccw_device_start(), ccw_device_start_timeout(), ccw_device_start_key(), ccw_device_start_key_timeout()
   启动一个I/O请求
ccw_device_resume()
   恢复通道程序的执行
ccw_device_halt()
   终止设备上正在处理的当前I/O请求
### do_IRQ()
   通用中断例程。每当系统接收到I/O中断时，该函数由中断入口例程调用。`do_IRQ()`例程确定中断状态，并根据在发起I/O请求时通过`do_IO()`定义的规则（标志）调用特定于设备的中断处理程序。
接下来的章节将更详细地描述除`do_IRQ()`之外的其他函数。
`do_IRQ()`接口没有被描述，因为它仅从Linux/390的第一级中断处理程序中调用，并不构成可由设备驱动程序调用的接口。相反，`do_IO()`的功能描述也涵盖了对特定于设备的中断处理程序的输入描述。
**注：**
所有解释同样适用于64位架构s390x。
### 对于Linux/390设备驱动的支持 (CDS)
#### 一般信息

以下章节描述了Linux/390通用设备支持(CDS)提供的与I/O相关的接口例程，这些例程允许在IBM ESA/390硬件平台上实现特定于设备的驱动程序。这些接口旨在提供每个设备驱动程序实现所需的功能，以使能够驱动ESA/390平台上的特定硬件设备。某些接口例程是Linux/390特有的，而另一些则可以在其他Linux平台实现中找到。
各种函数原型、数据声明和宏定义可以在架构特定的C头文件`linux/arch/s390/include/asm/irq.h`中找到。
#### CDS接口概念概述

不同于其他硬件平台，ESA/390架构没有定义由特定中断控制器管理的中断线以及可能支持或不支持共享中断、DMA处理等的总线系统。相反，ESA/390架构实现了所谓的通道子系统，为物理连接到系统的设备提供了统一的视图。
尽管ESA/390硬件平台支持各种不同的外围设备附件，如磁盘设备（通常称为DASD）、磁带、通信控制器等，但它们都可以通过一种定义良好的访问方法来访问，并且以统一的方式呈现I/O完成：即I/O中断。每个单独的设备都通过一个称为子通道的独特标识符被系统识别，其中ESA/390架构允许最多连接64K个设备。
然而，Linux最初是在Intel PC架构上构建的，该架构具有两个级联的8259可编程中断控制器(PIC)，允许最多15个不同的中断线。连接到此类系统的所有设备共享这15个中断级别。连接到ISA总线系统的设备不允许共享中断级别（即IRQ），因为ISA总线基于边缘触发的中断。MCA、EISA、PCI和其他总线系统基于电平触发的中断，因此允许共享IRQ。但是，如果多个设备通过同一个（共享的）IRQ呈现其硬件状态，则操作系统必须调用注册在此IRQ上的每个单个设备驱动程序，以确定引发中断的设备所属的设备驱动程序。
直到内核2.4版本，Linux/390都是通过IRQ（子通道）提供接口。
对于通用 I/O 层的内部使用而言，这些功能仍然存在。然而，
设备驱动程序应当仅通过 `ccw_device` 使用新的调用接口。
在启动过程中，Linux/390 系统会检查外围设备。每个这样的设备都由 ESA/390
通道子系统中的所谓“子通道”唯一定义。虽然子通道号是系统自动生成的，但每个
子通道也具有用户定义的属性，即所谓的设备号。
子通道号和设备号都不能超过 65535。在 sysfs 初始化期间，会收集有关控制单元类型和设备类型的
信息，这些类型意味着特定的 I/O 命令（通道命令字 - CCWs），以便操作设备。设备驱动程序可以在它们的初始化阶段获取这套硬件
信息来识别它们支持的设备，这些信息保存在传递给它们的 `struct ccw_device` 中。
这种方法意味着 Linux/390 不需要探测空闲（未激活）的中断请求线（IRQs）来驱动其设备。如果适用，设备驱动程序可以使用
READ DEVICE CHARACTERISTICS 的 CCW 来检索设备特性，作为其在线例程的一部分。
为了便于启动 I/O 操作，CDS 层提供了一个 `ccw_device_start()` 接口，该接口接收设备特定的通道程序（一个或多个 CCWs）作为输入，设置所需的架构特有控制块，并代表设备驱动程序启动一个 I/O 请求。`ccw_device_start()` 允许指定是否期望 CDS 层为每次观察到的中断通知设备驱动程序，或者只在最终状态时通知。更多详细信息请参阅 `ccw_device_start()`。设备驱动程序绝不能自行发出 ESA/390 I/O 命令，而必须使用 Linux/390 的 CDS 接口代替。
对于需要取消的长时间运行的 I/O 请求，CDS 层提供了 `ccw_device_halt()` 函数。某些设备可能需要在没有挂起的 I/O 请求的情况下首先发出 HALT SUBCHANNEL (HSCH) 命令。此功能同样由 `ccw_device_halt()` 覆盖。
`get_ciw()` — 获取命令信息字

此调用允许设备驱动程序从扩展 SenseID 数据中获取关于支持命令的信息：
::

  struct ciw *
  ccw_device_get_ciw(struct ccw_device *cdev, __u32 cmd);

====  ========================================================
cdev  需要获取命令的 ccw_device
cmd   需要获取的命令类型
====  ========================================================

`ccw_device_get_ciw()` 返回：

=====  ================================================================
NULL  没有扩展数据可用、无效的设备或未找到命令
=====  ==============================================================
!NULL 所请求的命令

=====  ================================================================

::

  ccw_device_start() - 发起I/O请求

`ccw_device_start()` 函数是I/O请求的前端处理器。所有设备驱动程序的I/O请求必须使用此函数发起。设备驱动程序不得自行发出ESA/390 I/O命令。相反，`ccw_device_start()` 函数提供了所有必要的接口来驱动任意设备。此描述还涵盖了传递给设备驱动程序中断处理程序的状态信息，因为这与在调用 `ccw_device_start()` 时为相关I/O请求定义的规则（标志）有关。

::

  int ccw_device_start(struct ccw_device *cdev,
		       struct ccw1 *cpa,
		       unsigned long intparm,
		       __u8 lpm,
		       unsigned long flags);
  int ccw_device_start_timeout(struct ccw_device *cdev,
			       struct ccw1 *cpa,
			       unsigned long intparm,
			       __u8 lpm,
			       unsigned long flags,
			       int expires);
  int ccw_device_start_key(struct ccw_device *cdev,
			   struct ccw1 *cpa,
			   unsigned long intparm,
			   __u8 lpm,
			   __u8 key,
			   unsigned long flags);
  int ccw_device_start_key_timeout(struct ccw_device *cdev,
				   struct ccw1 *cpa,
				   unsigned long intparm,
				   __u8 lpm,
				   __u8 key,
				   unsigned long flags,
				   int expires);

============= =============================================================
cdev          目标I/O的ccw_device
cpa           通道程序逻辑起始地址
user_intparm  用户特定的中断信息；将被呈现回设备驱动程序的中断处理程序。允许设备驱动程序将中断与特定的I/O请求关联起来
lpm           定义了用于特定I/O请求的通道路径。值为0会使cio使用opm
key           用于I/O的存储键（对于操作具有非默认键的存储有用）
flag          定义了要执行的I/O处理动作
expires       超时值（以jiffies为单位）。通用I/O层将在该时间后终止正在运行的程序，并带着ERR_PTR(-ETIMEDOUT)作为irb调用中断处理程序
============= =============================================================

可能的标志值包括：

========================= =============================================
DOIO_ALLOW_SUSPEND        通道程序可能会暂停
DOIO_DENY_PREFETCH        不允许CCW预取；通常这意味着通道程序可能会被修改
DOIO_SUPPRESS_INTER       不在中间状态时调用处理程序
========================= =============================================

参数`cpa`指向通道程序中的第一个格式1 CCW（通道控制字）：

  struct ccw1 {
	__u8  cmd_code; /* 命令代码 */
	__u8  flags;    /* 标志，例如IDA寻址等 */
	__u16 count;    /* 字节数量 */
	__u32 cda;      /* 数据地址 */
  } __attribute__ ((packed,aligned(8)));

以下定义了CCW标志值：

=================== =========================
CCW_FLAG_DC         数据链接
CCW_FLAG_CC         命令链接
CCW_FLAG_SLI        抑制不正确的长度
CCW_FLAG_SKIP       跳过
CCW_FLAG_PCI        PCI
CCW_FLAG_IDA        间接寻址
CCW_FLAG_SUSPEND    暂停
=================== =========================

通过`ccw_device_set_options()`，设备驱动程序可以为设备指定以下选项：

========================= ======================================
DOIO_EARLY_NOTIFICATION   允许早期中断通知
DOIO_REPORT_ALL           报告所有中断条件
========================= ======================================

`ccw_device_start()` 函数返回：

======== ======================================================================
      0  成功完成或请求成功启动
 -EBUSY  设备当前正在处理之前的I/O请求，或者设备有挂起的状态
-ENODEV  cdev无效，设备未运行或ccw_device未在线
======== ======================================================================

当I/O请求完成时，CDS第一级中断处理程序将积累状态到struct irb中，然后调用设备中断处理程序。
`intparm`字段将包含设备驱动程序与特定I/O请求关联的值。如果识别出挂起的设备状态，则`intparm`将被设置为0（零）。这种情况可能会发生在I/O启动期间或由于警报状态通知而延迟。无论如何，这种状态与当前（最后一个）I/O请求无关。在延迟状态通知的情况下，不会出现特殊的中断以指示I/O完成，因为I/O请求从未启动，即使`ccw_device_start()` 返回成功完成。
IRB 可能包含错误值，设备驱动程序应首先检查这一点：

========== =================================================================
-ETIMEDOUT 在指定的超时值后，通用I/O层终止了请求
-EIO       由于错误状态，通用I/O层终止了请求
========== =================================================================

如果 IRB 中扩展状态字 (ESW) 的并发感知标志被设置，则 ESW 中的 `erw.scnt` 字段描述了在扩展控制字 `irb->scsw.ecw[]` 中可用的设备特定感知字节数。不需要设备驱动程序自身进行任何设备感知。
设备中断处理程序可以使用以下定义来调查在感知字节 0 中编码的主要单元检查源：

======================= ====
SNS0_CMD_REJECT         0x80
SNS0_INTERVENTION_REQ   0x40
SNS0_BUS_OUT_CHECK      0x20
SNS0_EQUIPMENT_CHECK    0x10
SNS0_DATA_CHECK         0x08
SNS0_OVERRUN            0x04
SNS0_INCOMPL_DOMAIN     0x01
======================= ====

根据设备状态，这些值中的多个可能同时被设置。请参阅设备特定文档以获取详细信息。
字段 `irb->scsw.cstat` 提供（累积的）子通道状态：

========================= ============================
SCHN_STAT_PCI             程序控制中断
SCHN_STAT_INCORR_LEN      长度不正确
SCHN_STAT_PROG_CHECK      程序检查
SCHN_STAT_PROT_CHECK      保护检查
SCHN_STAT_CHN_DATA_CHK    通道数据检查
SCHN_STAT_CHN_CTRL_CHK    通道控制检查
SCHN_STAT_INTF_CTRL_CHK   接口控制检查
SCHN_STAT_CHAIN_CHECK     链接检查
========================= ============================

字段 `irb->scsw.dstat` 提供（累积的）设备状态：

===================== =================
DEV_STAT_ATTENTION    注意
DEV_STAT_STAT_MOD     状态修改器
DEV_STAT_CU_END       控制单元结束
DEV_STAT_BUSY         忙碌
DEV_STAT_CHN_END      通道结束
DEV_STAT_DEV_END      设备结束
DEV_STAT_UNIT_CHECK   单元检查
DEV_STAT_UNIT_EXCEP   单元异常
===================== =================

有关各个标志含义的详细信息，请参阅 ESA/390 操作原理手册。

使用说明：

调用 `ccw_device_start()` 时必须禁用并持有 ccw 设备锁。
设备驱动程序允许从其中断处理程序内部发出下一个 `ccw_device_start()` 调用。除非需要安排一个不确定长度的错误恢复过程或类似操作，否则不需要调度下半部。在 I/O 处理过程中，Linux/390 通用 I/O 设备驱动程序支持已经获得了 IRQ 锁，即处理程序在调用 `ccw_device_start()` 时不应尝试再次获取它，否则会导致死锁！

如果设备驱动程序依赖于 I/O 请求在其开始下一个请求之前完成，可以通过在提交的 CCW 链尾部链接一个 NoOp I/O 命令 `CCW_CMD_NOOP` 来减少 I/O 处理开销。这将迫使通道结束和设备结束状态一起呈现，由单一中断触发。但是，这应该谨慎使用，因为它意味着通道将保持忙碌状态，无法处理同一通道上其他设备的 I/O 请求。因此，例如读命令不应使用这种技术，因为结果无论如何都会由单一中断呈现。
为了最小化 I/O 开销，设备驱动程序仅当设备可以在设备结束前报告中间中断信息，并且设备驱动程序迫切依赖于这一点时才使用 `DOIO_REPORT_ALL`。在这种情况下，所有 I/O 中断都将呈现给设备驱动程序，直到识别出最终状态。
如果设备能够从异步呈现的 I/O 错误中恢复，它可以使用 `DOIO_EARLY_NOTIFICATION` 标志执行重叠 I/O。虽然有些设备总是将通道结束和设备结束状态一起报告，使用单一中断，但其他设备会在通道准备好进行下一次 I/O 请求时报告主要状态（通道结束），而在数据传输完成后报告次要状态（设备结束）。
上述标志允许利用此特性，例如对于能够处理网络上丢失数据的通信设备，允许增强 I/O 处理。
除非通道子系统在任何时候产生一个次级状态中断，
利用这个特性只会导致在执行重叠I/O时向设备驱动程序呈现一级状态中断。当一个没有错误的次级状态（警报状态）被呈现时，这表明自上次次级（最终）状态以来发出的所有重叠`ccw_device_start()`请求已成功完成。
意图在通道命令字(CCW)上设置暂停标志的通道程序必须使用DOIO_ALLOW_SUSPEND选项启动I/O操作，否则暂停标志将导致通道程序检查。当通道程序被暂停时，通道子系统会生成一个中间中断。

`ccw_device_resume()` — 恢复通道程序执行

如果设备驱动程序选择通过在特定CCW上设置CCW暂停标志来暂停当前的通道程序执行，则通道程序执行会被暂停。为了恢复通道程序执行，CIO层提供了`ccw_device_resume()`函数：
```
int ccw_device_resume(struct ccw_device *cdev);
```

| 参数 | 描述 |
| --- | --- |
| `cdev` | 请求恢复操作的`ccw_device` |

`ccw_device_resume()`函数返回值如下：

| 返回值 | 描述 |
| --- | --- |
| `0` | 暂停的通道程序已被恢复 |
| `-EBUSY` | 状态待处理 |
| `-ENODEV` | `cdev`无效或非活动子通道 |
| `-EINVAL` | 恢复函数不适用 |
| `-ENOTCONN` | 没有等待完成的I/O请求 |

**使用说明：**

请参阅`ccw_device_start()`的使用说明以获取更多关于暂停通道程序的信息。

`ccw_device_halt()` — 停止I/O请求处理

有时设备驱动程序可能需要一种方式来停止长时间运行的通道程序的处理，或者设备可能需要最初发出一个停止子通道(HSCH) I/O命令。为此目的提供了`ccw_device_halt()`命令。

`ccw_device_halt()`必须在禁用状态下调用，并且持有ccw设备锁：
```
int ccw_device_halt(struct ccw_device *cdev, unsigned long intparm);
```

| 参数 | 描述 |
| --- | --- |
| `cdev` | 请求停止操作的`ccw_device` |
| `intparm` | 中断参数；只有在没有正在进行的I/O时才使用该值，否则返回与I/O请求关联的`intparm` |

`ccw_device_halt()`函数返回值如下：

| 返回值 | 描述 |
| --- | --- |
| `0` | 请求已成功发起 |
| `-EBUSY` | 设备当前忙或状态待处理 |
| `-ENODEV` | `cdev`无效 |
| `-EINVAL` | 设备不处于运行状态或ccw设备未在线 |

**使用说明：**

设备驱动程序可以通过编写一个永不结束的通道程序来实现这一点，即通过使用通道到通道传输(TIC)命令(`CCW_CMD_TIC`)使通道程序在其结尾处循环回到开头。通常这是由网络设备驱动程序通过设置PCI CCW标志(`CCW_FLAG_PCI`)来完成的。一旦执行了这个CCW，就会生成一个程序控制中断(PCI)。然后设备驱动程序可以执行相应的操作。在中断对网络设备的读取操作之前（无论是否设置了PCI标志），都需要调用`ccw_device_halt()`来终止正在执行的操作。
`ccw_device_clear()` — 终止 I/O 请求处理

为了终止子通道上的所有 I/O 处理，使用清除子通道 (CSCH) 命令。可以通过 `ccw_device_clear()` 发出此命令。调用 `ccw_device_clear()` 时必须处于禁用状态，并且持有 ccw 设备锁。

```
int ccw_device_clear(struct ccw_device *cdev, unsigned long intparm);
```

===== ===============================================
cdev   对其请求清除操作的 ccw_device
intparm 中断参数（参见 ccw_device_halt()）
===== ===============================================

`ccw_device_clear()` 函数返回：

=====  ==============================================================
      0  请求已成功发起
-ENODEV cdev 无效
-EINVAL 设备未运行或 ccw 设备不在线
=====  ==============================================================

其他支持例程
------------------

本章描述了在 Linux/390 设备驱动程序环境中可使用的各种例程。

`get_ccwdev_lock()`

获取特定设备锁的地址。然后在 `spin_lock()` / `spin_unlock()` 调用中使用该锁。

```
__u8 ccw_device_get_path_mask(struct ccw_device *cdev);
```

获取当前可用于 cdev 的路径掩码。
