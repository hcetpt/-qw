======================
AArch64 Linux 中的带标签虚拟地址
======================

作者：Will Deacon <will.deacon@arm.com>

日期：2013年6月12日

本文档简要介绍了 AArch64 翻译系统中带标签虚拟地址的提供及其在 AArch64 Linux 中的潜在用途。
内核配置了翻译表，使得通过 TTBR0（即用户空间映射）进行的翻译将忽略虚拟地址的最高字节（位 63:56）。这释放了该字节供应用程序使用。

向内核传递带标签的地址
------------------------------

内核对用户空间内存地址的所有解释都假设地址标签为 0x00，除非应用程序明确启用了 AArch64 带标签地址 ABI（参见 `Documentation/arch/arm64/tagged-address-abi.rst`）。
这包括但不限于以下位置中的地址：

- 系统调用中的指针参数，包括传递给系统调用的结构中的指针，

- 栈指针（sp），例如，在传递信号时对其的解释，

- 帧指针（x29）和帧记录，例如，在生成回溯或调用图时对其的解释。
在未启用用户空间应用程序的 AArch64 带标签地址 ABI 的情况下，在上述任何位置使用非零地址标签可能会导致返回错误代码、引发（致命）信号或其他形式的失败。
出于这些原因，当禁用 AArch64 带标签地址 ABI 时，通过系统调用向内核传递非零地址标签是被禁止的，并且强烈不建议为 sp 使用非零地址标签。
维护使用非零地址标签的帧指针和帧记录的程序可能遭受调试和性能分析可见性的降低或不准确。

保留标签
--------------

在传递信号时，除非在安装信号处理程序时设置了 sigaction.sa_flags 中的标志 SA_EXPOSE_TAGBITS，否则不会在 siginfo.si_addr 中保留非零标签。这意味着使用标签的应用程序中的信号处理程序不能依赖于这些字段中用户虚拟地址的标签信息，除非设置了该标志。
由于架构限制，即使设置了 SA_EXPOSE_TAGBITS，同步标签检查故障（SEGV_MTESERR）响应中也不会保留故障地址的位 63:60。应用程序应该将这些位的值视为未定义，以适应未来可能保存这些位的架构修订。
对于由断点调试异常引发的信号，无论 SA_EXPOSE_TAGBITS 标志设置如何，都会保留标签信息。
非零标签在 `sigcontext.fault_address` 中永远不会被保留，不论 `SA_EXPOSE_TAGBITS` 标志的设置如何。
架构阻止了带标签的程序计数器（PC）的使用，因此在异常返回时，最高字节将被设置为第 55 位的符号扩展。
当启用 AArch64 带标签地址应用程序二进制接口（ABI）时，这种行为得以保持。

其他考虑事项：

在使用带标签的指针时应特别小心，因为很可能 C 编译器不会区分仅在最高字节不同的两个虚拟地址。
