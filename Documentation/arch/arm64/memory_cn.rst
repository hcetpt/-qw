==============================
AArch64 Linux 的内存布局
==============================

作者: Catalin Marinas <catalin.marinas@arm.com>

本文档描述了 AArch64 Linux 内核使用的虚拟内存布局。该架构允许使用最多 4 级的页表，对应 4KB 的页面大小，或最多 3 级的页表对应 64KB 的页面大小。AArch64 Linux 在 4KB 页面配置中使用 3 级或 4 级页表，分别允许使用 39 位（512GB）或 48 位（256TB）的虚拟地址，这些地址既适用于用户空间也适用于内核空间。对于 64KB 页面大小，仅使用 2 级页表，允许使用 42 位（4TB）的虚拟地址，但内存布局相同。
ARMv8.2 增加了对大虚拟地址空间的可选支持。这仅在使用 64KB 页面大小时可用，并扩展了第一级页表中的描述符数量。
选择 TTBRx 是由虚拟地址的第 55 位决定的。`swapper_pg_dir` 只包含内核（全局）映射，而 `user pgd` 只包含用户（非全局）映射。`swapper_pg_dir` 地址被写入 TTBR1，而从不写入 TTBR0。

AArch64 Linux 在 4KB 页面 + 4 级（48 位）的内存布局如下所示：

| 开始地址 | 结束地址 | 大小 | 用途 |
|-----------------------------------------------------------------------|
| 0000000000000000 | 0000ffffffffffff | 256TB | 用户空间 |
| ffff000000000000 | ffff7fffffffffff | 128TB | 内核逻辑内存映射 |
| [ffff600000000000 | ffff7fffffffffff] | 32TB | [kasan shadow 区域] |
| ffff800000000000 | ffff80007fffffff | 2GB | 模块 |
| ffff800080000000 | fffffbffefffffff | 124TB | vmalloc |
| fffffbfff0000000 | fffffbfffdffffff | 224MB | 固定映射（自上而下） |
| fffffbfffe000000 | fffffbfffe7fffff | 8MB | [保护区域] |
| fffffbfffe800000 | fffffbffff7fffff | 16MB | PCI I/O 空间 |
| fffffbffff800000 | fffffbffffffffff | 8MB | [保护区域] |
| fffffc0000000000 | ffffffdffffffffff | 2TB | vmemmap |
| fffffe0000000000 | ffffffffffffffff | 2TB | [保护区域] |

AArch64 Linux 在 64KB 页面 + 3 级（52 位，需要硬件支持）的内存布局如下所示：

| 开始地址 | 结束地址 | 大小 | 用途 |
|-----------------------------------------------------------------------|
| 0000000000000000 | 000fffffffffffff | 4PB | 用户空间 |
| fff0000000000000 | ffff7fffffffffff | ~4PB | 内核逻辑内存映射 |
| [fffd800000000000 | ffff7fffffffffff] | 512TB | [kasan shadow 区域] |
| ffff800000000000 | ffff80007fffffff | 2GB | 模块 |
| ffff800080000000 | fffffbffefffffff | 124TB | vmalloc |
| fffffbfff0000000 | fffffbfffdffffff | 224MB | 固定映射（自上而下） |
| fffffbfffe000000 | fffffbfffe7fffff | 8MB | [保护区域] |
| fffffbfffe800000 | fffffbffff7fffff | 16MB | PCI I/O 空间 |
| fffffbffff800000 | fffffbffffffffff | 8MB | [保护区域] |
| fffffc0000000000 | fffffffdfffffffff | ~4TB | vmemmap |
| ffffffe000000000 | ffffffffffffffff | 128GB | [保护区域] |

4KB 页面的页表查找方式如下所示：

```
+--------+--------+--------+--------+--------+--------+--------+--------+
|63    56|55    48|47    40|39    32|31    24|23    16|15     8|7      0|
+--------+--------+--------+--------+--------+--------+--------+--------+
            |        |         |         |         |         |
            |        |         |         |         |         v
            |        |         |         |         |   [11:0]  页面偏移
            |        |         |         |         +-> [20:12] L3 索引
            |        |         |         +-----------> [29:21] L2 索引
            |        |         +---------------------> [38:30] L1 索引
            |        +-------------------------------> [47:39] L0 索引
            +----------------------------------------> [55] TTBR0/1
```

64KB 页面的页表查找方式如下所示：

```
+--------+--------+--------+--------+--------+--------+--------+--------+
|63    56|55    48|47    40|39    32|31    24|23    16|15     8|7      0|
+--------+--------+--------+--------+--------+--------+--------+--------+
            |        |    |               |              |
            |        |    |               |              v
            |        |    |               |            [15:0]  页面偏移
            |        |    |               +----------> [28:16] L3 索引
            |        |    +--------------------------> [41:29] L2 索引
            |        +-------------------------------> [47:42] L1 索引（48 位）
            |                                          [51:42] L1 索引（52 位）
            +----------------------------------------> [55] TTBR0/1
```

当使用 KVM 而没有 Virtualization Host Extensions 时，虚拟机在 EL2 上以一个固定的（且可能随机的）偏移量映射内核页面。更多信息请参阅 `kern_hyp_va` 宏和 `kvm_update_va_mask` 函数。MMIO 设备如 GICv2 会紧邻 HYP idmap 页面映射，当为特定 CPU 启用 `ARM64_SPECTRE_V3A` 时，中断向量也会如此映射。
当使用带有 Virtualization Host Extensions 的 KVM 时，不需要创建额外的映射，因为主机内核直接在 EL2 上运行。

52 位 VA 支持在内核中
-------------------------------
如果存在 ARMv8.2-LVA 可选特性，并且我们正在使用 64KB 页面大小；那么可以为用户空间和内核地址使用 52 位的地址空间。然而，任何支持 52 位的内核二进制文件也必须能够在早期启动时硬件特性不存在的情况下回退到 48 位。
这种回退机制要求内核的 `.text` 部分位于较高地址处，以便它们对 48/52 位 VA 不变。由于 kasan shadow 占用了整个内核 VA 空间的部分，无论是在 48 位还是 52 位情况下，kasan shadow 的结束地址都必须位于内核 VA 空间的较高一半中。（从 48 位转换到 52 位时，kasan shadow 的结束地址不变且依赖于 `~0UL`，而起始地址将“增长”到较低地址）
为了优化 `phys_to_virt` 和 `virt_to_phys`，`PAGE_OFFSET` 被保持在一个常量值 0xFFF0000000000000（对应 52 位），这样就不需要额外的变量读取。`physvirt` 偏移量和 `vmemmap` 偏移量在早期启动时计算以实现这一逻辑。
由于单一的二进制文件需要同时支持 48 位和 52 位 VA 空间，因此 `VMEMMAP` 必须足够大以适应 52 位 VA，并且还必须足够大以容纳一个固定的 `PAGE_OFFSET`。
内核中的大部分代码通常不需要考虑`VA_BITS`，但对于确实需要了解虚拟地址（VA）大小的代码，相关变量定义如下：

VA_BITS		常量	*最大* 虚拟地址空间大小

VA_BITS_MIN	常量	*最小* 虚拟地址空间大小

vabits_actual	变量	*实际* 虚拟地址空间大小

最大和最小大小对于确保缓冲区足够大或地址足够接近以应对“最坏情况”是有用的，例如52位用户空间的虚拟地址。

### 52位用户空间虚拟地址

为了与依赖ARMv8.0架构下48位虚拟地址空间最大值的软件保持兼容性，默认情况下，内核将向用户空间返回来自48位范围内的虚拟地址。软件可以通过指定一个大于48位的mmap提示参数来选择接收来自52位空间的虚拟地址。例如：

```c
maybe_high_address = mmap(~0UL, size, prot, flags,...);
```

此外，也可以通过启用以下内核配置选项来构建一个返回52位空间地址的调试内核：

```sh
CONFIG_EXPERT=y && CONFIG_ARM64_FORCE_52BIT=y
```

请注意，此选项仅用于调试应用程序，不应在生产环境中使用。
