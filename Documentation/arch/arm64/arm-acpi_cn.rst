===================
ACPI 在 Arm 系统上的应用
===================

ACPI 可以用于遵循 BSA（Arm 基础系统架构）[0] 和 BBR（Arm 基础启动要求）[1] 规范设计的 Armv8 和 Armv9 系统。BSA 和 BBR 都是公开可访问的文档。
Arm 服务器，除了符合 BSA 的要求外，还遵循在 SBSA（服务器基础系统架构）[2] 中定义的一系列规则。
Arm 内核实现了 ACPI 版本 5.1 或更高版本的简化硬件模型。该规范及其引用的所有外部文档由 UEFI 论坛管理。规范可在 http://www.uefi.org/specifications 获取，而规范中引用的文档则可通过 http://www.uefi.org/acpi 找到。
如果一个 Arm 系统不符合 BSA 和 BBR 的要求，或者无法使用所需 ACPI 规范中定义的机制进行描述，则 ACPI 对于此类硬件可能不是一个好的选择。
尽管上述文档规定了构建行业标准 Arm 系统的要求，但它们也适用于多个操作系统。本文档的目的仅在于描述 ACPI 和 Linux 在 Arm 系统上的交互 —— 即 Linux 对 ACPI 的期望以及 ACPI 对 Linux 的期望。

为什么在 Arm 上使用 ACPI？
-------------------------------

在详细探讨 ACPI 和 Linux 之间的接口之前，理解为什么使用 ACPI 是有帮助的。毕竟，Linux 中已经存在多种技术来描述非枚举型硬件。本节总结了 Grant Likely 的一篇博客文章 [3]，概述了在 Arm 系统上使用 ACPI 的理由。实际上，我们几乎直接摘取了部分总结文本。
对于在 Arm 上采用 ACPI 的简要理由如下：

-  ACPI 的字节码（AML）允许平台编码硬件行为，而设备树（DT）明确不支持这一点。对于硬件供应商来说，能够编码行为是在新硬件上支持操作系统发布的关键工具。
-  ACPI 的 OSPM 定义了一个约束平台可以执行操作的特定模型的电源管理模型，同时仍然为硬件设计提供了灵活性。
-  在企业服务器环境中，ACPI 已经建立了绑定（例如针对 RAS），这些绑定目前在生产系统中被使用。设备树并不具备这样的绑定。
虽然可以在某个时候在设备树中定义这样的绑定，但这样做意味着 Arm 和 x86 在固件和内核中最终会使用完全不同的代码路径。
选择单一接口来描述平台与操作系统之间的抽象层是非常重要的。硬件供应商如果想要支持多种操作系统，并不需要同时实现设备树（DT）和高级配置与电源接口（ACPI）。此外，就单一接口达成一致而不是为每个操作系统制定单独的接口，可以提高整体的互操作性。

新的ACPI治理流程运行良好，Linux现在与硬件供应商和其他操作系统供应商处于同一地位。实际上，现在已经没有理由认为ACPI只属于Windows或Linux在这一领域相对于微软处于次要位置。将ACPI治理转移到UEFI论坛极大地开放了规范开发过程，目前对ACPI所做的大部分更改都是由Linux驱动的。

使用ACPI的关键在于支持模型。对于服务器而言，硬件行为的责任不能仅仅归属于内核，而必须在平台和内核之间进行划分，以允许随着时间的推移有序地变更。ACPI使操作系统无需理解硬件的所有细节，从而不必为每台设备单独移植操作系统。它允许硬件供应商负责电源管理行为，而不依赖于他们无法控制的操作系统发布周期。

ACPI之所以重要，是因为硬件和操作系统供应商已经共同确定了一般用途计算生态系统的支持机制。基础设施、绑定和流程都已到位。设备树（DT）在处理垂直集成设备时确实满足了Linux的需求，但对于服务器供应商所需的支持却缺乏良好的流程。Linux有可能通过DT达到目的，但这实际上是重复了一个已经行之有效的方法。ACPI已经满足了硬件供应商的需求，微软不会参与到DT的合作中，而硬件供应商最终仍需要提供两个完全独立的固件接口——一个用于Linux，另一个用于Windows。

### 内核兼容性

ACPI的一个主要动机是标准化，利用这一点为Linux内核提供向后兼容性。在服务器市场中，软件和硬件通常会被长期使用。ACPI使得内核和固件能够在长时间内就一致的抽象层达成共识，即使硬件或软件发生变化也是如此。只要抽象层得到支持，系统就可以更新，而不一定需要替换内核。

当Linux驱动程序或子系统首次使用ACPI实现时，它们实际上就需要特定版本的ACPI规范——即其基线。ACPI固件必须继续工作，即使可能不是最优的，但也必须能够与最早提供该基线版本ACPI支持的内核版本一起工作。可能需要额外的驱动程序，但添加新功能（例如，CPU电源管理）不应破坏旧的内核版本。此外，ACPI固件也必须与最新的内核版本一起工作。

### 与设备树的关系

Arm上的驱动程序和子系统对ACPI的支持不应该与编译时的设备树（DT）支持相互排斥。

在启动时，内核将仅根据从引导加载器（包括内核启动参数）传递的参数使用一种描述方法。

无论使用设备树还是ACPI，内核始终必须能够使用任一方案启动（对于启用了这两种方案的内核）。

### 使用ACPI表启动

Arm上将ACPI表传递给内核的唯一定义方法是通过UEFI系统配置表。为了明确起见，这意味着ACPI仅在通过UEFI启动的平台上受支持。
当一个 ARM 系统启动时，它可以有设备树 (DT) 信息、ACPI 表格，或者在一些非常特殊的情况下两者都有。如果没有使用命令行参数，内核将尝试使用 DT 进行设备枚举；如果不存在 DT，则内核会尝试使用 ACPI 表格，但这仅在 ACPI 表格存在的情况下。如果两者都不可用，内核将无法启动。如果在命令行中使用 `acpi=force`，内核将首先尝试使用 ACPI 表格，但如果不存在 ACPI 表格则会退回到 DT。基本思路是除非内核绝对没有其他选择，否则不会导致启动失败。
通过在内核命令行传递 `acpi=off` 可以禁用 ACPI 表格的处理；这是默认行为。
为了让内核能够加载和使用 ACPI 表格，UEFI 实现 **必须** 将 `ACPI_20_TABLE_GUID` 设置为指向 RSDP 表（具有 "RSD PTR " ACPI 标志的表）。如果这个指针不正确，并且使用了 `acpi=force`，内核将禁用 ACPI 并尝试使用 DT 来启动；实际上，内核已经确定了此时不存在 ACPI 表格。
如果指向 RSDP 表的指针是正确的，ACPI 核心将使用由 UEFI 提供的地址将该表映射到内核中。
然后，ACPI 核心将使用 RSDP 表中的地址来定位 XSDT（扩展系统描述表），并进一步映射所有其他由系统固件提供的 ACPI 表格。XSDT 反过来提供了系统固件提供的所有其他 ACPI 表格的地址；然后 ACPI 核心将遍历这些表格并映射列出的表格。
ACPI 核心将忽略任何提供的 RSDT（根系统描述表）。RSDT 已被废弃，并且在 arm64 上被忽略，因为它们只允许使用 32 位地址。
此外，ACPI 核心只使用 FADT（固定 ACPI 描述表）中的 64 位地址字段。FADT 中的任何 32 位地址字段将在 arm64 上被忽略。
硬件简化模式（参见 ACPI 6.1 规范第 4.1 节）将在 arm64 上由 ACPI 核心强制执行。这样做可以让 ACPI 核心运行更简单的代码，因为它不再需要为其他架构的旧式硬件提供支持。对于硬件简化模式不需要使用的任何字段必须设置为零。
为了使ACPI核心正常运行，并进而提供内核配置设备所需的信息，它期望找到以下表格（所有章节编号均参照ACPI 6.5规范）：

    - RSDP（根系统描述指针），第5.2.5节

    - XSDT（扩展系统描述表），第5.2.8节

    - FADT（固定ACPI描述表），第5.2.9节

    - DSDT（差异化系统描述表），第5.2.11.1节

    - MADT（多APIC描述表），第5.2.12节

    - GTDT（通用定时器描述表），第5.2.24节

    - PPTT（处理器属性拓扑表），第5.2.30节

    - DBG2（DeBuG端口表2），第5.2.6节，具体为表5-6
- APMT（Arm性能监控单元表），第5.2.6节，具体为表5-6
- AGDI（Arm通用诊断卸载和重置设备接口表），第5.2.6节，具体为表5-6
- 如果支持PCI，则需要MCFG（内存映射配置表），第5.2.6节，具体为表5-6
- 如果支持无控制台=设备内核参数启动，则需要SPCR（串行端口控制台重定向表），第5.2.6节，具体为表5-6
- 如果有必要描述I/O拓扑、SMMUs和GIC ITSs，则需要IORT（输入输出重映射表），第5.2.6节，具体为表5-6
- 如果支持NUMA，则需要以下表格：

       - SRAT（系统资源亲和性表），第5.2.16节

       - SLIT（系统局部性距离信息表），第5.2.17节

    - 如果支持NUMA，并且系统包含异构内存，则需要HMAT（异构内存属性表），第5.2.28节
- 如果需要ACPI平台错误接口，则有条件地需要以下表格：

       - BERT（启动错误记录表），第18.3.1节

       - EINJ（错误注入表），第18.6.1节

       - ERST（错误记录序列化表），第18.5节

       - HEST（硬件错误源表），第18.3.2节

       - SDEI（软件委托异常接口表），第5.2.6节，具体为表5-6

       - AEST（Arm错误源表），第5.2.6节，具体为表5-6

       - RAS2（ACPI RAS2特性表），第5.2.21节

    - 如果系统包含使用PCC通道的控制器，则需要PCCT（平台通信通道表），第14.1节

    - 如果系统包含一个用于捕获板级系统状态并与主机通过PCC通信的控制器，则需要PDTT（平台调试触发表），第5.2.29节
- 如果支持NVDIMM，则需要NFIT（NVDIMM固件接口表），第5.2.26节

    - 如果存在视频帧缓冲区，则需要BGRT（启动图形资源表），第5.2.23节

    - 如果实现了IPMI，则需要SPMI（服务器平台管理接口），第5.2.6节，具体为表5-6
- 如果系统包含一个CXL主机桥接器，则需要CEDT（CXL早期发现表），第5.2.6节，具体为表5-6
- 如果系统支持MPAM，应特别参考MPAM（内存分区与监控表），第5.2.6节，
       具体来说是表5-6。
- 如果系统缺少持久性存储，应特别参考IBFT（iSCSI启动固件
       表），第5.2.6节，具体来说是表5-6。
如果上述表格不全存在，内核可能无法正常启动，因为它可能无法配置所有可用的
设备。这个表格列表并非全部；在某些环境下，可能还需要其他表格（例如，第18节中的任何APEI
表格）来支持特定功能。
ACPI检测
--------------
驱动程序应该通过检查ACPI_HANDLE是否为空值，或者检查.of_node，或者设备结构中的其他信息来确定其probe()类型。这在“驱动程序建议”部分中有更详细的说明。
在非驱动代码中，如果需要在运行时检测ACPI的存在，则应检查acpi_disabled的值。如果未设置CONFIG_ACPI，acpi_disabled将始终为1。
设备枚举
------------------
ACPI中的设备描述应使用标准认可的ACPI接口。
这些描述可能包含的信息比通过设备树描述同一设备通常提供的信息要少。这也是ACPI有用的原因之一 —— 驱动程序考虑到它可能对设备了解的信息较少，并因此使用合理的默认值。
如果驱动程序正确处理了这一点，硬件可以随着时间推移发生变化和改进，而无需改变驱动程序本身。
时钟提供了一个很好的例子。在设备树(Device Tree, DT)中，时钟需要被指定，驱动程序也需要考虑它们。而在ACPI中，默认假设UEFI会将设备保持在一个合理状态，包括任何时钟设置。如果出于某种原因驱动程序需要更改一个时钟值，这可以在一个ACPI方法中完成；驱动程序所要做的是调用该方法，而不需要关心该方法如何实际更改时钟。这样，可以通过更改ACPI方法来随着时间推移改变硬件，而无需更改驱动程序。
在DT中，驱动程序为了像上面的例子那样设置时钟所需的参数被称为“绑定(bindings)”；在ACPI中，这些被称为“设备属性(Device Properties)”，并通过_DSD对象提供给驱动程序。
ACPI 表格使用一种称为 ASL（ACPI 源语言）的形式语言进行描述（规范的第 19 节）。这意味着总是有多种方式来描述同样的事物 — 包括设备属性。例如，设备属性可以使用看起来像这样的 ASL 构造：Name(KEY0, "value0")。然后，ACPI 设备驱动程序将通过评估 KEY0 对象来检索该属性的值。然而，以这种方式使用 Name() 存在多个问题：(1) ACPI 将名称（如 "KEY0"）限制为四个字符，与 DT 不同；(2) 没有一个行业范围内的注册表来维护名称列表，从而最小化重复使用；(3) 同样也没有一个用于定义属性值（如 "value0"）的注册表，这同样使得重复使用变得困难；(4) 当新硬件出现时，如何保持向后兼容性？_DSD 方法正是为了解决这类问题而创建的；Linux 驱动程序应该始终使用 _DSD 方法来处理设备属性，而不是其他方法。

_DSM 对象（ACPI 第 9.14.1 节）也可以用来向驱动程序传递设备属性。Linux 驱动程序只应在 _DSD 无法表示所需数据，并且无法为 _DSD 对象创建新的 UUID 的情况下期望使用它。需要注意的是，对 _DSM 的使用监管甚至比 _DSD 更少。随着时间的推移，依赖于 _DSM 对象内容的驱动程序将更难以维护；截止到本文撰写之时，_DSM 的使用是导致相当多固件问题的原因，因此不推荐使用。

驱动程序应该只在 _DSD 对象中查找设备属性；_DSD 对象在 ACPI 规范的第 6.2.5 节中有所描述，但仅描述了如何定义通过 _DSD 返回的对象结构，以及特定 UUID 定义的具体数据结构。Linux 应该只使用 _DSD 设备属性 UUID [4]：

   - UUID: daffd814-6eba-4d8c-8a91-bc9bbf4aa301

可以通过提交拉取请求到 [4] 来注册通用的设备属性，以便它们可以在所有支持 ACPI 的操作系统中使用。

尚未在 UEFI 论坛注册的设备属性可以使用，但不能作为 "uefi-" 类型的通用属性使用。

在创建新的设备属性之前，请确保它们没有被定义过，并且要么已经在 Linux 内核文档中作为 DT 绑定注册，要么在 UEFI 论坛中作为设备属性注册。虽然我们并不想简单地将所有的 DT 绑定移动到 ACPI 设备属性中，但我们可以从以前定义的内容中学到经验。

如果有必要定义一个新的设备属性，或者如果合成绑定定义使其能够在任何固件中使用是有意义的，那么对于设备驱动程序的 DT 绑定和 ACPI 设备属性都有审查流程。两者都要用。当驱动程序本身提交给 Linux 邮件列表进行审核时，必须同时提交所需的设备属性定义。如果缺少这些定义，支持 ACPI 并使用设备属性的驱动程序将不会被视为完整。一旦设备属性被 Linux 社区接受，必须将其注册到 UEFI 论坛 [4]，后者将再次对其进行审核以确保其在注册表中的一致性。这可能需要反复迭代。但是，UEFI 论坛始终将是设备属性定义的权威来源。

在打算注册一个未使用的设备属性名称时，通知 UEFI 论坛可能是有意义的，作为一种预留名称供以后使用的方式。其他操作系统供应商也将提交注册请求，这可能会帮助简化这一过程。

完成注册和审核后，内核提供了一个独立于是否使用 DT 或 ACPI 查找设备属性的接口。应该使用这个 API [5]；它可以消除驱动程序探测函数中的一些代码路径重复，并阻止 DT 绑定和 ACPI 设备属性之间的分歧。

### 可编程电源控制资源
可编程电源控制资源包括电压/电流提供者（调节器）和时钟源等资源。
通过ACPI，内核时钟和调节框架不期望被使用。
内核假设这些资源的电源控制是通过
电源资源对象（ACPI第7.1节）表示的。然后，ACPI核心将正确处理
根据需要启用和禁用资源。为了使这一切工作，ACPI假设每个设备都定义了D状态，并且可以通过可选的ACPI方法_PS0、_PS1、_PS2和_PS3进行控制；
在ACPI中，_PS0是将设备完全打开的方法，而_PS3则是将设备完全关闭的方法。
对于使用这些电源资源有两种选择。它们可以：

   - 在进入Dx电源状态时调用的_PSx方法中进行管理
- 单独声明为具有自己的_ON和_OFF方法的电源资源。然后通过_PRx将它们与特定设备的D状态关联起来，_PRx指定了设备在Dx状态下需要开启的电源资源。内核随后跟踪使用某个电源资源的设备数量，并在需要时调用_ON/_OFF方法
内核中的ACPI代码还将假设_PSx方法遵循此类方法通常的ACPI规则：

   - 如果实现了_PS0或_PS3中的任何一个，则必须实现另一个方法
- 如果设备在开启时需要使用或设置电源资源，则ACPI源语言(ASL)应组织将其分配/启用使用_PS0方法
- 在_PS0方法中分配或启用的资源应在_PS3方法中禁用或取消分配
- 固件将在将控制权移交给内核之前将资源置于合理状态
_PSx方法中的这类代码当然会非常依赖于平台。但是，
这允许驱动程序抽象出操作设备的接口，并避免必须从ACPI表中读取特殊的非标准值。此外，
对这些资源使用的抽象化允许硬件随时间变化而不必更新驱动程序
时钟
------
ACPI假设时钟由固件——在这种情况下为UEFI——初始化为某个有效值，在将控制权移交给内核之前。这对诸如UART或SoC驱动的LCD显示器等设备有影响。
当内核启动时，假设时钟已被设置为合理的运行值。如果由于某种原因需要更改频率——例如，为了电源管理而进行的节流——设备驱动程序应预期这一过程将被抽象成某个可以调用的 ACPI 方法（请参阅 ACPI 规范以获取关于期望的标准方法的进一步建议）。唯一的例外是 CPU 时钟，因为 CPPC 提供了一个比 ACPI 方法更丰富的接口。如果时钟未被设置，Linux 将没有直接的方式来控制它们。如果一个 SoC 厂商希望提供对系统时钟的精细控制，他们可以通过提供可以被 Linux 驱动程序调用的 ACPI 方法来实现这一点。然而，这并不推荐，且 Linux 驱动程序不应使用这些方法，即使它们被提供了。这些方法目前并未在 ACPI 规范中标准化，并且使用它们可能会使内核与特定的 SoC 版本或 SoC 与特定版本的内核绑定在一起，而这正是我们试图避免的情况。

### 驱动程序建议
-------------------

**不要** 在添加 ACPI 支持时移除任何设备树 (DT) 处理。相同的设备可能用于许多不同的系统上。

**尝试** 将驱动程序设计为数据驱动的方式。也就是说，根据默认值和驱动程序探测函数必须发现的其他信息，设置一个包含每个设备内部状态的结构体。然后让驱动程序的其余部分基于该结构体的内容进行操作。这样做应该能确保 ACPI 和 DT 功能之间的大多数差异仅限于探测函数，而不是分散在整个驱动程序中。例如：

```c
static int device_probe_dt(struct platform_device *pdev)
{
         /* 设备树 (DT) 特定功能 */
         ..
}

static int device_probe_acpi(struct platform_device *pdev)
{
         /* ACPI 特定功能 */
         ..
}

static int device_probe(struct platform_device *pdev)
{
         ..
struct device_node node = pdev->dev.of_node;
         ..
if (node)
                 ret = device_probe_dt(pdev);
         else if (ACPI_HANDLE(&pdev->dev))
                 ret = device_probe_acpi(pdev);
         else
                 /* 其他初始化 */
                 ..
/* 继续执行任何通用的探测操作 */
         ..
}
```

**保持** 在驱动程序中将 MODULE_DEVICE_TABLE 条目集中在一起，以便清楚地显示驱动程序通过设备树 (DT) 和 ACPI 探测的不同名称：

```c
static struct of_device_id virtio_mmio_match[] = {
          { .compatible = "virtio,mmio", },
          { }
};
MODULE_DEVICE_TABLE(of, virtio_mmio_match);

static const struct acpi_device_id virtio_mmio_acpi_match[] = {
          { "LNRO0005", },
          { }
};
MODULE_DEVICE_TABLE(acpi, virtio_mmio_acpi_match);
```

### ASWG
ACPI 规范会定期更新。例如，在 2014 年间，发布了 5.1 版本，并且完成了大部分 6.0 版本的工作，其中许多变更都是由 Arm 的具体需求驱动的。提出的变更会在 ASWG (ACPI 规范工作组)，即 UEFI 论坛的一部分中提出并讨论。当前版本的 ACPI 规范是 2022 年 8 月发布的 6.5 版本。
本组的参与面向所有UEFI成员开放。有关成员资格的详细信息，请参见
http://www.uefi.org/workinggroup 
ARM ACPI内核代码的目标是尽可能严格遵循ACPI规范，并仅实现符合UEFI ASWG发布的标准的功能。实际上，可能会有供应商提供不合规的ACPI表或以某种方式违反这些标准。
如果这是由于错误导致，则可能需要进行一些特殊处理和修正，但会尽量避免这种情况。如果ACPI中缺少某些特性从而使其无法在某个平台上使用，则应提交ECR（工程变更请求）给ASWG并经过正常的审批流程；对于不是UEFI成员的用户，Linux社区中的许多其他成员是UEFI成员，并且很可能会愿意协助提交ECR。

Linux代码
---------
与ARM上的Linux相关的特定项目，包含在Linux源代码中，如下列表所示：

ACPI_OS_NAME
                       此宏定义了当ACPI方法调用_OS方法时返回的字符串。在ARM系统上，默认情况下此宏将为“Linux”。
可以使用命令行参数acpi_os=<string>将其设置为其他值。对于其他架构，默认值为“Microsoft Windows NT”。

ACPI对象
--------
对ACPI表和对象的详细期望列于文件Documentation/arch/arm64/acpi_object_usage.rst中。

参考文献
--------
[0] https://developer.arm.com/documentation/den0094/latest
    文档Arm-DEN-0094：“ARM基础系统架构”，版本1.0C，日期为2022年10月6日

[1] https://developer.arm.com/documentation/den0044/latest
    文档Arm-DEN-0044：“ARM基础启动要求”，版本2.0G，日期为2022年4月15日

[2] https://developer.arm.com/documentation/den0029/latest
    文档Arm-DEN-0029：“ARM服务器基础系统架构”，版本7.1，日期为2022年10月6日

[3] http://www.secretlab.ca/archives/151，
    2015年1月10日，版权所有 © 2015，
    Linaro Ltd.，由Grant Likely编写

[4] _DSD（设备特定数据）实现指南
    https://github.com/UEFI/DSD-Guide/blob/main/dsd-guide.pdf

[5] 统一设备属性接口的内核代码可以在include/linux/property.h和drivers/base/property.c中找到。

作者
-----
- Al Stone <al.stone@linaro.org>
- Graeme Gregory <graeme.gregory@linaro.org>
- Hanjun Guo <hanjun.guo@linaro.org>

- Grant Likely <grant.likely@linaro.org>，负责"Why ACPI on ARM?"部分的撰写
