======================
AArch64 Linux 的可扩展矩阵扩展支持
======================

本文档简要概述了 Linux 向用户空间提供的接口，以支持使用 ARM 可扩展矩阵扩展 (SME)。这里仅概述最重要的特性和问题，并非详尽无遗。应当与 `sve.rst` 中的 SVE 文档一起阅读，该文档提供了关于包含在 SME 中的流式 SVE 模式的详细信息。
本文档不打算描述 SME 架构或程序员模型。为了帮助理解，在附录 A 中包含了 SME 相关程序员模型特性的最小描述。
1. 通用说明
--------------

* PSTATE.SM、PSTATE.ZA、流模式向量长度、ZA 寄存器状态（以及存在时的 ZTn 寄存器状态）和 TPIDR2_EL0 都是按线程跟踪的。
* SME 的存在通过辅助向量中的 AT_HWCAP2 入口中的 HWCAP2_SME 标志报告给用户空间。此标志的存在意味着存在 SME 指令和寄存器，以及本文件中描述的 Linux 特定系统接口。SME 在 `/proc/cpuinfo` 中显示为 "sme"。
* SME2 的存在通过辅助向量中的 AT_HWCAP2 入口中的 HWCAP2_SME2 标志报告给用户空间。此标志的存在意味着存在 SME2 指令和 ZT0，以及本文件中描述的 Linux 特定系统接口。SME2 在 `/proc/cpuinfo` 中显示为 "sme2"。
* 用户空间可以通过读取 CPU ID 寄存器 ID_AA64PFR1_EL1 来检测执行 SME 指令的支持情况，使用 MRS 指令检查 SME 字段的值非零。[3] 
   这并不保证以下各节中描述的系统接口的存在：需要验证这些接口存在的软件必须检查 HWCAP2_SME。
* 有多个可选的 SME 特性，它们的存在通过 AT_HWCAP2 报告：

    HWCAP2_SME_I16I64
    HWCAP2_SME_F64F64
    HWCAP2_SME_I8I32
    HWCAP2_SME_F16F32
    HWCAP2_SME_B16F32
    HWCAP2_SME_F32F32
    HWCAP2_SME_FA64
    HWCAP2_SME2

  随着 SME 架构的发展，这个列表可能会随时间延长。
这些扩展也通过 CPU ID 寄存器 ID_AA64SMFR0_EL1 报告，用户空间可以使用 MRS 指令读取。请参阅 `elf_hwcaps.txt` 和 `cpu-feature-registers.txt` 获取更多细节。
* 调试器应限制自己通过 NT_ARM_SVE、NT_ARM_SSVE、NT_ARM_ZA 和 NT_ARM_ZT 注册集与目标交互。推荐的检测这些注册集支持的方法是先连接到目标进程，然后尝试进行

	ptrace(PTRACE_GETREGSET, pid, NT_ARM_<regset>, &iov)
* 当用户空间与内核之间在内存中交换ZA寄存器值时，该寄存器值以一系列从0到VL/8-1的水平向量形式编码在内存中，并使用与SVE向量相同的端序不变格式进行存储。
* 在线程创建时，除非指定了CLONE_SETTLS，否则TPIDR2_EL0将被保留，在这种情况下，它会被设置为0。
2. **向量长度**
------------------

SME定义了第二种类似于SVE向量长度的向量长度，它控制着流模式SVE向量和ZA矩阵数组的大小。ZA矩阵是正方形的，每边的字节数与流模式SVE向量相同。
3. **流模式与非流模式SVE状态的共享**
---------------------------------------------------------

是否以及哪些部分的SVE状态在流模式和非流模式之间共享是由实现定义的。当通过像ptrace这样的软件接口在不同模式间切换时，如果没有提供寄存器内容，则假定没有任何状态被共享，所有内容都将被清零。
4. **系统调用行为**
-------------------------

* 在系统调用时PSTATE.ZA将被保留，如果PSTATE.ZA等于1，则ZA矩阵的内容以及ZTn（如果存在）也将被保留。
* 在系统调用时PSTATE.SM将被清除，并且SVE寄存器将按照标准SVE ABI处理。
* SVE寄存器、ZA或ZTn均不用于传递系统调用参数或接收系统调用结果。
* 在进程创建（例如，clone()）时，新创建的进程将有PSTATE.SM被清除。
* 线程的所有其他SME状态，包括当前配置的向量长度、PR_SME_VL_INHERIT标志的状态以及延迟向量长度（如果有），在所有系统调用中都将被保留，但第6节中描述的execve()特殊情况除外。
### 信号处理
-------------------

* 信号处理器在流模式下被调用，并且禁用了ZA。
* 添加了一个新的信号帧记录`TPIDR2_MAGIC`，其格式为`tpidr2_context`结构体，以便从信号处理器中访问`TPIDR2_EL0`。
* 在信号传递时添加了一个新的信号帧记录`za_context`来编码ZA寄存器的内容。[1]

* ZA的信号帧记录始终包含基本元数据，特别是线程的向量长度（位于`za_context.vl`中）。
* ZA矩阵可能包含也可能不包含在记录中，这取决于PSTATE.ZA的值。寄存器仅当：
  `za_context.head.size >= ZA_SIG_CONTEXT_SIZE(sve_vq_from_vl(za_context.vl))`
  时存在，此时`PSTATE.ZA == 1`。
* 如果矩阵数据存在，记录的其余部分具有依赖于vl的大小和布局。定义了宏`ZA_SIG_*` [1] 来方便访问它们。
* 矩阵以一系列水平向量的形式存储，与SVE向量使用的格式相同。
* 如果ZA上下文太大以至于无法放入`sigcontext.__reserved[]`中，则会在栈上分配额外的空间，并在`__reserved[]`中写入一个`extra_context`记录来引用这部分空间。然后将`za_context`写入额外的空间中。关于这一机制的更多细节请参考[1]。
* 如果支持ZTn并且`PSTATE.ZA==1`，则会生成一个ZTn的信号帧记录。
* ZTn的信号记录包含魔数`ZT_MAGIC`（0x5a544e01），由标准的信号帧头部后跟一个`zt_context`结构体组成，该结构体指定了系统支持的ZTn寄存器数量，随后是`zt_context.nregs`个每寄存器64字节的数据块。

### 信号返回
-----------------

从信号处理器返回时：

* 如果信号帧中没有`za_context`记录，或者记录虽然存在但如前一节所述不包含寄存器数据，则禁用ZA。
如果信号帧中包含 `za_context` 并且其中含有矩阵数据，则将 `PSTATE.ZA` 设置为 1，并用指定的数据填充 `ZA`。
* 无法通过信号返回更改向量长度。如果信号帧中的 `za_context.vl` 与当前的向量长度不匹配，则尝试返回信号被视为非法操作，从而导致强制触发 `SIGSEGV`。
* 如果不支持 `ZTn` 或者 `PSTATE.ZA==0`，则在信号帧中记录 `ZTn` 的信息是非法的，这会导致强制触发 `SIGSEGV`。
6. `prctl` 扩展
--------------------

添加了一些新的 `prctl()` 调用来允许程序管理 SME 向量长度：

`prctl(PR_SME_SET_VL, unsigned long arg)`

    设置调用线程的向量长度及相关标志，其中 `arg == vl | flags`。调用进程的其他线程不受影响。
`vl` 是期望的向量长度，其中必须满足 `sve_vl_valid(vl)` 为真。
标志：

	`PR_SME_VL_INHERIT`

	    在 `execve()` 调用时继承当前的向量长度。否则，在 `execve()` 调用时向量长度会被重置为系统默认值。（参见第 9 节。）

	`PR_SME_SET_VL_ONEXEC`

	    将请求的向量长度变更延迟到该线程下一次执行 `execve()` 时。
效果等同于在该线程下一次执行 `execve()`（如果有的话）后立即隐式执行以下调用：

	`prctl(PR_SME_SET_VL, arg & ~PR_SME_SET_VL_ONEXEC)`

	    这样可以启动一个新的程序并使用不同的向量长度，同时避免对调用者运行时产生副作用
如果没有 `PR_SME_SET_VL_ONEXEC`，请求的变更会立即生效
返回值：成功时返回非负数，出错时返回负数：
`EINVAL`: 不支持 SME、请求了无效的向量长度或无效的标志
成功时：

    * 根据 `arg` 中是否存在 `PR_SME_SET_VL_ONEXEC`，设置调用线程的向量长度或在下次 `execve()` 时应用的延迟向量长度，其值被设置为系统支持的最大值，且该值小于等于 `vl`。如果 `vl == SVE_VL_MAX`，设置的值将是系统支持的最大值。
* 在调用线程中，任何先前存在的延迟向量长度变更被取消。
* 返回的值描述了结果配置，其编码方式与 PR_SME_GET_VL 相同。此值中报告的向量长度是该线程的新当前向量长度（如果 arg 中不存在 PR_SME_SET_VL_ONEXEC）；否则，报告的向量长度是将在下一次由调用线程执行的 execve() 时应用的延迟向量长度。
* 更改向量长度会导致所有 ZA、ZTn、P0..P15、FFR 和除 Z0 的 [127:0] .. Z31 的 [127:0] 位之外的所有 Z0..Z31 位变为未指定状态，包括流式和非流式的 SVE 状态。对于此目的而言，使用等于线程当前向量长度的 vl 调用 PR_SME_SET_VL 或带有 PR_SME_SET_VL_ONEXEC 标志调用 PR_SME_SET_VL 不被视为向量长度的更改。
* 更改向量长度会导致 PSTATE.ZA 和 PSTATE.SM 被清除。对于此目的而言，使用等于线程当前向量长度的 vl 调用 PR_SME_SET_VL 或带有 PR_SME_SET_VL_ONEXEC 标志调用 PR_SME_SET_VL 不被视为向量长度的更改。
* prctl(PR_SME_GET_VL)

    获取调用线程的向量长度。
可以在结果中进行以下标志的或运算：

    PR_SME_VL_INHERIT

        向量长度将跨 execve() 继承。
没有方法可以确定是否存在一个待处理的延迟向量长度变更（在典型使用情况下，这通常只会在 fork() 或 vfork() 与对应的 execve() 之间发生）。
要从结果中提取向量长度，请将其与 PR_SME_VL_LEN_MASK 进行按位与操作。
返回值：成功时返回非负值，错误时返回负值：
	EINVAL: 不支持SME

7.  ptrace 扩展
---------------------

* 定义了一个新的寄存器集 NT_ARM_SSVE 用于通过 PTRACE_GETREGSET 和 PTRACE_SETREGSET 访问流模式 SVE 状态，相关内容已在 sve.rst 中进行记录。
* 定义了一个新的寄存器集 NT_ARM_ZA 用于访问 ZA 状态，可通过 PTRACE_GETREGSET 和 PTRACE_SETREGSET 进行访问。
具体定义请参阅 [2]。
寄存器集数据以 struct user_za_header 结构体开始，其中包含：

    size

寄存器集的完整大小（以字节为单位）
这取决于 vl，并且可能在未来还取决于其他因素
如果对 PTRACE_GETREGSET 的调用请求的数据少于 size 的值，调用者可以分配一个更大的缓冲区并重试，以便读取完整的寄存器集。
max_size

目标线程的寄存器集可以增长到的最大字节数。即使目标线程更改其向量长度等，寄存器集也不会超过此大小。
vl

目标线程当前的流式向量长度（以字节为单位）。
max_vl

目标线程可能的最大流式向量长度。
以下是提供的文本的中文翻译：

以下标志可为零个或多个，它们与相应的 PR_SET_VL_* 标志具有相同的含义和行为：

- SME_PT_VL_INHERIT

- SME_PT_VL_ONEXEC（仅适用于 SETREGSET）

* 更改向量长度及/或标志的效果等同于 PR_SME_SET_VL 中所记录的效果。
调用者如果需要知道 SETREGSET 实际设置的 VL 是什么，则必须进一步执行 GETREGSET 调用，除非已事先知道请求的 VL 是受支持的。
* 有效载荷的大小和布局取决于头部字段。提供了 ZA_PT_ZA*() 宏以方便访问数据。
* 在两种情况下，对于 SETREGSET，允许省略有效载荷，在这种情况下，向量长度和标志将被更改，并且 PSTATE.ZA 将被设置为 0（伴随着这些更改的任何后果）。如果提供了有效载荷，则 PSTATE.ZA 将被设置为 1。
* 对于 SETREGSET，如果请求的 VL 不受支持，则其效果将如同省略了有效载荷一样，除了会报告一个 EIO 错误之外。
不会尝试将有效载荷数据转换为实际设置的向量长度的正确布局。由调用者负责根据实际的 VL 转换有效载荷布局并重试。
* 写入部分、不完整有效载荷的效果是未指定的。
* 定义了一个新的寄存器集 NT_ARM_ZT 用于通过 PTRACE_GETREGSET 和 PTRACE_SETREGSET 访问 ZTn 状态。
* NT_ARM_ZT 寄存器集由一个单一的 512 位寄存器组成。
* 当PSTATE.ZA等于0时，对NT_ARM_ZT的读取会报告ZTn的所有位均为0
* 对NT_ARM_ZT的写入会将PSTATE.ZA设置为1
8.  ELF核心转储扩展
---------------------------

* 对于已转储进程中的每个线程，都会向每个核心转储添加NT_ARM_SSVE注释。其内容等同于如果在生成核心转储时为每个线程执行相应类型的PTRACE_GETREGSET所读取的数据
* 对于已转储进程中的每个线程，都会向每个核心转储添加一个NT_ARM_ZA注释。其内容等同于如果在生成核心转储时为每个线程执行NT_ARM_ZA的PTRACE_GETREGSET所读取的数据
* 对于已转储进程中的每个线程，都会向每个核心转储添加一个NT_ARM_ZT注释。其内容等同于如果在生成核心转储时为每个线程执行NT_ARM_ZT的PTRACE_GETREGSET所读取的数据
* NT_ARM_TLS注释将扩展到两个寄存器，第二个寄存器在支持SME的系统上将包含TPIDR2_EL0，并且在其他情况下会被读取为0，忽略写入操作
9.  系统运行时配置
--------------------------------

* 为了减轻信号帧扩展对ABI的影响，提供了一种策略机制供管理员、发行版维护者和开发者设置用户空间进程的默认向量长度：

/proc/sys/abi/sme_default_vector_length

    将整数的文本表示形式写入此文件可将系统的默认向量长度设置为指定值，使用与通过PR_SME_SET_VL设置向量长度相同的规则将其舍入到受支持的值
可以通过重新打开该文件并读取其内容来确定结果
启动时，默认向量长度最初设置为32或最大支持的向量长度（取较小且受支持的那个）。这决定了init进程（PID 1）的初始向量长度
读取此文件返回当前系统的默认向量长度
* 在每次 `execve()` 调用时，新进程的向量长度将被设置为系统默认向量长度，除非：

    * 对于调用线程设置了 `PR_SME_VL_INHERIT`（或等效地 `SME_PT_VL_INHERIT`），或者

    * 存在一个待处理的向量长度更改，该更改是通过 `PR_SME_SET_VL_ONEXEC` 标志（或 `SME_PT_VL_ONEXEC`）建立的。
* 修改系统默认向量长度不会影响任何未进行 `execve()` 调用的现有进程或线程的向量长度。

附录 A. SME 程序员模型（参考）

==============================

本节提供了一个最小化的描述，涵盖了 SME 对 ARMv8-A 程序员模型所做的与本文档相关的补充说明。请注意：本节仅为参考信息，并非旨在完整或替代任何架构规范。

A.1. 寄存器
--------------

在 A64 状态下，SME 添加了以下内容：

* 一种新的模式，称为流模式，在此模式中可使用 FPSIMD 和 SVE 的一部分特性。支持的 EL0 软件可以随时进入和退出流模式。
为了获得最佳系统性能，强烈建议软件仅在实际使用时启用流模式。
* 一个新的向量长度控制流模式下的 ZA 和 Z 寄存器大小，与非流模式下用于 SVE 的向量长度分开。对于给定系统中两种模式当前选定的向量长度或支持的向量长度集合之间没有特定关系的要求。流模式的向量长度称为 SVL。
* 一个新的 ZA 矩阵寄存器。这是一个 SVL×SVL 位的方阵。大多数对 ZA 的操作需要启用流模式，但可以在不启用流模式的情况下启用 ZA 来加载、保存和保留数据。
为了获得最佳系统性能，强烈建议软件仅在实际使用时启用 ZA。
* 当存在 SME2 时引入一个新的 ZT0 寄存器。这是一个 512 位的寄存器，当 PSTATE.ZA 设置时可以访问，就像 ZA 本身一样。
在PSTATE中新增了两个1位字段，这些字段可以通过SMSTART和SMSTOP指令或通过访问SVCR系统寄存器来控制：

* PSTATE.ZA，如果该值为1，则ZA矩阵可被访问并且包含有效数据；如果为0，则ZA无法被访问。当PSTATE.ZA从0变为1时，ZA中的所有位将被清零。
* PSTATE.SM，如果该值为1，则PE（处理单元）处于流模式。当PSTATE.SM的值发生变化时，是否可以保留两种模式下都有效的浮点寄存器子集的具体行为由实现定义。其他任何位都将被清零。

参考文献
=========

[1] arch/arm64/include/uapi/asm/sigcontext.h  
    AArch64 Linux信号ABI定义

[2] arch/arm64/include/uapi/asm/ptrace.h  
    AArch64 Linux ptrace ABI定义

[3] Documentation/arch/arm64/cpu-feature-registers.rst
