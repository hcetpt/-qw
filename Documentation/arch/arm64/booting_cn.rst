启动AArch64 Linux
=====================

作者: Will Deacon <will.deacon@arm.com>

日期  : 2012年9月7日

本文档基于Russell King编写的ARM启动文档，
适用于所有公开发布的AArch64 Linux内核。
AArch64异常模型由多个异常级别组成（EL0至EL3），其中EL0、EL1和EL2都有安全与非安全版本。EL2是虚拟机管理程序级别，EL3是最优先级且仅存在于安全模式下。这两者都是架构上可选的。
为本文档的目的，我们将使用术语“引导加载程序”来简单定义在将控制权交给Linux内核之前在CPU上执行的所有软件。这可能包括安全监视器和虚拟机管理程序代码，也可能只是一些用于准备最小启动环境的指令。
基本上，引导加载程序应提供以下内容：

1. 设置并初始化RAM
2. 设置设备树
3. 解压缩内核镜像
4. 调用内核镜像


1. 设置并初始化RAM
---------------------------

要求：必须

引导加载程序需要找到并初始化内核将在系统中用于易失性数据存储的所有RAM。它以机器依赖的方式执行此操作。（它可以使用内部算法自动定位和确定所有RAM的大小，也可以利用对机器中RAM的知识，或者采用引导加载程序设计人员认为合适的任何其他方法。）

2. 设置设备树
-------------------------

要求：必须

设备树二进制文件（dtb）必须放置在8字节对齐的位置，并且其大小不得超过2兆字节。由于dtb将使用最大2兆字节的块映射为可缓存，因此不得将其放置在任何必须使用特定属性映射的2M区域内。
注意：在v4.2之前的版本还要求DTB位于从内核镜像下方text_offset字节开始的512MB区域之内。
3. 解压缩内核镜像
------------------------------

要求：可选

当前AArch64内核不提供解压缩器，因此如果使用了压缩的镜像目标（例如Image.gz），则需要引导加载程序执行解压（如gzip等）。对于未实现此要求的引导加载程序，可以使用未压缩的Image目标。
4. 调用内核镜像
------------------------

要求：必须

解压缩后的内核镜像包含一个64字节的头部如下所示：

  u32 code0;			/* 可执行代码 */
  u32 code1;			/* 可执行代码 */
  u64 text_offset;		/* 镜像加载偏移量，小端格式 */
  u64 image_size;		/* 实际镜像大小，小端格式 */
  u64 flags;			/* 内核标志，小端格式 */
  u64 res2	= 0;		/* 保留 */
  u64 res3	= 0;		/* 保留 */
  u64 res4	= 0;		/* 保留 */
  u32 magic	= 0x644d5241;	/* 魔术数字，小端格式，“ARM\x64” */
  u32 res5;			/* 保留（用于PE COFF偏移量） */


头部说明：

- 自v3.17起，除非另有说明，所有字段均为小端格式
- code0/code1负责跳转到stext
- 通过EFI引导时，最初会跳过code0/code1
res5是一个指向PE头的偏移量，而PE头包含了EFI入口点（efi_stub_entry）。当引导程序完成其工作后，它会跳转到code0以继续正常的启动过程。
- 在 v3.17 之前，`text_offset` 的字节序没有被指定。在这种情况下，`image_size` 是零，而 `text_offset` 在内核的字节序下是 0x80000。当 `image_size` 非零时，它采用小端格式并且必须遵守。当 `image_size` 为零时，可以假设 `text_offset` 是 0x80000。
- `flags` 字段（在 v3.17 中引入）是一个 64 位的小端字段，其组成如下：

  ============= ===============================================================
  位 0         内核字节序。如果为大端则为 1，如果为小端则为 0
  位 1-2       内核页大小
    * 0 - 未指定
    * 1 - 4KB
    * 2 - 16KB
    * 3 - 64KB
  位 3         内核物理布局

    0
      2MB 对齐的基础地址应尽可能接近 DRAM 的基址，因为在此之下内存不能通过线性映射访问
    1
      2MB 对齐的基础地址，使得从镜像开始计算的全部 `image_size` 字节都在物理内存的 48 位可寻址范围内
  位 4-63     保留
  ============= ==============================================================

- 当 `image_size` 为零时，引导加载程序应尝试为内核立即在内核镜像末尾之后留出尽可能多的可用内存。所需的空间量将根据所选功能的不同而变化，并且实际上是没有上限的。
- 镜像必须放置在一个 2MB 对齐的基本地址上，该地址位于可用系统 RAM 的任何位置，并在那里调用。从 2MB 对齐的基础地址到镜像起始之间的区域对内核没有特殊意义，并可用于其他目的。
- 从镜像开始至少要有 `image_size` 字节的区域供内核使用。
- 注意：v4.6 之前的版本无法利用镜像物理偏移以下的内存，因此建议将镜像尽可能靠近系统 RAM 的起始位置放置。
- 如果在启动时向内核传递了 initrd/initramfs，它必须完全位于一个最大 32GB 大小的、1GB 对齐的物理内存窗口内，该窗口完全覆盖内核镜像。
任何向内核描述的内存（即使是在镜像开始之前的内存），如果未被标记为内核保留（例如，在设备树中通过 memreserve 区域），都将被视为可供内核使用。

在跳转到内核之前，必须满足以下条件：

- 使所有能够进行DMA操作的设备处于静默状态，以防止因错误的网络包或磁盘数据导致内存损坏。这将为你节省数小时的调试时间。
- 主CPU通用寄存器设置如下：

    - x0 = 设备树blob（dtb）在系统RAM中的物理地址
    - x1 = 0（预留供将来使用）
    - x2 = 0（预留供将来使用）
    - x3 = 0（预留供将来使用）

- CPU模式

  所有形式的中断都必须在 PSTATE.DAIF 中被屏蔽（调试、SErr、IRQ 和 FIQ）
CPU必须处于非安全状态，可以在 EL2 中（推荐，以便访问虚拟化扩展功能），或者在 EL1 中
- 缓存与MMU

  必须关闭MMU
指令缓存可以开启或关闭，但不得包含任何与加载的内核镜像相关的过时条目
与加载的内核镜像对应的地址范围必须被清理至PoC。在存在系统缓存或其他启用缓存的一致性主控的情况下，这通常需要通过虚拟地址而非集/路操作来进行缓存维护
遵守架构定义的通过虚拟地址进行缓存维护的系统缓存必须被配置，并且可以被启用
不遵守架构定义的通过虚拟地址进行缓存维护的系统缓存（不推荐）必须被配置并且禁用
- 定时器架构

  必须使用定时器频率对CNTFRQ进行编程，并且必须在所有CPU上为CNTVOFF编程一致的值。如果在EL1级别进入内核，CNTHCTL_EL2必须设置EL1PCTEN（位0），如果可用的话。
- 一致性

  由内核启动的所有CPU都必须在进入内核时属于同一个一致性域。这可能需要实现定义的初始化来确保每个CPU都能接收到维护操作。
- 系统寄存器

  在内核映像将要进入的异常级别或以下的所有可写的架构系统寄存器必须由更高异常级别的软件进行初始化，以防止处于未知状态的执行。
对于所有系统：
  - 如果存在EL3：

    - SCR_EL3.FIQ在内核运行的所有CPU上必须具有相同的值
- 当内核正在运行时，SCR_EL3.FIQ的值必须与启动时的值相同
- 如果存在EL3并且内核在EL2级别进入：

    - SCR_EL3.HCE（位8）必须初始化为0b1
对于使用GICv3中断控制器并将在v3模式下使用的系统：
  - 如果存在EL3：

      - ICC_SRE_EL3.Enable（位3）必须初始化为0b1
- ICC_SRE_EL3.SRE（位0）必须初始化为0b1
- ICC_CTLR_EL3.PMHE（位6）在内核运行的所有CPU上必须具有相同的值，并且在整个内核生命周期中保持不变
- 如果内核在EL1级别进入：

      - ICC_SRE_EL2.Enable（位3）必须初始化为0b1
      - ICC_SRE_EL2.SRE（位0）必须初始化为0b1
对于使用兼容模式（v2）的GICv3中断控制器的系统：

- 如果存在EL3：

    ICC_SRE_EL3.SRE（位0）必须初始化为0b0
- 如果内核在EL1级别启动：

    ICC_SRE_EL2.SRE（位0）必须初始化为0b0
- 设备树（DT）或ACPI表必须描述一个GICv2中断控制器
对于具有指针认证功能的CPU：

- 如果存在EL3：

    - SCR_EL3.APK（位16）必须初始化为0b1
    - SCR_EL3.API（位17）必须初始化为0b1

- 如果内核在EL1级别启动：

    - HCR_EL2.APK（位40）必须初始化为0b1
    - HCR_EL2.API（位41）必须初始化为0b1

对于具有活动监视器单元v1（AMUv1）扩展的CPU：

- 如果存在EL3：

    - CPTR_EL3.TAM（位30）必须初始化为0b0
    - CPTR_EL2.TAM（位30）必须初始化为0b0
    - AMCNTENSET0_EL0必须初始化为0b1111
    - AMCNTENSET1_EL0必须初始化为平台特定值，其中每个辅助计数器对应的位设置为0b1
- 如果内核在EL1级别启动：

    - AMCNTENSET0_EL0必须初始化为0b1111
    - AMCNTENSET1_EL0必须初始化为平台特定值，其中每个辅助计数器对应的位设置为0b1
对于具有细粒度陷阱（FEAT_FGT）扩展支持的CPU：

- 如果存在EL3且内核在EL2级别启动：

    - SCR_EL3.FGTEn（位27）必须初始化为0b1
对于支持HCRX_EL2（FEAT_HCX）的CPU：

- 如果存在EL3且内核在EL2级别启动：

    - SCR_EL3.HXEn（位38）必须初始化为0b1
对于具有高级SIMD和浮点支持的CPU：

- 如果存在EL3：

    - CPTR_EL3.TFP（位10）必须初始化为0b0
- 如果存在EL2且内核在EL1级别启动：

    - CPTR_EL2.TFP（位10）必须初始化为0b0
对于具备可扩展向量扩展（FEAT_SVE）特性的CPU：

  - 如果存在EL3：

    - 必须将CPTR_EL3.EZ（第8位）初始化为0b1
- 必须将ZCR_EL3.LEN初始化为同一值，该值适用于内核运行的所有CPU
- 如果内核在EL1级别进入且存在EL2：

    - 必须将CPTR_EL2.TZ（第8位）初始化为0b0
- 必须将CPTR_EL2.ZEN（第17至16位）初始化为0b11
- 必须将ZCR_EL2.LEN初始化为同一值，该值适用于内核将运行的所有CPU
对于具备可扩展矩阵扩展（FEAT_SME）特性的CPU：

  - 如果存在EL3：

    - 必须将CPTR_EL3.ESM（第12位）初始化为0b1
- 必须将SCR_EL3.EnTP2（第41位）初始化为0b1
- 必须将SMCR_EL3.LEN初始化为同一值，该值适用于内核将运行的所有CPU
- 如果内核在EL1级别进入且存在EL2：

    - 必须将CPTR_EL2.TSM（第12位）初始化为0b0
- 必须将CPTR_EL2.SMEN（第25至24位）初始化为0b11
- SCTLR_EL2.EnTP2（位60）必须初始化为0b1
- 对于内核将要执行的所有CPU，SMCR_EL2.LEN必须初始化为相同的值
- HWFGRTR_EL2.nTPIDR2_EL0（位55）必须初始化为0b01
- HWFGWTR_EL2.nTPIDR2_EL0（位55）必须初始化为0b01
- HWFGRTR_EL2.nSMPRI_EL1（位54）必须初始化为0b01
- HWFGWTR_EL2.nSMPRI_EL1（位54）必须初始化为0b01

对于具有可扩展矩阵扩展FA64特性（FEAT_SME_FA64）的CPU：

  - 如果存在EL3：

    - SMCR_EL3.FA64（位31）必须初始化为0b1
- 如果内核在EL1进入且存在EL2：

    - SMCR_EL2.FA64（位31）必须初始化为0b1

对于具有内存标记扩展特性（FEAT_MTE2）的CPU：

  - 如果存在EL3：

    - SCR_EL3.ATA（位26）必须初始化为0b1
- 如果内核在EL1进入且存在EL2：

    - HCR_EL2.ATA（位56）必须初始化为0b1
对于具有可扩展矩阵扩展版本2 (FEAT_SME2) 的CPU：

  - 如果存在EL3：

    - SMCR_EL3.EZT0（第30位）必须初始化为0b1
- 如果内核在EL1级别启动并且存在EL2：

    - SMCR_EL2.EZT0（第30位）必须初始化为0b1
对于具有内存复制和内存设置指令 (FEAT_MOPS) 的CPU：

  - 如果内核在EL1级别启动并且存在EL2：

    - HCRX_EL2.MSCEn（第11位）必须初始化为0b1
对于具有扩展的转换控制寄存器特性 (FEAT_TCR2) 的CPU：

  - 如果存在EL3：

    - SCR_EL3.TCR2En（第43位）必须初始化为0b1
- 如果内核在EL1级别启动并且存在EL2：

    - HCRX_EL2.TCR2En（第14位）必须初始化为0b1
对于具有第一级权限间接扩展特性 (FEAT_S1PIE) 的CPU：

  - 如果存在EL3：

    - SCR_EL3.PIEn（第45位）必须初始化为0b1
- 如果内核在EL1级别启动并且存在EL2：

    - HFGRTR_EL2.nPIR_EL1（第58位）必须初始化为0b1
- HFGWTR_EL2.nPIR_EL1（第58位）必须初始化为0b1
- HFGRTR_EL2.nPIRE0_EL1（第57位）必须初始化为0b1
- HFGRWR_EL2.nPIRE0_EL1（第57位）必须初始化为0b1
上述对CPU模式、缓存、MMU（存储管理单元）、架构定时器、一致性及系统寄存器的要求适用于所有CPU。所有CPU必须以相同的异常级别进入内核。在文档中所列出的值禁用陷阱的情况下，允许这些陷阱被启用，只要这些陷阱能被更高异常级别的处理器透明地处理，就好像设置了文档中的值一样。

启动加载器预期按照以下方式在每个CPU上进入内核：

- 主CPU必须直接跳转到内核映像的第一条指令。由该CPU传递的设备树块必须包含每个CPU节点的“enable-method”属性。支持的启用方法如下所述。
预计启动加载器将在进入内核之前生成这些设备树属性并将其插入到块中。
- 对于具有“spin-table”启用方法的CPU，其CPU节点中必须有一个“cpu-release-addr”属性。此属性标识一个自然对齐的64位零初始化内存位置。
这些CPU应该在内存的一个预留区域（通过设备树中的/memreserve/区域与内核通信）外部循环等待，轮询它们的cpu-release-addr位置，该位置必须位于预留区域内。可以插入wfe指令来降低忙等循环的开销，并且主CPU将发出sev指令。当读取由cpu-release-addr指向的位置返回非零值时，CPU必须跳转到该值。该值将以单个64位小端序的形式写入，因此CPU在跳转前必须将读取的值转换为本机字节序。
- 具有“psci”启用方法的CPU应保持在内核之外（即，在描述给内核的内存节点区域之外，或在通过设备树中的/memreserve/区域描述给内核的预留内存区域）。内核将按照ARM文档编号ARM DEN 0022A（《ARM处理器上的电源状态协调接口系统软件》）中描述的方式发出CPU_ON调用来将CPU带入内核。
设备树中应包含一个“psci”节点，如Documentation/devicetree/bindings/arm/psci.yaml中所述。
- 次级CPU通用寄存器设置

  - x0 = 0 （为将来使用保留）
  - x1 = 0 （为将来使用保留）
  - x2 = 0 （为将来使用保留）
  - x3 = 0 （为将来使用保留）
