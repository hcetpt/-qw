=======================
ARM64 平台上的 crashkernel 内存预留
=======================

作者：何宝全 <bhe@redhat.com>

Kdump 机制用于捕获损坏的内核 vmcore，以便后续分析。为了实现这一点，需要预先预留内存来预加载 kdump 内核，并在发生故障时启动该内核。
预留的内存被适配以最小限度地容纳 kdump 内核和收集 vmcore 所需的用户空间程序。

内核参数
================

通过以下内核参数，在首次启动内核的早期阶段可以相应地预留内存，从而找到连续的大块内存。如果从高地址区域预留 crashkernel，则需要考虑低地址内存预留：
- crashkernel=size@offset
- crashkernel=size
- crashkernel=size,high crashkernel=size,low

低地址内存与高地址内存
==========================

对于 kdump 预留来说，低地址内存是指特定限制以下的内存区域，通常由 kdump 内核运行所需的 DMA 能力设备的可访问地址位决定。与 vmcore 倾倒无关的那些设备可以忽略。在 ARM64 架构上，低地址内存的上限不是固定的：在 RPi4 平台上是 1GB，而在大多数其他系统上则是 4GB。
对于禁用 CONFIG_ZONE_(DMA|DMA32) 配置的特殊内核构建而言，整个系统 RAM 被视为低地址内存。除了上述低地址内存之外，其余的系统 RAM 被认为是高地址内存。

实现
==============

1) crashkernel=size@offset
--------------------------

crashkernel 内存必须在用户指定的区域预留，或者如果已经被占用则失败。

2) crashkernel=size
-------------------

crashkernel 内存区域将根据搜索顺序在任何可用位置预留：

首先，内核会在低地址内存区域中寻找具有指定大小的可用区域。
如果在低地址内存搜索失败，内核会退回到高地址内存区域中寻找具有指定大小的可用区域。如果在高地址内存中的预留成功，那么还会在低地址内存中做一个默认大小的预留。目前默认大小为 128MB，足以满足 kdump 内核对低地址内存的需求。
注意：crashkernel=size 是推荐的 crashkernel 内核预留选项。用户无需了解特定平台的系统内存布局。

3) crashkernel=size,high crashkernel=size,low
---------------------------------------------

crashkernel=size,(high|low) 是 crashkernel=size 的重要补充。它们允许用户分别指定从高地址内存和低地址内存中分配多少内存。在许多系统上，低地址内存非常宝贵，应尽量减少从该区域进行的 crashkernel 预留。
为了在 `crashkernel=size,high` 中预留内存，首先会尝试从高端内存区域进行搜索。如果预留成功，则随后会在低端内存中进行预留。
如果在高端内存中的预留失败，内核将退回到使用 `crashkernel=,high` 中指定的大小在低端内存中进行搜索。
如果成功，不再需要为低端内存进行进一步的预留。
注意事项：

- 如果没有指定 `crashkernel=,low`，默认的低端内存预留将自动完成。
- 如果指定了 `crashkernel=0,low`，这意味着有意省略低端内存的预留。
