标题：非对称32位SoC
================================

作者: Will Deacon <will@kernel.org>

本文档描述了非对称32位SoC对执行32位（`AArch32`）应用程序的影响。
日期：2021-05-17

介绍
=============

一些Armv9 SoC存在着一个不理想的大核小核特性，即只有部分CPU能够运行32位用户应用程序。在这样的系统上，默认情况下Linux将其不对称性视为“不匹配”，禁用对`PER_LINUX32`人格以及32位ELF二进制文件`execve(2)`的支持，后者返回`-ENOEXEC`。如果在64位专用CPU的后期上线过程中检测到这种不匹配，则上线操作会失败，新的CPU将无法用于调度。

令人惊讶的是，这些SoC被设计为运行遗留32位二进制文件。不出所料，这与Linux默认行为不太兼容。

似乎未来的SoC将完全放弃32位支持，因此如果你不幸需要在这些过渡平台上运行32位代码，那么明智的做法是考虑诸如重新编译、模拟或退役等替代方案。如果这些选项都不实际，那么请继续阅读。

启用内核支持
=======================

由于内核支持并非对用户空间完全透明，允许32位任务在非对称32位系统上运行需要显式“选择加入”，可以通过在内核命令行中传递`allow_mismatched_32bit_el0`参数来启用。

本文档的其余部分中，我们将把*非对称系统*定义为运行带有此内核命令行选项的Linux的非对称32位SoC。

用户空间影响
================

在非对称系统上运行的32位任务的行为与在同构系统上大致相同，只是有一些关键差异与CPU亲和力相关。

sysfs
-----

能够运行32位任务的CPU子集在`/sys/devices/system/cpu/aarch32_el0`中描述，并在`Documentation/ABI/testing/sysfs-devices-system-cpu`中有进一步说明。

**注意：**当检测到这些CPU时，它们会被此文件列出，因此能够在运行时通过内核修改文件内容以反映后期上线的32位兼容CPU。一旦被列出，CPU就不会从文件中移除。

`execve(2)`
-------------

在同构系统上，任务的CPU亲和力会在`execve(2)`调用之间保持不变。在非对称系统上，这并不总是可行的，特别是在执行的新程序是32位，而亲和力掩码包含仅64位CPU的情况下。在这种情况下，内核确定新亲和力掩码的方式如下：

  1. 如果亲和力掩码中的32位兼容子集不为空，则亲和力限制在这个子集上，并保存旧的亲和力掩码。这个保存的掩码将在`fork(2)`中被继承并在32位程序的`execve(2)`调用间保持不变。
**注释：**此步骤不适用于``SCHED_DEADLINE``任务。请参阅 `SCHED_DEADLINE`_。
1. 否则，将遍历任务的cpuset层级结构，直到找到至少包含一个32位兼容CPU的祖先。然后将任务的亲和性更改为与通过遍历确定的cpuset中的32位兼容子集相匹配。
2. 如果失败（即内存不足），则将亲和性更改为内核所知的所有32位兼容CPU的集合。
随后由32位任务执行的64位程序的``execve(2)``操作会使得在(1)中保存的亲和性掩码失效，并尝试使用之前有效的保存掩码恢复任务的CPU亲和性。
由于对deadline策略或cpuset层级结构的中间变更，这种恢复可能会失败，在这种情况下，``execve(2)``操作将继续进行，亲和性保持不变。
对于32位任务调用的``sched_setaffinity(2)``仅考虑请求的亲和性掩码中的32位兼容CPU。如果成功，则更新该任务的亲和性，并使任何先前``execve(2)``保存的掩码失效。
``SCHED_DEADLINE``
------------------

在一个不对称的32位系统上，明确允许32位deadline任务进入默认的根域（例如，通过调用``sched_setattr(2)``）将在不对称32位系统上被拒绝，除非通过向``/proc/sys/kernel/sched_rt_runtime_us``写入-1来禁用准入控制。
从64位deadline任务执行32位程序的``execve(2)``如果该任务的根域包含任何仅支持64位的CPU并且准入控制已启用，则将返回``-ENOEXEC``。32位兼容CPU的同时下线仍可能需要执行`execve(2)`_中描述的过程，在这种情况下，将跳过步骤(1)，并在控制台上发出警告。

**注释：**建议如果要在不对称系统上使用``SCHED_DEADLINE``与32位任务，应将一组32位兼容的CPU置于单独的根域中。否则很可能会导致错过最后期限。
### Cpusets

在不对称系统中，32位任务的亲和性可能包括其所属cpuset明确不允许的CPU。
这种情况可能由以下两种情况导致：

  - 一个附属于只允许64位CPU的cpuset的64位任务执行了一个32位程序；
- 包含32位任务的cpuset所允许的所有能够运行32位任务的CPU都被离线了；
在这两种情况下，新的亲和性根据`execve(2)`_中描述的过程中的步骤(2)来计算，并且无论cgroup版本如何，cpuset层次结构保持不变。

### CPU热插拔

在不对称系统中，首次检测到的能够运行32位任务的CPU被禁止由用户空间将其离线，任何尝试离线该CPU的操作将返回`-EPERM`。需要注意的是，即使主CPU（即CPU 0）仅支持64位，挂起操作仍然是允许的。

### KVM

尽管KVM不会向不对称系统上的任何虚拟CPU（vCPU）宣传32位EL0的支持，但在EL1上存在故障的客户机仍可能试图以32位模式执行代码。在这种情况下，处于32位模式下的vCPU线程退出时，将以`KVM_EXIT_FAIL_ENTRY`作为`exit_reason`返回给主机用户空间，并保持不可运行状态，直到通过后续的`KVM_ARM_VCPU_INIT`操作成功重新初始化为止。
