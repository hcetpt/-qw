===================
遗留指令
===================

Linux 内核的 arm64 端口提供了基础设施来支持已被废弃或在架构中过时的指令的仿真。该基础设施代码使用未定义指令的钩子来支持仿真。在可用的情况下，它还允许在硬件中开启指令执行。
通过写入 sysctl 节点（/proc/sys/abi）可以控制仿真模式。以下解释了不同的执行行为及其对应的 sysctl 节点值：

* 未定义 (Undef)
    值：0

  生成未定义指令异常。对于在架构中已过时的指令，默认行为，例如 SWP。

* 仿真 (Emulate)
    值：1

  使用软件仿真。为了帮助软件迁移，在此模式下会跟踪被仿真的指令的使用，并发出限速警告。这是对已废弃指令的默认行为，例如 CP15 屏障。

* 硬件执行 (Hardware Execution)
    值：2

  尽管已被标记为废弃，某些实现可能支持这些指令的硬件执行的支持启用/禁用。使用硬件执行通常能提供更好的性能，但会失去收集废弃指令运行时统计信息的能力。
默认模式取决于指令在架构中的状态。已废弃的指令应默认为仿真模式，而过时的指令必须默认为未定义模式。
注意：并非所有情况下都能进行指令仿真。请参阅各个指令的说明以获取更多信息。
支持的遗留指令
-----------------

* SWP{B}

:节点: /proc/sys/abi/swp
:状态: 过时
:默认: 未定义 (0)

* CP15 屏障

:节点: /proc/sys/abi/cp15_barrier
:状态: 已废弃
:默认: 仿真 (1)

* SETEND

:节点: /proc/sys/abi/setend
:状态: 已废弃
:默认: 仿真 (1)*

  注意: 系统上的所有 CPU 在 EL0 上都必须支持混合字节序才能启用此功能。如果在此功能启用后热插拔了一个不支持混合字节序的新 CPU，则应用程序可能会出现意外结果。
