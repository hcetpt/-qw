### SPDX 许可证标识符：GPL-2.0

#### 在用户空间应用程序中使用 FS 和 GS 段
====================================

x86 架构支持分段。访问内存的指令可以使用基于段寄存器的寻址模式。以下表示法用于在段内寻址一个字节：

  Segment-register:Byte-address

将段基地址加到 Byte-address 上以计算要访问的结果虚拟地址。这允许使用相同的 Byte-address（即相同的代码）访问多个数据实例。选择特定实例完全基于段寄存器中的基地址。
在 32 位模式下，CPU 提供 6 个段，这些段也支持段限制。这些限制可用于强制执行地址空间保护。
在 64 位模式下，CS/SS/DS/ES 段被忽略，并且基地址始终为 0 以提供完整的 64 位地址空间。FS 和 GS 段在 64 位模式下仍然可用。
##### 常见的 FS 和 GS 使用
--------------------------

FS 段通常用于寻址线程本地存储（TLS）。FS 通常由运行时代码或线程库管理。使用 '__thread' 存储类指定符声明的变量按线程实例化，并且编译器会为访问这些变量发出 FS: 地址前缀。每个线程都有自己的 FS 基地址，因此可以使用通用代码而无需复杂的地址偏移计算来访问每个线程的实例。当应用程序使用管理每个线程 FS 的运行时或线程库时，不应将 FS 用于其他目的。
GS 段没有常见的用途，可以由应用程序自由使用。GCC 和 Clang 支持通过地址空间标识符进行 GS 基于地址的寻址。
##### 读取和写入 FS/GS 基地址
------------------------------------------

有两种机制来读取和写入 FS/GS 基地址：

- arch_prctl() 系统调用

- FSGSBASE 指令家族

#### 通过 arch_prctl() 访问 FS/GS 基地址
--------------------------------------

基于 arch_prctl(2) 的机制在所有 64 位 CPU 和所有内核版本上都可用。
读取基地址：

   arch_prctl(ARCH_GET_FS, &fsbase);
   arch_prctl(ARCH_GET_GS, &gsbase);

写入基地址：

   arch_prctl(ARCH_SET_FS, fsbase);
   arch_prctl(ARCH_SET_GS, gsbase);

ARCH_SET_GS prctl 可能根据内核配置和安全设置被禁用。
#### 通过 FSGSBASE 指令访问 FS/GS 基地址
----------------------------------------

从 Ivy Bridge CPU 一代开始，Intel 引入了一组新的指令，可以直接从用户空间访问 FS 和 GS 基寄存器。这些指令也在 AMD Family 17H CPU 上得到支持。以下指令可用：

  =============== ===========================
  RDFSBASE %reg   读取 FS 基寄存器
  RDGSBASE %reg   读取 GS 基寄存器
  WRFSBASE %reg   写入 FS 基寄存器
  WRGSBASE %reg   写入 GS 基寄存器
  =============== ===========================

这些指令避免了 arch_prctl() 系统调用的开销，并允许用户空间应用程序更灵活地使用 FS/GS 寻址模式。但这并不能防止线程库和运行时之间产生冲突，这些库利用了 FS，同时应用程序又想将其用于自己的目的。
##### FSGSBASE 指令启用
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
这些指令在 CPUID 叶子 7 的 EBX 寄存器第 0 位中枚举。如果可用，则 /proc/cpuinfo 中的 CPU 标志条目中会显示 'fsgsbase'。

指令的可用性并不会自动启用它们。内核必须在 CR4 中显式启用它们。这样做的原因是较旧的内核对 GS 寄存器中的值做出了一些假设，并且当通过 arch_prctl() 设置 GS 基地址时会强制执行这些假设。允许用户空间向 GS 基地址写入任意值将违反这些假设并导致功能故障。
在那些未启用FSGSBASE的内核上，执行FSGSBASE指令将因未定义指令(#UD)异常而失败。
内核在ELF AUX向量中提供了关于启用状态的可靠信息。如果AUX向量中的HWCAP2_FSGSBASE位被设置，则表示内核已启用了FSGSBASE指令，应用程序可以使用它们。
下面的代码示例展示了这种检测是如何工作的：

   #include <sys/auxv.h>
   #include <elf.h>

   /* 最终会放在 asm/hwcap.h 中 */
   #ifndef HWCAP2_FSGSBASE
   #define HWCAP2_FSGSBASE        (1 << 1)
   #endif

   ...
unsigned val = getauxval(AT_HWCAP2);

   if (val & HWCAP2_FSGSBASE)
        printf("FSGSBASE 已启用\n");

FSGSBASE指令的编译器支持
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

GCC版本4.6.4及更高版本提供了FSGSBASE指令的内置函数。Clang 5也支持这些内置函数。

=================== ===========================
  _readfsbase_u64()   读取FS基寄存器
  _readgsbase_u64()   读取GS基寄存器
  _writefsbase_u64()  写入FS基寄存器
  _writegsbase_u64()  写入GS基寄存器
  =================== ===========================

要利用这些内置函数，必须在源代码中包含<immintrin.h>，并且需要添加编译器选项-mfsgsbase。

基于FS/GS寻址的编译器支持
-------------------------------------------

GCC版本6及更高版本通过命名地址空间提供了对基于FS/GS寻址的支持。GCC为x86实现了以下地址空间标识符：

  ========= ====================================
  __seg_fs  变量相对于FS进行寻址
  __seg_gs  变量相对于GS进行寻址
  ========= ====================================

当支持这些地址空间时，预处理器符号__SEG_FS和__SEG_GS会被定义。实现回退模式的代码应该检查这些符号是否被定义。使用示例：

  #ifdef __SEG_GS

  long data0 = 0;
  long data1 = 1;

  long __seg_gs *ptr;

  /* 检查内核是否启用了FSGSBASE (HWCAP2_FSGSBASE) */
  ...
/* 设置GS基寄存器指向data0 */
  _writegsbase_u64(&data0);

  /* 访问GS的偏移0 */
  ptr = 0;
  printf("data0 = %ld\n", *ptr);

  /* 设置GS基寄存器指向data1 */
  _writegsbase_u64(&data1);
  /* ptr仍然访问偏移0! */
  printf("data1 = %ld\n", *ptr);

Clang不提供GCC的地址空间标识符，但在Clang 2.6及更高版本中，它通过基于属性的机制提供了地址空间：

 ==================================== =====================================
  __attribute__((address_space(256))  变量相对于GS进行寻址
  __attribute__((address_space(257))  变量相对于FS进行寻址
 ==================================== =====================================

使用内联汇编进行基于FS/GS的寻址
-------------------------------------------

如果编译器不支持地址空间，可以使用内联汇编来进行基于FS/GS的寻址模式：

```
mov %fs:offset, %reg
mov %gs:offset, %reg

mov %reg, %fs:offset
mov %reg, %gs:offset
```
