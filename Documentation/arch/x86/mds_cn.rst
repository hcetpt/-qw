### 微架构数据采样（MDS）缓解措施

#### .. _mds:

##### 概览

微架构数据采样（MDS）是一类针对Intel CPU内部缓冲区的侧信道攻击。其变体包括：

- 微架构存储缓冲数据采样（MSBDS）(CVE-2018-12126)
- 微架构填充缓冲数据采样（MFBDS）(CVE-2018-12130)
- 微架构加载端口数据采样（MLPDS）(CVE-2018-12127)
- 微架构数据采样不可缓存内存（MDSUM）(CVE-2019-11091)

MSBDS会导致存储缓冲条目的泄露，这些条目可以被投机性地转发到依赖的加载操作（存储至加载转发），作为优化手段。该转发也可以发生在一个故障或辅助加载操作中，针对不同的内存地址，在某些条件下可被利用。存储缓冲区在超线程之间是隔离的，因此跨线程转发是不可能的。但是，如果一个线程进入或退出睡眠状态，存储缓冲区会被重新分配，这可能会使一个线程的数据暴露给另一个线程。

MFBDS会导致填充缓冲条目的泄露。填充缓冲区用于管理L1缺失情况，并保存响应内存或I/O操作返回或发送的数据。填充缓冲区可以将数据转发给加载操作，也可以将数据写入缓存。当填充缓冲区被释放时，它可能保留先前操作的陈旧数据，然后这些数据可以被转发到故障或辅助加载操作，从而在某些条件下被利用。填充缓冲区在超线程之间共享，因此可能发生跨线程泄漏。

MLPDS会导致加载端口数据的泄露。加载端口用于执行从内存或I/O的加载操作。接收到的数据随后会被转发到寄存器文件或后续操作。在某些实现中，加载端口可能包含来自前一个操作的陈旧数据，在某些条件下这些数据可以被转发到故障或辅助加载操作，进而可能被最终利用。加载端口在超线程之间共享，因此可能发生跨线程泄漏。

MDSUM是MSBDS、MFBDS和MLPDS的一种特殊情况。从内存进行不可缓存的加载，如果发生故障或辅助操作，可能会在微架构结构中留下数据，稍后可以通过与MSBDS、MFBDS或MLPDS相同的方法观察到。

##### 暴露假设

假设攻击代码位于用户空间或来宾中，但有一个例外。做出这一假设的理由是，利用MDS所需的代码构造需要：

- 控制触发故障或辅助的加载操作。
- 拥有一个披露小工具，通过侧信道暴露投机访问的数据以供消费。
- 控制披露小工具暴露数据所使用的指针。

不能完全排除内核中存在此类构造的可能性，但涉及的复杂性使其极为不可能。
有一个例外，即不可信任的BPF（Berkeley Packet Filter）。虽然不可信任的BPF功能有限，但仍需彻底调查是否可以用它来创建此类构造。

##### 缓解策略

所有变体对于单CPU线程案例（关闭SMT）都有相同的缓解策略：强制CPU清除受影响的缓冲区。
这是通过结合微码更新使用原本未使用且已过时的VERW指令实现的。微码会在执行VERW指令时清除受影响的CPU缓冲区。

对于虚拟化，有两种方法可以实现CPU缓冲区的清除。一种是修改后的VERW指令，另一种是通过L1D Flush命令。当启用L1TF缓解措施时会发出后者，因此可以避免额外的VERW。如果CPU不受L1TF影响，则需要发出VERW指令。
如果带有提供的段选择符参数的VERW指令在没有微码更新的CPU上执行，则除了浪费少量无意义的CPU周期外，没有其他副作用。
这并不能防止跨超线程攻击，除非是针对MSBDS的情况，而MSBDS仅在其中一个超线程进入C状态时才可能被跨超线程利用。
内核提供了一个用于调用缓冲区清除的函数：

    mds_clear_cpu_buffers()

此外，在退出到用户空间路径末尾的汇编代码中也可以使用CLEAR_CPU_BUFFERS宏。
除了CFLAGS.ZF之外，此宏不会影响任何寄存器。
缓解措施会在内核/用户空间、虚拟机监视器/客户机以及C状态（空闲）转换时被调用。
为了解决虚拟化场景中的特殊情况，即主机已更新了微码，但虚拟机监视器尚未（或暂未）向客户机暴露MD_CLEAR的CPUID位，内核会发出VERW指令，希望它能实际清空缓冲区。相应的状态也会得到反映。
根据当前的知识，内核本身不需要额外的缓解措施，因为无法以一种可以被恶意用户空间或VM客户机利用的方式控制必要的小工具来暴露泄露的数据。
内核内部缓解模式
-------------------

 ======= ============================================================
 off      缓解措施被禁用。要么CPU不受影响，要么在内核命令行中提供了mds=off

 full     启用了缓解措施。CPU受到影响，并且在CPUID中宣传了MD_CLEAR

 vmwerv   启用了缓解措施。CPU受到影响，但在CPUID中并未宣传MD_CLEAR。这主要是为了虚拟化场景设计的，其中主机已更新了微码，但虚拟机监视器并未在CPUID中暴露MD_CLEAR。这是一种尽力而为的方法，不保证一定能成功
 ======= ============================================================

如果CPU受到影响，并且内核命令行中没有提供mds=off，则内核将根据MD_CLEAR CPUID位的可用性选择适当的缓解模式。
缓解措施要点
--------------

1. 返回用户空间
^^^^^^^^^^^^^^^^^^^^^^^

   当从内核空间转换到用户空间时，如果内核命令行没有禁用缓解措施，则受影响的CPU上的CPU缓冲区会被清空。该缓解措施是通过特性标志X86_FEATURE_CLEAR_CPU_BUF启用的。
该缓解措施在恢复用户寄存器后、即将转换到用户空间前被调用。这样做是为了尽量减少VERW之后内核数据可能被访问的时间窗口，例如，通过VERW之后的NMI。
**未处理的特殊情况**
   返回内核的中断不会清除CPU缓冲区，因为预期退出到用户空间的路径已经完成了这一操作。但是，在退出到用户空间路径已清除缓冲区之后，内核中可能会产生一个NMI。这种情况并未得到处理，并且返回内核的NMI不会清除CPU缓冲区，原因如下：

   1. 在VERW之后但返回用户空间之前获得NMI的情况很少见。
2. 对于非特权用户来说，目前尚无已知方法使此类NMI变得更常见或进行针对性攻击。
3. 要发起实际攻击，需要大量精确计时的NMI，而这似乎带宽不足。
4. 问题中的NMI发生在VERW之后，即用户状态已恢复且大多数有趣的数据已被清除之时。剩下的只是NMI会触及的数据，这些数据可能并非具有任何兴趣。
2. C-State转换
^^^^^^^^^^^^^^^^^^^^^

   当CPU处于空闲状态并进入C-State时，如果同时多线程（SMT）处于活动状态，则需要清除受影响CPU上的CPU缓冲区。这解决了当其中一个超线程进入C-State时存储缓冲区重新分配的问题。
当SMT处于非活动状态，即CPU不支持SMT或者所有兄弟线程都已离线时，无需清除CPU缓冲区。
仅受MSBDS影响而未受其他MDS变体影响的CPU上启用了空闲清除功能。其他MDS变体无法防止跨超线程攻击，因为填充缓冲区和加载端口是共享的。因此，在受其他变体影响的CPU上，空闲清除将是一种表面工作，并因此未被激活。
该调用由静态键mds_idle_clear控制，根据选择的缓解模式和系统的SMT状态切换此键。
缓冲区清除仅在进入C状态之前被调用，以防止空闲CPU中的陈旧数据在存储缓冲区重新分配且所有条目对非空闲的兄弟线程可用之后泄露到超线程兄弟线程。
从空闲状态恢复时，存储缓冲区再次被分割，这样每个兄弟线程都可以使用其中的一半。因此，从空闲状态返回的CPU可能会推测性地接触到兄弟线程的内容。这些缓冲区会在退出到用户空间或进行VMENTER操作时被刷新，从而防止用户空间中的恶意代码或客户操作系统中的恶意代码进行推测性访问。
缓解措施已经集成到了所有版本的halt()/mwait()中，但并未覆盖传统的ACPI I/O端口机制，因为大约在2010年左右，ACPI空闲驱动已经被intel_idle驱动所取代，并且在所有预期会通过微码更新获得MD_CLEAR功能的受影响CPU上被优先使用。除此之外，I/O端口机制是一个遗留接口，只在较老的系统中使用，而这些系统要么不受影响，要么不再接收微码更新。
