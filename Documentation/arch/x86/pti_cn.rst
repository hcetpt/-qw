SPDX 许可证标识符: GPL-2.0

==========================
页表隔离 (PTI)
==========================

概述
========

页表隔离 (pti，以前称为 KAISER [1]_) 是一种针对共享用户/内核地址空间的攻击（如“Meltdown”方法 [2]_）的对策。为了缓解这类攻击，我们为运行用户空间应用程序时创建了一组独立的页表。当通过系统调用、中断或异常进入内核时，切换到完整的“内核”副本页表。当系统返回用户模式时，再次使用用户副本。用户空间页表仅包含少量内核数据：即进入/退出内核所需的那些，比如进入/退出函数本身以及中断描述符表 (IDT)。有一些严格来说不必要的内容也被映射了，例如进入中断的第一个 C 函数（参见 pti.c 中的注释）。这种方法有助于确保在启用 PTI 的情况下，利用页结构的旁路攻击无法起作用。它可以通过在编译时将 CONFIG_MITIGATION_PAGE_TABLE_ISOLATION 设置为 y 来启用。一旦在编译时启用，可以在启动时通过 'nopti' 或 'pti=' 内核参数禁用（参见 kernel-parameters.txt）。
页表管理
=====================

当 PTI 启用时，内核管理两组页表。第一组与没有 PTI 的内核中的单一组非常相似。这包括内核可以用于像 copy_to_user() 这样的操作的用户空间完整映射。尽管是_完整的_，但用户部分的内核页表通过在顶级设置 NX 位而受到限制。这样可以确保任何遗漏的内核->用户 CR3 切换会立即导致用户空间在其执行第一条指令时崩溃。用户空间页表仅映射进入和退出内核所需的内核数据。这些数据完全包含在 'struct cpu_entry_area' 结构中，该结构被放置在固定映射中，这为每个 CPU 的该区域副本提供了一个编译时固定的虚拟地址。对于新的用户空间映射，内核像往常一样在其页表中做条目。唯一的区别是在内核在顶级 (PGD) 层制作条目时。除了在主内核 PGD 中设置条目外，还在用户空间页表的 PGD 中复制一个条目。这种在 PGD 层面的共享还内在地共享所有较低层的页表。这就留下了一组单一共享的用户空间页表来管理。锁定一个 PTE，一组访问位，脏位等。
开销
=====

针对侧信道攻击的防护非常重要。但是，
这种防护是有代价的：

1. 增加内存使用

  a. 每个进程现在需要一级页全局目录(PGD)而不是零级
(每个进程额外消耗大约 4KB)
b. `cpu_entry_area` 结构必须为 2MB 大小且对齐到 2MB，以便通过设置单一的页中间目录(PMD)条目来映射。这在内核解压缩后会消耗近 2MB 的 RAM，但不会占用内核镜像本身的任何空间
2. 运行时成本

  a. 在切换页表副本时需要操纵 CR3，这必须在中断、系统调用和异常的进入与退出时进行（当内核被中断时可以省略）。向 CR3 的写入操作大约需要一百个周期，并且每次进入和退出都需要执行。
b. 每个CPU的 TSS 被映射到用户空间页表中以使 SYSCALL64 路径在 PTI 下工作。这没有直接的运行时成本，但可以说它打开了某些时间攻击场景的可能性
c. 对于所有未同时映射到内核空间和用户空间页表中的内核结构，禁用了全局页面。MMU 的这一特性允许不同的进程共享内核映射的 TLB 条目。失去这一特性意味着上下文切换后会有更多的 TLB 缺失。然而，实际性能损失非常小，从不超过 1%
d. 进程上下文标识符 (PCID) 是 CPU 的一个特性，它允许我们在切换页表时（通过在修改页表时在 CR3 中设置一个特殊位）避免刷新整个 TLB。这使得在上下文切换或内核进出时切换页表更便宜。但是，在支持 PCID 的系统上，上下文切换代码必须将用户和内核条目都从 TLB 中刷新出去。用户 PCID TLB 刷新被延迟到返回用户空间时进行，以最小化成本。请参阅 intel.com/sdm 获取关于 PCID/INVPCID 的详细信息
e. 必须为每个新进程填充用户空间页表。即使没有 PTI，共享内核映射也是通过将顶层 (PGD) 条目复制到每个新进程中创建的。但是，在 PTI 下，现在有两个内核映射：一个在内核页表中映射所有内容，另一个用于入口/出口结构。在 fork() 时，我们需要复制两者
f. 除了在 fork() 时复制外，每当对用于映射用户空间的 PGD 执行 set_pgd() 时，还必须更新用户空间 PGD。这确保了内核和用户空间的副本始终映射相同的用户空间内存
g. 在没有PCID支持的系统上，每次CR3写操作都会刷新整个TLB。这意味着每次系统调用、中断或异常都会导致TLB被刷新。
h. INVPCID是一条用于刷新TLB的指令，它允许刷新非当前PCID的TLB项。有些系统支持PCID但不支持INVPCID。在这些系统上，只能从TLB中刷新当前PCID的地址。当我们需要刷新内核地址时，必须刷新所有PCID，因此单次内核地址刷新会在下次使用每个PCID时都需要执行一次TLB刷新的CR3写操作。

可能的未来工作
=================
1. 我们可以在实际改变CR3值的情况下才进行写入操作，以此来更加谨慎地处理。
2. 允许在运行时启用/禁用PTI，而不仅限于启动时切换。

测试
======
为了测试PTI的稳定性，建议采用以下测试程序，理想情况下应同时执行所有这些步骤：

1. 设置CONFIG_DEBUG_ENTRY=y。
2. 在多个CPU上循环运行所有工具/测试/selftests/x86/测试（排除MPX和protection_keys）几分钟。这些测试经常能发现内核入口代码中的边缘情况。通常，旧版本的内核可能会使这些测试本身崩溃，但它们不应该使内核崩溃。
3. 以一种会生成许多频繁性能监控不可屏蔽中断（参见"/proc/interrupts"中的"NMI"）的方式运行"perf"工具（如top或record模式）。这可以测试NMI的入口/出口代码，该代码已知会触发那些未预料到会被中断的代码路径中的错误，包括嵌套NMI。使用"-c"可以提高NMI的频率，而使用两个-c与不同的计数器则鼓励产生嵌套NMI和更不确定的行为。
   ::
   
      while true; do perf record -c 10000 -e instructions,cycles -a sleep 10; done

4. 启动一个KVM虚拟机。
5. 在支持SYSCALL指令的系统上运行32位二进制文件。这是一个测试较少的代码路径，需要额外的关注。

调试
=======
PTI中的bug会导致几种不同类型的崩溃现象，值得在此处特别指出。
* 自检/x86代码的失败。通常是一个在`entry_64.S`较为晦涩角落中的bug。
* 在早期启动时崩溃，特别是在CPU启动过程中。这些崩溃由映射中的bug引起。
* 在第一个中断时崩溃。由`entry_64.S`中的bug导致，例如错误地切换页表。也可能是因为错误地映射了中断请求（IRQ）处理程序入口代码。
* 在第一个不可屏蔽中断（NMI）时崩溃。NMI代码与主要的中断处理器是分开的，可能存在不影响正常中断的bug。同样可能是因为错误地映射了NMI代码。中断进入点代码的NMI必须非常小心，可能是运行`perf`时出现崩溃的原因。
* 在第一次退出到用户空间时内核崩溃。可能是`entry_64.S`中的bug，或者未能映射部分退出代码。
* 在第一个中断用户空间的中断时崩溃。`entry_64.S`中返回到用户空间的路径有时与返回到内核的路径是分开的。
* 双重故障：由于页错误引发页错误而导致内核栈溢出。可能是由于在入口代码中访问非pti映射的数据，或者忘记在调用非pti映射的C函数之前切换到内核CR3所导致。
* 在启动早期用户空间段错误，有时表现为`mount(8)`无法挂载根文件系统。这些问题往往是TLB无效化问题。通常是无效化了错误的PCID，或者遗漏了某个无效化操作。
  
  .. [1] https://gruss.cc/files/kaiser.pdf
  .. [2] https://meltdownattack.com/meltdown.pdf
