... SPDX 许可证标识符: GPL-2.0

=================
x86 特性标志
=================

介绍
============

/proc/cpuinfo 中的特性标志列表并不完整，它代表了很久以前一次不幸的尝试，试图将特性标志置于用户空间易于查找的位置。然而，随着每一代 CPU 的出现，特性的数量在不断增长，导致 /proc/cpuinfo 文件变得难以解析和难以管理。更重要的是，这些特性标志甚至不必出现在该文件中，因为用户空间并不关心它们——glibc 等库已经使用 CPUID 来确定目标机器支持哪些功能以及不支持哪些功能。即使 /proc/cpuinfo 中没有显示某个特定的特性标志——尽管 CPU 仍然支持相应的硬件功能并且该 CPU 支持 CPUID 故障——用户空间也可以简单地探测该特性以判断是否支持它，无论它是否被公开宣传过。此外，一旦这些标志字符串出现在那里，它们就成为了一种应用程序二进制接口 (ABI)，当没有任何东西使用它们时永远维护它们是一项巨大的浪费。因此，/proc/cpuinfo 当前的用途是展示内核已启用和支持的特性。也就是说：CPUID 特性标志在那里，内核在启动时已经完成了额外的设置，并且功能已经准备好使用。一个很好的例子就是 “user_shstk”，其中内核中有额外的代码启用以支持用户程序的影子栈。
因此，如果用户想知道给定系统上是否可用某个特性，他们会尝试在 /proc/cpuinfo 中找到该标志。如果给定的标志存在，则意味着：

* 内核对特性有足够的了解，以至于拥有一个 X86_FEATURE 位

* 内核支持它，并且当前正在向用户空间或内核的其他部分提供它

* 如果标志代表一个硬件特性，则硬件支持它
/proc/cpuinfo 中缺少某个标志本身对最终用户来说几乎没有任何意义。
一方面，像“vaes”这样的特性可能完全可供用户应用程序在一个未定义 X86_FEATURE_VAES 的内核上使用，因此在 /proc/cpuinfo 中没有“vaes”。
另一方面，在非 VAES 硬件上运行的新内核也将没有 “vaes” 在 /proc/cpuinfo 中。应用程序或用户无法区分这两种情况。
最终结果是，`/proc/cpuinfo` 中的 `flags` 字段对于内核调试来说有轻微的作用，但除此之外实际上并没有太多用途。应用程序应当使用像 glibc 提供的查询 CPU 支持的功能。用户应当依赖诸如 `tools/arch/x86/kcpuid` 和 `cpuid(1)` 这样的工具。

关于实现方面，在 `/proc/cpuinfo` 中出现的标志位在 `arch/x86/include/asm/cpufeatures.h` 中有一个对应的 `X86_FEATURE` 定义。这些标志位既代表硬件特性也代表软件特性。
如果内核关心某个特性或者 KVM 想要向 KVM 客户机暴露该特性，那么它只应在客户机需要解析 `/proc/cpuinfo` 时才暴露这个特性。正如上面提到的，这种情况非常不可能发生。KVM 可以合成 CPUID 位，而 KVM 客户机可以直接通过查询 CPUID 来确定虚拟化管理程序支持什么特性、不支持什么特性。正如已经指出的那样，`/proc/cpuinfo` 并不是用来倾倒无用特征标志位的地方。

特征标志是如何创建的？
==========================

a: 特征标志可以从 CPUID 叶子的内容中派生
--------------------------------------------------
这些特征定义按照 CPUID 叶子的布局组织，并且按照 `cpufeatures.h`（见 `arch/x86/include/asm/cpufeatures.h` 的详细信息）中的枚举 `cpuid_leafs` 分组到不同的字中。如果一个特征被定义为 `cpufeatures.h` 中的 `X86_FEATURE_<name>`，并且在运行时被检测到，相应的标志将在 `/proc/cpuinfo` 中显示出来。例如，“avx2” 标志来自 `cpufeatures.h` 中的 `X86_FEATURE_AVX2`。
b: 标志可以来自零散的基于 CPUID 的特性
----------------------------------------------------
在稀疏分布的 CPUID 叶子中列举的硬件特性会获得软件定义的值。然而，仍然需要通过查询 CPUID 来判断给定的特性是否存在。这是在 `init_scattered_cpuid_features()` 中完成的。例如，`X86_FEATURE_CQM_LLC` 被定义为 `11*32 + 0`，其存在与否会在运行时在相应的 CPUID 叶子 `[EAX=f, ECX=0]` 的 `EDX[1]` 位进行检查。
分散 CPUID 叶子的目的是为了避免不必要的膨胀 `struct cpuinfo_x86.x86_capability[]`。例如，CPUID 叶子 `[EAX=7, ECX=0]` 包含 30 个特性且密集，而 CPUID 叶子 `[EAX=7, EAX=1]` 只有一个特性，在 `x86_capability[]` 数组中会浪费 31 位的空间。由于每个可能的 CPU 都有一个 `struct cpuinfo_x86`，因此浪费的内存并非微不足道。

c: 在某些条件下可以合成创建标志以表示硬件特性
-------------------------------------------------------------------------------------
这些条件的例子包括某些特性是否出现在 MSR_IA32_CORE_CAPS 中或特定的 CPU 型号被识别。如果满足所需条件，则通过 `set_cpu_cap` 或 `setup_force_cpu_cap` 宏启用这些特性。例如，如果在 MSR_IA32_CORE_CAPS 中第 5 位被设置，那么将启用特性 `X86_FEATURE_SPLIT_LOCK_DETECT` 并显示 `"split_lock_detect"`。标志 `"ring3mwait"` 仅在运行于 INTEL_XEON_PHI_[KNL|KNM] 处理器上时才会显示。

d: 标志可以代表纯软件特性
------------------------------------------------
这些标志并不表示硬件特性。相反，它们代表了内核中实现的一个软件特性。例如，Kernel Page Table Isolation 是一个纯软件特性，并且其特征标志 `X86_FEATURE_PTI` 也在 cpufeatures.h 中定义。

标志命名规则
==============

脚本 `arch/x86/kernel/cpu/mkcapflags.sh` 处理来自 `cpufeatures.h` 的 `#define X86_FEATURE_<name>` 并生成 `kernel/cpu/capflags.c` 中的 `x86_cap/bug_flags[]` 数组。结果 `x86_cap/bug_flags[]` 中的名称用于填充 `/proc/cpuinfo`。`x86_cap/bug_flags[]` 中标志的命名规则如下：

a: 标志的名称默认来自 `X86_FEATURE_<name>` 中的字符串
----------------------------------------------------------------------------
默认情况下，`/proc/cpuinfo` 中的标志 `<name>` 从 `cpufeatures.h` 中相应的 `X86_FEATURE_<name>` 提取。例如，标志 `"avx2"` 来自 `X86_FEATURE_AVX2`。

b: 名称可以被覆盖
--------------------------------
如果 `#define X86_FEATURE_*` 行的注释以双引号字符 (`""`) 开始，那么双引号内的字符串将是标志的名称。例如，标志 `"sse4_1"` 来自跟随 `X86_FEATURE_XMM4_1` 定义之后的注释 `"sse4_1"`。
在某些情况下，需要覆盖标志显示的名称。例如，`/proc/cpuinfo` 是用户空间接口，必须保持不变。如果出于某种原因，`X86_FEATURE_<name>` 的命名发生变化，应该用已在 `/proc/cpuinfo` 中使用的名称来覆盖新的命名。
命名覆盖可以是""，这意味着它将不会出现在/proc/cpuinfo中。

如果该特性对用户空间暴露没有意义，则应从/proc/cpuinfo中省略。例如，X86_FEATURE_ALWAYS在cpufeatures.h中定义，但该标志是一个内核内部特性，用于备选运行时修补功能。因此，其名称被覆盖为""。这样，它的标志就不会出现在/proc/cpuinfo中。
当出现以下一种或多种情况时，标志会缺失：
###

a: 硬件未枚举对该特性的支持
-------------------------------
例如，在旧硬件上运行新内核或者该特性未通过启动固件启用。即使硬件较新，也可能存在运行时启用该特性的问题，此时标志将不会显示。
b: 内核不知道该标志
---------------------
例如，在新硬件上运行旧内核。
c: 内核在编译时禁用了对该特性的支持
---------------------------------------
例如，如果在构建时不启用5级分页（即，未选择CONFIG_X86_5LEVEL），则"la57"标志将不会出现[#f1]_。尽管通过CPUID仍能检测到该特性，但内核会通过setup_clear_cpu_cap(X86_FEATURE_LA57)清除标志来禁用它。
d: 该特性在启动时被禁用
-------------------------
可以通过命令行参数或因为特性未能启用而禁用某个特性。可以使用命令行参数 `clearcpuid=` 来根据 `/arch/x86/include/asm/cpufeatures.h` 中定义的特性编号来禁用特性。例如，可以使用 `clearcpuid=514` 禁用用户模式指令保护功能。数字 514 是从 `#define X86_FEATURE_UMIP (16*32 + 2)` 计算得出的。
此外，还存在各种自定义命令行参数来禁用特定的特性。这些参数包括但不限于 `nofsgsbase`, `nogxs`, `noxsave` 等。五级分页也可以通过 `"no5lvl"` 来禁用。
e: 该特性已知为非功能性
-------------------------
该特性已知为非功能性，因为在运行时缺少了依赖项。例如，如果禁用了 XSAVE 特性，AVX 标志将不会出现，因为它们依赖于 XSAVE 特性。另一个例子是故障 CPU 缺少微码补丁。由于这些原因，内核决定不启用某个特性。
.. [#f1] 五级分页使用的是 57 位线性地址。
