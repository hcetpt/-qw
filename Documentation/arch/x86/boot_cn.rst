... SPDX 许可证标识符: GPL-2.0

===========================
Linux/x86 启动协议
===========================

在 x86 平台上，Linux 内核使用了一个相当复杂的启动约定。这部分是由于历史因素，以及早期希望内核本身能够成为一个可启动映像的愿望，加上复杂的 PC 内存模型，以及由于主流操作系统实模式 DOS 的衰落所导致的 PC 行业期望的变化。
目前，以下版本的 Linux/x86 启动协议存在：

=============	============================================================================
旧内核	zImage/Image 支持仅此而已。一些非常早期的内核
		甚至可能不支持命令行
协议 2.00	(内核 1.3.73) 添加了 bzImage 和 initrd 支持，以及
		一个正式化的方式来实现引导加载程序和内核之间的通信。setup.S 变为可重定位，
		尽管传统的 setup 区域仍然假设为可写
协议 2.01	(内核 1.3.76) 添加了堆溢出警告
协议 2.02	(内核 2.4.0-test3-pre3) 新的命令行协议
降低常规内存上限。	不对传统 setup 区域进行覆盖，从而使得对于使用
		SMM 或 32 位 BIOS 入口点提供的 EBDA 的系统而言，启动过程安全。zImage 已废弃但仍然
		被支持
协议 2.03	(内核 2.4.18-pre1) 明确地将尽可能高的 initrd 地址提供给引导加载程序
协议 2.04	(内核 2.6.14) 将 syssize 字段扩展到四个字节
协议 2.05	(内核 2.6.20) 实现保护模式下内核的可重定位
引入了可重定位内核（`relocatable_kernel`）和内核对齐（`kernel_alignment`）字段。

协议 2.06 （内核 2.6.22） 添加了一个包含引导命令行大小的字段。

协议 2.07 （内核 2.6.24） 引入了半虚拟化启动协议。引入了硬件子架构（`hardware_subarch`）和硬件子架构数据（`hardware_subarch_data`），以及在`load_flags`中的`KEEP_SEGMENTS`标志。

协议 2.08 （内核 2.6.26） 添加了CRC32校验和及ELF格式的有效载荷。引入了`payload_offset`和`payload_length`字段以帮助定位有效载荷。

协议 2.09 （内核 2.6.26） 添加了一个指向单链表中`struct setup_data`的64位物理指针的字段。

协议 2.10 （内核 2.6.31） 添加了一个关于放宽对齐要求的协议，超出了原先添加的`kernel_alignment`，新增了`init_size`和`pref_address`字段。添加了扩展的启动加载器ID。

协议 2.11 （内核 3.6） 添加了一个用于EFI交接协议入口点偏移量的字段。

协议 2.12 （内核 3.8） 添加了`xloadflags`字段和结构体`boot_params`的扩展字段，用于在64位系统中高于4GB的位置加载bzImage和RAM磁盘。

协议 2.13 （内核 3.14） 支持在`xloadflags`中设置32位和64位标志，以支持从32位EFI引导64位内核。

协议 2.14 被错误提交烧毁
                ae7e1238e68f2a472a125673ab506d49158c1889
                ("x86/boot: 在setup_header中添加ACPI RSDP地址")
                不要使用！假设与2.13相同。
协议 2.15 (内核 5.5) 添加了 kernel_info 和 kernel_info.setup_type_max
=============	============================================================

  .. note::
     协议版本号仅在设置头发生更改时才应变更。如果 boot_params 或 kernel_info 发生变化，则无需更新版本号。此外，建议使用 xloadflags（在这种情况下也不需要更新协议版本号）或 kernel_info 向引导加载程序传达支持的 Linux 内核特性。由于原始设置头部可用空间非常有限，因此对它的每次更新都应谨慎考虑。从协议 2.15 开始，向引导加载程序传达信息的主要方式是 kernel_info。
内存布局
=============

对于 Image 或 zImage 内核所用的传统内核加载器内存图通常如下所示：

		|			 |
	0A0000	+------------------------+
		|  为 BIOS 预留	 |	不要使用。为 BIOS EBDA 预留
09A000	+------------------------+
		|  命令行		 |
		|  栈/堆		 |	供内核实模式代码使用
098000	+------------------------+
		|  内核设置		 |	内核实模式代码
090200	+------------------------+
		|  内核引导扇区	 |	内核遗留引导扇区
090000	+------------------------+
		|  保护模式内核	 |	内核映像的主体部分
010000	+------------------------+
		|  引导加载程序	 |	<- 引导扇区入口点 0000:7C00
	001000	+------------------------+
		|  为 MBR/BIOS 预留 |
	000800	+------------------------+
		|  通常由 MBR 使用 |
	000600	+------------------------+
		|  仅供 BIOS 使用	 |
	000000	+------------------------+

使用 bzImage 时，保护模式内核被重定位到 0x100000（“高内存”），而内核实模式块（引导扇区、设置和栈/堆）可被重定位到低内存 0x10000 到末尾之间的任意地址。不幸的是，在协议 2.00 和 2.01 中，0x90000+ 内存范围仍被内核内部使用；2.02 协议解决了该问题。
保持“内存上限”——即引导加载程序触及的低内存最高点尽可能低是理想的，因为一些较新的 BIOS 已开始在低内存顶部分配相当大量的内存，称为扩展 BIOS 数据区域。引导加载程序应该使用“INT 12h”BIOS 调用来验证有多少低内存可用。
不幸的是，如果 INT 12h 报告内存量过低，引导加载程序通常除了向用户报告错误之外别无他法。因此，引导加载程序的设计应尽量减少其在低内存中占用的空间。对于需要将数据写入 0x90000 段的 zImage 或旧版 bzImage 内核，引导加载程序应确保不使用高于 0x9A000 的内存；太多 BIOS 在这个点以上会出现问题。
对于现代的bzImage内核，如果引导协议版本 >= 2.02，则建议采用以下内存布局：

		~                        ~
		|  保护模式下的内核     |
	100000  +------------------------+
		|  I/O 内存空洞          |
	0A0000	+------------------------+
		|  保留给BIOS            |	尽可能多地保留未使用
		~                        ~
		|  启动参数              |	（也可以位于X+10000标记之下）
	X+10000	+------------------------+
		|  栈/堆                 |	供内核实模式代码使用
X+08000	+------------------------+
		|  内核设置              |	内核实模式代码
|  内核引导扇区         |	内核传统引导扇区
X       +------------------------+
		|  引导加载程序           |	<- 引导扇区入口点 0000:7C00
	001000	+------------------------+
		|  保留给MBR/BIOS        |
	000800	+------------------------+
		|  通常由MBR使用         |
	000600	+------------------------+
		|  仅用于BIOS            |
	000000	+------------------------+

... 其中地址X尽可能低，这取决于引导加载程序的设计。

### 实模式下的内核头文件

在下面的文本中以及内核启动序列中的任何地方，“一个扇区”指的是512字节。它独立于底层介质的实际扇区大小。
加载Linux内核的第一步应该是加载实模式代码（引导扇区和设置代码），然后检查在偏移量0x01f1处的以下头部信息。实模式代码总共可以达到32K，尽管引导加载程序可以选择只加载前两个扇区（1K），然后检查启动扇区的大小。
头部看起来像这样：

===========	========	=====================	============================================
Offset/Size	Proto		Name			Meaning
===========	========	=====================	============================================
01F1/1		ALL(1)		setup_sects		设置代码的扇区大小
01F2/2		ALL		root_flags		如果设置，则根文件系统以只读方式挂载
01F4/4		2.04+(2)	syssize			32位代码的16字节段大小
01F8/2		ALL		ram_size		不要使用 - 仅供bootsect.S使用
01FA/2		ALL		vid_mode		视频模式控制
01FC/2		ALL		root_dev		默认根设备编号
01FE/2		ALL		boot_flag		0xAA55的魔数
0200/2		2.00+		jump			跳转指令
0202/4		2.00+		header			魔数签名 "HdrS"
0206/2		2.00+		version			支持的引导协议版本
0208/4		2.00+		realmode_swtch		引导加载程序钩子（见下文）
020C/2		2.00+		start_sys_seg		加载低位段（0x1000）（过时）
020E/2		2.00+		kernel_version		指向内核版本字符串的指针
0210/1		2.00+		type_of_loader		引导加载程序标识符
0211/1		2.00+		loadflags		引导协议选项标志
0212/2		2.00+		setup_move_size		移动到高内存的大小（与钩子一起使用）
0214/4		2.00+		code32_start		引导加载程序钩子（见下文）
0218/4		2.00+		ramdisk_image		initrd加载地址（由引导加载程序设置）
021C/4		2.00+		ramdisk_size		initrd大小（由引导加载程序设置）
0220/4		2.00+		bootsect_kludge		不要使用 - 仅供bootsect.S使用
0224/2		2.01+		heap_end_ptr		设置结束后可用内存后的指针
0226/1		2.02+(3)	ext_loader_ver		扩展引导加载程序版本
0227/1		2.02+(3)	ext_loader_type		扩展引导加载程序ID
0228/4		2.02+		cmd_line_ptr		指向内核启动参数的32位指针
022C/4		2.03+		initrd_addr_max		合法initrd地址的最大值
0230/4		2.05+		kernel_alignment	内核所需的物理地址对齐
0234/1		2.05+		relocatable_kernel	内核是否可重定位
0235/1		2.10+		min_alignment		最小对齐值，以2的幂表示
0236/2		2.12+		xloadflags		引导协议选项标志
0238/4		2.06+		cmdline_size		内核启动参数的最大大小
023C/4		2.07+		hardware_subarch	硬件子架构
0240/8		2.07+		hardware_subarch_data	特定子架构的数据
0248/4		2.08+		payload_offset		内核负载的偏移量
024C/4		2.08+		payload_length		内核负载的长度
0250/8		2.09+		setup_data		指向结构化setup_data链表的64位物理指针
0258/8		2.10+		pref_address		首选加载地址
0260/4		2.10+		init_size		初始化期间所需的线性内存
0264/4		2.11+		handover_offset		交接入口点的偏移量
0268/4		2.15+		kernel_info_offset	内核_info的偏移量
===========	========	=====================	============================================

.. note::
  (1) 为了向后兼容，如果setup_sects字段包含0，则实际值为4
(2) 对于2.04之前的引导协议版本，syssize字段的高两位无法使用，这意味着无法确定bzImage内核的大小
(3) 对于2.02-2.09版本的引导协议，可以忽略，但安全地设置

如果在偏移量0x202处没有找到“HdrS”（0x53726448）的魔数，则引导协议版本是“旧”的。加载旧内核时，应假设以下参数：

- 图像类型 = zImage
- 不支持initrd
- 实模式下的内核必须位于0x90000处
否则，“version”字段包含协议版本，例如协议版本2.01将在此字段中包含0x0201。在设置头部字段时，你必须确保仅设置所使用协议版本支持的字段。
头部字段详情
=============

对于每个字段，有些是内核传递给引导加载程序的信息（“读取”），有些预期由引导加载程序填写（“写入”），还有一些预期由引导加载程序读取并修改（“修改”）。
所有通用引导加载程序都应该写入标记为（必需）的字段。如果引导加载程序想要在非标准地址加载内核，则应该填写标记为（重定位）的字段；其他引导加载程序可以忽略这些字段。
所有字段的字节序都是小端格式（毕竟这是x86架构）。

============	===========
字段名称:	setup_sects
类型:		读取
偏移量/大小:	0x1f1/1
协议:		全部
============	===========

  设置代码在512字节扇区中的大小。如果此字段为0，则实际值为4。实模式代码包括启动扇区（始终是一个512字节的扇区）加上设置代码。
============	=================
字段名称:	root_flags
类型:		修改（可选）
偏移量/大小:	0x1f2/2
协议:		全部
============	=================

  如果此字段非零，则根分区默认为只读。使用此字段的做法已过时；请改用命令行上的"ro"或"rw"选项。
============	===============================================
字段名称:	syssize
类型:		读取
偏移量/大小:	0x1f4/4（协议2.04及以上）0x1f4/2（协议全部）
协议:		2.04及以上
============	===============================================

  受保护模式代码的大小，以16字节段为单位
对于2.04以前版本的协议，此字段仅为两个字节宽，因此如果设置了LOAD_HIGH标志，则无法信赖它来表示内核的大小。
============	===============
字段名称:	ram_size
类型:		内核内部使用
偏移量/大小:	0x1f8/2
协议:		全部
============	===============

  此字段已过时
============	===================
字段名称:	vid_mode
类型:		修改（必需）
偏移量/大小:	0x1fa/2
============	===================

  请参阅SPECIAL COMMAND LINE OPTIONS部分
============	=================
字段名称:	root_dev
类型:		修改（可选）
偏移量/大小:	0x1fc/2
协议:		全部
============	=================

  默认的根设备编号。使用此字段的做法已过时，请改用命令行上的"root="选项。
============= ===========
字段名称: boot_flag
类型:      读取
偏移/大小: 0x1fe/2
协议:      所有
============= ===========

  包含值 0xAA55。这是旧版 Linux 内核中与魔法数字最接近的东西。
============= ===========
字段名称: jump
类型:      读取
偏移/大小: 0x200/2
协议:      2.00+
============= ===========

  包含 x86 跳转指令，即 0xEB 后跟相对于字节 0x202 的带符号偏移量。这可用于确定头部的大小。
============= ===========
字段名称: header
类型:      读取
偏移/大小: 0x202/4
协议:      2.00+
============= ===========

  包含魔法数字 "HdrS"（0x53726448）。
============= ===========
字段名称: version
类型:      读取
偏移/大小: 0x206/2
协议:      2.00+
============= ===========

  包含引导协议版本，格式为 (主版本号 << 8) + 次版本号，例如：0x0204 表示版本 2.04，而 0x0a11 表示假设版本 10.17。
============= ==================
字段名称: realmode_swtch
类型:      修改（可选）
偏移/大小: 0x208/4
协议:      2.00+
============= ==================

  引导加载程序挂钩（参见下面的“高级引导加载程序挂钩”。）

============= ==============
字段名称: start_sys_seg
类型:      读取
偏移/大小: 0x20c/2
协议:      2.00+
============= ==============

  加载低段（0x1000）。已过时。
============= ===============
字段名称: kernel_version
类型:      读取
偏移/大小: 0x20e/2
协议:      2.00+
============= ===============

  如果设置为非零值，则包含指向以 NUL 结尾的人类可读内核版本号字符串的指针，减去 0x200。此值可用于向用户显示内核版本。该值应小于 (0x200 * setup_sects)。
例如，如果该值设置为 0x1c00，则可以在内核文件的偏移量 0x1e00 处找到内核版本号字符串。
此值仅在“setup_sects”字段包含 15 或更高值时有效，因为：
  
  0x1c00 < 15 * 0x200 (= 0x1e00) 但是
  0x1c00 >= 14 * 0x200 (= 0x1c00)

  0x1c00 >> 9 = 14，因此 setup_secs 的最小值为 15
============= ===================
字段名称: type_of_loader
类型:      写入（强制性）
偏移/大小: 0x210/1
协议:      2.00+
============= ===================

  如果您的引导加载程序有一个分配的标识符（参见下表），则在此处输入 0xTV，其中 T 是引导加载程序的标识符，V 是版本号。否则，请输入 0xFF。
对于 T > 0xD 的引导加载程序 ID，将 T = 0xE 写入此字段，并将扩展 ID 减去 0x10 写入 ext_loader_type 字段。
同样地，`ext_loader_ver`字段可以用于提供超过四个比特位的引导加载程序版本信息。
例如，对于 T = 0x15, V = 0x234, 写作：

  - `type_of_loader`  <- 0xE4
  - `ext_loader_type` <- 0x05
  - `ext_loader_ver`  <- 0x23

分配的引导加载程序标识（十六进制）:

| == | ======================================= |
| --- | -------------------------------------- |
| 0   | LILO                                   |
|     | （0x00 预留用于 2.00 版本之前的引导加载程序） |
| 1   | Loadlin                                |
| 2   | bootsect-loader                        |
|     | （0x20，所有其他值预留）               |
| 3   | Syslinux                               |
| 4   | Etherboot/gPXE/iPXE                    |
| 5   | ELILO                                  |
| 7   | GRUB                                   |
| 8   | U-Boot                                 |
| 9   | Xen                                    |
| A   | Gujin                                  |
| B   | Qemu                                   |
| C   | Arcturus Networks uCbootloader         |
| D   | kexec-tools                            |
| E   | 扩展（参见 `ext_loader_type`）          |
| F   | 特殊（0xFF = 未定义）                  |
| 10  | 预留                                  |
| 11  | 最小 Linux 引导加载程序                |
|      | <http://sebastian-plotz.blogspot.de>  |
| 12  | OVMF UEFI 虚拟化堆栈                   |
| 13  | barebox                                |

如果您需要分配一个引导加载程序ID值，请联系 `<hpa@zytor.com>`。

=============  ====================
字段名称: loadflags
类型: 修改（必需）
偏移/大小: 0x211/1
协议: 2.00+
=============  ====================

此字段是一个位掩码。
位 0（读取）: LOADED_HIGH

- 如果为 0，则保护模式代码加载在 0x10000 处
- 如果为 1，则保护模式代码加载在 0x100000 处
位 1（内核内部）: KASLR_FLAG

- 由压缩内核内部使用以向内核主体传达 KASLR 状态
- 如果为 1，则启用 KASLR
- 如果为 0，则禁用 KASLR
位 5（写入）: QUIET_FLAG

- 如果为 0，则打印早期消息
- 如果为 1，则抑制早期消息
这段文档描述了与内核启动相关的配置字段，以下是翻译成中文的内容：

这要求内核（解压器和早期内核）不要写入那些需要直接访问显示硬件的早期信息。
位6（已废弃）：KEEP_SEGMENTS

协议：2.07+

- 这个标志已废弃
位7（写）：CAN_USE_HEAP

将此位设置为1以指示在heap_end_ptr中输入的值是有效的。如果此字段未设置，则某些设置代码的功能将会被禁用。
============	===================
字段名称:	setup_move_size
类型:		修改（必需）
偏移量/大小:	0x212/2
协议:		2.00-2.01
============	===================

当使用协议2.00或2.01时，如果实模式内核没有加载到0x90000处，在加载序列后期它会被移动到该位置。如果希望除了实模式内核本身之外还移动其他数据（例如内核命令行），请填写这个字段。
单位是从引导扇区开始的字节数。
当协议为2.02或更高版本时，或者实模式代码被加载到0x90000时，可以忽略此字段。
============	========================
字段名称:	code32_start
类型:		修改（可选，重定位）
偏移量/大小:	0x214/4
协议:		2.00+
============	========================

受保护模式下跳转到的地址。默认情况下，这是内核的加载地址，并且可以由引导加载程序来确定正确的加载地址。
此字段可以出于以下两个目的进行修改：

    1. 作为引导加载程序的挂钩（参见下面的高级引导加载程序挂钩。）

    2. 如果一个不安装挂钩的引导加载程序以非标准地址加载了一个可重定位的内核，则必须修改此字段以指向加载地址。
============	==================
字段名称:	ramdisk_image
类型:		写入（必需）
偏移量/大小:	0x218/4
协议:		2.00+
============	==================

初始RAM磁盘或RAM文件系统的32位线性地址。如果没有初始RAM磁盘/RAM文件系统则保持为零。
============	==================
字段名称:	ramdisk_size
类型:		写入（必需）
偏移量/大小:	0x21c/4
协议:		2.00+
============	==================

初始RAM磁盘或RAM文件系统的大小。如果没有初始RAM磁盘/RAM文件系统则保持为零。
============= ===============
字段名称: bootsect_kludge
类型:     内核内部使用
偏移/大小: 0x220/4
协议版本: 2.00+
============= ===============

此字段已废弃。
============= ==================
字段名称: heap_end_ptr
类型:     写入（必需）
偏移/大小: 0x224/2
协议版本: 2.01+
============= ==================

将此字段设置为实模式代码开始处到设置堆栈/堆末尾的偏移量，减去0x0200。
============= =================
字段名称: ext_loader_ver
类型:     写入（可选）
偏移/大小: 0x226/1
协议版本: 2.02+
============= =================

此字段用作`type_of_loader`字段中版本号的扩展。总的版本号被认为是`(type_of_loader & 0x0f) + (ext_loader_ver << 4)`。
此字段的使用依赖于引导加载程序。如果未写入，则其值为零。
在2.6.31之前的内核不识别此字段，但对于协议版本2.02或更高版本写入它是安全的。
============= =======================================================
字段名称: ext_loader_type
类型:     写入（当`(type_of_loader & 0xf0)`等于0xE0时必需）
偏移/大小: 0x227/1
协议版本: 2.02+
============= =======================================================

此字段用作`type_of_loader`字段中类型编号的扩展。如果`type_of_loader`中的类型是0xE，则实际类型是`(ext_loader_type + 0x10)`。
如果`type_of_loader`中的类型不是0xE，则忽略此字段。
在2.6.31之前的内核不识别此字段，但对于协议版本2.02或更高版本写入它是安全的。
============= ==================
字段名称: cmd_line_ptr
类型:     写入（必需）
偏移/大小: 0x228/4
协议版本: 2.02+
============= ==================

将此字段设置为内核命令行的线性地址。
内核命令行可以位于设置堆之后与0xA0000之间的任何位置；它不必位于与实模式代码相同的64K段中。
即使您的启动加载器不支持命令行，也要填写此字段，在这种情况下您可以将其指向空字符串（或者更好的选择是字符串"auto"）。如果此字段留空（默认为零），内核将假定您的启动加载器不支持2.02及更高版本的协议。
============	===============
字段名称: initrd_addr_max
类型: 读取
偏移/大小: 0x22c/4
协议: 2.03+
============	===============

初始ramdisk/ramfs内容可能占用的最大地址。对于2.02或更早版本的启动协议，此字段不存在，并且最大地址为0x37FFFFFF。（此地址定义为最高安全字节的位置，因此如果您ramdisk的确切长度为131072字节，且此字段为0x37FFFFFF，则可以从0x37FE0000开始加载您的ramdisk。）

============	============================
字段名称: kernel_alignment
类型: 读取/修改（重定位）
偏移/大小: 0x230/4
协议: 2.05+（读取），2.10+（修改）
============	============================

内核所需的对齐单元（如果relocatable_kernel为真）。一个与该字段中的值不兼容地加载的可重定位内核将在内核初始化期间重新对齐。
从协议版本2.10开始，这反映了内核为了最优性能所偏好的对齐方式；加载器可以修改此字段以允许较低的对齐方式。参见下面的min_alignment和pref_address字段。
============	==================
字段名称: relocatable_kernel
类型: 读取（重定位）
偏移/大小: 0x234/1
协议: 2.05+
============	==================

如果此字段非零，则受保护模式部分的内核可以加载到满足kernel_alignment字段中指定条件的任何地址
加载后，启动加载器必须设置code32_start字段，使其指向已加载的代码或指向启动加载器挂钩
============	=============
字段名称: min_alignment
类型: 读取（重定位）
偏移/大小: 0x235/1
协议: 2.10+
============	=============

如果此字段非零，它表示内核启动所需的最小对齐方式（而非偏好），以2的幂表示。如果启动加载器使用此字段，应将kernel_alignment字段更新为所需对齐单元；通常如下所示：

    kernel_alignment = 1 << min_alignment

对齐不足的内核可能会导致相当大的性能损失。因此，加载器通常应该尝试从kernel_alignment到此对齐方式的所有2的幂对齐方式。
============	==========
字段名称: xloadflags
类型: 读取
偏移/大小: 0x236/2
协议: 2.12+
============	==========

此字段是一个位掩码。
位 0（读取）: XLF_KERNEL_64

    - 如果为1，此内核在0x200处有传统的64位入口点
位 1（读取）: XLF_CAN_BE_LOADED_ABOVE_4G

    - 如果为1，内核/启动参数/命令行/ramdisk可以在4GB以上的位置加载
以下是提供的英文描述翻译成中文：

位 2（读取）: XLF_EFI_HANDOVER_32

    - 如果为1，则内核支持在 handover_offset 处给出的 32 位 EFI 交接入口点
位 3（读取）: XLF_EFI_HANDOVER_64

    - 如果为1，则内核支持在 handover_offset + 0x200 处给出的 64 位 EFI 交接入口点
位 4（读取）: XLF_EFI_KEXEC

    - 如果为1，则内核支持具有 EFI 运行时支持的 kexec EFI 启动
============= =============
字段名称: cmdline_size
类型: 读取
偏移量/大小: 0x238/4
协议版本: 2.06+
============= =============

  命令行的最大长度，不包括终止零。这意味着命令行最多可以包含 cmdline_size 个字符。在协议版本 2.05 及更早版本中，最大长度为 255。
============= ===================================
字段名称: hardware_subarch
类型: 写入（可选，默认为 x86/PC）
偏移量/大小: 0x23c/4
协议版本: 2.07+
============= ===================================

  在半虚拟化环境中，硬件低级架构组件如中断处理、页表处理以及访问进程控制寄存器等需要以不同的方式进行处理。此字段允许引导加载程序通知内核我们处于这些环境之一。
========== ==============================
  0x00000000 默认的 x86/PC 环境
  0x00000001 lguest
  0x00000002 Xen
  0x00000003 Moorestown MID
  0x00000004 CE4100 TV 平台
========== ==============================
============= ===========================
字段名称: hardware_subarch_data
类型: 写入（取决于子架构）
偏移量/大小: 0x240/8
协议版本: 2.07+
============= ===========================

  指向特定于硬件子架构的数据的指针
  对于默认的 x86/PC 环境，此字段目前未使用，请勿修改
============= ===============
字段名称: payload_offset
类型: 读取
偏移量/大小: 0x248/4
协议版本: 2.08+
============= ===============

  如果非零，则此字段包含从受保护模式代码的开始到有效负载的偏移量
  有效负载可能是压缩的。压缩和未压缩数据的格式应通过标准魔法数字确定。当前支持的压缩格式包括 gzip（魔法数字 1F 8B 或 1F 9E）、bzip2（魔法数字 42 5A）、LZMA（魔法数字 5D 00）、XZ（魔法数字 FD 37）、LZ4（魔法数字 02 21）和 ZSTD（魔法数字 28 B5）。未压缩的有效负载目前始终为 ELF（魔法数字 7F 45 4C 46）
============= ===============
字段名称: payload_length
类型: 读取
偏移量/大小: 0x24c/4
协议版本: 2.08+
============= ===============

  有效负载的长度
============= ===============
字段名称: setup_data
类型: write (特殊)
偏移量/大小: 0x250/8
协议版本: 2.09+
============= ===============

这是一个指向单链表中 `struct setup_data` 的64位物理指针，链表以 `NULL` 结尾。该结构用于定义一种更可扩展的启动参数传递机制。`struct setup_data` 的定义如下所示：

```c
struct setup_data {
    u64 next;      // 指向链表中下一个节点的64位物理指针；最后一个节点的next字段为0
    u32 type;      // 用于标识data字段的内容类型
    u32 len;       // data字段的长度
    u8  data[0];   // 实际的有效载荷
};
```

在启动过程中，这个列表可能会被多次修改。因此，在修改此列表时，必须始终考虑到链表可能已经包含条目的情况。
使用 `setup_data` 来处理非常大的数据对象有些笨拙，原因在于 `setup_data` 标头必须与数据对象相邻，并且它有一个32位长度字段。然而，在启动过程的中间阶段，重要的是要有方法来识别哪些内存块被内核数据占用。

因此，在协议版本2.15中引入了 `struct setup_indirect` 和 `SETUP_INDIRECT` 类型：

```c
struct setup_indirect {
    __u32 type;          // SETUP_INDIRECT | SETUP_*
    __u32 reserved;      // 预留字段，必须设为0
    __u64 len;           // 数据长度
    __u64 addr;          // 数据地址
};
```

其中 `type` 成员是 `SETUP_INDIRECT | SETUP_*` 类型。但是，它不能仅是 `SETUP_INDIRECT` 本身，因为将 `setup_indirect` 设计成树状结构可能会需要大量的栈空间，而在启动环境中栈空间可能有限。

下面举例说明如何使用 `setup_indirect` 指向 `SETUP_E820_EXT` 数据：
在这种情况下，`setup_data` 和 `setup_indirect` 将如下所示：

```c
struct setup_data {
    __u64 next = 0 或 <addr_of_next_setup_data_struct>;  // 指向下一个setup_data结构的地址或0
    __u32 type = SETUP_INDIRECT;
    __u32 len = sizeof(setup_indirect);
    __u8 data[sizeof(setup_indirect)] = {  // setup_indirect结构
        .type = SETUP_INDIRECT | SETUP_E820_EXT,
        .reserved = 0,
        .len = <len_of_SETUP_E820_EXT_data>,
        .addr = <addr_of_SETUP_E820_EXT_data>
    };
};
```

**注意：**
无法正确区分 `SETUP_INDIRECT | SETUP_NONE` 对象和 `SETUP_INDIRECT` 本身。因此，此类对象不能由引导加载程序提供。

============= ===============
字段名称: pref_address
类型: read (重定位)
偏移量/大小: 0x258/8
协议版本: 2.10+
============= ===============

如果非零，该字段表示内核的首选加载地址。重定位的引导加载程序应尽可能尝试在此地址加载内核。
对于不可重定位的内核，它会无条件地将自身移动到此地址并运行。对于可重定位的内核，如果其加载地址低于此地址，则会将自身移动到此地址。

============= =======
字段名称: init_size
类型: read
偏移量/大小: 0x260/4
============= =======

该字段指示从内核运行时起始地址开始所需的线性连续内存的数量，直到内核能够检查其内存映射。这并不等同于内核启动所需的总内存数量，但它可以被重定位的引导加载程序用来帮助选择一个安全的加载地址。

内核运行时起始地址由以下算法确定：

```c
if (relocatable_kernel) {
    runtime_start = align_up(load_address, kernel_alignment)
} else {
    runtime_start = pref_address
}
```

============= ===============
字段名称: handover_offset
类型: read
偏移量/大小: 0x264/4
============= ===============

该字段是从内核映像开始到EFI手递协议入口点的偏移量。使用EFI手递协议启动内核的引导加载程序应该跳转到此偏移量。
下面是EFI交接协议的更多细节。

=============	==================
字段名称：	kernel_info_offset
类型：		读取
偏移量/大小：	0x268/4
协议：		2.15+
=============	==================

此字段是从内核镜像开始到`kernel_info`结构的偏移量。`kernel_info`结构嵌入在Linux镜像的未压缩保护模式区域中。

`kernel_info`
=============

各头部之间的关系类似于各种数据段：

  `setup_header` = `.data`
  `boot_params/setup_data` = `.bss`

从上面的列表中缺失的是：

  `kernel_info` = `.rodata`

我们长期以来一直在（滥用）`.data`来存放本可以放入`.rodata`或`.bss`的内容，这是由于缺乏替代方案以及早期的惰性。另外，BIOS存根负责创建`boot_params`，因此它对基于BIOS的加载器不可用（但`setup_data`是可用的）。
`setup_header`由于2字节跳转字段的作用范围及其作为结构长度字段的双重功能，加上保护模式加载器或BIOS存根必须将其复制到`struct boot_params`中的“空洞”的大小，其永久限制为144字节。目前它长119字节，这给我们留下了非常宝贵的25字节空间。如果不彻底修订启动协议，破坏向后兼容性，这个问题无法解决。
`boot_params`本身被限制为4096字节，但可以通过添加`setup_data`条目任意扩展。它不能用于传达内核图像的属性，因为它属于`.bss`并且没有由图像提供的内容。
`kernel_info`通过提供一个可扩展的地方来存储关于内核图像的信息来解决这一问题。它是只读的，因为内核不能依赖于加载器复制其内容，但这没关系；如果有必要，它仍然可以包含预期已启用的加载器会复制到`setup_data`块中的数据项。
所有`kernel_info`数据都应成为这个结构的一部分。固定大小的数据必须放在`kernel_info_var_len_data`标签之前。可变大小的数据必须放在`kernel_info_var_len_data`标签之后。每一块可变大小的数据都必须以头部/魔法和其大小为前缀，例如：

```assembly
kernel_info:
        .ascii  "LToP"          /* 头部，Linux顶点（结构）。 */
        .long   kernel_info_var_len_data - kernel_info
        .long   kernel_info_end - kernel_info
        .long   0x01234567      /* 供加载器使用的固定大小数据。 */
kernel_info_var_len_data:
example_struct:                 /* 供加载器使用的可变大小数据。 */
        .ascii  "0123"          /* 头部/魔法。 */
        .long   example_struct_end - example_struct
        .ascii  "Struct"
        .long   0x89012345
example_struct_end:
example_strings:                /* 供加载器使用的可变大小数据。 */
        .ascii  "ABCD"          /* 头部/魔法。 */
        .long   example_strings_end - example_strings
        .asciz  "String_0"
        .asciz  "String_1"
example_strings_end:
kernel_info_end:
```

这样`kernel_info`就成为一个自包含的块。

**注释**：
每个可变大小数据的头部/魔法可以是任何4个字符的字符串，字符串末尾没有`\0`，并且不会与现有的可变长度数据头部/魔法冲突。

`kernel_info`字段的详细信息
============================

=============	========
字段名称：	header
偏移量/大小：	0x0000/4
=============	========

  包含魔法数字"LToP"（0x506f544c）
============= =========
字段名称：size
偏移量/大小：0x0004/4
============= =========

此字段包含`kernel_info`（包括`kernel_info.header`）的大小。
它不计算`kernel_info.kernel_info_var_len_data`的大小。此字段应由
启动加载程序使用，以检测`kernel_info`中支持的固定大小字段
以及`kernel_info.kernel_info_var_len_data`的起始位置。
============= =========
字段名称：size_total
偏移量/大小：0x0008/4
============= =========

此字段包含`kernel_info`（包括`kernel_info.header`和`kernel_info.kernel_info_var_len_data`）的总大小。
============= ===============
字段名称：setup_type_max
偏移量/大小：0x000c/4
============= ===============

此字段包含`setup_data` 和 `setup_indirect` 结构体允许的最大类型。

映像校验和
==================

从版本2.08开始，使用特征多项式0x04C11DB7及初始余数0xffffffff计算整个文件的CRC-32校验和。
校验和附加在文件末尾；因此根据`header`中的`syssize`字段指定的限制，文件的CRC总是0。

内核命令行
=======================

内核命令行已成为启动加载器与内核通信的重要方式。其中一些选项也与启动加载器本身相关，参见下面的“特殊命令行选项”。
内核命令行是一个以空字符终止的字符串。最大长度可以从`cmdline_size`字段获取。在协议版本2.06之前，最大长度为255个字符。过长的字符串将被内核自动截断。
如果启动协议版本为2.02或更高版本，则内核命令行的地址由`header`字段`cmd_line_ptr`给出（参见上文）。此地址可以位于setup堆的结尾与0xA0000之间任意位置。
如果协议版本不是2.02或更高版本，则使用以下协议输入内核命令行：

  - 在偏移量0x0020（字），名为`cmd_line_magic`的位置，输入魔数0xA33F
- 在偏移量0x0022（字），名为`cmd_line_offset`的位置，输入内核命令行的偏移量（相对于实模式内核的起始位置）
内核命令行 *必须* 位于 `setup_move_size` 所覆盖的内存区域内，因此您可能需要调整这个字段。

实模式代码的内存布局
==================

实模式代码需要设置堆栈/堆空间，并且需要为内核命令行分配内存。这些操作需要在实模式可访问的低端兆字节内存中完成。
值得注意的是，现代机器通常有一个较大的扩展 BIOS 数据区域（EBDA）。因此，建议尽可能少地使用低端兆字节的内存。
不幸的是，在以下情况下，必须使用 0x90000 内存段：

- 当加载 zImage 内核时 (`(loadflags & 0x01) == 0`)
- 当加载 2.01 或更早版本的引导协议内核时
.. note::
     对于 2.00 和 2.01 版本的引导协议，实模式代码可以加载到其他地址，但内部会将其重定位到 0x90000。对于“旧”协议，实模式代码必须加载到 0x90000
当在 0x90000 加载时，避免使用高于 0x9a000 的内存
对于 2.02 或更高版本的引导协议，命令行不必位于与实模式设置代码相同的 64K 段中；因此允许给堆栈/堆分配整个 64K 段，并将命令行置于其上方
内核命令行不应位于实模式代码之下，也不应位于高端内存中

示例引导配置
==============

作为示例配置，假设实模式段有如下布局：
当加载位置低于 0x90000 时，使用整个段：

        =============	===================
	0x0000-0x7fff	实模式内核
	0x8000-0xdfff	栈和堆
	0xe000-0xffff	内核命令行
	=============	===================

    当加载位置为 0x90000 或协议版本为 2.01 或更早时：

	=============	===================
	0x0000-0x7fff	实模式内核
	0x8000-0x97ff	栈和堆
	0x9800-0x9fff	内核命令行
	=============	===================

此类引导程序应将以下字段填入头部：

    unsigned long base_ptr;	/* 实模式段的基地址 */

    如果 ( setup_sects == 0 ) {
        setup_sects = 4;
    }

    如果 ( protocol >= 0x0200 ) {
        type_of_loader = <类型代码>;
        如果 ( loading_initrd ) {
            ramdisk_image = <initrd地址>;
            ramdisk_size = <initrd大小>;
        }

        如果 ( protocol >= 0x0202 && loadflags & 0x01 )
            heap_end = 0xe000;
        否则
            heap_end = 0x9800;

        如果 ( protocol >= 0x0201 ) {
            heap_end_ptr = heap_end - 0x200;
            loadflags |= 0x80; /* CAN_USE_HEAP */
        }

        如果 ( protocol >= 0x0202 ) {
            cmd_line_ptr = base_ptr + heap_end;
            strcpy(cmd_line_ptr, cmdline);
        } else {
            cmd_line_magic	= 0xA33F;
            cmd_line_offset = heap_end;
            setup_move_size = heap_end + strlen(cmdline)+1;
            strcpy(base_ptr+cmd_line_offset, cmdline);
        }
    } else {
        /* 非常旧的内核 */

        heap_end = 0x9800;

        cmd_line_magic	= 0xA33F;
        cmd_line_offset = heap_end;

        /* 一个非常旧的内核必须将其实模式代码
           加载在 0x90000 处 */

        如果 ( base_ptr != 0x90000 ) {
            /* 复制实模式内核 */
            memcpy(0x90000, base_ptr, (setup_sects+1)*512);
            base_ptr = 0x90000;		 /* 重新定位 */
        }

        strcpy(0x90000+cmd_line_offset, cmdline);

        /* 推荐清除内存直到达到 32K 标记 */
        memset(0x90000 + (setup_sects+1)*512, 0,
               (64-(setup_sects+1))*512);
    }


加载剩余部分的内核
==============================

32位（非实模式）内核从内核文件中的偏移位置 (setup_sects+1)*512 开始（再次说明，如果 setup_sects == 0 则实际值为 4）
它应该被加载到 Image/zImage 内核的 0x10000 地址处，bzImage 内核的 0x100000 地址处
如果协议 >= 2.00 并且 loadflags 字段中设置了 0x01 位（LOAD_HIGH），则该内核是 bzImage 内核 ::

    is_bzImage = (protocol >= 0x0200) && (loadflags & 0x01);
    load_address = is_bzImage ? 0x100000 : 0x10000;

请注意 Image/zImage 内核可以达到最大 512K 的大小，因此它们使用整个 0x10000-0x90000 内存范围。这意味着对于这些内核来说，在 0x90000 处加载实模式部分几乎是必须的。bzImage 内核允许更大的灵活性。
特殊的命令行选项
============================

如果引导程序提供的命令行是由用户输入的，则用户可能期望以下命令行选项能正常工作
通常不应从内核命令行中删除这些选项，即使并非所有选项对内核都有实际意义。需要为引导程序本身添加额外命令行选项的引导程序作者应将它们注册在 Documentation/admin-guide/kernel-parameters.rst 中以确保它们现在或将来不会与实际内核选项冲突
vga=<模式>
    <模式> 可以是一个整数（用 C 语言表示法，即十进制、八进制或十六进制）或以下字符串之一：“normal”（表示 0xFFFF）、“ext”（表示 0xFFFE）或 “ask”（表示 0xFFFD）。此值应被填入 vid_mode 字段，因为内核会在解析命令行之前使用它
mem=<大小>
    <大小> 是一个可选地后跟（不区分大小写）K、M、G、T、P 或 E（表示 << 10、<< 20、<< 30、<< 40、<< 50 或 << 60）的 C 表示法中的整数。这向内核指定了内存的结束位置。这会影响 initrd 的放置位置，因为 initrd 应放置在内存接近末尾的位置。请注意，这是内核和引导程序的选项！

  initrd=<文件>
    应加载一个 initrd。<文件> 的含义显然取决于引导程序，有些引导程序（如 LILO）没有这样的命令
此外，一些引导程序会向用户指定的命令行中添加以下选项：

  BOOT_IMAGE=<文件>
    已加载的启动映像。同样，<文件> 的含义显然取决于引导程序
auto
    内核是在无用户显式干预的情况下启动的
如果这些选项由引导程序添加，强烈建议将它们放在首位，即在用户指定或配置指定的命令行之前。否则，“init=/bin/sh” 会被 “auto” 选项搞混
运行内核
==================

通过跳转到内核入口点来启动内核，该入口点位于 *段* 偏移 0x20 处的实模式内核开始处。这意味着如果你将实模式内核代码加载到了 0x90000 处，那么内核入口点是 9020:0000
在进入时，ds、es 和 ss 应指向实模式内核代码的起始位置（如果代码加载在 0x90000，则为 0x9000），sp 应正确设置，通常指向堆栈顶部，并且应禁用中断。此外，为了防止内核中的错误，建议引导加载器将 fs、gs 设置与 ds、es 和 ss 相同。

在我们上面的例子中，我们会这样做：

	/* 注意：对于“旧”内核协议，此时 base_ptr 必须等于 0x90000；参见前面的示例代码 */

	seg = base_ptr >> 4;

	cli();	/* 进入时禁用中断！ */

	/* 设置实模式内核栈 */
	_SS = seg;
	_SP = heap_end;

	_DS = _ES = _FS = _GS = seg;
	jmp_far(seg+0x20, 0);	/* 运行内核 */

如果你的启动扇区访问软盘驱动器，建议在运行内核之前关闭软盘电机，因为内核启动会禁用中断，因此电机不会关闭，特别是如果加载的内核有作为按需加载模块的软盘驱动程序！

高级引导加载器挂钩
==================

如果引导加载器运行在一个特别恶劣的环境中（例如 LOADLIN，它运行在 DOS 下），可能无法满足标准内存位置要求。这种引导加载器可以使用以下挂钩，如果设置的话，在适当的时候由内核调用。使用这些挂钩应该被视为最后的手段！

重要：所有挂钩都必须在调用过程中保持 %esp、%ebp、%esi 和 %edi 的值不变。
realmode_swtch：
	一个 16 位实模式远过程子程序，在进入保护模式前立即被调用。默认程序禁用 NMI，因此你的程序也应该这样做。
code32_start：
	一个 32 位平坦模式程序，在转换到保护模式后立即跳转到该程序，但在内核解压之前。除了 CS 以外，没有任何段保证会被设置（当前内核会这样做，但旧版本不会）；你应该自己将其设置为 BOOT_DS (0x18)。
完成你的挂钩后，你应该跳转到此字段中先前保存的地址（如果适用，已重定位）。

32 位启动协议
=============

对于一些使用非传统 BIOS 的新 BIOS 机器，如 EFI、LinuxBIOS 等，以及 kexec，基于传统 BIOS 的内核中的 16 位实模式设置代码无法使用，因此需要定义一个 32 位启动协议。
在 32 位启动协议中，加载 Linux 内核的第一步应该是设置启动参数（struct boot_params，传统上称为“零页”）。struct boot_params 的内存应该分配并初始化为全零。然后从内核映像偏移量 0x01f1 开始的设置头应该被加载到 struct boot_params 中并进行检查。设置头的结束位置可以计算如下：

	0x0202 + 偏移量 0x0201 处的字节值

除了读取/修改/写入 struct boot_params 中设置头的内容如同 16 位启动协议那样，引导加载器还应填充 struct boot_params 中其他字段，具体描述参见文档 Documentation/arch/x86/zero-page.rst。
设置完 struct boot_params 后，引导加载器可以以与 16 位启动协议相同的方式加载 32/64 位内核。
在 32 位启动协议中，通过跳转到 32 位内核入口点来启动内核，即加载的 32/64 位内核的起始地址。
在进入时，CPU 必须处于 32 位保护模式且禁用了分页；必须加载 GDT 并包含选择符 __BOOT_CS(0x10) 和 __BOOT_DS(0x18) 的描述符；两个描述符都必须是 4GB 的平坦段；__BOOT_CS 必须具有执行/读权限，而 __BOOT_DS 必须具有读/写权限；CS 必须是 __BOOT_CS，而 DS、ES 和 SS 必须是 __BOOT_DS；中断必须被禁用；%esi 必须持有 struct boot_params 的基址；%ebp、%edi 和 %ebx 必须为零。

64 位启动协议
=============

对于 64 位 CPU 和 64 位内核的机器，我们可以使用 64 位引导加载器，并需要一个 64 位启动协议。
在64位启动协议中，加载Linux内核的第一步应该是设置启动参数（struct boot_params，传统上称为“零页”）。struct boot_params的内存可以分配在任何地方（甚至高于4G）并初始化为全零。然后，应将内核映像上的偏移量0x01f1处的设置头加载到struct boot_params中并进行检查。设置头的结束位置可以通过以下方式计算：

    0x0202 + 偏移量0x0201处的字节值

除了像16位启动协议那样读取/修改/写入struct boot_params的设置头之外，引导加载程序还应该根据Documentation/arch/x86/zero-page.rst章节中的描述填充struct boot_params的其他字段。设置好struct boot_params后，引导加载程序可以以与16位启动协议相同的方式加载64位内核，但是内核可以被加载到高于4G的位置。
在64位启动协议中，通过跳转到64位内核入口点来启动内核，这是加载的64位内核的起始地址加上0x200。
在入口时，CPU必须处于64位模式并启用分页。
从加载内核的起始地址到零页和命令行缓冲区的范围具有设置头(setup_header)的init_size大小的同一映射；必须加载一个全局描述符表(GDT)，其中包含选择器__BOOT_CS(0x10)和__BOOT_DS(0x18)的描述符；两个描述符都必须是4G的平坦段；__BOOT_CS必须具有执行/读取权限，而__BOOT_DS必须具有读写权限；CS必须是__BOOT_CS，而DS、ES、SS必须是__BOOT_DS；必须禁用中断；%rsi必须持有struct boot_params的基地址。

### EFI移交协议（已废弃）

此协议允许引导加载程序将初始化推迟给EFI启动存根。引导加载程序需要从启动介质加载内核/initrd(s)，并跳转到EFI移交协议入口点，该入口点位于startup_{32,64}开头后的hdr->handover_offset字节处。
引导加载程序在处理PE/COFF元数据时**必须**遵守，这些元数据包括部分对齐、可执行映像超出文件本身的内存占用，以及PE/COFF头中可能影响图像作为PE/COFF二进制文件在EFI固件提供的执行环境中正确运行的任何其他方面。
移交入口点的函数原型如下所示：

    efi_stub_entry(void *handle, efi_system_table_t *table, struct boot_params *bp)

'handle'是由EFI固件传递给引导加载程序的EFI图像句柄，'table'是EFI系统表——这些都是UEFI规范第2.3节中所述的“移交状态”的前两个参数。'bp'是由引导加载程序分配的启动参数。
引导加载程序**必须**在bp中填写以下字段：

  - hdr.cmd_line_ptr
  - hdr.ramdisk_image（如果适用）
  - hdr.ramdisk_size（如果适用）

所有其他字段都应该设为零。
注释：EFI移交协议已被废弃，取而代之的是普通的PE/COFF入口点，结合使用基于LINUX_EFI_INITRD_MEDIA_GUID的initrd加载协议（参见[0]了解与此相关的启动加载器示例），这消除了EFI启动加载器需要了解boot_params内部表示、命令行和内存中ramdisk的任何要求或限制以及内核镜像本身的内存放置位置的需求。

[0] https://github.com/u-boot/u-boot/commit/ec80b4735a593961fe701cc3a5d717d4739b0fd0
