### SPDX 许可证标识符: GPL-2.0

### 包含: <isonum.txt>

=================================
总线锁检测与处理
=================================

:版权所有: © 2021 英特尔公司
:作者: - 尤峰华 <fenghua.yu@intel.com>
          - 托尼·拉克 <tony.luck@intel.com>

问题
====

分段锁是指任何操作数跨越两个缓存行的原子操作。由于操作数跨越了两个缓存行，并且该操作必须是原子性的，因此在CPU访问这两个缓存行时系统会锁定总线。通过向写回（WB）内存进行分段锁定访问或对非WB内存进行任何锁定访问来获取总线锁。这通常比在单个缓存行内的原子操作慢数千个周期。它还会影响其他核心的性能，并使整个系统性能下降。

检测
=====

英特尔处理器可能支持以下一种或两种硬件机制来检测分段锁和总线锁：
1. **#AC异常用于分段锁检测**

   从Tremont Atom CPU开始，尝试执行分段锁操作时可能会触发对齐检查（#AC）异常。
   
2. **#DB异常用于总线锁检测**

   某些CPU有能力在用户指令获取总线锁并被执行后通过#DB陷阱通知内核。这使得内核可以终止应用程序或强制执行节流。

软件处理
========

内核的#AC和#DB处理程序根据内核参数“split_lock_detect”处理总线锁。以下是不同选项的总结：

|split_lock_detect=| #AC用于分段锁检测 | #DB用于总线锁检测 |
|---|---|---|
|off| 不做任何处理 | 不做任何处理 |
|warn (默认)| 内核发出警告信息，每个任务仅一次，增加延迟，增加同步以防止多个核心同时执行分段锁。可以通过sysctl split_lock_mitigate避免延迟和同步。当两者都支持时，在#AC中发出警告。| 每个任务仅警告一次并继续运行。|
|fatal| 内核发出警告信息并向用户发送SIGBUS信号| 向用户发送SIGBUS信号 |
|ratelimit:N (0 < N <= 1000)| 不做任何处理 | 限制全系统每秒总线锁次数为N，并在发生总线锁时发出警告 |

用途
====

检测和处理总线锁在多个领域可能有应用：

对于构建整合实时系统的实时系统设计者来说至关重要。这些系统在某些核心上运行硬实时代码，在其他核心上运行“不受信任”的用户进程。硬实时代码无法承受来自不受信任进程的任何总线锁影响实时性能。到目前为止，设计者们无法部署这些解决方案，因为他们没有办法阻止“不受信任”的用户代码生成分段锁和总线锁，从而阻止硬实时代码在总线锁定期间访问内存。

对于通用计算也有用，可以防止来宾或用户应用程序通过执行带有总线锁的指令减慢整个系统的速度。

指导
====

**off**

禁用分段锁和总线锁的检查。如果存在触发这些事件的老式应用程序，其频率较低以至于不需要缓解措施，则此选项可能有用。

**warn**

当检测到总线锁时发出警告，这有助于识别违规的应用程序。这是默认行为。
### 致命情况
在这种情况下，不允许出现总线锁定，并且会终止该进程。

### 限速
---

指定了一个系统范围内的总线锁定速率限制N，其中 0 < N <= 1000。这允许每秒最多N次的总线锁定速率。当超过总线锁定速率时，则通过总线锁定#DB异常捕获到的任何任务将被强制休眠以降低速率直到其再次低于限制。
在可以容忍最小影响的情况下，这是一种有效的缓解措施，但需要防止最终的拒绝服务攻击。它允许识别出违规进程，并分析这些进程是恶意的还是仅仅是编写得不好。
选择1000的速率限制允许每秒最多锁定总线约七百万个周期（假设每次总线锁定需要7000个周期）。在一个2GHz的处理器上，这将导致大约0.35%的系统速度减慢。
