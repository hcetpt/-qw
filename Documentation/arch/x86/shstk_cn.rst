SPDX 许可证标识符: GPL-2.0

======================================================
控制流强制技术 (CET) 阴影栈
======================================================

CET 背景
==============

控制流强制技术 (CET) 涵盖了几种相关的 x86 处理器特性，这些特性提供了针对控制流劫持攻击的保护。CET 可以同时保护应用程序和内核。
CET 引入了阴影栈和间接分支追踪 (IBT)。阴影栈是从内存中分配的第二个栈，不能被应用程序直接修改。当执行 CALL 指令时，处理器会将返回地址推送到普通栈和阴影栈中。在函数返回时，处理器会弹出阴影栈中的副本，并将其与普通栈中的副本进行比较。如果两者不同，则处理器会引发一个控制保护错误。IBT 确认间接 CALL/JMP 目标是经过编译器用 'ENDBR' 操作码标记的预期目标。并非所有 CPU 同时支持阴影栈和间接分支追踪。目前，在 64 位内核中，仅支持用户空间阴影栈和内核 IBT。

使用阴影栈的要求
=================================

要使用用户空间阴影栈，您需要支持它的硬件、配置了该特性的内核以及使用该特性编译的用户空间库。
内核 Kconfig 选项为 X86_USER_SHADOW_STACK。编译时，可以通过内核参数 nousershstk 在运行时禁用阴影栈。
要构建支持用户阴影栈的内核，需要 Binutils v2.29 或 LLVM v6 或更高版本。
在运行时，/proc/cpuinfo 显示处理器支持的 CET 特性。“user_shstk”表示当前内核和硬件支持用户空间阴影栈。

应用启用
====================

应用程序的 CET 能力在其 ELF 注释中标记，并可以从 readelf/llvm-readelf 输出中验证：

    readelf -n <application> | grep -a SHSTK
        属性: x86 特性: SHSTK

内核不直接处理这些应用程序标记。应用程序或加载器必须使用第 4 节中描述的接口来启用 CET 功能。通常这会在动态加载器或静态运行时对象中完成，就像在 GLIBC 中那样。

启用 arch_prctl()
=======================

ELF 特性应该由加载器使用下面的 arch_prctl() 来启用。它们仅在 64 位用户应用程序中受支持。这些特性按线程操作。启用状态会在 clone 时继承，因此如果在第一个线程上启用了特性，它会传播到应用程序的所有线程。

arch_prctl(ARCH_SHSTK_ENABLE, unsigned long feature)
    启用 'feature' 中指定的单个特性。一次只能操作一个特性。
The following translations provide the equivalent text in Chinese:

`arch_prctl(ARCH_SHSTK_DISABLE, unsigned long feature)`
    禁用 'feature' 中指定的单一功能。每次只能操作一个功能。
`arch_prctl(ARCH_SHSTK_LOCK, unsigned long features)`
    将功能锁定在当前启用或禁用的状态。'features' 是所有要锁定的功能的掩码。设置的所有位都将被处理，未设置的位将被忽略。该掩码与现有值进行或运算。因此，这里设置的任何功能位之后都无法启用或禁用。
`arch_prctl(ARCH_SHSTK_UNLOCK, unsigned long features)`
    解锁功能。'features' 是所有要解锁的功能的掩码。所有设置的位都将被处理，未设置的位将被忽略。仅通过 ptrace 方式生效。
`arch_prctl(ARCH_SHSTK_STATUS, unsigned long addr)`
    将当前启用的功能复制到由 addr 指定的地址。使用传递给其他函数的位来描述这些功能。

返回值如下：成功时返回 0；出现错误时，errno 可能为：

        -EPERM 如果传递的任一功能已被锁定
-ENOTSUPP 如果硬件或内核不支持该功能
-EINVAL 参数无效（例如不存在的功能等）
        -EFAULT 如果无法将信息复制回用户空间

支持的功能位包括：

    ARCH_SHSTK_SHSTK - 阴影栈
    ARCH_SHSTK_WRSS  - WRSS

目前通过此接口支持阴影栈和 WRSS。WRSS 只能在启用了阴影栈的情况下启用，并且如果阴影栈被禁用则会自动禁用。

进程状态
========

要检查应用程序是否实际运行在阴影栈上，用户可以读取 `/proc/$PID/status`。它将根据已启用的功能报告“wrss”或“shstk”。示例如下：

    x86_Thread_features: shstk wrss
    x86_Thread_features_locked: shstk wrss

阴影栈的实现
=============

阴影栈大小
-----------

任务的阴影栈从内存中分配，其固定大小为 `MIN(RLIMIT_STACK, 4 GB)`。换句话说，阴影栈分配的最大大小等于常规栈的大小，但上限为 4 GB。对于 `clone3` 系统调用，有一个传递进来的栈大小参数，此时阴影栈使用这个参数而不是 rlimit 的值。

信号
----

主程序及其信号处理程序使用相同的阴影栈。由于阴影栈只存储返回地址，较大的阴影栈可以覆盖主程序栈和信号交替栈同时耗尽的情况。
当发生信号时，旧的信号前状态被推入栈中。当启用阴影栈时，阴影栈特有的状态会被推入阴影栈。现在这仅仅是旧的 SSP（阴影栈指针），以一种特殊格式推入，其中第 63 位被设置。在 `sigreturn` 时，内核验证并恢复这个旧的 SSP 标记。内核还会将常规的恢复地址推入阴影栈，以帮助用户空间避免在经过恢复路径的 `sigreturn` 过程中发生阴影栈违规。
因此，影子栈信号帧格式如下：

    |1...旧SSP| - 指向信号帧令牌格式中旧的信号前的ssp（第63位设置为1）
    |        ...| - 未来可能会在其中添加其他状态

在启用了影子栈的情况下，Linux 不支持32位 ABI 的信号。通过将影子栈分配在32位地址空间之外，Linux阻止了32位执行。当执行进入32位模式时，无论是通过远调用还是返回用户空间，硬件都会生成一个#GP异常，这将作为段错误传递给进程。在切换到用户空间时，寄存器的状态就好像返回到用户空间的指令导致了段错误。

分叉（Fork）
-------------

影子栈的虚拟内存区域（VMA）设置了VM_SHADOW_STACK标志；其页表项（PTE）必须是只读和脏的。当影子栈的PTE不是只读和脏状态时，影子访问会触发带有影子栈访问位被设置的页面故障。
当一个任务创建一个子进程时，它的影子栈PTE会被复制，并且父进程和子进程的影子栈PTE的脏位会被清除。
在下一次影子栈访问时，所产生的影子栈页面故障将通过页面复制/重用来处理。
当创建一个新的pthread子线程时，内核会为新线程分配一个新的影子栈。新影子栈的创建行为类似于使用ASLR的mmap()。同样地，在线程退出时，该线程的影子栈将被禁用。

执行（Exec）
------------

在执行exec操作时，内核会禁用影子栈特性。此时，用户空间可以选择重新启用或锁定它们。
