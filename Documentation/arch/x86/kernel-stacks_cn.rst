### SPDX 许可证标识符: GPL-2.0

#### 内核栈

#### x86-64位的内核栈

大部分文本由 Keith Owens 提供，经 AK 修改。

x86-64 的页大小（PAGE_SIZE）为 4KB。
和其他所有架构一样，x86-64 为每个活动线程提供了一个内核栈。这些线程栈的大小为 THREAD_SIZE（4 * PAGE_SIZE）。
只要一个线程存活或处于僵尸状态，这些栈就包含有用的数据。当线程在用户空间中时，内核栈除了底部的 thread_info 结构体外为空。
除了每个线程的专用栈之外，每个 CPU 还有关联的特殊栈。这些特殊栈仅在该 CPU 处于内核控制下时使用；当 CPU 返回到用户空间时，特殊栈不包含任何有用数据。主要的 CPU 栈包括：

* 中断栈。IRQ_STACK_SIZE

  用于外部硬件中断。如果这是第一个外部硬件中断（即不是嵌套硬件中断），那么内核会从当前任务切换到中断栈。与 i386 上的线程和中断栈分离类似，这样可以为内核中断处理提供更多的空间，而无需增加每个线程栈的大小。
  中断栈同样用于处理软中断（softirq）。
  切换到内核中断栈是通过基于每个 CPU 的中断嵌套计数器的软件来实现的。这是因为 x86-64 “IST” 硬件栈无法在无竞争的情况下嵌套。
  x86-64 还具有 i386 所不具备的一个特性：能够在指定事件（如双故障或非屏蔽中断 NMI）发生时自动切换到新的栈，这使得在 x86-64 上处理这些异常情况变得更加容易。这一特性称为中断栈表（IST）。每个 CPU 最多可以有 7 个 IST 条目。IST 代码是 Task State Segment (TSS) 中的一个索引。TSS 中的 IST 条目指向专用栈；每个栈的大小可以不同。
  当一个中断发生且硬件加载了带有非零 IST 字段值的中断门描述符时，硬件会自动设置新的栈指针，然后调用中断处理程序。如果中断来自用户模式，则中断处理程序的前导部分会切换回线程专用栈。如果软件希望允许嵌套的 IST 中断，则处理程序必须在进入和退出中断处理程序时调整 IST 值。（这种情况偶尔会发生，例如对于调试异常。）

  不同 IST 代码（即使用不同栈）的事件可以嵌套。例如，一个调试中断可以安全地被非屏蔽中断（NMI）中断。arch/x86_64/kernel/entry.S::paranoidentry 在进入和退出所有 IST 事件时调整栈指针，理论上允许相同代码的 IST 事件嵌套。然而，在大多数情况下，分配给 IST 的栈大小假设同一代码不会嵌套。
  如果这一假设被打破，栈将会变得混乱。

目前分配的 IST 栈如下：

* ESTACK_DF。EXCEPTION_STKSZ (PAGE_SIZE)
用于中断8 - 双重故障异常（#DF）
当处理一个异常导致另一个异常时被调用。这种情况发生在
内核非常混乱的时候（例如，内核堆栈指针损坏）
在许多情况下，使用独立的堆栈可以让内核很好地从中恢复，
足以输出一个oops。

* ESTACK_NMI.  EXCEPTION_STKSZ (PAGE_SIZE)
用于不可屏蔽中断（NMI）
NMI可以在任何时候发生，包括内核正在切换堆栈的过程中。
对于NMI事件使用IST避免了对内核堆栈的先前状态做出假设。

* ESTACK_DB.  EXCEPTION_STKSZ (PAGE_SIZE)
用于硬件调试中断（中断1）和软件调试中断（INT3）
在调试内核时，调试中断（无论是硬件还是
软件）都可以在任何时候发生。对于这些中断使用IST避免了
对内核堆栈的先前状态做出假设。
为了正确处理嵌套的#DB，存在两个DB堆栈实例。在
进入#DB时，#DB的IST堆栈指针切换到第二个实例，
这样嵌套的#DB可以从一个干净的堆栈开始。嵌套的#DB将
IST堆栈指针切换到一个保护空洞以捕捉三层嵌套的情况。
* ESTACK_MCE.  EXCEPTION_STKSZ (PAGE_SIZE)
用于中断 18 - 机器检查异常 (#MC)
MCE 可以在任何时候发生，包括内核正在切换栈的过程中。
使用 IST（Interrupt Service Thread，中断服务线程）处理 MCE 事件可以避免对内核栈先前状态的假设。
更多细节请参见 Intel IA32 或 AMD AMD64 架构手册。

x86 上的回溯打印
==================

关于 x86 栈跟踪中函数名前的“?”的问题经常被提出，以下是详细的解释。读者如果能仔细阅读 `print_context_stack()` 和 arch/x86/kernel/dumpstack.c 中的相关机制会有所帮助。
内容改编自 Ingo 的邮件，Message-ID: <20150521101614.GA10889@gmail.com>：

我们总是从栈顶到栈底扫描整个内核栈上存储的返回地址 [1]_，并打印出所有看起来像是内核文本地址的内容。
如果它符合帧指针链，我们会不带问号直接打印出来，因为我们知道这是真实回溯的一部分。
如果地址不符合我们预期的帧指针链，我们仍然会打印它，但是会加上一个“?”。这可能意味着两种情况：

- 要么该地址不属于调用链：这只是内核栈上之前函数调用留下的过时值。这是常见的情况。
- 要么它确实是调用链的一部分，但是在函数内部帧指针没有正确设置，所以我们无法识别它。
这样我们总能打印出真实的调用链（加上一些额外的条目），无论帧指针是否正确设置——但在大多数情况下，我们也能正确得到调用链。打印出来的条目严格按栈顺序排列，因此你也可以从中推断出更多信息。
这种方法最重要的特性是我们_永远不会_丢失信息：我们始终努力打印出栈中所有看起来像是内核文本地址的地址，因此即使调试信息有误，我们仍然会打印出真实的调用链——只是比理想情况下多了些问号。
.. [1] 对于像IRQ和IST栈这样的情况，我们也按照正确的顺序扫描这些栈，并尝试从一个栈过渡到另一个栈来重构调用链。这种方法大多数时候都能奏效。
