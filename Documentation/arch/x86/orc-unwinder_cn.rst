SPDX 许可证标识符: GPL-2.0

==================
ORC 回溯功能
==================

概述
=====

内核的 `CONFIG_UNWINDER_ORC` 选项启用了 ORC 回溯器，其概念上类似于 DWARF 回溯器。不同之处在于 ORC 数据的格式比 DWARF 简单得多，这反过来又允许 ORC 回溯器更加简单和快速。
ORC 数据由 objtool 生成的回溯表组成，它们包含被内核中的 ORC 回溯器使用的额外数据。objtool 通过首先执行编译时栈元数据验证（`CONFIG_STACK_VALIDATION`）来生成 ORC 数据。在分析了 `.o` 文件的所有代码路径后，它确定文件中每个指令地址的栈状态信息，并将这些信息输出到 `.orc_unwind` 和 `.orc_unwind_ip` 段中。
每个对象的 ORC 段在链接时合并，并在启动时进行排序和后期处理。回溯器使用生成的数据在运行时将指令地址与其栈状态相关联。

ORC 与帧指针
=============

启用帧指针后，GCC 会向内核中的每个函数添加仪器代码。内核的 `.text` 大小增加约 3.2%，导致整个内核范围内的性能下降。Mel Gorman 的测量结果 [1]_ 显示某些工作负载下性能下降了 5-10%。
相比之下，ORC 回溯器对 `.text` 大小或运行时性能没有影响，因为调试信息是额外的。因此，如果你禁用帧指针并启用 ORC 回溯器，你将在整个范围内获得良好的性能提升，同时仍然拥有可靠的栈跟踪。
Ingo Molnar 说：

  “需要注意的是，这不仅仅是性能提升，而且也是指令缓存局部性的改进：`.text` 减少 3.2% 直接转化为同样大小的缓存占用减少。对于那些缓存局部性接近极限的工作负载来说，这可能会转化为更高的加速。”

ORC 相比于帧指针的另一个优点是它可以可靠地跨中断和异常进行回溯。基于帧指针的回溯有时可能会跳过被中断函数的调用者，如果该调用者是一个叶函数或者是中断发生在保存帧指针之前的情况。
ORC 回溯器相比于帧指针的主要缺点是它需要更多的内存来存储 ORC 回溯表：根据内核配置大致需要 2-4MB 的内存。

ORC 与 DWARF
=============

ORC 调试信息相比 DWARF 的优势在于它更简单。
它去除了复杂的 DWARF CFI 状态机，也去除了对不必要的寄存器的追踪。这使得回溯器更加简单，意味着更少的错误，这对于关键任务的 oops 代码尤为重要。
更简单的调试信息格式也让解绕器（unwinder）能够比DWARF快得多，这对性能（perf）和锁依赖性检查（lockdep）非常重要。在Jiri Slaby的基本性能测试中_2]，ORC解绕器的速度大约是树外（out-of-tree）DWARF解绕器的20倍。（注：该测量是在加入一些性能优化之前进行的，这些优化使性能翻了一番，因此相对于DWARF的加速可能接近40倍。）

与DWARF相比，ORC数据格式确实有一些缺点。ORC解绕表占用的RAM大约多50%（对于x86缺省配置内核来说+1.3MB）比基于DWARF的eh_frame表。
另一个潜在的缺点是，随着GCC的发展，ORC数据可能会变得过于简单，以至于无法描述某些优化中的栈状态。但在我看来这种情况不太可能发生，因为GCC为它所做的任何异常栈调整都会保存帧指针，所以我怀疑我们实际上只需要跟踪栈指针和帧指针之间的调用帧。但即便最终我们必须像DWARF那样跟踪所有寄存器，至少我们还能控制这个格式，例如不需要复杂的状态机。

### ORC解绕表生成

ORC数据由objtool生成。借助现有的编译时栈元数据验证功能，objtool已经可以跟踪所有的代码路径，因此它已经有了从头开始生成ORC数据所需的所有信息。所以从栈验证到ORC数据生成是一个简单的步骤。
也有可能使用一个简单的工具将DWARF转换为ORC数据。然而，由于内核大量使用了汇编语言、内联汇编以及像异常表这样的特殊段，这样的解决方案将是不完整的。
这可以通过手动使用GNU汇编器的.cfi注释来标注那些特殊的代码路径，并且在.c文件中为内联汇编使用自制的注释来解决。但是过去尝试过使用汇编注释，结果发现它们难以维护。这些注释常常是不正确或不完整的，使得代码更难阅读和保持更新。
根据查看glibc代码的经验，在.c文件中注释内联汇编可能会更糟糕。
尽管objtool仍然需要一些注释，但仅限于对栈做非常规处理的代码，比如入口代码。即使这样，所需的注释也远少于DWARF所需要的，因此它们比DWARF CFI注释更易于维护。
使用objtool生成ORC数据的优点在于它提供了更准确的调试信息，并且几乎不需要注释。这也使内核免受工具链bug的影响，这些问题在内核中处理起来可能非常痛苦，因为我们通常不得不为工具链的老版本中的问题寻找解决办法多年之久。
缺点是解绕器现在依赖于objtool解析GCC代码流的能力。如果GCC的优化变得过于复杂以至于objtool无法跟踪，那么ORC数据生成可能会停止工作或者变得不完整。（值得一提的是，实时补丁已经存在对objtool跟踪GCC代码流能力的依赖。）
如果新版本的GCC引入了一些破坏objtool的优化，我们可能需要重新考虑当前实现。一些可能的解决方案包括要求GCC让优化变得更易于接受，或者让objtool使用DWARF作为额外输入，或者创建一个GCC插件来帮助objtool进行分析。但目前，objtool能很好地跟踪GCC代码。
### 解绕器实现细节

objtool通过集成编译时栈元数据验证功能来生成ORC数据，该功能在tools/objtool/Documentation/objtool.txt中有详细描述。在分析完一个.o文件的所有代码路径后，它会创建一个orc_entry结构数组，以及与这些结构相关的指令地址的并行数组，并将它们分别写入.orc_unwind和.orc_unwind_ip节中。
ORC 数据被分割成两个数组以提升性能，这样做可以让数据的可搜索部分（.orc_unwind_ip）更加紧凑。这两个数组在启动时并行进行排序。
通过在运行时创建一个快速查找表进一步提升了性能。这个快速查找表将给定地址与 .orc_unwind 表中的索引范围关联起来，使得只需要搜索表中的一小部分。
词源学
======

在中世纪民间传说中，兽人是令人畏惧的生物，它们是矮人的天敌。同样地，ORC 解旋器是为了对抗 DWARF 的复杂性和缓慢性而创造出来的。
“尽管兽人很少考虑一个问题的多种解决方案，但它们擅长于行动而非思考，因此在完成任务方面表现出色。”[3]_ 同样地，与复杂的 DWARF 解旋器不同，真实的 ORC 解旋器不会浪费时间和硅基努力来解码变长的零扩展无符号整数字节编码的状态机调试信息条目。
就像兽人经常无情高效地破坏其对手的良好意图一样，ORC 解旋器也常常以无情高效的手段解开堆栈。
ORC 代表 Oops Rewind Capability
.. [1] https://lore.kernel.org/r/20170602104048.jkkzssljsompjdwy@suse.de
.. [2] https://lore.kernel.org/r/d2ca5435-6386-29b8-db87-7f227c2b713a@suse.cz
.. [3] http://dustin.wikidot.com/half-orcs-and-orcs
