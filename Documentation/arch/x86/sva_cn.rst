### SPDX 许可证标识符：GPL-2.0

===========================================
使用 ENQCMD 的共享虚拟寻址（SVA）
===========================================

### 背景
共享虚拟寻址（SVA）允许处理器和设备使用相同的虚拟地址，从而避免了软件需要将虚拟地址转换为物理地址的需求。SVA 是 PCI Express (PCIe) 所称的共享虚拟内存 (SVM)。除了设备可以方便地使用应用程序的虚拟地址之外，它还不需要为了直接内存访问 (DMA) 而固定页面。
PCIe 地址转换服务 (ATS) 加上页请求接口 (PRI) 允许设备像 CPU 处理应用程序的页错误那样工作。更多信息请参考 PCIe 规范第 10 章：ATS 规范。
使用 SVA 需要平台支持 I/O 内存管理单元 (IOMMU)。IOMMU 也是支持 PCIe 特性 ATS 和 PRI 所必需的。ATS 允许设备缓存虚拟地址的转换。IOMMU 驱动程序使用 `mmu_notifier()` 支持来保持设备的 TLB 缓存与 CPU 缓存同步。当 ATS 查找某个虚拟地址失败时，设备应该使用 PRI 请求将虚拟地址分页到 CPU 的页表中。设备必须再次使用 ATS 来获取转换结果才能使用。

### 共享硬件工作队列
与单根 I/O 虚拟化 (SR-IOV) 不同，可扩展 I/O 虚拟化 (SIOV) 允许应用程序和虚拟机 (VM) 使用共享工作队列 (SWQ)。这使得硬件资源利用率更高，避免了硬分区资源可能导致的资源利用不足。为了让硬件能够通过 SWQ 接口区分执行工作的上下文，SIOV 使用进程地址空间 ID (PASID)，这是由 PCIe 标准组织定义的一个 20 位数字。
PASID 值被编码在所有来自设备的事务中。这允许 IOMMU 跟踪每个 PASID 的 I/O 操作，此外还使用了 PCIe 资源标识符 (RID)，即总线/设备/功能。

### ENQCMD
ENQCMD 是 Intel 平台上的一项新指令，它可以原子性地向设备提交一个工作描述符。该描述符包括要执行的操作、所有参数的虚拟地址、完成记录的虚拟地址以及当前进程的进程地址空间 ID (PASID)。
ENQCMD 使用非立即确认语义，并返回状态以指示命令是否被硬件接受。这使得提交者可以知道是否需要重试提交或提供其他特定于设备的机制来实现公平性或确保进展。
ENQCMD 是确保应用程序可以直接向硬件提交命令并允许硬件通过使用 PASID 来了解应用程序上下文进行 I/O 操作的关键。

### 进程地址空间标记
一个新的线程作用域模型特定寄存器 (MSR)（IA32_PASID）提供了用户进程与其他硬件之间的连接。当应用程序首次访问支持 SVA 的设备时，此 MSR 被初始化为一个新的 PASID 分配值。设备驱动程序调用一个特定于 IOMMU 的 API 来设置 DMA 和页请求的路由。
例如，Intel 数据流加速器（DSA）使用 `iommu_sva_bind_device()`，该函数将执行以下操作：

- 分配 PASID，并在 PASID 上下文中编程进程页表（%cr3 寄存器）
- 注册 `mmu_notifier()` 以跟踪任何页表失效，以保持设备 TLB 的同步。例如，当一个页表项被失效时，IOMMU 将此失效传播到设备 TLB。这将迫使设备对这个虚拟地址的任何未来访问参与 ATS。如果 IOMMU 响应正确的回复表明页面不存在，则设备会通过 PCIe PRI 协议请求将页面调入内存，然后执行 I/O 操作
此 MSR 由 XSAVE 特性集作为“监管状态”进行管理，以确保在上下文切换期间更新 MSR。

### PASID 管理

内核必须为每个将要使用 ENQCMD 的进程分配一个 PASID，并将其编程到新的 MSR 中，以便向平台硬件传达进程标识。ENQCMD 使用存储在此 MSR 中的 PASID 来标记来自该进程的请求。当用户使用 ENQCMD 指令向设备提交工作描述符时，描述符中的 PASID 字段会自动填充为 MSR_IA32_PASID 的值。来自设备的 DMA 请求也带有相同的 PASID。平台 IOMMU 使用事务中的 PASID 进行地址转换。IOMMU API 在 IOMMU 中设置与 CPU 使用的进程地址（例如 x86 中的 %cr3 寄存器）对应的 PASID 条目。

在任何应用程序线程可以与设备交互之前，必须在每个逻辑 CPU 上配置此 MSR。属于同一进程的线程共享相同的页表，因此具有相同的 MSR 值。

### PASID 生命周期管理

进程创建时 PASID 初始化为 IOMMU_PASID_INVALID（-1）
只有访问支持 SVA 的设备的进程才需要分配 PASID。这种分配发生在进程打开/绑定支持 SVA 的设备但未为此进程找到 PASID 时。后续打开/绑定相同或其他设备将共享同一个 PASID。

虽然 PASID 是通过打开设备分配给进程的，但它在该进程的任何线程中都不是活动的。当线程尝试使用 ENQCMD 向设备提交工作描述符时，PASID 才被懒加载到 IA32_PASID MSR 中。
首次访问会触发 #GP 故障，因为当设备打开时为进程分配的 PASID 值尚未初始化到 IA32_PASID MSR 中。Linux 的 #GP 处理程序注意到已为进程分配了 PASID，因此初始化 IA32_PASID MSR 并返回，以便重新执行 ENQCMD 指令。

在 fork(2) 或 exec(2) 调用后，由于进程不再拥有打开设备时的相同地址空间，所以从进程中移除 PASID。
在使用clone(2)时，新任务将共享相同的地址空间，因此可以使用为进程分配的PASID。IA32_PASID并没有预先初始化，因为此时PASID值可能尚未分配，或者内核不知道该线程是否会访问设备；清空的IA32_PASID MSR通过xstate初始化优化减少了上下文切换开销。由于必须处理在为进程的mm分配PASID之前创建的所有线程上的#GP故障，新创建的线程也应该被一致地对待。
由于在解除绑定时释放PASID和清除所有线程中的IA32_PASID MSR的复杂性，在mm退出时才懒惰地释放PASID。
如果一个进程执行了设备文件描述符的close(2)操作和设备MMIO端口的munmap(2)操作，则驱动程序将解除绑定设备。对于访问过该设备的进程中任何线程的PASID_MSR中，PASID仍然标记为VALID。但这是无害的，因为在没有MMIO端口的情况下它们无法向设备提交新的任务。
### 关系

* 每个进程有很多线程，但只有一个PASID。
* 设备具有有限数量（大约几十到几千）的硬件工作队列，设备驱动程序管理这些硬件工作队列的分配。
* 单次mmap()映射一个硬件工作队列为“端口”，每个端口映射到一个单独的工作队列。
* 对于与进程交互的每个设备，必须有一个或多个mmap()的端口。
* 进程内的多个线程可以共享一个端口来访问单一设备。
* 多个进程可以分别mmap()同一个端口，在这种情况下，它们仍然共享一个设备硬件工作队列。
* 单个进程范围内的PASID被所有线程用于与所有设备进行交互。例如，并不存在每个线程或每个线程<->设备对的独立PASID。
常见问题解答
==============

* 什么是SVA/SVM？

共享虚拟寻址（SVA）允许I/O硬件和处理器在同一地址空间内工作，即它们可以共享该地址空间。有些人将其称为共享虚拟内存（SVM），但是Linux社区希望避免与已经在使用的POSIX共享内存和安全虚拟机这两个术语混淆。
* 什么是PASID？

进程地址空间ID（PASID）是PCIe定义的事务层包（TLP）前缀。PASID是一个由操作系统分配和管理的20位数字。PASID包含在平台与设备之间所有的事务中。
* 共享工作队列有何不同？

传统上，为了使用户空间应用程序能够与硬件交互，需要为每个进程提供一个单独的硬件实例。例如，可以将门铃视为一种通知硬件有任务要处理的机制。每个门铃都需要间隔4K（或页大小）以实现进程隔离。这要求硬件必须为此预留空间并在MMIO中保留。随着线程数量变得非常大时，这种方法不再适用。硬件还负责管理共享工作队列（SWQ）的队列深度，消费者无需跟踪队列深度。如果无法接收命令，则设备会返回错误指示重试。
用户应该检查设备是否支持延迟内存写入（DMWr）功能，并且仅在设备支持的情况下提交ENQCMD。根据新的DMWr PCIe术语，设备需要支持DMWr完成者功能。此外，还需要所有交换端口都支持DMWr路由，并且必须由PCIe子系统启用，就像如何管理PCIe原子操作一样。
SWQ允许硬件仅在设备中配置单个地址。当使用ENQCMD提交任务时，设备可以通过识别随任务一起提交的分配给该进程的PASID来区分提交任务的进程。这有助于设备扩展到大量进程。
* 这与用户空间设备驱动程序相同吗？

通过共享工作队列与设备通信比完全实现的用户空间驱动程序简单得多。内核驱动程序负责所有硬件初始化工作。用户空间只需要关注提交任务和处理完成情况。
* 这与SR-IOV相同吗？

单根I/O虚拟化（SR-IOV）侧重于为硬件虚拟化提供独立的硬件接口。因此，它需要提供几乎完整的软件接口支持传统的基址寄存器（BAR）、通过MSI-X提供的中断空间以及其自身的寄存器布局。
### 虚拟函数（VFs）由物理函数（PF）驱动辅助
可扩展I/O虚拟化基于PASID概念构建设备实例以实现虚拟化。SIOV要求主机软件协助创建虚拟设备；每个虚拟设备由一个PASID及该设备的总线/设备/功能表示。这使得设备硬件能够优化设备资源的创建，并且可以根据需求动态增长。相比之下，SR-IOV的创建和管理本质上非常静态。详情请参考以下参考资料。
* 为什么不为每个应用程序创建一个虚拟函数？

创建PCIe SR-IOV类型的虚拟函数（VF）成本很高。VFs需要复制PCI配置空间和中断（如MSI-X）等硬件资源。创建时必须将诸如中断这样的资源在VFs之间进行硬性分区，而且无法根据需求动态扩展。VFs并非完全独立于物理函数（PF）。大多数VFs需要与PF驱动程序进行通信并获得其帮助。相反地，SIOV创建了一个软件定义的设备，其中所有的配置和控制方面都通过慢路径进行中介。工作提交和完成无需任何中介。
* 这是否支持虚拟化？

ENQCMD可以在来宾VM内部使用。在这种情况下，VMM会帮助设置一个翻译表，用于从来宾PASID到主机PASID的转换。更多细节请参阅ENQCMD指令集参考。
* 是否需要固定内存？

当设备支持SVA以及平台硬件（如支持此类设备的IOMMU）时，无需为了直接内存访问（DMA）目的固定内存。
支持SVA的设备还支持其他PCIe特性，这些特性消除了对内存固定的需要。
- 设备TLB支持：设备通过地址翻译服务（ATS）请求让IOMMU查找地址。如果存在映射但操作系统未分配页面，则IOMMU硬件会返回不存在映射的信息。
- 设备通过页请求接口（PRI）请求虚拟地址被映射。一旦操作系统成功完成映射，它将响应返回给设备。设备再次请求翻译并继续操作。
- IOMMU与操作系统合作，确保页面表与设备的一致性。在移除页面时，它会与设备交互以移除任何可能已缓存的设备TLB条目，然后才从操作系统中移除映射。
参考文献
==========

VT-D:
https://01.org/blogs/ashokraj/2018/recent-enhancements-intel-virtualization-technology-directed-i-o-intel-vt-d

SIOV:
https://01.org/blogs/2019/assignable-interfaces-intel-scalable-i-o-virtualization-linux

ISE 中的 ENQCMD:
https://software.intel.com/sites/default/files/managed/c5/15/architecture-instruction-set-extensions-programming-reference.pdf

DSA 规范:
https://software.intel.com/sites/default/files/341204-intel-data-streaming-accelerator-spec.pdf
