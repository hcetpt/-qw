### SPDX 许可证标识符：GPL-2.0

==========================
Linux 微码加载器
==========================

**作者：** - 冯华 裕 <fenghua.yu@intel.com>
          - Borislav Petkov <bp@suse.de>
          - Ashok Raj <ashok.raj@intel.com>

内核具有一个 x86 微码加载功能，旨在提供操作系统中的微码加载方法。潜在的应用场景包括：
- 在原始设备制造商（OEM）终止支持之后的平台上更新微码；
- 在无需重启的情况下为长时间运行的系统更新微码。

加载器支持三种加载方法：

#### 早期加载微码
====================

内核可以在启动非常早期阶段更新微码。早期加载微码可以解决在内核启动过程中可能遇到的 CPU 问题。
微码存储在一个 initrd 文件中。在启动过程中，它将从该文件读取并加载到 CPU 核心中。
合并的 initrd 映像格式是（未压缩的）cpio 格式的微码后面跟着（可能已压缩的）initrd 映像。加载器在启动时解析合并的 initrd 映像。
cpio 名称空间中的微码文件为：

对于 Intel：
  kernel/x86/microcode/GenuineIntel.bin
对于 AMD：
  kernel/x86/microcode/AuthenticAMD.bin

在 BSP（引导处理器）启动（SMP 前）期间，内核扫描 initrd 中的微码文件。如果找到与 CPU 匹配的微码，则将在 BSP 和所有 AP（应用处理器）上应用。
加载器还会将匹配的 CPU 微码保存在内存中，因此当 CPU 从睡眠状态恢复时，缓存的微码补丁将被应用。
以下是一个简单的示例，说明如何准备包含微码的 initrd（这通常会由发行版在重新创建 initrd 时自动完成，因此您通常不必自己动手。这里仅记录以供参考）：
```
#!/bin/bash

if [ -z "$1" ]; then
    echo "需要提供一个 initrd 文件"
    exit 1
fi

INITRD="$1"

DSTDIR=kernel/x86/microcode
TMPDIR=/tmp/initrd

rm -rf $TMPDIR

mkdir $TMPDIR
cd $TMPDIR
mkdir -p $DSTDIR

if [ -d /lib/firmware/amd-ucode ]; then
        cat /lib/firmware/amd-ucode/microcode_amd*.bin > $DSTDIR/AuthenticAMD.bin
fi

if [ -d /lib/firmware/intel-ucode ]; then
        cat /lib/firmware/intel-ucode/* > $DSTDIR/GenuineIntel.bin
fi

find . | cpio -o -H newc >../ucode.cpio
cd .
mv $INITRD $INITRD.orig
cat ucode.cpio $INITRD.orig > $INITRD

rm -rf $TMPDIR
```

系统需要将微码包安装到 `/lib/firmware` 或者您需要根据实际情况调整上述路径（例如，如果您是从处理器供应商的网站直接下载的）。
### 延迟加载

你只需安装你的发行版提供的微码包，并运行：

```shell
# echo 1 > /sys/devices/system/cpu/microcode/reload
```

作为root用户
加载机制会在`/lib/firmware/{intel-ucode,amd-ucode}`中查找微码文件。默认的发行版安装包已经将它们放在这里了。
从内核5.19开始，延迟加载不再是默认启用的。
在5.19中移除了`/dev/cpu/microcode`的方法。
为什么延迟加载是危险的？
==============================

### 同步所有CPU
微码引擎接收微码更新，在SMT系统中被两个逻辑线程共享。因此，当在一个SMT线程的核心上执行更新时，另一个线程“自动”也会获得该更新。
由于微码可以“模拟”MSR（模型特定寄存器），所以在微码更新过程中，这些模拟的MSR会暂时不存在。如果SMT兄弟线程恰好正在访问这样的MSR，这可能会导致不可预测的结果。通常观察到的是这种MSR访问会导致生成#GP（通用保护错误）来指示这些寄存器不存在。
消失的MSR只是观察到的一个常见问题。
任何被修补并由另一个SMT兄弟线程同时执行的指令也可能导致类似、不可预测的行为。
为了消除这种情况，引入了一个基于`stop_machine()`的CPU同步机制，以确保所有逻辑CPU不会执行任何代码，而是在一个自旋循环中等待，轮询一个原子变量。
虽然这解决了设备或外部中断、包括LVT类型的IPI（中断请求）如CMCI等问题，但它无法处理其他特殊中断，这些中断不能被关闭。这些特殊中断包括机器检查异常（#MC）、系统管理中断（#SMI）和非屏蔽中断（#NMI）。
机器检查
--------------

机器检查（#MC）是不可屏蔽的。有两种类型的机器检查错误 (MCE)：致命且不可恢复的 MCE 和可恢复的 MCE。虽然不可恢复的错误是致命的，但在内核上下文中发生的可恢复错误也被内核视为致命的。
在某些英特尔机器上，MCE 也会广播给系统中的所有线程。如果一个线程正在执行 WRMSR 操作过程中，MCE 将在该流程的末尾被捕获。无论如何，它们会等待执行 wrmsr(0x79) 的线程与 MCE 处理程序会合，并最终关闭系统中任何一个线程未能加入 MCE 会合的情况。
为了保持谨慎并获得可预测的行为，操作系统可以选择设置 MCG_STATUS.MCIP。由于系统中的 MCE 最多只有一个，如果触发了 MCE，则上述条件将自动导致系统重置。操作系统可以在更新该核心后关闭 MCIP。
系统管理中断
---------------------------

SMI 也广播给平台中的所有 CPU。微码更新请求在写入 MSR 0x79 之前对核心具有独占访问权。因此，如果发生这种情况，即一个线程正在进行 WRMSR 流程，而第二个线程接收到 SMI，则该线程将在 SMI 处理程序的第一条指令处停止。
由于次级线程在 SMI 中的第一条指令处停止，它几乎不可能处于正在打补丁的指令执行过程中。此外，操作系统无法阻止 SMI 的发生。
不可屏蔽中断
-----------------------

当一个核心的线程0正在进行微码更新时，如果线程1被拉入 NMI，这可能会导致不可预测的行为，原因如上所述。
操作系统可以选择多种方法来避免遇到这种情况。
微码是否适合延迟加载？
-------------------------------------------

延迟加载是在系统完全运行并执行实际工作负载时进行的。延迟加载行为取决于升级到新补丁前 CPU 上的基础补丁是什么。
这一点对于英特尔 CPU 是适用的。
例如，假设一个CPU的补丁级别为1，而更新的目标是补丁级别3。
在补丁1和补丁3之间，补丁2可能已经废弃了一个软件可见的功能。
如果软件有可能在使用该功能的话，这是不可接受的。
例如，假设MSR_X在更新后不再可用，
访问这个MSR会导致#GP故障。
基本上，没有方法可以声明一个新的微码更新适合后期加载。这也是导致后期加载默认不启用的问题之一。
内置微码
==========

加载器还支持通过常规内置固件方法CONFIG_EXTRA_FIRMWARE加载内置微码。目前仅支持64位。
这里有一个例子：

```
CONFIG_EXTRA_FIRMWARE="intel-ucode/06-3a-09 amd-ucode/microcode_amd_fam15h.bin"
CONFIG_EXTRA_FIRMWARE_DIR="/lib/firmware"
```

这意味着，你本地有如下目录结构：

```
/lib/firmware/
|-- amd-ucode
..
|   |-- microcode_amd_fam15h.bin
  ..
|-- intel-ucode
  ..
|   |-- 06-3a-09
  ..
```

这段文字描述了如何配置和处理CPU的微码更新，特别是在软件可能依赖于某些特性的情况下如何避免潜在问题，并且提供了一个关于如何设置内置微码的具体示例。
因此，构建系统可以找到这些文件并将它们整合到最终的内核镜像中。早期加载器会找到这些文件并应用它们。
不用说，这种方法并不是最灵活的，因为它要求每次有CPU厂商提供的更新微码时都需要重新构建内核。
