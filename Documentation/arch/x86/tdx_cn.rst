SPDX 许可证标识符: GPL-2.0

=====================================
英特尔信任域扩展 (TDX)
=====================================

英特尔的信任域扩展 (TDX) 通过隔离访客虚拟机的寄存器状态并加密访客内存，保护机密的访客虚拟机免受主机和物理攻击。在 TDX 中，一个特殊模式下运行的特殊模块位于主机与访客之间，并管理访客与主机之间的隔离。

TDX 主机内核支持
=======================

TDX 引入了一种新的 CPU 模式称为安全仲裁模式 (SEAM)，以及由 SEAM 范围寄存器 (SEAMRR) 指向的新隔离范围。一个经过 CPU 认证的软件模块，即“TDX 模块”，在新的隔离范围内运行，以提供管理和运行受保护虚拟机的功能。TDX 还利用了英特尔多密钥全内存加密 (MKTME) 来为虚拟机提供加密保护。TDX 预留了部分 MKTME KeyIDs 作为 TDX 私有 KeyIDs，这些 KeyIDs 只能在 SEAM 模式下访问。BIOS 负责将传统 MKTME KeyIDs 和 TDX KeyIDs 分区。在使用 TDX 模块创建和运行受保护的虚拟机之前，必须将其加载到隔离范围内并正确初始化。虽然 TDX 架构不要求 BIOS 加载 TDX 模块，但内核假设该模块是由 BIOS 加载的。

TDX 启动时检测
-----------------------

内核通过在启动期间检测 TDX 私有 KeyIDs 来检测 TDX。下面的 dmesg 输出显示当 TDX 被 BIOS 启用时的信息：

  [... ] virt/tdx: BIOS 启用：私有 KeyID 范围：[16, 64)

TDX 模块初始化
---------------------------------------

内核通过新的 SEAMCALL 指令与 TDX 模块进行通信。TDX 模块实现了 SEAMCALL 叶子函数，以便内核可以对其进行初始化。
如果未加载 TDX 模块，SEAMCALL 指令将以一个特殊的错误失败。在这种情况下，内核会失败模块初始化并报告模块未被加载：

  [... ] virt/tdx: 模块未加载

初始化 TDX 模块大约需要消耗系统 RAM 大小的 1/256 作为 TDX 内存的“元数据”。它还需要额外的 CPU 时间来初始化这些元数据以及 TDX 模块本身。这两者都不是简单的操作。内核按需在运行时初始化 TDX 模块。
除了初始化 TDX 模块外，在任何其他 SEAMCALL 在某 CPU 上执行之前，必须在该 CPU 上完成每 CPU 的初始化 SEAMCALL。

内核提供了两个函数 tdx_enable() 和 tdx_cpu_enable()，允许 TDX 用户启用 TDX 模块并分别在其本地 CPU 上启用 TDX。
执行 SEAMCALL 需要在该 CPU 上完成 VMXON。目前只有 KVM 实现了 VMXON。现在，tdx_enable() 和 tdx_cpu_enable() 都不会内部执行 VMXON（这不是简单的操作），而是依赖于调用来保证这一点。
为了启用 TDX，调用 TDX 的代码应当执行以下操作：1) 暂时禁用 CPU 热插拔；2) 在所有在线的 CPU 上执行 VMXON 和 tdx_enable_cpu()；3) 调用 tdx_enable()。例如：

        cpus_read_lock();
        on_each_cpu(vmxon_and_tdx_cpu_enable());
        ret = tdx_enable();
        cpus_read_unlock();
        if (ret)
                goto no_tdx;
        // TDX 准备就绪，可以使用

调用 TDX 的代码必须保证在想要运行任何其他 SEAMCALL 之前，tdx_cpu_enable() 已经在每个 CPU 上成功完成。
一个典型的用法是在 CPU 热插拔上线回调中同时执行 VMXON 和 tdx_cpu_enable()，如果 tdx_cpu_enable() 失败，则拒绝上线。
用户可以通过 dmesg 查看 TDX 模块是否已经初始化。
如果 TDX 模块成功初始化，dmesg 将显示如下内容：

  [..] virt/tdx: 为 PAMT 分配了 262668 KB 的内存
  [..] virt/tdx: 模块已初始化

如果 TDX 模块初始化失败，dmesg 同样会显示它初始化失败的信息：

  [..] virt/tdx: 模块初始化失败 ..
TDX 与内核其他组件的交互
-------------------------------

TDX 内存策略
~~~~~~~~~~~~

TDX 报告一系列“可转换内存区域”(CMR)，以告诉内核哪些内存是 TDX 兼容的。内核需要构建一系列内存区域（基于 CMR）作为“TDX 可用”内存，并将这些区域传递给 TDX 模块。一旦完成，这些“TDX 可用”的内存区域在整个模块生命周期中是固定的。
为了简化处理，目前内核只是保证页分配器中的所有页面都是 TDX 内存。具体来说，内核使用核心内存管理（core-mm）在 TDX 模块初始化时刻的所有系统内存作为 TDX 内存，并且同时拒绝任何非 TDX 内存在内存热插拔中的上线。
物理内存热插拔
~~~~~~~~~~~~~~

请注意，TDX 假设可转换内存总是在机器运行期间物理存在。一个无错误的 BIOS 不应支持任何可转换内存的热移除。此实现不处理 ACPI 内存移除，而是依赖于 BIOS 正确行为。
CPU 热插拔
~~~~~~~~~~

TDX 模块要求每个 CPU 的初始化 SEAMCALL 必须在一个 CPU 上完成之后才能在这个 CPU 上进行其他任何 SEAMCALL。内核提供了 tdx_cpu_enable() 来让 TDX 用户在希望使用新 CPU 进行 TDX 任务时完成这个操作。
TDX 不支持物理（ACPI）CPU 热插拔。在机器启动过程中，TDX 在启用 TDX 之前验证所有启动时存在的逻辑 CPU 是否兼容 TDX。一个无错误的 BIOS 不应支持物理 CPU 的热添加/移除。当前内核不处理物理 CPU 热插拔，而是依赖于 BIOS 正确行为。
请注意，TDX 支持 CPU 的逻辑上线/下线，因此内核仍然允许离线逻辑 CPU 并再次上线。
### Kexec()
目前，TDX主机支持缺乏处理kexec的能力。为了简化起见，在Kconfig中只能启用其中一种功能。这个问题将在未来得到解决。

### 错误修正
TDX硬件的前几代存在一个错误。对TDX私有内存缓存行的部分写入会默默地“污染”该行。随后的读取将消费这些污染并触发机器检查。
部分写入是指小于缓存行大小的写入事务到达内存控制器的情况。CPU通过非临时写指令（如MOVNTI）或通过UC/WC内存映射执行这类操作。设备也可以通过DMA进行部分写入。
理论上，内核中的bug可能会对TDX私有内存进行部分写入，并触发意外的机器检查。更糟糕的是，机器检查代码会把这些情况报告为“硬件错误”，尽管实际上是软件触发的问题。但最终，这个问题很难被触发。
如果平台存在这样的错误，内核在机器检查处理器中打印额外的消息以告知用户机器检查可能是由TDX私有内存上的内核bug引起的。

### 与S3和更深状态的交互
TDX无法从S3及更深的状态恢复。当平台进入S3及更深状态时，硬件会重置并完全禁用TDX。这会导致TDX虚拟机及其模块永久性地销毁。
内核使用S3来实现挂起到内存（suspend-to-RAM），而使用S4和更深的状态来实现休眠。目前，为了简化处理，内核选择让TDX与S3和休眠互斥。
当支持休眠时，内核会在早期启动阶段禁用TDX：

  [... ] virt/tdx: 初始化失败：已启用休眠支持

要使用TDX，请在内核命令行中添加`nohibernate`来禁用休眠。
如果启用了TDX，则在内核早期启动阶段禁用ACPI S3。用户需要在BIOS中关闭TDX才能使用S3。

### TDX虚拟机支持
由于主机不能直接访问虚拟机寄存器或内存，许多常规的hypervisor功能必须移至虚拟机内部实现。这是通过虚拟化异常(#VE)来实现的，该异常由虚拟机内核处理。#VE完全在虚拟机内核内部处理，但有些情况下需要咨询hypervisor。
TDX 包含了类似超调用的新机制，用于从客户机向虚拟机监视器或 TDX 模块进行通信。

新的 TDX 异常
-------------

TDX 客户机与裸机和传统 VMX 客户机的行为不同。
在 TDX 客户机中，原本正常的指令或内存访问可能会导致 #VE 或 #GP 异常。
标有 '*' 的指令有条件地引发异常。这些指令的详细信息如下所述。

基于指令的 #VE
~~~~~~~~~~~~~~~~

- 端口 I/O（INS, OUTS, IN, OUT）
- HLT
- MONITOR, MWAIT
- WBINVD, INVD
- VMCALL
- RDMSR*, WRMSR*
- CPUID*

基于指令的 #GP
~~~~~~~~~~~~~~~~

- 所有 VMX 指令：INVEPT, INVVPID, VMCLEAR, VMFUNC, VMLAUNCH, VMPTRLD, VMPTRST, VMREAD, VMRESUME, VMWRITE, VMXOFF, VMXON
- ENCLS, ENCLU
- GETSEC
- RSM
- ENQCMD
- RDMSR*, WRMSR*

RDMSR/WRMSR 行为
~~~~~~~~~~~~~~~~

MSR 访问行为分为三类：

- 生成 #GP
- 生成 #VE
- “直接工作”

通常情况下，在客户机中不应该使用会生成 #GP 的 MSR。它们的使用很可能表明客户机存在错误。客户机可能尝试通过超调用来处理 #GP，但这不太可能成功。
生成 #VE 的 MSR 通常能够由虚拟机监视器处理。客户机可以发出超调用来让虚拟机监视器处理 #VE。
“直接工作”的 MSR 不需要任何特殊的客户机处理。它们可能是通过直接将 MSR 传递给硬件实现的，或者是在 TDX 模块中捕获并处理的。除了可能速度较慢之外，这些 MSR 似乎像在裸机上一样正常工作。

CPUID 行为
~~~~~~~~~~

对于某些 CPUID 叶子及其子叶，虚拟化后的 CPUID 返回值（在客户机 EAX/EBX/ECX/EDX 中）可由虚拟机监视器配置。对于这种情况，Intel TDX 模块架构定义了两种虚拟化类型：

- 虚拟机监视器控制客户机看到的值的位字段（TD）
- 虚拟机监视器配置值使得客户机 TD 要么看到原生值要么看到 0 的位字段。对于这些位字段，虚拟机监视器可以屏蔽掉原生值，但不能开启值
当 TDX 模块不知道如何处理某些 CPUID 叶子及其子叶时，会产生 #VE。此时，客户机内核可以通过超调用来请求虚拟机监视器提供相应的值。
### TDX 中的内存访问
----------------------

本质上，TDX 存在两种类型的内存：私有和共享。
私有内存享有完整的 TDX 保护。其内容受到保护，防止来自虚拟机监视器（hypervisor）的访问。共享内存预期将被来宾（guest）与虚拟机监视器共享，并且不会获得完整的 TDX 保护。
一个信任域（TD）中的来宾可以控制其内存访问是被视为私有还是共享。它通过在其页表条目中设置一个位来选择行为。这有助于确保来宾不会将敏感信息置于共享内存中，从而暴露给不可信的虚拟机监视器。

### TDX 中的共享内存
~~~~~~~~~~~~~~~~~~~~

对共享映射的访问可能会导致 #VE（Virtualization Exception）。虚拟机监视器最终控制着是否由共享内存访问引发 #VE，因此来宾必须小心仅引用那些在发生 #VE 时能安全处理的共享页面。例如，在读取 #VE 信息结构（TDG.VP.VEINFO.GET）之前，来宾应小心不要访问共享内存中的内容。
共享映射的内容完全受虚拟机监视器控制。来宾只应使用共享映射来与虚拟机监视器通信。
共享映射绝不能用于敏感内存内容，如内核堆栈。一个很好的经验法则是，虚拟机监视器共享的内存应当被视为与用户空间映射的内存相同。虚拟机监视器和用户空间都是完全不可信的。
虚拟设备的 MMIO（Memory-Mapped I/O）作为共享内存实现。除非来宾已准备好处理 #VE，否则它必须小心不要访问设备的 MMIO 区域。

### 私有页面上的 #VE
~~~~~~~~~~~~~~~~~~~~

对私有映射的访问也可能导致 #VE。由于所有内核内存同时也是私有内存，理论上内核可能需要处理任意内核内存访问上的 #VE。但这并不可行，因此 TDX 来宾确保所有来宾内存都在被内核使用前已被“接受”。
通常情况下，固件会在内核运行前预接受一小部分内存（通常是 512MB），以确保内核能够启动而不会遭受 #VE。
虚拟机监视器被允许单方面将已接受的页面移至“阻止”状态。但是，如果这样做，则页面访问不会生成 #VE。相反，它会触发一个“TD 退出”，此时要求虚拟机监视器处理异常。
Linux #VE 处理器
--------------

就像页错误或 #GP（通用保护错误），#VE 异常可以被处理或者导致致命错误。通常，未处理的用户空间 #VE 将导致发出 SIGSEGV 信号。而未处理的内核 #VE 将导致系统崩溃（oops）。
在 x86 上处理嵌套异常通常是棘手的事情。一个 #VE 可能被非屏蔽中断 (NMI) 打断，进而触发另一个 #VE，从而产生一系列复杂的情况。TDX 的 #VE 架构预料到了这种场景，并包含了一项功能来使其稍微不那么棘手。
在处理 #VE 期间，TDX 模块确保所有中断（包括 NMI）都被屏蔽。这个屏蔽会一直保持到访客执行 TDG.VP.VEINFO.GET TDCALL。这允许访客控制何时接收中断或新的 #VE。
然而，访客内核仍然需要小心避免可能触发 #VE 的操作（如上所述），当这个屏蔽处于激活状态时。
当屏蔽处于激活状态时，任何 #VE 都会被提升为双重故障 (#DF)，这是不可恢复的。

MMIO 处理
---------

在非 TDX 虚拟机中，MMIO 通常通过给访客提供一个访问时会导致虚拟机退出 (VMEXIT) 的映射来实现，然后由宿主机模拟该访问。而在 TDX 访客中这是不可能的，因为 VMEXIT 会暴露寄存器状态给宿主机。TDX 访客不信任宿主机，不能让它们的状态暴露给宿主机。
在 TDX 中，MMIO 区域通常会在访客中触发 #VE 异常。访客的 #VE 处理程序则在访客内部模拟 MMIO 指令，并将其转换为受控的 TDCALL 到宿主机，而不是将访客状态暴露给宿主机。
在 x86 上，MMIO 地址只是特殊的物理地址。理论上，它们可以通过任何访问内存的指令来访问。
然而，内核指令解码方法是有限制的。它仅设计用于解码像那些由 io.h 宏生成的指令。
通过其他方式（如结构覆盖）访问 MMIO 可能会导致意外情况。

共享内存转换
-------------------------

所有 TDX 客户端内存最初在启动时都是私有的。这部分内存无法被虚拟机监视器访问。然而，一些内核用户（例如设备驱动程序）可能需要与虚拟机监视器共享数据。为此，必须将内存转换为共享或私有状态。这可以通过使用现有的内存加密辅助函数来实现：

- `set_memory_decrypted()` 将一系列页面转换为共享状态
- `set_memory_encrypted()` 将内存转换回私有状态
设备驱动程序是共享内存的主要使用者，但无需修改每个驱动程序。DMA 缓冲区和 `ioremap()` 函数会自动进行转换。
TDX 对大多数 DMA 分配使用 SWIOTLB。SWIOTLB 缓冲区在启动时转换为共享状态。
对于一致性 DMA 分配，DMA 缓冲区会在分配时进行转换。详情请参阅 `force_dma_unencrypted()` 函数。
认证
===========

认证用于在向客户端提供秘密信息之前验证 TDX 客户端的可信度。例如，在释放加密密钥以挂载加密根文件系统或辅助驱动器之前，密钥服务器可能希望使用认证来确认客户端是预期中的那个。
TDX 模块利用构建时间测量寄存器 (MRTD) 和运行时测量寄存器 (RTMR) 记录客户机启动过程各阶段的状态。与客户机初始配置和固件映像相关的测量记录在 MRTD 寄存器中；与初始状态、内核映像、固件映像、命令行选项、initrd、ACPI 表等相关的测量则记录在 RTMR 寄存器中。更多详细信息，请参考 TDX 虚拟固件设计规范中标题为“TD 测量”的部分。
在 TDX 客户端运行时，认证过程用来对这些测量结果进行认证。
认证过程包含两个步骤：TDREPORT 的生成和报价 (Quote) 的生成。
TDX 客户端使用 TDCALL[TDG.MR.REPORT] 从 TDX 模块获取 TDREPORT（TDREPORT_STRUCT）。TDREPORT 是由 TDX 模块生成的固定大小的数据结构，其中包含特定于客户端的信息（如构建和启动测量值）、平台安全版本以及用于保护 TDREPORT 完整性的 MAC。用户提供的 64 字节 REPORTDATA 作为输入并包含在 TDREPORT 中。通常它可以是由证明服务提供的某个随机数，以便 TDREPORT 可以被唯一地验证。
关于 TDREPORT 的更多详细信息可以在 Intel TDX 模块规范中找到，具体见“TDG.MR.REPORT Leaf”一节。
获取到 TDREPORT 后，证明过程的第二步是将其发送给报价飞地（Quoting Enclave，简称 QE）以生成报价（Quote）。设计上，TDREPORT 只能在本地平台上验证，因为 MAC 密钥与平台绑定。为了支持远程验证 TDREPORT，TDX 利用 Intel SGX 报价飞地来在本地验证 TDREPORT，并将其转换为可远程验证的报价。将 TDREPORT 发送给 QE 的方法取决于具体实现。证明软件可以选择任何可用的通信渠道（例如 vsock 或 TCP/IP）来将 TDREPORT 发送给 QE 并接收报价。

### 参考资料

TDX 相关资料汇总如下：

https://www.intel.com/content/www/us/en/developer/articles/technical/intel-trust-domain-extensions.html
