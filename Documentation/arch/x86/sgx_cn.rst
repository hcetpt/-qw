SPDX 许可证标识符: GPL-2.0

===============================
软件防护扩展 (SGX)
===============================

概述
========

软件防护扩展 (SGX) 硬件使得用户空间应用能够划分出私有内存区域以存放代码和数据：

* 特权（环0）ENCLS 函数协调这些区域的构建
* 非特权（环3）ENCLU 函数允许应用进入并在这些区域内执行
这些内存区域被称为飞地。只有在固定的入口点才能进入飞地。每个入口点一次只能容纳一个硬件线程。虽然飞地是从常规二进制文件中通过 ENCLS 函数加载的，但只有在飞地内的线程可以访问其内存。该区域被CPU拒绝外部访问，并且在离开最后一级缓存(LLC)前进行加密。

支持情况可以通过以下命令确定：

```
grep sgx /proc/cpuinfo
```

SGX 必须同时得到处理器的支持并由 BIOS 启用。如果在有硬件支持的系统上 SGX 显得不受支持，请确保在 BIOS 中启用了支持。如果 BIOS 提供了“启用”和“软件启用”两种模式的选择，请选择“启用”。

飞地页缓存
==================

SGX 利用 *飞地页缓存 (EPC)* 来存储与飞地关联的页面。它位于 BIOS 预留的物理内存区域中。
与用于常规内存的页面不同，这些页面只能在使用特殊的、有限的 SGX 指令构造飞地时从飞地外部访问。
只有在飞地内执行的 CPU 可以直接访问飞地内存。
然而，在飞地内执行的 CPU 也可以访问飞地外的正常内存。
内核管理飞地内存的方式类似于处理设备内存的方式。

飞地页类型
------------------

**SGX 飞地控制结构 (SECS)**
   此结构定义了飞地的地址范围、属性和其他全局数据
**常规 (REG)**
   常规EPC页面包含了飞地的代码和数据。

**线程控制结构 (TCS)**
   线程控制结构页面定义了进入飞地的入口点，并跟踪飞地线程的执行状态。

**版本数组 (VA)**
   版本数组页面包含512个槽，每个槽可以存储一个从EPC中被驱逐的页面的版本号。

飞地页缓存映射
----------------------

处理器通过一个称为*飞地页缓存映射 (EPCM)* 的硬件元数据结构来跟踪EPC页面。EPCM为每个EPC页面提供了一个条目，描述了拥有该页面的飞地、访问权限以及页面类型等信息。
EPCM权限与正常的页表权限是分开的。这防止了内核例如允许对飞地希望保持只读的数据进行写入操作。EPCM权限只能在正常的x86页权限之上施加额外的限制。
从所有实际目的来看，SGX架构允许处理器随时无效化所有的EPCM条目。这就要求软件必须准备好在任何时候处理EPCM故障。实际上，这可能发生在像电源转换等事件中，此时加密飞地内存的临时密钥丢失了。

应用接口
=============

飞地构建函数
-----------------------

除了传统的编译器和链接器构建过程之外，SGX还有一个独立的飞地“构建”过程。飞地在被执行（进入）之前必须先构建。构建飞地的第一步是打开 **/dev/sgx_enclave** 设备。由于飞地内存受到直接访问的保护，因此需要使用特殊的特权指令将数据复制到飞地页面并建立飞地页面权限。
.. kernel-doc:: arch/x86/kernel/cpu/sgx/ioctl.c
   :functions: sgx_ioc_enclave_create
               sgx_ioc_enclave_add_pages
               sgx_ioc_enclave_init
               sgx_ioc_enclave_provision

飞地运行时管理
--------------------------

支持SGX2的系统还支持已初始化飞地的更改：修改飞地页面权限和类型，以及动态添加和删除飞地页面。当飞地访问其地址范围内没有后端页面的地址时，则会动态地向飞地添加一个新的常规页面。在飞地可以使用新页面之前，它仍然需要运行EACCEPT对该页面进行处理。
.. kernel-doc:: arch/x86/kernel/cpu/sgx/ioctl.c
   :functions: sgx_ioc_enclave_restrict_permissions
               sgx_ioc_enclave_modify_types
               sgx_ioc_enclave_remove_pages

飞地vDSO
------------

进入飞地只能通过特定于SGX的EENTER和ERESUME函数实现，并且这是一个非简单的过程。因为从和进入飞地之间的过渡非常复杂，所以飞地通常会利用一个库来处理这些实际的过渡。这大致类似于glibc实现被大多数应用程序用来包装系统调用的方式。
另一个飞地的关键特性是它们可以在正常操作中产生需要在飞地内部处理或仅限于SGX的异常。
而不是采用传统的信号机制来处理这些异常，SGX
可以利用vDSO提供的特殊异常修复功能。内核提供的vDSO函数封装了进出飞地的低级别转换，如EENTER和ERESUME。vDSO函数拦截了那些原本会产生信号的异常，并直接将故障信息返回给调用者。这避免了需要处理信号处理器的需求。
.. kernel-doc:: arch/x86/include/uapi/asm/sgx.h
   :functions: vdso_sgx_enter_enclave_t

ksgxd
=====

SGX支持包括一个名为*ksgxd*的内核线程
EPC清理
----------------

*ksgxd*在SGX初始化时启动。飞地内存通常在处理器上电或重置时即可使用。然而，如果自重置以来SGX一直在使用中，飞地页面可能处于不一致状态。这种情况可能会发生在崩溃后进行kexec()循环之后。在启动时，*ksgxd*重新初始化所有飞地页面以便它们能够被分配和再利用。清理过程是通过遍历EPC地址空间并对每个物理页应用EREMOVE函数完成的。某些飞地页面（如SECS页面）对其他页面有硬件依赖性，这会阻止EREMOVE正常工作；执行两次EREMOVE遍历可以移除这些依赖性。
页面回收器
--------------

类似于核心kswapd，*ksgxd*负责管理飞地内存的过度分配问题。如果系统耗尽了飞地内存，*ksgxd*将会把飞地内存“交换”到常规内存中。
启动控制
==============

SGX提供了一个启动控制机制。复制所有飞地页面后，内核执行EINIT函数以初始化飞地。只有在此之后，CPU才能在飞地内部执行指令。
EINIT函数接收一个使用RSA-3072算法签名的飞地测量值。该函数检查测量值是否正确且签名是否由与四个**IA32_SGXLEPUBKEYHASH{0, 1, 2, 3}**模型特定寄存器(MSR)对应的公钥哈希值所签名，这些MSR代表的是公钥的SHA256哈希值。
这些MSR可以通过BIOS配置为可读或可写。Linux仅支持可写配置，以便内核在启动控制策略方面拥有完全控制权。在调用EINIT函数之前，驱动程序设置MSR以匹配飞地的签名密钥。
加密引擎
==================

为了在数据离开CPU封装时隐藏飞地数据，内存控制器配备了一个加密引擎来透明地加密和解密飞地内存。
在Ice Lake之前的CPU中，使用内存加密引擎（MEE）来加密离开CPU缓存的页面。MEE使用一个n元Merkle树，其根存储在SRAM中，以维护加密数据的完整性。这提供了完整性和防重放保护，但由于更新Merkle树所需的时间与内存大小呈对数增长，因此并不适用于大规模内存。
从Icelake开始的CPU使用总内存加密（TME）替代了MEE。基于TME的SGX实现没有完整性Merkle树，这意味着完整性和重放攻击无法得到缓解。不过，它包括额外的变化以防止密文被返回以及创建SW内存别名。
在MEE和TME系统上，通过范围寄存器阻止直接内存访问（DMA）到飞地内存（SDM第41.10节）。
使用模型
============

共享库
--------------

敏感数据及其处理代码从应用程序中分离出来，作为一个独立的库。然后将该库链接为动态共享对象（DSO），可以加载到飞地中。应用程序可以通过特殊的SGX指令向飞地进行单个函数调用。在飞地中配置运行时环境，以将函数参数传递进和传出飞地，并调用正确的库函数。
应用容器
---------------------

一个应用可以被加载到一个包含特别配置的库操作系统和运行时环境的容器飞地中运行。
当线程进入飞地时，飞地运行时环境和库操作系统协同工作以执行应用。
潜在内核SGX漏洞的影响
===================================

EPC泄露
---------

当发生EPC页面泄露时，在dmesg中会显示这样的警告：

"EREMOVE 返回... 并且一个EPC页面被泄露。SGX可能会变得不可用..."

这实际上是内核对EPC页面的use-after-free问题，由于SGX的工作方式，此错误是在释放时被检测到的。而不是将页面添加回可用EPC页面池，内核故意泄露页面以避免未来的更多错误。
当这种情况发生时，内核很可能很快会泄露更多的EPC页面，而SGX可能因为可用于SGX的内存有限而变得不可用。然而，虽然这对SGX可能是致命的，但内核的其他部分不太可能受到影响并应继续工作。
因此，当这种情况发生时，用户应该停止运行任何新的SGX工作负载（或者任何新的工作负载），并将所有有价值的工作负载迁移出去。尽管重启机器可以恢复所有EPC内存，但应该向Linux开发者报告这个bug。
