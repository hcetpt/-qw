IBM "Hypervisor Virtual Console Server" (HVCS) 安装指南
===============================================================

针对 Linux 内核 2.6.4 及以上版本

版权所有 © 2004 IBM 公司

.. ===========================================================================
.. 注意：为了阅读此文件，最佳的编辑器设置是使用八个空格作为制表符。
.. ===========================================================================

作者: Ryan S. Arnold <rsa@us.ibm.com>

创建日期: 2004 年 3 月 2 日
最后修改日期: 2004 年 8 月 24 日

.. 目录:

    1. 驱动程序简介：
    2. 系统要求
    3. 构建选项:
        3.1 内置:
        3.2 模块:
    4. 安装:
    5. 连接:
    6. 断开连接:
    7. 配置:
    8. 常见问题与解答:
    9. 报告错误:

1. 驱动程序简介:
=======================

这是 IBM Hypervisor Virtual Console Server（hvcs）的设备驱动程序。IBM hvcs 提供了一个 tty 驱动程序接口，使 Linux 用户空间应用程序能够访问在同一分区 Power5 ppc64 系统上运行的逻辑分区操作系统（Linux 和 AIX）的系统控制台。在这种硬件上为每个分区提供物理硬件控制台是不实际的，因此通过此驱动程序使用固件接口访问系统控制台来实现虚拟终端设备。

2. 系统要求:
=======================

此设备驱动程序是使用 2.6.4 版本的 Linux 内核 API 编写的，并且仅能在该版本或更高版本的内核中构建和运行。
此驱动程序专为 IBM Power5 ppc64 硬件设计，尽管在抽象架构相关固件调用时已尽量保持代码独立性。
sysfs 必须挂载到系统中，以便用户可以确定与每个 vty-server 关联的主要和次要数字。sysfs 的挂载说明不在本文档范围内。

3. 构建选项:
=================

hvcs 驱动程序作为 tty 驱动程序注册。tty 层动态分配一组由注册驱动程序请求的主要和次要数字。默认情况下，hvcs 驱动程序向 tty 层请求 64 个这样的主/次数字用于 hvcs 设备节点条目。
如果默认数量的设备条目足够，则此驱动程序可以构建到内核中。如果不足够，可以通过使用 insmod 参数将驱动程序作为模块插入来覆盖默认值。
3.1 内置:
-------------

以下 menuconfig 示例演示了选择将此驱动程序构建到内核中的方法：

    设备驱动程序  --->
        字符设备  --->
            <*> IBM Hypervisor Virtual Console Server 支持

开始内核构建过程。
3.2 模块:
-----------

以下 menuconfig 示例演示了选择将此驱动程序构建为内核模块的方法：

    设备驱动程序  --->
        字符设备  --->
            <M> IBM Hypervisor Virtual Console Server 支持

构建过程将生成以下内核模块：

    - hvcs.ko
    - hvcserver.ko

要使用默认分配插入模块，请按出现顺序执行以下命令：

    insmod hvcserver.ko
    insmod hvcs.ko

hvcserver 模块包含特定于架构的固件调用，并且必须首先插入，否则 hvcs 模块将找不到它期望的一些符号。
要覆盖默认值，请使用 insmod 参数（例如请求 4 个 tty 设备）：

    insmod hvcs.ko hvcs_parm_num_devs=4

在 insmod 上可以指定的最大设备条目数量有限制。
我们认为目前允许的最大服务器适配器数量为 1024 是一个合理的数字。这个值可以通过在构建前修改源文件中的常量来更改。
注意：将驱动程序加载到内核所花费的时间似乎与注册驱动程序请求的tty接口数量有关
为了卸载驱动模块，请执行以下命令：

```sh
rmmod hvcs.ko
```

推荐安装hvcs模块的方法是使用`depmod`来在`/lib/modules/$(uname -r)`中构建当前的`modules.dep`文件，然后执行：

```sh
modprobe hvcs hvcs_parm_num_devs=4
```

`modules.dep`文件表明在插入`hvcs.ko`之前需要先插入`hvcserver.ko`，`modprobe`会根据此文件智能地按正确顺序插入模块。
以下`modprobe`命令用于按正确的顺序移除`hvcs`和`hvcserver`：

```sh
modprobe -r hvcs
```

4. 安装：
========

tty层会创建sysfs条目，其中包含为hvcs驱动分配的主要和次要编号。下面是一个`tree`命令输出的sysfs目录示例，展示了这些编号的位置：

```
sys/
|-- *其他sysfs基础目录*
|
|-- class
|   |-- *其他设备类别*
|   |
|   `-- tty
|       |-- *其他tty设备*
|       |
|       |-- hvcs0
|       |   `-- dev
|       |-- hvcs1
|       |   `-- dev
|       |-- hvcs2
|       |   `-- dev
|       |-- hvcs3
|       |   `-- dev
|       |
|       |-- *其他tty设备*
|
|-- *其他sysfs基础目录*
```

对于上述示例，以下是通过`cat`命令读取hvcs目录下的`dev`条目的结果：

```
Pow5:/sys/class/tty/hvcs0/ # cat dev
254:0

Pow5:/sys/class/tty/hvcs1/ # cat dev
254:1

Pow5:/sys/class/tty/hvcs2/ # cat dev
254:2

Pow5:/sys/class/tty/hvcs3/ # cat dev
254:3
```

从`dev`属性读取的结果是tty层为此驱动分配的字符设备的主要和次要编号。大多数运行hvcs的系统已经创建了设备条目或udev会自动完成这项工作。
根据上面的示例输出，要手动创建`/dev/hvcs*`节点条目，可以使用`mknod`命令如下：

```sh
mknod /dev/hvcs0 c 254 0
mknod /dev/hvcs1 c 254 1
mknod /dev/hvcs2 c 254 2
mknod /dev/hvcs3 c 254 3
```

使用`mknod`手动创建设备条目可以使这些设备节点持久化。一旦创建，它们就会在驱动加载前存在。
尝试在插入hvcs模块之前连接应用程序到`/dev/hvcs*`会导致类似以下的错误消息：

```
"/dev/hvcs*: 没有这样的设备"
```
注意：仅仅因为存在设备节点，并不意味着已经为此节点配置了vty-server设备。
5. 连接：
============

由于此驱动控制提供tty接口的设备，用户可以使用任何标准的tty交互方法（例如“cat”，“dd”，“echo”）与设备节点条目进行交互。然而，该驱动的目标是提供实时控制台交互，以与Linux分区的控制台进行交互，这需要使用能够与tty设备双向、交互式I/O的应用程序。
充当终端仿真器的应用程序（如“minicom”和“screen”）或对通过它们的数据执行终端类型控制序列转换的应用程序并不适用于提供交互式控制台I/O。这些程序通常模拟过时的终端类型（vt100和ANSI），并期望传入数据采用支持的终端类型之一的形式，但它们要么不转换，要么不能充分转换传出数据以适应调用它们的终端类型（尽管screen进行了尝试并且显然可以通过大量的termcap操作来进行配置）。

因此，kermit和cu是推荐用于通过hvcs设备与Linux控制台交互的应用程序。这些程序仅仅是数据传输的通道，它们不需要传入数据采取特定的终端类型形式，也不对传出数据进行特定终端类型的处理。
为了确保控制台应用程序的正常运行，在连接到`/dev/hvcs`控制台后，必须确保控制台的`$TERM`环境变量设置为启动交互式I/O应用程序时使用的终端仿真器的确切终端类型。如果使用xterm和kermit连接到`/dev/hvcs0`，当控制台提示出现时，应在控制台上执行`export TERM=xterm`。这告诉从控制台调用的ncurses应用程序应输出xterm可以理解的控制序列。
作为一种预防措施，HVCS（主机虚拟控制台服务）用户在断开诸如Kermit之类的应用程序与设备节点的连接之前，应当始终“退出”他们的会话。如果不这样做，下一个连接到控制台的用户将继续使用前一个用户的登录会话，其中包括使用前一个用户提供的$TERM变量。
热插拔添加和移除VTY服务器适配器会影响用于连接到每个VTY服务器适配器的`/dev/hvcs*`节点。为了确定哪个VTY服务器适配器与哪个`/dev/hvcs*`节点相关联，在每个VTY服务器sysfs条目中增加了一个特殊的sysfs属性。这个条目被称为“index”，显示它会揭示一个指向应使用的`/dev/hvcs*`条目的整数。例如，查看VTY服务器适配器30000004的index属性显示如下：

```
Pow5:/sys/bus/vio/drivers/hvcs/30000004 # cat index
2
```

这个索引值'2'意味着为了连接到VTY服务器适配器30000004，用户应该与`/dev/hvcs2`进行交互。
需要注意的是，由于系统的热插拔I/O能力，特定VTY服务器适配器交互的`/dev/hvcs*`条目在系统重启后不保证保持不变。关于这个问题的更多信息，请参阅问答部分。
6. 断开连接
=============

作为一项防止向未预期目标传递陈旧数据的安全特性，Power5系统固件会在VTY服务器与VTY之间的连接被切断时禁用数据获取并丢弃这些数据。例如，当VTY服务器在向VTY输出数据之后立即从VTY断开连接时，VTY适配器可能没有足够的时间在接收到数据中断和连接被切断之间获取来自固件的数据，因为固件已禁用了数据获取。
当HVCS用于提供控制台服务时，这种行为不是一个大问题，因为适配器在几乎所有数据写入后长时间保持连接状态。然而，当HVCS被用作TTY通道来在两个分区之间传输数据时（请参见下面的问答），这将是一个严重的问题，因为Linux的标准行为是在cat或dd数据到设备时打开TTY，发送数据，然后关闭TTY。如果此驱动程序在TTY关闭时手动终止VTY服务器连接，那么这将在目标VTY有机会获取数据之前关闭VTY服务器和VTY连接。
此外，在模块移除或适配器移除时仅断开VTY服务器和VTY是不切实际的，因为在其他分区中的其他VTY服务器可能随时需要使用目标VTY。
由于这种行为限制，VTY服务器与已连接VTY的断开连接是一项手动操作，通过写入下面概述的一个sysfs属性实现；而另一方面，初始的VTY服务器与VTY的连接由该驱动程序自动建立。无需手动连接VTY服务器。
为了终止VTY服务器与VTY之间的连接，使用了每个VTY服务器的sysfs条目中的“vterm_state”sysfs属性。
读取此属性可以显示VTY服务器适配器的当前连接状态。零表示VTY服务器未连接到VTY。一表示连接活动。
向vterm_state属性写入'0'（零）将仅在vterm_state先前读为'1'的情况下断开VTY服务器与目标VTY之间的VTERM连接。如果vterm_state读为'0'或写入vterm_state属性的值不是'0'，则忽略写入指令。以下示例将展示验证VTY服务器连接状态和断开VTY服务器连接的方法：

```
Pow5:/sys/bus/vio/drivers/hvcs/30000004 # cat vterm_state
1

Pow5:/sys/bus/vio/drivers/hvcs/30000004 # echo 0 > vterm_state

Pow5:/sys/bus/vio/drivers/hvcs/30000004 # cat vterm_state
0
```

当设备热插拔移除或模块移除时，所有VTY服务器连接都会自动终止。
7. 配置
================

每个vty-server在`/sys/devices/vio`目录下都有一个sysfs条目，该条目在多个其他sysfs树目录中被符号链接，特别是位于hvcs驱动程序条目下，如下例所示：

	Pow5:/sys/bus/vio/drivers/hvcs # ls
	.  ..  30000003  30000004  rescan

按设计，固件会通知hvcs驱动程序有关vty-server的生命周期和伙伴vty移除的信息，但不会通知新增加的伙伴vtys。由于HMC超级管理员可以动态添加伙伴信息，我们为hvcs驱动程序的sysfs目录提供了一个名为“rescan”的更新属性，它将查询固件并更新此驱动程序管理的所有vty-servers的伙伴信息。向该属性写入'1'会触发更新。下面是一个明确的例子：

	Pow5:/sys/bus/vio/drivers/hvcs # echo 1 > rescan

读取该属性将指示状态为'1'或'0'。'1'表示正在处理更新，而'0'表示更新已完成或从未执行过。
vty-server在这个目录中的条目是一个由固件创建的32位分区唯一的单元地址。例如，一个vty-server的sysfs条目如下所示：

	Pow5:/sys/bus/vio/drivers/hvcs/30000004 # ls
	.   current_vty   devspec       name          partner_vtys
	..  index         partner_clcs  vterm_state

每个条目默认都提供了一个"name"属性。读取"name"属性会显示设备类型，如下例所示：

	Pow5:/sys/bus/vio/drivers/hvcs/30000003 # cat name
	vty-server

每个条目也默认提供了一个"devspec"属性，读取时会显示完整的设备规范，如下例所示：

	Pow5:/sys/bus/vio/drivers/hvcs/30000004 # cat devspec
	/vdevice/vty-server@30000004

每个vty-server的sysfs目录提供了两个只读属性，它们提供了易于解析的伙伴vty数据列表：“partner_vtys”和"partner_clcs"：

	Pow5:/sys/bus/vio/drivers/hvcs/30000004 # cat partner_vtys
	30000000
	30000001
	30000002
	30000000
	30000000

	Pow5:/sys/bus/vio/drivers/hvcs/30000004 # cat partner_clcs
	U5112.428.103048A-V3-C0
	U5112.428.103048A-V3-C2
	U5112.428.103048A-V3-C3
	U5112.428.103048A-V4-C0
	U5112.428.103048A-V5-C0

读取partner_vtys会返回伙伴vtys的列表。由于vty单元地址编号仅在每个分区内部是唯一的，因此条目会经常重复出现。读取partner_clcs会返回“汇聚位置代码”的列表，这些代码由系统序列号后跟"-V*"（其中'*'为目标分区号）和"-C*"（其中'*'是适配器插槽）组成。第一个vty伙伴对应于第一个clc项，第二个vty伙伴对应于第二个clc项等。
一个vty-server一次只能连接到一个vty。"current_vty"条目打印当前选定伙伴vty的clc。
可以通过向条目写入有效的伙伴clc来更改current_vty，如以下示例所示：

	Pow5:/sys/bus/vio/drivers/hvcs/30000004 # echo U5112.428.10304
	8A-V4-C0 > current_vty

当vty-server已经连接到一个vty时更改current_vty不会影响当前连接。更改在当前打开的连接被释放时生效。
关于"vterm_state"属性的信息已在本章“断开连接”部分中讨论过。
8. 问题与解答：
=======================

问：使用hvcs存在哪些安全方面的顾虑？

答：主要存在三个安全方面的顾虑：

	1. 创建`/dev/hvcs*`节点的人有能力限制某些用户或组访问设备条目。最好是为系统控制台访问创建一个特殊的hvcs组权限。
2. 为了在网络获取控制台时提供安全性，建议用户使用安全的方法（如SSH）连接到控制台托管分区，或者直接坐在硬件控制台上。
3. 使用完控制台后请确保退出用户会话，否则下一个vty-server连接（可能来自另一个分区）可能会体验到之前登录的会话。
---------------------------------------------------------------------------

问：如何通过hvcs获取的控制台进行多路复用以便其他人也能看到？

答：您可以使用"screen"直接连接到`/dev/hvcs*`设备，并使用控制台组权限在您的机器上设置会话。正如前面所指出的，默认情况下screen不提供大多数终端模拟器所需的termcap设置，以从"screen"终端类型到其他类型的字符转换提供足够的支持。这意味着基于curses的程序可能无法在screen会话中正确显示。
---

Q: 为什么颜色都乱了？
Q: 为什么控制字符表现得奇怪或者不起作用？
Q: 为什么控制台输出全都奇怪且无法辨认？

A: 请参阅前面的“连接”部分，讨论应用程序如何影响字符控制序列的显示。此外，仅仅因为你使用 xterm 登录到控制台，并不意味着其他人没有先于你使用 HMC 控制台（vt320）登录控制台并留下登录会话。最好的做法是在获取控制台时将 TERM 设置为你的终端模拟器的类型。此外，请确保在断开与控制台的连接前“退出”控制台。这样可以确保下一个用户在登录时设置他们自己的 TERM 类型。

---

Q: 当我尝试用 Kermit 连接到 hvcs 设备时，我得到如下提示：“抱歉，无法打开连接：/dev/hvcs*”，这是怎么回事？

A: 可能是另一个 Power5 控制台机制占用了虚拟终端并且没有释放它。你可以尝试通过右键点击分区然后选择“关闭终端”来强制从 HMC 断开控制台连接。否则，你需要找到拥有控制台权限的人。有可能你已经在另一个 Kermit 会话中打开了控制台只是忘记了。请查看 Power5 系统的控制台选项以确定系统控制台可能被占用的多种方式。
或者

A: 另一个用户可能当前没有连接到 /dev/hvcs 设备，但 vterm_state 显示他们仍然保持着 vty-server 连接。他们需要按照“断开连接”部分中描述的方法来释放这个连接，以便其他人可以连接到目标 vty。
或者

A: 你用于执行 Kermit 的用户配置文件可能没有使用 /dev/hvcs* 设备的权限。
或者

A: 你可能还没有插入 hvcs.ko 模块，但是 /dev/hvcs* 入口依然存在（在没有 udev 的系统上）
或者

A: 没有一个与现有 /dev/hvcs* 入口对应的 vty-server 设备。

---

Q: 当我尝试用 Kermit 连接到 hvcs 设备时，我得到如下提示：“抱歉，拒绝写入 UUCP 锁定文件目录。”

A: 你指定的 /dev/hvcs* 入口可能不存在于你说的位置？也许你还没有插入模块（对于有 udev 的系统）。

---

Q: 如果我已经安装了一个 Linux 分区，我可以使用该分区上的 hvcs 来为第二个 Linux 分区的安装提供控制台吗？

A: 是的，前提是你是使用 Kermit、cu 或其他不提供终端模拟的程序连接到 /dev/hvcs* 设备。
---

Q: 使用此驱动程序，我可以同时连接到多个分区的控制台吗？

A: 可以。当然，这意味着必须为此分区配置多个vty-server，并且每个都必须指向一个未连接的vty。

---

Q: hvcs驱动程序是否支持动态（热插拔）添加设备？

A: 是的，如果你的系统启用了dlpar和热插拔功能并且这些功能已经构建到内核中，那么hvcs驱动程序被配置为动态处理新设备的添加和未使用设备的移除。

---

Q: 重启后，不知何故/`dev/hvcs*`没有映射到相同的vty-server适配器。发生了什么？

A: 将vty-server适配器分配给/`dev/hvcs*`条目的操作总是按照适配器暴露的顺序进行。由于该驱动程序具有热插拔功能，热插拔添加的vty-server可能与模块加载时的顺序不同。在动态添加之后重新启动或重新加载模块可能会导致如果vty-server适配器在两个其他vty-server适配器之间插入，则/`dev/hvcs*`和vty-server之间的关联发生变化。请参考上面的部分来确定哪个vty-server与哪个/`dev/hvcs*`节点相关联（提示：查看vty-server的sysfs“index”属性）。

---

Q: 我可以使用/`dev/hvcs*`作为管道到另一个分区的通道，并使用该分区上的tty设备作为管道的另一端吗？

A: 是的，在Power5平台上，hvc_console驱动程序为额外的/`dev/hvc*`设备提供了tty接口（其中/`dev/hvc0`很可能是控制台）。为了让两个分区之间的tty通道工作，HMC超级管理员必须通过HMC GUI为目标分区创建一个额外的“串行服务器”，这将在目标分区重启后显示为/`dev/hvc*`。然后，HMC超级管理员为当前分区创建一个额外的“串行客户端”，并将其指向目标分区中新创建的“串行服务器”适配器（记住槽位）。这会显示为一个额外的/`dev/hvcs*`设备。现在可以在目标系统上配置一个程序来读取或写入/`dev/hvc*`，并在当前分区上配置另一个程序来读取或写入/`dev/hvcs*`。现在你就在两个分区之间有了一个tty通道。

---

9. 报告错误：
=============

报告错误的正确渠道是通过提供你的操作系统的Linux发行版公司，或者通过向PowerPC开发邮件列表发送问题：

linuxppc-dev@lists.ozlabs.org

这个请求是为了提供一个记录在案且可搜索的公共交流平台，以便围绕此驱动程序的问题及其解决方案能够为所有用户带来益处。
