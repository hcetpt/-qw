===============================================
Power Architecture 64 位 Linux 系统调用 ABI
===============================================

系统调用 (syscall)
=======

调用
----------
系统调用通过 `sc` 指令发起，并在该指令后的下一条指令处继续执行。
如果 `PPC_FEATURE2_SCV` 出现在 ELF 辅助向量 `AT_HWCAP2` 中，则 `scv 0` 指令是另一种可能提供更好性能的选择，尽管它与调用序列有所不同。
系统调用的调用序列\[1\]与 Power Architecture 64 位 ELF ABI 规范中 C 函数的调用序列相匹配，包括寄存器保留规则，具体差异如下：
.. [1] 部分系统调用（通常是低级管理功能）可能有不同的调用序列（例如，`rt_sigreturn`）。

参数
----------
系统调用号指定在寄存器 `r0` 中。
一个系统调用最多可以有 6 个整数参数，这些参数通过寄存器 `r3` 到 `r8` 传递。

返回值
------------
- 对于 `sc` 指令，会同时返回一个值和一个错误条件。`cr0.SO` 是错误条件，而 `r3` 是返回值。当 `cr0.SO` 清除时，表示系统调用成功，`r3` 中包含的是返回值；当 `cr0.SO` 设置时，表示系统调用失败，`r3` 中包含的是错误值（通常对应于 `errno`）
- 对于 `scv 0` 指令，若返回值为 -4095 至 -1（即无符号比较下 >= -MAX_ERRNO (-4095)），则表示失败，此时错误值是返回值的负值。

栈
-----
系统调用不会修改调用者的栈帧。例如，调用者的栈帧中的 LR 和 CR 保存字段不会被使用。
注册保护规则
---------------------------
注册保护规则与 ELF ABI 调用序列相匹配，但存在一些差异。
对于 sc 指令，与 ELF ABI 的不同之处如下：

+--------------+--------------------+-----------------------------------------+
| 寄存器       | 保护规则           | 目的                                    |
+==============+====================+=========================================+
| r0           | 易失性             | （系统调用编号。）                      |
+--------------+--------------------+-----------------------------------------+
| r3           | 易失性             | （参数 1 及返回值。）                    |
+--------------+--------------------+-----------------------------------------+
| r4-r8        | 易失性             | （参数 2-6。）                          |
+--------------+--------------------+-----------------------------------------+
| cr0          | 易失性             | （cr0.SO 是返回的错误条件。）            |
+--------------+--------------------+-----------------------------------------+
| cr1, cr5-7   | 非易失性           |                                         |
+--------------+--------------------+-----------------------------------------+
| lr           | 非易失性           |                                         |
+--------------+--------------------+-----------------------------------------+

对于 scv 0 指令，与 ELF ABI 的不同之处如下：

+--------------+--------------------+-----------------------------------------+
| 寄存器       | 保护规则           | 目的                                    |
+==============+====================+=========================================+
| r0           | 易失性             | （系统调用编号。）                      |
+--------------+--------------------+-----------------------------------------+
| r3           | 易失性             | （参数 1 及返回值。）                    |
+--------------+--------------------+-----------------------------------------+
| r4-r8        | 易失性             | （参数 2-6。）                          |
+--------------+--------------------+-----------------------------------------+

所有浮点数和向量数据寄存器以及控制和状态寄存器均为非易失性的。
事务内存
--------------------
如果处理器处于事务或暂停事务状态时，系统调用的行为可能会发生变化，并且该系统调用可能会影响事务的行为。
如果在暂停状态时发出系统调用，则系统调用将正常执行并正常返回。系统调用将在暂停状态下执行，因此其副作用将根据常规的事务内存语义持久化。系统调用可能导致硬件使事务失败，也可能不会。
如果在事务状态时发出系统调用，则行为取决于 AT_HWCAP2 ELF 辅助向量中是否存在 PPC_FEATURE2_HTM_NOSC：
- 如果存在（这是较新内核的情况），则不会执行系统调用，内核将通过硬件使交易失败，失败代码为 TM_CAUSE_SYSCALL | TM_CAUSE_PERSISTENT 存储在 TEXASR SPR 中。
- 如果不存在（旧内核），则内核会暂停事务状态并继续执行系统调用，就像在暂停状态下的系统调用一样，并会在返回调用者之前恢复事务状态。这种情况定义不佳，也不受支持，因此不应依赖于这种行为。
scv 0 系统调用总是表现为 PPC_FEATURE2_HTM_NOSC。
ptrace
------
当跟踪系统调用（PTRACE_SYSCALL）时，pt_regs.trap 值包含可以用来区分 sc 和 scv 0 系统调用的系统调用类型，可以据此考虑不同的寄存器约定。
如果 (pt_regs.trap & 0xfff0) 的值为 0xc00，则使用 sc 指令执行了系统调用；如果为 0x3000，则使用 scv 0 指令执行了系统调用。
### vsyscall
vsyscall的调用序列与syscall的调用序列相匹配，但存在以下差异。某些vsyscall可能有不同的调用序列。

#### 参数和返回值
- r0 不作为输入使用。vsyscall通过其地址进行选择。

#### 栈
- vsyscall可能会或可能不会使用调用者的栈帧保存区域。

#### 寄存器保护规则

| 寄存器 | 属性 |
|--------|------|
| r0     | 非保护（易失） |
| cr1, cr5-7 | 非保护（易失） |
| lr     | 非保护（易失） |

#### 调用
- 通过分支链接指令到vsyscall函数地址来执行vsyscall。

#### 事务内存
- vsyscall将在与调用者相同的事务状态下运行。vsyscall可能会或可能不会导致硬件使事务失败。
