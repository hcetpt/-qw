### Coherent Accelerator (CXL) 闪存

#### 引言
IBM Power 架构提供了对 CAPI（Coherent Accelerator Power Interface，一致性加速器电源接口）的支持，该接口在 Power 8 系统的某些 PCIe 插槽中可用。CAPI 可以被视为一种特殊的通过 PCIe 的隧道协议，允许 PCIe 适配器看起来像是专用协处理器，能够读取或写入应用程序的内存并生成页面错误。因此，在 CAPI 模式下运行的适配器的主机接口不需要将数据缓冲区映射到设备的内存（绕过 IOMMU）也不需要固定内存。
在 Linux 中，Coherent Accelerator (CXL) 内核服务通过实现虚拟 PCI 主机桥接器将 CAPI 设备呈现为 PCI 设备。
这种抽象简化了基础设施和编程模型，使得驱动程序类似于其他原生 PCI 设备驱动程序。
CXL 提供了一种机制，使用户空间应用程序可以直接与设备（网络或存储）通信，绕过典型的内核/设备驱动程序栈。CXL 闪存适配器驱动程序使用户空间应用程序可以直接访问闪存存储。
CXL 闪存适配器驱动程序是一个内核模块，位于 SCSI 栈中作为低级设备驱动程序（位于 SCSI 磁盘和协议驱动程序之下），用于 IBM CXL 闪存适配器。此驱动程序负责初始化适配器、设置用户空间访问的特殊路径以及执行错误恢复。它直接与 Flash Accelerator Functional Unit (AFU) 通信，具体描述见 `Documentation/arch/powerpc/cxl.rst`。
cxlflash 驱动程序支持两种互斥的操作模式：

- 任何闪存设备（LUN）都可以配置为常规磁盘设备（例如：/dev/sdc）。这是默认模式。
- 任何闪存设备（LUN）都可以配置为使用一个特殊的块库从用户空间访问。此模式进一步规定了访问设备的方式，并提供了对整个 LUN 的直接访问（称为直接或物理 LUN 访问）或对 LUN 的内核/AFU 调解分区的访问（称为虚拟 LUN 访问）。磁盘设备分割为虚拟 LUN 由 Flash AFU 提供的特殊转换服务协助完成。

#### 概述

Coherent Accelerator Interface Architecture (CAIA，一致性加速器接口架构) 引入了一个主上下文的概念。主通常被内核或虚拟机监视器授予特殊权限，允许其执行 AFU 范围内的管理和控制。主可能不直接参与每次用户 I/O，但至少会在用户应用程序被允许直接向 AFU 发送请求之前涉及最初的设置。
CXL 闪存适配器驱动程序与 AFU 建立了一个主上下文。它使用内存映射 I/O (MMIO) 进行此控制和设置。适配器问题空间内存映射如下所示：

```
                     +-------------------------------+
                     |    512 * 64 KB 用户 MMIO      |
                     |        （每个上下文）          |
                     |       用户可访问              |
                     +-------------------------------+
                     |    512 * 128 B 每个上下文    |
                     |    配置和控制                |
                     |   受信任进程可访问            |
                     +-------------------------------+
                     |         64 KB 全局            |
                     |   受信任进程可访问            |
                     +-------------------------------+
```

此驱动程序作为适配器驱动程序配置到 SCSI 软件栈中。驱动程序是唯一被认为可以编程上述 MMIO 空间中的配置和控制及全局区域的受信任进程。主上下文驱动程序发现所有连接到 CXL 闪存适配器的 LUN，并为每个路径上看到的每个唯一的 LUN 实例化 SCSI 块设备（/dev/sdb、/dev/sdc 等）。
一旦这些 SCSI 块设备被实例化，根据块库提供的规范编写的应用程序就可以从用户空间访问闪存（无需系统调用）。
此主上下文驱动还为该块库提供了一系列的 ioctl，以启用用户空间访问。该驱动支持两种访问块设备的模式。

第一种模式称为虚拟模式。在此模式下，一个 SCSI 块设备（/dev/sdb）可以划分为任意数量的独立虚拟逻辑单元（LUN）。只要所有虚拟 LUN 的大小总和及其相关元数据不超过物理容量，这些虚拟 LUN 可以调整大小。
第二种模式称为物理模式。在此模式下，单个块设备（/dev/sdb）可以直接由块库打开，并且整个 LUN 空间可供应用程序使用。
只有物理模式能保证数据持久性，即写入块设备的数据在应用程序退出和重启以及系统重启后仍然存在。虚拟 LUN 不具备持久性（即，在应用程序终止或系统重启后不会保留）。

块库 API
========

希望从用户空间获取 CXL Flash 访问权限的应用程序应使用块库，因为它抽象了直接与 cxlflash 驱动交互的细节，这些细节对于执行管理操作（例如：设置、拆除、调整大小）是必要的。
块库可以被看作是一个服务使用者，通过 ioctl 实现，这些 ioctl 是 cxlflash 驱动专门为用户空间访问模式下的设备（LUN）提供的。虽然应用程序不需要理解块库与 cxlflash 驱动之间的接口，但下面提供了每个支持的服务（ioctl）的高级概述。
块库可以在 GitHub 上找到：
http://github.com/open-power/capiflash

CXL Flash 驱动 LUN ioctl
========================

希望通过用户空间访问与闪存设备（LUN）进行交互的使用者（如块库），需要使用 cxlflash 驱动提供的服务。由于这些服务是通过 ioctl 实现的，因此首先需要获取文件描述符句柄来建立使用者与内核之间的通信通道。这个文件描述符是通过打开与 LUN 发现过程中创建的 SCSI 磁盘设备（/dev/sdb）关联的设备特殊文件获得的。根据 cxlflash 驱动在 SCSI 协议栈中的位置，实际的打开操作不会被 cxlflash 驱动看到。成功打开后，使用者会收到一个文件描述符（以下简称 fd1），用于发出以下 ioctl。
这些 ioctl 的结构定义可以在以下位置找到：
uapi/scsi/cxlflash_ioctl.h

DK_CXLFLASH_ATTACH
------------------

此 ioctl 通过 CXL 内核服务获取、初始化并启动一个上下文。这些服务通过指定一个上下文 ID（u16）来唯一标识该上下文及其分配的资源。此外，服务还提供第二个文件描述符（以下简称 fd2），该文件描述符由块库用来对 CXL 闪存设备发起内存映射 I/O（通过 mmap()）以及轮询完成事件。这个文件描述符是特意由本驱动安装而非由 CXL 内核服务安装的，以便在非用户主动关闭（如进程被杀掉）的情况下允许中间通知和访问。关于这一点的设计细节在 DK_CXLFLASH_DETACH ioctl 的说明中有更详细的描述。

关于返回给使用者的“令牌”（上下文 ID 和 fd2）有几个重要的方面：

- 这些令牌仅对创建它们的过程有效。分叉过程的子进程不能继续使用其父进程创建的上下文 ID 或文件描述符（请参阅 DK_CXLFLASH_VLUN_CLONE 获取更多详细信息）。
- 这些令牌仅在其创建时的上下文生命周期及所属过程生命周期内有效。一旦上下文或过程被销毁，这些令牌将被视为过期，后续使用会导致错误。
- 仅在初始连接上下文时返回有效的适配器文件描述符（fd2 >= 0）。对于已存在的上下文的后续连接（存在DK_CXLFLASH_ATTACH_REUSE_CONTEXT标志），不会提供适配器文件描述符，因为它之前已经告知了应用程序。
- 当不再需要一个上下文时，用户应当通过DK_CXLFLASH_DETACH ioctl从该上下文分离。当ioctl返回一个有效的适配器文件描述符并且带有DK_CXLFLASH_APP_CLOSE_ADAP_FD返回标志时，应用程序_必须_在成功分离后关闭适配器文件描述符。
- 当ioctl返回一个有效的fd2和带有DK_CXLFLASH_APP_CLOSE_ADAP_FD返回标志时，应用程序_必须_在以下情况下关闭fd2：

		+ 成功分离上下文的最后一个用户之后
		+ 在上下文的原始fd2上成功恢复之后
		+ 在fork()产生的子进程中，在clone ioctl之后，对与源上下文关联的fd2上

- 在任何时候，关闭fd2将使令牌失效。应用程序应谨慎行事，只在适当的时候（如前所述）关闭fd2，以避免过早丢失I/O。

### DK_CXLFLASH_USER_DIRECT
此ioctl负责将逻辑单元（LUN）转换为直接（物理）模式访问，并针对每个上下文配置AFU以允许用户空间直接访问。此外，返回给用户的块大小和最后一个逻辑块地址（LBA）。
如前所述，在用户空间访问模式下运行时，可以整体或部分地访问LUN。一次只允许一种模式，如果一种模式正在使用中（存在未完成的引用），则拒绝使用LUN的其他模式请求。
AFU通过向其资源句柄表添加条目来配置为用户空间直接访问。条目的索引被视为资源句柄并返回给用户。然后用户可以使用该句柄在I/O期间引用LUN。

### DK_CXLFLASH_USER_VIRTUAL
此ioctl负责将LUN转换为虚拟模式访问，并针对每个上下文配置AFU以允许用户空间虚拟访问。此外，返回给用户的块大小和最后一个逻辑块地址（LBA）。
如前所述，在用户空间访问模式下运行时，可以整体或部分地访问LUN。一次只允许一种模式，如果一种模式正在使用中（存在未完成的引用），则拒绝使用LUN的其他模式请求。
AFU通过向其资源句柄表添加条目来配置为用户空间虚拟访问。条目的索引被视为资源句柄并返回给用户。用户随后可以使用该句柄在I/O期间引用LUN。
默认情况下，虚拟LUN创建时大小为0。用户需要使用DK_CXLFLASH_VLUN_RESIZE ioctl来调整虚拟LUN的增长到所需大小。为了避免在首次创建虚拟LUN时执行此类调整大小操作，用户可以选择在DK_CXLFLASH_USER_VIRTUAL ioctl中指定大小，这样当成功返回给用户时，提供的资源句柄已经指向预分配的存储空间。这体现在最后一个LBA为非零值。
当一个逻辑单元号（LUN）可以从多个端口访问时，此ioctl将返回带有`DK_CXLFLASH_ALL_PORTS_ACTIVE`返回标志。这为用户提供了一个提示，即在发生I/O错误时可以重试I/O操作，因为该LUN可以通过多条路径访问。

`DK_CXLFLASH_VLUN_RESIZE`
-------------------------
此ioctl负责调整之前创建的虚拟LUN的大小，并且如果调用时LUN不处于虚拟模式则会失败。成功后，会向用户返回更新后的最后一个逻辑块地址（LBA），指示与资源句柄关联的虚拟LUN的新大小。
虚拟LUN的分区由cxlflash驱动程序和AFU共同管理。对于每个处于虚拟模式下的LUN，都维护有一个分配表，并用于编程LUN转换表，AFU在接收到资源句柄时会引用这个表。
此ioctl可能会返回-EAGAIN，如果AFU同步操作耗时过长。
除了向用户返回失败外，cxlflash还会安排一个异步AFU重置。如果用户选择重试该操作，预计会成功。如果此ioctl失败并返回-EAGAIN，用户可以选择重试操作或将其视为失败。

`DK_CXLFLASH_RELEASE`
---------------------
此ioctl负责释放先前获取的对物理或虚拟LUN的引用。这可以认为是`DK_CXLFLASH_USER_DIRECT`或`DK_CXLFLASH_USER_VIRTUAL` ioctl的逆操作。成功后，资源句柄不再有效，并且资源句柄表中的条目可供再次使用。
作为虚拟LUN释放过程的一部分，首先将虚拟LUN调整为0大小以清除并释放与虚拟LUN引用相关的转换表。

`DK_CXLFLASH_DETACH`
--------------------
此ioctl负责从cxlflash驱动程序中注销一个上下文，并释放未通过`DK_CXLFLASH_RELEASE` ioctl明确释放的资源。成功后，所有从`DK_CXLFLASH_ATTACH`开始提供给用户的“令牌”均不再有效。
如果在成功的attach操作中返回了`DK_CXLFLASH_APP_CLOSE_ADAP_FD`标志，则应用程序必须在上下文的最终用户detach后关闭与该上下文关联的fd2。

`DK_CXLFLASH_VLUN_CLONE`
------------------------
此ioctl负责克隆一个先前创建的上下文到一个较新创建的上下文中。它仅用于支持进程fork后用户空间对存储的访问保持不变。成功后，子进程（调用了ioctl的进程）将能够通过相同的资源句柄访问相同的LUNs，但这些LUNs是在不同的上下文中可用。
跨进程上下文共享在CXL中不受支持，因此每个fork操作都必须为子进程建立一个新的上下文。这个ioctl简化了在这种情况下用户所需的状态管理和回放。当一个进程进行fork时，子进程可以通过首先创建一个上下文（通过DK_CXLFLASH_ATTACH）然后使用此ioctl从父进程到子进程执行克隆来克隆父进程的上下文。
克隆本身相对简单。资源句柄和LUN转换表从父上下文复制到子进程的上下文中，然后与AFU同步。
如果在成功attach后返回了DK_CXLFLASH_APP_CLOSE_ADAP_FD标志，则应用程序**必须**在克隆之后关闭与源上下文（仍然驻留在父进程中且可访问）相关的fd2。这是为了避免子进程文件描述符表中的陈旧条目。
如果AFU同步操作耗时过长，此ioctl可以返回-EAGAIN。
除了向用户返回失败之外，cxlflash还会安排异步AFU重置。如果用户选择重试该操作，预期会成功。如果此ioctl因-EAGAIN失败，用户可以选择重试该操作或将其视为失败。

### DK_CXLFLASH_VERIFY

这个ioctl用于检测各种变化，例如磁盘容量的变化、可见LUN数量的变化等。在某些变化影响应用程序的情况下（如LUN调整大小），cxlflash驱动程序将向应用程序报告变化状态。
用户在想要验证LUN是否已发生变化以响应检查条件时调用此ioctl。由于用户是在内核之外运行的，他们会看到这些类型的事件而内核并不知晓。遇到这种情况时，用户的架构行为是调用此ioctl，指示他们想要验证的内容，并传递任何适当的信息。目前，仅支持通过sense数据验证LUN变化（即：大小不同）。

### DK_CXLFLASH_RECOVER_AFU

这个ioctl用于驱动指定用户上下文的恢复（如果需要此类操作）。在成功恢复后，与用户上下文相关的任何状态都会被重新建立。
当设备需要重置或终止时，用户上下文会被置于错误状态。用户通过在MMIO读取时看到全0xF来得知这种错误状态。遇到这种情况时，用户的架构行为是调用此ioctl来恢复他们的上下文。用户也可以随时调用此ioctl来检查设备是否正常运行。如果从此ioctl返回失败，用户应优雅地通过release/detach ioctl清理他们的上下文。在此之前，他们持有的上下文不会被释放。用户还可以选择退出进程，在这种情况下，他们持有的上下文/资源将在释放fop过程中被释放。
如果在成功attach后返回了DK_CXLFLASH_APP_CLOSE_ADAP_FD标志，则应用程序**必须**在该ioctl返回成功并指示上下文已被恢复（DK_CXLFLASH_RECOVER_AFU_CONTEXT_RESET）后取消映射并关闭与原始上下文相关的fd2。
### DK_CXLFLASH_MANAGE_LUN
---
此 ioctl 用于将 LUN 从可用作文件系统访问（传统模式）的状态切换到专供用户空间独占访问（超级管道模式）的状态。如果一个 LUN 可以在多个端口和适配器上看到，此 ioctl 通过其全球节点名称 (WWNN) 来唯一标识每个 LUN。

### CXL Flash 驱动程序主机 IOCTLs
==================================

由 cxlflash 驱动程序支持的每个主机适配器实例都有一个与其关联的特殊字符设备，以便启用一系列主机管理功能。这些字符设备托管在一个专门为 cxlflash 设定的类中，并可通过 `/dev/cxlflash/*` 访问。
可以编写应用程序来使用以下主机 ioctl API 执行各种功能。
这些 IOCTL 的结构定义可在以下位置找到：
`uapi/scsi/cxlflash_ioctl.h`

### HT_CXLFLASH_LUN_PROVISION
-----------------------------
此 ioctl 用于在缺少外部 LUN 管理接口的 cxlflash 设备上创建和删除持久性 LUN。仅当与支持 LUN 提供能力的 AFU 一起使用时才有效。
当有足够的空间时，可以通过指定承载 LUN 的目标端口和所需的大小（以 4K 块为单位）来创建 LUN。成功后，会返回创建的 LUN 的 LUN ID 和 WWID，并且可以扫描 SCSI 总线来检测 LUN 拓扑的变化。请注意，部分分配是不支持的。如果由于空间问题而导致创建失败，则可以查询目标端口以获取其当前的 LUN 几何信息。
要移除 LUN，必须首先使设备与 Linux SCSI 子系统分离。然后可以通过指定目标端口和 LUN ID 来启动 LUN 删除操作。成功后，与端口关联的 LUN 几何信息将更新以反映新分配的 LUN 数量和可用容量。
为了查询端口的 LUN 几何信息，需要指定目标端口。成功后，将呈现以下信息：

- 允许为此端口配置的最大 LUN 数量
- 此端口当前配置的 LUN 数量
- 此端口配置的 LUN 的最大总容量（4K 块）
- 此端口配置的 LUN 的当前总容量（4K 块）

有了这些信息，就可以计算出可用的 LUN 数量和容量。

### HT_CXLFLASH_AFU_DEBUG
-------------------------
此 ioctl 用于通过支持命令传递接口来调试 AFU。仅当与支持 AFU 调试能力的 AFU 一起使用时才有效。
除了缓冲区管理之外，AFU 调试命令对于 cxlflash 是不透明的，并被视为传递。对于需要数据传输的调试命令，用户需要提供适当大小的数据缓冲区，并且必须根据主机指定数据传输方向。存在最大 256K 的传输大小限制。请注意，不支持部分读取完成 — 当主机读取数据传输过程中遇到错误时，数据缓冲区不会复制回用户。
