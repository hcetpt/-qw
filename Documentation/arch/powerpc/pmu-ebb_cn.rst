========================
基于事件的分支 (PMU EBB)
========================

基于事件的分支 (EBBs) 是一种特性，它允许硬件在特定事件发生时直接跳转到指定的用户空间地址。完整的规范可以在 Power ISA v2.07 中找到：

  https://www.power.org/documentation/power-isa-version-2-07/

EBBs 可以配置的一种事件类型是 PMU 异常。本文档描述了使用 Linux 的 perf_events API 配置 Power PMU 生成 EBBs 的 API。
术语
--------------

在整个文档中，我们将提到“EBB 事件”或“EBB 事件”。这仅指设置了其 attr.config 中的“EBB”标志的 struct perf_event。所有能够在硬件 PMU 上配置的事件都是可能的“EBB 事件”。
背景
--------------

当发生 PMU EBB 时，它会被传递给当前运行的进程。因此，EBB 只能被程序用于自我监控。

perf_events API 的一个特点是，可以在其他进程中创建事件（需经过标准权限检查）。这对 EBB 事件同样适用。然而，除非目标进程通过 mtspr(BESCR) 启用了 EBB，否则不会有任何 EBB 被传递。

这使得一个进程可以为自己启用 EBB，但实际上不配置任何事件。稍后，另一个进程可以附加一个 EBB 事件到该进程中，从而导致 EBB 被传递给第一个进程。目前尚不清楚这种用法是否实际有用。

当 PMU 配置为使用 EBB 时，所有的 PMU 中断都会传递给用户进程。这意味着一旦在 PMU 上调度了一个 EBB 事件，就不能再配置非 EBB 事件。这意味着 EBB 事件不能与常规的 'perf' 命令或其他 perf 事件同时运行。

然而，在使用 EBB 的进程中运行 'perf' 命令是安全的。通常情况下，内核会调度 EBB 事件，并且 perf 会收到通知，表明其事件无法运行。

EBB 事件和常规事件之间的排他性是通过使用 perf_events 已有的 "pinned" 和 "exclusive" 属性实现的。这意味着 EBB 事件将优先于其他事件，除非它们也被固定。

如果一个 EBB 事件和一个常规事件都被固定，则首先启用的事件会被调度，而另一个则会进入错误状态。有关更多信息，请参阅下面标题为“启用 EBB 事件”的部分。
创建一个EBB事件
---------------------

为了请求使用EBB来计数某个事件，事件代码的第63位应被设置。
EBB事件必须使用特定且受限的一组属性来创建——这是为了确保它们能与perf_events子系统的其他部分正确协同工作。
创建EBB事件时必须设置“pinned”和“exclusive”属性。
请注意，如果您正在创建一组EBB事件，则只有领导事件可以设置这些属性。
创建EBB事件时不得设置任何“inherit”、“sample_period”、“freq”或“enable_on_exec”属性。
EBB事件必须附加到一个任务上。这通常是通过向perf_event_open()传递一个pid值来指定的，通常为0，表示当前任务。
组内的所有事件必须就是否需要EBB达成一致。也就是说，要么所有事件都请求使用EBB，要么都不请求使用EBB。
EBB事件必须指定其将在哪个PMC上进行计数。这样可以确保用户空间能够可靠地确定事件被调度在哪个PMC上。

启用一个EBB事件
---------------------

一旦成功打开了一个EBB事件，就必须通过perf_events API将其启用。这可以通过ioctl()接口或者prctl()接口实现。
然而，由于perf_events API的设计，启用一个事件并不能保证它已经被调度到PMU上。为了确保EBB事件已经被调度到PMU上，您必须对事件执行一次读取(read())操作。如果读取返回EOF，则说明事件尚未被调度，EBB功能未启用。
这种行为的发生是因为EBB事件是固定的（被钉住的）且具有排他性。当EBB事件被启用时，它会强制PMU（性能监控单元）上的所有其他非固定事件停止。在这种情况下，启用操作将会成功。然而，如果PMU上已经有一个事件被固定，则此次启用将不会成功。

读取EBB事件
------------

可以对EBB事件进行`read()`操作。但是，读取的结果没有意义。因为中断正在被传递给用户进程，内核无法计数该事件，因此返回的是无效值。

关闭EBB事件
------------

当不再需要使用EBB事件时，可以像处理普通事件一样使用`close()`来关闭它。如果这是最后一个EBB事件，PMU将被取消配置，并且不会再接收进一步的PMU EBB事件。

EBB处理器
----------

EBB处理器只是普通的用户空间代码，但它必须按照中断处理器的风格编写。当进入处理器时，所有寄存器都是活动状态（可能是这样），因此在调用其他代码之前，必须以某种方式保存它们。

程序如何处理这一点取决于具体实现。对于C程序而言，一个相对简单的选项是在栈上创建一个中断帧并将寄存器保存在那里。

Fork
----

EBB事件不会通过`fork`继承给子进程。如果子进程希望使用EBB事件，应该为自己打开一个新的事件。同样地，在`fork()`之后，BESCR/EBBHR/EBBRR中的EBB状态会被清除。
