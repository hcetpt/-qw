==================================================
飞思卡尔QUICC引擎固件上传
==================================================

(c) 2007 提姆·塔比 <timur at freescale.com>,
    飞思卡尔半导体

.. 目录

   I - 固件软件许可

   II - 微码可用性

   III - 描述与术语

   IV - 微码编程细节

   V - 固件结构布局

   VI - 创建固件文件的示例代码

修订信息
========

2007年11月30日: 第1.0版 - 初始版本

I - 固件软件许可
==================

每个固件文件都带有其自身的软件许可。有关特定许可的信息，请参阅随固件分发的许可文本。
II - 微码可用性
==================

固件文件通过各种渠道分发。有些可以在 http://opensource.freescale.com 上获得。对于其他固件文件，请联系您的飞思卡尔代表或操作系统供应商。
III - 描述与术语
==================

在本文档中，术语“微码”指的是构成实际QE微码的32位整数序列。
术语“固件”指的是包含微码以及其他数据的二进制文件，这些数据：

    1) 描述了微码的目的
    2) 描述了如何以及在哪里上传微码
    3) 指定了各种寄存器的值
    4) 包括供特定设备驱动程序使用的额外数据

固件文件是仅包含固件的二进制文件。
IV - 微码编程细节
======================

QE架构只允许每个RISC处理器的I-RAM中存在一个微码。要替换任何当前微码，必须首先执行完整的QE重置（这会禁用微码）。
使用以下步骤上传QE微码：

1) 使用IRAM.IADD和IRAM.IDATA寄存器将微码放置到I-RAM的特定位置
2) 根据固件是否需要分割I-RAM，将CERCR.CIR位设置为0或1。分割I-RAM仅对具有多个RISC处理器的QE的SOC有意义，例如8360。分割I-RAM允许每个处理器运行不同的微码，从而有效地创建了一个非对称多处理(AMP)系统
3) 将TIBCR陷阱寄存器加载为微码中的陷阱处理程序地址
4) 对RSP.ECCR寄存器进行编程以提供指定的值
5) 如果有必要，需要虚拟陷阱和扩展模式数据的设备驱动程序将使用它们
### 虚拟微码陷阱

这些虚拟陷阱是微码中的条件分支。它们是在ROM代码中引入的“软”暂定指令，以实现更高的灵活性并节省硬件陷阱。如果激活了新功能或在RAM包中修复问题时应激活它们。此数据结构指示哪些虚拟陷阱处于活动状态。该结构包含6个字，应用程序需要将其复制到一些预先定义的具体位置。下表描述了该结构：

|-----------------------|------------------|---------------------|-----------|
| 在数组中的偏移量 | 协议             | 在PRAM中的目标偏移量 | 操作数大小 |
|-----------------------|------------------|---------------------|-----------|
|      0                | 以太网           |       0xF8          | 4 字节    |
|                       | 交互工作         |                     |           |
|-----------------------|------------------|---------------------|-----------|
|      4                | ATM              |       0xF8          | 4 字节    |
|                       | 交互工作         |                     |           |
|-----------------------|------------------|---------------------|-----------|
|      8                | PPP              |       0xF8          | 4 字节    |
|                       | 交互工作         |                     |           |
|-----------------------|------------------|---------------------|-----------|
|     12                | 以太网接收       |       0x22          | 1 字节    |
|                       | 分发页           |                     |           |
|-----------------------|------------------|---------------------|-----------|
|     16                | ATM全局参数表    |       0x28          | 1 字节    |
|                       | 参数表           |                     |           |
|-----------------------|------------------|---------------------|-----------|
|     20                | 插入帧           |       0xF8          | 4 字节    |
|-----------------------|------------------|---------------------|-----------|

### 扩展模式

这是一个双字位数组（64位），定义了对软件驱动程序有影响的特殊功能。每个位都有其特定的影响，并且与之相关的软件有特殊的指令。下面的表格描述了该结构：

|-------------------|------------|------------------------------------|
| 位号              | 名称       | 描述                               |
|-------------------|------------|------------------------------------|
|   0               | 通用推送命令 | 表示在应用发出每个主机命令前，软件必须设置一个特殊的主机命令（推送命令）：CECDR = 0x00800000；CECR = 0x01c1000f。 |
|-------------------|------------|------------------------------------|
|   1               | UCC ATM RX INIT | 表示在发送ATM RX INIT命令后，主机必须发出另一个特殊推送命令，并立即重新发送ATM RX INIT命令。 |
|                   |             | CECDR = 0x00800000；CECR = 0x01c1000f。 |
|-------------------|------------|------------------------------------|
|   2               | 添加/删除验证 | 表示在执行“添加/删除哈希查找表条目”的特定主机命令之后，用户必须发出另一个命令。 |
|                   |             | CECDR = 0xce000003；CECR = 0x01c10f58。 |
|-------------------|------------|------------------------------------|
|   3               | 通用推送命令 | 表示软件必须初始化以太网线程页面中的一些指针，这些指针在启用头部压缩时使用。 |
|-------------------|------------|------------------------------------|
|   4               | 通用推送命令 | 表示在发出以太网TX INIT命令后，用户必须为以太网TX线程的每个SNUM发出此命令。 |
|                   |             | CECDR = 0x00800003；CECR = 0x7'b{0}, 8'b{以太网TX线程SNUM}, 1'b{1}, 12'b{0}, 4'b{1}。 |
|-------------------|------------|------------------------------------|
| 5 - 31            | N/A        | 预留，设置为零。                   |
|-------------------|------------|------------------------------------|

### V - 固件结构布局

#### 固件结构布局

飞思卡尔的QE微码通常以头文件的形式提供。此头文件包含定义微码二进制本身以及用于上传该微码的其他数据的宏。这些文件的格式不利于简单地包含到其他代码中。因此，需要一种更便携的格式。本节定义了这种格式。不是分发一个头文件，而是将微码及相关数据嵌入到一个二进制块中。这个块被传递给`qe_upload_firmware()`函数，该函数解析块并执行所有必要的操作来上传微码。所有整数均为大端序。参见`qe_upload_firmware()`函数的注释以获取最新的实现信息。

此结构支持版本控制，其中结构的版本号嵌入到结构本身中。为了确保向前和向后的兼容性，所有版本的结构都必须以相同的`qe_header`结构开始。

**`header`（类型：`struct qe_header`）**

- `length`字段表示整个结构的大小（以字节为单位），包括嵌入的所有微码以及CRC（如果存在）。
- `magic`字段是一个包含字母'Q'、'E'和'F'的三个字节的数组。这是一个标识符，表明此结构是一个QE固件结构。
- `version`字段是一个单字节，表示此结构的版本。如果结构布局需要更改以支持额外类型的微码，则版本号也应更改。
- `id`字段是一个空终止字符串（适合打印），用于识别固件。
- `count`字段表示“微码”结构的数量。对于每个RISC处理器，必须且仅有一个“微码”结构。
因此，这个字段也代表了此 SoC 中的 RISC 处理器数量。
`soc` 结构包含了用于匹配微码与 SoC 本身的 SoC 编号和修订版本。通常，微码加载程序应当检查该结构中的数据与 SoC 的编号和修订版本，并且仅在匹配的情况下上传微码。然而，并非所有平台都会执行这项检查。
虽然不推荐这样做，您可以在 `soc.model` 字段中指定 '0' 来完全跳过 SoC 的匹配。
`model` 字段是一个 16 位数字，与实际的 SoC 匹配。`major` 和 `minor` 字段分别是 SoC 的主次修订版本号。
例如，要匹配 8323，修订版 1.0：

     soc.model = 8323
     soc.major = 1
     soc.minor = 0

`padding` 是为了结构对齐所必需的。这个字段确保 `extended_modes` 字段在 64 位边界上对齐。
`extended_modes` 是一个位字段，定义了对设备驱动程序有影响的特殊功能。每个比特位都有其特定的影响，并且与之关联的驱动程序有特殊的指令。这个字段存储在 QE 库中，并提供给任何调用 qe_get_firmware_info() 的驱动程序。
`vtraps` 是一个包含 8 个字的数组，每个虚拟陷阱有一个虚拟陷阱值。与 `extended_modes` 类似，这个字段存储在 QE 库中，并提供给任何调用 qe_get_firmware_info() 的驱动程序。
`microcode`（类型：struct qe_microcode）：
对于每个 RISC 处理器，都存在一个 `microcode` 结构。第一个 `microcode` 结构对应于第一个 RISC，依此类推。
`id` 字段是一个适合打印的以空字符终止的字符串，用来标识这个特定的微码。
`traps` 是一个包含 16 个字的数组，其中包含针对 16 个陷阱的硬件陷阱值。如果 traps[i] 为 0，则表示忽略这个特定的陷阱（即不写入 TIBCR[i]）。整个值原样写入 TIBCR[i] 寄存器，因此请确保必要时设置 EN 和 T_IBP 位。
`eccr` 是需要编程到 ECCR 寄存器中的值。
`iram_offset` 是从 IRAM 开始写入微码的偏移量。
`count` 是微码中 32 位字的数量。
`code_offset` 是从该结构开头到微码本身所在位置的字节偏移量。第一个微码二进制文件应紧接在 `microcode` 数组之后。
`major`、`minor` 和 `revision` 分别是微码的主要、次要和修订版本号。如果所有值都为 0，则忽略这些字段。
`reserved` 是为了结构对齐所必需的。由于 `microcode` 是一个数组，因此 64 位的 `extended_modes` 字段需要对齐到 64 位边界上，并且只有当 `microcode` 的大小是 8 字节的倍数时才能实现。为了确保这一点，我们添加了 `reserved`。

最后一个微码之后是一个 32 位 CRC 校验。可以使用以下算法进行计算：

```c
u32 crc32(const u8 *p, unsigned int len)
{
    unsigned int i;
    u32 crc = 0;

    while (len--) {
        crc ^= *p++;
        for (i = 0; i < 8; i++)
            crc = (crc >> 1) ^ ((crc & 1) ? 0xedb88320 : 0);
    }
    return crc;
}
```

VI - 创建固件文件的示例代码
============================================

可以从 http://opensource.freescale.com 获取一个用于从通常由 Freescale 发布的头文件创建固件二进制文件的 Python 程序。
