SPDX 许可证标识符: GPL-2.0

===============================================
RISC-V 内核启动要求与约束
===============================================

:作者: Alexandre Ghiti <alexghiti@rivosinc.com>
:日期: 2023年5月23日

本文档描述了RISC-V内核对启动加载器和固件的期望，以及任何开发者在处理早期启动过程时必须考虑的约束。就本文档而言，“早期启动过程”是指在最终虚拟映射设置之前的任何运行代码。
启动前的要求与约束
=======================================

RISC-V 内核对启动加载器和平台固件有以下期望：

寄存器状态
--------------

RISC-V 内核期望如下：

  * ``$a0`` 包含当前核心的hartid
  * ``$a1`` 包含内存中设备树的地址

CSR 状态
---------

RISC-V 内核期望如下：

  * ``$satp = 0``：如果存在MMU，则必须被禁用

为驻留固件预留的内存
-------------------------------------

RISC-V 内核不得在直接映射中映射任何驻留内存或使用PMP保护的内存，因此固件必须根据设备树规范和/或UEFI规范正确标记这些区域。

内核位置
---------------

RISC-V 内核期望被放置在一个PMD边界（对于rv64为2MB对齐，对于rv32为4MB对齐）。请注意，如果情况不是这样，EFI stub将物理重定位内核。

硬件描述
--------------------

固件可以向RISC-V内核传递设备树或ACPI表。

设备树可以直接从上一阶段通过``$a1``寄存器传递给内核，或者当使用UEFI启动时，可以通过EFI配置表传递。

ACPI表通过EFI配置表传递给内核。在这种情况下，EFI stub仍会创建一个小型的设备树。有关此设备树的详细信息，请参阅下面的“EFI stub和设备树”部分。

内核入口
------------

在SMP系统中，有两种方法进入内核：

- ``RISCV_BOOT_SPINWAIT``：固件在内核中释放所有hart，一个hart通过抽奖获胜并执行早期启动代码，而其他hart则停放等待初始化完成。这种方法主要用于支持没有SBI HSM扩展的老式固件和M模式的RISC-V内核。
### 有序启动
“有序启动”：固件仅释放一个Hart来执行初始化阶段，然后使用SBI HSM扩展启动所有其他Hart。对于启动RISC-V内核而言，有序启动方法是首选的启动方法，因为它可以支持CPU热插拔和kexec UEFI。

### UEFI内存映射
在使用UEFI启动时，RISC-V内核将仅使用EFI内存映射来填充系统内存。UEFI固件必须解析`/reserved-memory`设备树节点的子节点，并遵循设备树规范，将这些子节点的属性（`no-map`和`reusable`）转换为正确的EFI等效项（参见设备树规范v0.4-rc1版本中“3.5.4 /reserved-memory和UEFI”章节）。

### RISCV_EFI_BOOT_PROTOCOL
在使用UEFI启动时，EFI存根需要启动Hart ID，以便将其传递给RISC-V内核中的`$a1`寄存器。EFI存根通过以下方法之一获取启动Hart ID：

- `RISCV_EFI_BOOT_PROTOCOL`（**优选**）
- 设备树`boot-hartid`子节点（**废弃**）

任何新的固件都必须实现`RISCV_EFI_BOOT_PROTOCOL`，因为基于设备树的方法已经废弃。

### 早期启动要求与约束
RISC-V内核的早期启动过程遵循以下约束：

#### EFI存根与设备树
使用UEFI启动时，设备树由EFI存根进行补充（或创建），参数与ARM64相同，具体描述参见Documentation/arch/arm/uefi.rst文件中“ARM上的UEFI内核支持”段落。

#### 虚拟映射安装
RISC-V内核中的虚拟映射安装分为两个步骤：

1. `setup_vm()`在`early_pg_dir`中安装一个临时的内核映射，允许发现系统内存。此时仅映射内核的文本和数据部分。由于系统内存尚未确定，在建立此映射时无法进行分配，因此`early_pg_dir`页表静态分配（每个层级仅使用一个表）。
2. `setup_vm_final()`在`swapper_pg_dir`中创建最终的内核映射，并利用已发现的系统内存来创建线性映射。在建立此映射时，内核可以分配内存但不能直接访问它（因为直接映射尚未存在），因此它使用fixmap区域中的临时映射来访问新分配的页表层级。

为了使`virt_to_phys()`和`phys_to_virt()`能够正确地将直接映射地址转换为物理地址，它们需要知道DRAM的起始地址。这发生在第一步之后，在第二步安装直接映射之前（参见arch/riscv/mm/init.c中的`setup_bootmem()`函数）。在最终虚拟映射安装之前使用这些宏的情况必须仔细检查。
### 通过固定映射（fixmap）实现的设备树映射

由于`reserved_mem`数组是用由`setup_vm()`建立的虚拟地址初始化，并且与`setup_vm_final()`建立的映射一起使用，RISC-V内核利用固定映射区域来映射设备树。这确保了设备树能够被两个虚拟映射访问：
- 预MMU执行

有一些代码需要在建立第一个虚拟映射之前运行。这些包括安装第一个虚拟映射本身、修补早期备选方案以及对内核命令行的早期解析。
这部分代码必须非常谨慎地编译，具体如下：

- `-fno-pie`：这是可重定位内核所必需的，这些内核使用`-fPIE`。否则，任何对全局符号的访问都会通过GOT（全局偏移表），而GOT仅在虚拟地址空间中进行重定位。
- `-mcmodel=medany`：任何对全局符号的访问都必须相对于程序计数器（PC）以避免在MMU设置之前发生任何重定位。
- 所有工具性功能也必须禁用（这包括KASAN、ftrace等）。

由于从不同的编译单元使用一个符号要求该单元也需要用这些标志进行编译，我们建议尽可能不要使用外部符号。
