中断
=====

2.5.2-rmk5:
  这是首个内核版本，其中对一些主要的架构特定子系统进行了重大调整。
首先，在处理内存管理单元（MMU）的转换后备缓冲器（TLB）的方式上进行了一些重要改动。现在每个MMU TLB变体都完全独立处理 —— 我们有TLB v3、没有写缓冲区的TLB v4、带有写缓冲区的TLB v4以及最后一种带有写缓冲区和I TLB无效条目的TLB v4。
这些函数内部包含更多的汇编代码，主要是为了在未来能够更灵活地处理TLB。
其次，中断子系统
2.5系列内核将对处理中断请求（IRQ）的方式进行重大改变。
不幸的是，这意味着所有触及irq_desc[]数组的机器类型（基本上是所有机器类型）都将受到影响，也就是说我们当前所有的机器类型都将受到影响。
让我们以一个例子来说明。在Assabet与Neponset组合中，我们有：

                  GPIO25                 IRR:2
        SA1100 ------------> Neponset -----------> SA1111
                                         IIR:1
                                      -----------> USAR
                                         IIR:0
                                      -----------> SMC9196

目前的情况是，所有来自SA1111的中断彼此互斥 —— 如果正在处理来自SA1111的一个中断，而另一个中断到来，则必须等待当前中断处理完成才能服务新的中断。例如，一个基于SA1111的IDE PIO中断会排除所有其他SA1111和SMC9196的中断直到它完成了多扇区数据传输，这可能需要很长时间。另外，由于我们在SA1111的IRQ处理器中循环，SA1111的IRQ可以无限期地阻止SMC9196的IRQ。
新的方法引入了几种新思路：
我们引入了“父”和“子”的概念。例如，对于Neponset处理器而言，“父”是GPIO25，而“子”包括SA1111、SMC9196和USAR。
我们还引入了IRQ“芯片”的概念（主要是为了减小irqdesc数组的大小）。这个“芯片”不一定是一个实际的“集成电路”；实际上，SA11x0的IRQ由两个不同的“芯片”结构处理，一个用于GPIO0-10，另一个用于其余部分。它只是一个容器，用来封装各种操作（也许这个名字未来会有所改进）。
此结构具有以下操作：

```c
struct irqchip {
        /* 
         * 确认中断请求(IRQ)
         * 如果这是一个基于电平的IRQ，则期望同时屏蔽IRQ
         */
        void (*ack)(unsigned int irq);
        /* 
         * 在硬件中屏蔽IRQ
         */
        void (*mask)(unsigned int irq);
        /* 
         * 在硬件中解除屏蔽IRQ
         */
        void (*unmask)(unsigned int irq);
        /* 
         * 重新触发IRQ
         */
        void (*rerun)(unsigned int irq);
        /* 
         * 设置IRQ的类型
         */
        int (*type)(unsigned int irq, unsigned int, type);
};

/* ack - 必需。对于由do_level_IRQ处理的IRQ，可以与mask为同一函数 */
/* mask - 必需 */
/* unmask - 必需 */
/* rerun - 可选。如果你使用do_level_IRQ来处理所有使用此'irqchip'的IRQ，则不需要此函数。通常期望如果可能的话重新触发硬件IRQ。如果无法做到，可以直接调用处理程序。 */
/* type - 可选。如果你不支持改变IRQ的类型，应该将其设为null，以便人们可以检测到他们是否无法设置IRQ类型。 */
```
对于每个中断请求（IRQ），我们维护以下信息：

        - “禁用”深度（没有对应`enable_irq()`的`disable_irq()`的数量）
        - 标志，指示我们可以对这个IRQ执行哪些操作（有效、探测、
          禁止自动取消屏蔽）与之前相同
        - IRQ的状态（探测中、启用等）
        - 中断控制器芯片
        - 每个IRQ的处理程序
        - `irqaction`结构列表

处理程序可以是三种标准处理程序之一——“电平触发”、“边沿触发”和
“简单”，或者如果您需要执行一些特殊操作，则可以使用自定义处理程序。
“电平触发”处理程序是我们目前使用的类型——它非常简单。
“边沿触发”处理程序了解某些IRQ实现存在的问题——即在处理中断时，
需要保持硬件中断启用，并在处理过程中如果再次发生中断，则需要排队进一步的中断事件。 
“简单”处理程序非常基础，不会执行任何硬件操作或状态跟踪。 
这对于像SMC9196和USAR这样的设备很有用。
那么，有哪些变化？
==================

1. 架构实现不应该直接写入`irqdesc`数组。
2. 新增用于操作`irqdesc`数组的函数。前四个函数预计只对特定架构代码有用。最后一个函数建议仅由特定架构代码使用，但在绝对必要的情况下也可以在驱动程序中使用。
`set_irq_chip(irq, chip)`
                设置处理该IRQ的掩码/取消掩码方法。

        `set_irq_handler(irq, handler)`
                设置该IRQ的处理程序（电平触发、边沿触发、简单）。

        `set_irq_chained_handler(irq, handler)`
                为该IRQ设置一个“连锁”处理程序——自动启用此IRQ（例如，Neponset和SA1111处理程序）
`set_irq_flags(irq, flags)`
                设置有效/探测/禁止自动启用标志
`set_irq_type(irq, type)`
                设置IRQ激活的边沿/电平。这取代了SA1111 INTPOL的操作，以及`set_GPIO_IRQ_edge()`函数。类型应该是`<linux/irq.h>`中定义的`IRQ_TYPE_xxx`之一。

3. `set_GPIO_IRQ_edge()`已过时，应被`set_irq_type`替换。
4. 直接访问SA1111 INTPOL已被弃用。请改用`set_irq_type`。
5. 处理程序应该通过正确的芯片特定函数来完成对父IRQ的任何必要的确认。例如，如果SA1111直接连接到SA1110的GPIO，则每次重新读取SA1111的IRQ状态时，都应该确认SA1110的IRQ。
6. 对于任何没有自身 IRQ 启用/禁用控制的孩子设备（例如，SMC9196），处理程序在调用孩子处理程序时必须屏蔽或确认父 IRQ，并且孩子处理程序应当是“简单”处理程序（既不是“边沿”也不是“电平”）。处理程序完成后，应解除父 IRQ 的屏蔽，并重新检查所有孩子的状态以查找待处理事件。（有关详细信息，请参阅 Neponset IRQ 处理程序）
7. fixup_irq() 已被移除，以及 `arch/arm/mach-*/include/mach/irq.h`。

请注意，这并不能解决所有问题——有些问题是基于硬件的。在同一父信号上混合基于电平和基于边沿的 IRQ（例如 neponset）就是其中一个领域，在这里，仅靠软件解决方案无法完全解决 IRQ 低延迟的问题。
