======================================
集群范围内的上电/下电竞赛避免算法
======================================

本文件记录了用于协调CPU和集群的设置与拆解操作以及安全地管理硬件一致性控制的算法。
“原理”部分解释了该算法的目的及其必要性。“基本模型”部分通过简化系统视图来解释一般概念。其他部分则详细说明了实际使用的算法细节。

原理
--------

在一个包含多个CPU的系统中，当系统处于空闲状态时，能够关闭单个CPU以减少功耗和热耗散是非常理想的。
在包含多个CPU集群的系统中，能够关闭整个集群也是非常理想的。
整个集群的上电和下电操作是存在风险的，因为它涉及到对一组独立运行的CPU执行可能具有破坏性的操作，而此时操作系统仍在继续运行。这意味着我们需要某种协调机制以确保仅在真正安全的情况下执行关键的集群级操作。
简单的锁定可能不足以解决此问题，因为像Linux自旋锁这样的机制可能依赖于在集群上电时不会立即启用的一致性机制。由于启用或禁用这些机制本身可能是一个非原子操作（例如写入一些硬件寄存器和使大型缓存失效），因此需要其他协调方法以保证集群级别的安全下电和上电。
本文档中描述的机制提出了一种基于一致内存的协议来进行所需的协调。其目标是在提供所需的安全属性的同时尽可能轻量。

基本模型
--------

每个集群和CPU被分配一个状态，如下所示：

    - DOWN（下电）
    - COMING_UP（上电中）
    - UP（上电）
    - GOING_DOWN（下电中）

```
    +---------> UP ----------+
    |                        v

    COMING_UP                GOING_DOWN

    ^                        |
    +--------- DOWN <--------+
```

DOWN：
    CPU 或集群不具有一致性，并且已下电或暂停，或者准备下电或暂停。
COMING_UP：
    CPU 或集群已承诺移至 UP 状态
    可能正处于初始化过程中并启用一致性。
UP:
	在硬件级别上，CPU 或集群处于活动且一致的状态。处于这种状态的 CPU 并不一定被内核积极使用。
GOING_DOWN:
	CPU 或集群已决定转换为 DOWN 状态。它可能正处于拆解过程和一致性退出的部分阶段中。

在任意给定的时间点，每个 CPU 都会被分配其中一个状态。关于 CPU 状态的具体描述，请参阅下文的“CPU 状态”部分。
每个集群也被分配了一个状态，但需要将这个状态值分为两部分（即“集群”状态和“入向”状态），并引入额外的状态来避免集群中的不同 CPU 同时修改状态时产生的竞态条件。集群级别的状态将在“集群状态”部分进行描述。

为了帮助区分本讨论中的 CPU 状态与集群状态，我们将为 CPU 状态加上 `CPU_` 前缀，而集群状态则加上 `CLUSTER_` 或 `INBOUND_` 前缀。

### CPU 状态

在这个算法中，一个多核心处理器中的每个单独的核心被称为一个“CPU”。假设每个 CPU 是单线程的：因此，在任何给定时间点，一个 CPU 只能执行一项任务。
这意味着 CPU 符合基本模型的定义。

该算法为系统中的每个 CPU 定义了以下四种状态：

	- CPU_DOWN
	- CPU_COMING_UP
	- CPU_UP
	- CPU_GOING_DOWN

:: 

	集群设置完成和
	CPU 设置完成          策略决策
	      +-----------> CPU_UP ------------+
	      |                                v

	CPU_COMING_UP                   CPU_GOING_DOWN

	      ^                                |
	      +----------- CPU_DOWN <----------+
	 策略决策           CPU 拆解完成
	或硬件事件

这四种状态的定义与基本模型中的状态非常接近。
状态之间的转换如下：
触发事件（自发）意味着CPU仅通过本地进展就能转换到下一个状态，无需任何外部事件的发生。

### CPU_DOWN：
当一个CPU准备好进行功耗降低时，它会进入CPU_DOWN状态。到达这个状态后，CPU通常会通过WFI指令或固件调用自行降低功耗或挂起。

#### 下一个状态：
- CPU_COMING_UP

#### 条件：
- 无

#### 触发事件：
1. 由另一个CPU上的策略决策导致的明确硬件启动操作；
2. 硬件事件，如中断。

### CPU_COMING_UP：
在集群设置完成并保持一致性之前，CPU无法开始参与硬件一致性的工作。如果集群尚未准备就绪，则CPU将停留在CPU_COMING_UP状态，直到集群被设置完成。

#### 下一个状态：
- CPU_UP

#### 条件：
- CPU所属的父集群必须处于CLUSTER_UP状态。

#### 触发事件：
- 父集群转换至CLUSTER_UP状态。
请参阅“集群状态”部分以了解CLUSTER_UP状态的描述。

### CPU_UP：
当一个CPU达到CPU_UP状态时，该CPU可以安全地开始参与本地一致性的工作。
这是通过跳转到内核的CPU恢复代码来实现的。
需要注意的是，此状态的定义与基本模型略有不同：CPU_UP并不意味着CPU已经完全一致，但它确实意味着可以安全地恢复内核。内核负责处理剩余的恢复过程，因此这些步骤不作为竞争避免算法的一部分而可见。
CPU保持在这种状态，直到做出明确的策略决策来关闭或暂停CPU。
下一状态:
		CPU_GOING_DOWN
条件:
		无
触发事件:
		明确的策略决策

CPU_GOING_DOWN:
	在此状态下，CPU退出一致性，包括实现这一点所需的所有操作（如清理数据缓存）。
下一状态:
		CPU_DOWN
条件:
		本地CPU拆解完成
触发事件:
		(自发)

集群状态
--------

集群是一组具有某些共享资源的互联CPU。
由于一个集群包含多个CPU，因此它可以同时执行多项任务。这有一些含义。特别是，当另一个CPU正在拆解集群时，一个CPU可以启动。
在这个讨论中，“出站侧”是从正在拆解集群的CPU的角度来看的集群状态视图；“入站侧”是从正在设置CPU的角度来看的集群状态视图。
为了在这种情况下实现安全协调，非常重要的是，设置集群的CPU能够独立于拆解集群的CPU宣传其状态。出于这个原因，集群状态被分为两部分：

	“集群”状态：集群的全局状态；或者出站侧的状态：

		- CLUSTER_DOWN
		- CLUSTER_UP
		- CLUSTER_GOING_DOWN

	“入站”状态：入站侧的集群状态
- INBOUND_NOT_COMING_UP
		- INBOUND_COMING_UP


这些状态的不同组合导致集群整体上可能存在的六种状态如下所示：

	                            CLUSTER_UP
	          +==========> INBOUND_NOT_COMING_UP -------------+
	          #                                               |
	                                                          |
	     CLUSTER_UP     <----+                                |
	  INBOUND_COMING_UP      |                                v

	          ^             CLUSTER_GOING_DOWN       CLUSTER_GOING_DOWN
	          #              INBOUND_COMING_UP <=== INBOUND_NOT_COMING_UP

	    CLUSTER_DOWN         |                                |
	  INBOUND_COMING_UP <----+                                |
	                                                          |
	          ^                                               |
	          +===========     CLUSTER_DOWN      <------------+
	                       INBOUND_NOT_COMING_UP

转换 -----> 只能由出站CPU进行，并且只涉及对“集群”状态的更改
转换 ===##> 只能由入站CPU进行，并且只涉及对“入站”状态的更改，除非在出站侧没有进一步的转换可能（即，出站CPU已将集群置于CLUSTER_DOWN状态）
竞赛避免算法没有提供确定集群内部哪些确切CPU承担这些角色的方法。这必须通过其他方式提前决定。有关更多解释，请参阅“最后和首个选择人”部分
CLUSTER_DOWN/INBOUND_NOT_COMING_UP是唯一可以使集群实际断电的状态。
通过存在两条从 `CLUSTER_GOING_DOWN` / `INBOUND_NOT_COMING_UP`（对应基本模型中的 `GOING_DOWN`）到 `CLUSTER_DOWN` / `INBOUND_COMING_UP`（对应基本模型中的 `COMING_UP`）的不同路径，可以观察到入站和出站 CPU 的并行性。第二条路径完全避免了集群的拆解。

`CLUSTER_UP` / `INBOUND_COMING_UP` 等同于基本模型中的 `UP`。最终过渡到 `CLUSTER_UP` / `INBOUND_NOT_COMING_UP` 是微不足道的，它仅仅是为了重置状态机，以便为下一个周期做准备。

下面列出了允许的状态转换详情：

每种情况下下一个状态表示如下：

		<集群状态>/<入站状态> (<转换器>)

其中 `<转换器>` 表示发生转换的一侧；可能是入站侧或出站侧。

`CLUSTER_DOWN` / `INBOUND_NOT_COMING_UP`：
	下一个状态：
		`CLUSTER_DOWN` / `INBOUND_COMING_UP` （入站）
	条件：
		无

	触发事件：
		a) 明确的硬件启动操作，源自另一个 CPU 上的策略决策；

		b) 硬件事件，例如中断

`CLUSTER_DOWN` / `INBOUND_COMING_UP`：

	在此状态下，入站 CPU 设置集群，包括在集群级别启用硬件一致性以及任何其他所需的操作（如缓存失效），以实现这一点。
此状态的目的在于完成足够的集群级别设置，使得集群内的其他 CPU 可以安全地进入一致性状态。
下一个状态：
		`CLUSTER_UP` / `INBOUND_COMING_UP` （入站）
	条件：
		集群级别设置与硬件一致性完成
	触发事件：
		(自发)

`CLUSTER_UP` / `INBOUND_COMING_UP`：

	集群级别的设置已完成，并且为集群启用了硬件一致性。集群内的其他 CPU 可以安全地进入一致性状态。
这是一个短暂状态，会立即转移到 `CLUSTER_UP` / `INBOUND_NOT_COMING_UP`。集群上的所有其他 CPU 应当认为这两个状态是等效的。
下一个状态：
		`CLUSTER_UP` / `INBOUND_NOT_COMING_UP` （入站）
	条件：
		无
	触发事件：
		(自发)

`CLUSTER_UP` / `INBOUND_NOT_COMING_UP`：

	集群级别的设置已完成，并且为集群启用了硬件一致性。集群内的其他 CPU 可以安全地进入一致性状态。
集群将保持在这种状态，直到根据策略决定关闭集群的电源。
下一个状态：
CLUSTER_GOING_DOWN/INBOUND_NOT_COMING_UP（出站）
条件：
无
触发事件：
对集群进行关机的策略决定

CLUSTER_GOING_DOWN/INBOUND_NOT_COMING_UP：

一个出站CPU正在拆解集群。被选中的CPU必须在此状态下等待，直到集群中的所有CPU都处于CPU_DOWN状态。
当所有CPU都处于CPU_DOWN状态时，可以拆解集群，例如清理数据缓存并退出集群级别的一致性。
为了避免不必要的浪费性拆解操作，出站CPU应该检查入站集群的状态，以异步过渡到INBOUND_COMING_UP。或者，可以单独检查各个CPU是否进入CPU_COMING_UP或CPU_UP状态。
下一个状态：

CLUSTER_DOWN/INBOUND_NOT_COMING_UP（出站）
条件：
集群已拆解并准备好关闭电源
触发事件：
（自发性）

CLUSTER_GOING_DOWN/INBOUND_COMING_UP（入站）
条件：
无
触发事件：
a) 明确的硬件上电操作，由另一个CPU上的策略决定导致；

b) 硬件事件，如中断

CLUSTER_GOING_DOWN/INBOUND_COMING_UP：

集群正在（或曾）被拆解，但同时另一个CPU上线，并试图重新设置集群。
如果出站CPU观察到这种状态，则有两种选择：

a) 退出拆解过程，恢复集群到CLUSTER_UP状态；

b) 完成集群的拆解，并将集群置于CLUSTER_DOWN状态；入站CPU将从那里再次设置集群
选择(a)允许在集群实际上不会被关闭的情况下避免不必要的拆解和设置操作，从而减少一些延迟。
下一个状态：

CLUSTER_UP/INBOUND_COMING_UP（出站）
条件：
集群级别设置和硬件一致性完成

触发事件：
（自发性）

CLUSTER_DOWN/INBOUND_COMING_UP（出站）
条件：
集群已拆解并准备好关闭电源

触发事件：
（自发性）

最后一个人和第一个人的选择
------------------------------

执行出站侧集群拆解操作的CPU通常被称为“最后一个人”。
执行入站侧集群设置的CPU通常被称为“第一个人”。
上述记录的竞赛避免算法并未提供一种机制来选择哪些CPU应该承担这些角色。

最后的角色（Last man）：

在关闭集群时，所有涉及的CPU最初都在执行Linux，因此它们之间是同步的。因此，在CPU变得不同步之前，可以使用普通的自旋锁来安全地选择最后一个角色。

第一个角色（First man）：

由于CPU可能因外部唤醒事件而异步启动，需要一个动态机制来确保只有一个CPU尝试扮演第一个角色并进行集群级别的初始化：其他任何CPU都必须等待此过程完成才能继续。
集群级别的初始化可能包括诸如在总线结构中配置一致性控制等操作。
当前实现中的mcpm_head.S使用了一个独立的互斥机制来进行这种仲裁。该机制在vlocks.txt中有详细记录。

特性和限制
--------------

实现：

当前基于ARM的实现分为两部分：arch/arm/common/mcpm_head.S（低级别入站CPU操作）和arch/arm/common/mcpm_entry.c（其余部分）：

- `__mcpm_cpu_going_down()`信号表示CPU状态转变为CPU_GOING_DOWN
- `__mcpm_cpu_down()`信号表示CPU状态转变为CPU_DOWN
- 通过mcpm_head.S中的低级启动代码，CPU的状态从CPU_COMING_UP转换到CPU_UP。这可能涉及特定于CPU的设置代码，但在当前实现中并没有这样的处理。
- `__mcpm_outbound_enter_critical()` 和 `__mcpm_outbound_leave_critical()` 处理从CLUSTER_UP到CLUSTER_GOING_DOWN的转换，以及从CLUSTER_GOING_DOWN到CLUSTER_DOWN或返回到CLUSTER_UP（在集群电源关闭被中断的情况下）的转换。

这些函数比`__mcpm_cpu_*()`函数更复杂，因为需要额外的CPU间协调以确保集群级别的安全转换。
集群从 `CLUSTER_DOWN` 状态转换回 `CLUSTER_UP` 状态，是通过 `mcpm_head.S` 中的低级启动代码实现的。这通常涉及到由通过 `mcpm_sync_init` 注册的平台特定 `power_up_setup` 函数提供的平台特定设置代码。

深度拓扑：

按照当前的描述和实现，该算法不支持涉及超过两层的 CPU 拓扑结构（即，不支持集群的集群）。可以通过为额外的拓扑层级复制集群级别的状态，并修改中间层级（非最外层集群）的转换规则来扩展该算法。

结语
------

最初由 Dave Martin 为 Linaro Limited 创建并记录，与 Nicolas Pitre 和 Achin Gupta 合作完成。
版权所有 © 2012-2013 Linaro Limited
根据定义在 `linux/COPYING` 中的 GNU 通用公共许可证第2版的条款进行分发。
