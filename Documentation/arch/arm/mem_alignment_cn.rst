内存对齐

近期，内核代码中未注意到的未对齐内存访问引发了许多问题。因此，现在对于基于SA11x0的目标系统无条件地配置了对齐修正。据Alan Cox所说，禁用这种配置是一个糟糕的想法，但Russell King在某些混乱的ARM架构（如EBSA110）上有一些充分的理由这样做。然而，在我所了解的许多设计中，例如所有基于SA11x0的设计，并非如此。
当然，依赖对齐陷阱来执行通常情况下的未对齐内存访问是一个糟糕的想法。如果这些访问是可预测的，你最好使用`include/asm/unaligned.h`中提供的宏。对齐陷阱可以处理例外情况下的未对齐访问，但这会带来较高的性能成本。最好让它很少发生。
至于用户空间的应用程序，可以配置对齐陷阱在任何执行未对齐访问的代码处触发SIGBUS信号（这对调试不良代码很有帮助），或者甚至像内核代码那样通过软件修正访问。后一种模式由于性能原因不被推荐（想想浮点数仿真器的工作方式就知道）。最好是修正你的代码！

请注意，随意改变行为而不经过深思熟虑是非常糟糕的——它改变了用户空间中所有未对齐指令的行为，可能会导致程序意外失败。
要更改对齐陷阱的行为，只需将一个数字回显到`/proc/cpu/alignment`。该数字由各种位组成：

===		========================================================
位		设置时的行为
===		========================================================
0		当用户进程执行未对齐的内存访问时，内核将打印一条消息，指示进程名称、PID、PC、指令、地址和故障代码
1		内核将尝试修正执行未对齐访问的用户进程。这当然是缓慢的（想想浮点数仿真器）并且不建议在生产环境中使用
2		内核将向执行未对齐访问的用户进程发送SIGBUS信号
===		========================================================

请注意，并非所有组合都受支持——仅支持值0到5（值6和7没有意义）
例如，以下命令将启用警告，但不进行修正或发送SIGBUS信号：

	echo 1 > /proc/cpu/alignment

你还可以读取同一文件的内容以获取未对齐访问发生的统计信息以及用户空间代码当前的操作模式。
Nicolas Pitre, 2001年3月13日。Russell King修改于2001年11月30日。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
