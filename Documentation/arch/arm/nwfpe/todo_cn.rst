待办事项列表
==========

::

  POW{cond}<S|D|E>{P,M,Z} Fd, Fn, <Fm,#value> - 幂运算
  RPW{cond}<S|D|E>{P,M,Z} Fd, Fn, <Fm,#value> - 反向幂运算
  POL{cond}<S|D|E>{P,M,Z} Fd, Fn, <Fm,#value> - 极角（反正切）

  LOG{cond}<S|D|E>{P,M,Z} Fd, <Fm,#value> - 以10为底的对数
  LGN{cond}<S|D|E>{P,M,Z} Fd, <Fm,#value> - 以e为底的对数
  EXP{cond}<S|D|E>{P,M,Z} Fd, <Fm,#value> - 指数
  SIN{cond}<S|D|E>{P,M,Z} Fd, <Fm,#value> - 正弦
  COS{cond}<S|D|E>{P,M,Z} Fd, <Fm,#value> - 余弦
  TAN{cond}<S|D|E>{P,M,Z} Fd, <Fm,#value> - 正切
  ASN{cond}<S|D|E>{P,M,Z} Fd, <Fm,#value> - 反正弦
  ACS{cond}<S|D|E>{P,M,Z} Fd, <Fm,#value> - 反余弦
  ATN{cond}<S|D|E>{P,M,Z} Fd, <Fm,#value> - 反正切

这些功能尚未实现。目前编译器并未生成这些指令，它们由libc中的例程处理。FPA11硬件本身并不支持这些功能，而是通过浮点支持代码来处理。未来版本中应予以实现。

实现这些功能的方法有几种。一种方法是使用高精度表格法。我有一些来自IBM以色列海法研究实验室的S. Gal所写的论文，似乎可以保证极高的准确性（大约99.8%）并具有合理的速度。GLIBC在某些超越函数中就采用了这种方法。

另一种我不太了解的方法是CORDIC（坐标旋转数字计算机）。这是一种主要依赖移位和加法，并辅以少量乘法和除法来计算超越函数的方法。ARM架构擅长移位和加法操作，因此这种方法很有潜力，但需要进一步研究来确定其可行性。

--- 

舍入方法
---------

IEEE标准定义了四种舍入模式。默认模式是四舍五入，但也可以选择正无穷、负无穷或零舍入。许多架构允许通过修改控制寄存器中的位来指定舍入模式。ARM FPA11架构则不同，要改变舍入模式必须在每条指令中指定。

这使得移植一些基准测试变得困难。可以在模拟器中引入这种能力。FPCR包含描述舍入模式的位。可以通过检查一个标志位来修改模拟器的行为：如果该标志位被设置，则忽略指令中的舍入模式，并使用FPCR中的位指定的模式。

这需要提供一种获取/设置标志位以及FPCR中位的方法。在ArmLinux中，由于WFC和RFC指令仅能在监督模式下执行，因此这需要一个内核调用。如果有任何想法或评论，请告诉我。

---

注：
从一些关于ARM浮点的文档中摘录，特别针对Acorn FPE，但不仅限于此：

浮点控制寄存器（FPCR）可能只存在于某些实现中：它的存在是为了以实现特定的方式控制硬件，例如禁用浮点系统。ARM用户模式不允许使用此寄存器（因为保留了在不同实现之间更改它的权利），而WFC和RFC指令在用户模式下尝试时会触发陷阱。
因此，答案是肯定的，你可以这样做，但这样做的风险是你可能会在将来硬件浮点仿真出现时变得孤立无援。

---

-- Russell
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
