笔记
=====

似乎在`exp(double)`和我们的模拟器之间存在问题。我还没有找出具体原因。这个问题在Russell King提供的模拟器上并未出现。
我还发现了模拟器中的一个奇怪现象。我认为问题并不严重，但还是需要指出：ARM的调用约定要求在函数调用过程中保留浮点寄存器f4-f7的值。编译器经常会使用stfe指令在进入函数时将f4保存到栈中，并使用ldfe指令在返回前恢复其值。
我在查看一些代码时发现，这些代码计算出一个双精度结果并将其存储在f4中，然后进行函数调用。从函数调用返回后，f4中的数字在模拟器中被转换成了扩展精度值。
这是stfe指令的一个副作用。f4中的双精度数必须先转换为扩展精度，然后再存储。如果使用了lfm/sfm组合，则不会发生转换。这与性能相关。函数调用的结果和f4的内容被用于乘法运算。如果模拟器检测到双精度和扩展精度之间的乘法，它会将双精度提升到扩展精度，然后以扩展精度执行乘法。
这段代码会导致此问题：

```c
double x, y, z;
z = log(x)/log(y);
```

`log(x)`的结果（双精度）将被计算出来，返回到f0，然后移至f4以在`log(y)`调用期间保持其值不变。由于在`log(y)`中使用了stfe指令来保存f4，所以除法将以扩展精度执行。
