================
内核模式下的 NEON
================

简要总结
-------------
* 只使用 NEON 指令，或不依赖支持代码的 VFP 指令
* 将您的 NEON 代码隔离在一个单独的编译单元中，并使用 `-march=armv7-a -mfpu=neon -mfloat-abi=softfp` 进行编译
* 在调用 NEON 代码前后放置 `kernel_neon_begin()` 和 `kernel_neon_end()` 调用
* 不要在 NEON 代码中睡眠，并注意它将在禁用抢占的情况下执行

简介
------------
可以在运行于内核模式的代码中使用 NEON 指令（在某些情况下还可以使用 VFP 指令）。然而，出于性能原因，与普通寄存器文件不同，NEON/VFP 寄存器文件不会在每次上下文切换或异常发生时被保存和恢复，因此需要一些手动干预。此外，对于可能引起睡眠（即，可能调用 `schedule()`）的代码，由于以下所述的原因，必须特别小心处理，因为 NEON 或 VFP 指令将在不可抢占的部分中执行。

延迟保存与恢复
-------------------------
NEON/VFP 寄存器文件通过延迟保存（单处理器系统上）和延迟恢复（多处理器和单处理器系统上）进行管理。这意味着寄存器文件保持“活动状态”，仅在多个任务争夺 NEON/VFP 单元（或多处理器情况下，任务迁移到其他核心时）时才进行保存和恢复。延迟恢复是通过在每次上下文切换后禁用 NEON/VFP 单元来实现的，这样当随后发出 NEON/VFP 指令时就会产生一个陷阱，允许内核介入并根据需要执行恢复操作。

内核模式下对 NEON/VFP 单元的任何使用都不应干扰这一机制，因此需要“主动”地保存 NEON/VFP 寄存器文件，并显式启用 NEON/VFP 单元以避免后续首次使用时产生异常。这些由函数 `kernel_neon_begin()` 处理，该函数应在发出任何内核模式 NEON 或 VFP 指令之前调用。

同样，在使用后应再次禁用 NEON/VFP 单元，以确保用户模式在下次使用时会遇到延迟恢复陷阱。这由函数 `kernel_neon_end()` 处理。

内核模式下的中断
----------------------------
出于性能和简单性的考虑，决定不在内核模式下的 NEON/VFP 寄存器内容中实施保存/恢复机制。这意味着只有在保证不会触及 NEON/VFP 寄存器的情况下才能允许中断内核模式下的 NEON 部分。为此，内核中适用以下规则和限制：

* 不允许在中断上下文中使用 NEON/VFP 代码；
* 不允许 NEON/VFP 代码睡眠；
* NEON/VFP 代码在禁用抢占的情况下执行

如果延迟是一个问题，可以在代码中的 NEON 寄存器均未处于活跃状态的地方连续调用 `kernel_neon_end()` 和 `kernel_neon_begin()`。（如果在此期间没有发生上下文切换，则对 `kernel_neon_begin()` 的额外调用应该是相对便宜的。）

VFP 和支持代码
--------------------
早期版本的 VFP（3 版本以前）依赖软件支持来处理像符合 IEEE-754 的下溢处理等事情。当 VFP 单元需要此类软件辅助时，它会通过引发未定义指令异常的方式通知内核。内核响应此信号，检查 VFP 控制寄存器、当前指令及其参数，并在软件中模拟该指令。

目前，这种软件辅助尚未为内核模式下执行的 VFP 指令实现。如果遇到这种情况，内核将失败并生成 OOPS。

将 NEON 代码与普通代码分离
---------------------------------------
编译器不了解 `kernel_neon_begin()` 和 `kernel_neon_end()` 的特殊重要性，即只允许在这两个函数调用之间发出 NEON/VFP 指令。此外，如果选择了 `-mfpu=neon`，GCC 可能在 `-O3` 级别生成自己的 NEON 指令，即使内核当前以 `-O2` 编译，未来的变化也可能导致如果不采取特别措施，NEON/VFP 指令出现在意外的位置。

因此，推荐且唯一支持的在内核中使用 NEON/VFP 的方式是遵循以下规则：

* 将 NEON 代码隔离在一个单独的编译单元中，并使用 `-march=armv7-a -mfpu=neon -mfloat-abi=softfp` 进行编译；
* 从一个未设置 GCC 标志 `-mfpu=neon` 的编译单元中发出 `kernel_neon_begin()`、`kernel_neon_end()` 以及调用包含 NEON 代码的单元。

由于内核是以 `-msoft-float` 编译的，上述方法可以确保无论优化级别如何，NEON 和 VFP 指令都只会出现在指定的编译单元中。
### NEON 汇编器
-----------------
只要遵循上述规则，NEON 汇编器就受到支持，无需额外的注意事项。

### 由 GCC 生成的 NEON 代码
-----------------------------
GCC 的选项 `-ftree-vectorize`（由 `-O3` 启用）试图利用隐式并行性，并从普通的 C 源代码生成 NEON 代码。只要遵循上述规则，这都是完全支持的。

### NEON 内联函数
-------------------
NEON 内联函数也受到支持。但是，由于使用 NEON 内联函数的代码依赖于 GCC 头文件 `<arm_neon.h>`（该文件包含了 `<stdint.h>`），因此除了遵循上述规则外，您还应遵守以下事项：

* 使用 `-ffreestanding` 编译包含 NEON 内联函数的单元，这样 GCC 将使用其内置版本的 `<stdint.h>`（这是一个 C99 标头，内核不提供它）；
* 最后包含 `<arm_neon.h>`，或者至少在 `<linux/types.h>` 之后包含它。
