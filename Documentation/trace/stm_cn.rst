SPDX 许可证标识符: GPL-2.0

===================
系统跟踪模块
===================

系统跟踪模块（STM）是根据 MIPI STP 规范描述的一种设备，作为 STP 跟踪流生成器。STP（系统跟踪协议）是一种跟踪协议，用于复用来自多个跟踪源的数据，每个跟踪源都分配了一个唯一的主控/通道对。虽然某些主控和通道是静态分配给特定硬件跟踪源的，但其他主控和通道可供软件使用。软件跟踪源通常可以从这个池中自由选择任何主控/通道组合。

在接收端（解码器端），跟踪源只能通过主控/通道组合来识别，因此为了让解码器能够理解涉及多个跟踪源的跟踪数据，它需要能够将这些主控/通道对映射到它所理解的跟踪源。例如，知道 syslog 消息来自主控 7 的通道 15，而任意用户应用程序可以使用主控 48 到 63 和通道 0 到 127 是有帮助的。

为了解决这种映射问题，stm 类提供了通过 configfs 进行政策管理的机制，允许定义规则，将字符串标识符映射到主控和通道的范围。如果这些规则（政策）与解码器期望的一致，那么它就能够正确处理跟踪数据。

这个政策是一个树形结构，包含规则（policy_node），每个规则都有一个名称（字符串标识符）以及关联的主控和通道范围。这个树形结构位于 configfs 中的“stp-policy”子系统目录内。最顶层目录的名称（即政策）格式化为适用于该政策的 STM 设备名称和一个任意字符串标识符，并以句点分隔。从上面的例子来看，一个规则可能如下所示：

```
$ ls /config/stp-policy/dummy_stm.my-policy/user
channels masters
$ cat /config/stp-policy/dummy_stm.my-policy/user/masters
48 63
$ cat /config/stp-policy/dummy_stm.my-policy/user/channels
0 127
```

这意味着此规则的主控分配池包括主控 48 到 63，通道分配池包括通道 0 到 127。现在，任何标识为“user”的生产者（跟踪源）将从这些范围内分配一个主控和通道。

这些规则可以嵌套，例如，可以在上面示例中的“user”目录下定义一个名为“dummy”的规则，这个新规则将用于标识为“user/dummy”的跟踪源。

跟踪源需要打开 stm 类设备的节点，并将它们的跟踪数据写入其文件描述符。

为了找到适用于给定跟踪源的适当政策节点，可以使用几种机制。首先，跟踪源可以通过调用字符设备文件描述符上的 STP_POLICY_ID_SET ioctl 明确标识自己，并提供其 ID 字符串，然后再写入任何数据。其次，如果它们选择不进行显式标识（因为您可能不想修补现有软件来做这件事），它们可以直接开始写入数据，此时 stm 核心将尝试查找与任务名称（如“syslogd”）匹配的政策节点，并在存在时使用它。第三，如果无法在政策节点中找到任务名称，则会使用通配条目“default”，如果它存在的话。这个条目也需要由系统管理员或负责政策配置的工具创建和配置。最后，如果所有上述步骤都失败，则写入 stm 文件描述符的操作将返回错误（EINVAL）。

以前，如果未找到跟踪源的政策节点，stm 类将默默地回退到从设备的主控/通道范围的开头分配第一个可用的连续主控/通道范围。新的要求是必须存在政策节点，这将帮助程序员和系统管理员识别配置中的空白，并更好地控制未识别的来源。
一些STM设备可能允许直接将通道MMIO区域映射到用户空间，以实现零拷贝写入。一个可映射的页面（就MMU而言）通常包含多个通道的MMIO，因此用户需要通过上述ioctl()调用为自己分配相应数量的通道才能进行这种操作。也就是说，如果你的STM设备的通道MMIO区域为64字节且硬件页大小为4096字节，在成功执行宽度为64的STP_POLICY_ID_SET ioctl()调用后，你应该能够在这个文件描述符上mmap()一页，并获得对64个通道MMIO区域的直接访问权限。Intel(R) Trace Hub [1] 和Coresight STM [2]是STM设备的一些示例。

### stm_source

对于基于内核的跟踪源，有一个名为“stm_source”的设备类。此类设备可以通过sysfs属性“stm_source_link”在运行时连接和断开与STM设备的连接，方法是在该属性中写入所需STM设备的名称，例如：

```
$ echo dummy_stm.0 > /sys/class/stm_source/console/stm_source_link
```

有关如何在内核中使用stm_source接口的示例，请参阅stm_console、stm_heartbeat或stm_ftrace驱动程序。
每个stm_source设备都需要假设一个主设备和一组通道范围，具体取决于它所需的通道数量。这些根据策略配置为设备分配。如果在策略目录根目录下存在与stm_source设备名称匹配的节点（例如，“console”），则此节点将用于分配主设备和通道号。如果没有这样的策略节点，stm核心将使用捕获所有情况的条目"default"（如果存在）。如果两者都不存在，则对stm_source_link的写入将返回错误。

### stm_console

在上面的例子中也使用了这个接口的一个实现——“stm_console”驱动程序，它基本上提供了一个通过STM设备传输内核消息的单向控制台。
要配置分配给此控制台的STP流中的主/通道对，请创建一个“console”策略条目（参见本文开头关于如何创建的说明）。初始化时，它将消耗一个通道。

### stm_ftrace

这是另一个“stm_source”设备，一旦stm_ftrace与一个STM设备链接，并且启用了“function”追踪器，Ftrace子系统会存储到环形缓冲区中的函数地址和父函数地址将同时通过STM设备导出。
目前仅支持Ftrace的“function”追踪器。

* [1] https://software.intel.com/sites/default/files/managed/d3/3c/intel-th-developer-manual.pdf
* [2] http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0444b/index.html
