.. SPDX-License-Identifier: GPL-2.0 OR GFDL-1.2-no-invariants-only

===========================
无锁环形缓冲区设计
===========================

版权所有 2009 红帽公司
:作者:   Steven Rostedt <srostedt@redhat.com>
:许可证:  GNU 自由文档许可协议，版本 1.2
           （同时根据 GPL v2 授权）
:审阅者:  Mathieu Desnoyers, 黄颖, Hidetoshi Seto,
	     和 Frederic Weisbecker
编写用于: 2.6.31

本文档中使用的术语
-------------------

tail（尾部）
    - 环形缓冲区中新写入发生的位置
head（头部）
    - 环形缓冲区中新读取发生的位置
producer（生产者）
    - 向环形缓冲区写入的任务（与 writer 相同）

writer（写入者）
    - 与 producer 相同

consumer（消费者）
    - 从缓冲区读取的任务（与 reader 相同）

reader（读取者）
    - 与 consumer 相同
reader_page（读取者页面）
    - 一个位于环形缓冲区之外的页面，主要用于（大部分情况下）读取者
head_page（头部页面）
    - 指向读取者将要使用下一页的指针

tail_page（尾部页面）
    - 指向下一次写入页面的指针

commit_page（提交页面）
    - 指向最后一次完成的非嵌套写入的页面
cmpxchg（比较并交换）
    - 一种硬件辅助的原子事务，执行以下操作：

        A = B 如果之前的 A == C

        R = cmpxchg(A, C, B) 表示我们仅在当前 A 等于 C 的情况下用 B 替换 A，并将旧的（当前的）A 放入 R

        无论 A 是否被更新为 B，R 都会得到之前的 A
为了检查更新是否成功，可以进行 ``R == C`` 的比较
通用环形缓冲区
-----------------------

环形缓冲区可以在覆盖模式或生产者/消费者模式下使用
生产者/消费者模式是指，如果生产者在消费者能够释放任何空间之前填满了缓冲区，生产者将停止向缓冲区写入。这会导致丢失最近的事件。

覆盖模式是指，如果生产者在消费者能够释放任何空间之前填满了缓冲区，生产者将覆盖较旧的数据。这会导致丢失最旧的事件。

没有两个写入者可以同时写入（在同一份每CPU缓冲区上），但一个写入者可以中断另一个写入者，但它必须在前一个写入者继续之前完成写入。这一点对算法非常重要。写入者的行为像一个“栈”。中断的工作方式强制了这种行为：

```
写入者1开始
    <被抢占> 写入者2开始
        <被抢占> 写入者3开始
                        写入者3完成
                    写入者2完成
    写入者1完成
```

这非常类似于一个写入者被中断抢占，而中断也在进行写入。
读取可以在任何时候发生。但是没有两个读取者可以同时运行，一个读取者也不能抢占/中断另一个读取者。读取者不能抢占/中断写入者，但它可以在写入者写入的同时从缓冲区读取/消费，但读取者必须在另一个处理器上才能这样做。读取者可以在自己的处理器上读取，并且可以被写入者抢占。

写入者可以抢占读取者，但读取者不能抢占写入者。
但是读取者可以在另一个处理器上与写入者同时读取缓冲区。
环形缓冲区由一个链表连接的页面列表组成。
在初始化时，为不属于环形缓冲区的读取者分配一个读取页面。
头页面、尾页面和提交页面都被初始化为指向同一个页面。
读取页面被初始化为下一个指针指向头页面，上一个指针指向头页面之前的页面。
读者有自己的页面来使用。启动时，这个页面会被分配但不附加到列表中。当读者想要从缓冲区读取时，如果它的页面是空的（就像启动时那样），它会将其页面与头页面交换。旧的读者页面将变为环形缓冲区的一部分，而头页面则被移除。插入页面（旧读者页面）之后的页面将成为新的头页面。
一旦新的页面交给读者，读者可以随其意愿处理这个页面，只要写入者已经离开了该页面。
下面是一个如何交换读者页面的示例：请注意，这没有显示缓冲区中的头页面，仅用于演示交换过程：

```
  +------+
  |reader|          RING BUFFER
  |page  |
  +------+
                  +---+   +---+   +---+
                  |   |-->|   |-->|   |
                  |   |<--|   |<--|   |
                  +---+   +---+   +---+
                   ^ |             ^ |
                   | +-------------+ |
                   +-----------------+


  +------+
  |reader|          RING BUFFER
  |page  |-------------------+
  +------+                   v
    |             +---+   +---+   +---+
    |             |   |-->|   |-->|   |
    |             |   |<--|   |<--|   |<-+
    |             +---+   +---+   +---+  |
    |              ^ |             ^ |   |
    |              | +-------------+ |   |
    |              +-----------------+   |
    |              +-----------------+   |
    +------------------------------------+

  +------+
  |reader|          RING BUFFER
  |page  |-------------------+
  +------+ <---------------+ v
    |  ^          +---+   +---+   +---+
    |  |          |   |-->|   |-->|   |
    |  |          |   |   |   |<--|   |<-+
    |  |          +---+   +---+   +---+  |
    |  |             |             ^ |   |
    |  |             +-------------+ |   |
    |  +-----------------------------+   |
    +------------------------------------+

  +------+
  |buffer|          RING BUFFER
  |page  |-------------------+
  +------+ <---------------+ v
    |  ^          +---+   +---+   +---+
    |  |          |   |   |   |-->|   |
    |  |  New     |   |   |   |<--|   |<-+
    |  | Reader   +---+   +---+   +---+  |
    |  |  page ----^                 |   |
    |  |                             |   |
    |  +-----------------------------+   |
    +------------------------------------+
```

有可能交换的页面是提交页面和尾页面，如果环形缓冲区中的内容少于一个缓冲页面所持有的内容。

```
            reader page    commit page   tail page
                |              |             |
                v              |             |
               +---+           |             |
               |   |<----------+             |
               |   |<------------------------+
               |   |------+
               +---+      |
                          |
                          v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |--->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+
```

这种情况对于此算法仍然是有效的。当写入者离开页面时，它直接进入环形缓冲区，因为读者页面仍然指向环形缓冲区中的下一个位置。
主要指针包括：

- **读者页面**：仅由读者使用的页面，并不是环形缓冲区的一部分（可能会被交换进来）。
- **头页面**：环形缓冲区中下一个将要与读者页面交换的页面。
- **尾页面**：下一个写入操作将要发生的页面。
- **提交页面**：最后一个完成写入操作的页面。
提交页面仅由最外层的写入器在写入栈中更新。一个抢占其他写入器的写入器不会移动提交页面。
当数据被写入环形缓冲区时，会在环形缓冲区中预留一个位置，并将其返回给写入器。当写入器完成向该位置写入数据后，会提交写入操作。
在此事务期间，可能会发生另一个写入（或读取）。如果发生另一个写入，则必须先完成该写入才能继续之前的写入。

写入预留示例：

```
       缓冲区页面
      +---------+
      |已写入  |
      +---------+  <--- 返回给写入器（当前提交）
      |预留  |
      +---------+ <--- 尾指针
      |空  |
      +---------+
```

写入提交示例：

```
       缓冲区页面
      +---------+
      |已写入  |
      +---------+
      |已写入  |
      +---------+  <--- 下一个写入位置（当前提交）
      |空  |
      +---------+
```

如果在第一次预留之后发生写入：

```
       缓冲区页面
      +---------+
      |已写入  |
      +---------+  <-- 当前提交
      |预留  |
      +---------+  <--- 返回给第二个写入器
      |预留  |
      +---------+ <--- 尾指针
```

第二个写入器提交后：

```
       缓冲区页面
      +---------+
      |已写入  |
      +---------+  <--（上次完整提交）
      |预留  |
      +---------+
      |待定  |
      |提交  |
      +---------+ <--- 尾指针
```

第一个写入器提交后：

```
       缓冲区页面
      +---------+
      |已写入  |
      +---------+
      |已写入  |
      +---------+
      |已写入  |
      +---------+  <--（最后一次完整提交和尾指针）
```

提交指针指向最后一次未抢占其他写入而提交的位置。当一个抢占了其他写入的写入被提交时，它只会变成一个待定提交，在所有写入都被提交之前，不会成为完整的提交。提交页面指向具有最后一次完整提交的页面。尾页面指向最后一个写入的位置（在提交之前）。尾页面始终等于或位于提交页面之后。它可能领先几个页面。如果尾页面追上提交页面，则不再允许进行写入（无论环形缓冲区是覆盖模式还是生产者/消费者模式）。

页面顺序如下：

头页面
提交页面
尾页面

可能的情景：

```
                                尾页面
    头页面         提交页面  |
        |                 |        |
        v                 v        v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |--->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+
```

有一种特殊情况是头页面位于提交页面甚至尾页面之后。这发生在提交（和尾）页面与读取页面交换的情况下。这是因为头页面始终是环形缓冲区的一部分，但读取页面不是。每当环形缓冲区内部有一个未满页被提交，并且读取器交换了一个页面时，它将交换提交页面：

```
            读取页面    提交页面   尾页面
                |              |             |
                v              |             |
               +---+           |             |
               |   |<----------+             |
               |   |<------------------------+
               |   |------+
               +---+      |
                          |
                          v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |--->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+
                          ^
                          |
                      头页面
```

在这种情况下，当尾页面和提交页面重新进入环形缓冲区时，头页面不会移动。
如果提交页面仍在该页面上，读取器不能将页面交换到环形缓冲区中。如果读取遇到最后一次提交（实际提交而非待定或预留），则没有更多内容可读。
缓冲区被认为为空，直到另一个完整的提交完成。
当尾部页面与头部页面相遇时，如果缓冲区处于覆盖模式，则头部页面将向前推进一位。如果缓冲区处于生产者/消费者模式，则写入操作将失败。
覆盖模式：

```
        尾部页面
           |
           v
  +---+    +---+    +---+    +---+
<---|   |--->|   |--->|   |--->|   |--->
--->|   |<---|   |<---|   |<---|   |<---
  +---+    +---+    +---+    +---+
                  ^
                  |
              头部页面

        尾部页面
           |
           v
  +---+    +---+    +---+    +---+
<---|   |--->|   |--->|   |--->|   |--->
--->|   |<---|   |<---|   |<---|   |<---
  +---+    +---+    +---+    +---+
                             ^
                             |
                         头部页面

            尾部页面
                |
                v
  +---+    +---+    +---+    +---+
<---|   |--->|   |--->|   |--->|   |--->
--->|   |<---|   |<---|   |<---|   |<---
  +---+    +---+    +---+    +---+
                             ^
                             |
                         头部页面

注意：读取页面仍然指向之前的头部页面，但在交换发生时，它会使用最新的头部页面。
使环形缓冲区无锁化：
--------------------------------

无锁算法背后的主要思想是结合移动头部页面指针和与读取器交换页面。状态标志被放置在页面指针内部。为此，每个页面必须在内存中按4字节对齐。这将允许地址的最后两位用作标志，因为这些位对于地址来说总是为零。要获取地址，只需屏蔽掉标志即可：

  MASK = ~3

  地址 & MASK

这两比特将保持两个标志：

   HEADER
   - 被指向的页面是一个头部页面

   UPDATE
   - 被指向的页面正在被写入者更新，并且曾经或即将成为头部页面
```

```
        读取页面
           |
           v
     +---+
     |   |------+
     +---+      |
                     |
                     v
 +---+    +---+    +---+    +---+
<---|   |--->|   |-H->|   |--->|   |--->
--->|   |<---|   |<---|   |<---|   |<---
 +---+    +---+    +---+    +---+

上述指针 "-H->" 将设置 HEADER 标志。这意味着下一个页面将是读取器要交换出的页面。
这个指针表示下一个页面是头部页面。
当尾部页面遇到头部指针时，它将使用 cmpxchg 将指针更改为 UPDATE 状态：

        尾部页面
           |
           v
 +---+    +---+    +---+    +---+
<---|   |--->|   |-H->|   |--->|   |--->
--->|   |<---|   |<---|   |<---|   |<---
 +---+    +---+    +---+    +---+

        尾部页面
           |
           v
 +---+    +---+    +---+    +---+
<---|   |--->|   |-U->|   |--->|   |--->
--->|   |<---|   |<---|   |<---|   |<---
 +---+    +---+    +---+    +---+

"-U->" 表示一个处于 UPDATE 状态的指针。
任何对读取器的访问都需要某种锁来序列化读者。但写入者永远不会在写入环形缓冲区时获取锁。这意味着我们只需要担心单个读者，并且写入仅以“堆栈”形式抢占。
```
当读者尝试用环形缓冲区交换页面时，它也会使用`cmpxchg`。如果指向头部页面的指针中的标志位没有设置HEADER标志，则比较将失败，读者需要查找新的头部页面并重试。

注意：UPDATE和HEADER标志永远不会同时设置。

读者交换页面的过程如下：

```
  +------+
  |reader|          RING BUFFER
  |page  |
  +------+
                  +---+    +---+    +---+
                  |   |--->|   |--->|   |
                  |   |<---|   |<---|   |
                  +---+    +---+    +---+
                   ^ |               ^ |
                   | +---------------+ |
                   +-----H-------------+
```

读者将reader page的next指针设置为HEADER，并指向头部页面之后的页面：

```
  +------+
  |reader|          RING BUFFER
  |page  |-------H-----------+
  +------+                   v
    |             +---+    +---+    +---+
    |             |   |--->|   |--->|   |
    |             |   |<---|   |<---|   |<-+
    |             +---+    +---+    +---+  |
    |              ^ |               ^ |   |
    |              | +---------------+ |   |
    |              +-----H-------------+   |
    +--------------------------------------+
```

它使用cmpxchg更新前一个头部页面的指针，使其指向reader page。注意新指针不包含HEADER标志。这一操作原子地向前移动了头部页面：

```
  +------+
  |reader|          RING BUFFER
  |page  |-------H-----------+
  +------+                   v
    |  ^          +---+   +---+   +---+
    |  |          |   |-->|   |-->|   |
    |  |          |   |<--|   |<--|   |<-+
    |  |          +---+   +---+   +---+  |
    |  |             |             ^ |   |
    |  |             +-------------+ |   |
    |  +-----------------------------+   |
    +------------------------------------+
```

设置新的头部页面后，头部页面的前一个指针被更新到reader page：

```
  +------+
  |reader|          RING BUFFER
  |page  |-------H-----------+
  +------+ <---------------+ v
    |  ^          +---+   +---+   +---+
    |  |          |   |-->|   |-->|   |
    |  |          |   |   |   |<--|   |<-+
    |  |          +---+   +---+   +---+  |
    |  |             |             ^ |   |
    |  |             +-------------+ |   |
    |  +-----------------------------+   |
    +------------------------------------+

  +------+
  |buffer|          RING BUFFER
  |page  |-------H-----------+  <--- 新的头部页面
  +------+ <---------------+ v
    |  ^          +---+   +---+   +---+
    |  |          |   |   |   |-->|   |
    |  |  New     |   |   |   |<--|   |<-+
    |  | Reader   +---+   +---+   +---+  |
    |  |  page ----^                 |   |
    |  |                             |   |
    |  +-----------------------------+   |
    +------------------------------------+
```

另一个重要点：通过reader page的前一个指针回溯所指向的页面（现在指向新的头部页面）不会回溯到reader page。这是因为reader page不是环形缓冲区的一部分。通过next指针遍历环形缓冲区总会留在环形缓冲区内。通过prev指针遍历可能不会。

确定reader page的方法是检查页面的前一个指针。如果前一个页面的next指针不回溯到原始页面，则该原始页面是一个reader page：

```
             +--------+
             | reader |  next   +----+
             |  page  |-------->|    |<====== (buffer page)
             +--------+         +----+
                 |                | ^
                 |                v | next
            prev |              +----+
                 +------------->|    |
                                +----+
```

头部页面如何向前移动：

当尾部页面遇到头部页面并且缓冲区处于覆盖模式且有更多的写入发生时，必须在写入者移动尾部页面之前先移动头部页面。这是通过写入者执行cmpxchg来实现的，即将头部页面的指针从HEADER标志转换为设置UPDATE标志。一旦完成，读者将无法从缓冲区中交换头部页面，也无法移动头部页面，直到写入者完成移动。
这消除了读者对写入者的竞争。读者必须自旋，这就是为什么读者不能抢占写入者的原因：

```
              tail page
                 |
                 v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-H->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+
```

接下来将要设置为新的头部页面的页面：

```
             tail page
                 |
                 v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |-H->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+
```

设置新的头部页面后，可以将旧的头部页面指针恢复为NORMAL：

```
             tail page
                 |
                 v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |--->|   |-H->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+
```

移动头部页面后，尾部页面现在可以向前移动：

```
                      tail page
                          |
                          v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |--->|   |-H->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+
```

以上是简单的更新。现在来看更复杂的情况：
如前所述，如果足够的写入抢占了第一次写入，尾部页面可能会绕过整个缓冲区并与提交页面相遇。此时，我们必须开始丢弃写入（通常会向用户发出某种警告）。但如果提交仍在reader page上怎么办？提交页面不属于环形缓冲区的一部分。尾部页面必须考虑到这一点：

```
            reader page    commit page
                |              |
                v              |
               +---+           |
               |   |<----------+
               |   |
               |   |------+
               +---+      |
                          |
                          v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-H->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+
                 ^
                 |
             tail page
```

如果尾部页面简单地将头部页面向前推，那么离开reader page时提交将不会指向正确的页面。
解决方法是在推动头部页面之前测试提交页面是否在reader page上。如果是，则可以假设尾部页面绕过了缓冲区，必须丢弃新的写入。
这不是竞争条件，因为提交页面只能由最外层的写入者（被抢占的写入者）移动。
这意味着，在写入者移动尾部页面时，提交页面不会移动。如果reader page也作为提交页面使用，读者不能交换reader page。读者只需检查提交是否离开了reader page。一旦提交页面离开reader page，除非另一个读者与缓冲区页面（同时也是提交页面）进行交换，否则它不会回到reader page上。

嵌套写入
--------

在推动尾部页面的过程中，如果头部页面是下一个页面，则必须首先推动头部页面。如果头部页面不是下一个页面，则仅需使用cmpxchg更新尾部页面。
只有写入者会移动尾页。这必须以原子操作的方式完成，以防止嵌套写入者的干扰：

  temp_page = tail_page
  next_page = temp_page->next
  cmpxchg(tail_page, temp_page, next_page)

上述代码会在尾页仍然指向预期页面时更新尾页。如果失败，说明嵌套写入已将其向前推进，当前写入不需要再推进尾页：

```
             临时页面
                 |
                 v
          尾页面
                 |
                 v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |--->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

嵌套写入进入并向前推进尾页：

                      被嵌套写入推进的尾页面
              临时页面   |
                 |        |
                 v        v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |--->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

上述操作会导致 cmpxchg 失败，但因为尾页已经被向前推进，写入者只需再次尝试在新的尾页上预留空间。
但是，移动头页面的过程要复杂一些：

              尾页面
                 |
                 v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-H->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

写入将头页面指针转换为 UPDATE：

              尾页面
                 |
                 v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

但如果嵌套写入在此处抢占，则它会看到下一个页面是头页面，但也是嵌套的。它会检测到这一点并保存该信息。这种检测是通过查看 UPDATE 标志而不是 HEADER 或 NORMAL 指针来实现的。
嵌套写入将设置新的头页面指针：

             尾页面
                 |
                 v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |-H->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

但它不会重置 UPDATE 回到正常状态。只有将指针从 HEAD 转换为 UPDATE 的写入者才会将其转换回 NORMAL：

                      尾页面
                          |
                          v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |-H->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

嵌套写入完成后，最外层的写入者将把 UPDATE 指针转换为 NORMAL：

                      尾页面
                          |
                          v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |--->|   |-H->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

如果有多个嵌套写入进入并将尾页向前推进多页，情况会更加复杂：

  （第一个写入者）

              尾页面
                 |
                 v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-H->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

写入将头页面指针转换为 UPDATE：

              尾页面
                 |
                 v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |--->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

下一个写入者进入，并看到 UPDATE 并设置新的头页面：

  （第二个写入者）

             尾页面
                 |
                 v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |-H->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

嵌套写入将尾页向前推进。但它不会将旧的 UPDATE 页面设置为 NORMAL，因为它不是最外层的写入者：

                      尾页面
                          |
                          v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |-H->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

另一个写入者抢占并看到尾页之后的页面是一个头页面。它将其从 HEAD 转换为 UPDATE：

  （第三个写入者）

                      尾页面
                          |
                          v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |-U->|   |--->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

写入者将头页面向前推进：

  （第三个写入者）

                      尾页面
                          |
                          v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |-U->|   |-H->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

现在第三个写入者已经将 HEAD 标志转换为 UPDATE，它会将其转换为正常：

  （第三个写入者）

                      尾页面
                          |
                          v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |--->|   |-H->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

然后它将移动尾页并返回给第二个写入者：

  （第二个写入者）

                               尾页面
                                   |
                                   v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |--->|   |-H->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

第二个写入者无法移动尾页，因为它已经被移动，所以它会再次尝试并将数据添加到新的尾页。
它会返回给第一个写入者：

  （第一个写入者）

                               尾页面
                                   |
                                   v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |--->|   |-H->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

第一个写入者不能原子性地知道尾页是否在其更新头页面时发生了移动。它会将头页面更新为其认为的新头页面：

  （第一个写入者）

                               尾页面
                                   |
                                   v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |-H->|   |-H->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

由于 cmpxchg 返回指针的旧值，第一个写入者会认为其成功地将指针从 NORMAL 更新为 HEAD。
但如我们所见，这还不够。它还必须检查尾页是否在其原来的位置或下一页：

  （第一个写入者）

                 A        B    尾页面
                 |        |        |
                 v        v        v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |-H->|   |-H->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

如果尾页 != A 且尾页 != B，则必须将指针重置为 NORMAL。由于它只需要担心嵌套写入者，因此只需在设置头页面后检查这一点：

  （第一个写入者）

                 A        B    尾页面
                 |        |        |
                 v        v        v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |-U->|   |--->|   |-H->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+

现在写入者可以更新头页面了。这也是为什么头页面必须保持在 UPDATE 状态，并且只能由最外层的写入者重置的原因。这样可以防止读者看到不正确的头页面：

  （第一个写入者）

                 A        B    尾页面
                 |        |        |
                 v        v        v
      +---+    +---+    +---+    +---+
  <---|   |--->|   |--->|   |--->|   |-H->
  --->|   |<---|   |<---|   |<---|   |<---
      +---+    +---+    +---+    +---+
