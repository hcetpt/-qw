确定性自动机监控器合成
========================================

应用运行时验证（RV）技术的起点是对被审查系统的期望（或不期望）行为进行*规范*或*建模*。然后需要将这种形式化的表示*合成*为一个*监控器*，该监控器可以用于分析系统的跟踪记录。*监控器*通过一个*仪器*与系统连接，该仪器将来自*系统*的事件转换为*规范*中的事件。在Linux术语中，运行时验证监控器封装在*RV监控器*抽象中。RV监控器包括一组监控器实例（如每CPU监控器、每任务监控器等）、将监控器与系统参考模型连接起来的辅助函数以及作为对事件解析和异常反应的跟踪输出，如下图所示：

```
Linux  +----- RV Monitor ----------------------------------+ 正式领域
  领域 |                                                   | 
  +-------------------+     +----------------+     +-----------------+
  |   Linux内核       |     |     监控器     |     |     参考模型    |
  |     跟踪          |  -> |   实例(s)     | <-  |      （规范）   |
  | （仪器）           |     | （验证）      |     |                |
  +-------------------+     +----------------+     +-----------------+
         |                          |                       |
         |                          V                       |
         |                     +----------+                 |
         |                     | 反应      |                 |
         |                     +--+--+--+-+                 |
         |                        |  |  |                   |
         |                        |  |  +-> 跟踪输出？       |
         +------------------------|--|----------------------+
                                  |  +----> 恐慌？          
                                  +-------> <用户指定>

DA监控器合成
--------------------

基于自动机模型到Linux *RV监控器* 抽象的合成由dot2k工具自动化，并且rv/da_monitor.h头文件包含了一系列自动生成监控器代码的宏。

dot2k
-----

dot2k工具利用了dot2c的功能，将DOT格式的自动机模型转换为C表示，并创建了一个内核监控器的C代码骨架。例如，可以使用以下命令将位于[1]中的wip.dot模型转换为每CPU监控器：

```
$ dot2k -d wip.dot -t per_cpu
```

这将创建一个名为wip/的目录，其中包含以下文件：
- wip.h：用C编写的wip模型
- wip.c：RV监控器

wip.c文件包含监控器声明及系统仪器化的起点。
监控器宏
--------------

rv/da_monitor.h使用C宏实现了*监控器实例*的自动代码生成。使用宏进行监控器合成有三个优点：
- 减少代码重复；
- 方便错误修复/改进；
- 避免开发人员以（所谓的）非标准方式修改监控器核心代码来操控模型。

此初始实现提供了三种不同类型的监控器实例：
- ``#define DECLARE_DA_MON_GLOBAL(name, type)``
- ``#define DECLARE_DA_MON_PER_CPU(name, type)``
- ``#define DECLARE_DA_MON_PER_TASK(name, type)``

第一种声明了一个全局确定性自动机监控器的函数，第二种声明了具有每CPU实例的监控器，第三种声明了具有每任务实例的监控器。在所有情况下，'name'参数是一个标识监控器的字符串，而'type'参数是dot2k在C中表示模型时使用的数据类型。例如，具有两个状态和三个事件的wip模型可以用'unsigned char'类型存储。考虑到抢占控制是一种每CPU的行为，因此在wip.c文件中的监控器声明如下：

```
DECLARE_DA_MON_PER_CPU(wip, unsigned char);
```

通过调用下面列出的函数发送事件来进行监控器执行：

```
da_handle_event_$(MONITOR_NAME)($(来自事件枚举的事件));
da_handle_start_event_$(MONITOR_NAME)($(来自事件枚举的事件));
da_handle_start_run_event_$(MONITOR_NAME)($(来自事件枚举的事件));
```

``da_handle_event_$(MONITOR_NAME)()``函数是常规情况，其中如果监控器正在处理事件，则会处理该事件。
当监视器被启用时，它会被置于自动机的初始状态。然而，监视器并不知道系统是否处于*初始状态*。
`da_handle_start_event_$(MONITOR_NAME)()` 函数用于通知监视器系统正在返回初始状态，因此监视器可以开始监控下一个事件。
`da_handle_start_run_event_$(MONITOR_NAME)()` 函数用于通知监视器系统已知处于初始状态，因此监视器可以开始监控并监控当前事件。

以wip模型为例，“preempt_disable”和“sched_waking”事件应分别通过以下方式发送给监视器 [2]：

```c
da_handle_event_wip(preempt_disable_wip);
da_handle_event_wip(sched_waking_wip);
```

而“preempt_enabled”事件将使用：

```c
da_handle_start_event_wip(preempt_enable_wip);
```

来通知监视器系统将返回初始状态，从而使系统和监视器保持同步。

最终总结
--------

通过使用rv/da_monitor.h和dot2k进行监视器合成，开发人员的工作应仅限于系统的仪器化，从而增强对整体方法的信心。
[1] 关于确定性自动机格式及其表示之间的转换详情，请参阅：

```plaintext
Documentation/trace/rv/deterministic_automata.rst
```

[2] dot2k会在事件枚举中追加监视器名称后缀，以避免在导出全局vmlinux.h（由BPF程序使用）时产生冲突变量。
