高分辨率定时器和动态滴答设计说明
=====================================================

更多详细信息可以在OLS 2006的演讲论文《hrtimers及其超越》中找到。该论文是OLS 2006会议论文集第一卷的一部分，可以从OLS网站上获取：
https://www.kernel.org/doc/ols/2006/ols2006v1-pages-333-346.pdf

该演讲的幻灯片可以从以下链接下载：
http://www.cs.columbia.edu/~nahum/w6998/papers/ols2006-hrtimers-slides.pdf

幻灯片包含五个图表（第2、15、18、20、22页），这些图表展示了与时间相关的Linux子系统的变化。图1（第2页）显示了在高分辨率定时器和其他构建模块合并到主线内核之前Linux时间系统的结构。
注意：论文和幻灯片中提到的是“时钟事件源”，而我们现在改称为“时钟事件设备”。
该设计包含以下基本构建模块：

- 高分辨率定时器基础架构
- 当前时间和时钟源管理
- 时钟事件管理
- 高分辨率定时器功能
- 动态滴答

高分辨率定时器基础架构
---------------------------

高分辨率定时器基础架构被合并到了2.6.16版本的内核中。基础实现的细节可以在Documentation/timers/hrtimers.rst文件中找到。参见图2（OLS幻灯片第15页）。

与基于轮询的定时器的主要区别在于：

- 按时间顺序将定时器插入红黑树中
- 不依赖于滴答（处理基于纳秒）

当前时间和时钟源管理
-------------------------------------

约翰·斯尔茨（John Stultz）的通用当前时间（GTOD）框架将大量代码从架构特定的部分转移到了一个通用管理框架中，如图3（OLS幻灯片第18页）所示。架构特定的部分仅限于时钟源的低级硬件细节，这些细节在框架中注册，并基于质量进行选择。低级代码提供硬件设置和读取例程，并初始化数据结构，这些数据结构被通用时钟管理代码用来将时钟滴答转换为基于纳秒的时间值。所有其他与时间管理相关的功能都被移到了通用代码中。GTOD基础补丁已经被合并到2.6.18版本的内核中。
关于通用当前时间框架的更多信息可以在OLS 2005会议论文集第一卷中找到：

	http://www.linuxsymposium.org/2005/linuxsymposium_procv1.pdf

论文《我们不再年轻：一种新的时间与定时器方法》由J. Stultz, D.V. Hart, & N. Aravamudan撰写。
图3（OLS幻灯片第18页）展示了这种转变。
时钟事件管理
----------------------

虽然时钟源提供了对单调递增时间值的读取访问，但时钟事件设备用于调度下一个事件中断。目前定义的下一个事件是周期性的，其周期在编译时确定。各种事件驱动功能所使用的事件设备的设置和选择被硬编码在架构依赖的代码中。这导致所有架构中的代码重复，并使得更改系统配置以使用架构内置以外的事件中断设备变得极其困难。当前设计的另一个影响是，为了提供诸如高分辨率定时器或动态滴答等新功能，必须修改所有架构特定的实现。
时钟事件子系统试图通过提供一个通用解决方案来管理时钟事件设备及其在各种时钟事件驱动内核功能中的使用来解决这个问题。时钟事件子系统的目标是将时钟事件相关的架构依赖代码减少到纯粹的硬件相关处理，并允许轻松添加和利用新的时钟事件设备。它还减少了架构之间的重复代码，因为它提供了从中断服务处理器到硬件几乎固有的通用功能。
时钟事件设备要么由架构依赖的启动代码注册，要么在模块插入时注册。每个时钟事件设备填充一个带有时钟特定属性参数和回调函数的数据结构。时钟事件管理根据指定的属性参数决定时钟事件设备将支持的一组系统功能。这包括区分每CPU和全局系统事件设备。
系统级别的全局事件设备用于Linux周期性滴答。每CPU事件设备用于提供本地CPU功能，如进程计费、性能分析和高分辨率定时器。
管理层为时钟事件设备分配以下一个或多个功能：

- 系统全局周期性滴答（更新jiffies）
- 本地CPU更新进程时间
- 本地CPU性能分析
- 本地CPU下一个事件中断（非周期模式）

时钟事件设备将这些定时器中断相关功能的选择完全委托给管理层。时钟管理层在设备描述结构中存储一个函数指针，该指针需要从硬件级别处理程序调用。这移除了大量架构特定的定时器中断处理程序中的重复代码，并将对时钟事件设备以及分配定时器中断相关功能的控制权交给核心代码。
时钟事件层API相对较小。除了时钟事件设备注册接口外，它还提供了用于调度下一个事件中断、时钟事件设备通知服务以及支持挂起和恢复的功能。
该框架增加了大约700行代码，导致内核二进制文件大小增加了2KB。移除i386相关的代码减少了约100行代码，二进制文件大小减少约400字节。我们认为增加的灵活性和跨架构避免重复代码的优点足以抵消二进制文件大小的轻微增加。
架构转换在功能上没有影响，但允许在不修改时钟事件设备和定时器中断代码的情况下利用高分辨率和动态滴答功能。转换后，启用高分辨率定时器和动态滴答只需将`kernel/time/Kconfig`文件添加到特定架构的Kconfig中，并在空闲例程中添加动态滴答相关调用（总共在空闲函数和Kconfig文件中增加3行代码）。

图#4（OLS幻灯片第20页）展示了高分辨率定时器功能的转换过程。
-----------------------------------

在系统启动期间无法使用高分辨率定时器功能，而实现这一点既困难又无实际用途。必须初始化时钟事件设备框架、时钟源框架（GTOD）以及hrtimers本身，并在高分辨率功能生效之前注册适当的时钟源和时钟事件设备。直到hrtimers初始化完成之前，系统仍以常规低分辨率周期模式运行。时钟源和时钟事件设备层提供了通知功能，这些功能会告知hrtimers新硬件的可用性。hrtimers会在切换到高分辨率模式前验证已注册的时钟源和时钟事件设备的可用性。这确保了配置为高分辨率定时器的内核可以在缺乏必要硬件支持的系统上运行。
高分辨率定时器代码不支持仅具有全局时钟事件设备的SMP机器。支持这种硬件需要在中断发生时使用IPI调用，其开销远大于带来的好处。这就是为什么目前我们在i386 SMP系统中停止本地APIC进入C3电源状态时禁用了高分辨率和动态滴答。有一个解决思路作为变通方法，但问题尚未得到解决。
基于时间顺序插入的定时器提供了所有基础设施来决定在添加定时器时是否需要重新编程事件设备。这一决策是在每个定时器基上做出的，并在一个支持函数中同步每个CPU上的定时器基。设计允许系统为每个CPU的定时器基利用独立的每CPU时钟事件设备，但目前每个CPU仅利用一个可重新编程的时钟事件设备。
当定时器中断发生时，下一个事件中断处理程序从时钟事件分发代码被调用，并将过期的定时器从红黑树移动到单独的双向链表中，并调用软中断处理程序。hrtimer结构中的额外模式字段允许系统直接从下一个事件中断处理程序执行回调函数。这仅限于可以安全地在硬中断上下文中执行的代码。例如，对于像nanosleep中使用的唤醒函数，这样做的优势在于可以避免多达两次的上下文切换——从被中断的上下文切换到软中断再到由过期定时器唤醒的任务。
一旦系统切换到高分辨率模式，周期性滴答就会被关闭。这禁用了系统的全局周期性时钟事件设备——例如i386 SMP系统中的PIT。
周期性滴答功能是由每个CPU上的hrtimer提供的。回调函数在下一个事件中断上下文中执行，并更新jiffies并调用update_process_times和profiling。基于hrtimer的周期性滴答实现旨在扩展动态滴答功能。
这使得可以在UP系统上使用单个时钟事件设备来调度高分辨率定时器和周期性事件（jiffies滴答、性能分析、进程会计）。这一点已经在i386的PIT和PPC的Incrementer上得到了验证。
软中断（softirq）用于运行高分辨率定时器队列并执行回调，现在已从周期性定时器软中断中分离出来，以确保高分辨率定时信号的准确传递。这些高分辨率定时信号被itimer和POSIX间隔定时器所使用。虽然这个软中断的执行仍可能被其他软中断延迟，但这种分离显著减少了整体延迟。图#5（OLS幻灯片第22页）展示了这一转变。
动态时钟
-------------

动态时钟是基于高分辨率定时器替换周期性时钟（sched_tick）的逻辑结果。sched_tick高分辨率定时器的功能通过以下三个函数进行了扩展：

- hrtimer_stop_sched_tick
- hrtimer_restart_sched_tick
- hrtimer_update_jiffies

当CPU进入空闲状态时，会调用hrtimer_stop_sched_tick()。代码会评估下一个计划的定时事件（包括高分辨率定时器和定时轮），如果下一个事件的时间比下一个时钟更远，则会将sched_tick重新编程为该未来的事件，以便在没有无意义中断的情况下实现更长的空闲睡眠时间。此外，在空闲期间发生不会导致重新调度的中断时，也会调用此函数。这是必要的，因为中断处理程序可能会设置一个到期时间早于之前调用hrtimer_stop_sched_tick时确定的最近事件的新定时器。

当CPU在调用schedule()之前离开空闲状态时，会调用hrtimer_restart_sched_tick()。hrtimer_restart_sched_tick()会恢复周期性时钟，并保持其活动状态，直到下次调用hrtimer_stop_sched_tick()。

当在空闲期间发生中断时，会从irq_enter()调用hrtimer_update_jiffies()，以确保jiffies是最新的，并且中断处理程序不必处理可能过时的jiffies值。

动态时钟特性提供了统计值，这些统计值通过/proc/stat导出到用户空间，并可用于增强的电源管理控制。实现还为进一步的发展留有空间，例如完全无时钟系统（tickless系统），其中时间片由调度器控制、可变频率分析以及将来完全移除jiffies。

除了目前提交的i386支持外，补丁集已经扩展到了x86_64和ARM。MIPS和PowerPC的初步（正在进行中）支持也已经可用。

Thomas, Ingo
