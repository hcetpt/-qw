===============================
高分辨率内核定时器子系统 (hrtimers)
===============================

此补丁引入了一个新的高分辨率内核定时器子系统。有人可能会问：我们已经有了一个定时器子系统（kernel/timers.c），为什么需要两个定时器子系统？经过大量的尝试，试图将高分辨率和高精度特性集成到现有的定时器框架中，并在实践中测试了各种高分辨率定时器实现后，我们得出结论：定时轮代码本质上不适合这种做法。最初我们并不相信这一点（“一定有办法解决这个问题”），并投入了大量的努力尝试将其集成到定时轮中，但最终失败了。事后看来，这种集成之所以困难/不可能的原因有几个：

- 强制以相同方式处理低分辨率和高分辨率定时器会导致许多妥协、宏魔法和 #ifdef 混乱。timers.c 代码围绕 jiffies 和 32 位假设进行了非常紧密的编写，并且多年来针对相对狭窄的应用场景（在相对狭窄的 HZ 范围内的 jiffies）进行了优化——因此即使是对其进行小的扩展也很容易破坏定时轮的概念，导致更多的妥协。定时轮代码本身是非常优秀且紧凑的代码，在当前使用中没有任何问题——但它不适合扩展用于高分辨率定时器。
- 级联带来的不可预测的 [O(N)] 开销会导致延迟，从而需要更复杂的高分辨率定时器处理方法，这反过来又降低了鲁棒性。这样的设计仍然会导致相当大的时间不准确性。级联是定时轮概念的基本属性，无法在不严重损害 timers.c 其他部分的情况下“设计出去”。
- 当前基于定时轮实现的 POSIX 定时器子系统已经引入了相当复杂的绝对 CLOCK_REALTIME 定时器在 settimeofday 或 NTP 时间调整时所需的重新调整处理——进一步通过实例验证了我们的经验：即定时轮数据结构对于高分辨率定时器来说过于僵化。
- 定时轮代码最适合可以识别为“超时”的用例。这些超时通常设置为覆盖各种 I/O 路径中的错误条件，如网络和块 I/O。绝大多数这些定时器从未过期，也很少被重新级联，因为预期的正确事件及时到达，因此可以在进一步处理之前从定时轮中移除。因此，这些超时的用户可以接受定时轮的粒度和精度折衷，并且在很大程度上期望定时器子系统具有接近零的开销。精确计时并不是它们的核心需求——事实上，大多数使用的超时值都是临时决定的。对于它们而言，保证实际超时完成的处理最多只是一个必要的恶（因为大多数超时都在完成前被删除），因此应尽可能便宜且不干扰其他操作。
高精度定时器的主要用户是使用 nanosleep、POSIX 定时器和 itimer 接口的用户空间应用程序。此外，需要精确定时事件的内核用户（例如驱动程序和多媒体子系统）也可以从独立的高分辨率定时器子系统中受益。
虽然此子系统目前还不提供高分辨率时钟源，但 hrtimer 子系统可以轻松扩展高分辨率时钟功能，并且相关补丁正在迅速成熟。
实时和多媒体应用以及其他潜在的精确定时器用户的日益增长的需求，为分离“超时”和“精确定时器”子系统提供了另一个理由。
另一个潜在的好处是，这种分离允许对现有定时轮进行更多专用优化，以适应低分辨率和低精度用例——一旦将精度敏感的 API 从定时轮中分离出来并迁移到 hrtimers 中。例如，我们可以将超时子系统的频率从 250 Hz 降低到 100 Hz（甚至更低）。
HRTimer 子系统实现细节
----------------------------------------

基本设计考虑如下：

- 简洁性

- 数据结构不依赖于 jiffies 或任何其他粒度。所有内核逻辑均以 64 位纳秒精度运行，不妥协
- 简化现有的与定时相关的内核代码

另一个基本要求是，在激活时立即对定时器进行入队和排序。在考虑了包括基数树和哈希表在内的多种可能解决方案后，我们选择了红黑树作为基本数据结构。红黑树在内核中作为一种库提供，并被广泛应用于如内存管理和文件系统的性能关键区域。红黑树仅用于按时间排序，而单独的列表则用于使过期代码能够快速访问已排队的定时器，无需遍历红黑树（此单独列表对于引入高分辨率时钟时也非常有用，我们需要保持时间顺序的同时拥有独立的待处理和已过期间隔队列）。

时间排序入队不仅是为了高分辨率时钟的目的，它还简化了基于低分辨率 CLOCK_REALTIME 的绝对定时器处理。现有实现需要维护一个所有已启动的绝对 CLOCK_REALTIME 定时器的额外列表，并伴有复杂的锁定机制。在 `settimeofday` 和 NTP 情况下，所有定时器都需要出队，时间更改代码必须逐一修正它们，然后再重新入队。时间排序入队以及将过期时间存储为绝对时间单位的方式消除了 POSIX 定时器实现中的复杂且扩展性差的代码——设置时钟时无需触碰红黑树。这也使得 POSIX 定时器的处理总体上更为简单。
HRTimer 的锁和每 CPU 行为主要借鉴了现有的定时轮代码，因为该代码已经成熟且非常适用。由于不同的数据结构，共享代码并不是一个优势。此外，HRTimer 函数现在具有更清晰的行为和命名，例如 `hrtimer_try_to_cancel()` 和 `hrtimer_cancel()` （这两个函数大致相当于 `timer_delete()` 和 `timer_delete_sync()`），因此在算法级别上没有一对一的映射关系，也没有真正的代码共享潜力。
基本数据类型：所有时间值，无论是绝对的还是相对的，都采用一种特殊的 64 位纳秒精度类型：`ktime_t`
（最初，内核内部的 `ktime_t` 值及其操作通过宏和内联函数实现，并可以在“混合联合”类型和平坦的 64 位纳秒表示之间切换（编译时）。但在 Y2038 工作过程中放弃了这种方式。）

HRTimer - 定时器值的舍入
-----------------------------------

HRTimer 代码会将定时事件舍入到较低分辨率的时钟，这是不可避免的。除此之外，它不会进行任何人为的舍入。
一个问题在于，`clock_getres()` 接口应该向用户返回什么分辨率值。这将返回给定时钟的实际分辨率 —— 不管它是低分辨率、高分辨率还是人为低分辨率。

HRTimer - 测试和验证
-----------------------------------

我们使用基于 HRTimer 的高分辨率时钟子系统来验证 HRTimer 实现细节的实际效果，并运行了 POSIX 定时器测试以确保符合规范。我们还对低分辨率时钟进行了测试。
HRTimer 补丁将以下内核功能转换为使用 HRTimer：

- nanosleep
- itimers
- POSIX 定时器

对 `nanosleep` 和 POSIX 定时器的转换实现了 `nanosleep` 和 `clock_nanosleep` 的统一。
该代码在以下平台上成功编译：

i386, x86_64, ARM, PPC, PPC64, IA64

该代码在以下平台上进行了运行测试：

i386(单处理器/多处理器), x86_64(单处理器/多处理器), ARM, PPC

HRTimer 还被整合到 `-rt` 树中，伴随着基于 HRTimer 的高分辨率时钟实现，因此 HRTimer 代码得到了大量实际测试和使用。
托马斯·格莱克斯纳，因戈·莫尔纳尔
