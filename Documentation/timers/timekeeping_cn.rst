==============================================
时钟源、时钟事件、sched_clock() 和延迟定时器
==============================================

本文档试图简要解释一些基本的内核时间管理抽象概念。它部分涉及通常位于内核目录 drivers/clocksource 中的驱动程序，但相关代码可能散布在整个内核中。

如果你在内核源码中进行搜索，会发现许多架构特定的时钟源、时钟事件实现以及一些同样为架构特定的对 sched_clock() 函数和一些延迟定时器的重写。

为了提供平台的时间管理功能，时钟源提供了基本的时间线，而时钟事件则在这个时间线上特定的点触发中断，提供诸如高分辨率定时器等设施。

sched_clock() 用于调度和时间戳记录，而延迟定时器则利用硬件计数器提供精确的延迟来源。

时钟源
------

时钟源的作用是为系统提供一个时间线，告诉你当前所处的时间点。例如，在 Linux 系统上执行 'date' 命令最终会读取时钟源来确定确切的时间。

通常，时钟源是一个单调递增且原子的计数器，它提供 n 位计数，从 0 计数到 (2^n)-1，然后回到 0 并重新开始计数。

理想情况下，只要系统运行，时钟源就不会停止计数。它可能在系统挂起期间停止。

时钟源应尽可能具有高分辨率，并且其频率应尽可能稳定和准确，与实际世界中的时钟保持一致。它不应在时间上不可预测地来回跳动或偶尔丢失几个周期。

它必须不受某些硬件效应的影响，例如计数器寄存器在总线上分两阶段读取，先读取最低 16 位，再读取高 16 位，其间计数器位可能被更新，从而导致非常奇怪的计数值风险。
当墙钟精度的时钟源不令人满意时，时间保持代码中有一些特殊的处理和层次结构，例如将用户可见的时间同步到系统中的RTC时钟或使用NTP与网络时间服务器同步。但它们基本上只是更新一个相对于时钟源的偏移量，该时钟源为系统提供了基本的时间线。这些措施不会直接影响时钟源本身，它们只是使系统适应时钟源的不足。

时钟源结构应当提供一种方法，将提供的计数器转换为纳秒值（作为一个无符号长整型（无符号64位）数字）。由于此操作可能会被频繁调用，因此严格从数学意义上进行这种转换是不可取的。相反，使用乘法和移位运算来尽可能接近纳秒值。在`clocksource_cyc2ns()`函数中可以看到如下形式：

  `ns ~= (clocksource * mult) >> shift`

你会在时钟源代码中找到一些辅助函数，用于提供这些`mult`和`shift`值，例如`clocksource_khz2mult()`、`clocksource_hz2mult()`等，这些函数有助于根据固定的移位值确定`mult`因子；而`clocksource_register_hz()`和`clocksource_register_khz()`则可以根据时钟源的频率帮助分配`shift`和`mult`因子。对于从单个I/O内存位置访问的简单时钟源，现在甚至有`clocksource_mmio_init()`函数，它可以接收一个内存位置、位宽、一个参数来指示寄存器中的计数器是递增还是递减，以及定时器时钟速率，并生成所有必要的参数。

由于一个32位计数器在100MHz下大约43秒后会回零，处理时钟源的代码必须对此进行补偿。这就是为什么时钟源结构还包含一个`mask`成员，用于说明时钟源的有效位数。这样，时间保持代码可以知道计数器何时会回零，并在回零点两侧插入必要的补偿代码，以确保系统时间线保持单调性。

### 时钟事件

时钟事件是时钟源的概念反向：它们接受一个期望的时间规格值，并计算出要写入硬件定时器寄存器的值。

时钟事件与时钟源是正交的。相同的硬件和寄存器范围可能用于时钟事件，但本质上是不同的事物。驱动时钟事件的硬件必须能够触发中断，以便在系统时间线上触发事件。在一个SMP系统中，理想情况下每个CPU核心都有一个这样的事件驱动定时器，使得每个核心可以独立于其他核心触发事件。

你会发现时钟事件设备代码基于同样的基本思想，即使用`mult`和`shift`算术将计数器转换为纳秒值，并且你会发现同样的一系列辅助函数用于分配这些值。然而，时钟事件驱动程序不需要`mask`属性：系统不会试图计划超出时钟事件时间范围的事件。
sched_clock()
-------------

除了时钟源和时钟事件外，内核中还有一个特殊的弱函数叫做 sched_clock()。该函数应返回自系统启动以来的纳秒数。架构可以自行选择是否提供 sched_clock() 的实现。如果没有提供本地实现，则会使用系统的 jiffies 计数器作为 sched_clock()。

如其名称所示，sched_clock() 主要用于调度系统，例如在 CFS 调度程序中确定某个进程的确切时间片。当您选择在 printk 中包含时间信息（例如用于启动图表）时，它也用于 printk 时间戳。

与时钟源相比，sched_clock() 必须非常快：它被调用得更频繁，尤其是由调度程序调用。如果您必须在精度与时钟源之间进行权衡，可以在 sched_clock() 中牺牲精度以换取速度。然而，它需要与时钟源相同的一些基本特性，即应该是单调递增的。

sched_clock() 函数只能在无符号长整型（unsigned long long）边界上溢出，即在 64 位之后。由于这是一个纳秒值，这意味着大约 585 年后才会溢出。（对于大多数实际系统来说，这意味着“永远不会”溢出。）

如果架构没有提供自己的实现，则会退回到使用 jiffies，使其最大分辨率为架构的 jiffies 频率的 1/HZ。这将影响调度精度，并可能在系统基准测试中表现出来。

驱动 sched_clock() 的时钟可能会在系统挂起/休眠期间停止或重置为零。这对于系统上的事件调度功能来说无关紧要。但是，这可能导致 printk() 中出现有趣的时间戳。

sched_clock() 函数应在任何上下文中都可调用，并且是 IRQ 和 NMI 安全的，在任何上下文中都能返回合理值。

某些架构可能具有有限的时间源集，并且缺乏一个良好的计数器来生成 64 位纳秒值。因此，例如在 ARM 架构上，创建了特殊辅助函数，以便从 16 位或 32 位计数器中提供 sched_clock() 的纳秒基数。有时也会使用同一个计数器作为时钟源。

在 SMP 系统上，为了性能考虑，必须能够在每个 CPU 上独立地调用 sched_clock()，而不受任何同步性能的影响。

一些硬件（如 x86 TSC）会导致系统中的各个 CPU 上的 sched_clock() 函数产生漂移。内核可以通过启用 CONFIG_HAVE_UNSTABLE_SCHED_CLOCK 选项来解决这个问题。这也是使 sched_clock() 与普通时钟源不同的另一个方面。

延迟定时器（仅部分架构）
----------------------------

在具有可变 CPU 频率的系统上，各种 kernel delay() 函数有时会出现奇怪的行为。基本上这些延迟通常使用硬循环，通过一个“lpj”（每 jiffies 的循环次数）值来延迟一定数量的 jiffies 分数，该值在启动时进行校准。
让我们希望你的系统在进行校准这个值时能够以最大频率运行：当频率降至满频的一半时，任何 delay() 的延迟时间将会是原来的两倍。通常这并不会造成问题，因为通常你请求的延迟时间本身就是那么多或更多。但在这样的系统上，其语义基本上是不可预测的。

这时基于定时器的延迟就派上了用场。使用这种方法，可以通过读取定时器来代替硬编码的循环以提供所需的延迟。
这是通过声明一个 `struct delay_timer` 并为其分配相应的函数指针和速率设置来实现的。
这种机制在某些架构上可用，比如 OpenRISC 或 ARM。
