======================================
NO_HZ：减少调度时钟中断
======================================

本文档描述了Kconfig选项和启动参数，这些选项和参数可以减少调度时钟中断的数量，从而提高能效并降低操作系统抖动。降低操作系统抖动对于某些类型的高度计算密集型高性能计算（HPC）应用以及实时应用非常重要。

管理调度时钟中断（也称为“调度时钟滴答”或简称“滴答”）主要有三种方式：

1. 永不省略调度时钟滴答（`CONFIG_HZ_PERIODIC=y` 或旧内核中的 `CONFIG_NO_HZ=n`）。通常你不希望选择这个选项。
2. 在空闲的CPU上省略调度时钟滴答（`CONFIG_NO_HZ_IDLE=y` 或旧内核中的 `CONFIG_NO_HZ=y`）。这是最常见的方法，并且应该是默认配置。
3. 在空闲或仅有单个可运行任务的CPU上省略调度时钟滴答（`CONFIG_NO_HZ_FULL=y`）。除非你正在运行实时应用或某些类型的HPC工作负载，否则通常你不希望启用这个选项。

以下三个部分分别描述了这三种情况，接着是关于RCU特定考虑的章节、测试讨论章节，最后是已知问题列表。

永不省略调度时钟滴答
=====================

上世纪90年代和2000年初的非常老版本的Linux无法省略调度时钟滴答。实际上，在某些情况下，这种传统方法仍然是正确的选择，例如在具有大量使用短时间CPU爆发的任务的重负载中，这些任务频繁进入空闲状态，但空闲时间也非常短暂（几十或几百微秒）。对于这类工作负载，由于每个CPU上经常有多个可运行任务，调度时钟中断通常仍然会被触发。在这种情况下，尝试关闭调度时钟中断除了增加从空闲状态切换以及用户态与内核态之间转换的开销外，不会产生任何效果。

可以通过设置 `CONFIG_HZ_PERIODIC=y`（或旧内核中的 `CONFIG_NO_HZ=n`）来选择这种操作模式。

然而，如果你运行的是轻负载并且有较长的空闲期，不省略调度时钟中断会导致过高的功耗。这对电池供电设备尤其不利，因为它会导致极短的电池寿命。如果你运行的是轻负载，你应该阅读接下来的部分。

此外，如果你运行的是实时负载或具有短迭代周期的HPC负载，调度时钟中断可能会降低你的应用程序性能。如果这描述了你的工作负载，你应该继续阅读下面两个部分。

在空闲CPU上省略调度时钟滴答
===============================

如果一个CPU处于空闲状态，就没有必要向它发送调度时钟中断。毕竟，调度时钟中断的主要目的是迫使繁忙的CPU在多个任务之间切换注意力，而空闲的CPU没有需要切换的任务。
一个没有收到调度时钟中断的空闲 CPU 被称为“dyntick-idle”、“处于 dyntick-idle 模式”、“处于 nohz 模式”，或“运行无时钟模式”。本文档其余部分将使用“dyntick-idle 模式”。

`CONFIG_NO_HZ_IDLE=y` 的 Kconfig 选项使得内核避免向空闲 CPU 发送调度时钟中断，这对电池供电设备和高度虚拟化的大型机至关重要。

一台运行 `CONFIG_HZ_PERIODIC=y` 内核的电池供电设备会很快耗尽其电池，速度可能是同样设备运行 `CONFIG_NO_HZ_IDLE=y` 内核的两到三倍。一台运行 1500 个操作系统实例的大型机可能会发现其一半的 CPU 时间被不必要的调度时钟中断消耗掉了。在这些情况下，有强烈的动机避免向空闲 CPU 发送调度时钟中断。不过，dyntick-idle 模式并非免费：

1. 它增加了进入和退出空闲循环所需的指令数量。
2. 在许多架构上，dyntick-idle 模式还增加了昂贵的时钟重新编程操作的数量。

因此，具有严格实时响应要求的系统通常运行 `CONFIG_HZ_PERIODIC=y` 内核（或旧内核中的 `CONFIG_NO_HZ=n`），以避免从空闲状态切换时的延迟恶化。

还有一个启动参数 `nohz=` 可用于通过指定 `nohz=off` 来禁用 `CONFIG_NO_HZ_IDLE=y` 内核中的 dyntick-idle 模式。默认情况下，`CONFIG_NO_HZ_IDLE=y` 内核启动时 `nohz=on`，启用 dyntick-idle 模式。

省略只有一个可运行任务的 CPU 的调度时钟中断
================================================

如果一个 CPU 只有一个可运行的任务，发送调度时钟中断是没有意义的，因为没有其他任务可以切换。

注意，省略只有一个可运行任务的 CPU 的调度时钟中断也意味着省略空闲 CPU 的调度时钟中断。

`CONFIG_NO_HZ_FULL=y` 的 Kconfig 选项使得内核避免向只有一个可运行任务的 CPU 发送调度时钟中断，这样的 CPU 被称为“自适应时钟 CPU”。这对于具有严格实时响应要求的应用程序非常重要，因为它允许它们通过最大调度时钟中断持续时间来改善最坏情况下的响应时间。对于计算密集型短迭代工作负载也很重要：如果任何一个 CPU 在给定的迭代中被延迟，所有其他 CPU 将被迫空闲等待延迟的 CPU 完成。因此，延迟会被乘以 CPU 数量减一。在这种情况下，再次强烈需要避免发送调度时钟中断。
默认情况下，没有CPU会被设置为自适应时钟（adaptive-ticks）CPU。启动参数`nohz_full=`用于指定哪些CPU是自适应时钟CPU。例如，`nohz_full=1,6-8`表示CPU 1、6、7和8将被设置为自适应时钟CPU。请注意，禁止将所有CPU都标记为自适应时钟CPU：至少需要有一个非自适应时钟的CPU保持在线，以便处理时间维护任务，确保像`gettimeofday()`这样的系统调用在自适应时钟CPU上返回准确的值。（对于`CONFIG_NO_HZ_IDLE=y`的情况，这不是问题，因为没有运行的用户进程来观察时钟速率的轻微漂移。）这意味着您的系统必须至少有两个CPU，`CONFIG_NO_HZ_FULL=y`才能发挥作用。

此外，自适应时钟CPU必须将其RCU回调卸载到其他地方。这在下面的“RCU 影响”部分中有详细说明。

通常情况下，CPU尽可能长时间地保持在自适应时钟模式。特别是，切换到内核模式并不会自动改变模式。只有在必要时，CPU才会退出自适应时钟模式，例如，如果该CPU排队了一个RCU回调。

正如dyntick-idle模式一样，自适应时钟模式的好处并不是免费的：

1. `CONFIG_NO_HZ_FULL`选择了`CONFIG_NO_HZ_COMMON`，因此您不能在不启用dyntick idle的情况下运行自适应时钟。这种依赖关系贯穿了实现层面，因此所有`CONFIG_NO_HZ_IDLE`的成本也由`CONFIG_NO_HZ_FULL`承担。
2. 用户/内核之间的转换稍微更昂贵，因为需要通知内核子系统（如RCU）关于模式的变化。
3. POSIX CPU定时器阻止CPU进入自适应时钟模式。需要根据CPU时间消耗采取行动的实时应用需要使用其他手段来实现这一点。
4. 如果待处理的性能事件（perf events）多于硬件能处理的数量，通常会采用轮询的方式来逐步收集所有事件。但在自适应时钟模式下，这种轮询可能无法进行。预计通过阻止有大量待处理性能事件的CPU进入自适应时钟模式来解决这个问题。

5. 自适应时钟CPU的调度统计可能会与非自适应时钟CPU有所不同，这可能会干扰实时任务的负载均衡。尽管随着时间推移会有改进，但自适应时钟对于许多实时和计算密集型应用来说仍然非常有用。然而，上述缺点意味着目前不应默认启用自适应时钟。

### RCU 影响

在某些情况下，空闲的CPU不允许进入动态空闲模式或自适应时钟模式，最常见的场景是该CPU有待处理的RCU回调。可以通过使用 CONFIG_RCU_NOCB_CPU=y 的 Kconfig 选项将RCU回调处理卸载到“rcuo”线程上来避免这种情况。具体卸载哪些CPU可以使用“rcu_nocbs=”内核启动参数来指定，该参数接受逗号分隔的CPU列表或范围，例如，“1,3-5”表示选择CPU 1、3、4和5。需要注意的是，由“nohz_full”内核启动参数指定的CPU也会被卸载。被卸载的CPU永远不会排队RCU回调，因此RCU不会阻止这些CPU进入动态空闲模式或自适应时钟模式。不过，请注意，如果希望将“rcuo”线程固定到特定的CPU上，则需要用户空间来进行设置。否则，调度器将决定它们在哪里运行，而这可能不是您希望的位置。

### 测试

假设您启用了本文档中描述的所有OS抖动特性，但没有看到工作负载行为的任何变化。这是由于您的工作负载受OS抖动影响不大，还是因为其他原因？本节提供了一个简单的OS抖动测试套件，帮助回答这个问题。该测试套件可在以下git仓库的master分支上找到：

```
git://git.kernel.org/pub/scm/linux/kernel/git/frederic/dynticks-testing.git
```

克隆此仓库并按照README文件中的说明进行操作。该测试过程将生成一个跟踪文件，以便您评估是否成功从系统中消除了OS抖动。
如果此跟踪显示您已尽可能地消除了操作系统抖动，那么您可以得出结论：您的工作负载对操作系统抖动并不敏感。

注意：此测试要求系统至少有两个CPU。
我们目前还没有好的方法来消除单CPU系统的操作系统抖动。

已知问题
==========

* Dyntick-idle会稍微减慢进入和退出空闲状态的转换。
实际上，这在大多数情况下并不是一个问题，除非是最激进的实时工作负载。这些工作负载有选择禁用dyntick-idle模式的选项，而大多数工作负载都会选择禁用。然而，一些工作负载无疑希望使用自适应时钟来消除调度时钟中断的延迟。以下是这些工作负载的一些选项：

a. 使用用户空间中的PMQOS来告知内核您的延迟需求（推荐）
b. 在x86系统上，使用"idle=mwait"引导参数
c. 在x86系统上，使用"intel_idle.max_cstate="来限制最大C状态深度
d. 在x86系统上，使用"idle=poll"引导参数
但是，请注意，使用此参数可能会导致您的CPU过热，从而可能引起热节流，进而降低您的延迟——这种降级甚至可能比dyntick-idle更严重。此外，此参数实际上会在Intel CPU上禁用Turbo Mode，这可能会显著降低最大性能。

* 自适应时钟会稍微减慢用户/内核之间的转换。
这不预计会成为计算密集型工作负载的问题，因为这类工作负载的转换次数很少。需要仔细的基准测试来确定其他工作负载是否会受到这种影响。

* 自适应时钟（Adaptive-ticks）仅在给定CPU上只有一个可运行任务时才会起作用，尽管存在许多其他情况下不需要调度时钟中断。举一个例子，考虑一个具有一个高优先级SCHED_FIFO任务和任意数量低优先级SCHED_OTHER任务的CPU。在这种情况下，该CPU必须运行SCHED_FIFO任务，直到它被阻塞或另一个更高优先级的任务在这个CPU上唤醒（或被分配到这个CPU），因此没有必要向这个CPU发送调度时钟中断。然而，当前实现仍然会向具有单个可运行SCHED_FIFO任务和多个可运行SCHED_OTHER任务的CPU发送这些不必要的调度时钟中断。
即使在一个给定的CPU上有多个可运行任务，在当前正在运行的任务的时间片到期之前打断这个CPU也是没有意义的，而这通常远长于下一个调度时钟中断的时间。
更好地处理这些情况是未来的工作。

* 重新配置自适应空闲（adaptive idle）和RCU回调卸载需要重启。如果需要，可以在运行时提供重新配置功能，但由于在运行时重新配置RCU的复杂性，需要有一个极其充分的理由。
特别是考虑到你有简单的方法，即随时将所有CPU上的RCU回调卸载，并将其固定在你想固定的位置。

* 需要额外的配置来处理其他来源的操作系统抖动，包括中断、系统实用程序任务和进程。这种配置通常涉及将中断和任务绑定到特定的CPU上。

* 当前一些操作系统抖动源只能通过限制工作负载来消除。例如，唯一消除全局TLB撤销导致的操作系统抖动的方法是避免导致这些撤销的操作（如内核模块卸载操作）。另一个例子是，通过使用大页并限制应用程序使用的内存量，可以减少（在某些情况下甚至消除）页面错误和TLB缺失。预加载工作集也可以有所帮助，尤其是在结合mlock()和mlockall()系统调用时。

* 除非所有CPU都处于空闲状态，否则至少有一个CPU必须保持调度时钟中断以支持准确的时间记录。

* 如果可能有一些自适应时钟（adaptive-ticks）的CPU，那么即使所有其他CPU都处于空闲状态，也会至少有一个CPU保持调度时钟中断。
更好地处理这种情况仍在进行中。

* 一些进程处理操作仍然需要偶尔的调度时钟滴答。这些操作包括计算CPU负载、维护调度平均值、计算CFS实体的虚拟运行时间（vruntime）、计算avenrun以及执行负载均衡。目前，这些操作通过每秒左右一次的调度时钟滴答来实现。正在进行的工作将消除甚至对这些不频繁的调度时钟滴答的需求。
