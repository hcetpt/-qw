内容:
段落编号:

==========================
Linux 实现说明
==========================

本文件提供了关于 Linux 内核实现 eBPF 指令集的更详细信息。
字节交换指令
======================

`BPF_FROM_LE` 和 `BPF_FROM_BE` 分别作为 `BPF_TO_LE` 和 `BPF_TO_BE` 的别名存在。
跳转指令
=================

`BPF_CALL | BPF_X | BPF_JMP`（0x8d），其中辅助函数整数将从指定寄存器读取，当前不被验证器支持。任何包含此指令的程序在添加此类支持前将无法加载。
映射表
====

Linux 仅在单元素数组映射上支持 'map_val(map)' 操作。
Linux 使用 fd_array 来存储与 BPF 程序关联的映射表。因此，`map_by_idx(imm)` 使用数组中该索引处的 fd。
变量
=========

以下 64 位立即数指令指定了应加载的变量地址，该地址对应于存储在 'imm' 字段中的某个整数：

=========================  ======  ===  =========================================  ===========  ==============
指令结构                   指令码   源   假代码                                     立即数类型    目标类型
=========================  ======  ===  =========================================  ===========  ==============
BPF_IMM | BPF_DW | BPF_LD  0x18    0x3  dst = var_addr(imm)                        变量标识      数据指针
=========================  ======  ===  =========================================  ===========  ==============

在 Linux 上，这个整数是一个 BTF ID。
传统 BPF 包访问指令
=====================================

如 `ISA 标准文档 <instruction-set.html#legacy-bpf-packet-access-instructions>`_ 中所述，为了保持在 eBPF 解释器中运行的传统套接字过滤器的性能，Linux 有一组特殊的 eBPF 指令用于访问包数据，这些指令是从经典 BPF 继承而来的。
这些指令有两种形式：`BPF_ABS | <size> | BPF_LD` 和 `BPF_IND | <size> | BPF_LD`。
这些指令用于访问包数据，仅当程序上下文是指向网络包的指针时才能使用。`BPF_ABS` 在由立即数据指定的绝对偏移处访问包数据，而 `BPF_IND` 在包括寄存器值和立即数据的偏移处访问包数据。

这些指令有七个隐含操作数：

* 寄存器 R6 是一个隐含输入，必须包含指向 struct sk_buff 的指针。
* 寄存器R0是一个隐含的输出寄存器，其中包含从数据包中获取的数据。
* 寄存器R1至R5是临时寄存器，会被指令覆盖。

这些指令同样有一个隐含的程序退出条件。如果eBPF程序尝试访问超出数据包边界的额外数据，程序执行将会被终止。

``BPF_ABS | BPF_W | BPF_LD`` (0x20) 的含义是：

  R0 = ntohl(*(u32 *) ((struct sk_buff *) R6->data + imm))

其中 ``ntohl()`` 将一个32位数值从网络字节序转换为主机字节序。

``BPF_IND | BPF_W | BPF_LD`` (0x40) 的含义是：

  R0 = ntohl(*(u32 *) ((struct sk_buff *) R6->data + src + imm))

这里，`ntohl()` 同样用于将32位数值从网络字节序转换为主机字节序，而 `src` 是一个在指令中定义的源地址偏移量。但是根据上下文，`src` 可能是指寄存器中的值，该值与立即数 `imm` 相加以形成最终的内存地址。
