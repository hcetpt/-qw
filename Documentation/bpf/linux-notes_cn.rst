内容:
段落编号:

==========================
Linux 实现说明
==========================

本文件提供了关于 Linux 内核实现 eBPF 指令集的更多详细信息。
字节交换指令
======================

`BPF_FROM_LE` 和 `BPF_FROM_BE` 分别作为 `BPF_TO_LE` 和 `BPF_TO_BE` 的别名存在。
跳转指令
=================

`BPF_CALL | BPF_X | BPF_JMP`（0x8d），其中辅助函数整数将从指定寄存器读取，当前不被验证器支持。任何包含该指令的程序在添加此类支持之前都无法加载。
映射
====

Linux 仅支持对单元素数组映射使用 "map_val(map)" 操作。
Linux 使用 fd_array 来存储与 BPF 程序关联的映射。因此，
map_by_idx(imm) 使用数组中该索引处的 fd。
变量
=========

以下 64 位立即数指令指定了应加载一个变量地址，该地址对应于存储在 'imm' 字段中的某个整数：

=========================  ======  ===  =========================================  ===========  ==============
指令构造                 指令码   源   伪代码                                     立即数类型    目标类型
=========================  ======  ===  =========================================  ===========  ==============
BPF_IMM | BPF_DW | BPF_LD  0x18    0x3  dst = var_addr(imm)                        变量标识符    数据指针
=========================  ======  ===  =========================================  ===========  ==============

在 Linux 上，这个整数是一个 BTF ID。
传统 BPF 包访问指令
=====================================

如 `ISA 标准文档
<instruction-set.html#legacy-bpf-packet-access-instructions>`_ 中所述，
为了保留运行在 eBPF 解释器中的传统套接字过滤器性能，Linux 有专门的 eBPF 指令用于访问包数据，这些指令是从经典 BPF 继承过来的。

这些指令有两种形式：`BPF_ABS | <大小> | BPF_LD` 和 `BPF_IND | <大小> | BPF_LD`。

这些指令用于访问包数据，并且只能在程序上下文为指向网络包的指针时使用。`BPF_ABS` 在由立即数指定的绝对偏移处访问包数据，而 `BPF_IND` 在包括寄存器值和立即数的偏移处访问包数据。

这些指令有七个隐式操作数：

* 寄存器 R6 是一个隐式输入，必须包含指向 struct sk_buff 的指针。
* 寄存器R0是一个隐含的输出寄存器，其中包含从数据包中获取的数据
* 寄存器R1-R5是临时工作寄存器，会被指令覆盖

这些指令还有一个隐含的程序退出条件。如果eBPF程序尝试访问超出数据包边界的额外数据，程序执行将会被终止。

`BPF_ABS | BPF_W | BPF_LD` (0x20) 表示:

  R0 = ntohl(*(u32 *) ((struct sk_buff *) R6->data + imm))

其中 `ntohl()` 将一个32位数值从网络字节序转换为主机字节序

`BPF_IND | BPF_W | BPF_LD` (0x40) 表示:

  R0 = ntohl(*(u32 *) ((struct sk_buff *) R6->data + src + imm))
