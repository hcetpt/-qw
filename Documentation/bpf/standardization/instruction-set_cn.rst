.. contents::
.. sectnum::

======================================
BPF指令集架构（ISA）
======================================

eBPF，也常被称为BPF，是一种起源于Linux内核的技术，它可以在受信任的上下文中，如操作系统内核中，运行不可信程序。本文档指定了BPF指令集架构（ISA）。

作为历史注释，BPF最初代表Berkeley Packet Filter，但现在它可以做的远不止过滤数据包，这个缩写不再有意义。BPF现在被认为是一个独立的术语，不代表任何东西。原来的BPF有时被称为cBPF（经典BPF），以区别于现在广泛部署的eBPF（扩展BPF）。

文档约定
=========================

本文件中的关键词“MUST”，“MUST NOT”，“REQUIRED”，“SHALL”，“SHALL NOT”，“SHOULD”，“SHOULD NOT”，“RECOMMENDED”，“NOT RECOMMENDED”，“MAY”，和“OPTIONAL”在它们全部大写时，如这里所示，应按照BCP 14 `<https://www.rfc-editor.org/info/rfc2119>`_ 和 `<https://www.rfc-editor.org/info/rfc8174>`_ 中描述的方式进行解释。

为了简洁性和一致性，本文档使用了缩写语法来引用类型家族，并在描述指令语义时提到了几个说明性、助记符函数。

这些类型的合法值范围以及这些函数的语义在以下小节中定义。

类型
-----
本文档使用`SN`表示法来引用整数类型，其中`S`指定有无符号，`N`指定位宽。

.. table:: 有无符号表示法的含义

  ==== =========
  S    含义
  ==== =========
  u    无符号
  s    有符号
  ==== =========

.. table:: 位宽表示法的含义

  ===== =========
  N     位宽
  ===== =========
  8     8位
  16    16位
  32    32位
  64    64位
  128   128位
  ===== =========

例如，`u32`是一种类型，其有效值是所有32位无符号数字；而`s16`是一种类型，其有效值是所有16位有符号数字。

函数
---------

以下字节交换函数与方向无关。也就是说，同一函数用于下面讨论的任一方向的转换。

* be16：接受一个无符号16位数字，并在主机字节顺序和大端序（`IEN137 <https://www.rfc-editor.org/ien/ien137.txt>`_）字节顺序之间进行转换。
* be32：接受一个无符号32位数字，并在主机字节顺序和大端序字节顺序之间进行转换。
* be64: 接受一个无符号的64位数字，并在主机字节序与大端字节序之间进行转换。
* bswap16: 接受一个以大端或小端格式表示的无符号16位数字，并返回具有相同位宽但字节序相反的等效数字。
* bswap32: 接受一个以大端或小端格式表示的无符号32位数字，并返回具有相同位宽但字节序相反的等效数字。
* bswap64: 接受一个以大端或小端格式表示的无符号64位数字，并返回具有相同位宽但字节序相反的等效数字。
* le16: 接受一个无符号的16位数字，并在主机字节序与小端字节序之间进行转换。
* le32: 接受一个无符号的32位数字，并在主机字节序与小端字节序之间进行转换。
* le64: 接受一个无符号的64位数字，并在主机字节序与小端字节序之间进行转换。

定义
----

.. glossary::

  符号扩展
    对一个``X``位数`A`进行`符号扩展至` ``Y``位数`B`，意味着：

    #. 将`A`中的所有``X``位复制到`B`的低位``X``位中；
    #. 设置`B`中剩余的``Y`` - ``X``位为`A`的最高有效位的值。

.. 警告:: 示例

  在大端平台上将一个8位数`A`符号扩展至16位数`B`：
  ::

    A:          10000110
    B: 11111111 10000110

一致性组
--------

实现者无需支持本文件中指定的所有指令（例如，已弃用的指令）。相反，规定了多个一致性组。实现者**必须**支持base32一致性组，并且**可选**支持其他一致性组，其中支持一致性组意味着它**必须**支持该一致性组中的所有指令。
使用命名的符合性组（conformance groups）使得执行指令的运行时与生成运行时指令的工具（如编译器）之间能够实现互操作性。因此，根据符合性组进行的能力发现可能由用户手动完成或由工具自动完成。每个符合性组都有一个简短的ASCII标签（例如，“base32”），对应一组必须支持的指令集。也就是说，每条指令至少属于一个或多个符合性组。

本文件定义了以下符合性组：

- base32：包括本规范中定义的所有指令，除非另有说明。
- base64：包括base32中的所有指令，加上明确标注为属于base64符合性组的额外指令。
- atomic32：包括32位原子操作指令（参见“原子操作”部分）。
- atomic64：包括atomic32中的所有指令，加上64位原子操作指令。
- divmul32：包括32位除法、乘法和模运算指令。
- divmul64：包括divmul32中的所有指令，加上64位除法、乘法和模运算指令。
- packet：已弃用的包访问指令。

指令编码
=========

BPF有两种指令编码方式：

- 基础指令编码，使用64位来编码一条指令。
- 宽指令编码，在基础指令后追加第二个64位，总共使用128位进行编码。
基本指令编码
--------------------------

一个基本指令的编码如下所示：

  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    opcode     |     regs      |            offset             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              imm                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

**opcode**
  要执行的操作，其编码方式如下：

    +-+-+-+-+-+-+-+-+
    |specific |class|
    +-+-+-+-+-+-+-+-+

  **specific**
    这些位的格式根据指令类的不同而变化。

  **class**
    指令类（参见“指令类”）

**regs**
  源寄存器和目标寄存器编号，其在小端主机上编码如下：

    +-+-+-+-+-+-+-+-+
    |src_reg|dst_reg|
    +-+-+-+-+-+-+-+-+

  在大端主机上编码如下：

    +-+-+-+-+-+-+-+-+
    |dst_reg|src_reg|
    +-+-+-+-+-+-+-+-+

  **src_reg**
    源寄存器编号（0-10），除非另有说明（“64位立即数指令”重用此字段用于其他目的）

  **dst_reg**
    目标寄存器编号（0-10），除非另有说明（未来的指令可能重用此字段用于其他目的）

**offset**
  与指针算术一起使用的有符号整数偏移量，除非另有说明（某些算术指令重用此字段用于其他目的）

**imm**
  有符号整数立即值

需要注意的是，多字节字段（'offset'和'imm'）的内容存储时使用大端字节序在大端主机上以及小端字节序在小端主机上。
例如：

  opcode                  offset imm          assembly
         src_reg dst_reg
  07     0       1        00 00  44 33 22 11  r1 += 0x11223344 // 小端
         dst_reg src_reg
  07     1       0        00 00  11 22 33 44  r1 += 0x11223344 // 大端

需要注意的是，大多数指令不会使用所有字段，
未使用的字段必须清零至零。
宽指令编码
--------------------------

有些指令定义为使用宽指令编码，该编码使用两个32位立即数值。在基础指令格式之后的64位包含一条伪指令，
其中'opcode'、'dst_reg'、'src_reg'和'offset'均设置为零。
这在下图中表示：

  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    opcode     |     regs      |            offset             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              imm                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           reserved                            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           next_imm                            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

**opcode**
  要执行的操作，其编码方式如上所述

**regs**
  源寄存器和目标寄存器编号（除非另有说明），其编码方式如上所述

**offset**
  与指针算术一起使用的有符号整数偏移量，除非另有说明

**imm**
  有符号整数立即值

**reserved**
  未使用，设置为零

**next_imm**
  第二个有符号整数立即值

指令类
-------------------

'opcode'字段的最低三位存储指令类：

.. table:: 指令类

  =====  =====  ===============================  ===================================
  class  value  描述                      参考
  =====  =====  ===============================  ===================================
  LD     0x0    非标准加载操作                 “加载和存储指令”
  LDX    0x1    加载到寄存器操作              “加载和存储指令”
  ST     0x2    从立即数存储操作              “加载和存储指令”
  STX    0x3    从寄存器存储操作              “加载和存储指令”
  ALU    0x4    32位算术操作                  “算术和跳转指令”
  JMP    0x5    64位跳转操作                  “算术和跳转指令”
  JMP32  0x6    32位跳转操作                  “算术和跳转指令”
  ALU64  0x7    64位算术操作                  “算术和跳转指令”
  =====  =====  ===============================  ===================================

算术和跳转指令
================================

对于算术和跳转指令（``ALU``、``ALU64``、``JMP``和``JMP32``），8位'opcode'字段被分为三部分：

  +-+-+-+-+-+-+-+-+
  |  code |s|class|
  +-+-+-+-+-+-+-+-+

**code**
  操作码，其含义随指令类不同而变化

**s (source)**
  源操作数位置，除非另有说明，它为：

  .. table:: 源操作数位置

    ======  =====  ==============================================
    source  value  描述
    ======  =====  ==============================================
    K       0      使用32位'imm'值作为源操作数
    X       1      使用'src_reg'寄存器值作为源操作数
    ======  =====  ==============================================

**instruction class**
  指令类（参见“指令类”）

算术指令
-----------------------

``ALU``使用32位宽操作数，而``ALU64``使用64位宽操作数进行相同的操作。除非另有说明，``ALU64``指令属于base64一致性组。
'code'字段按以下方式编码操作，其中'src'指的是源操作数，'dst'指的是目标寄存器的值：
.. table:: 算术指令

  =====  =====  =======  ==========================================================
  name   code   offset   描述
  =====  =====  =======  ==========================================================
  ADD    0x0    0        dst += src
  SUB    0x1    0        dst -= src
  MUL    0x2    0        dst *= src
  DIV    0x3    0        dst = (src != 0) ? (dst / src) : 0
  SDIV   0x3    1        dst = (src != 0) ? (dst s/ src) : 0
  OR     0x4    0        dst |= src
  AND    0x5    0        dst &= src
  LSH    0x6    0        dst <<= (src & mask)
  RSH    0x7    0        dst >>= (src & mask)
  NEG    0x8    0        dst = -dst
  MOD    0x9    0        dst = (src != 0) ? (dst % src) : dst
  SMOD   0x9    1        dst = (src != 0) ? (dst s% src) : dst
  XOR    0xa    0        dst ^= src
  MOV    0xb    0        dst = src
  MOVSX  0xb    8/16/32  dst = (s8,s16,s32)src
  ARSH   0xc    0        dst >>= (src & mask) （符号扩展）
  END    0xd    0        字节交换操作（参见下面的“字节交换指令”）
  =====  =====  =======  ==========================================================

算术运算允许下溢和上溢，这意味着64位或32位值将循环。如果BPF程序执行会导致除以零，则目标寄存器将被设置为零。
如果执行会导致对零求模，则对于``ALU64``，目标寄存器的值保持不变，而对于``ALU``，目标寄存器的高32位被清零。
``{ADD, X, ALU}``，其中'code' = ``ADD``，'source' = ``X``，且'class' = ``ALU``，意味着：

  dst = (u32) ((u32) dst + (u32) src)

其中'(u32)'表示高32位被清零。
``{ADD, X, ALU64}``意味着：

  dst = dst + src

``{XOR, K, ALU}``意味着：

  dst = (u32) dst ^ (u32) imm

``{XOR, K, ALU64}``意味着：

  dst = dst ^ imm

需要注意的是，大多数算术指令的'offset'设置为0。只有三个指令（``SDIV``、``SMOD``、``MOVSX``）具有非零'offset'。
对于``ALU``的除法、乘法和模运算属于"divmul32"一致性组，而对于``ALU64``的除法、乘法和模运算则属于"divmul64"一致性组。

除法和模运算支持无符号和有符号两种类型。
对于无符号操作（``DIV``和``MOD``），在``ALU``中，'imm'被视为一个32位无符号值。在``ALU64``中，'imm'首先从32位到64位进行符号扩展，然后被视为一个64位无符号值。
对于有符号操作（``SDIV``和``SMOD``），在``ALU``中，'imm'被视为一个32位有符号值。在``ALU64``中，'imm'首先从32位到64位进行符号扩展，然后被视为一个64位有符号值。
需要注意的是，当被除数或除数为负数时，有符号模运算的定义各不相同，不同的编程语言实现可能会有所不同，如Python、Ruby等与C、Go、Java等的实现不同。本规范要求有符号模运算必须使用截断除法（其中-13 % 3 == -1），就像C、Go等语言中的实现一样：

   a % n = a - n * trunc(a / n)

``MOVSX``指令执行带有符号扩展的移动操作。
``{MOVSX, X, ALU}``将8位和16位的操作数进行符号扩展到32位，并将剩余的高32位清零。
``{MOVSX, X, ALU64}``将8位、16位和32位的操作数扩展到64位。与其它算术指令不同，``MOVSX``仅对寄存器源操作数（``X``）定义。
``{MOV, K, ALU64}``意味着：

  dst = (s64)imm

``{MOV, X, ALU}``意味着：

  dst = (u32)src

``{MOVSX, X, ALU}``当'offset'为8时意味着：

  dst = (u32)(s32)(s8)src

``NEG``指令仅在源位清除（``K``）时定义。
移位操作在64位操作中使用0x3F（63）的掩码，在32位操作中使用0x1F（31）的掩码。
字节交换指令
--------------
字节交换指令使用``ALU``和``ALU64``的指令类以及``END``字段的4位'code'。
字节交换指令仅作用于目标寄存器，不使用独立的源寄存器或立即值。对于`ALU`，操作码中的1位源操作数字段用于选择操作转换的字节顺序是从还是到。对于`ALU64`，操作码中的1位源操作数字段是保留的，必须设置为0。

.. 表格:: 字节交换指令

  =====  ========  =====  =================================================
  类别  源         值      描述
  =====  ========  =====  =================================================
  ALU    小端       0      在主机字节序和小端序之间转换
  ALU    大端       1      在主机字节序和大端序之间转换
  ALU64  预留       0      无条件进行字节交换
  =====  ========  =====  =================================================

'imm'字段编码了交换操作的宽度。支持以下宽度：16、32 和 64。宽度为64的操作属于base64一致性组，其他交换操作属于base32一致性组。
示例：

``{END, LE, ALU}``与'imm' = 16/32/64意味着：

  dst = le16(dst)
  dst = le32(dst)
  dst = le64(dst)

``{END, BE, ALU}``与'imm' = 16/32/64意味着：

  dst = be16(dst)
  dst = be32(dst)
  dst = be64(dst)

``{END, TO, ALU64}``与'imm' = 16/32/64意味着：

  dst = bswap16(dst)
  dst = bswap32(dst)
  dst = bswap64(dst)

跳转指令
--------

``JMP32``使用32位宽的操作数，并指示base32一致性组，而``JMP``使用64位宽的操作数进行相同的操作（除非另有说明），并指示base64一致性组。
'code'字段如下编码操作：

.. 表格:: 跳转指令

  ========  =====  =======  =================================  ===================================================
  code      值      src_reg  描述                                注释
  ========  =====  =======  =================================  ===================================================
  JA        0x0    0x0      PC += offset                        只有{JA, K, JMP}
  JA        0x0    0x0      PC += imm                           只有{JA, K, JMP32}
  JEQ       0x1    任意     如果dst == src则PC += offset
  JGT       0x2    任意     如果dst > src则PC += offset         无符号
  JGE       0x3    任意     如果dst >= src则PC += offset        无符号
  JSET      0x4    任意     如果dst & src则PC += offset
  JNE       0x5    任意     如果dst != src则PC += offset
  JSGT      0x6    任意     如果dst > src则PC += offset         有符号
  JSGE      0x7    任意     如果dst >= src则PC += offset        有符号
  CALL      0x8    0x0      通过静态ID调用辅助函数              只有{CALL, K, JMP}，参见`辅助函数`_
  CALL      0x8    0x1      调用PC += imm                       只有{CALL, K, JMP}，参见`程序本地函数`_
  CALL      0x8    0x2      通过BTF ID调用辅助函数              只有{CALL, K, JMP}，参见`辅助函数`_
  EXIT      0x9    0x0      返回                                 只有{CALL, K, JMP}
  JLT       0xa    任意     如果dst < src则PC += offset         无符号
  JLE       0xb    任意     如果dst <= src则PC += offset        无符号
  JSLT      0xc    任意     如果dst < src则PC += offset         有符号
  JSLE      0xd    任意     如果dst <= src则PC += offset        有符号
  ========  =====  =======  =================================  ===================================================

其中'PC'表示程序计数器，递增的偏移量以相对于跳转指令后指令的64位指令单位表示。因此，'PC += 1'如果下一个指令是基本指令则跳过其执行，或者如果下一个指令是128位宽指令则结果为未定义行为。
示例：

``{JSGE, X, JMP32}``意味着：

  如果(s32)dst s>= (s32)src则goto +offset

其中's>='表示有符号'>='比较
``{JLE, K, JMP}``意味着：

  如果dst <= (u64)(s64)imm则goto +offset

``{JA, K, JMP32}``意味着：

  goto +imm

其中'imm'表示分支偏移量来自'imm'字段
注意，有两种类型的``JA``指令。``JMP``类允许由'offset'字段指定的16位跳转偏移量，而``JMP32``类允许由'imm'字段指定的32位跳转偏移量。一个>16位的条件跳转可以转换为<16位的条件跳转加上32位无条件跳转
所有``CALL``和``JA``指令都属于base32一致性组。
辅助函数
~~~~~~~~~~

辅助函数是一个概念，BPF程序可以调用由底层平台暴露的一组函数调用。
历史上，每个辅助函数都通过在'imm'字段中编码的静态ID来识别。关于辅助函数的进一步文档说明超出了本文档的范围，并且标准化工作留待未来进行，但其使用已广泛部署，更多信息可以在特定平台的文档（例如，Linux内核文档）中找到。
支持BPF类型格式（BTF）的平台支持通过在'imm'字段中编码的BTF ID来识别辅助函数，其中BTF ID标识辅助函数的名称和类型。关于BTF的进一步文档说明同样超出了本文档的范围，标准化工作留待未来进行，但其使用已广泛部署，更多信息可以在特定平台的文档（例如，Linux内核文档）中找到。

程序本地函数
~~~~~~~~~~~~~~
程序本地函数是由调用者同一BPF程序公开的函数，通过从调用指令后跟随的指令的偏移量来引用，类似于``JA``。调用指令的'imm'字段中编码了该偏移量。在程序本地函数中的``EXIT``将返回到调用者。

加载和存储指令
=================

对于加载和存储指令（``LD``，``LDX``，``ST``和``STX``），8位'opcode'字段如下划分：

```
+---+---+---+---+---+---+---+---+
| m | o | d | e | s | z | c | l |
+---+---+---+---+---+---+---+---+
```

**mode**
模式修饰符之一为：

.. table:: 模式修饰符

```
+------------+-----+--------------------------------------+-----------------------+
| mode modifier | value | description                         | reference             |
+============+=====+======================================+=======================+
| IMM        | 0   | 64位立即数指令                      | `64位立即数指令`_       |
+------------+-----+--------------------------------------+-----------------------+
| ABS        | 1   | 传统BPF数据包访问（绝对）           | `传统BPF数据包访问指令`_ |
+------------+-----+--------------------------------------+-----------------------+
| IND        | 2   | 传统BPF数据包访问（间接）           | `传统BPF数据包访问指令`_ |
+------------+-----+--------------------------------------+-----------------------+
| MEM        | 3   | 常规的加载和存储操作                | `常规的加载和存储操作`_ |
+------------+-----+--------------------------------------+-----------------------+
| MEMSX      | 4   | 符号扩展加载操作                     | `符号扩展加载操作`_     |
+------------+-----+--------------------------------------+-----------------------+
| ATOMIC     | 6   | 原子操作                            | `原子操作`_            |
+------------+-----+--------------------------------------+-----------------------+
```

**sz（大小）**
大小修饰符之一为：

.. table:: 大小修饰符

```
+----+-----+---------------------+
| size | value | description        |
+====+=====+====================+
| W  | 0   | 字（4字节）        |
+----+-----+---------------------+
| H  | 1   | 半字（2字节）      |
+----+-----+---------------------+
| B  | 2   | 字节               |
+----+-----+---------------------+
| DW | 3   | 双字（8字节）      |
+----+-----+---------------------+
```

使用``DW``的指令属于base64一致性组。

**class**
指令类（参见`指令类`_）

常规的加载和存储操作
------------------------

``MEM``模式修饰符用于编码常规的加载和存储指令，在寄存器和内存之间传输数据。
``{MEM, <size>, STX}``意味着：

``*(size *) (dst + offset) = src``

``{MEM, <size>, ST}``意味着：

``*(size *) (dst + offset) = imm``

``{MEM, <size>, LDX}``意味着：

``dst = *(unsigned size *) (src + offset)``

其中'<size>'为：``B``、``H``、``W``或``DW``，而'unsigned size'为：u8、u16、u32或u64。

符号扩展加载操作
-------------------

``MEMSX``模式修饰符用于编码符号扩展（Sign Extend）加载指令，在寄存器和内存之间传输数据。
``{MEMSX, <size>, LDX}``意味着：

``dst = *(signed size *) (src + offset)``

其中'<size>'为：``B``、``H``或``W``，而'signed size'为：s8、s16或s32。

原子操作
---------

原子操作是在内存上执行的操作，不能被其他BPF程序或其他超出本规范的方法对同一内存区域的访问中断或破坏。
所有受BPF支持的原子操作都编码为使用``ATOMIC``模式修饰符的存储操作，具体如下：

* 对于32位操作，使用``{ATOMIC, W, STX}``，这属于"atomic32"一致性组的一部分。
* ``{ATOMIC, DW, STX}``用于64位操作，这些操作是"atomic64"一致性组的一部分。
* 不支持8位和16位宽的原子操作。
'imm'字段用于编码实际的原子操作。
简单的原子操作使用在'imm'字段中定义的值的子集来编码算术操作：

.. 表格:: 简单原子操作

  ========  =====  ===========
  imm       值      描述
  ========  =====  ===========
  ADD       0x00   原子加法
  OR        0x40   原子或运算
  AND       0x50   原子与运算
  XOR       0xa0   原子异或运算
  ========  =====  ==========

``{ATOMIC, W, STX}``加上'imm' = ADD意味着：

  *(u32 *)(dst + offset) += src

``{ATOMIC, DW, STX}``加上'imm' = ADD意味着：

  *(u64 *)(dst + offset) += src

除了简单的原子操作外，还有修饰符和两种复杂的原子操作：

.. 表格:: 复杂原子操作

  ===========  ================  ===========================
  imm          值                描述
  ===========  ================  ===========================
  FETCH        0x01              修饰符：返回旧值
  XCHG         0xe0 | FETCH      原子交换
  CMPXCHG      0xf0 | FETCH      原子比较并交换
  ===========  ================  ===========================

``FETCH``修饰符对于简单的原子操作是可选的，并且总是为复杂原子操作设置。如果设置了``FETCH``标志，则该操作还将用修改前存储器中的值覆盖``src``。
``XCHG``操作原子地将``src``与由``dst + offset``所指向的值交换。
``CMPXCHG``操作原子地比较由``dst + offset``所指向的值与``R0``。如果它们匹配，那么由``dst + offset``所指向的值被替换为``src``。无论情况如何，操作前位于``dst + offset``处的值会被零扩展并重新加载到``R0``。

64位立即数指令
--------------

带有``IMM``模式修饰符的指令使用在`指令编码`_中定义的宽指令编码，并使用基本指令的'src_reg'字段来保存一个操作码子类型。
下表定义了一系列具有'src_reg'字段中操作码子类型的``{IMM, DW, LD}``指令，使用了下面进一步定义的新术语，如"map"：

.. 表格:: 64位立即数指令

  =======  =========================================  ===========  ==============
  src_reg  伪代码                                     立即数类型     目标类型
  =======  =========================================  ===========  ==============
  0x0      dst = (next_imm << 32) | imm               整数           整数
  0x1      dst = map_by_fd(imm)                       地图文件描述符 地图
  0x2      dst = map_val(map_by_fd(imm)) + next_imm   地图文件描述符 数据地址
  0x3      dst = var_addr(imm)                        变量ID         数据地址
  0x4      dst = code_addr(imm)                       整数           代码地址
  0x5      dst = map_by_idx(imm)                      地图索引        地图
  0x6      dst = map_val(map_by_idx(imm)) + next_imm  地图索引        数据地址
  =======  =========================================  ===========  ==============

其中

* map_by_fd(imm)意味着将一个32位文件描述符转换为地图地址（参见`Maps`_）
* map_by_idx(imm)意味着将一个32位索引转换为地图地址
* map_val(map)获取给定地图中第一个值的地址
* var_addr(imm)获取具有特定ID的平台变量的地址（参见`平台变量`_）
* code_addr(imm)获取在指定相对偏移处的指令地址，偏移以64位指令的数量计算
* '立即数类型'可用于反汇编程序进行显示
* '目标类型'可用于验证和JIT编译目的

地图
~~~~

地图是在某些平台上可供BPF程序访问的共享内存区域。
地图可以有各种语义，这些语义在单独的文档中定义，地图可能或可能没有单一连续的内存区域，但目前'map_val(map)'仅对确实拥有单一连续内存区域的地图定义。
每个地图都可以有一个文件描述符（fd），如果平台支持的话，其中'map_by_fd(imm)'意味着获取具有指定文件描述符的地图。每个BPF程序也可以在加载时定义使用一组与程序关联的地图，而'map_by_idx(imm)'意味着获取在与包含指令的BPF程序相关联的集合中具有给定索引的地图。
平台变量
~~~~~~~~~~~~~

平台变量是由运行时暴露并可在某些平台上被BPF程序访问的、由整数ID标识的内存区域。`var_addr(imm)`操作意味着获取由给定ID标识的内存区域的地址。

遗留BPF数据包访问指令
-------------------------------------

BPF之前为了访问数据包数据而引入了特殊指令，这些指令是从经典BPF继承过来的。这些指令使用“LD”指令类，大小修饰符为“W”、“H”或“B”，以及模式修饰符为“ABS”或“IND”。'dst_reg'和'offset'字段设置为零，对于“ABS”，'src_reg'也设置为零。然而，这些指令已被弃用，不再建议使用。所有遗留的数据包访问指令都属于“packet”一致性组。

这段文本主要描述了在BPF（Berkeley Packet Filter）中，平台变量的概念和它们的用途，以及一些遗留的BPF数据包访问指令的介绍和弃用说明。
