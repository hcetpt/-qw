.. contents::
.. sectnum::

======================================
BPF 指令集架构 (ISA)
======================================

eBPF，也常被称为 BPF，是一项起源于 Linux 内核的技术，可以在受保护的环境中如操作系统内核中运行不可信程序。本文档指定了 BPF 指令集架构 (ISA)。
作为历史性的注释，BPF 最初代表伯克利包过滤器 (Berkeley Packet Filter)，但随着其功能远不止包过滤，这个缩写不再适用。现在 BPF 被认为是一个独立术语，不特指任何含义。原始的 BPF 有时被称作 cBPF（经典 BPF），以区别于现在广泛部署的 eBPF（扩展 BPF）。

文档约定
=========================

本文档中的关键词“MUST”，“MUST NOT”，“REQUIRED”，“SHALL”，“SHALL NOT”，“SHOULD”，“SHOULD NOT”，“RECOMMENDED”，“NOT RECOMMENDED”，“MAY”，以及 “OPTIONAL” 在全部大写时应按照 BCP 14 `<https://www.rfc-editor.org/info/rfc2119>`_ 和 `<https://www.rfc-editor.org/info/rfc8174>`_ 中描述的方式进行解释。
为了简洁和一致性，本文档使用了一种简写语法来引用类型家族，并在描述指令语义时提到了几个说明性的、助记符功能。
这些类型的有效值范围和这些函数的语义在以下小节中定义。

类型
-----
本文档使用 `SN` 的表示法来指定类型的有符号性 (`S`) 和位宽 (`N`)。
.. table:: 有符号性的含义

  ==== =========
  S    含义
  ==== =========
  u    无符号
  s    有符号
  ==== =========

.. table:: 位宽的含义

  ===== =========
  N     位宽
  ===== =========
  8     8 位
  16    16 位
  32    32 位
  64    64 位
  128   128 位
  ===== =========

例如，`u32` 是一个类型，其有效值为所有 32 位无符号数，而 `s16` 是一个类型，其有效值为所有 16 位有符号数。

函数
---------

以下是字节序转换函数，它们的方向无关。也就是说，同一个函数用于下面讨论的任意方向的转换。
* be16：接受一个无符号 16 位数字并将其在主机字节序与大端字节序 (`IEN137 <https://www.rfc-editor.org/ien/ien137.txt>`_) 之间转换。
* be32：接受一个无符号 32 位数字并将其在主机字节序与大端字节序之间转换。
* be64: 接受一个无符号的64位数字，并在主机字节序与大端字节序之间进行转换。
* bswap16: 接受一个以大端或小端格式表示的无符号16位数字，并返回具有相同位宽但字节序相反的等效数字。
* bswap32: 接受一个以大端或小端格式表示的无符号32位数字，并返回具有相同位宽但字节序相反的等效数字。
* bswap64: 接受一个以大端或小端格式表示的无符号64位数字，并返回具有相同位宽但字节序相反的等效数字。
* le16: 接受一个无符号的16位数字，并在主机字节序与小端字节序之间进行转换。
* le32: 接受一个无符号的32位数字，并在主机字节序与小端字节序之间进行转换。
* le64: 接受一个无符号的64位数字，并在主机字节序与小端字节序之间进行转换。

定义
----

.. glossary::

  符号扩展
    对一个``X``位数`A`进行`符号扩展`到一个``Y``位数`B`意味着：

    #. 将`A`中的所有``X``位复制到`B`的低位``X``位中；
    #. 设置`B`中剩余的``Y`` - ``X``位为`A`的最高有效位的值。

.. admonition:: 示例

  在大端平台上，将一个8位数``A``符号扩展到16位数``B``:
  ::

    A:          10000110
    B: 11111111 10000110

一致性组
---------

实现不必支持本文件中指定的所有指令（例如：已弃用的指令）。相反，定义了多个一致性组。实现必须支持base32一致性组，并且可以选择支持其他一致性组，其中支持一致性组意味着它必须支持该一致性组中的所有指令。
使用命名的兼容性组实现了执行指令的运行时与生成运行时指令的编译器等工具之间的互操作性。因此，根据兼容性组进行的能力发现可以由用户手动完成或由工具自动完成。每个兼容性组都有一个简短的ASCII标签（例如，“base32”），对应一组必须支持的指令。也就是说，每条指令都属于一个或多个兼容性组。

本文件定义了以下兼容性组：

* base32：包含本规范中定义的所有指令，除非另有说明
* base64：包含base32中的所有指令，再加上明确标注为属于base64兼容性组的指令
* atomic32：包含32位原子操作指令（参见“原子操作”）
* atomic64：包含atomic32中的所有指令，再加上64位原子操作指令
* divmul32：包含32位除法、乘法和取模指令
* divmul64：包含divmul32中的所有指令，再加上64位除法、乘法和取模指令
* packet：已弃用的包访问指令

指令编码
=========

BPF有两种指令编码方式：

* 基本指令编码，使用64位来编码一条指令
* 宽指令编码，在基本指令之后附加第二个64位，总共使用128位来编码指令
基本指令编码
--------------------------

一条基本指令的编码如下所示：

  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    opcode     |     regs      |            offset             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              imm                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

**opcode**
  要执行的操作，其编码方式如下：

    +-+-+-+-+-+-+-+-+
    |specific |class|
    +-+-+-+-+-+-+-+-+

  **specific**
    这些位的具体格式根据指令类别而变化。

  **class**
    指令类别（参见“指令类别”部分）

**regs**
  源寄存器和目标寄存器编号，其编码方式如下：
  
  在小端系统主机上：

    +-+-+-+-+-+-+-+-+
    |src_reg|dst_reg|
    +-+-+-+-+-+-+-+-+

  在大端系统主机上：

    +-+-+-+-+-+-+-+-+
    |dst_reg|src_reg|
    +-+-+-+-+-+-+-+-+

  **src_reg**
    源寄存器编号（0-10），除非另有说明
    （在“64位立即数指令”中，此字段被重用于其他目的）

  **dst_reg**
    目标寄存器编号（0-10），除非另有说明
    （未来的指令可能将此字段重用于其他目的）

**offset**
  与指针算术一起使用的有符号整数偏移量，除非另有说明
  （某些算术指令将此字段重用于其他目的）

**imm**
  有符号整数立即数值

需要注意的是，多字节字段（'offset' 和 'imm'）的内容存储时使用大端字节顺序（在大端系统主机上）和小端字节顺序（在小端系统主机上）。例如：

  opcode                  offset imm          assembly
         src_reg dst_reg
  07     0       1        00 00  44 33 22 11  r1 += 0x11223344 // 小端
         dst_reg src_reg
  07     1       0        00 00  11 22 33 44  r1 += 0x11223344 // 大端

需要注意的是大多数指令并不会使用所有的字段。
未使用的字段应当被清零。
宽指令编码
--------------------------

某些指令定义为使用宽指令编码，该编码包含两个32位的立即数值。紧随基本指令格式之后的64位包含一个伪指令，
其中 'opcode'、'dst_reg'、'src_reg' 和 'offset' 均设置为零。
这在下图中进行了描述：

  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    opcode     |     regs      |            offset             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              imm                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           reserved                            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           next_imm                            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

**opcode**
  要执行的操作，其编码方式如上所述

**regs**
  源寄存器和目标寄存器编号（除非另有规定），其编码方式如上所述

**offset**
  与指针算术一起使用的有符号整数偏移量，除非另有说明

**imm**
  有符号整数立即数值

**reserved**
  未使用，设置为零

**next_imm**
  第二个有符号整数立即数值

指令类别
-------------------

'opcode' 字段的最低三位存储指令类别：

.. table:: 指令类别

  =====  =====  ===============================  ===================================
  类别  值     描述                            参考
  =====  =====  ===============================  ===================================
  LD     0x0    非标准加载操作                   “加载和存储指令”部分
  LDX    0x1    加载到寄存器的操作              “加载和存储指令”部分
  ST     0x2    从立即数进行存储的操作          “加载和存储指令”部分
  STX    0x3    从寄存器进行存储的操作          “加载和存储指令”部分
  ALU    0x4    32位算术操作                    “算术和跳转指令”部分
  JMP    0x5    64位跳转操作                    “算术和跳转指令”部分
  JMP32  0x6    32位跳转操作                    “算术和跳转指令”部分
  ALU64  0x7    64位算术操作                    “算术和跳转指令”部分
  =====  =====  ===============================  ===================================

算术和跳转指令
================================

对于算术和跳转指令（``ALU``、``ALU64``、``JMP`` 和 ``JMP32``），8位的 'opcode' 字段被分为三个部分：

  +-+-+-+-+-+-+-+-+
  |  code |s|class|
  +-+-+-+-+-+-+-+-+

**code**
  操作码，其含义根据指令类别而变化

**s (source)**
  源操作数位置，默认情况下为以下之一：

  .. table:: 源操作数位置

    ======  =====  ==============================================
    源     值     描述
    ======  =====  ==============================================
    K       0      使用32位 'imm' 值作为源操作数
    X       1      使用 'src_reg' 寄存器值作为源操作数
    ======  =====  ==============================================

**instruction class**
  指令类别（参见“指令类别”部分）

算术指令
-----------------------

``ALU`` 使用32位宽的操作数，而 ``ALU64`` 使用64位宽的操作数来执行相同的运算。除非另有说明，``ALU64`` 指令属于 base64 符合性组。
'code' 字段编码了运算，其中 'src' 指代源操作数，而 'dst' 指代目标寄存器的值。
.. table:: 算术指令

  =====  =====  =======  ==========================================================
  名称   code   偏移量   描述
  =====  =====  =======  ==========================================================
  ADD    0x0    0        dst += src
  SUB    0x1    0        dst -= src
  MUL    0x2    0        dst *= src
  DIV    0x3    0        dst = (src != 0) ? (dst / src) : 0
  SDIV   0x3    1        dst = (src != 0) ? (dst s/ src) : 0
  OR     0x4    0        dst |= src
  AND    0x5    0        dst &= src
  LSH    0x6    0        dst <<= (src & mask)
  RSH    0x7    0        dst >>= (src & mask)
  NEG    0x8    0        dst = -dst
  MOD    0x9    0        dst = (src != 0) ? (dst % src) : dst
  SMOD   0x9    1        dst = (src != 0) ? (dst s% src) : dst
  XOR    0xa    0        dst ^= src
  MOV    0xb    0        dst = src
  MOVSX  0xb    8/16/32  dst = (s8,s16,s32)src
  ARSH   0xc    0        dst >>= (src & mask)，并进行符号扩展
  END    0xd    0        字节交换操作（参见下面的“字节交换指令”部分）
  =====  =====  =======  ==========================================================

算术运算过程中允许发生下溢和上溢，这意味着64位或32位的值将会循环回绕。如果BPF程序执行会导致除以零，则目标寄存器会被设置为零。
如果执行会导致对零取模，则对于 ``ALU64``，目标寄存器的值保持不变；而对于 ``ALU``，目标寄存器的高32位会被清零。
``{ADD, X, ALU}``，其中 'code' = ``ADD``，'source' = ``X``，且 'class' = ``ALU``，意味着：

  dst = (u32) ((u32) dst + (u32) src)

其中 '(u32)' 表示高32位被清零。
``{ADD, X, ALU64}`` 意味着：

  dst = dst + src

``{XOR, K, ALU}`` 意味着：

  dst = (u32) dst ^ (u32) imm

``{XOR, K, ALU64}`` 意味着：

  dst = dst ^ imm

需要注意的是，大多数算术指令的 'offset' 设置为0。只有三个指令（``SDIV``、``SMOD``、``MOVSX``）具有非零的 'offset'。
对于 ``ALU`` 的除法、乘法和取模操作是 "divmul32" 符合性组的一部分，而 ``ALU64`` 的除法、乘法和取模操作则是 "divmul64" 符合性组的一部分。
除法和取模操作均支持无符号和有符号两种类型。
对于无符号操作（``DIV`` 和 ``MOD``），在 ``ALU`` 中，'imm' 被解释为一个 32 位的无符号值。对于 ``ALU64``，'imm' 首先通过 :term:`符号扩展<Sign Extend>` 从 32 位扩展到 64 位，然后被解释为一个 64 位的无符号值。
对于有符号操作（``SDIV`` 和 ``SMOD``），在 ``ALU`` 中，'imm' 被解释为一个 32 位的有符号值。对于 ``ALU64``，'imm' 首先通过 :term:`符号扩展<Sign Extend>` 从 32 位扩展到 64 位，然后被解释为一个 64 位的有符号值。
需要注意的是，当被除数或除数为负时，有符号取模运算有不同的定义，不同语言中的实现可能有所不同，例如 Python、Ruby 等与 C、Go、Java 等不同。本规范要求有符号取模必须使用截断除法（其中 -13 % 3 == -1），这与 C、Go 等语言中的实现相同：

   a % n = a - n * trunc(a / n)

``MOVSX`` 指令执行带有符号扩展的移动操作。
``{MOVSX, X, ALU}`` 对 8 位和 16 位操作数进行 :term:`符号扩展<Sign Extend>` 到 32 位操作数，并将剩余的高 32 位清零。
``{MOVSX, X, ALU64}`` 对 8 位、16 位和 32 位操作数进行 :term:`符号扩展<Sign Extend>` 到 64 位操作数。与其它算术指令不同，``MOVSX`` 只对寄存器源操作数（``X``）定义。
``{MOV, K, ALU64}`` 表示如下：

  dst = (s64)imm

``{MOV, X, ALU}`` 表示如下：

  dst = (u32)src

``{MOVSX, X, ALU}`` 当 'offset' 为 8 时表示如下：

  dst = (u32)(s32)(s8)src

``NEG`` 指令仅在源位为 0（``K``）时定义。
移位操作对于 64 位操作使用 0x3F（63）的掩码，对于 32 位操作使用 0x1F（31）的掩码。
字节交换指令
----------------------

字节交换指令使用 ``ALU`` 和 ``ALU64`` 的指令类以及一个 4 位的 'code' 字段 ``END``。
字节交换指令仅作用于目标寄存器，而不使用单独的源寄存器或立即数。对于`ALU`类，操作码中的1位源操作数字段用于选择操作转换的字节顺序是从什么到什么。对于`ALU64`类，操作码中的1位源操作数字段是保留的，并且必须设置为0。
.. table:: 字节交换指令

  =====  ========  =====  =================================================
  class  source    value  description
  =====  ========  =====  =================================================
  ALU    LE        0      在主机字节序与小端序之间进行转换
  ALU    BE        1      在主机字节序与大端序之间进行转换
  ALU64  Reserved  0      无条件地执行字节交换
  =====  ========  =====  =================================================

'imm'字段编码了交换操作的宽度。支持以下宽度：16、32和64。宽度为64的操作属于base64一致性组，而其他交换操作属于base32一致性组。
示例：

``{END, LE, ALU}``与'imm' = 16/32/64意味着:

  dst = le16(dst)
  dst = le32(dst)
  dst = le64(dst)

``{END, BE, ALU}``与'imm' = 16/32/64意味着:

  dst = be16(dst)
  dst = be32(dst)
  dst = be64(dst)

``{END, TO, ALU64}``与'imm' = 16/32/64意味着:

  dst = bswap16(dst)
  dst = bswap32(dst)
  dst = bswap64(dst)

跳转指令
--------

`JMP32`使用32位宽的操作数并指示属于base32一致性组，而`JMP`使用64位宽的操作数来实现相同的功能，指示属于base64一致性组，除非另有说明。
'code'字段按如下方式编码操作：

.. table:: 跳转指令

  ========  =====  =======  =================================  ===================================================
  code      value  src_reg  description                        notes
  ========  =====  =======  =================================  ===================================================
  JA        0x0    0x0      PC += offset                       仅适用于{JA, K, JMP}
  JA        0x0    0x0      PC += imm                          仅适用于{JA, K, JMP32}
  JEQ       0x1    any      如果dst == src，则PC += offset
  JGT       0x2    any      如果dst > src（无符号）则PC += offset
  JGE       0x3    any      如果dst >= src（无符号）则PC += offset
  JSET      0x4    any      如果dst & src则PC += offset
  JNE       0x5    any      如果dst != src则PC += offset
  JSGT      0x6    any      如果dst > src（有符号）则PC += offset
  JSGE      0x7    any      如果dst >= src（有符号）则PC += offset
  CALL      0x8    0x0      通过静态ID调用辅助函数            仅适用于{CALL, K, JMP}，参见“辅助函数”
  CALL      0x8    0x1      通过PC += imm调用                  仅适用于{CALL, K, JMP}，参见“程序局部函数”
  CALL      0x8    0x2      通过BTF ID调用辅助函数             仅适用于{CALL, K, JMP}，参见“辅助函数”
  EXIT      0x9    0x0      返回                               仅适用于{CALL, K, JMP}
  JLT       0xa    any      如果dst < src（无符号）则PC += offset
  JLE       0xb    any      如果dst <= src（无符号）则PC += offset
  JSLT      0xc    any      如果dst < src（有符号）则PC += offset
  JSLE      0xd    any      如果dst <= src（有符号）则PC += offset
  ========  =====  =======  =================================  ===================================================

其中'PC'表示程序计数器，增量偏移量以相对于跳转指令之后的64位指令为单位。因此'PC += 1'将跳过下一个基本指令的执行，或者如果下一个指令是128位宽的指令，则结果行为未定义。
示例：

``{JSGE, X, JMP32}``意味着:

  如果(s32)dst s>= (s32)src则goto +offset

其中's>='表示有符号'>='比较
``{JLE, K, JMP}``意味着:

  如果dst <= (u64)(s64)imm则goto +offset

``{JA, K, JMP32}``意味着:

  goto +imm

其中'imm'意味着分支偏移量来自'imm'字段
请注意，有两种类型的`JA`指令。`JMP`类允许由'offset'字段指定的16位跳转偏移量，而`JMP32`类允许由'imm'字段指定的32位跳转偏移量。一个大于16位的条件跳转可以通过一个小于16位的条件跳转加上一个32位的无条件跳转来转换。
所有`CALL`和`JA`指令都属于base32一致性组。
辅助函数
~~~~~~~~~~

辅助函数是一种概念，即BPF程序可以调用由底层平台暴露的一组函数调用。
历史上，每个辅助函数都通过在 'imm' 字段中编码的静态ID来标识。辅助函数的进一步文档说明超出了本文档的范围，并且标准化工作留待将来进行，但其使用已广泛部署，更多信息可以在特定平台的文档（例如，Linux内核文档）中找到。
支持BPF类型格式（BTF）的平台支持通过在 'imm' 字段中编码的BTF ID来标识辅助函数，其中BTF ID标识辅助函数的名字和类型。关于BTF的更多文档说明同样超出了本文档的范围，并且标准化工作留待将来进行，但其使用已广泛部署，更多信息可以在特定平台的文档（例如，Linux内核文档）中找到。

程序局部函数
~~~~~~~~~~~~~~
程序局部函数是由调用者所在同一BPF程序公开的函数，并通过从调用指令后的一个指令计算出的偏移量来引用，类似于 ``JA``。该偏移量被编码在调用指令的 'imm' 字段中。如果一个程序局部函数内部有 ``EXIT`` 指令，则会返回到调用者。

加载与存储指令
=================

对于加载和存储指令（``LD``, ``LDX``, ``ST``, 和 ``STX``），8位的 'opcode' 字段被划分如下：

```
  +-+-+-+-+-+-+-+-+
  |mode |sz |class|
  +-+-+-+-+-+-+-+-+
```

**mode**
  模式修饰符可以是：

  .. table:: 模式修饰符

    =============  =====  ====================================  =============
    模式修饰符     值     描述                               参考
    =============  =====  ====================================  =============
    IMM            0      64位立即数指令                       `64位立即数指令`_
    ABS            1      传统BPF包访问（绝对）               `传统BPF包访问指令`_
    IND            2      传统BPF包访问（间接）               `传统BPF包访问指令`_
    MEM            3      标准加载和存储操作                  `标准加载和存储操作`_
    MEMSX          4      符号扩展加载操作                     `符号扩展加载操作`_
    ATOMIC         6      原子操作                             `原子操作`_
    =============  =====  ====================================  =============

**sz (大小)**
  大小修饰符可以是：

  .. table:: 大小修饰符

    ====  =====  =====================
    大小  值     描述
    ====  =====  =====================
    W     0      字 (4字节)
    H     1      半字 (2字节)
    B     2      字节
    DW    3      双字 (8字节)
    ====  =====  =====================

  使用 ``DW`` 的指令属于base64一致性组。
**class**
  指令类别（参见 `指令类别`_）

标准加载和存储操作
-------------------

``MEM`` 模式修饰符用于编码标准的加载和存储指令，这些指令在寄存器和内存之间传输数据：
``{MEM, <size>, STX}`` 表示：

  *(<size> *) (dst + offset) = src

``{MEM, <size>, ST}`` 表示：

  *(<size> *) (dst + offset) = imm

``{MEM, <size>, LDX}`` 表示：

  dst = *(无符号<size> *) (src + offset)

其中 '<size>' 可以是：``B``, ``H``, ``W``, 或 ``DW``，而 '无符号<size>' 可以是：u8, u16, u32, 或 u64。

符号扩展加载操作
------------------

``MEMSX`` 模式修饰符用于编码符号扩展加载指令，这些指令在寄存器和内存之间传输数据：
``{MEMSX, <size>, LDX}`` 表示：

  dst = *(有符号<size> *) (src + offset)

其中 '<size>' 可以是：``B``, ``H``, 或 ``W``，而 '有符号<size>' 可以是：s8, s16, 或 s32。

原子操作
---------

原子操作是在内存上执行的操作，不能被其他BPF程序或其他超出本规范的方法对同一内存区域的访问中断或破坏。
所有受BPF支持的原子操作都被编码为使用 ``ATOMIC`` 模式修饰符的存储操作，具体如下：

* 对于32位操作，使用 ``{ATOMIC, W, STX}``，这是“atomic32”一致性组的一部分。
* ``{ATOMIC, DW, STX}`` 表示 64 位操作，这些操作是 "atomic64" 符合性组的一部分。
* 不支持 8 位和 16 位的原子操作。
`imm` 字段用于编码实际的原子操作。
简单的原子操作使用在 `imm` 字段中定义的、用于编码算术操作的值的一个子集来编码原子操作：

.. table:: 简单原子操作

  ========  =====  ===========
  imm       value  描述
  ========  =====  ===========
  ADD       0x00   原子加
  OR        0x40   原子或
  AND       0x50   原子与
  XOR       0xa0   原子异或
  ========  =====  ===========

``{ATOMIC, W, STX}`` 且 `imm` = ADD 表示:

  *(u32 *)(dst + offset) += src

``{ATOMIC, DW, STX}`` 且 `imm` = ADD 表示:

  *(u64 *)(dst + offset) += src

除了简单的原子操作之外，还有一种修饰符和两种复杂的原子操作:

.. table:: 复杂原子操作

  ===========  ================  ===========================
  imm          value             描述
  ===========  ================  ===========================
  FETCH        0x01              修饰符：返回旧值
  XCHG         0xe0 | FETCH      原子交换
  CMPXCHG      0xf0 | FETCH      原子比较并交换
  ===========  ================  ===========================

`FETCH` 修饰符对于简单原子操作是可选的，并且总是为复杂的原子操作设置。如果设置了 `FETCH` 标志，则操作还会将 `src` 覆盖为修改前内存中的值。
`XCHG` 操作原子地将 `src` 与 `dst + offset` 所指向的值进行交换。
`CMPXCHG` 操作原子地比较 `dst + offset` 所指向的值与 `R0`。如果它们匹配，则 `dst + offset` 所指向的值被替换为 `src`。无论结果如何，`dst + offset` 修改前的值都会零扩展并加载回 `R0`。

64 位立即数指令
-------------------

带有 `IMM` '模式' 修饰符的指令使用在 `指令编码`_ 中定义的宽指令编码，并使用基本指令的 'src_reg' 字段来保存一个操作码子类型。
下表定义了一系列 `{IMM, DW, LD}` 指令，其操作码子类型位于 'src_reg' 字段中，并使用下面进一步定义的新术语如 "map":

.. table:: 64 位立即数指令

  =======  =========================================  ===========  ==============
  src_reg  伪代码                                     imm 类型     目标类型
  =======  =========================================  ===========  ==============
  0x0      dst = (next_imm << 32) | imm               整数          整数
  0x1      dst = map_by_fd(imm)                       地图文件描述符  地图
  0x2      dst = map_val(map_by_fd(imm)) + next_imm   地图文件描述符  数据地址
  0x3      dst = var_addr(imm)                        变量标识符    数据地址
  0x4      dst = code_addr(imm)                       整数          代码地址
  0x5      dst = map_by_idx(imm)                      地图索引       地图
  0x6      dst = map_val(map_by_idx(imm)) + next_imm  地图索引       数据地址
  =======  =========================================  ===========  ==============

其中

* `map_by_fd(imm)` 意味着将一个 32 位文件描述符转换为地图地址（参见 `Maps`_）
* `map_by_idx(imm)` 意味着将一个 32 位索引转换为地图地址
* `map_val(map)` 获取给定地图的第一个值的地址
* `var_addr(imm)` 获取具有指定 ID 的平台变量的地址（参见 `平台变量`_）
* `code_addr(imm)` 获取相对于当前指令位置的指定偏移处的指令地址
* `'imm 类型'` 可以由反汇编器用于显示
* `'目标类型'` 可用于验证和 JIT 编译的目的

地图
~~~~

地图是在某些平台上可供 BPF 程序访问的共享内存区域。
地图可以有不同的语义，这些语义在另一个文档中定义，并且可能或可能没有单一连续的内存区域，但目前 `map_val(map)` 只对有单一连续内存区域的地图定义。
每个地图都可以有一个文件描述符（fd），如果平台支持的话，其中 `map_by_fd(imm)` 意味着获取具有指定文件描述符的地图。每个 BPF 程序也可以定义为在加载时使用一组与程序关联的地图，而 `map_by_idx(imm)` 意味着获取该指令所在 BPF 程序中与之关联的地图集中的指定索引的地图。
### 平台变量

平台变量是由整数ID标识的内存区域，这些内存区域由运行时暴露，并在某些平台上可供BPF程序访问。`var_addr(imm)`操作意味着获取由给定ID标识的内存区域的地址。

### 遗留BPF数据包访问指令

BPF之前引入了用于访问数据包数据的特殊指令，这些指令是从经典BPF继承过来的。这些指令使用“LD”指令类别、“W”、“H”或“B”的大小修饰符以及“ABS”或“IND”的模式修饰符。`dst_reg`和`offset`字段设置为0，对于“ABS”，`src_reg`也设置为0。然而，这些指令已被弃用，**不建议再使用**。所有遗留的数据包访问指令都属于“packet”一致性组。
