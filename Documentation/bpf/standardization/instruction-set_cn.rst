.. contents::
.. sectnum::

======================================
BPF 指令集架构 (ISA)
======================================

eBPF，也通常被称为 BPF，是一项起源于 Linux 内核的技术，可以在受保护的环境中（例如操作系统内核）运行不受信任的程序。本文档指定了 BPF 指令集架构 (ISA)。
作为历史注解，BPF 最初代表的是 Berkeley Packet Filter，但现在它能做的远不止包过滤，该缩写已经不再适用。现在 BPF 被认为是一个独立的术语，并不代表任何特定含义。原始的 BPF 有时被称为 cBPF（经典 BPF），以区别于现在广泛部署的 eBPF（扩展 BPF）。

文档约定
=========================

本文件中的关键词 "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"NOT RECOMMENDED"、"MAY" 和 "OPTIONAL" 在出现时应按照 BCP 14 `<https://www.rfc-editor.org/info/rfc2119>`_ `<https://www.rfc-editor.org/info/rfc8174>`_ 中描述的方式进行解释，仅当它们全部大写时才如此使用。
为了简洁和一致性，本文档在描述指令语义时采用简短的语法来引用类型家族，并使用几种说明性的助记函数。
这些类型的合法值范围以及这些函数的语义在以下子章节中定义。

类型
-----
本文档用 `SN` 格式的表示法来指代整数类型，其中 `S` 表示有符号性，`N` 表示位宽。

.. table:: 有符号性的含义

  ==== =========
  S    含义
  ==== =========
  u    无符号
  s    有符号
  ==== =========

.. table:: 位宽的含义

  ===== =========
  N     位宽
  ===== =========
  8     8 位
  16    16 位
  32    32 位
  64    64 位
  128   128 位
  ===== =========

例如，`u32` 是一个类型，其有效值为所有 32 位无符号数字，而 `s16` 是一个类型，其有效值为所有 16 位有符号数字。

函数
--------

以下字节交换函数是方向无关的，即同一函数用于下面讨论的两个方向的转换：
* be16：接受一个无符号 16 位数字并将其在主机字节序和大端字节序 (`IEN137 <https://www.rfc-editor.org/ien/ien137.txt>`_) 之间转换
* be32：接受一个无符号 32 位数字并将其在主机字节序和大端字节序之间转换
* be64: 接受一个无符号的64位数字，并在主机字节序与大端字节序之间进行转换。
* bswap16: 接受一个以大端或小端格式表示的无符号16位数字，并返回具有相同位宽但字节序相反的等效数字。
* bswap32: 接受一个以大端或小端格式表示的无符号32位数字，并返回具有相同位宽但字节序相反的等效数字。
* bswap64: 接受一个以大端或小端格式表示的无符号64位数字，并返回具有相同位宽但字节序相反的等效数字。
* le16: 接受一个无符号的16位数字，并在主机字节序与小端字节序之间进行转换。
* le32: 接受一个无符号的32位数字，并在主机字节序与小端字节序之间进行转换。
* le64: 接受一个无符号的64位数字，并在主机字节序与小端字节序之间进行转换。

定义
----

.. glossary::

  符号扩展
    对一个``X``位数`A`进行`符号扩展`到一个``Y``位数`B`意味着：

    #. 将`A`中的所有``X``位复制到`B`的低位``X``位中；
    #. 设置`B`中剩余的``Y`` - ``X``位为`A`的最高有效位的值。

.. admonition:: 示例

  在大端平台上，将一个8位数``A``符号扩展到16位数``B``:
  ::

    A:          10000110
    B: 11111111 10000110

一致性组
---------

实现不必支持本文件中指定的所有指令（例如：已弃用的指令）。相反，定义了多个一致性组。实现必须支持base32一致性组，并且可以选择支持其他一致性组，其中支持一致性组意味着它必须支持该一致性组中的所有指令。
使用命名的兼容性组实现了执行指令的运行时与生成运行时指令的编译器等工具之间的互操作性。因此，根据兼容性组进行的能力发现可以由用户手动完成或由工具自动完成。每个兼容性组都有一个简短的ASCII标签（例如，“base32”），对应一组必须支持的指令。也就是说，每条指令都属于一个或多个兼容性组。

本文件定义了以下兼容性组：

* base32：包含本规范中定义的所有指令，除非另有说明
* base64：包含base32中的所有指令，再加上明确标注为属于base64兼容性组的指令
* atomic32：包含32位原子操作指令（参见“原子操作”）
* atomic64：包含atomic32中的所有指令，再加上64位原子操作指令
* divmul32：包含32位除法、乘法和取模指令
* divmul64：包含divmul32中的所有指令，再加上64位除法、乘法和取模指令
* packet：已弃用的包访问指令

指令编码
=========

BPF有两种指令编码方式：

* 基本指令编码，使用64位来编码一条指令
* 宽指令编码，在基本指令之后附加第二个64位，总共使用128位来编码指令
基本指令编码
--------------------------

一条基本指令的编码如下所示：

  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    opcode     |     regs      |            offset             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              imm                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

**opcode**
  要执行的操作，其编码方式如下：

    +-+-+-+-+-+-+-+-+
    |specific |class|
    +-+-+-+-+-+-+-+-+

  **specific**
    这些位的具体格式根据指令类别而变化。

  **class**
    指令类别（参见“指令类别”部分）

**regs**
  源寄存器和目标寄存器编号，其编码方式如下：
  
  在小端系统主机上：

    +-+-+-+-+-+-+-+-+
    |src_reg|dst_reg|
    +-+-+-+-+-+-+-+-+

  在大端系统主机上：

    +-+-+-+-+-+-+-+-+
    |dst_reg|src_reg|
    +-+-+-+-+-+-+-+-+

  **src_reg**
    源寄存器编号（0-10），除非另有说明
    （在“64位立即数指令”中，此字段被重用于其他目的）

  **dst_reg**
    目标寄存器编号（0-10），除非另有说明
    （未来的指令可能将此字段重用于其他目的）

**offset**
  与指针算术一起使用的有符号整数偏移量，除非另有说明
  （某些算术指令将此字段重用于其他目的）

**imm**
  有符号整数立即数值

需要注意的是，多字节字段（'offset' 和 'imm'）的内容存储时使用大端字节顺序（在大端系统主机上）和小端字节顺序（在小端系统主机上）。例如：

  opcode                  offset imm          assembly
         src_reg dst_reg
  07     0       1        00 00  44 33 22 11  r1 += 0x11223344 // 小端
         dst_reg src_reg
  07     1       0        00 00  11 22 33 44  r1 += 0x11223344 // 大端

需要注意的是大多数指令并不会使用所有的字段。
未使用的字段应当被清零。
宽指令编码
--------------------------

某些指令定义为使用宽指令编码，该编码包含两个32位的立即数值。紧随基本指令格式之后的64位包含一个伪指令，
其中'opcode'、'dst_reg'、'src_reg'以及'offset'均设置为0。如下面的图示所示：

  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |    opcode     |     regs      |            offset             |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                              imm                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           reserved                            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                           next_imm                            |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

**opcode**
  要执行的操作，其编码方式如上所述

**regs**
  源寄存器和目标寄存器编号（除非另有说明），其编码方式如上所述

**offset**
  与指针算术一起使用的有符号整数偏移量，除非另有说明

**imm**
  有符号整数立即数值

**reserved**
  未使用，设置为0

**next_imm**
  第二个有符号整数立即数值

指令类别
-------------------

'opcode'字段中的最低三位存储了指令类别：

.. table:: 指令类别

  =====  =====  ===============================  ===================================
  类别  值    描述                             参考
  =====  =====  ===============================  ===================================
  LD     0x0   非标准的加载操作                “加载和存储指令”部分
  LDX    0x1   加载到寄存器的操作              “加载和存储指令”部分
  ST     0x2   从立即数进行存储的操作          “加载和存储指令”部分
  STX    0x3   从寄存器进行存储的操作          “加载和存储指令”部分
  ALU    0x4   32位算术运算                     “算术和跳转指令”部分
  JMP    0x5   64位跳转运算                     “算术和跳转指令”部分
  JMP32  0x6   32位跳转运算                     “算术和跳转指令”部分
  ALU64  0x7   64位算术运算                     “算术和跳转指令”部分
  =====  =====  ===============================  ===================================

算术和跳转指令
================================

对于算术和跳转指令（``ALU``、``ALU64``、``JMP`` 和 ``JMP32``），8位的'opcode'字段被分为三部分：

  +-+-+-+-+-+-+-+-+
  |  code |s|class|
  +-+-+-+-+-+-+-+-+

**code**
  操作码，其含义根据指令类别而变化

**s (source)**
  源操作数的位置，除非另有说明，是以下之一：

  .. table:: 源操作数位置

    ======  =====  ==============================================
    源     值    描述
    ======  =====  ==============================================
    K       0     使用32位的'imm'值作为源操作数
    X       1     使用'src_reg'寄存器的值作为源操作数
    ======  =====  ==============================================

**instruction class**
  指令类别（参见“指令类别”部分）

算术指令
-----------------------

``ALU``使用32位宽的操作数，而``ALU64``使用64位宽的操作数来进行相同的运算。除非另有说明，``ALU64``指令属于base64一致性组。
'code'字段编码的操作如下所示，其中'src'指的是源操作数，'dst'指的是目标寄存器的值。
.. table:: 算术指令

  =====  =====  =======  ==========================================================
  名称   code   偏移     描述
  =====  =====  =======  ==========================================================
  ADD    0x0    0        dst += src
  SUB    0x1    0        dst -= src
  MUL    0x2    0        dst *= src
  DIV    0x3    0        dst = (src != 0) ? (dst / src) : 0
  SDIV   0x3    1        dst = (src != 0) ? (dst s/ src) : 0
  OR     0x4    0        dst |= src
  AND    0x5    0        dst &= src
  LSH    0x6    0        dst <<= (src & mask)
  RSH    0x7    0        dst >>= (src & mask)
  NEG    0x8    0        dst = -dst
  MOD    0x9    0        dst = (src != 0) ? (dst % src) : dst
  SMOD   0x9    1        dst = (src != 0) ? (dst s% src) : dst
  XOR    0xa    0        dst ^= src
  MOV    0xb    0        dst = src
  MOVSX  0xb    8/16/32  dst = (s8,s16,s32)src
  ARSH   0xc    0        dst >>= (src & mask)，术语：符号扩展
  END    0xd    0        字节交换操作（参见下文的“字节交换指令”部分）
  =====  =====  =======  ==========================================================

算术运算允许发生下溢和上溢，意味着64位或32位的值会发生循环。如果BPF程序执行会导致除以零，则目标寄存器设置为零。
如果执行会导致对零取模，在``ALU64``情况下，目标寄存器的值保持不变；而在``ALU``情况下，目标寄存器的高32位会被清零。
``{ADD, X, ALU}``，其中'code' = ``ADD``，'source' = ``X``，'class' = ``ALU``，意味着：

  dst = (u32) ((u32) dst + (u32) src)

其中'(u32)'表示高32位被清零。
``{ADD, X, ALU64}``意味着：

  dst = dst + src

``{XOR, K, ALU}``意味着：

  dst = (u32) dst ^ (u32) imm

``{XOR, K, ALU64}``意味着：

  dst = dst ^ imm

需要注意的是大多数算术指令的'offset'设置为0。只有三个指令（``SDIV``、``SMOD``、``MOVSX``）具有非零的'offset'。
对于 ``ALU`` 的除法、乘法和取模操作是 "divmul32" 符合性组的一部分，而 ``ALU64`` 的除法、乘法和取模操作则是 "divmul64" 符合性组的一部分。
除法和取模操作均支持无符号和有符号两种类型。
对于无符号操作（``DIV`` 和 ``MOD``），在 ``ALU`` 中，'imm' 被解释为一个 32 位的无符号值。对于 ``ALU64``，'imm' 首先通过 :term:`符号扩展<Sign Extend>` 从 32 位扩展到 64 位，然后被解释为一个 64 位的无符号值。
对于有符号操作（``SDIV`` 和 ``SMOD``），在 ``ALU`` 中，'imm' 被解释为一个 32 位的有符号值。对于 ``ALU64``，'imm' 首先通过 :term:`符号扩展<Sign Extend>` 从 32 位扩展到 64 位，然后被解释为一个 64 位的有符号值。
需要注意的是，当被除数或除数为负时，有符号取模运算有不同的定义，不同语言中的实现可能有所不同，例如 Python、Ruby 等与 C、Go、Java 等不同。本规范要求有符号取模必须使用截断除法（其中 -13 % 3 == -1），这与 C、Go 等语言中的实现相同：

   a % n = a - n * trunc(a / n)

``MOVSX`` 指令执行带符号扩展的移动操作。
``{MOVSX, X, ALU}`` 对 8 位和 16 位操作数进行 :term:`符号扩展<Sign Extend>` 到 32 位操作数，并将剩余的高 32 位置零。
``{MOVSX, X, ALU64}`` 对 8 位、16 位和 32 位操作数进行 :term:`符号扩展<Sign Extend>` 到 64 位操作数。与其它算术指令不同，``MOVSX`` 只对寄存器源操作数（``X``）定义。
``{MOV, K, ALU64}`` 表示：

  dst = (s64)imm

``{MOV, X, ALU}`` 表示：

  dst = (u32)src

``{MOVSX, X, ALU}`` 当 'offset' 为 8 时表示：

  dst = (u32)(s32)(s8)src

``NEG`` 指令仅在源位清除（``K``）的情况下定义。
移位操作使用 64 位操作的 0x3F (63) 遮罩和 32 位操作的 0x1F (31) 遮罩。
字节交换指令
----------------------

字节交换指令使用 ``ALU`` 和 ``ALU64`` 的指令类以及 4 位的 'code' 字段 ``END``。
字节交换指令仅对目标寄存器操作，不使用单独的源寄存器或立即数。对于`ALU`，操作码中的1位源操作数字段用于选择操作转换的字节顺序是从什么到什么。对于`ALU64`，操作码中的1位源操作数字段是保留的，并且必须设置为0。
.. table:: 字节交换指令

  =====  ========  =====  =================================================
  类别  源类型    值      描述
  =====  ========  =====  =================================================
  ALU    小端序   0      在主机字节序与小端序之间转换
  ALU    大端序   1      在主机字节序与大端序之间转换
  ALU64  保留     0      无条件进行字节交换
  =====  ========  =====  =================================================

'imm'字段编码了交换操作的宽度。支持以下宽度：16、32和64。宽度为64的操作属于base64一致性组，其他交换操作属于base32一致性组。
示例：

``{END, LE, ALU}`` 与 'imm' = 16/32/64 表示如下：

  dst = le16(dst)
  dst = le32(dst)
  dst = le64(dst)

``{END, BE, ALU}`` 与 'imm' = 16/32/64 表示如下：

  dst = be16(dst)
  dst = be32(dst)
  dst = be64(dst)

``{END, TO, ALU64}`` 与 'imm' = 16/32/64 表示如下：

  dst = bswap16(dst)
  dst = bswap32(dst)
  dst = bswap64(dst)

跳转指令
--------

`JMP32`使用32位宽的操作数并指示base32一致性组，而`JMP`使用64位宽的操作数进行相同的操作，除非另有说明，否则指示base64一致性组。
'code'字段编码了如下的操作：

.. table:: 跳转指令

  ========  =====  =======  =================================  ===================================================
  代码      值      源寄存器  描述                                注释
  ========  =====  =======  =================================  ===================================================
  JA        0x0    0x0      PC += 偏移量                        仅{JA, K, JMP}
  JA        0x0    0x0      PC += imm                           仅{JA, K, JMP32}
  JEQ       0x1    任意     如果dst == src则PC += 偏移量
  JGT       0x2    任意     如果dst > src则PC += 偏移量        无符号
  JGE       0x3    任意     如果dst >= src则PC += 偏移量       无符号
  JSET      0x4    任意     如果dst & src则PC += 偏移量
  JNE       0x5    任意     如果dst != src则PC += 偏移量
  JSGT      0x6    任意     如果dst > src则PC += 偏移量        有符号
  JSGE      0x7    任意     如果dst >= src则PC += 偏移量       有符号
  CALL      0x8    0x0      通过静态ID调用辅助函数            仅{CALL, K, JMP}, 见“辅助函数”
  CALL      0x8    0x1      通过PC += imm调用                  仅{CALL, K, JMP}, 见“程序局部函数”
  CALL      0x8    0x2      通过BTF ID调用辅助函数             仅{CALL, K, JMP}, 见“辅助函数”
  EXIT      0x9    0x0      返回                                 仅{CALL, K, JMP}
  JLT       0xa    任意     如果dst < src则PC += 偏移量        无符号
  JLE       0xb    任意     如果dst <= src则PC += 偏移量       无符号
  JSLT      0xc    任意     如果dst < src则PC += 偏移量        有符号
  JSLE      0xd    任意     如果dst <= src则PC += 偏移量       有符号
  ========  =====  =======  =================================  ===================================================

其中'PC'表示程序计数器，要增加的偏移量以相对于跳转指令之后的64位指令为单位。因此'PC += 1'如果下一条指令是基本指令，则跳过它的执行；如果下一条指令是128位宽的指令，则结果是未定义的行为。
示例：

``{JSGE, X, JMP32}`` 意味着：

  如果(s32)dst >= (s32)src则跳转到+偏移量

其中's>='表示带符号的'>='比较
``{JLE, K, JMP}`` 意味着：

  如果dst <= (u64)(s64)imm则跳转到+偏移量

``{JA, K, JMP32}`` 意味着：

  跳转到+imm

其中'imm'意味着分支偏移量来自'imm'字段
请注意，有两种类型的`JA`指令。`JMP`类允许由'offset'字段指定的16位跳转偏移量，而`JMP32`类允许由'imm'字段指定的32位跳转偏移量。一个大于16位的条件跳转可以转换为一个小于16位的条件跳转加上一个32位的无条件跳转
所有`CALL`和`JA`指令都属于base32一致性组
辅助函数
~~~~~~~~~

辅助函数是一种概念，BPF程序可以通过它调用由底层平台暴露的一组函数调用。
历史上，每个辅助函数都通过在 'imm' 字段中编码的静态ID来标识。辅助函数的进一步文档说明超出了本文档的范围，并且标准化工作留待将来进行，但其使用已广泛部署，更多信息可以在特定平台的文档（例如，Linux内核文档）中找到。
支持BPF类型格式（BTF）的平台支持通过在 'imm' 字段中编码的BTF ID来标识辅助函数，其中BTF ID标识辅助函数的名称和类型。关于BTF的进一步文档说明同样超出了本文档的范围，并且标准化工作留待将来进行，但其使用已广泛部署，更多信息可以在特定平台的文档（例如，Linux内核文档）中找到。

程序本地函数
~~~~~~~~~~~~~~
程序本地函数是由调用者相同的BPF程序公开的函数，并通过从调用指令后跟随的指令计算出的偏移量来进行引用，类似于 ``JA``。该偏移量被编码在调用指令的 'imm' 字段中。如果程序本地函数内部有 ``EXIT`` 指令，则会返回到调用者。

加载与存储指令
=================

对于加载和存储指令（``LD``, ``LDX``, ``ST``, 和 ``STX``），8位的 'opcode' 字段被划分如下：

```
  +-+-+-+-+-+-+-+-+
  |mode |sz |class|
  +-+-+-+-+-+-+-+-+
```

**mode**
  模式修饰符可以是：

  .. table:: 模式修饰符

    =============  =====  ====================================  =============
    模式修饰符     值     描述                               参考
    =============  =====  ====================================  =============
    IMM            0      64位立即数指令                       `64位立即数指令`_
    ABS            1      传统BPF包访问（绝对）               `传统BPF包访问指令`_
    IND            2      传统BPF包访问（间接）               `传统BPF包访问指令`_
    MEM            3      标准加载和存储操作                  `标准加载和存储操作`_
    MEMSX          4      符号扩展加载操作                     `符号扩展加载操作`_
    ATOMIC         6      原子操作                             `原子操作`_
    =============  =====  ====================================  =============

**sz (大小)**
  大小修饰符可以是：

  .. table:: 大小修饰符

    ====  =====  =====================
    大小  值     描述
    ====  =====  =====================
    W     0      字 (4字节)
    H     1      半字 (2字节)
    B     2      字节
    DW    3      双字 (8字节)
    ====  =====  =====================

  使用 ``DW`` 的指令属于base64一致性组。
**class**
  指令类别（参见 `指令类别`_）

标准加载和存储操作
-------------------

``MEM`` 模式修饰符用于编码标准的加载和存储指令，这些指令在寄存器和内存之间传输数据：
``{MEM, <size>, STX}`` 表示：

  *(<size> *) (dst + offset) = src

``{MEM, <size>, ST}`` 表示：

  *(<size> *) (dst + offset) = imm

``{MEM, <size>, LDX}`` 表示：

  dst = *(无符号<size> *) (src + offset)

其中 '<size>' 可以是：``B``, ``H``, ``W``, 或 ``DW``，而 '无符号<size>' 可以是：u8, u16, u32, 或 u64。

符号扩展加载操作
------------------

``MEMSX`` 模式修饰符用于编码符号扩展加载指令，这些指令在寄存器和内存之间传输数据：
``{MEMSX, <size>, LDX}`` 表示：

  dst = *(有符号<size> *) (src + offset)

其中 '<size>' 可以是：``B``, ``H``, 或 ``W``，而 '有符号<size>' 可以是：s8, s16, 或 s32。

原子操作
---------

原子操作是在内存上执行的操作，不能被其他BPF程序或其他本规范之外的方式中断或破坏对同一内存区域的访问。
所有受BPF支持的原子操作都被编码为使用 ``ATOMIC`` 模式修饰符的存储操作，具体如下：

* 对于32位操作，使用 ``{ATOMIC, W, STX}``，这是 "atomic32" 一致性组的一部分。
* ``{ATOMIC, DW, STX}`` 表示 64 位操作，这些操作是 "atomic64" 符合性组的一部分。
* 不支持 8 位和 16 位的原子操作。
`imm` 字段用于编码实际的原子操作。
简单的原子操作使用在 `imm` 字段中定义的、用于编码算术操作的值的一个子集来编码原子操作：

.. table:: 简单原子操作

  ========  =====  ===========
  imm       value  描述
  ========  =====  ===========
  ADD       0x00   原子加
  OR        0x40   原子或
  AND       0x50   原子与
  XOR       0xa0   原子异或
  ========  =====  ===========

``{ATOMIC, W, STX}`` 且 `imm` = ADD 意味着：

  *(u32 *)(dst + offset) += src

``{ATOMIC, DW, STX}`` 且 `imm` = ADD 意味着：

  *(u64 *)(dst + offset) += src

除了简单的原子操作之外，还有一些修饰符和两个复杂的原子操作：

.. table:: 复杂原子操作

  ===========  ================  ===========================
  imm          value             描述
  ===========  ================  ===========================
  FETCH        0x01              修饰符：返回旧值
  XCHG         0xe0 | FETCH      原子交换
  CMPXCHG      0xf0 | FETCH      原子比较并交换
  ===========  ================  ===========================

`FETCH` 修饰符对于简单的原子操作来说是可选的，并且总是为复杂的原子操作设置。如果设置了 `FETCH` 标志，则操作还会将修改前内存中的值覆盖到 `src` 中。
`XCHG` 操作原子地将 `src` 与由 `dst + offset` 指定的值进行交换。
`CMPXCHG` 操作原子地比较由 `dst + offset` 指定的值与 `R0`。如果它们相等，则将由 `dst + offset` 指定的值替换为 `src`。无论结果如何，`dst + offset` 在操作前的值都会被零扩展，并加载回 `R0`。

64 位立即数指令
-------------------

带有 `IMM` 'mode' 修饰符的指令使用在 `指令编码`_ 中定义的宽指令编码，并使用基本指令的 `src_reg` 字段来保存一个操作码子类型。
下表定义了一组带有 `src_reg` 字段中的操作码子类型的 ``{IMM, DW, LD}`` 指令，其中使用了如“map”等新术语，这些术语在下面进一步定义：

.. table:: 64 位立即数指令

  =======  =========================================  ===========  ==============
  src_reg  伪代码                                     imm 类型     目标类型
  =======  =========================================  ===========  ==============
  0x0      dst = (next_imm << 32) | imm               整数         整数
  0x1      dst = map_by_fd(imm)                       map 文件描述符  map
  0x2      dst = map_val(map_by_fd(imm)) + next_imm   map 文件描述符  数据地址
  0x3      dst = var_addr(imm)                        变量 ID       数据地址
  0x4      dst = code_addr(imm)                       整数         代码地址
  0x5      dst = map_by_idx(imm)                      map 索引      map
  0x6      dst = map_val(map_by_idx(imm)) + next_imm  map 索引      数据地址
  =======  =========================================  ===========  ==============

其中

* `map_by_fd(imm)` 意味着将 32 位文件描述符转换为 map 的地址（参见 `Maps`_）
* `map_by_idx(imm)` 意味着将 32 位索引转换为 map 的地址
* `map_val(map)` 获取给定 map 中第一个值的地址
* `var_addr(imm)` 获取具有指定 ID 的平台变量的地址（参见 `平台变量`_）
* `code_addr(imm)` 获取相对于当前指令位置（以 64 位指令的数量为单位）指定偏移处指令的地址
* `imm 类型` 可以被反汇编器用于显示
* `目标类型` 可以用于验证和 JIT 编译的目的

Map
~~~

Map 是一些平台上 BPF 程序可以访问的共享内存区域。
Map 可以有不同的语义，这些语义在单独的文档中定义，并且不一定有单一连续的内存区域，但目前 `map_val(map)` 只对有单一连续内存区域的 map 定义。
每个 map 如果平台支持的话可以有一个文件描述符(fd)，其中 `map_by_fd(imm)` 意味着获取具有指定文件描述符的 map。每个 BPF 程序也可以定义为使用一组在加载时与程序关联的 map，而 `map_by_idx(imm)` 意味着获取具有给定索引的、与包含该指令的 BPF 程序相关联的 map。
### 平台变量

平台变量是由整数ID标识的内存区域，这些内存区域由运行时暴露，并在某些平台上可供BPF程序访问。`var_addr(imm)`操作意味着获取由给定ID标识的内存区域的地址。

### 遗留BPF数据包访问指令

BPF之前引入了用于访问数据包数据的特殊指令，这些指令是从经典BPF继承过来的。这些指令使用“LD”指令类别、“W”、“H”或“B”的大小修饰符以及“ABS”或“IND”的模式修饰符。`dst_reg`和`offset`字段设置为0，对于“ABS”，`src_reg`也设置为0。然而，这些指令已被废弃，**不应再使用**。所有遗留的数据包访问指令都属于“packet”一致性组。
