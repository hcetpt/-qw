标题：=================
BPF 环形缓冲区
=================

本文档描述了 BPF 环形缓冲区设计、API 和实现细节。
.. contents::
    :local:
    :depth: 2

动机
----------

本工作的两个独特推动力，现有 perf 缓冲区无法满足，这促使创建新的环形缓冲区实现：
- 通过跨 CPU 共享环形缓冲区来更高效地利用内存；
- 即使在多个 CPU 上，也保留随时间顺序发生的事件的顺序（例如，任务的 fork/exec/exit 事件）
这两个问题相互独立，但 perf 缓冲区都无法满足两者。
这两个问题都是选择每个 CPU 拥有独立 perf 环形缓冲区的结果。二者都可以通过具有 MPSC（多生产者单消费者）实现的环形缓冲区解决。理论上，排序问题可以通过内核中的一些计数解决，但对于 perf 缓冲区，鉴于第一个问题需要一个 MPSC 缓冲区，同一解决方案会自动解决第二个问题。

语义和 API
------------------

单个环形缓冲区作为类型为 ``BPF_MAP_TYPE_RINGBUF`` 的 BPF 映射实例呈现给 BPF 程序。考虑过两种其他替代方案，但最终被拒绝。
一种方式是，类似于 ``BPF_MAP_TYPE_PERF_EVENT_ARRAY``，使 ``BPF_MAP_TYPE_RINGBUF`` 能够表示一组环形缓冲区，但不强制执行“仅限相同 CPU”规则。这将是一个与现有 BPF 中 perf 缓冲区使用更熟悉的接口，但如果应用程序需要更高级的逻辑来通过任意键查找环形缓冲区，则会失败。
``BPF_MAP_TYPE_HASH_OF_MAPS`` 通过当前方法解决了这一点。
此外，考虑到 BPF 环形缓冲区的性能，许多用例会选择使用所有 CPU 共享的简单单个环形缓冲区，对于这种情况，当前方法将显得过度复杂。
另一种方法可以引入一个新的概念，与 BPF 映射并行，以表示通用的“容器”对象，该对象不一定具有带查找/更新/删除操作的键/值接口。这种方法将增加大量额外的基础设施，需要构建用于可观察性和验证器支持。它也会向 BPF 开发人员引入另一个必须熟悉的概念，libbpf 中的新语法等。但实际并未提供比使用映射方法更多的好处。``BPF_MAP_TYPE_RINGBUF`` 不支持查找/更新/删除操作，但其他一些映射类型也不支持（例如，队列和堆栈；数组不支持删除等）。
所选方法的优势在于能够重用现有的BPF映射基础设施（内核中的自省API、libbpf支持等），这是一个熟悉的概念（无需向用户教授BPF程序中的一种新对象类型），并利用现有工具（如bpftool）。对于使用单一环形缓冲区供所有CPU使用的常见场景，它同样简单直接，就像使用专用的“容器”对象一样。另一方面，作为映射，它可以与“ARRAY_OF_MAPS”和“HASH_OF_MAPS”中的映射组合，以实现各种拓扑结构，从每个CPU一个环形缓冲区（例如，作为perf缓冲区使用案例的替代方案）到复杂的应用程序哈希/分片的环形缓冲区（例如，拥有一个小的环形缓冲池，其中任务的tgid经过哈希处理作为查找键，以保持顺序但减少竞争）。

键和值大小被强制为零。“max_entries”用于指定环形缓冲区的大小，且必须是2的幂次值。

perf缓冲区（`BPF_MAP_TYPE_PERF_EVENT_ARRAY`）和新的BPF环形缓冲语义之间有很多相似之处：

- 可变长度记录；
- 如果环形缓冲区没有更多空间，则保留失败，不进行阻塞；
- 用户空间应用程序可映射的数据区域，便于消费和高性能；
- 新数据到达时的epoll通知；
- 但是，如果必要，仍然有能力对新数据进行忙轮询，以达到最低延迟

BPF环形缓冲为BPF程序提供了两套API：

- `bpf_ringbuf_output()`允许将数据从一处复制到环形缓冲区，类似于`bpf_perf_event_output()`；
- `bpf_ringbuf_reserve()`/`bpf_ringbuf_commit()`/`bpf_ringbuf_discard()` API将整个过程分为两个步骤。首先，预留固定数量的空间。如果成功，返回环形缓冲数据区域内数据的指针，BPF程序可以像使用数组/哈希映射内的数据一样使用它。一旦准备就绪，这段内存要么被提交，要么被丢弃。丢弃类似于提交，但使消费者忽略该记录。

`bpf_ringbuf_output()`的缺点是会引发额外的内存复制，因为记录必须先在其他地方准备好。但它允许提交长度未知于验证器的记录。它也与`bpf_perf_event_output()`紧密匹配，因此将大大简化迁移。

`bpf_ringbuf_reserve()`通过直接向环形缓冲内存提供内存指针避免了额外的内存复制。在许多情况下，记录大于BPF堆栈空间允许的大小，因此许多程序会使用额外的每CPU数组作为准备样本的临时堆。bpf_ringbuf_reserve()完全避免了这种需求。但作为交换，它只允许预留已知的常量大小的内存，以便验证器可以验证BPF程序不能访问其预留记录空间之外的内存。虽然由于额外的内存复制而略慢，`bpf_ringbuf_output()`覆盖了一些不适合`bpf_ringbuf_reserve()`的使用场景。

提交和丢弃之间的区别很小。丢弃只是标记记录为已丢弃，此类记录应由消费者代码忽略。丢弃适用于一些高级使用场景，例如确保所有或无多记录提交，或在单个BPF程序调用中模拟临时的`malloc()`/`free()`。

每个预留记录都通过现有的引用跟踪逻辑由验证器进行跟踪，类似于套接字引用跟踪。因此不可能预留一条记录，但忘记提交（或丢弃）它。

`bpf_ringbuf_query()`辅助函数允许查询环形缓冲区的各种属性。目前支持4种：

- `BPF_RB_AVAIL_DATA`返回环形缓冲区中未消费的数据量；
- `BPF_RB_RING_SIZE`返回环形缓冲区的大小；
- `BPF_RB_CONS_POS`/`BPF_RB_PROD_POS`分别返回当前消费者的逻辑位置/生产者

返回的值是环形缓冲区状态的瞬间快照，可能在辅助函数返回时就已经过时，因此这仅应用于调试/报告原因或实现考虑某些特性高度变化性的各种启发式算法。
一种这样的启发式方法可能涉及对环形缓冲区中新数据可用性的poll/epoll通知更精细的控制。结合`BPF_RB_NO_WAKEUP`/`BPF_RB_FORCE_WAKEUP`标志用于输出/提交/丢弃辅助功能，它允许BPF程序具有高度的控制能力，例如，更高效的批量通知。然而，默认的自我平衡策略对于大多数应用程序来说已经足够，并且将可靠而高效地工作。

设计与实现
--------------

这种预留/提交模式允许多个生产者，无论是在不同的CPU上还是甚至在相同的CPU或同一BPF程序中，独立地预留记录并处理它们，而不阻塞其他生产者。这意味着如果一个BPF程序被另一个共享相同环形缓冲区的BPF程序中断，它们都将得到记录的预留（只要剩余空间充足），并且可以独立地处理和提交这些记录。这同样适用于NMI上下文，除了在预留时使用自旋锁，在NMI上下文中，`bpf_ringbuf_reserve()`可能会因为无法获取锁而失败，即使环形缓冲区未满的情况下也是如此。

环形缓冲区本身内部实现为一个2的幂大小的循环缓冲区，有两个逻辑上且始终增加的计数器（在32位架构上可能回绕，但这不是问题）：

- 消费者计数器显示消费者已消费的数据到哪个逻辑位置；
- 生产者计数器表示所有生产者预留的数据量
每次记录被预留时，拥有该记录的生产者将成功推进生产者计数器。此时，数据仍然尚未准备好供消费。每个记录有8字节的头部，其中包含预留记录的长度以及两个额外的比特：忙碌比特表示记录仍在处理中，以及丢弃比特，如果在提交时记录被丢弃，则可能会被设置。在这种情况下，消费者应该跳过该记录并继续到下一个。记录头还编码了记录相对于环形缓冲区数据区域开始处的相对偏移（以页为单位）。这使得`bpf_ringbuf_commit()`/`bpf_ringbuf_discard()`仅接受记录本身的指针，而不需要环形缓冲区本身的指针即可。环形缓冲区的内存位置将从记录元数据头恢复。这极大地简化了验证过程，同时也提高了API的可用性。

生产者计数器的递增在自旋锁下进行序列化，因此在预留之间存在严格的顺序。另一方面，提交是完全无锁且独立的。所有记录按预留顺序对消费者可用，但只有在所有先前记录已被提交后。因此，慢速生产者可能暂时阻碍那些被较晚预留的已提交记录。

一个显著简化（从而也加速）生产者和消费者实现的有趣实施细节是数据区域如何在虚拟内存中连续两次背靠背映射。这允许对于必须在循环缓冲区数据区域末尾环绕的样本，不必采取任何特殊措施，因为最后一页数据之后的下一页将是第一数据页再次出现，因此样本在虚拟内存中仍将完全连续。参见`bpf_ringbuf_area_alloc()`中的注释和简单的ASCII图示，以视觉方式展示这一点。

BPF环形缓冲区区别于perf环形缓冲区的另一特征是自我调速的新数据可用性通知。`bpf_ringbuf_commit()`的实现在提交后仅当消费者已经追赶到正在提交的记录时才会发送新记录可用的通知。如果不是这样，消费者仍然需要追赶，因此无需额外的轮询通知就能看到新数据。

基准测试（见tools/testing/selftests/bpf/benchs/bench_ringbufs.c）表明，这允许在无需采用“每N个样本通知一次”等技巧的情况下达到非常高的吞吐量，而在perf缓冲区中这些技巧是必要的。对于极端情况，当BPF程序想要对通知有更多的手动控制时，提交/丢弃/输出辅助函数接受`BPF_RB_NO_WAKEUP`和`BPF_RB_FORCE_WAKEUP`标志，这提供了数据可用性通知的全面控制，但要求在使用此API时额外小心和谨慎。
