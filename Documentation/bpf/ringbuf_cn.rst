============= BPF 环形缓冲区 =============

本文档描述了 BPF 环形缓冲区的设计、API 和实现细节。

.. contents::
    :local:
    :depth: 2

动机
----------

本工作有两个显著的驱动因素，这些因素在现有的 perf 缓冲区中并未得到满足，从而促使创建了一个新的环形缓冲区实现：
- 更高效地利用内存，通过跨 CPU 共享环形缓冲区；
- 即使跨越多个 CPU，也保留随时间顺序发生的事件的顺序（例如，任务的 fork/exec/exit 事件）。
这两个问题独立存在，但 perf 缓冲区在这两方面都未能满足需求。之所以出现这些问题，是因为选择为每个 CPU 实现一个独立的 perf 环形缓冲区。这两个问题也可以通过实现一个多生产者单消费者 (MPSC) 的环形缓冲区来解决。理论上，通过内核中的某些计数机制可以解决排序问题，但考虑到第一个问题需要 MPSC 缓冲区，相同的解决方案会自动解决第二个问题。

语义和 API
------------------

单个环形缓冲区作为类型为 `BPF_MAP_TYPE_RINGBUF` 的 BPF 映射实例呈现给 BPF 程序。考虑过另外两种替代方案，但最终被拒绝。

一种方式是类似于 `BPF_MAP_TYPE_PERF_EVENT_ARRAY`，让 `BPF_MAP_TYPE_RINGBUF` 表示环形缓冲区数组，但不强制执行“仅限同一 CPU”的规则。这将是一个与现有 BPF 中 perf 缓冲区使用更兼容的界面，但如果应用程序需要更高级的逻辑来根据任意键查找环形缓冲区，则这种方法将失败。

另一种方法是引入一个新的概念，与 BPF 映射并行，表示通用的“容器”对象，该对象不一定具有带有查找/更新/删除操作的键/值接口。这种方法将增加大量的额外基础设施以支持可观察性和验证器。它还会引入另一个概念，BPF 开发者需要熟悉这个概念，引入 libbpf 中的新语法等。但实际上，并没有提供比使用映射更多的额外好处。`BPF_MAP_TYPE_RINGBUF` 不支持查找/更新/删除操作，但其他几种映射类型也不支持这些操作（例如，队列和堆栈；数组不支持删除等）。
所选择的方法具有重用现有BPF映射基础设施（内核中的自省API、libbpf支持等）的优势，是一个熟悉的概念（无需向用户教授BPF程序中的一种新对象类型），并且利用了现有的工具（如bpftool）。对于使用单一环形缓冲区供所有CPU使用的常见场景来说，它同样简单直接，就像使用专用的“容器”对象一样。另一方面，作为映射，它可以与“ARRAY_OF_MAPS”和“HASH_OF_MAPS”这类映射中的映射相结合，实现各种不同的拓扑结构，从每个CPU一个环形缓冲区（例如，作为perf buffer使用案例的替代方案）到复杂的环形缓冲区哈希/分片应用（例如，拥有一个小规模的环形缓冲区池，其中任务的tgid经过哈希处理后作为查找键以保持顺序但减少竞争）。

键和值大小被强制为零。“max_entries”用于指定环形缓冲区的大小，并且必须是2的幂。
BPF环形缓冲区与perf buffer（`BPF_MAP_TYPE_PERF_EVENT_ARRAY`）之间有很多相似之处：

- 可变长度记录；
- 如果环形缓冲区没有剩余空间，则保留操作失败，不会阻塞；
- 为用户空间应用程序提供可内存映射的数据区域以方便消费和提高性能；
- 对于新数据到达时的epoll通知；
- 但仍然有能力通过忙轮询获取新数据来达到最低延迟，如果必要的话。

BPF环形缓冲区向BPF程序提供了两组API：

- `bpf_ringbuf_output()`允许将数据从一处复制到环形缓冲区中，类似于`bpf_perf_event_output()`；
- `bpf_ringbuf_reserve()`/`bpf_ringbuf_commit()`/`bpf_ringbuf_discard()`这些API将整个过程分为两个步骤。首先，预留固定数量的空间。如果成功，则返回环形缓冲区数据区域内数据的指针，BPF程序可以像使用数组/哈希映射中的数据一样使用这个指针。一旦准备就绪，这部分内存会被提交或丢弃。丢弃类似于提交，但使消费者忽略该记录。

`bpf_ringbuf_output()`的缺点在于需要额外的内存拷贝，因为记录必须在其他地方先准备好。但它允许提交长度未知的记录给验证器。此外，它与`bpf_perf_event_output()`非常接近，因此会极大地简化迁移过程。
`bpf_ringbuf_reserve()`通过直接向环形缓冲区内存提供内存指针避免了额外的内存拷贝。在许多情况下，记录比BPF栈空间允许的更大，因此许多程序会使用额外的每CPU数组作为临时堆来准备样本。`bpf_ringbuf_reserve()`完全避免了这种需求。但作为交换，它只允许预留已知的固定大小的内存，这样验证器可以验证BPF程序不能访问超出其预留记录空间之外的内存。虽然`bpf_ringbuf_output()`由于额外的内存拷贝而略慢一些，但它覆盖了一些不适合使用`bpf_ringbuf_reserve()`的情况。

提交与丢弃之间的区别很小。丢弃只是标记记录为已丢弃，这样的记录应被消费者代码忽略。丢弃适用于某些高级使用场景，比如确保所有记录要么全部提交要么全部不提交或多记录提交的模拟临时“malloc()”/“free()”功能。

每个预留的记录都通过现有的引用跟踪逻辑被验证器跟踪，这与套接字引用跟踪类似。因此不可能预留一个记录却忘记提交（或丢弃）它。
`bpf_ringbuf_query()`辅助函数允许查询环形缓冲区的各种属性。目前支持四种：

- `BPF_RB_AVAIL_DATA`返回环形缓冲区中未消费的数据量；
- `BPF_RB_RING_SIZE`返回环形缓冲区的大小；
- `BPF_RB_CONS_POS`/`BPF_RB_PROD_POS`分别返回当前消费者的逻辑位置和生产者的逻辑位置

返回的值是环形缓冲区状态的瞬时快照，在辅助函数返回时可能会有所偏差，因此只应用于调试/报告目的或实现在某些特性高度变化的情况下考虑这些特性的各种启发式算法。
一种这样的启发式方法可能涉及对环形缓冲区中新数据可用性的 poll/epoll 通知进行更细粒度的控制。结合 `BPF_RB_NO_WAKEUP` / `BPF_RB_FORCE_WAKEUP` 标志用于输出/提交/丢弃辅助函数，它允许 BPF 程序具有高度的控制能力，并且例如可以实现更高效的批量通知。不过，默认的自我平衡策略对于大多数应用程序来说已经足够，并且将可靠高效地工作。

设计与实现
-----------

这种预留/提交方案允许多个生产者以自然的方式预留独立的记录并对其进行操作，而不会阻塞其他生产者，这些生产者可以在不同的 CPU 上或甚至在同一 BPF 程序中。这意味着如果一个 BPF 程序被另一个共享相同环形缓冲区的 BPF 程序中断，它们都将获得一条记录预留（前提是剩余空间足够），并且可以独立地处理和提交该记录。这也适用于 NMI（不可屏蔽中断）上下文，只是由于在预留过程中使用了自旋锁，在 NMI 上下文中，`bpf_ringbuf_reserve()` 可能无法获取锁，即使环形缓冲区未满，预留也会失败。

环形缓冲区本身内部实现为 2 的幂大小的循环缓冲区，有两个逻辑上且不断增加的计数器（在 32 位架构上可能会回绕，这不是问题）：

- 消费者计数器显示消费者已消费的数据的逻辑位置；
- 生产者计数器表示所有生产者预留的数据量

每当一条记录被预留时，拥有该记录的生产者会成功推进生产者计数器。此时，数据仍然还未准备好供消费。每条记录都有一个 8 字节的头部，其中包含预留记录的长度以及两个额外的比特：忙比特表示记录仍在处理中，丢弃比特可在提交时设置，如果记录被丢弃。在这种情况下，消费者应跳过该记录并继续处理下一个。记录头部还编码了记录相对于环形缓冲区数据区域起始位置的相对偏移（按页计算）。这使得 `bpf_ringbuf_commit()` / `bpf_ringbuf_discard()` 只需要记录本身的指针，而不需要指向环形缓冲区本身的指针。环形缓冲区的内存位置将从记录元数据头部恢复。这不仅大大简化了验证过程，也提高了 API 的可用性。

生产者计数器的递增是在自旋锁下序列化的，因此预留之间有严格的顺序。另一方面，提交是完全无锁且独立的。所有记录按照预留的顺序提供给消费者，但只有在所有之前的记录都已提交后才可消费。因此，慢速生产者可以暂时阻止已提交但稍后预留的记录。

一个显著简化（也因此加快速度）生产者和消费者实现的有趣的设计点是，如何在虚拟内存中连续地将数据区域映射两次。这样就不必为必须绕过环形缓冲区数据区域末尾的样本采取特殊措施，因为最后一个数据页之后的下一页将是第一个数据页，因此样本在虚拟内存中仍然保持完全连续。请参阅 `bpf_ringbuf_area_alloc()` 中的注释和简单的 ASCII 图表，以直观地展示这一点。

BPF 环形缓冲区区别于 perf 环形缓冲区的另一特征是自我调整的新数据可用性通知。`bpf_ringbuf_commit()` 实现仅在消费者已跟上到正在提交的记录时才会发送新记录可用的通知。如果不是这种情况，则消费者仍需赶上进度，因此无需额外的 poll 通知就能看到新数据。

基准测试（见 tools/testing/selftests/bpf/benchs/bench_ringbufs.c）表明，这允许在无需采用“每隔 N 个样本通知一次”等技巧的情况下达到非常高的吞吐量，而在 perf 缓冲区中这是必要的。对于极端情况，当 BPF 程序想要对通知有更多的手动控制时，提交/丢弃/输出辅助函数接受 `BPF_RB_NO_WAKEUP` 和 `BPF_RB_FORCE_WAKEUP` 标志，这提供了对数据可用性通知的完全控制，但也要求在使用此 API 时格外小心和细致。
