============= BPF 环形缓冲区 =============

本文档描述了 BPF 环形缓冲区的设计、API 和实现细节。

.. contents::
    :local:
    :depth: 2

动机
----------

本工作有两个显著的驱动因素，这些因素在现有的 perf 缓冲区中并未得到满足，从而促使创建了一个新的环形缓冲区实现：
- 更高效地利用内存，通过跨 CPU 共享环形缓冲区；
- 即使跨越多个 CPU，也保留随时间顺序发生的事件的顺序（例如，任务的 fork/exec/exit 事件）。
这两个问题独立存在，但 perf 缓冲区在这两方面都未能满足需求。之所以出现这些问题，是因为选择为每个 CPU 实现一个独立的 perf 环形缓冲区。这两个问题也可以通过实现一个多生产者单消费者 (MPSC) 的环形缓冲区来解决。理论上，通过内核中的某些计数机制可以解决排序问题，但鉴于第一个问题需要 MPSC 缓冲区，相同的解决方案会自动解决第二个问题。

语义和 API
------------------

单个环形缓冲区作为类型为 `BPF_MAP_TYPE_RINGBUF` 的 BPF 映射实例呈现给 BPF 程序。考虑过另外两种替代方案，但最终被拒绝。

一种方式是类似于 `BPF_MAP_TYPE_PERF_EVENT_ARRAY`，让 `BPF_MAP_TYPE_RINGBUF` 表示环形缓冲区数组，但不强制执行“仅限同一 CPU”的规则。这将是一个与现有 BPF 中 perf 缓冲区使用更兼容的界面，但如果应用程序需要更高级的逻辑来根据任意键查找环形缓冲区，则该方法会失败。

`BPF_MAP_TYPE_HASH_OF_MAPS` 以当前的方法解决了这个问题。

此外，考虑到 BPF 环形缓冲区的性能，许多用例会选择使用一个简单的环形缓冲区，该缓冲区由所有 CPU 共享，而当前的方法在这种情况下显得过于复杂。

另一种方法可能引入一个新的概念，与 BPF 映射并列，代表通用的“容器”对象，不一定具有带查找/更新/删除操作的键/值接口。这种方法会增加大量额外的基础架构，用于可观察性和验证器支持。它还会增加另一个概念，BPF 开发人员需要熟悉，libbpf 中的新语法等。但实际上并没有提供比使用映射更多的好处。`BPF_MAP_TYPE_RINGBUF` 不支持查找/更新/删除操作，但其他几种映射类型也不支持这些操作（例如，队列和栈不支持这些操作；数组不支持删除操作等）。
所选择的方法具有重用现有BPF映射基础设施（内核中的自省API、libbpf支持等）的优势，是一个熟悉的概念（无需向用户教授BPF程序中的新对象类型），并且利用了现有的工具（如bpftool）。对于使用单一环形缓冲区供所有CPU使用的常见场景而言，它同样简单直接，就像使用专门的“容器”对象一样。另一方面，作为映射，它可以与“数组中的映射”和“哈希中的映射”结合使用，以实现各种拓扑结构，从每个CPU一个环形缓冲区（例如，作为perf缓冲区使用案例的替代方案），到复杂的环形缓冲区哈希/分片应用（例如，有一个较小的环形缓冲区池，其中任务的tgid经过哈希处理后作为查找键，以保持顺序但减少竞争）。
键和值大小被强制为零。“max_entries”用于指定环形缓冲区的大小，并且必须是2的幂。
与perf缓冲区（`BPF_MAP_TYPE_PERF_EVENT_ARRAY`）和新的BPF环形缓冲区语义之间有许多相似之处：

- 可变长度记录；
- 如果环形缓冲区中没有更多空间，则保留失败，不会阻塞；
- 用户空间应用程序可以映射数据区域以方便消费和提高性能；
- 新数据到达时的epoll通知；
- 但是仍然有能力对新数据进行繁忙轮询，如果必要的话，可以达到最低延迟

BPF环形缓冲区为BPF程序提供了两组API：

- `bpf_ringbuf_output()`允许将数据从一个地方*复制*到环形缓冲区，类似于`bpf_perf_event_output()`；
- `bpf_ringbuf_reserve()`/`bpf_ringbuf_commit()`/`bpf_ringbuf_discard()` API将整个过程分为两个步骤。首先，预留固定数量的空间。如果成功，返回指向环形缓冲区数据区域内数据的指针，BPF程序可以像使用数组/哈希映射内的数据一样使用该指针。一旦准备就绪，这块内存要么提交要么丢弃。丢弃类似于提交，但让消费者忽略这条记录。

`bpf_ringbuf_output()`的缺点是会增加额外的内存拷贝，因为记录必须先在其他地方准备好。但它允许提交长度未知于验证器的记录。此外，它与`bpf_perf_event_output()`非常接近，因此将极大地简化迁移过程。
`bpf_ringbuf_reserve()`通过直接提供环形缓冲区内存的内存指针避免了额外的内存拷贝。在很多情况下，记录大于BPF堆栈空间允许的大小，因此许多程序会使用额外的每CPU数组作为临时堆来准备样本。`bpf_ringbuf_reserve()`完全避免了这种需求。但作为交换，它只允许预留已知的固定大小的内存，这样验证器可以验证BPF程序不能访问超出其预留记录空间之外的内存。虽然`bpf_ringbuf_output()`由于额外的内存拷贝而略慢一些，但它覆盖了一些不适合使用`bpf_ringbuf_reserve()`的使用案例。
提交和丢弃之间的区别很小。丢弃只是标记一条记录为已丢弃，这样的记录应被消费者代码忽略。丢弃对于一些高级使用案例很有用，比如确保所有或无一的多条记录提交，或者在单次BPF程序调用中模拟临时的`malloc()`/`free()`。
每个预留的记录都通过现有的引用跟踪逻辑由验证器跟踪，类似于套接字引用跟踪。因此，不可能预留一条记录却忘记提交（或丢弃）它。
`bpf_ringbuf_query()`辅助函数允许查询环形缓冲区的各种属性。目前支持4种：

- `BPF_RB_AVAIL_DATA`返回环形缓冲区中未消费的数据量；
- `BPF_RB_RING_SIZE`返回环形缓冲区的大小；
- `BPF_RB_CONS_POS`/`BPF_RB_PROD_POS`分别返回当前消费者的逻辑位置和生产者的逻辑位置
返回的值是环形缓冲区状态的一瞬间快照，到辅助函数返回时可能已经有所偏差，因此这仅应用于调试/报告目的或实现考虑到这些特性高度变化性的各种启发式方法。
一种这样的启发式方法可能涉及对环形缓冲区中新数据可用性的 poll/epoll 通知进行更细粒度的控制。结合 `BPF_RB_NO_WAKEUP` / `BPF_RB_FORCE_WAKEUP` 标志用于输出/提交/丢弃辅助函数，它允许 BPF 程序具有高度的控制能力，例如，可以实现更高效的批量通知。不过，默认的自平衡策略对于大多数应用程序来说已经足够，并且将可靠高效地工作。

设计与实现
-----------

这种预留/提交方案允许多个生产者（无论是在不同的 CPU 上还是甚至在同一个 CPU 或同一 BPF 程序中）以非阻塞的方式独立地预留记录并处理它们。这意味着如果一个 BPF 程序被另一个共享相同环形缓冲区的 BPF 程序中断，两者都将获得一条记录预留（只要剩余空间足够），并且可以独立地处理和提交这些记录。这同样适用于 NMI（不可屏蔽中断）上下文，只是由于在预留时使用了自旋锁，在 NMI 上下文中，`bpf_ringbuf_reserve()` 可能无法获取锁，即使环形缓冲区未满，预留也可能失败。

环形缓冲区本身内部实现为 2 的幂次大小的循环缓冲区，有两个逻辑上递增的计数器（在 32 位架构上可能会回绕，这不是问题）：

- 消费者计数器显示消费者消费数据到哪个逻辑位置；
- 生产者计数器表示所有生产者预留的数据量。

每当一条记录被预留时，拥有该记录的生产者将成功推进生产者计数器。此时，数据仍然尚未准备好供消费。每条记录都有一个 8 字节的头部，其中包含预留记录的长度以及两个额外的比特：忙碌比特表示记录仍在处理中；丢弃比特可以在提交时设置，如果记录被丢弃。在这种情况下，消费者应该跳过该记录并继续处理下一条记录。记录头部还编码了记录相对于环形缓冲区数据区域起始处的相对偏移（按页计算）。这使得 `bpf_ringbuf_commit()` / `bpf_ringbuf_discard()` 只需要接受记录本身的指针而不需要环形缓冲区本身的指针即可。环形缓冲区的内存位置将从记录元数据头部恢复。这极大地简化了验证过程，同时也提高了 API 的可用性。

生产者计数器的递增是在自旋锁下序列化的，因此预留之间有严格的顺序。另一方面，提交是完全无锁且独立的。所有记录按照预留的顺序提供给消费者，但只有在所有之前的记录都已经提交后才提供。因此，慢速生产者可能会暂时阻止已提交的记录，这些记录是稍后预留的。

一个显著简化（从而也加快）生产者和消费者实现的有趣实现细节是数据区域如何在虚拟内存中连续两次背靠背映射。这样就不需要对那些必须在循环缓冲区数据区域末尾环绕的样本采取特殊措施，因为最后一个数据页之后的下一页将是第一个数据页，因此样本在虚拟内存中仍然是完全连续的。请参阅 `bpf_ringbuf_area_alloc()` 中的注释和简单的 ASCII 图表，以直观展示这一点。

另一个将 BPF 环形缓冲区与 perf 环形缓冲区区分开来的特性是自我调节的新数据可用性通知。`bpf_ringbuf_commit()` 实现仅在消费者已经追赶到即将提交的记录时发送新记录可用的通知。如果没有，则消费者仍需追赶，因此无需额外的 poll 通知就可以看到新数据。

基准测试（见 tools/testing/selftests/bpf/benchs/bench_ringbufs.c）表明，这允许在不需要像“每 N 个样本通知一次”这样的技巧的情况下实现非常高的吞吐量，而在 perf 缓冲区中这是必要的。对于极端情况，当 BPF 程序希望对通知有更多的手动控制时，提交/丢弃/输出辅助函数接受 `BPF_RB_NO_WAKEUP` 和 `BPF_RB_FORCE_WAKEUP` 标志，这提供了对数据可用性通知的完全控制，但要求在使用此 API 时更加小心谨慎。
