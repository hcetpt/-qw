=========================
BPF 图数据结构
=========================

本文档描述了新型“图”数据结构（链表、红黑树）的实现细节，特别关注验证器针对这些数据结构特定语义的实现。
虽然本文档中没有提及具体的验证器代码，但假设读者具备关于BPF验证器内部原理、BPF映射以及编写BPF程序的一般知识。
请注意，本文档旨在描述这些图数据结构当前的状态。**不保证**其语义或API的稳定性。

.. contents::
    :local:
    :depth: 2

简介
------------

BPF映射API历来是将各种类型的数据结构暴露给BPF程序的主要方式。某些数据结构与映射API天然契合（如HASH、ARRAY），而其他一些则不然。因此，对于那些缺乏BPF经验的内核程序员来说，处理后一类数据结构的程序可能难以理解。
幸运的是，一些促使使用BPF映射语义的限制已经不再适用。随着kfuncs、kptrs和any-context BPF分配器的引入，现在可以实现与内核其他部分暴露的API和语义更为接近的BPF数据结构。
两种这样的数据结构——链表和红黑树——有许多共同的验证细节。因为两者都有“根”（链表中的“头”）和“节点”，验证器代码和本文档都将其共同功能称为“graph_api”、“graph_root”、“graph_node”等。
除非另有说明，以下示例和语义适用于这两种图数据结构。

不稳定API
------------

使用BPF映射API实现的数据结构历来使用BPF辅助函数——要么是像`bpf_map_update_elem`这样的标准映射API辅助函数，要么是特定映射的辅助函数。新型图数据结构则使用kfuncs来定义它们的操纵辅助函数。由于kfuncs没有稳定性保证，这些数据结构的API和语义可以根据需要以破坏向后兼容性的方式进行演进。
新型数据结构的根和节点类型在`uapi/linux/bpf.h`头部文件中不透明地定义。

锁
-------

新型数据结构是侵入式的，并且类似于它们的原生内核对应物那样定义：

.. code-block:: c

        struct node_data {
          long key;
          long data;
          struct bpf_rb_node node;
        };

        struct bpf_spin_lock glock;
        struct bpf_rb_root groot __contains(node_data, node);

链表和红黑树的“根”类型都期望位于包含`bpf_spin_lock`的映射值中——在上面的例子中，两个全局变量被放置在一个单值数组映射中。验证器认为这个自旋锁与`bpf_rb_root`相关联，因为它们都在同一个映射值中，并会在验证操作树的BPF程序时强制确保持有正确的锁。由于这种锁检查发生在验证时间，因此在运行时不会有任何性能损失。
### 非所有权引用

**动机**

考虑以下BPF代码：

```c
struct node_data *n = bpf_obj_new(typeof(*n)); /* ACQUIRED */

bpf_spin_lock(&lock);

bpf_rbtree_add(&tree, n); /* PASSED */

bpf_spin_unlock(&lock);
```

从验证器的角度来看，`bpf_obj_new`返回的指针`n`具有类型`PTR_TO_BTF_ID | MEM_ALLOC`，带有`struct node_data`的`btf_id`和非零的`ref_obj_id`。由于程序持有`n`，它拥有被指向对象（通过`n`指向的对象）的生命周期。BPF程序在退出前必须传递所有权——要么通过`bpf_obj_drop`释放该对象，要么通过`bpf_rbtree_add`将其添加到`tree`中。（示例中的`ACQUIRED`和`PASSED`注释分别表示“获取所有权”和“传递所有权”的语句）

验证器在所有权传递后应该对`n`做什么？如果对象使用`bpf_obj_drop`释放，则答案很明显：验证器应当拒绝尝试在`bpf_obj_drop`之后访问`n`的程序，因为此时对象已不再有效。底层内存可能已被重用作其他分配、解除映射等。
当所有权通过`bpf_rbtree_add`传递给`tree`时，答案就不那么明显了。验证器可以强制执行与`bpf_obj_drop`相同的语义，但这将导致一些有用且常见的编程模式被拒绝，例如：

```c
int x;
struct node_data *n = bpf_obj_new(typeof(*n)); /* ACQUIRED */

bpf_spin_lock(&lock);

bpf_rbtree_add(&tree, n); /* PASSED */
x = n->data;
n->data = 42;

bpf_spin_unlock(&lock);
```

读取和写入`n->data`都将被拒绝。但是，验证器可以通过利用两个细节来做得更好：

1. 图数据结构API只能在持有与图根关联的`bpf_spin_lock`时使用。
2. 所有图数据结构都具有指针稳定性：
   - 因为图节点是通过`bpf_obj_new`分配的，并且向根节点添加或删除涉及调整节点结构中的`bpf_{list,rb}_node`字段，所以在进行这两种操作后，图节点将保持在同一地址。
   
由于任何添加或删除节点的程序都必须持有与之关联的`bpf_spin_lock`，因此我们处于由这个锁限定的临界区时，我们知道没有其他程序能够添加或删除节点直到临界区结束。
结合指针稳定性意味着，在临界区结束之前，即使已经使用`n`传递所有权，我们也可以安全地通过`n`访问图节点。
验证器将此类引用视为*非所有权引用*。相应地，`bpf_obj_new`返回的引用被视为*所有权引用*。这两个术语目前仅在图节点和API的上下文中具有意义。

### 详细信息

让我们列举两种类型引用的属性。
**所有权引用**

- 此引用控制被指向对象的生命周期。
- 被指向对象的所有权必须通过传递给某个图API内核函数或通过`bpf_obj_drop`（释放被指向对象）来“释放”。

  - 如果在程序结束前未释放，则验证器认为程序无效。
  
- 访问被指向对象的内存不会导致分页错误。

**非所有权引用**

- 此引用不拥有被指向对象。

  - 它不能用于将图节点添加到图根，也不能通过`bpf_obj_drop`释放。
  
- 没有显式控制生命周期，但可以根据非所有权引用的存在推断出有效的生命周期（参见下面的解释）。
- 访问被指向对象的内存不会导致分页错误。

从验证器的角度来看，非所有权引用只能存在于`spin_lock`和`spin_unlock`之间。为什么？因为在`spin_unlock`之后，另一个程序可以对数据结构执行任意操作，如移除并通过`bpf_obj_drop`释放。指向已移除、释放并通过`bpf_obj_new`重用的内存块的非所有权引用将指向完全不同的东西。
或者该内存可能被释放。

为了避免这种逻辑违规，所有非拥有引用在关键代码段结束后都会被验证器失效。
这是确保非拥有引用“不会产生页错误”属性所必需的。因此如果验证器没有使某个非拥有引用失效，访问它将不会产生页错误。
目前不允许在关键代码段中使用`bpf_obj_drop`，所以如果有有效的非拥有引用，我们一定处于一个关键代码段中，并且可以得出结论：该引用指向的内存没有被释放并`free`或释放并重用。

对于红黑树中的任何一个节点的引用必须是非拥有的，因为树控制着被引用对象的生命周期。同样地，任何不在红黑树中的节点的引用必须是拥有的。这导致了一个很好的特性：
图API的添加/移除实现不需要检查节点是否已经被添加（或已经移除），因为所有权模型允许验证器仅通过类型检查来阻止此类状态的有效性。

然而，指针别名对上述“很好的特性”构成了一个问题。
考虑以下示例：

```c
struct node_data *n, *m, *o, *p;
n = bpf_obj_new(sizeof(*n));     /* 1 */

bpf_spin_lock(&lock);

bpf_rbtree_add(&tree, n);        /* 2 */
m = bpf_rbtree_first(&tree);     /* 3 */

o = bpf_rbtree_remove(&tree, n); /* 4 */
p = bpf_rbtree_remove(&tree, m); /* 5 */

bpf_spin_unlock(&lock);

bpf_obj_drop(o);
bpf_obj_drop(p); /* 6 */
```

假设这个程序运行前树为空。如果我们跟踪验证器状态的变化，使用上述注释中的数字标记：

  1) n是一个拥有引用

  2) n变成了非拥有引用，它已经被加入到树中

  3) n和m都是非拥有引用，它们都指向同一个节点

  4) o是一个拥有引用，n和m为非拥有引用，都指向同一个节点

  5) o和p是拥有引用，n和m为非拥有引用，都指向同一个节点

  6) 发生了重复释放的问题，因为o和p指向同一个节点，并且o已经在上一条语句中被`free`了

状态4和5违反了我们的“很好的特性”，即存在指向不在红黑树中的节点的非拥有引用。第5条语句会尝试移除一个由于这种违规而已经被移除的节点。状态6是一个危险的重复释放问题。

至少我们应该防止状态6的发生。如果我们不能同时防止状态5，那么我们必须放弃我们的“很好的特性”，并在运行时检查节点是否已经被移除。

我们通过推广`bpf_spin_unlock`中“使非拥有引用失效”的行为并执行类似的在`bpf_rbtree_remove`之后的失效操作来防止这两种情况。这里的逻辑是任何图形API内核函数（kfunc）：

  * 接受任意节点作为参数

  * 从数据结构中移除它

  * 返回一个指向移除节点的拥有引用

可能会导致其他一些非拥有引用指向同一节点的状态。因此，“移除”类型的kfuncs也必须被视为使非拥有引用失效的点。
