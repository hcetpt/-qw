=========================
BPF 图数据结构
=========================

本文档描述了新型“图”数据结构（链表、红黑树）的实现细节，特别关注验证器针对这些数据结构特定语义的实现。尽管本文档中没有提及具体的验证器代码，但假设读者具备关于BPF验证器内部原理、BPF映射以及编写BPF程序的一般知识。
请注意，本文档旨在描述这些图数据结构当前的状态。**不保证**其语义或API的稳定性。

.. contents::
    :local:
    :depth: 2

简介
------------

BPF映射API历来是将各种类型的数据结构暴露给BPF程序的主要方式。某些数据结构与映射API天然契合（如HASH、ARRAY），而其他一些则不然。因此，对于没有先前BPF经验的内核程序员来说，与后者这类数据结构交互的程序可能难以理解。
幸运的是，一些促使使用BPF映射语义的限制现在已经不再适用。随着kfuncs、kptrs和任意上下文BPF分配器的引入，现在可以实现与内核其余部分所暴露的API和语义更加接近的BPF数据结构。
两种这样的数据结构——链表和红黑树——有许多共同的验证细节。由于两者都有“根”（链表中的“头”）和“节点”，验证器代码和本文档将共同功能称为“graph_api”、“graph_root”、“graph_node”等。
除非另有说明，下面的例子和语义同时适用于这两种图数据结构。
不稳定API
------------

使用BPF映射API实现的数据结构历来使用BPF辅助函数——要么是标准映射API辅助函数如`bpf_map_update_elem`，要么是映射特定的辅助函数。新型图数据结构则使用kfuncs定义其操作辅助函数。由于kfuncs没有稳定性保证，因此这些数据结构的API和语义可以根据需要以破坏向后兼容性的方式进行演进。
新型数据结构的根和节点类型在`uapi/linux/bpf.h`头文件中不透明地定义。
锁定
-------

新型数据结构是侵入式的，并且类似于它们的内核标准对应物定义：

.. code-block:: c

        struct node_data {
          long key;
          long data;
          struct bpf_rb_node node;
        };

        struct bpf_spin_lock glock;
        struct bpf_rb_root groot __contains(node_data, node);

对于链表和红黑树而言，“根”类型期望位于包含`bpf_spin_lock`的映射值中——在上述示例中，两个全局变量都放置在一个单值数组映射中。验证器认为该自旋锁与`bpf_rb_root`相关联，因为二者都位于同一个映射值中，并会在验证操纵树的BPF程序时强制确保持有正确的锁。由于这种锁检查发生在验证时间，因此在运行时不会有任何性能损失。
### 非所有权引用

**动机**

考虑以下BPF代码：

```c
struct node_data *n = bpf_obj_new(typeof(*n)); /* ACQUIRED */

bpf_spin_lock(&lock);

bpf_rbtree_add(&tree, n); /* PASSED */

bpf_spin_unlock(&lock);
```

从验证器的角度来看，`bpf_obj_new`返回的指针`n`具有类型`PTR_TO_BTF_ID | MEM_ALLOC`，带有`struct node_data`的`btf_id`和非零的`ref_obj_id`。由于程序持有`n`，它拥有被指向对象（通过`n`指向的对象）的生命周期。BPF程序在退出前必须传递所有权——要么通过`bpf_obj_drop`释放该对象，要么通过`bpf_rbtree_add`将其添加到`tree`中。（示例中的`ACQUIRED`和`PASSED`注释分别表示“获取所有权”和“传递所有权”的语句）

验证器在所有权传递后应该对`n`做什么？如果对象使用`bpf_obj_drop`释放，则答案很明显：验证器应当拒绝尝试在`bpf_obj_drop`之后访问`n`的程序，因为此时对象已不再有效。底层内存可能已被重用作其他分配、解除映射等。
当所有权通过`bpf_rbtree_add`传递给`tree`时，答案就不那么明显了。验证器可以强制执行与`bpf_obj_drop`相同的语义，但这将导致一些有用且常见的编程模式被拒绝，例如：

```c
int x;
struct node_data *n = bpf_obj_new(typeof(*n)); /* ACQUIRED */

bpf_spin_lock(&lock);

bpf_rbtree_add(&tree, n); /* PASSED */
x = n->data;
n->data = 42;

bpf_spin_unlock(&lock);
```

读取和写入`n->data`都将被拒绝。但是，验证器可以通过利用两个细节来做得更好：

1. 图数据结构API只能在持有与图根关联的`bpf_spin_lock`时使用。
2. 所有图数据结构都具有指针稳定性：
   - 因为图节点是通过`bpf_obj_new`分配的，并且向根节点添加或删除涉及调整节点结构中的`bpf_{list,rb}_node`字段，所以在这些操作后图节点将继续保留在相同的地址上。
   
由于任何添加或删除节点的程序都必须持有与之关联的`bpf_spin_lock`，因此我们知道直到临界区结束之前，没有其他程序能够进行添加或删除操作。结合指针稳定性意味着，在临界区结束之前，我们即使在传递所有权后也可以安全地通过`n`访问图节点。
验证器将此类引用视为*非所有权引用*。相应地，由`bpf_obj_new`返回的引用被视为*所有权引用*。这两个术语目前仅在图节点和API的上下文中具有意义。

**详细信息**

让我们列举两种类型引用的属性：
***所有权引用***

- 此引用控制被指向对象的生命周期。
- 必须通过将其传递给某个图API内核函数或通过`bpf_obj_drop`来释放被指向对象的所有权，后者会释放该对象。
  - 如果程序结束前未释放所有权，验证器认为程序无效。
- 访问被指向对象的内存不会导致页面错误。

***非所有权引用***

- 此引用不拥有被指向对象。
  - 它不能用于将图节点添加到图根，也不能通过`bpf_obj_drop`释放。
- 没有明确的生命周期控制，但可以根据非所有权引用的存在推断出有效的生命周期（参见下面的解释）。
- 访问被指向对象的内存不会导致页面错误。

从验证器的角度来看，非所有权引用仅存在于`spin_lock`和`spin_unlock`之间。为什么？因为在`spin_unlock`之后，另一个程序可以在数据结构上执行任意操作，如移除并通过`bpf_obj_drop`释放。如果某个内存块被移除、通过`bpf_obj_drop`释放并重新通过`bpf_obj_new`使用，那么指向这块内存的非所有权引用将指向一个完全不同的东西。
或者内存可能会被释放。

为了防止这种逻辑违规，所有非拥有引用在关键代码段结束后都会被验证器失效。这是确保非拥有引用“不会产生页错误”属性所必需的。因此，如果验证器没有使一个非拥有引用失效，访问它将不会产生页错误。
目前不允许在关键代码段中使用`bpf_obj_drop`，所以如果有有效的非拥有引用，我们一定处于关键代码段内，并可以得出结论：该引用的内存没有被释放并`free`，或者没有被释放并重新使用。

对红黑树中的节点的任何引用必须是非拥有的，因为树控制着被引用对象的生命周期。类似地，对不在红黑树中的节点的任何引用必须是拥有的。这导致了一个很好的特性：
图API添加/移除实现不需要检查节点是否已经被添加（或已经移除），因为所有权模型允许验证器仅通过类型检查来阻止此类状态成为有效状态。

然而，指针别名给上述“很好的特性”带来了问题。
考虑以下示例：

```c
struct node_data *n, *m, *o, *p;
n = bpf_obj_new(typeof(*n));     /* 1 */

bpf_spin_lock(&lock);

bpf_rbtree_add(&tree, n);        /* 2 */
m = bpf_rbtree_first(&tree);     /* 3 */

o = bpf_rbtree_remove(&tree, n); /* 4 */
p = bpf_rbtree_remove(&tree, m); /* 5 */

bpf_spin_unlock(&lock);

bpf_obj_drop(o);
bpf_obj_drop(p); /* 6 */
```

假设在程序运行前树为空。如果我们用上面注释中的数字追踪验证器的状态变化：

  1) n是一个拥有引用

  2) n变成了非拥有引用，它已经被加入到树中

  3) n和m都是非拥有引用，它们都指向同一个节点

  4) o是一个拥有引用，n和m为非拥有引用，所有这些都指向同一个节点

  5) o和p是拥有引用，n和m是非拥有引用，它们都指向同一个节点

  6) 发生了双重释放，因为o和p指向同一个节点，而o已经在上一条语句中被`free`了

状态4和5违反了我们的“很好的特性”，即存在指向不在红黑树中的节点的非拥有引用。语句5将尝试移除一个因这一违规行为已被移除的节点。状态6是一个危险的双重释放。

至少我们应该防止状态6的发生。如果我们不能同时阻止状态5，则我们必须放弃我们的“很好的特性”，并在运行时检查节点是否已被移除。

我们通过推广`bpf_spin_unlock`中的“使非拥有引用失效”的行为并类似地在`bpf_rbtree_remove`后进行类似的失效处理来阻止这两种情况。这里的逻辑是任何图API内核函数，如果：

  * 接受任意节点参数

  * 将其从数据结构中移除

  * 返回指向移除节点的拥有引用

那么可能会导致其他某个非拥有引用也指向相同的节点。因此，“移除”类型的内核函数也必须被视为非拥有引用的失效点。
