=========================
BPF 图数据结构
=========================

本文档描述了新型“图”数据结构（链表，红黑树）的实现细节，特别关注于验证器对这些数据结构特有语义的实现。虽然本文档中没有提及任何具体的验证器代码，但假设读者对BPF验证器内部、BPF映射和BPF程序编写有基本了解。
请注意，本文档的目的是描述这些图数据结构的当前状态。**不保证**其语义或API的稳定性。

.. contents::
    :local:
    :depth: 2

简介
------------

BPF映射API历来是为BPF程序暴露各种类型数据结构的主要方式。一些数据结构自然适合映射API（如HASH，ARRAY），而其他则不然。因此，与后一组数据结构交互的程序对于没有先前BPF经验的内核程序员来说可能难以理解。
幸运的是，一些促使使用BPF映射语义的限制不再相关。通过引入kfuncs、kptrs和any-context BPF分配器，现在可以实现BPF数据结构，使其API和语义更接近内核其余部分所暴露的。
两种这样的数据结构——链表和红黑树——有许多共同的验证细节。由于两者都有“根”（链表中的“头”）和“节点”，验证器代码和本文档将共同功能称为“graph_api”，“graph_root”，“graph_node”等。
除非另有说明，以下示例和语义适用于两种图数据结构。
不稳定API
------------

使用BPF映射API实现的数据结构历来使用BPF辅助函数——要么是标准映射API辅助函数如`bpf_map_update_elem`，要么是特定映射的辅助函数。新型图数据结构转而使用kfuncs定义其操作辅助函数。因为kfuncs没有稳定性保证，所以如果必要，这些数据结构的API和语义可以以破坏向后兼容性的方式进化。
新数据结构的根和节点类型在`uapi/linux/bpf.h`头文件中不透明地定义。
锁定
-------

新型数据结构具有侵入性，并且类似于它们的原生内核对应物定义：

.. code-block:: c

        struct node_data {
          long key;
          long data;
          struct bpf_rb_node node;
        };

        struct bpf_spin_lock glock;
        struct bpf_rb_root groot __contains(node_data, node);

对于链表和红黑树，“root”类型期望位于包含`bpf_spin_lock`的map_value中——在上述示例中，两个全局变量都放置在一个单值数组映射中。验证器认为这个自旋锁与`bpf_rb_root`关联，因为它们都在同一个map_value中，并会在验证操作树的BPF程序时强制执行正确的锁被持有。由于这种锁检查发生在验证时间，因此运行时没有开销。
非所有权引用
--------------

**动机**

考虑以下BPF代码：

```c
struct node_data *n = bpf_obj_new(typeof(*n)); /* 获得所有权 */

bpf_spin_lock(&lock);

bpf_rbtree_add(&tree, n); /* 传递所有权 */

bpf_spin_unlock(&lock);
```

从验证器的角度看，由`bpf_obj_new`返回的指针`n`具有类型`PTR_TO_BTF_ID | MEM_ALLOC`，其`btf_id`为`struct node_data`，且有一个非零的`ref_obj_id`。由于它持有`n`，程序拥有所指对象（`n`指向的对象）的生命周期。BPF程序在退出前必须转移所有权——要么通过`bpf_obj_drop`，这会释放该对象，要么通过`bpf_rbtree_add`将其添加到`tree`中（示例中的`ACQUIRED`和`PASSED`注释分别表示“获得所有权”和“传递所有权”的语句）

验证器在所有权转移后应该如何处理`n`？如果对象通过`bpf_obj_drop`被`free`，答案显而易见：验证器应拒绝任何尝试在`bpf_obj_drop`后访问`n`的程序，因为对象已不再有效。底层内存可能已被重新用于其他分配、未映射等。
当通过`bpf_rbtree_add`将所有权传递给`tree`时，答案就不那么明显了。验证器可以执行与`bpf_obj_drop`相同的语义，但这将导致一些有用且常见的编程模式被拒绝，例如：

```c
int x;
struct node_data *n = bpf_obj_new(typeof(*n)); /* 获得所有权 */

bpf_spin_lock(&lock);

bpf_rbtree_add(&tree, n); /* 传递所有权 */
x = n->data;
n->data = 42;

bpf_spin_unlock(&lock);
```

对`n->data`的读写都将被拒绝。但是，验证器可以通过利用两个细节做得更好：

1. 图数据结构API只能在持有与图根相关的`bpf_spin_lock`时使用。

2. 所有图数据结构都具有指针稳定性。

   * 因为图节点是通过`bpf_obj_new`分配的，并且添加/删除根节点涉及调整节点结构的`bpf_{list,rb}_node`字段，因此无论执行哪种操作，图节点都将保持在同一地址。
由于任何添加或删除的程序都必须持有相关的`bpf_spin_lock`，如果我们处于该锁限定的关键区域，我们知道直到关键区域结束，没有其他程序可以添加或删除。
结合指针稳定性意味着，在关键区域结束之前，即使已经用`n`来传递所有权，我们也可以安全地通过`n`访问图节点。
验证器将此类引用视为*非所有权引用*。相应地，`bpf_obj_new`返回的引用被视为*所有权引用*。
这两个术语目前仅在图节点和API的上下文中有意义。
**详细信息**

让我们列举两种类型引用的属性。
*所有权引用*

  * 此引用控制所指对象的生命周期。

  * 必须通过将所指对象传递给某个图API内核函数或通过`bpf_obj_drop`（释放所指对象）来“释放”所指对象的所有权。

    * 如果在程序结束前未释放，则验证器认为程序无效。

  * 访问所指对象的内存不会导致分页错误。

*非所有权引用*

  * 此引用不拥有所指对象。

     * 它不能用于将图节点添加到图根，也不能通过`bpf_obj_drop`释放。

  * 没有明确的生命周期控制，但可以根据非所有权引用的存在推断出有效生命周期（参见下面的解释）。

  * 访问所指对象的内存不会导致分页错误。

从验证器的角度来看，非所有权引用只能存在于spin_lock和spin_unlock之间。为什么？在spin_unlock之后，另一个程序可以在数据结构上执行任意操作，如移除并通过bpf_obj_drop释放。对已被移除、通过bpf_obj_drop释放并经由bpf_obj_new重用的某段内存的非所有权引用，将指向一个完全不同的东西。
或者，内存可能消失。

为了避免这种逻辑违规，所有非拥有引用在关键部分结束后都会被验证器无效化。
这是确保非拥有引用“不会产生页面错误”属性所必需的。因此，如果验证器没有
使一个非拥有引用无效，访问它将不会产生页面错误。

目前，“bpf_obj_drop”不允许在关键部分中使用，所以
如果有有效的非拥有引用存在，我们一定处于关键部分内，并可以
得出结论，该引用的内存尚未被丢弃并`free`或
丢弃并重新使用。

对rbtree中的任何节点的引用_必须是非拥有的，因为
树控制着被引用对象的生命周期。同样地，对不在rbtree中的任何节点的引用_必须是拥有的。
这导致了一个很好的特性：
图API添加/删除实现无需检查节点是否已添加（或已删除），因为
所有权模型允许验证器仅通过类型检查来阻止此类状态的有效性。

然而，指针别名对上述“很好的特性”构成了一个问题。
考虑以下示例：

```c
struct node_data *n, *m, *o, *p;
n = bpf_obj_new(typeof(*n));     /* 1 */

bpf_spin_lock(&lock);

bpf_rbtree_add(&tree, n);        /* 2 */
m = bpf_rbtree_first(&tree);     /* 3 */

o = bpf_rbtree_remove(&tree, n); /* 4 */
p = bpf_rbtree_remove(&tree, m); /* 5 */

bpf_spin_unlock(&lock);

bpf_obj_drop(o);
bpf_obj_drop(p); /* 6 */
```

假设在程序运行前树是空的。如果我们用上述注释中的数字跟踪验证器状态变化：

  1) n是一个拥有引用

  2) n变成了非拥有引用，它已经被添加到树中

  3) n和m都是非拥有引用，它们都指向同一个节点

  4) o是一个拥有引用，n和m是非拥有引用，所有引用都指向同一个节点

  5) o和p是拥有引用，n和m是非拥有引用，所有引用都指向同一个节点

  6) 发生了双重释放，因为o和p指向同一个节点，而o在上一条语句中已被`free`处理

状态4和5违反了我们的“很好的特性”，因为存在指向不在rbtree中的节点的非拥有引用。第5条语句会尝试移除一个已经由于此违规而被移除的节点。状态6是一个危险的双重释放。

至少我们应该防止状态6成为可能。如果我们不能同时防止状态5，那么我们必须放弃我们的“很好的特性”，并在运行时检查节点是否已经被移除。

我们通过将“bpf_spin_unlock”的“使非拥有引用无效”行为泛化，并在“bpf_rbtree_remove”后执行类似的无效化来防止这两种情况。这里的逻辑是任何图形API kfunc，如果：

  * 接受任意节点参数

  * 从数据结构中移除它

  * 返回对移除节点的拥有引用

可能会导致其他某个非拥有引用指向同一个节点的状态。因此，“remove”类型的kfunc也必须被视为非拥有引用的无效化点。
