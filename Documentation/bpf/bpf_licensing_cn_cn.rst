BPF 许可证
==========

背景
====

* 经典 BPF 采用 BSD 许可

最初，“BPF”作为 BSD 数据包过滤技术的一部分在论文 http://www.tcpdump.org/papers/bpf-usenix93.pdf 中被提出。其中的指令集及其具体实现源自 BSD，且附带 BSD 许可协议。这一原始指令集如今被称为“经典 BPF”（Classic BPF 或 cBPF）。然而，指令集本质上是对机器语言交互的一种规范，类似编程语言，而非代码本身，因此在某些场景下将其视为受版权保护的对象并适用 BSD 许可或许会造成混淆。

* eBPF（扩展 BPF）指令集维持 BSD 许可状态

自2014年起，经典 BPF 的指令集经历了一次重大升级。为了区分新旧版本，我们通常将更新后的指令集称为 eBPF。值得注意的是，eBPF 指令集依然沿用 BSD 许可协议。

eBPF 的实现
===========

利用 eBPF 指令集，需要在内核空间和用户空间两方面进行代码的实施。

在 Linux 内核中
---------------

Linux 核心部分包含了 eBPF 解释器及各类即时编译器的参考实现，这些均遵循 GPLv2 许可协议。eBPF 辅助函数的实现同样受到 GPLv2 许可的约束。eBPF 解释器、即时编译器、辅助函数和验证器共同构成了所谓的 eBPF 运行时环境。

在用户空间
----------

除了内核空间的实现，还存在基于不同许可协议的 eBPF 运行时（包括解释器、即时编译器和辅助函数）实现，具体如下：

- Apache2 许可：https://github.com/iovisor/ubpf
- MIT 许可：https://github.com/qmonnet/rbpf
- BSD 许可：https://github.com/DPDK/dpdk/blob/main/lib/librte_bpf

在硬件中
--------

硬件制造商可以选择直接支持 eBPF 指令的原生执行，通过硬件提供 eBPF 运行时，或者借助专有许可的固件实现这一功能。

在其他操作系统中
------------------

针对非 Linux 系统，无论是内核还是用户空间，eBPF 指令集及运行时的实现可能采用专有许可。

在 Linux 内核中使用 BPF 程序
==============================

尽管 Linux 内核自身遵循 GPLv2 许可，但它允许私有内核模块根据特定规则与其链接。详细信息可参阅文档：
Documentation/process/license-rules.rst

加载内核模块时，Linux 内核会对计划调用的函数进行检查。若发现任何标记为“仅限 GPL”的函数，相应模块或程序需具备与 GPL 兼容的许可协议。将 BPF 程序加载至 Linux 内核的操作与加载内核模块相似，虽然 BPF 程序是在运行时动态加载而非静态链接至内核。加载 BPF 程序时，会遵循与内核模块相同的许可检查规则，这意味着 BPF 程序可以是私有的，只要它们不调用“仅限 GPL”的 BPF 辅助函数。

然而，某些类型的 BPF 程序，如 2021 年 8 月前的 Linux 安全模块（LSM）和 TCP 拥塞控制（struct_ops），即使不直接使用“仅限 GPL”的辅助函数，也必须与 GPL 兼容。LSM 和 TCP 拥塞控制模块的注册过程涉及 EXPORT_SYMBOL_GPL 内核函数，这实质上意味着 LSM 和 struct_ops 类型的 BPF 程序间接调用了“仅限 GPL”的函数。

对于直接调用内核函数的 BPF 程序（通过不稳定接口，即所谓的“kfunc”），同样适用上述限制。

将 BPF 程序与用户空间应用程序捆绑
======================================

一般而言，私有许可的应用程序与遵循 GPL 许可编写、用于 Linux 内核的 BPF 程序能够共存于同一软件包中，因为它们被视为独立的可执行实体。这一点对 cBPF 和 eBPF 程序同样适用。

需要注意的是，尽管 BPF 程序与内核紧密关联，但当它们作为独立的可执行实体存在时，与用户空间应用程序捆绑并不会触犯 GPL 的传播条件。这是因为 BPF 程序与用户空间应用程序在运行时是分离的，各自拥有独立的地址空间和资源。因此，只要 BPF 程序本身遵守其许可条款，它就能与任何许可类型的应用程序一同打包和分发。然而，如果 BPF 程序调用了“仅限 GPL”的内核功能或接口，则整个程序或应用可能需要遵循 GPL 协议，以确保与内核的兼容性。
