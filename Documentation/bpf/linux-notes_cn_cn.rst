### Linux 实现说明

#### 字节交换指令

`BPF_FROM_LE` 和 `BPF_FROM_BE` 指令作为 `BPF_TO_LE` 和 `BPF_TO_BE` 的同义词存在，用于处理字节序转换。

#### 跳转指令

`BPF_CALL | BPF_X | BPF_JMP`（0x8d）跳转指令，其辅助函数的整数参数从指定的寄存器读取，目前不被验证器支持。含有这类指令的程序，在相应支持未添加前，将无法加载。

#### 映射表

Linux 仅支持在单元素数组映射上进行 'map_val(map)' 操作。它使用 `fd_array` 存储与 BPF 程序相关的映射表，因此 `map_by_idx(imm)` 使用数组在该索引处的文件描述符。

#### 变量

64位立即数指令 `BPF_IMM | BPF_DW | BPF_LD`（0x18, 0x3）指定应加载的变量地址，该地址对应于 'imm' 字段中存储的整数，代表变量标识，目标为数据指针。在 Linux 上，这个整数是一个 BTF ID。

#### 传统 BPF 包访问指令

为了保持在 eBPF 解释器中运行的传统套接字过滤器的性能，Linux 设计了一组特殊 eBPF 指令用于访问包数据，这些指令源自传统 BPF。

- `BPF_ABS | <size> | BPF_LD` 和 `BPF_IND | <size> | BPF_LD` 用于访问包数据，只能在程序上下文为指向网络包的指针时使用。
- `BPF_ABS` 访问由立即数指定的绝对偏移处的包数据；`BPF_IND` 访问由寄存器值和立即数共同确定的偏移处的包数据。

这些指令有七项隐含操作数：
- 寄存器 R6 必须包含指向 `struct sk_buff` 的指针；
- 寄存器 R0 是隐含输出寄存器，存储从数据包中读取的数据；
- 寄存器 R1 至 R5 是临时寄存器，可能被指令覆盖。

此外，存在隐含的程序退出条件：如果 eBPF 程序尝试访问超出数据包边界的额外数据，则程序执行会终止。

`BPF_ABS | BPF_W | BPF_LD`（0x20）表示：
  R0 = ntohl(*(u32 *) ((struct sk_buff *) R6->data + imm))

`BPF_IND | BPF_W | BPF_LD`（0x40）表示：
  R0 = ntohl(*(u32 *) ((struct sk_buff *) R6->data + src + imm))

其中 `ntohl()` 函数用于将32位数值从网络字节序转换为主机字节序，而 `src` 可能是指寄存器中的值，与立即数 `imm` 相加形成最终的内存地址。
