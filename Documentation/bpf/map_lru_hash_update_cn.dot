以下是给定代码段的中文翻译：

```
// SPDX 许可证标识符：GPL-2.0-only
// 版权所有 (C) 2022-2023 Isovalent, Inc.
digraph {
  节点 [颜色方案=accent4,样式=填充] # 将颜色方案应用于所有节点
  图形 [样条线=正交,节点间隔=1]

  子图集群 key {
    标签 = "键\n（操作期间持有的锁）";
    排列方向 = TB;

    远程锁 [形状=矩形,填充色=4,标签="远程 CPU LRU 锁"]
    哈希锁 [形状=矩形,填充色=3,标签="哈希表锁"]
    LRU锁 [形状=矩形,填充色=2,标签="LRU 锁"]
    本地锁 [形状=矩形,填充色=1,标签="本地 CPU LRU 锁"]
    无锁 [形状=矩形,标签="没有持有任何锁"]
  }

  开始 [形状=椭圆,标签="开始\nbpf_map_update()"]

  // 带有'fn_'前缀的节点大致按照触发内核/bpf/bpf_lru_list.c中对应逻辑的C函数名命名。
// 数字后缀和errno后缀处理该函数编写时对应的逻辑子部分。
// 参见 __local_list_pop_free() / bpf_percpu_lru_pop_free()
  本地空闲列表检查 [形状=菱形,填充色=1,
    标签="本地空闲列表\n节点可用？"];
  使用本地节点 [形状=矩形,
    标签="使用由\n此CPU拥有的节点"]

  // 参见 bpf_lru_pop_free()
  公共LRU检查 [形状=菱形,
    标签="带有公共\nLRU创建的映射？\n(!BPF_F_NO_COMMON_LRU)"];

  函数_bpf_lru_list_pop_free_to_local [形状=矩形,填充色=2,
    标签="刷新本地待处理,\n旋转全局列表,移动\nLOCAL_FREE_TARGET\n从全局 -> 本地"]
  // 同时对应：
  // 函数__local_list_flush()
  // 函数bpf_lru_list_rotate()
  函数___bpf_lru_node_move_to_free[形状=菱形,填充色=2,
    标签="能够释放\nLOCAL_FREE_TARGET\n节点？"]

  函数___bpf_lru_list_shrink_inactive [形状=矩形,填充色=3,
    标签="缩小非活动列表\n最多剩余\nLOCAL_FREE_TARGET\n(全局 LRU -> 本地)"]
  函数___bpf_lru_list_shrink [形状=菱形,填充色=2,
    标签="> 0 项在\n本地空闲列表？"]
  函数___bpf_lru_list_shrink2 [形状=矩形,填充色=2,
    标签="从非活动项中窃取一个节点，或如果为空，\n从全局活动列表中窃取"]
  函数___bpf_lru_list_shrink3 [形状=矩形,填充色=3,
    标签="尝试从哈希表中移除\n节点"]

  本地空闲列表检查2 [形状=菱形,标签="哈希表移除\n成功？"]
  公共LRU检查2 [形状=菱形,
    标签="带有公共\nLRU创建的映射？\n(!BPF_F_NO_COMMON_LRU)"];

  子图集群 remote_lock {
    标签 = "遍历CPU\n（从当前开始）";
    样式 = 点划线;
    排列方向=LR;

    本地空闲列表检查5 [形状=菱形,填充色=4,
      标签="从每个CPU的\n空闲列表中窃取节点？"]
    本地空闲列表检查6 [形状=矩形,填充色=4,
      标签="从\n(1)未引用的待处理，或\n(2)任意待处理节点中窃取"]
    本地空闲列表检查7 [形状=矩形,填充色=3,
      标签="尝试从哈希表中移除\n节点"]
    函数_htab_lru_map_update_elem [形状=菱形,
      标签="从远程\nCPU中窃取了节点？"]
    函数_htab_lru_map_update_elem2 [形状=菱形,标签="遍历\n所有CPU？"]
    // 同时对应：
    // 使用本地节点()
    // 函数__local_list_pop_pending()
  }

  函数_bpf_lru_list_pop_free_to_local2 [形状=矩形,
    标签="使用未被\n近期引用的节点"]
  本地空闲列表检查4 [形状=矩形,
    标签="使用被\n积极引用的节点\n在全局列表中"]
  函数_htab_lru_map_update_elem_ENOMEM [形状=椭圆,标签="返回 -ENOMEM"]
  函数_htab_lru_map_update_elem3 [形状=矩形,
    标签="使用被\n积极引用的节点\n在（另一个？）CPU的缓存中"]
  函数_htab_lru_map_update_elem4 [形状=矩形,填充色=3,
    标签="更新哈希表\n与新元素"]
  函数_htab_lru_map_update_elem5 [形状=椭圆,标签="返回 0"]
  函数_htab_lru_map_update_elem_EBUSY [形状=椭圆,标签="返回 -EBUSY"]
  函数_htab_lru_map_update_elem_EEXIST [形状=椭圆,标签="返回 -EEXIST"]
  函数_htab_lru_map_update_elem_ENOENT [形状=椭圆,标签="返回 -ENOENT"]

  开始 -> 本地空闲列表检查
  本地空闲列表检查 -> 使用本地节点 [边标签="Y"]
  本地空闲列表检查 -> 公共LRU检查 [边标签="N"]
  公共LRU检查 -> 函数_bpf_lru_list_pop_free_to_local [边标签="Y"]
  公共LRU检查 -> 函数___bpf_lru_list_shrink_inactive [边标签="N"]
  函数_bpf_lru_list_pop_free_to_local -> 函数___bpf_lru_node_move_to_free
  函数___bpf_lru_node_move_to_free ->
    函数_bpf_lru_list_pop_free_to_local2 [边标签="Y"]
  函数___bpf_lru_node_move_to_free ->
    函数___bpf_lru_list_shrink_inactive [边标签="N"]
  函数___bpf_lru_list_shrink_inactive -> 函数___bpf_lru_list_shrink
  函数___bpf_lru_list_shrink -> 函数_bpf_lru_list_pop_free_to_local2 [边标签 = "Y"]
  函数___bpf_lru_list_shrink -> 函数___bpf_lru_list_shrink2 [边标签="N"]
  函数___bpf_lru_list_shrink2 -> 函数___bpf_lru_list_shrink3
  函数___bpf_lru_list_shrink3 -> 本地空闲列表检查2
  本地空闲列表检查2 -> 本地空闲列表检查4 [边标签 = "Y"]
  本地空闲列表检查2 -> 公共LRU检查2 [边标签 = "N"]
  公共LRU检查2 -> 本地空闲列表检查5 [边标签 = "Y"]
  公共LRU检查2 -> 函数_htab_lru_map_update_elem_ENOMEM [边标签 = "N"]
  本地空闲列表检查5 -> 函数_htab_lru_map_update_elem [边标签 = "Y"]
  本地空闲列表检查5 -> 本地空闲列表检查6 [边标签 = "N"]
  本地空闲列表检查6 -> 本地空闲列表检查7
  本地空闲列表检查7 -> 函数_htab_lru_map_update_elem

  函数_htab_lru_map_update_elem -> 函数_htab_lru_map_update_elem3 [边标签 = "Y"]
  函数_htab_lru_map_update_elem -> 函数_htab_lru_map_update_elem2  [边标签 = "N"]
  函数_htab_lru_map_update_elem2 ->
    函数_htab_lru_map_update_elem_ENOMEM [边标签 = "Y"]
  函数_htab_lru_map_update_elem2 -> 本地空闲列表检查5 [边标签 = "N"]
  函数_htab_lru_map_update_elem3 -> 函数_htab_lru_map_update_elem4

  使用本地节点 -> 函数_htab_lru_map_update_elem4
  函数_bpf_lru_list_pop_free_to_local2 -> 函数_htab_lru_map_update_elem4
  本地空闲列表检查4 -> 函数_htab
