BPF 许可证
==========

背景
====

* 经典 BPF 是 BSD 许可的

"BPF" 最初作为 BSD 数据包过滤器在 http://www.tcpdump.org/papers/bpf-usenix93.pdf 中引入。相应的指令集及其实现来源于 BSD，并带有 BSD 许可。这个原始的指令集现在被称为“经典 BPF”。
然而，指令集是一种机器语言交互的规范，类似于编程语言。它不是代码。因此，在特定上下文中应用 BSD 许可可能会产生误导，因为指令集可能不受版权保护。
* eBPF（扩展 BPF）指令集继续为 BSD 许可

2014 年，经典 BPF 指令集得到了显著扩展。我们通常将此指令集称为 eBPF，以区别于 cBPF。
eBPF 指令集仍然是 BSD 许可的。

eBPF 的实现
===========

使用 eBPF 指令集需要在内核空间和用户空间中实现代码。

在 Linux 内核中
---------------

eBPF 解释器和各种即时编译器的参考实现是 Linux 的一部分，且是 GPLv2 许可的。eBPF 辅助函数的实现也是 GPLv2 许可的。解释器、JIT 编译器、辅助函数和验证器统称为 eBPF 运行时。

在用户空间
----------

还有根据
Apache2 (https://github.com/iovisor/ubpf),
MIT (https://github.com/qmonnet/rbpf)，以及
BSD (https://github.com/DPDK/dpdk/blob/main/lib/librte_bpf)
许可的 eBPF 运行时（解释器、JIT 编译器、辅助函数）的实现。

在硬件中
--------

硬件可以选择原生执行 eBPF 指令，并通过硬件提供 eBPF 运行时，或通过使用具有专有许可的固件实现。

在其他操作系统中
------------------

其他内核或用户空间的 eBPF 指令集和运行时的实现可以有专有许可。

在 Linux 内核中使用 BPF 程序
==============================

Linux 内核（尽管是 GPLv2）允许根据以下规则链接专有内核模块：
Documentation/process/license-rules.rst

当加载内核模块时，Linux 内核会检查它打算使用的函数。如果任何函数标记为“仅 GPL”，则相应的模块或程序必须具有与 GPL 兼容的许可。
将BPF程序加载到Linux内核中类似于加载内核模块。BPF在运行时加载，而不是静态链接到Linux内核。BPF程序的加载遵循与内核模块相同的许可证检查规则。BPF程序可以是专有的，只要它们不使用“仅GPL”的BPF辅助函数。

进一步地，一些类型的BPF程序——截至2021年8月的Linux安全模块（LSM）和TCP拥塞控制（struct_ops）——即使它们没有直接使用“仅GPL”辅助函数，也必须与GPL兼容。LSM和TCP拥塞控制模块的注册步骤通过EXPORT_SYMBOL_GPL内核函数完成。从这个意义上说，LSM和struct_ops BPF程序隐式调用了“仅GPL”的函数。

同样的限制也适用于通过不稳定接口直接调用内核函数的BPF程序，这种接口也被称为"kfunc"。

将BPF程序与用户空间应用程序一起打包
======================================

通常，专有许可的应用程序和为Linux内核编写的GPL许可的BPF程序可以在同一个包中共存，因为它们是独立的可执行进程。这适用于cBPF和eBPF程序。

请注意，尽管BPF程序可能与内核紧密相关，但当它们作为一个单独的可执行实体存在时，与用户空间应用程序一起打包并不会违反GPL的传播条件。这是因为BPF程序和用户空间应用程序在执行时是分开的，每个都有自己的地址空间和资源。因此，只要BPF程序本身遵守其许可要求，它就可以与任何许可类型的应用程序一起打包和分发。然而，如果BPF程序调用了"仅GPL"的内核功能或接口，则整个程序或应用可能需要遵守GPL，以保持与内核的兼容性。
