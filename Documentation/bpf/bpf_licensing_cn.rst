============= 
BPF 许可证
=============

背景
==========

* 经典 BPF 使用 BSD 许可证

"BPF" 最初作为 BSD 包过滤器在 http://www.tcpdump.org/papers/bpf-usenix93.pdf 中引入。相应的指令集及其实现来自 BSD 并带有 BSD 许可证。该原始的指令集现在被称为“经典 BPF”。
然而，指令集是一种用于机器语言交互的规范，类似于一种编程语言。它不是代码。因此，在某些情况下应用 BSD 许可证可能会产生误导，因为指令集可能不受版权保护。
* eBPF（扩展 BPF）指令集继续使用 BSD 许可

2014 年，经典 BPF 指令集得到了显著扩展。我们通常称这种指令集为 eBPF 以与 cBPF 区分。
eBPF 指令集仍然是 BSD 许可的。

eBPF 的实现
=====================

使用 eBPF 指令集需要在内核空间和用户空间中实现代码。

在 Linux 内核中
---------------

eBPF 解释器和各种即时编译器的参考实现是 Linux 的一部分，并且采用 GPLv2 许可。eBPF 辅助函数的实现也是 GPLv2 许可的。解释器、即时编译器、辅助函数以及验证器统称为 eBPF 运行时。

在用户空间
--------------

还有一些在 Apache2 (https://github.com/iovisor/ubpf)、MIT (https://github.com/qmonnet/rbpf) 和 BSD (https://github.com/DPDK/dpdk/blob/main/lib/librte_bpf) 许可下的 eBPF 运行时（解释器、即时编译器、辅助函数）的实现。

在硬件中
--------

硬件可以选择直接执行 eBPF 指令，并通过硬件提供 eBPF 运行时或通过使用专有许可的固件来实现。

在其他操作系统中
-------------------

其他内核或用户空间中的 eBPF 指令集和运行时的实现可以采用专有许可证。

在 Linux 内核中使用 BPF 程序
==================================

Linux 内核（虽然使用 GPLv2）允许根据以下规则链接专有内核模块：
Documentation/process/license-rules.rst

当加载一个内核模块时，Linux 内核会检查它打算使用的函数。如果任何函数被标记为“仅 GPL”，则对应的模块或程序必须具有与 GPL 兼容的许可证。
将BPF程序加载到Linux内核中类似于加载内核模块。BPF是在运行时加载的，而不是静态链接到Linux内核中的。BPF程序的加载遵循与内核模块相同的许可检查规则。BPF程序可以是专有的，只要它们不使用“仅GPL”的BPF辅助函数。
此外，截至2021年8月，某些类型的BPF程序—Linux安全模块（LSM）和TCP拥塞控制（struct_ops）—即使它们没有直接使用“仅GPL”的辅助函数，也要求必须与GPL兼容。LSM和TCP拥塞控制模块在Linux内核中的注册步骤是通过EXPORT_SYMBOL_GPL内核函数完成的。从这个意义上说，LSM和struct_ops BPF程序间接调用了“仅GPL”的函数。
同样的限制也适用于通过不稳定接口直接调用内核函数的BPF程序，这种接口也被称为"kfunc"。

与用户空间应用程序一起打包BPF程序
=====================================

通常情况下，专有许可的应用程序和为Linux内核编写的GPL许可的BPF程序可以在同一个包中共存，因为它们是独立的可执行进程。这适用于cBPF和eBPF程序。
