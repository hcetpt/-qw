BPF 设计问答
==============

BPF 的可扩展性和在网络、追踪、安全领域的适用性，无论是在 Linux 内核还是多种用户空间实现的 BPF 虚拟机中，都导致了一些对于 BPF 实际含义的误解。这份简短的问答尝试解决这些问题，并概述 BPF 长期的发展方向。

.. contents::
    :local:
    :depth: 3

问题与解答
=====================

问：BPF 是类似于 x64 和 arm64 的通用指令集吗？
-------------------------------------------------------------
答：不是。

问：BPF 是一个通用虚拟机吗？
-------------------------------------
答：不是。
BPF 是一个带有 C 调用约定的通用指令集
-----------------------------------------------------------

问：为什么选择了 C 调用约定？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

答：因为 BPF 程序设计用于在 Linux 内核中运行，而 Linux 内核是用 C 语言编写的，因此 BPF 定义了一个与最常用的两种架构 x64 和 arm64 兼容的指令集（并考虑了其他架构的重要特性），同时定义了一个与这些架构上的 Linux 内核 C 调用约定兼容的调用约定。
问：未来是否可以支持多个返回值？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
答：不可以。BPF 只允许使用寄存器 R0 作为返回值。
问：未来是否可以支持超过 5 个函数参数？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
答：不可以。BPF 调用约定只允许寄存器 R1-R5 作为参数使用。BPF 并不是一个独立的指令集（与 x64 ISA 不同，后者允许使用 msft、cdecl 等其他约定）。

问：BPF 程序能否访问指令指针或返回地址？
-----------------------------------------------------------------
答：不可以。
问：BPF 程序能否访问栈指针？
------------------------------------------
答：不可以。
仅能访问帧指针（寄存器R10）
从编译器的角度来看，拥有栈指针是必要的。
例如，LLVM在其BPF后端定义了寄存器R11作为栈指针，但它确保生成的代码从不使用它。
问：C调用约定是否减少了可能的应用场景？
-------------------------------------------------
答：是的
BPF设计迫使添加主要功能，形式如内核辅助函数和内核对象，如BPF映射，并在它们之间实现无缝互操作。它允许内核调用BPF程序，程序调用内核辅助函数，且没有额外开销，就像它们都是原生C代码一样。这尤其适用于JIT编译的BPF程序，它们与原生内核C代码无异。
问：这意味着对BPF代码的“创新”扩展被禁止了吗？
-------------------------------------------------------------------
答：温和的说是这样
至少目前如此，直到BPF核心支持BPF到BPF调用、间接调用、循环、全局变量、跳转表、只读段落，以及C代码可以产生的所有其他正常结构。
问：能否以安全的方式支持循环？
-----------------------------------------
答：目前还不清楚
BPF开发者正在尝试找到一种方法来支持有界循环。
问：验证器有哪些限制？
----------------------------
答：用户空间唯一已知的限制是BPF_MAXINSNS（4096）。
这是非特权bpf程序可以拥有的最大指令数量。验证器有各种内部限制，
例如在程序分析过程中可以探索的最大指令数量。目前，这个限制设置为100万，
这实际上意味着最大的程序可以由100万条NOP指令组成。对连续分支的最大数量有限制，
对嵌套的bpf到bpf调用的数量有限制，每条指令的验证器状态数量有限制，
对程序使用的映射(map)数量有限制。
所有这些限制都可以通过足够复杂的程序达到。
还有非数字型的限制，可能导致程序被拒绝。
验证器过去只识别指针+常量表达式。现在它可以识别指针+bpf边界寄存器表达式。
bpf_lookup_map_elem(key)曾经要求'key'必须是指向栈的指针。现在，'key'可以是指向映射值的指针。
验证器正在稳步地变得更“智能”。限制正在被移除。
唯一确定程序将被验证器接受的方法是尝试加载它。
bpf开发过程保证未来的内核版本将接受所有先前版本接受的bpf程序。

指令级别问题
--------------

问：LD_ABS和LD_IND指令与C代码的关系
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

问：为什么BPF中存在LD_ABS和LD_IND指令，而C代码无法表达它们，必须使用内置的内在函数？

答：这是与经典BPF兼容性的遗留问题。现代网络代码在BPF中不使用它们时性能更好。
参见“直接数据包访问”。
Q: BPF指令与原生CPU的映射并非一对一
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Q: 看起来并非所有BPF指令都能一对一映射到原生CPU上
例如，为什么BPF_JNE和其他比较与跳转指令不像CPU那样？

A: 这是为了避免在ISA中引入标志位，这些标志位在跨CPU架构时难以做到既通用又高效。

Q: 为何BPF_DIV指令不映射到x64的div？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A: 如果我们选择将BPF与x64做一对一映射，这会使得arm64和其他架构的支持变得更加复杂。同时它需要运行时检查除以零的情况。

Q: 为什么BPF有隐式的序言和尾声？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A: 因为像sparc这样的架构有寄存器窗口，并且一般来说，不同架构之间存在足够多的微妙差异，因此简单地将返回地址存储到栈中是行不通的。另一个原因是BPF必须防止除以零（以及LD_ABS指令的遗留异常路径）。这些指令需要调用尾声并隐式返回。

Q: 为何一开始没有引入BPF_JLT和BPF_JLE指令？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A: 因为经典BPF中并没有它们，而BPF的作者认为编译器的变通方法是可以接受的。结果证明，由于缺乏这些比较指令，程序性能有所下降，因此后来增加了这两个指令。
这两个指令完美地说明了未来可以接受并添加到BPF中的新指令类型。这两种指令在原生CPU中已经有了等效的指令。
没有一对一映射到硬件指令的新指令将不会被接受。

Q: BPF 32位子寄存器需求
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Q: BPF 32位子寄存器有一个要求，即需要清零BPF寄存器的上部32位，这使得BPF对于32位CPU架构和32位硬件加速器来说效率低下。未来是否可以向BPF添加真正的32位寄存器？

A: 不可以。
但是，有一些优化措施可用于减少BPF寄存器上部32位清零的操作，这些优化可以用来提高32位架构下JIT编译的BPF程序的性能。
从版本7开始，LLVM能够生成操作32位子寄存器的指令，前提是为编译程序传递选项-mattr=+alu32。此外，验证器现在可以标记那些需要将目标寄存器的高阶位清零的指令，并插入一个显式的零扩展（zext）指令（mov32的一种变体）。这意味着对于没有硬件支持zext的架构，JIT后端不需要清除由alu32指令或窄加载写入的子寄存器的高阶位。相反，后端只需要支持该mov32变体的代码生成，并重写bpf_jit_needs_zext()函数使其返回"true"（以便在验证器中启用zext插入）。

请注意，JIT后端可能有部分硬件支持zext。在这种情况下，如果启用了验证器的zext插入，可能会导致不必要的zext指令被插入。这样的指令可以通过在JIT后端内部创建一个简单的窥孔来移除：如果一条指令具有硬件支持的zext，并且下一条指令是显式的zext，则在进行代码生成时可以跳过后者。

问：BPF是否有稳定的ABI？
答：是的。BPF指令、BPF程序的参数、辅助函数及其参数、识别的返回码都是ABI的一部分。但是，有一个特定的例外，即使用如bpf_probe_read()等辅助函数遍历内核内部数据结构并使用内核内部头文件编译的追踪程序。这两种内核内部细节都可能发生变化，因此可能需要随着新内核的出现而相应地调整程序。

新的BPF功能通常通过使用kfuncs而不是新辅助函数来添加。Kfuncs不被视为稳定API的一部分，并且有自己的生命周期预期，如在:BPF_kfunc_lifecycle_expectations:中所述。

问：tracepoints是否是稳定ABI的一部分？
答：不是。Tracepoints与内部实现细节相关，因此它们可能会随着新内核的变化而变化。当这种情况发生时，BPF程序需要相应地更改。

问：kprobes可以附加的位置是否是稳定ABI的一部分？
答：不是。kprobes可以附加的位置是内部实现细节，这意味着它们可能会随着新内核的变化而变化。当这种情况发生时，BPF程序需要相应地更改。

问：BPF程序使用多少栈空间？
答：目前所有程序类型都被限制在512字节的栈空间内，但验证器会计算实际使用的栈空间量，而且解释器和大多数JIT代码都会消耗必要的量。

问：BPF能否卸载到硬件上？
答：是的。NFP驱动程序支持BPF硬件卸载。

问：经典BPF解释器是否仍然存在？
答：不是。经典BPF程序会被转换为扩展BPF指令。

问：BPF是否可以调用任意的内核函数？
答：不是。BPF程序只能调用作为BPF辅助函数或kfuncs暴露的特定函数。每种程序类型可用的函数集都有定义。
Q: BPF能否覆盖任意内核内存？
-------------------------------
A: 不可以
追踪型BPF程序可以使用bpf_probe_read()和bpf_probe_read_str()辅助函数读取任意内存。网络程序不能读取任意内存，因为它们无法访问这些辅助函数。
程序永远不能直接读写任意内存。

Q: BPF能否覆盖任意用户空间内存？
-------------------------------
A: 在某种程度上可以
追踪型BPF程序可以使用bpf_probe_write_user()覆盖当前任务的用户空间内存。每当加载此类程序时，内核都会打印警告信息，因此这个辅助函数仅适用于实验和原型开发。
追踪型BPF程序仅限root权限使用。

Q: 通过内核模块添加新功能？
---------------------------
Q: BPF的功能如新的程序或映射类型、新的辅助函数等，是否可以通过内核模块代码外的方式添加？

A: 可以，通过kfuncs和kptrs

核心BPF功能如程序类型、映射和辅助函数不能通过模块扩展。但是，模块可以通过导出kfuncs（可能返回指向模块内部数据结构的kptrs）向BPF程序暴露功能。

Q: 直接调用内核函数是一种ABI吗？
------------------------------
Q: 某些内核函数（例如tcp_slow_start）可被BPF程序调用。这些内核函数是否变成了一种ABI？

A: 不是
内核函数原型可能会改变，BPF程序将被验证器拒绝。例如，一些可被BPF调用的内核函数已经被其他内核tcp拥塞控制(cc)实现使用。如果这些内核函数有任何更改，树内和树外的内核tcp cc实现都必须相应更改。对于BPF程序来说也是如此，它们必须相应地进行调整。详细信息请参见 :ref:`BPF_kfunc_lifecycle_expectations`

Q: 附加到任意内核函数是一种ABI吗？
-----------------------------
Q: BPF程序可以附加到许多内核函数上。这些内核函数是否成为ABI的一部分？

A: 不是
### 内核函数原型将发生变化，附着在其上的BPF程序也需要进行更改。为了更容易地使您的BPF程序适应不同版本的内核，应使用BPF一次编译到处运行（CO-RE）。

**问题：** 标记了一个函数为BTF_ID是否使得该函数成为ABI的一部分？
--------------------------------------------------------------
**回答：** 不是。
BTF_ID宏并不会让一个函数成为ABI的一部分，这与EXPORT_SYMBOL_GPL宏的作用类似。

**问题：** 对于映射值中的特殊BPF类型，兼容性如何？
-----------------------------------------------------------------------

**问题：** 用户被允许在他们的BPF映射值中嵌入bpf_spin_lock、bpf_timer字段（当使用BTF支持的BPF映射时）。这允许在映射值内部的这些字段上使用相应的辅助函数。用户也被允许嵌入指向某些内核类型的指针（带有__kptr_untrusted和__kptr BTF标签）。内核是否会保留这些特性的向后兼容性？

**回答：** 这取决于具体情况。对于bpf_spin_lock和bpf_timer：是的；对于kptr和其他一切：不是，但请看下面的解释。
对于已经添加的结构类型，如bpf_spin_lock和bpf_timer，内核将保留向后兼容性，因为它们是UAPI的一部分。
对于kptrs，它们也是UAPI的一部分，但仅限于kptr机制本身。您可以使用__kptr_untrusted和__kptr标记的指针在结构中使用的类型并不属于UAPI合同的一部分。这些支持的类型会在不同的内核版本间发生变化。然而，对于支持的类型来说，访问kptr字段以及bpf_kptr_xchg()辅助函数等操作将在不同的内核版本间得到持续支持。
对于任何其他支持的结构类型，除非在本文档中明确说明并添加到bpf.h UAPI头文件中，这些类型可以在不同的内核版本间任意改变其大小、类型、对齐方式或任何其他用户可见的API或ABI细节。用户必须根据新的变化调整自己的BPF程序，并更新它们以确保程序能够继续正确运行。

**注释：** BPF子系统特别保留了'bpf_'前缀用于类型名称，以便将来引入更多的特殊字段。因此，用户程序必须避免定义以'bpf_'开头的类型，以免在未来版本中出现问题。
换句话说，如果使用了带有'bpf_'前缀的BTF中的类型，则不保证向后兼容性。

**问题：** 对于分配的对象中的特殊BPF类型，兼容性如何？
-----------------------------------------------------------------------------
**问题：** 同上，但对于分配的对象（即使用bpf_obj_new为用户定义的类型分配的对象）。内核是否会保留这些特性的向后兼容性？

**回答：** 不会。
与映射值类型不同，用于处理已分配对象的API以及对它们内部任何特殊字段的支持是通过kfuncs暴露的，因此具有与kfuncs本身相同的生命周期预期。详细信息请参阅 :ref:`BPF_kfunc_lifecycle_expectations`。

这句话的意思是，在BPF（Berkeley Packet Filter）编程中，对于已分配的对象和它们内部可能存在的特殊字段的处理，其相关的API和支持都是通过kfuncs（内核函数）提供的。这意味着这些功能的生命周期管理要遵循kfuncs的生命周期规则，具体细节可以参考文档中关于BPF_kfunc_lifecycle_expectations的部分。在BPF中，kfuncs提供了与内核交互的能力，使得用户可以在eBPF程序中调用内核代码，但这种调用和使用需要遵循一定的规则，以确保程序的稳定性和资源的正确管理。
