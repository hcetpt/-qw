BPF 设计问答
==============

BPF 的可扩展性和在网络、追踪、安全领域的适用性，无论是在 Linux 内核还是多种用户空间实现的 BPF 虚拟机中，都导致了一些对于 BPF 实际含义的误解。这份简短的问答尝试解决这些问题，并概述 BPF 长期的发展方向。

.. contents::
    :local:
    :depth: 3

问题与解答
=====================

问：BPF 是类似于 x64 和 arm64 的通用指令集吗？
-------------------------------------------------------------
答：不是。

问：BPF 是一个通用虚拟机吗？
-------------------------------------
答：不是。
BPF 是一个带有 C 调用约定的通用指令集
-----------------------------------------------------------

问：为什么选择了 C 调用约定？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

答：因为 BPF 程序设计用于在 Linux 内核中运行，而 Linux 内核是用 C 语言编写的，因此 BPF 定义了一个与最常用的两种架构 x64 和 arm64 兼容的指令集（并考虑了其他架构的重要特性），同时定义了一个与这些架构上的 Linux 内核 C 调用约定兼容的调用约定。
问：未来是否可以支持多个返回值？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
答：不可以。BPF 只允许使用寄存器 R0 作为返回值。
问：未来是否可以支持超过 5 个函数参数？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
答：不可以。BPF 调用约定只允许寄存器 R1-R5 作为参数使用。BPF 并不是一个独立的指令集（与 x64 ISA 不同，后者允许使用 msft、cdecl 等其他约定）。

问：BPF 程序能否访问指令指针或返回地址？
-----------------------------------------------------------------
答：不可以。
问：BPF 程序能否访问栈指针？
------------------------------------------
答：不可以。
仅能访问帧指针（寄存器R10）
从编译器的角度来看，需要有栈指针。
例如，在其BPF后端中，LLVM将寄存器R11定义为栈指针，但它确保生成的代码从不使用它。
问：C调用约定是否减少了可能的应用场景？
答：是的
BPF的设计迫使添加主要功能的形式，如内核辅助函数和内核对象如BPF映射，并且它们之间可以无缝互操作。这让内核能够调用BPF程序，而程序也可以调用内核辅助函数，没有任何开销，就像它们都是原生C代码一样。这一点尤其适用于通过JIT编译的BPF程序，这些程序与原生内核C代码无法区分。
问：这意味着对BPF代码的“创新”扩展被禁止了吗？
答：某种程度上是的
至少目前如此，直到BPF核心支持BPF到BPF调用、间接调用、循环、全局变量、跳转表、只读部分以及C代码可以产生的所有其他正常结构。
问：能否以安全的方式支持循环？
答：目前还不清楚
BPF开发者正在尝试找到一种支持有限循环的方法。
问：验证器有什么限制？
答：用户空间所知的唯一限制是BPF_MAXINSNS（4096）。
这是BPF非特权程序可以拥有的最大指令数量。验证器有各种内部限制，
例如在程序分析过程中可以探索的最大指令数。目前，这个限制设置为100万，
这实际上意味着最大的程序可以由100万个空操作（NOP）指令组成。还有对连续分支的最大数量的限制、
对嵌套BPF到BPF调用的数量的限制、每个指令的验证器状态的数量的限制、
以及程序使用映射的数量的限制。
所有这些限制都可能在一个足够复杂的程序中达到。
还有一些非数值型的限制可能导致程序被拒绝。验证器过去只识别指针+常量表达式。
现在它可以识别指针+有界寄存器表达式。
bpf_lookup_map_elem(key)曾有一个要求，即'key'必须是指向栈的指针。现在，'key'可以是指向映射值的指针。
验证器正逐渐变得更“智能”。这些限制正在被移除。
唯一确定程序会被验证器接受的方法就是尝试加载它。
BPF开发过程保证了未来的内核版本将接受所有先前版本接受的BPF程序。

指令级别问题
--------------

**问：**LD_ABS 和 LD_IND 指令与C代码的关系是什么？
**答：**这是为了与经典BPF兼容而存在的特性。现代BPF中的网络代码在没有它们的情况下表现得更好。
请参阅“直接数据包访问”。

**问：**为什么BPF中有LD_ABS和LD_IND指令，而C代码不能直接表达它们，必须使用内置的内在函数？
**答：**这是为了与传统BPF保持兼容性的遗留问题。现代BPF网络代码在不使用这些指令时性能更佳。
参见“直接数据包访问”。
Q: BPF指令与原生CPU指令并非一一对应
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Q: 看起来并非所有的BPF指令都能与原生CPU指令一一对应
例如，为什么BPF_JNE和其他比较与跳转指令不像CPU那样？

A: 这是为了避免在ISA中引入标志位，这些标志位对于跨CPU架构来说既难以通用又难以高效处理。

Q: 为什么BPF_DIV指令没有映射到x64的div？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A: 如果我们选择将BPF与x64进行一一对应，那么这将会使arm64和其他架构的支持变得更加复杂。此外，它还需要运行时检查除以零的情况。

Q: 为什么BPF有隐式的序言和尾声？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A: 因为像sparc这样的架构具有寄存器窗口，并且一般来说，不同架构之间存在足够多的微妙差异，因此简单地将返回地址存储到栈中是行不通的。另一个原因是BPF需要防止除以零（以及LD_ABS指令的遗留异常路径）。这些指令需要调用尾声并隐式返回。

Q: 为什么一开始没有引入BPF_JLT和BPF_JLE指令？
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A: 因为经典BPF中并没有它们，而BPF的作者认为编译器的变通方法是可以接受的。结果发现，由于缺乏这些比较指令，程序性能有所下降，因此后来增加了这两个指令。
这两个指令是未来可以接受和添加的新BPF指令的一个完美例子，因为它们已经在原生CPU中有等效的指令。
那些不能与硬件指令一一对应的新的指令将不会被接受。

Q: BPF 32位子寄存器的要求
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Q: BPF 32位子寄存器要求清零BPF寄存器的上32位，这使得BPF对于32位CPU架构和32位硬件加速器而言效率低下。将来能否在BPF中增加真正的32位寄存器？

A: 不可以。
但是有一些优化措施可用于减少对BPF寄存器上32位清零的操作，这些优化可以用来提高32位架构下JIT编译的BPF程序的性能。
从版本7开始，LLVM能够生成操作32位子寄存器的指令，前提是为编译程序传递了选项`-mattr=+alu32`。此外，验证器现在可以标记那些需要将目标寄存器的高位清零的指令，并插入一个明确的零扩展（zext）指令（mov32的一种变体）。这意味着对于没有zext硬件支持的架构，即时编译(JIT)后端无需清除由alu32指令或窄加载写入的子寄存器的高位。相反，后端只需支持该mov32变体的代码生成，并覆盖bpf_jit_needs_zext()函数使其返回"true"（以便在验证器中启用zext插入）。
需要注意的是，JIT后端可能部分支持zext硬件。在这种情况下，如果启用了验证器中的zext插入，则可能会插入不必要的zext指令。可以通过在JIT后端内部创建一个简单的窥孔优化来移除这些指令：如果一条指令有硬件支持的zext，并且下一条指令是明确的zext，则在进行代码生成时可以跳过后者。

**问：BPF是否有一个稳定的ABI？**
答：是的。BPF指令、BPF程序的参数、辅助函数集及其参数、可识别的返回码都是ABI的一部分。但是有一个特例，即使用如bpf_probe_read()等辅助函数追踪内核内部数据结构并使用内核内部头文件编译的程序。这两种内核内部细节都可能会发生变化，导致程序需要适应新内核的变化。
新增的BPF功能通常通过kfuncs而不是新的辅助函数来实现。Kfuncs不被视为稳定API的一部分，并且有自己的生命周期期望，具体描述参见:ref:`BPF_kfunc_lifecycle_expectations`。

**问：tracepoints是否是稳定ABI的一部分？**
答：不是。Tracepoints与内部实现细节相关联，因此它们可能会发生变化并在新内核中出现破坏。当这种情况发生时，BPF程序需要相应地做出更改。

**问：kprobes可以附着的位置是否是稳定ABI的一部分？**
答：不是。kprobes可以附着的位置属于内部实现细节，这意味着它们可能会发生变化并在新内核中出现破坏。当这种情况发生时，BPF程序需要相应地做出更改。

**问：BPF程序使用多少栈空间？**
答：目前所有类型的程序都被限制为最多使用512字节的栈空间，但验证器会计算实际使用的栈空间量，而且解释器和大多数即时编译代码都会消耗必要的栈空间。

**问：BPF能否卸载到硬件上？**
答：可以。NFP驱动支持BPF硬件卸载。

**问：经典的BPF解释器还存在吗？**
答：不存在。经典BPF程序会被转换为扩展BPF指令。

**问：BPF能否调用任意的内核函数？**
答：不可以。BPF程序只能调用作为BPF辅助函数或kfuncs公开的特定函数。可用函数集对于每种程序类型都是定义好的。
---

**问：BPF能覆写任意内核内存吗？**

答：不能  
跟踪型BPF程序可以使用`bpf_probe_read()`和`bpf_probe_read_str()`辅助函数读取任意内存。网络程序不能读取任意内存，因为它们无法访问这些辅助函数。程序永远不能直接读写任意内存。

**问：BPF能覆写任意用户空间内存吗？**

答：某种程度上可以  
跟踪型BPF程序可以使用`bpf_probe_write_user()`覆写当前任务的用户空间内存。每当加载这样的程序时，内核会打印警告信息，因此这个辅助函数仅适用于实验和原型开发。跟踪型BPF程序需要root权限。

**问：可以通过内核模块添加新功能吗？**

**问：BPF的新功能（如新的程序或映射类型、新的辅助函数等）可以通过内核模块代码实现吗？**

答：可以，通过kfuncs和kptrs  
核心BPF功能，如程序类型、映射和辅助函数，不能由模块扩展。但是，模块可以通过导出kfuncs来向BPF程序暴露功能（这些kfuncs可能会返回指向模块内部数据结构的指针作为kptrs）。

**问：直接调用内核函数是ABI的一部分吗？**

**问：一些内核函数（例如tcp_slow_start）可以被BPF程序调用。这些内核函数是否成为ABI的一部分？**

答：不是  
内核函数的原型可能会改变，并且BPF程序会被验证器拒绝。此外，例如，一些可被BPF调用的内核函数已经被其他内核TCP拥塞控制(cc)实现所使用。如果这些内核函数有任何变化，那么树内(in-tree)和树外(out-of-tree)的内核TCP拥塞控制实现都必须相应地进行调整。对于BPF程序也是如此，它们也必须相应地进行调整。详细信息参见 :ref:`BPF_kfunc_lifecycle_expectations`。

**问：将BPF程序附着到任意内核函数上是ABI的一部分吗？**

**问：BPF程序可以附着到许多内核函数上。这些内核函数是否成为ABI的一部分？**

答：不是
### 内核函数原型将发生变化，附着在其上的BPF程序也需要进行更改。为了便于将您的BPF程序适配到不同版本的内核，建议使用BPF“一次编译到处运行”(CO-RE)。

**问题：** 标记一个函数为BTF_ID是否意味着该函数成为ABI的一部分？
-------------------------------------------------------------
**回答：** **不**  
BTF_ID宏并不会使一个函数成为ABI的一部分，这与EXPORT_SYMBOL_GPL宏的作用类似。

**问题：** 对于映射值中的特殊BPF类型，其兼容性如何讲述？
-----------------------------------------------------------------------

**问题：** 用户被允许在他们的BPF映射值中嵌入`bpf_spin_lock`、`bpf_timer`字段（当使用BPF映射的BTF支持时）。这使得可以在映射值内部这些字段上使用此类对象的辅助函数。用户也被允许嵌入指向某些内核类型的指针（带有`__kptr_untrusted`和`__kptr` BTF标签）。内核是否会保持这些特性的向后兼容性？

**回答：** 这取决于具体情况。对于`bpf_spin_lock`和`bpf_timer`：**是**，对于`kptr`和其他所有内容：**不是**，但请参阅以下内容。
对于已经添加的结构类型，如`bpf_spin_lock`和`bpf_timer`，内核会保持向后兼容性，因为它们是UAPI的一部分。
对于`kptr`，它们也是UAPI的一部分，但仅限于`kptr`机制本身。您可以在结构体中使用`__kptr_untrusted`和`__kptr`标记指针所指向的类型并不是UAPI合同的一部分。支持的类型可能会随着内核版本的发布而变化。但是，对`kptr`字段的访问以及`bpf_kptr_xchg()`辅助函数等操作将继续支持适用于这些类型的内核版本。
对于任何其他支持的结构类型，除非在此文档中明确说明并添加到bpf.h UAPI头文件中，否则这些类型可能会任意改变其大小、类型、对齐方式或任何其他用户可见的API或ABI细节。用户必须根据新的变化调整他们的BPF程序，并更新以确保程序继续正确运行。
**注意：** BPF子系统特别保留了以`bpf_`前缀命名的类型，以便将来引入更多特殊字段。因此，用户程序必须避免定义以`bpf_`开头的类型，以免在未来的版本中出现问题。
换句话说，如果使用了带有`bpf_`前缀的BTF中的类型，则不能保证向后兼容性。

**问题：** 对于分配的对象中的特殊BPF类型，其兼容性如何讲述？
------------------------------------------------------------------------------
**问题：** 上述情况同样适用于分配的对象（即使用`bpf_obj_new`为用户定义的类型分配的对象）。内核是否会保持这些特性的向后兼容性？

**回答：** **不会**
与映射值类型不同，用于处理已分配对象的API及对它们内部特殊字段的任何支持是通过kfuncs暴露出来的，因此具有与kfuncs自身相同的生命周期预期。详细信息请参阅
:ref:`BPF_kfunc_lifecycle_expectations`。
