LED瞬态触发器
=====================

当前的LED定时器触发器没有接口来激活单次触发的定时器。现有的支持允许设置两个定时器，一个用于指定LED保持开启状态的时间，另一个用于指定LED保持关闭状态的时间。`delay_on`值定义了LED应保持在开启状态的时间段，随后是`delay_off`值，它指定了LED应保持在关闭状态的时长。开和关的循环将持续到触发器被停用为止。没有单次激活的机制来实现那些需要仅一次将LED保持在开启或关闭状态，然后永久保持在原始状态的功能。

没有单次定时器接口，用户空间仍然可以使用定时器触发器来设置定时器以保持某种状态，然而当用户空间应用程序崩溃或未停用定时器就退出时，硬件将永久地停留在那种状态。

瞬态触发器解决了单次定时器激活的需求。瞬态触发器可以像其他LED触发器一样被启用和禁用。

当LED类设备驱动程序注册自身时，它可以指定所有支持的LED触发器以及默认触发器。在注册期间，默认触发器的激活例程会被调用。在LED类设备注册期间，LED的状态不会改变。

当驱动程序注销时，当前活动触发器的停用例程将被调用，并且LED状态将变为LED_OFF。

驱动程序挂起会将LED状态更改为LED_OFF，而恢复不会改变状态。请注意，挂起和恢复操作与当前启用的触发器之间没有明确的交互。当驱动程序处于挂起状态时，LED状态变化被暂停。任何在驱动程序被挂起时活跃的定时器将继续运行，但无法实际改变LED状态。一旦驱动程序恢复，触发器开始再次发挥作用。

LED状态的变化通过亮度控制，这是LED类设备的通用属性。当从用户空间通过`echo 0 > brightness`将亮度设置为0时，它会导致当前触发器的停用。

瞬态触发器使用标准的注册和注销接口。在触发器注册期间，对于每个将此触发器指定为其默认触发器的LED类设备，触发器激活例程将被调用。在注册过程中，除非有其他触发器活动，在这种情况下LED状态变为LED_OFF，否则LED状态不会改变。

在触发器注销期间，LED状态将变更为LED_OFF。

瞬态触发器的激活例程不会改变LED状态。它创建其属性并进行初始化。瞬态触发器的停用例程将取消任何活跃的定时器，在清理和移除它创建的属性之前。它将LED状态恢复到非瞬态状态。当驱动程序被挂起时，无论瞬态状态如何，LED状态都会变为LED_OFF。
瞬时触发器可以在用户空间对 LED 类设备启用和禁用，前提是这些设备支持该触发器，如下所示：

```
echo transient > trigger
echo none > trigger
```

注意：
添加一个新的属性`trigger state`来控制状态。

此触发器导出三个属性：`activate`、`state`和`duration`。当瞬时触发器被激活时，这些属性会被设置为默认值：
- `duration`允许以毫秒为单位设置定时器的值。初始值为0。
- `activate`允许根据需要激活或禁用由`duration`指定的定时器。初始和默认值为0。这将允许在触发器激活后设置`duration`。
- `state`允许用户指定一个要保持的瞬时状态，持续时间为指定的`duration`。

`activate`
         - 单次定时器激活机制
激活时为1，未激活时为0
当启用瞬时触发器时，默认值为零，
         允许在激活后设置`duration`
激活状态表示正在运行具有指定
         `duration`值的定时器
未激活状态表示没有活动的定时器
         正在运行

以上是瞬时触发器在Linux内核中LED类设备上工作方式的详细描述，涉及其激活、状态及持续时间的控制。
### 时长 (Duration)

- 单次计时器值。当`activate`被设置时，使用`duration`的值来启动一个仅运行一次的计时器。此值除非用户通过`echo new_value > duration`的方式进行设置，否则不会被触发器改变。

### 状态 (State)

- 暂态状态保持值。它有两个值：0 或 1。0 映射到`LED_OFF`，而1映射到`LED_FULL`。指定的状态将保持在单次计时器的持续时间内，然后状态会变更为非暂态状态，即暂态状态的相反状态。
如果`state = LED_FULL`，当计时器到期时，状态将返回`LED_OFF`；
如果`state = LED_OFF`，当计时器到期时，状态将返回`LED_FULL`。
请注意，在变更至指定状态前，不会检查当前LED状态。
驱动程序可以基于其在`brightness_set()`接口中为LED定义的默认状态来映射这些值，该接口由`led brightness_set()`接口调用以控制LED状态。
当计时器过期时，`activate`将回到未激活状态，`duration`保留设置的值，用于未来某个时间点`activate`被设置时使用。这允许用户应用程序一次性设置时间，并根据需要激活它以按照指定值运行一次。当计时器过期时，状态恢复为非暂态状态，即暂态状态的相反状态：

| 命令                           | 描述                                                   |
|--------------------------------|--------------------------------------------------------|
| `echo 1 > activate`           | 当`duration`不为0时，开始计时器等于`duration`的值       |
| `echo 0 > activate`           | 取消正在运行的计时器                                   |
| `echo n > duration`           | 存储计时器值，以供下次`activate`时使用。当前活动计时器（如果有）继续按指定时间运行 |
| `echo 0 > duration`           | 存储计时器值，以供下次`activate`时使用。当前活动计时器（如果有）继续按指定时间运行 |
| `echo 1 > state`              | 存储期望的暂态状态`LED_FULL`，在指定的持续时间内保持    |

以上操作允许用户灵活地控制LED的状态和计时器的行为。
将以下内容翻译为中文：

`echo 0 > state` 存储希望的瞬态状态 `LED_OFF`，该状态将在指定的持续时间内保持。

==================   ================================================

不支持的内容
==================

- 定时器激活是一次性的，延长或缩短定时器的功能不受支持。
示例
========

使用场景1::

	`echo transient > trigger`
	`echo n > duration`
	`echo 1 > state`

根据需要重复以下步骤::

	`echo 1 > activate` - 开始定时器等于`duration`运行一次
	`echo 1 > activate` - 再次开始定时器等于`duration`运行一次
	`echo none > trigger`

此触发器设计用于以下示例使用场景：

- 用户空间应用程序使用LED作为活动指示器。
- 用户空间应用程序使用LED作为一种看门狗指示器 —— 只要应用程序活着，它可以保持LED点亮；如果它死亡，LED将自动熄灭。
- 任何需要瞬态GPIO输出的用户空间应用程序的使用。
