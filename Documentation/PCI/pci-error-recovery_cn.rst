### PCI错误恢复

#### 作者:
- Linas Vepstas <linasvepstas@gmail.com>
- Richard Lary <rlary@us.ibm.com>
- Mike Mason <mmlnx@us.ibm.com>

许多PCI总线控制器能够检测总线上的各种硬件PCI错误，如数据和地址总线上的奇偶校验错误以及SERR和PERR错误。一些更先进的芯片组能够处理这些错误；这包括PCI-E芯片组，以及IBM基于Power4、Power5和Power6的pSeries机器中发现的PCI主机桥接器。一种典型的行动是断开受影响设备的连接，停止所有对该设备的I/O操作。断开连接的目标是避免系统损坏；例如，阻止由于向“野指针”地址执行DMA操作而导致的系统内存损坏。通常还会提供一个重新连接机制，以便将受影响的PCI设备重置并恢复到正常工作状态。重置阶段需要受影响设备驱动程序与PCI控制器芯片之间的协调。

本文件描述了一个通用API，用于通知设备驱动程序总线断开，并随后执行错误恢复。这个API已经在2.6.16及更高版本的内核中实现。

报告和恢复分为几个步骤进行。首先，当PCI硬件错误导致总线断开时，会尽快将该事件报告给所有受影响的设备驱动程序，包括多功能卡上多个实例的设备驱动程序。这使得设备驱动程序可以避免在自旋循环中死锁，等待某个I/O空间寄存器发生变化，而这种变化可能永远不会发生。这也让驱动程序有机会根据需要推迟传入的I/O操作。

接下来，恢复过程分为几个阶段。大部分复杂性是由需要处理多功能设备引起的，即那些具有多个关联设备驱动程序的设备。在第一阶段，允许每个驱动程序指示其希望执行哪种类型的重置，选择包括简单的I/O重新启用或请求插槽重置。

如果任何驱动程序请求插槽重置，则将执行该操作。在重置和/或重新启用I/O之后，再次通知所有驱动程序，以便它们可以执行所需的任何设备设置/配置。在这些都完成后，会发出最终的“恢复正常操作”事件。

选择基于内核的实现而不是用户空间实现的最大原因是需要处理连接到存储介质的PCI设备的总线断开问题，特别是从作为根文件系统的设备断开的问题。如果根文件系统被断开，用户空间机制必须经过大量的复杂步骤才能完成恢复。当前大多数Linux文件系统都不容忍与其底层块设备的断开/重新连接。相比之下，总线错误在设备驱动程序中很容易管理。实际上，大多数设备驱动程序已经处理了非常相似的恢复程序；例如，SCSI通用层已经提供了大量机制来处理SCSI总线错误和SCSI总线重置。
### 详细设计
####

以下是基于与Ben Herrenschmidt在公共邮件列表中于大约2005年4月5日进行的讨论所形成的详细设计和实现细节。

错误恢复API以函数指针结构的形式暴露给驱动程序，这些指针通过`struct pci_driver`中的一个新字段指向。未提供该结构的驱动程序被视为“不支持”，实际采取的恢复步骤取决于平台。对于`arch/powerpc`实现，将模拟PCI热插拔移除/添加过程。

该结构定义如下：

```c
struct pci_error_handlers {
    int (*error_detected)(struct pci_dev *dev, pci_channel_state_t state);
    int (*mmio_enabled)(struct pci_dev *dev);
    int (*slot_reset)(struct pci_dev *dev);
    void (*resume)(struct pci_dev *dev);
    void (*cor_error_detected)(struct pci_dev *dev);
};
```

可能的通道状态包括：

```c
typedef enum {
    pci_channel_io_normal,  /* I/O通道处于正常状态 */
    pci_channel_io_frozen,  /* I/O到通道被阻塞 */
    pci_channel_io_perm_failure, /* PCI卡已失效 */
} pci_channel_state_t;
```

可能的返回值为：

```c
enum pci_ers_result {
    PCI_ERS_RESULT_NONE,        /* 没有结果/不支持/设备驱动程序中未实现 */
    PCI_ERS_RESULT_CAN_RECOVER, /* 设备驱动程序可以在不重置插槽的情况下恢复 */
    PCI_ERS_RESULT_NEED_RESET,  /* 设备驱动程序需要插槽重置 */
    PCI_ERS_RESULT_DISCONNECT,  /* 设备完全失败且不可恢复 */
    PCI_ERS_RESULT_RECOVERED,   /* 设备驱动程序已完全恢复并可运行 */
};
```

驱动程序不必实现所有这些回调函数；但是，如果实现了其中任何一个，则必须实现`error_detected()`函数。如果未实现某个回调函数，则认为对应的功能不受支持。例如，如果没有实现`mmio_enabled()`和`resume()`，则假设驱动程序不做任何直接恢复操作，并且需要插槽重置。通常，驱动程序会希望知道插槽重置的情况。

平台从PCI错误事件中恢复的具体步骤将取决于平台，但将遵循以下一般顺序：

### 第0步：错误事件
PCI总线错误由PCI硬件检测到。在PowerPC上，插槽会被隔离，即所有I/O都被阻断：所有读取返回0xffffffff，所有写入被忽略。

### 第1步：通知
平台对受错误影响的所有驱动程序实例调用`error_detected()`回调函数。
此时，根据平台的不同（在PowerPC上插槽将被隔离），设备可能已经无法访问。驱动程序可能因为I/O失败而已经“注意到”错误，但这才是正确的“同步点”，也就是说，它给了驱动程序一个清理的机会，等待待处理的任务（定时器等）完成；它可以获取信号量、调度等……除了接触设备之外的一切。在此函数内部及其返回后，驱动程序不应该执行新的I/O操作。此调用是在任务上下文中进行的。这有点像一个“静止”点。关于中断的注释请参阅本文档末尾。

所有参与该系统的驱动程序都必须实现此调用。

驱动程序必须返回以下结果代码之一：

- `PCI_ERS_RESULT_CAN_RECOVER`
    驱动程序返回此值表示它认为可以通过简单的I/O操作恢复硬件，或者想要有机会提取一些诊断信息（见下面的`mmio_enabled`）。
- PCI_ERS_RESULT_NEED_RESET  
  如果驱动程序返回此值，表示它在没有插槽重置的情况下无法恢复。
- PCI_ERS_RESULT_DISCONNECT  
  如果驱动程序返回此值，表示它根本不想进行恢复。

接下来采取的步骤将取决于驱动程序返回的结果代码。

如果段/插槽上的所有驱动程序都返回了PCI_ERS_RESULT_CAN_RECOVER，
那么平台应当重新启用该插槽的I/O（如果平台不隔离插槽，则可以不做特别处理），恢复流程进入第二步（MMIO启用）。
如果有任何驱动程序请求插槽重置（通过返回PCI_ERS_RESULT_NEED_RESET），
那么恢复流程进入第四步（插槽重置）。
如果平台无法恢复该插槽，下一步是第六步（永久性故障）。
.. 注意::

   当前的PowerPC实现假设设备驱动程序不会在此例程中调度或使用信号量；当前的PowerPC实现使用一个内核线程来通知所有设备；
   因此，如果一个设备休眠/调度，所有设备都会受到影响。
要做得更好需要在错误恢复实现中采用复杂的多线程逻辑（例如，在继续恢复之前等待所有通知线程“加入”）。
这看起来过于复杂且不值得实现。
当前的PowerPC实现不太关心设备此时是否尝试I/O。I/O将会失败，读取返回0xff的值，写入将被丢弃。
如果对冻结的适配器尝试超过EEH_MAX_FAILS次数的I/O，EEH会假设设备驱动程序进入了无限循环，并在系统日志中打印错误信息。
此时需要重启才能使设备再次工作。

**第二步：MMIO启用**

--------------------
平台重新启用到设备的MMIO（但通常不包括DMA），然后调用所有受影响设备驱动程序的mmio_enabled()回调函数。
这是“早期恢复”调用。允许再次进行I/O操作，但不允许DMA操作，并且存在一些限制。这不是驱动程序重新开始操作的回调，而只是用于检查/修改设备、提取诊断信息（如果有的话），并最终执行诸如触发设备本地重置等操作，但不重启操作。如果同一段上的所有驱动程序都认为可以尝试恢复，并且硬件没有执行自动链路重置，则会调用此回调。如果平台不能在不进行插槽重置或链路重置的情况下直接重新启用I/O操作，则不会调用此回调，而是直接进入步骤3（链路重置）或步骤4（插槽重置）。

.. note:: 

   以下是提议的内容；目前尚无平台实现这一点：
   提议：在此回调中，所有I/O操作应同步完成，由这些操作引发的错误将通过正常的pci_check_whatever() API返回，由于在此处发生错误而不会发出新的error_detected()回调。但是，此类错误可能会导致整个段的I/O被重新阻止，从而可能使同一段上其他设备所做的恢复无效，并迫使整个段进入下一个状态之一，即链路重置或插槽重置。
驱动程序应返回以下结果代码之一：
  - PCI_ERS_RESULT_RECOVERED
      如果驱动程序认为设备完全功能正常并且准备重新开始正常的驱动程序操作，则返回此值。无法保证实际上会被允许继续，因为同一段上的另一个驱动程序可能已失败，从而在支持该功能的平台上触发了插槽重置。
- PCI_ERS_RESULT_NEED_RESET
      如果驱动程序认为设备在其当前状态下不可恢复，并需要插槽重置才能继续，则返回此值。
- PCI_ERS_RESULT_DISCONNECT
      与上述相同。彻底失败，即使重置后也无法恢复，驱动程序失效。（待更精确地定义）

下一步采取的措施取决于驱动程序返回的结果。
如果所有驱动程序都返回了PCI_ERS_RESULT_RECOVERED，则平台将进入步骤3（链路重置）或步骤5（恢复操作）。
如果任一驱动程序返回了PCI_ERS_RESULT_NEED_RESET，则平台将进入步骤4（插槽重置）。

步骤3：链路重置
------------------
平台重置链路。这是PCI-Express特有的步骤，在检测到可以通过重置链路解决的致命错误时执行。
步骤4：插槽重置
------------------

对于返回值为PCI_ERS_RESULT_NEED_RESET的情况，平台将对请求的PCI设备执行插槽重置。
平台执行插槽重置的具体步骤将取决于平台本身。插槽重置完成后，平台将调用device slot_reset()回调。
PowerPC平台实现了两种级别的插槽重置：
软重置（默认）和基础重置（可选）。
PowerPC软重置包括断言适配器#RST线，然后将PCI BARs和PCI配置头恢复到相当于系统刚启动后经过电源开启BIOS/系统固件初始化的状态。
软复位也称为热复位。
PowerPC 基本复位仅由 PCI Express 卡支持，
并且会导致设备的状态机、硬件逻辑、端口状态和
配置寄存器初始化为它们的默认条件。
对于大多数 PCI 设备，软复位足以实现恢复。
提供了可选的基本复位来支持一小部分
软复位不足以实现恢复的 PCI Express 设备。
如果平台支持 PCI 热插拔，则复位可能通过
切换插槽的电源开/关来执行。
对于平台来说，将 PCI 配置空间恢复到“刚上电”的状态而非“最后状态”非常重要。复位后，
设备驱动程序几乎总是会使用其标准的设备初始化例程，而异常的配置空间设置可能会导致设备挂起、内核崩溃或静默数据损坏。
此调用给驱动程序提供了重新初始化硬件的机会（例如，重新下载固件等）。此时，驱动程序可以假定卡处于新鲜状态并完全可用。插槽已解除冻结，驱动程序可以完全访问 PCI 配置空间、内存映射 I/O 空间和 DMA。中断（传统、MSI 或 MSI-X）也将可用。
驱动程序此时不应重启正常的 I/O 处理操作。如果所有设备驱动程序在此回调中报告成功，平台将调用 resume() 来完成序列，并让驱动程序重启正常的 I/O 处理。
如果驱动程序在复位后无法使设备运行，它仍然可以为此函数返回一个严重失败。如果平台之前尝试过软复位，现在可能会尝试硬复位（电源循环），然后再次调用 slot_reset()。如果设备仍然无法恢复，那么就无能为力了；平台通常会在这种情况下报告“永久故障”。在这种情况下，设备将被视为“死机”。
多功能卡的驱动程序需要相互协调，确定哪个驱动程序实例将执行任何“一次性”或全局设备初始化。例如，Symbios sym53cxx2 驱动程序仅从 PCI 功能 0 执行设备初始化：

	+       如果 (PCI_FUNC(pdev->devfn) == 0)
	+               sym_reset_scsi_bus(np, 0);

结果代码：
	- PCI_ERS_RESULT_DISCONNECT
	  同上
对于需要基本重置的 PCI Express 卡的驱动程序，必须在它们的探测函数中将 `pci_dev` 结构中的 `needs_freset` 标志设置为真。
例如，QLogic qla2xxx 驱动程序为某些 PCI 卡类型设置了 `needs_freset` 标志：

	+	/* 如果 HBA 需要，则将 EEH 重置类型设置为基本重置 */
	+	if (IS_QLA24XX(ha) || IS_QLA25XX(ha) || IS_QLA81XX(ha))
	+		pdev->needs_freset = 1;
	+

平台将继续执行步骤 5（恢复操作）或步骤 6（永久故障）。
.. note::

   当前的 powerpc 实现不会尝试电源循环重置，如果驱动程序返回了 `PCI_ERS_RESULT_DISCONNECT` 的话。
然而，这可能是应该实现的功能。

**步骤 5：恢复操作**
-------------------------
如果段上所有驱动程序从之前的三个回调函数中返回了 `PCI_ERS_RESULT_RECOVERED`，那么平台将调用受影响的所有设备驱动程序的 `resume()` 回调函数。
这个回调函数的目标是告诉驱动程序重启活动，即一切都已恢复正常并正在运行。此回调函数不返回结果代码。
此时，如果发生新的错误，平台将重新启动一个新的错误恢复序列。

**步骤 6：永久故障**
-------------------------
已经发生了“永久故障”，并且平台无法恢复该设备。平台将通过调用 `error_detected()` 函数，并传递一个值为 `pci_channel_io_perm_failure` 的 `pci_channel_state_t` 类型参数来处理这种情况。
此时，设备驱动程序应假设最坏的情况。它应当取消所有待处理的 I/O 操作，拒绝所有新的 I/O 请求，并向上层返回 `-EIO`。然后，设备驱动程序应清理其所有的内存，并像系统关闭时那样从内核操作中移除自己。
通常情况下，平台将以某种方式通知系统操作员发生了永久故障。如果设备支持热插拔，操作员可能希望移除并更换该设备。
然而，请注意，并非所有故障都是真正“永久”的。有些是由过热引起的，有些则是由于插卡没有正确安装造成的。许多 PCI 错误事件是由软件缺陷导致的，例如对无效地址进行 DMA 操作或因编程错误导致的错误拆分事务。有关实际经验中软件错误原因的详细讨论，请参阅文档 `Documentation/arch/powerpc/eeh-pci-error-recovery.rst`。

结论；一般性评论
-----------------
回调函数的调用方式由平台策略决定。一个没有插槽重置功能的平台可能希望仅仅“忽略”那些无法恢复的驱动程序（断开连接），并尝试让同一段上的其他卡片恢复。请记住，在大多数实际情况中，每个段上通常只有一个驱动程序。

现在，关于中断的一些说明。如果你收到一个中断，而你的设备已经死亡或已被隔离，那么就存在问题了 :)

当前的策略是将这个问题转化为平台策略。
也就是说，恢复 API 只要求：

- 不能保证从检测到错误开始直到调用 `slot_reset` 回调函数期间，可以继续传递来自该段上任何设备的中断。在 `slot_reset` 被调用后，期望中断完全恢复正常工作。
- 也不能保证中断传递会被停止，即如果驱动程序在检测到错误之后收到中断，或者在中断处理程序内检测到错误，这会阻止正确的中断确认（从而无法移除中断源），那么它应该返回 `IRQ_NOTHANDLED`。如何处理这种情况取决于平台，通常是通过在错误处理期间屏蔽中断源来实现。平台需要知道哪些中断被路由到了具有错误管理能力的插槽，并能处理暂时禁用这些插槽的中断编号（这不是非常复杂）。这意味着对于共享此中断的其他设备可能会有一些中断延迟，但除此之外别无他法。高端平台通常不会让多个设备共享同一个中断。

.. note:: 

   PowerPC 平台的具体实现细节在文件 `Documentation/arch/powerpc/eeh-pci-error-recovery.rst` 中进行了讨论。

   至本文撰写时，越来越多的设备驱动程序实现了错误恢复的补丁。并非所有这些补丁都已合并入主线内核。这些补丁可以用作“示例”：

   - drivers/scsi/ipr
   - drivers/scsi/sym53c8xx_2
   - drivers/scsi/qla2xxx
   - drivers/scsi/lpfc
   - drivers/next/bnx2.c
   - drivers/next/e100.c
   - drivers/net/e1000
   - drivers/net/e1000e
   - drivers/net/ixgbe
   - drivers/net/cxgb3
   - drivers/net/s2io.c

   当错误严重程度为“可纠正”时，`cor_error_detected()` 回调函数会在 `handle_error_source()` 中被调用。这个回调函数是可选的，如果需要的话，它可以用来进行额外的日志记录。参见示例：

   - drivers/cxl/pci.c

结束
-------
