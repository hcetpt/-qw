SPDX 许可证标识符: GPL-2.0

==================
PCI 错误恢复
==================

作者: 
- Linas Vepstas <linasvepstas@gmail.com>
- Richard Lary <rlary@us.ibm.com>
- Mike Mason <mmlnx@us.ibm.com>

许多 PCI 总线控制器能够检测总线上的各种硬件 PCI 错误，例如数据和地址总线上的奇偶校验错误以及 SERR 和 PERR 错误。一些更先进的芯片组能够处理这些错误；这包括 PCI-E 芯片组，以及 IBM Power4、Power5 和 Power6 基础上的 pSeries 系统中的 PCI 主机桥接器。通常采取的措施是断开受影响设备的连接，停止所有对该设备的 I/O 操作。断开连接的目标是避免系统损坏；例如，防止由于向“野”地址进行 DMA 导致的系统内存损坏。通常还会提供一种重新连接机制，以便将受影响的 PCI 设备重置并恢复到正常工作状态。重置阶段需要受影响的设备驱动程序与 PCI 控制器芯片之间进行协调。

本文档描述了一个通用 API，用于通知设备驱动程序总线断开，并执行错误恢复。该 API 目前已实现在 2.6.16 及以后的内核版本中。报告和恢复分几个步骤进行。首先，在 PCI 硬件错误导致总线断开时，该事件会尽快报告给所有受影响的设备驱动程序，包括多功能卡上的多个设备驱动实例。这使得设备驱动程序可以避免在自旋锁中死锁，等待某个 I/O 空间寄存器发生变化，而实际上永远不会发生。这也让驱动程序有机会根据需要延迟传入的 I/O 操作。

接下来，恢复分为几个阶段进行。大部分复杂性是由需要处理多功能设备引起的，即具有多个关联设备驱动程序的设备。在第一阶段，每个驱动程序可以指示其所需的重置类型，选择包括简单的 I/O 重新启用或请求插槽重置。如果任何驱动程序请求插槽重置，则将执行该操作。

在重置和/或重新启用 I/O 后，所有驱动程序将再次收到通知，以便它们可以执行可能需要的任何设备设置/配置。在所有这些完成后，会发送一个最终的“恢复正常操作”事件。

选择基于内核的实现而不是用户空间实现的最大原因是需要处理连接到存储介质的 PCI 设备的总线断开，特别是根文件系统的断开。如果根文件系统断开，用户空间机制将不得不经历大量的复杂操作来完成恢复。当前大多数 Linux 文件系统无法容忍与其底层块设备的断开/重连。相比之下，在设备驱动程序中管理总线错误非常容易。事实上，大多数设备驱动程序已经处理了类似的恢复过程；例如，SCSI 泛型层已经提供了大量处理 SCSI 总线错误和 SCSI 总线重置的机制。
详细设计
===============

以下设计和实现细节基于2005年4月左右与Ben Herrenschmidt通过公开电子邮件讨论的结果。
错误恢复API以函数指针结构的形式暴露给驱动程序，该结构由`struct pci_driver`中的一个新字段指向。未能提供该结构的驱动程序被视为“无感知”，实际采取的恢复步骤依赖于平台。在`arch/powerpc`实现中，将模拟PCI热插拔移除/添加。

该结构形式如下：

```c
struct pci_error_handlers {
    int (*error_detected)(struct pci_dev *dev, pci_channel_state_t);
    int (*mmio_enabled)(struct pci_dev *dev);
    int (*slot_reset)(struct pci_dev *dev);
    void (*resume)(struct pci_dev *dev);
    void (*cor_error_detected)(struct pci_dev *dev);
};
```

可能的通道状态包括：

```c
typedef enum {
    pci_channel_io_normal,  /* I/O通道处于正常状态 */
    pci_channel_io_frozen,  /* 阻止对I/O通道的访问 */
    pci_channel_io_perm_failure, /* PCI卡已失效 */
} pci_channel_state_t;
```

可能的返回值包括：

```c
enum pci_ers_result {
    PCI_ERS_RESULT_NONE,        /* 没有结果/不支持 */
    PCI_ERS_RESULT_CAN_RECOVER, /* 驱动程序可以不重置插槽即可恢复 */
    PCI_ERS_RESULT_NEED_RESET,  /* 驱动程序需要重置插槽 */
    PCI_ERS_RESULT_DISCONNECT,  /* 设备完全失败，无法恢复 */
    PCI_ERS_RESULT_RECOVERED,   /* 驱动程序已完全恢复并可操作 */
};
```

驱动程序不必实现所有这些回调；但是，如果实现了任何回调，则必须实现`error_detected()`。如果没有实现某个回调，则认为对应的特性不受支持。例如，如果未实现`mmio_enabled()`和`resume()`，则假定驱动程序没有进行直接恢复，并且需要重置插槽。通常，驱动程序会想要知道`slot_reset()`的情况。

平台从PCI错误事件中恢复的实际步骤将取决于平台，但会遵循下面描述的一般顺序。

步骤0：错误事件
-------------------
PCI硬件检测到PCI总线错误。在PowerPC上，插槽被隔离，即所有I/O被阻止：所有读取返回0xffffffff，所有写入被忽略。

步骤1：通知
--------------------
平台调用每个受错误影响的驱动程序实例上的`error_detected()`回调。
此时，根据平台的不同（在PowerPC上插槽将被隔离），设备可能已无法访问。驱动程序可能已经因为I/O失败而“注意到”了错误，但这才是正确的“同步点”，也就是说，这给了驱动程序清理的机会，等待待处理任务（计时器等）完成；它可以获取信号量、调度等……除了触碰设备以外的一切。在此函数内部及其返回之后，驱动程序不应执行新的I/O操作。此回调是在任务上下文中调用的。这有点像一个“静止”点。有关中断的说明请参见本文档末尾。
参与此系统的所有驱动程序必须实现此调用。
驱动程序必须返回以下结果代码之一：

- `PCI_ERS_RESULT_CAN_RECOVER`
    驱动程序返回此值表示它认为可以通过简单的I/O操作恢复硬件，或者希望有机会提取一些诊断信息（见下文的`mmio_enable`）。
- PCI_ERS_RESULT_NEED_RESET  
  如果驱动程序无法在不进行插槽重置的情况下恢复，则返回此结果。

- PCI_ERS_RESULT_DISCONNECT  
  如果驱动程序不想进行任何恢复操作，则返回此结果。

接下来的步骤取决于驱动程序返回的结果代码：
- 如果段/插槽上的所有驱动程序都返回了 PCI_ERS_RESULT_CAN_RECOVER，那么平台应该重新启用插槽上的 I/O（如果平台不隔离插槽，则可以不做任何特别的操作），并进入第二步（MMIO 启用）。
- 如果任何一个驱动程序请求了插槽重置（通过返回 PCI_ERS_RESULT_NEED_RESET），则恢复过程进入第四步（插槽重置）。
- 如果平台无法恢复插槽，下一步是第六步（永久性故障）。

.. 注意::
   
   当前的 PowerPC 实现假设设备驱动程序在此例程中不会进行调度或使用信号量；当前的 PowerPC 实现使用一个内核线程来通知所有设备；因此，如果一个设备进入睡眠或调度状态，所有设备都会受到影响。
   要改进这一点需要在错误恢复实现中引入复杂的多线程逻辑（例如，在继续恢复之前等待所有通知线程“加入”）。这看起来过于复杂，并且不值得去实现。
   当前的 PowerPC 实现并不太关心设备此时是否尝试 I/O 操作。I/O 将会失败，读取返回 0xff 的值，写入将被丢弃。如果对冻结的适配器尝试超过 EEH_MAX_FAILS 次 I/O 操作，EEH 假设设备驱动程序进入了无限循环，并在系统日志中打印错误信息。然后需要重启以使设备恢复正常工作。

第二步：MMIO 启用
--------------------
平台重新启用设备的 MMIO（但通常不包括 DMA），然后调用所有受影响设备驱动程序的 mmio_enabled() 回调函数。
这是“早期恢复”调用。允许再次使用I/O，但不允许使用DMA，且有一些限制。这不是驱动程序重新开始操作的回调，而是为了检查/访问设备、提取诊断信息（如果有的话），并最终执行诸如触发设备本地重置等操作，但不能重启操作。如果段上的所有驱动程序都认为可以尝试恢复，并且硬件没有执行自动链路重置，则会调用此回调。如果平台无法在不进行插槽重置或链路重置的情况下重新启用I/O，则不会调用此回调，而是直接进入步骤3（链路重置）或步骤4（插槽重置）。

.. 注意::

   以下内容是提议；目前还没有任何平台实现这一点：
   提议：所有I/O都应在此回调中同步完成，由它们触发的错误将通过正常的pci_check_whatever() API返回，不会因为在这里发生的错误而发出新的error_detected()回调。然而，这样的错误可能会导致整个段的I/O被重新阻塞，从而使得同一段上其他设备所做的恢复无效，迫使整个段进入下一个状态，即链路重置或插槽重置。

驱动程序应返回以下结果代码之一：
  - PCI_ERS_RESULT_RECOVERED
      如果驱动程序认为设备已完全恢复正常，并且准备好重新开始正常操作，则返回此结果。但是，无法保证实际上会被允许继续，因为同一段上的另一个驱动程序可能失败了，从而在支持插槽重置的平台上触发插槽重置。
  - PCI_ERS_RESULT_NEED_RESET
      如果驱动程序认为设备在其当前状态下无法恢复，并且需要插槽重置才能继续，则返回此结果。
  - PCI_ERS_RESULT_DISCONNECT
      同上。彻底失败，即使重置后也无法恢复，驱动程序失效。（需进一步明确定义）

下一步的操作取决于驱动程序返回的结果。
如果所有驱动程序都返回PCI_ERS_RESULT_RECOVERED，则平台将继续执行步骤3（链路重置）或步骤5（恢复操作）。
如果任何一个驱动程序返回PCI_ERS_RESULT_NEED_RESET，则平台将继续执行步骤4（插槽重置）。

步骤3：链路重置
------------------
平台重置链路。这是PCI-Express特有的步骤，在检测到可以通过重置链路解决的致命错误时执行。

步骤4：插槽重置
------------------
在接收到PCI_ERS_RESULT_NEED_RESET的返回值后，平台将对请求的PCI设备执行插槽重置。具体执行插槽重置的步骤将取决于平台。插槽重置完成后，平台将调用device slot_reset()回调。
PowerPC平台实现了两种级别的插槽重置：软重置（默认）和基础重置（可选）。PowerPC软重置包括断言适配器#RST线，然后将PCI BARs和PCI配置头恢复到相当于系统刚启动后经过电源打开BIOS/系统固件初始化后的状态。
软复位也称为热复位。
Powerpc基础复位仅由PCI Express卡支持，并将导致设备的状态机、硬件逻辑、端口状态和配置寄存器初始化到其默认条件。
对于大多数PCI设备，软复位就足以实现恢复。
为了支持少数软复位不足以恢复的PCI Express设备，提供了可选的基础复位。
如果平台支持PCI热插拔，则复位可以通过切换插槽电源的开/关来完成。
平台必须将PCI配置空间恢复到“刚上电”的状态，而不是“最后的状态”。在插槽复位后，设备驱动程序几乎总是会使用其标准的设备初始化例程，而异常的配置空间设置可能会导致设备挂起、内核恐慌或静默数据损坏。
此调用使驱动程序有机会重新初始化硬件（例如重新下载固件等）。此时，驱动程序可以假定该卡处于全新状态并完全可用。插槽已解冻，驱动程序可以完全访问PCI配置空间、内存映射I/O空间和DMA。中断（传统中断、MSI或MSI-X）也将可用。
驱动程序不应在此时重启正常的I/O处理操作。如果所有设备驱动程序在此回调中报告成功，平台将调用resume()以完成序列，并让驱动程序重启正常的I/O处理。
如果驱动程序在复位后无法使设备正常运行，仍可以返回一个关键性失败。如果平台之前尝试了软复位，现在可能会尝试硬复位（电源循环），然后再调用slot_reset()。如果设备仍然无法恢复，则无法再做其他事情；平台通常会在这种情况下报告“永久故障”。在这种情况下，设备将被视为“失效”。
多功能卡的驱动程序需要协调它们之间的关系，确定哪个驱动实例将执行任何“一次性”或全局设备初始化。例如，Symbios sym53cxx2驱动程序仅从PCI功能0执行设备初始化：

```c
	+       if (PCI_FUNC(pdev->devfn) == 0)
	+               sym_reset_scsi_bus(np, 0);
```

结果代码：
- PCI_ERS_RESULT_DISCONNECT
  同上
需要基本重置的PCI Express卡的驱动程序必须在其probe函数中设置pci_dev结构中的needs_freset位。例如，QLogic qla2xxx驱动程序为某些PCI卡类型设置了needs_freset位：

	+	/* 如果HBA需要基本重置，则设置EEH重置类型为基本重置 */
	+	if (IS_QLA24XX(ha) || IS_QLA25XX(ha) || IS_QLA81XX(ha))
	+		pdev->needs_freset = 1;
	+

平台将进入步骤5（恢复操作）或步骤6（永久故障）。
.. 注意::

   当前的powerpc实现不会尝试电源循环重置，如果驱动程序返回了PCI_ERS_RESULT_DISCONNECT
然而，这可能是应该做的。
步骤5：恢复操作
-------------------------
如果段上的所有驱动程序在前三个回调中都返回了PCI_ERS_RESULT_RECOVERED，平台将调用resume()回调来恢复所有受影响设备驱动程序的活动。此回调的目标是告诉驱动程序重启活动，一切恢复正常。此回调不返回结果代码。
此时，如果发生新的错误，平台将重新启动一个新的错误恢复序列。
步骤6：永久故障
-------------------------
发生了“永久故障”，并且平台无法恢复该设备。平台将以pci_channel_io_perm_failure值调用error_detected()。
此时，设备驱动程序应假设最坏的情况。它应取消所有挂起的I/O操作，拒绝所有新的I/O请求，并向上层返回-EIO。然后，设备驱动程序应清理其所有内存并从内核操作中移除自身，就像系统关机时一样。
平台通常会以某种方式通知系统操作员发生了永久故障。如果设备支持热插拔，操作员可能希望移除并替换该设备。
然而，请注意，并非所有的故障都是真正“永久”的。有些是由过热引起的，有些则是由插卡接触不良造成的。许多PCI错误事件是由软件bug引起的，例如对无效地址的DMA操作或因编程错误导致的错误拆分事务。有关实际经验中软件错误原因的详细讨论，请参阅Documentation/arch/powerpc/eeh-pci-error-recovery.rst。

结论；一般性评论
---------------------------
回调函数的调用方式取决于平台策略。一个没有插槽重置功能的平台可能希望“忽略”那些无法恢复的驱动程序（断开连接），并尝试让同一段上的其他卡片恢复。请记住，在大多数实际情况中，每个段上通常只有一个驱动程序。

现在来说一下中断问题。如果你收到一个中断，而你的设备已经失效或被隔离了，那么就存在问题了。
目前的策略是将这个问题转化为平台策略。也就是说，恢复API仅要求：

- 不能保证从检测到错误开始直到调用slot_reset回调期间，可以从该段上的任何设备传递中断。在slot_reset回调之后，中断应完全恢复正常。
- 也不能保证中断传递会被停止，也就是说，如果驱动程序在检测到错误后收到了中断，或者在中断处理程序内部检测到错误，从而阻止了正确的中断确认（因此无法移除中断源），则应返回IRQ_NOTHANDLED。处理这种情况的责任在于平台，通常是在错误处理过程中屏蔽IRQ源。平台应该知道哪些中断路由到了具有错误管理能力的插槽，并且能够处理在错误处理过程中暂时禁用该IRQ编号（这并不复杂）。这意味着对于共享中断的其他设备会有一些IRQ延迟，但别无他法。高端平台本来就不应该让多个设备共享中断。

.. note::

   PowerPC平台的具体实现细节在文件Documentation/arch/powerpc/eeh-pci-error-recovery.rst中有讨论。

   截至撰写本文时，有一份不断增长的实现了错误恢复的设备驱动程序列表。并非所有这些补丁都已合并到主线内核中。这些可以作为“示例”：

   - drivers/scsi/ipr
   - drivers/scsi/sym53c8xx_2
   - drivers/scsi/qla2xxx
   - drivers/scsi/lpfc
   - drivers/next/bnx2.c
   - drivers/next/e100.c
   - drivers/net/e1000
   - drivers/net/e1000e
   - drivers/net/ixgbe
   - drivers/net/cxgb3
   - drivers/net/s2io.c

   当错误严重程度为“可纠正”时，cor_error_detected()回调会在handle_error_source()中被调用。此回调是可选的，允许在需要时进行额外的日志记录。示例如下：

   - drivers/cxl/pci.c

结束
-------
