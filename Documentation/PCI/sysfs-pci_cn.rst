### SPDX 许可证标识符: GPL-2.0

============================================
通过 sysfs 访问 PCI 设备资源
============================================

sysfs，通常挂载在 /sys，为支持它的平台提供了访问 PCI 资源的途径。例如，给定的总线可能看起来像这样：

```
/sys/devices/pci0000:17
|-- 0000:17:00.0
|   |-- class
|   |-- config
|   |-- device
|   |-- enable
|   |-- irq
|   |-- local_cpus
|   |-- remove
|   |-- resource
|   |-- resource0
|   |-- resource1
|   |-- resource2
|   |-- revision
|   |-- rom
|   |-- subsystem_device
|   |-- subsystem_vendor
|   `-- vendor
`-- ..
```

最顶层元素描述了 PCI 域和总线号。在这个例子中，域号是 0000，总线号是 17（两个值都是十六进制）。这个总线上包含一个位于插槽 0 的单功能设备。为了方便起见，重复列出了域号和总线号。在设备目录下有几个文件，每个文件都有其特定的功能：
=================== =====================================================
       文件		   功能
       =================== =====================================================
       class		   PCI 类别（ASCII，只读）
       config		   PCI 配置空间（二进制，读写）
       device		   PCI 设备（ASCII，只读）
       enable	           是否启用了该设备（ASCII，读写）
       irq		   中断请求号（ASCII，只读）
       local_cpus	   附近的 CPU 掩码（CPU掩码类型，只读）
       remove		   从内核列表中移除设备（ASCII，写入）
       resource		   PCI 资源主机地址（ASCII，只读）
       resource0..N	   如果存在，则为 PCI 资源 N（二进制，内存映射，读写[1]_）
       resource0_wc..N_wc  如果可预取，则为 PCI WC 映射资源 N（二进制，内存映射）
       revision		   PCI 版本（ASCII，只读）
       rom		   如果存在，则为 PCI ROM 资源（二进制，只读）
       subsystem_device	   PCI 子系统设备（ASCII，只读）
       subsystem_vendor	   PCI 子系统供应商（ASCII，只读）
       vendor		   PCI 供应商（ASCII，只读）
       =================== =====================================================

```
ro - 只读文件
rw - 文件可读可写
wo - 写入只文件
mmap - 文件可以进行内存映射
ascii - 文件包含 ASCII 文本
binary - 文件包含二进制数据
cpumask - 文件包含 CPU 掩码类型
```

.. [1] 仅对于 IORESOURCE_IO (I/O 端口) 区域才可读写

只读文件用于提供信息，对它们的写入将被忽略，除了 “rom” 文件。可写文件可用于执行设备上的操作（例如更改配置空间、卸载设备）。可以使用内存映射的文件通过文件偏移量 0 的内存映射获得，并可用于从用户空间实际编程设备。请注意，某些平台不支持某些资源的内存映射，因此一定要检查任何尝试的内存映射返回值。这些中最显著的是 I/O 端口资源，它们也提供读写访问。

“enable” 文件提供了一个计数器，指示设备被启用的次数。如果当前 “enable” 文件返回 “4”，并且向其中写入 “1”，它将变为 “5”。写入 “0” 会减少计数。即使它返回到 0，一些初始化也可能不会反转。

“rom” 文件是特殊的，因为它提供了只读访问设备的 ROM 文件（如果可用）。默认情况下它是禁用的，因此应用程序应在尝试读取之前向文件写入字符串 “1” 来启用它，在访问后通过写入 “0” 来禁用它。请注意，设备必须启用才能成功从 ROM 读取数据。

如果驱动程序未绑定到设备，可以使用上面记录的 “enable” 文件来启用它。

“remove” 文件用于通过向文件写入非零整数来移除 PCI 设备。这不涉及任何类型的热插拔功能，例如关闭设备电源。设备从内核的 PCI 设备列表中移除，sysfs 目录被删除，并且设备将从任何连接到它的驱动程序中移除。不允许移除 PCI 根总线。

通过 sysfs 访问传统资源
----------------------------------------

如果底层平台支持它们，传统 I/O 端口和 ISA 内存资源也在 sysfs 中提供。它们位于 PCI 类层次结构中，例如：

```
/sys/class/pci_bus/0000:17/
|-- bridge -> ../../../devices/pci0000:17
|-- cpuaffinity
|-- legacy_io
`-- legacy_mem
```

“legacy_io” 文件是一个读写文件，应用程序可以通过它来进行传统的端口 I/O。应用程序应打开文件，定位到所需的端口（例如 0x3e8），并进行 1、2 或 4 字节的读或写操作。“legacy_mem” 文件应使用与所需内存偏移相对应的偏移量进行内存映射，例如 VGA 帧缓冲区的 0xa0000。然后应用程序只需检查错误后对返回的指针进行解引用即可访问传统内存空间。
支持新平台上的 PCI 访问
--------------------------------------

为了支持如上所述的 PCI 资源映射，理想情况下，Linux 平台代码应该定义 `ARCH_GENERIC_PCI_MMAP_RESOURCE` 并使用该功能的通用实现。为了支持通过 `/proc/bus/pci` 目录下的文件进行的 `mmap()` 的历史接口，平台也可以设置 `HAVE_PCI_MMAP`。或者，设置了 `HAVE_PCI_MMAP` 的平台可以提供自己的 `pci_mmap_resource_range()` 实现，而不是定义 `ARCH_GENERIC_PCI_MMAP_RESOURCE`。

支持 PCI 资源写合并映射的平台必须定义 `arch_can_pci_mmap_wc()`，该函数在运行时当允许写合并时应返回非零值。支持 I/O 资源映射的平台以类似的方式定义 `arch_can_pci_mmap_io()`。

遗留资源由 `HAVE_PCI_LEGACY` 定义保护。希望支持遗留功能的平台应该定义它并提供 `pci_legacy_read`、`pci_legacy_write` 和 `pci_mmap_legacy_page_range` 函数。
