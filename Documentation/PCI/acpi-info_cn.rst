SPDX 许可证标识符：GPL-2.0

========================================
ACPI 对 PCI 主桥的考虑
========================================

一般规则是，除非操作系统有其他方法找到它，否则 ACPI 命名空间应描述所有操作系统可能会使用的内容 [1, 2]。例如，没有标准硬件机制来枚举 PCI 主桥，因此必须通过 ACPI 命名空间来描述每个主桥、访问其下 PCI 配置空间的方法、主桥转发到 PCI 的地址空间窗口（使用 _CRS），以及传统 INTx 中断的路由（使用 _PRT）。

位于主桥之下的 PCI 设备通常不需要通过 ACPI 来描述。操作系统可以通过标准的 PCI 枚举机制发现它们，通过配置访问来发现和识别设备，并读取和确定其 BAR 大小。然而，如果 ACPI 提供了这些设备的电源管理和热插拔功能，或者设备具有由平台中断控制器连接的 INTx 中断并且需要一个 _PRT 来描述这些连接，则 ACPI 可能会描述这些 PCI 设备。

ACPI 资源描述是通过 ACPI 命名空间中设备的 _CRS 对象完成的 [2]。_CRS 类似于通用的 PCI BAR：即使操作系统没有设备的驱动程序，也可以读取 _CRS 并弄清楚正在消耗哪些资源 [3]。这一点非常重要，因为它意味着旧的操作系统在面对新设备时仍然可以正确工作。

新设备可能无法正常工作，但至少操作系统可以确保没有资源与其冲突。静态表如 MCFG、HPET、ECDT 等不是用于预留地址空间的机制。静态表是为了让操作系统在启动早期就能知道一些信息，在它可以解析 ACPI 命名空间之前。如果定义了一个新的表，旧的操作系统应该能够在忽略该表的情况下正确运行。_CRS 允许这样做，因为它具有通用性并被旧的操作系统理解；而静态表则不能。

如果预期操作系统要管理一个通过 ACPI 描述的不可发现设备，那么该设备将有一个特定的 _HID/_CID，告诉操作系统应该绑定哪个驱动程序，而 _CRS 则告诉操作系统和驱动程序设备寄存器的位置。

PCI 主桥是 PNP0A03 或 PNP0A08 设备。它们的 _CRS 应描述其消耗的所有地址空间。这包括它们转发到 PCI 总线的所有窗口，以及未转发到 PCI 的主桥自身寄存器。主桥寄存器包括确定桥下总线范围的次级/从属总线寄存器、描述孔径的窗口寄存器等。

这些都是设备特定的、非架构化的部分，因此 PNP0A03/PNP0A08 驱动程序只能通过 _PRS/_CRS/_SRS 来管理这些寄存器，其中包含设备特定的细节。主桥寄存器还包括 ECAM 空间，因为它是被主桥消耗的。

ACPI 定义了一个 Consumer/Producer 位以区分桥寄存器（“Consumer”）和桥孔径（“Producer”）[4, 5]，但早期 BIOS 没有正确使用这个位。结果是当前的 ACPI 规范只对扩展地址空间描述符定义了 Consumer/Producer 位；在较早的 QWord/DWord/Word 地址空间描述符中，该位应被忽略。因此，操作系统必须假设所有的 QWord/DWord/Word 描述符都是窗口。
在扩展地址空间描述符加入之前，消费者/生产者（Consumer/Producer）的失败意味着没有办法在 PNP0A03/PNP0A08 设备本身中描述桥接寄存器。解决方法是在 PNP0C02 的通配设备中描述这些桥接寄存器（包括 ECAM 空间）。除了 ECAM 外，桥接寄存器空间是特定于设备的，因此通用的 PNP0A03/PNP0A08 驱动（pci_root.c）不需要知道这些信息。

新架构应该能够使用 PNP0A03 设备中的“消费者”扩展地址空间描述符来描述桥接寄存器，包括 ECAM，尽管严格的 [6] 解释可能会禁止这样做。旧的 x86 和 ia64 内核假设所有地址空间描述符（包括“消费者”扩展地址空间描述符）都是窗口，因此在这些架构上以这种方式描述桥接寄存器是不安全的。

PNP0C02 “主板”设备基本上是一个通配设备。除了“不要将这些资源用于其他用途”之外，没有其他编程模型。因此，一个 PNP0C02 _CRS 应该声明任何地址空间，只要这个地址空间：(1) 没有被 ACPI 命名空间中的其他设备对象的 _CRS 声明，并且 (2) 不应该由操作系统分配给其他设备。

PCIe 规范要求使用增强配置访问方法（ECAM），除非有一个标准固件接口用于配置访问，例如 ia64 的 SAL 接口 [7]。主机桥接消耗 ECAM 内存地址空间，并将内存访问转换为 PCI 配置访问。规范定义了 ECAM 地址空间布局和功能；只有地址空间的基础部分是特定于设备的。ACPI 操作系统从 PNP0A03 设备中的静态 MCFG 表或 _CBA 方法中学习基础地址。

MCFG 表必须描述非热插拔主机桥接的 ECAM 空间 [8]。由于 MCFG 是一个静态表且不能通过热插拔更新，因此 PNP0A03 设备中的 _CBA 方法描述热插拔主机桥接的 ECAM 空间 [9]。请注意，对于 MCFG 和 _CBA，基础地址始终对应于总线 0，即使桥接下方的总线范围（通过 _CRS 报告）不从 0 开始。

[1] ACPI 6.2，第 6.1 节：
    对于任何位于不可枚举类型总线（例如 ISA 总线）上的设备，OSPM 枚举设备标识符，并且 ACPI 系统固件必须为每个设备提供 _HID 对象……以便 OSPM 进行枚举。
    
[2] ACPI 6.2，第 3.7 节：
    操作系统通过读取 ACPI 命名空间来枚举主板设备，寻找具有硬件 ID 的设备。

每个由 ACPI 枚举的设备都包含在 ACPI 命名空间中的 ACPI 定义的对象，这些对象报告设备可能占用的硬件资源 [_PRS]、报告当前设备使用的资源的对象 [_CRS]，以及用于配置这些资源的对象 [_SRS]。这些信息被即插即用操作系统（OSPM）用来配置设备。

[3] ACPI 6.2，第 6.2 节：
    OSPM 使用设备配置对象来为通过 ACPI 枚举的设备配置硬件资源。设备配置对象提供了当前和可能的资源需求、共享资源之间的关系以及配置硬件资源的方法。

当 OSPM 枚举一个设备时，它调用 _PRS 来确定设备的资源需求。它还可以调用 _CRS 来查找设备当前的资源设置。使用这些信息，即插即用系统确定设备应该消耗哪些资源，并通过调用设备的 _SRS 控制方法来设置这些资源。
在ACPI中，设备可以消耗资源（例如，传统键盘），提供资源（例如，专有的PCI桥接器），或同时进行这两项操作。除非另有说明，否则假定设备的资源是从设备层次结构中该设备上方最近匹配的资源获取的。

[4] ACPI 6.2，第6.4.3.5.1节，第2、3、4点：
    QWord/DWord/Word 地址空间描述符（.1, .2, .3）
      通用标志：位 [0] 被忽略

    扩展地址空间描述符（.4）
      通用标志：位 [0] 消费者/生产者：

        * 1 – 此设备消耗此资源
        * 0 – 此设备生产和消耗此资源

[5] ACPI 6.2，第19.6.43节：
    ResourceUsage 指定了内存范围是由该设备消耗（ResourceConsumer）还是传递给子设备（ResourceProducer）。如果没有指定，则默认为 ResourceConsumer。

[6] PCI 固件规范 3.2，第4.1.2节：
    如果操作系统不支持原生预留 MMCFG 区域，则必须由固件预留 MMCFG 区域。MCFG 表或 _CBA 方法（参见第4.1.3节）报告的地址范围必须通过声明主板资源来预留。对于大多数系统，主板资源应出现在 ACPI 命名空间的根目录下（在 \_SB 下）的一个节点中，并且该节点的 _HID 应为 EISAID（PNP0C02），并且这些资源不应在根 PCI 总线的 _CRS 中被占用。这些资源可以选择性地作为保留内存返回到 Int15 E820 或 EFIGetMemoryMap，但必须始终通过 ACPI 作为主板资源报告。

[7] PCI Express 4.0，第7.2.2节：
    对于兼容 PC 的系统或未实现处理器架构特定固件接口标准的系统（该标准允许访问配置空间），需要 ECAM，定义如本节所述。

[8] PCI 固件规范 3.2，第4.1.2节：
    MCFG 表是一个 ACPI 表，用于传达非热插拔 PCI 段组范围内在启动时可供操作系统使用的基地址。这对于 PC 兼容系统是必需的。
    
    MCFG 表仅用于传达系统启动时可用的 PCI 段组对应的基地址。

[9] PCI 固件规范 3.2，第4.1.3节：
    _CBA（内存映射配置基地址）控制方法是一个可选的 ACPI 对象，用于返回热插拔功能主机桥接器的 64 位内存映射配置基地址。_CBA 返回的基地址是处理器相关的地址。_CBA 控制方法返回一个整数。
    
    此控制方法出现在主机桥接器对象下。当 _CBA 方法出现在活动主机桥接器对象下时，操作系统会评估此结构以识别与 _CRS 方法中指定的总线编号范围对应的 PCI 段组的内存映射配置基地址。包含 _CBA 方法的 ACPI 命名空间对象也必须包含相应的 _SEG 方法。
