### SPDX 许可证标识符：GPL-2.0

========================================
ACPI 对 PCI 主机桥的考虑
========================================

一般规则是 ACPI 命名空间应该描述所有操作系统可能使用的内容，除非操作系统有其他方式来找到这些内容[1, 2]。例如，并没有标准硬件机制来枚举 PCI 主机桥，因此必须通过 ACPI 命名空间来描述每个主机桥、访问其下 PCI 配置空间的方法、主机桥转发给 PCI 的地址空间窗口（使用 _CRS）、以及传统 INTx 中断的路由（使用 _PRT）。

对于位于主机桥下的 PCI 设备，通常不需要通过 ACPI 来描述。操作系统可以通过标准的 PCI 枚举机制来发现它们，使用配置访问来发现和识别设备并读取和确定它们的 BAR 大小。然而，如果 ACPI 提供了针对这些设备的电源管理和热插拔功能，或者设备具有由平台中断控制器连接的传统 INTx 中断且需要 _PRT 来描述这些连接，则 ACPI 也可以描述 PCI 设备。

ACPI 资源描述是通过 ACPI 命名空间中设备的 _CRS 对象完成的[2]。_CRS 类似于一个泛化的 PCI BAR：操作系统可以读取 _CRS 并推断出正在消耗什么资源，即使它没有该设备的驱动程序[3]。这很重要，因为它意味着旧的操作系统即便在包含新设备的系统上也能正确工作，尽管这些新设备对操作系统来说是未知的。

新设备可能无法执行任何操作，但操作系统至少可以确保没有资源与它们冲突。
静态表（如 MCFG、HPET、ECDT 等）不是用于预留地址空间的机制。这些静态表是为了让操作系统能够在启动早期了解一些信息，在它可以解析 ACPI 命名空间之前。如果定义了一个新的表，旧的操作系统即使忽略了这个表也需要能够正确运行。_CRS 允许这样做，因为它通用并且被旧的操作系统理解；而静态表则做不到这一点。

如果预期操作系统将管理通过 ACPI 描述的不可发现设备，那么该设备将有一个特定的 _HID/_CID 来告诉操作系统应该绑定哪个驱动程序，而 _CRS 告诉操作系统及其驱动程序设备寄存器的位置。

PCI 主机桥是 PNP0A03 或 PNP0A08 设备。它们的 _CRS 应该描述它们消耗的所有地址空间。这包括它们转发到 PCI 总线的所有窗口，以及未转发到 PCI 的主机桥本身的寄存器。主机桥寄存器包括决定桥下方总线范围的次级/从属总线寄存器、描述孔径的窗口寄存器等。这些都是设备特有的、非架构化的东西，因此 PNP0A03/PNP0A08 驱动程序只能通过 _PRS/_CRS/_SRS 来管理它们，其中包含了设备特性的细节。主机桥寄存器还包括 ECAM 空间，因为它被主机桥消耗。

ACPI 定义了一个“消费者/生产者”位来区分桥寄存器（“消费者”）和桥孔径（“生产者”）[4, 5]，但是早期的 BIOS 没有正确使用这个位。结果是当前的 ACPI 规范仅针对扩展地址空间描述符定义了“消费者/生产者”，该位应在较老的 QWord/DWord/Word 地址空间描述符中被忽略。因此，操作系统必须假设所有的 QWord/DWord/Word 描述符都是窗口。
在加入扩展地址空间描述符之前，消费者/生产者机制的失败意味着没有方法可以在 PNP0A03/PNP0A08 设备本身中描述桥接寄存器（包括 ECAM 空间）。解决方法是在 PNP0C02 全局设备中描述这些桥接寄存器（包括 ECAM 空间）[6]。除了 ECAM 之外，桥接寄存器空间本身就是特定于设备的，因此通用的 PNP0A03/PNP0A08 驱动程序（pci_root.c）无需了解这部分内容。

新架构应该能够使用 PNP0A03 设备中的“消费者”扩展地址空间描述符来描述桥接寄存器（包括 ECAM），尽管对 [6] 的严格解释可能会禁止这样做。旧的 x86 和 ia64 内核假设所有地址空间描述符（包括“消费者”扩展地址空间描述符）都是窗口，因此在这些架构上以这种方式描述桥接寄存器是不安全的。
PNP0C02 “主板”设备基本上是一个全局设备。除了“不要将这些资源用于其他任何用途”之外，它们没有其他的编程模型。因此，一个 PNP0C02 的 _CRS 应该声明任何地址空间，前提是这些地址空间（1）没有被 ACPI 命名空间中的其他设备对象的 _CRS 所声明；并且（2）不应该由操作系统分配给其他用途。
PCIe 规范要求使用增强配置访问方法（ECAM），除非存在标准的固件接口用于配置访问，例如 ia64 的 SAL 接口 [7]。主机桥接器消耗 ECAM 内存地址空间，并将内存访问转换为 PCI 配置访问。规范定义了 ECAM 地址空间布局和功能；只有地址空间的基础部分是特定于设备的。ACPI 操作系统从静态 MCFG 表或 PNP0A03 设备中的 _CBA 方法中学习到基础地址。
MCFG 表必须描述非热插拔主机桥接器的 ECAM 空间 [8]。由于 MCFG 是一个静态表且不能通过热插拔更新，因此 PNP0A03 设备中的 _CBA 方法描述了热插拔主机桥接器的 ECAM 空间 [9]。需要注意的是，对于 MCFG 和 _CBA 来说，基础地址始终对应于总线 0，即使桥接器下的总线范围（通过 _CRS 报告）不从 0 开始也是如此。
[1] ACPI 6.2 第 6.1 节：
    对于任何位于不可枚举类型总线（例如 ISA 总线）上的设备，OSPM 枚举设备的标识符，并且 ACPI 系统固件必须为每个设备提供 _HID 对象... 以使 OSPM 能够执行此操作。
[2] ACPI 6.2 第 3.7 节：
    操作系统通过读取 ACPI 命名空间来枚举主板设备，寻找具有硬件 ID 的设备。
每个由 ACPI 枚举的设备都包含了 ACPI 定义的对象，在 ACPI 命名空间中报告设备可能占用的硬件资源 [_PRS]、报告设备当前使用的资源的 [_CRS] 对象以及用于配置这些资源的对象 [_SRS]。这些信息被 Plug and Play 操作系统（OSPM）用来配置设备。
[3] ACPI 6.2 第 6.2 节：
    OSPM 使用设备配置对象来为通过 ACPI 枚举的设备配置硬件资源。设备配置对象提供了关于当前及可能的资源需求、共享资源之间的关系以及配置硬件资源的方法的信息。
当 OSPM 枚举一个设备时，它调用 _PRS 来确定设备的资源需求。它也可能调用 _CRS 来找到设备当前的资源设置。利用这些信息，Plug and Play 系统确定设备应该消耗哪些资源，并通过调用设备的 _SRS 控制方法来设置这些资源。
在ACPI中，设备可以消耗资源（例如，传统键盘），提供资源（例如，专有的PCI桥接器），或两者兼而有之。除非另有说明，否则假定设备的资源是从设备层次结构中位于该设备上方的最近匹配资源中获取的。

[4] ACPI 6.2，第6.4.3.5.1节，2、3、4：
    QWord/DWord/Word 地址空间描述符（.1、.2、.3）
      通用标志：位 [0] 被忽略

    扩展地址空间描述符（.4）
      通用标志：位 [0] 消费者/生产者：

        * 1 – 此设备消耗此资源
        * 0 – 此设备产生并消耗此资源

[5] ACPI 6.2，第19.6.43节：
    ResourceUsage指定内存范围是否被此设备消耗（ResourceConsumer）或传递给子设备（ResourceProducer）。如果没有指定，则默认为ResourceConsumer。
    
[6] PCI固件3.2，第4.1.2节：
    如果操作系统不原生支持保留MMCFG区域，则必须由固件保留MMCFG区域。MCFG表或通过_CBA方法报告的地址范围（见第4.1.3节）必须通过声明主板资源的方式进行预留。对于大多数系统，主板资源将出现在ACPI命名空间的根目录下（在\_SB下），节点具有EISAID（PNP0C02）的_HID，并且这些资源不应在根PCI总线的_CRS中声明。这些资源可以选择性地作为预留内存返回到Int15 E820或EFIGetMemoryMap中，但必须始终通过ACPI作为主板资源报告。

[7] PCI Express 4.0，第7.2.2节：
    对于兼容PC的系统或没有实现允许访问配置空间的处理器架构特定固件接口标准的系统，需要ECAM，其定义参见本节。

[8] PCI固件3.2，第4.1.2节：
    MCFG表是一个ACPI表，用于传达非热插拔PCI段组范围内可供操作系统启动时使用的PCI段组的基本地址。这对于兼容PC的系统是必需的。
    MCFG表仅用于传达启动时系统可用的PCI段组对应的基本地址。

[9] PCI固件3.2，第4.1.3节：
    _CBA（内存映射配置基地址）控制方法是一个可选的ACPI对象，用于返回热插拔功能主机桥接器的64位内存映射配置基地址。_CBA返回的基地址是相对于处理器的地址。_CBA控制方法评估为一个整数。
    此控制方法出现在主机桥接器对象下。当_CBA方法出现在活动主机桥接器对象下时，操作系统评估此结构以识别与_CRS方法中指定的总线编号范围对应的PCI段组的内存映射配置基地址。包含_CBA方法的ACPI命名空间对象还必须包含相应的_SEG方法。
