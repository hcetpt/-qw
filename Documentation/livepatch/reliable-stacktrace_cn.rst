可靠的堆栈回溯
===================

本文档概述了关于可靠堆栈回溯的基本信息。
.. 目录:

.. contents:: :local:

1. 引言
===============

内核实时补丁一致性模型依赖于准确识别哪些函数可能具有活动状态，因此可能不适合进行补丁更新。一种识别哪些函数处于活动状态的方法是使用堆栈回溯。现有的堆栈回溯代码可能无法总是提供所有具有活动状态的函数的准确视图，并且那些对调试有帮助的最佳努力方法对于实时补丁来说是不安全的。实时补丁依赖于架构提供一个*可靠的*堆栈回溯，以确保它永远不会遗漏任何活动函数。
2. 要求
===============

架构必须实现其中一个可靠的堆栈回溯函数。使用CONFIG_ARCH_STACKWALK配置的架构必须实现'arch_stack_walk_reliable'，而其他架构则必须实现'save_stack_trace_tsk_reliable'。

主要地，可靠的堆栈回溯函数必须确保以下两种情况之一：

* 堆栈回溯包括任务可能返回的所有函数，并且返回码为零以表示该堆栈回溯是可靠的。
* 返回码非零以表示该堆栈回溯不可靠。

.. note::
   在某些情况下，从堆栈回溯中省略特定函数是合法的，但所有其他函数都必须报告。这些情况将在下面详细描述。

其次，可靠的堆栈回溯函数必须在堆栈或其他反向追踪状态损坏或不可靠的情况下保持稳健。该函数应尝试检测这种情况并返回非零错误码，并且不应陷入无限循环或以不安全的方式访问内存。具体的情况将在下面详细描述。
3. 编译时分析
========================

为了确保内核代码可以在所有情况下正确地进行反向追踪，架构可能需要验证代码是否按照反向追踪器预期的方式编译。例如，反向追踪器可能期望函数以有限的方式操纵堆栈指针，或者所有函数都使用特定的序言和尾声序列。具有此类要求的架构应使用objtool验证内核编译。
在某些情况下，解绕器（unwinder）可能需要元数据才能正确地进行解绕。必要时，应使用`objtool`在构建时生成这些元数据。

4. 考虑事项
===========

解绕过程因架构、其相应的过程调用标准和内核配置而异。本节描述了架构应该考虑的一些常见细节。

4.1 确定成功终止
----------------------

解绕可能会因为多种原因提前终止，包括：

* 栈或帧指针损坏
* 对于某些不常见场景缺乏解绕支持，或者解绕器中存在错误
* 动态生成的代码（例如eBPF）或外来代码（例如EFI运行时服务）未遵循解绕器期望的约定

为了确保这种情况不会导致函数从跟踪中被遗漏，即使其他检查未能捕捉到这些问题，强烈建议架构验证栈跟踪在预期的位置结束，例如：
* 在一个特定函数内结束，该函数是进入内核的入口点
* 在栈上的一个特定位置结束，该位置对于内核入口点是预期的
* 在一个特定的栈上结束，该栈对于内核入口点是预期的（例如，如果架构有独立的任务栈和IRQ栈）
4.2 识别可展开代码
-------------------------------

展开通常依赖于遵循特定约定的代码（例如，操作帧指针），但也可能有不遵循这些约定的代码，这些代码在展开器中可能需要特殊处理，例如：
* 异常向量和入口汇编代码
* 过程链接表（PLT）条目和veneer函数
* 弹跳代码（例如ftrace、kprobes）
* 动态生成的代码（例如eBPF、optprobe弹跳代码）
* 外部代码（例如EFI运行时服务）

为了确保这些情况不会导致某些函数从追踪中被遗漏，强烈建议架构明确标识已知可以可靠展开的代码，并拒绝从所有其他代码进行展开。

内核代码（包括模块和eBPF）可以通过`__kernel_text_address()`与外部代码区分开来。进行这种检查也有助于检测栈损坏。

架构可以通过多种方式识别被认为不可靠展开的内核代码，例如：
* 将此类代码放入特殊的链接器部分，并拒绝从这些部分中的任何代码进行回溯
* 使用边界信息识别特定部分的代码

4.3 在中断和异常中进行回溯
-------------------------------

在函数调用边界处，堆栈和其他回溯状态应处于一致状态，以便可靠地进行回溯，但在函数执行过程中可能并非如此。例如，在函数序言或尾声期间，帧指针可能是暂时无效的；或者在函数体中，返回地址可能保存在一个任意的通用寄存器中。对于某些架构，这可能会由于动态仪器化而在运行时发生变化。
如果在堆栈或其他回溯状态不一致的情况下发生中断或其他异常，可能无法可靠地进行回溯，并且无法确定这种回溯是否可靠。请参见下面的例子。
无法识别何时可以可靠地进行回溯的架构（或根本不可靠的情况）必须拒绝跨越异常边界的回溯。请注意，某些异常（如IRQ）可能可以可靠地回溯，而其他异常（如NMI）则可能不可靠。
能够识别何时可以可靠地进行回溯的架构（或没有这种情况的架构）应尝试跨越异常边界进行回溯，因为这样做可以防止不必要的暂停实时补丁一致性检查，并允许实时补丁转换更快完成。

4.4 返回地址的重写
--------------------

一些跳板会暂时修改函数的返回地址，以便在函数返回时通过返回跳板进行拦截，例如：
* ftrace跳板可能会修改返回地址，以便函数图跟踪可以拦截返回。
* kprobes（或optprobes）跳板可能会修改返回地址，以便kretprobes能够拦截返回
当这种情况发生时，原始的返回地址将不会出现在其通常的位置。对于那些不受实时修补影响的跳板，如果一个展开器可以可靠地确定原始返回地址，并且跳板不改变任何展开状态，则该展开器可以报告原始返回地址来代替跳板，并认为这是可靠的。否则，展开器必须将这些情况报告为不可靠。
在识别原始返回地址时需要特别小心，因为这条信息在整个入口跳板或返回跳板期间并不是始终处于一致的位置。例如，考虑x86_64的`return_to_handler`返回跳板：

```plaintext
SYM_CODE_START(return_to_handler)
        UNWIND_HINT_UNDEFINED
        subq  $24, %rsp

        /* 保存返回值 */
        movq %rax, (%rsp)
        movq %rdx, 8(%rsp)
        movq %rbp, %rdi

        call ftrace_return_to_handler

        movq %rax, %rdi
        movq 8(%rsp), %rdx
        movq (%rsp), %rax
        addq $24, %rsp
        JMP_NOSPEC rdi
SYM_CODE_END(return_to_handler)
```

当被跟踪函数运行时，栈上的返回地址指向`return_to_handler`的开始位置，而原始返回地址存储在任务的`cur_ret_stack`中。在这段时间内，展开器可以通过`ftrace_graph_ret_addr()`找到返回地址。
当被跟踪函数返回到`return_to_handler`时，栈上不再有返回地址，但原始返回地址仍然存储在任务的`cur_ret_stack`中。在`ftrace_return_to_handler()`中，原始返回地址从`cur_ret_stack`中移除，并由编译器临时移动到任意位置，然后返回到`rax`中。`return_to_handler`跳板将这个地址移到`rdi`中，然后跳转到该地址。
某些架构可能无法展开这样的序列，比如当`ftrace_return_to_handler()`已经从`cur_ret_stack`中移除了地址，并且返回地址的位置无法可靠地确定时。
建议架构在尚未返回到`return_to_handler`的情况下展开这种情况，但架构并不强制要求从`return_to_handler`中间展开，并可以将其报告为不可靠。架构也不要求从其他修改返回地址的跳板展开。

### 4.5 返回地址的模糊处理
------------------------------

有些跳板并不会重写返回地址以拦截返回，但会在短时间内破坏返回地址或其他展开状态。
例如，x86_64实现的optprobes通过JMP指令修补被探查的函数，该指令的目标是与之关联的optprobe跳板。当探查点被命中时，CPU将分支到optprobe跳板，并且被探查函数的地址既不在任何寄存器中，也不在栈上。
类似地，arm64实现的DYNAMIC_FTRACE_WITH_REGS通过以下方式修补被跟踪的函数：

```plaintext
MOV X9, X30
BL <trampoline>
```

MOV指令将链接寄存器（X30）保存到X9中，以在BL指令破坏链接寄存器并分支到跳板之前保留返回地址。在跳板的开始处，被跟踪函数的地址位于X9中，而不是像通常情况下位于链接寄存器中。
架构必须确保展开器要么可靠地展开此类情况，要么将展开报告为不可靠。
4.6 链接寄存器的不可靠性
-------------------------------

在某些其他架构中，`call` 指令将返回地址存储到链接寄存器中，而 `return` 指令则从链接寄存器中读取返回地址而不修改该寄存器。在这种架构下，软件必须在进行函数调用之前将返回地址保存到栈中。在一个函数调用期间，返回地址可能仅存储在链接寄存器中、仅存储在栈中，或者同时存储在这两个位置。反向解析器（Unwinders）通常假定链接寄存器始终有效，但这一假设可能导致堆栈跟踪结果的不可靠。例如，考虑以下arm64汇编代码的一个简单函数：

.. code-block:: none

   function:
           STP X29, X30, [SP, -16]!
           MOV X29, SP
           BL <other_function>
           LDP X29, X30, [SP], #16
           RET

在进入此函数时，链接寄存器（x30）指向调用者，而帧指针（X29）指向调用者的帧，包括调用者的返回地址。前两条指令创建了一个新的栈帧并更新了帧指针，在这一点上，链接寄存器和帧指针都描述了这个函数的返回地址。在这个点上的跟踪可能会重复描述这个函数两次，并且如果正在跟踪函数返回，则反向解析器可能会从fgraph返回栈中消费两个条目而不是一个条目。

BL 调用 `other_function` 时，链接寄存器指向此函数的 LDR，帧指针指向此函数的栈帧。当 `other_function` 返回时，链接寄存器仍然指向 BL，因此在这个点上的跟踪可能会导致 `function` 在回溯中出现两次。

同样地，一个函数可能会故意破坏 LR，例如：

.. code-block:: none

   caller:
           STP X29, X30, [SP, -16]!
           MOV X29, SP
           ADR LR, <callee>
           BLR LR
           LDP X29, X30, [SP], #16
           RET

ADR 将 `callee` 的地址放入 LR 中，然后 BLR 分支到这个地址。如果在 ADR 之后立即进行跟踪，`callee` 会看起来是 `caller` 的父函数，而不是子函数。

由于上述情况，可能只能在函数调用边界可靠地消费链接寄存器的值。对于这种情况下的架构，必须拒绝跨越异常边界的反向解析，除非它们能够可靠地识别何时应该使用 LR 或栈的值（例如通过 objtool 生成的元数据）。
