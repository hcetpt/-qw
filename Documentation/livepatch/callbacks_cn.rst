======================
(卸载/安装)回调函数
======================

实时补丁 (卸载/安装)回调提供了一种机制，使实时补丁模块在内核对象被(卸载/安装)时执行回调函数。它们可以被认为是一个**高级功能**，**扩展了实时补丁的能力**，包括：

  - 安全更新全局数据

  - 对初始化和探测函数进行“补丁”处理

  - 补丁处理其他无法补丁的代码（例如汇编语言）

在大多数情况下，(卸载/安装)回调需要与内存屏障和内核同步原语一起使用，如互斥锁/自旋锁，甚至stop_machine()，以避免并发问题。

1. 动机
=============

回调与现有的内核设施不同：

  - 在禁用和重新启用补丁时，模块的初始化/退出代码不会运行。
  - 模块通知器无法阻止待补丁的模块加载。

回调是klp_object结构的一部分，并且其实现特定于该klp_object。其他实时补丁对象可能会或可能不会被补丁处理，这与目标klp_object的当前状态无关。

2. 回调类型
=============

可以为以下实时补丁操作注册回调：

  * 预补丁
         - 在klp_object被补丁之前

  * 后补丁
         - 在klp_object已经被补丁并活跃于所有任务之后

  * 预卸载补丁
         - 在klp_object被卸载补丁之前（即，补丁后的代码仍然活跃），用于清理后补丁回调资源

  * 后卸载补丁
         - 在klp_object已经被卸载补丁，所有代码都已恢复并且没有任务运行补丁后的代码，用于清理预补丁回调资源

3. 工作原理
=============

每个回调都是可选的，省略一个并不妨碍指定其他的。然而，实时补丁核心以对称的方式执行处理器：预补丁回调有一个后卸载补丁的对应部分，后补丁回调有一个预卸载补丁的对应部分。一个卸载补丁回调只有在其对应的补丁回调被执行的情况下才会执行。典型的应用案例是将一个获取和配置资源的补丁处理器与其拆除和释放这些资源的卸载补丁处理器配对。

一个回调只有在其宿主klp_object被加载时才会执行。对于内核vmlinux目标而言，这意味着当启用/禁用实时补丁时，回调始终会执行。对于补丁目标内核模块，回调只有在目标模块被加载时才会执行。当模块目标被(加载/卸载)时，如果实时补丁模块被启用，则其回调才会执行。

如果指定了预补丁回调，则期望返回一个状态码（0表示成功，-ERRNO表示错误）。错误状态码指示实时补丁核心当前klp_object的补丁处理不安全，并停止当前的补丁请求。（如果没有提供预补丁回调，则假定转换是安全的。）如果预补丁回调返回失败，内核的模块加载器将：

  - 如果实时补丁在目标代码之后加载，则拒绝加载实时补丁
或：
  - 如果实时补丁已经成功加载，则拒绝加载模块

如果由于预补丁回调失败或其他原因导致klp_object未能补丁处理，则不会执行给定klp_object的任何后补丁、预卸载补丁或后卸载补丁回调。

如果补丁转换被反转，则不会运行任何预卸载处理器（这遵循前面提到的对称性——预卸载回调只有在其对应的后补丁回调执行时才会发生）。
如果对象成功打补丁，但由于某些原因（例如，另一个对象未能打补丁）补丁转换从未开始，则只会调用 post-unpatch 回调。

4. 使用场景
============

展示回调 API 的示例实时补丁模块可以在 samples/livepatch/ 目录中找到。这些示例已修改用于 kselftests，并且可以在 lib/livepatch 目录中找到。
全局数据更新
------------------

在打补丁前的回调可以用来更新一个全局变量。例如，提交 75ff39ccc1bd ("tcp: 使挑战确认变得不那么可预测") 修改了一个全局 sysctl，并且对 tcp_send_challenge_ack() 函数进行了打补丁。
在这种情况下，如果我们非常谨慎，可以使用打补丁后的回调来更新数据，以便在打补丁完成后更新数据，这样 tcp_send_challenge_ack() 可以首先被修改为使用 READ_ONCE 读取 sysctl_tcp_challenge_ack_limit。

__init 和 probe 函数打补丁支持
-----------------------------------------

尽管 __init 和 probe 函数本身不能直接进行实时补丁处理，但可能通过预打补丁/后打补丁回调实现类似的更新。
提交 48900cb6af42 ("virtio-net: 删除 NETIF_F_FRAGLIST") 改变了 virtnet_probe() 初始化其驱动程序的 net_device 特性的方式。一个预/后打补丁回调可以遍历所有这样的设备，对其 hw_features 值做出类似的更改。（该值的客户端函数可能需要相应地进行更新。）
