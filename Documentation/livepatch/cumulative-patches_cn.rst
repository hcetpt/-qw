原子替换与累积补丁
==================

各个热补丁之间可能存在依赖关系。如果多个补丁需要对同一个函数进行不同的修改，则需要定义一个安装顺序。任何较新的热补丁中的函数实现必须基于较旧的补丁完成。这可能会成为一个维护噩梦，尤其是在多个补丁以不同方式修改了同一个函数的情况下。

一个优雅的解决方案是“原子替换”功能。它允许创建所谓的“累积补丁”。这些累积补丁包含了所有旧热补丁中所需的所有更改，并在一次转换中完全替换它们。
用法
-----

可以通过在 `struct klp_patch` 中设置 `replace` 标志来启用原子替换功能，例如：

```c
static struct klp_patch patch = {
	.mod = THIS_MODULE,
	.objs = objs,
	.replace = true,
};
```

所有进程随后将迁移到仅使用新补丁中的代码。一旦转换完成，所有旧补丁将自动禁用。

Ftrace 处理器会从不再被新累积补丁修改的函数中透明地移除。

结果是，热补丁作者只需维护一个累积补丁的源代码。这有助于在添加或删除各种修复或功能时保持补丁的一致性。

用户可以在转换完成后仅保留系统中最后一个补丁。这有助于清晰地看到实际使用的代码。此外，热补丁可以被视为一个“正常”的模块，用于修改内核行为。唯一的区别是在不破坏其功能的情况下可以在运行时更新它。
特性
--------

原子替换功能允许：

  - 在升级其他函数的同时，原子地恢复前一个补丁中的某些函数
  - 移除因不再被修补的函数而导致的核心重定向带来的性能影响
减少用户对实时补丁之间依赖关系的困惑。

限制：
------------

- 一旦操作完成，就没有简单的方法来逆转它并原子性地恢复被替换的补丁。
一个好的做法是在发布的实时补丁中设置 `.replace` 标志。然后重新添加旧的实时补丁相当于降级到该补丁。只要实时补丁不在 (un)patching 回调或 module_init() 或 module_exit() 函数中进行额外的修改，这是安全的，详见下文。
还需注意的是，只有在转换未被强制的情况下，被替换的补丁才能被移除并重新加载。
- 只执行来自新的累积实时补丁的 (un)patching 回调。任何被替换补丁中的回调都会被忽略。
换句话说，累积补丁负责执行所有必要的操作以正确替换任何旧补丁。
因此，用旧的累积补丁替换新的累积补丁可能是危险的。旧的实时补丁可能不提供必要的回调。
这在某些场景中可能被视为一个限制。但在许多其他情况下，这样做使事情变得更容易。只有新的累积实时补丁知道哪些修复/功能被添加/移除，并且需要哪些特殊操作来实现平滑过渡。
无论如何，如果所有启用的补丁的回调都被调用，考虑这些回调的顺序及其相互作用将是一场噩梦。
没有对影子变量进行特殊处理。Livepatch作者必须自行创建规则，以确定如何将它们从一个累积补丁传递到另一个累积补丁。特别是，他们不应在`module_exit()`函数中盲目地移除这些变量。

一个好的做法可能是在post-unpatch回调中移除影子变量。这个回调仅在livepatch被正确禁用时调用。
