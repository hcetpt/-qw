Livepatch
=========

本文档概述了内核热补丁的基本信息。
.. 目录:

.. contents:: :local:


1. 动机
=============

在许多情况下，用户不愿意重启系统。这可能是因为他们的系统正在进行复杂的科学计算或在高峰使用期间承受重负载。除了保持系统的正常运行外，用户还希望系统稳定且安全。热补丁通过允许重定向函数调用实现了这两点，从而无需重启系统即可修复关键功能。
2. Kprobes、Ftrace、热补丁
================================

Linux 内核中有多种机制与代码执行的重定向直接相关；即：内核探针、函数追踪和热补丁：

  - 内核探针是最通用的。代码可以通过在任何指令处插入断点指令来重定向。
  - 函数追踪器从靠近函数入口的位置调用代码。这个位置由编译器使用 '-pg' 的 gcc 选项生成。
  - 热补丁通常需要在函数入口处非常早的地方重定向代码，在函数参数或栈被修改之前。
所有三种方法都需要在运行时修改现有代码。因此，它们需要相互了解，并避免互相干扰。
这些问题大多数通过使用动态 ftrace 框架作为基础得以解决。当函数入口被探测时，Kprobe 会注册为 ftrace 处理程序，请参阅 CONFIG_KPROBES_ON_FTRACE。同样，来自热补丁的替代函数也通过自定义的 ftrace 处理程序调用。但存在一些限制，请参见下文。
3. 一致性模型
====================

函数的存在有其原因。它们接受一些输入参数，获取或释放锁，以定义的方式读取、处理甚至写入某些数据，并具有返回值。换句话说，每个函数都有一个定义好的语义。
许多修复并没有改变被修改函数的语义。例如，它们添加了空指针检查或边界检查，通过添加缺失的记忆屏障修复竞态条件，或者在关键部分周围增加一些锁定。
这些更改大多数是自包含的，并且函数对系统其余部分的表现方式相同。在这种情况下，可以独立地逐个更新这些函数。
但也有更复杂的修复方法。例如，一个补丁可能同时改变多个函数中的锁顺序。或者，一个补丁可能会更改某些临时结构的含义，并更新所有相关的函数。在这种情况下，受影响的单元（线程、整个内核）需要同时开始使用所有新版本的函数。此外，这种切换必须在安全的情况下进行，例如当受影响的锁被释放时，或在修改的结构中没有存储数据时。

如何以安全方式应用函数的理论相当复杂。目标是定义所谓的“一致性模型”。这一模型试图定义在何种条件下可以使用新的实现，从而确保系统保持一致。

Livepatch 的一致性模型结合了 kGraft 和 kpatch 的特点：它使用 kGraft 的按任务一致性及系统调用屏障切换，结合 kpatch 的堆栈跟踪切换。此外，还有许多回退选项使其非常灵活。

补丁按任务逐个应用，在任务被认为安全时进行切换。当启用一个补丁时，livepatch 进入一个过渡状态，在此状态下任务逐渐向打过补丁的状态收敛。通常这种过渡状态可以在几秒钟内完成。当禁用一个补丁时，也会发生相同的序列，只是任务从打过补丁的状态向未打补丁的状态收敛。

中断处理程序继承其中断的任务的打补丁状态。对于分叉的任务也是如此：子任务继承父任务的打补丁状态。

Livepatch 使用几种互补的方法来确定何时安全地为任务打补丁：

1. 第一种也是最有效的方法是对休眠任务的堆栈进行检查。如果给定任务的堆栈中没有受影响的函数，则对该任务打补丁。在大多数情况下，这种方法第一次尝试就能为大多数或全部任务打补丁。否则，它会定期继续尝试。此选项仅在架构支持可靠堆栈时可用（HAVE_RELIABLE_STACKTRACE）。
2. 如果需要，第二种方法是内核退出切换。当任务从系统调用、用户空间 IRQ 或信号返回用户空间时，对其进行切换。在以下情况下此方法有用：
   a) 为在受影响函数上休眠的 I/O 密集型用户任务打补丁。在这种情况下，必须发送 SIGSTOP 和 SIGCONT 以迫使其退出内核并被打补丁。
   b) 为 CPU 密集型用户任务打补丁。如果任务高度依赖 CPU，则会在下次被 IRQ 中断时被打补丁。
3. 对于空闲的“交换”任务，由于它们不会退出内核，因此在空闲循环中有一个 `klp_update_patch_state()` 调用，这允许它们在 CPU 进入空闲状态之前进行修补。（注意，目前还没有针对 kthreads 的类似方法。）

没有 `HAVE_RELIABLE_STACKTRACE` 的架构完全依赖于第二种方法。很有可能某些任务在该函数返回之前仍会以旧版本运行。在这种情况下，你需要向这些任务发送信号。这一点尤其适用于 kthreads。它们可能不会被唤醒，并需要强制唤醒。更多信息请参见下文。

除非我们能找到另一种修补 kthreads 的方法，否则没有 `HAVE_RELIABLE_STACKTRACE` 的架构不被视为完全支持内核实时修补。
`/sys/kernel/livepatch/<patch>/transition` 文件显示了一个补丁是否处于过渡状态。一次只能有一个补丁处于过渡状态。如果任何任务卡在初始修补状态，则补丁可以无限期地保持过渡状态。

可以通过在补丁过渡期间将相反的值写入 `/sys/kernel/livepatch/<patch>/enabled` 文件来逆转并有效地取消过渡。然后所有任务将尝试恢复到原始的修补状态。

还有一个 `/proc/<pid>/patch_state` 文件，可用于确定哪些任务阻止了修补操作的完成。
如果补丁处于过渡状态，此文件显示 0 表示任务未修补，显示 1 表示已修补。否则，如果没有补丁处于过渡状态，则显示 -1。任何阻止过渡的任务都可以通过发送 `SIGSTOP` 和 `SIGCONT` 来强制其改变修补状态。然而，这可能会对系统造成损害。向所有剩余的阻塞任务发送一个假信号是一个更好的替代方案。实际上并没有真正的信号被发送（信号待处理结构中没有数据）。任务会被中断或唤醒，并被迫改变其修补状态。假信号每 15 秒自动发送一次。

管理员还可以通过 `/sys/kernel/livepatch/<patch>/force` 属性影响过渡。在此处写入 1 可清除所有任务的 `TIF_PATCH_PENDING` 标志，从而强制任务进入已修补状态。重要提示！force 属性仅适用于过渡长时间停滞的情况，因为存在阻塞任务。管理员应收集所有必要的数据（特别是阻塞任务的堆栈跟踪），并向补丁分发者请求许可以强制过渡。未经授权的使用可能会对系统造成损害。这取决于补丁的性质、哪些函数被（取消）修补以及阻塞任务在哪些函数中休眠（`/proc/<pid>/stack` 可能对此有帮助）。当使用 force 功能时，永久禁用移除（rmmod）补丁模块。无法保证没有任务在这样的模块中休眠。这意味着如果补丁模块在循环中被禁用和启用，引用计数将是无界的。

此外，使用 force 还可能影响未来的实时补丁应用，并对系统造成更大的损害。管理员首先应考虑简单地取消过渡（参见上文）。如果使用了 force，应计划重启且不再应用实时补丁。
### 3.1 在新架构中添加一致性模型支持
---------------------------------------------

为了在新架构中添加一致性模型支持，有几种选择：

1) 添加CONFIG_HAVE_RELIABLE_STACKTRACE。这意味着需要移植objtool，并且对于非DWARF解绕器（unwinders），还需要确保堆栈追踪代码能够在堆栈上检测到中断。
2) 另一种选择是确保每个kthread在其安全位置调用klp_update_patch_state()。kthread通常在一个无限循环中重复执行某个操作。将kthread的补丁状态切换到一个安全位置应该是在循环中的某个指定点，此时没有锁定，并且所有数据结构都处于明确定义的状态。
使用workqueues或kthread worker API时，这个位置是很清楚的。这些kthread在一个通用循环中处理独立的操作。而对于具有自定义循环的kthread来说，这个安全位置必须根据具体情况仔细选择。
在这种情况下，没有HAVE_RELIABLE_STACKTRACE的架构仍然可以使用一致性模型中不依赖堆栈检查的部分：
a) 当用户任务跨越内核/用户空间边界时进行补丁处理；
b) 在其指定的补丁点对kthread和空闲任务进行补丁处理。
这个选项不如选项1好，因为它要求信号通知用户任务并唤醒kthread来进行补丁处理。但对于那些还没有可靠堆栈跟踪的架构来说，这仍然是一个好的备选方案。

### 4. 实时补丁模块
==================

实时补丁通过内核模块分发，详见samples/livepatch/livepatch-sample.c。
该模块包含我们想要替换的新函数实现。此外，它定义了一些描述原始实现与新实现之间关系的结构。然后有代码使内核在加载实时补丁模块时开始使用新的代码。在卸载实时补丁模块之前还有清理代码。以下各节将详细说明这些内容。

#### 4.1 新函数
------------------

新版本的函数通常是从原始源码复制而来。一个良好的做法是给它们的名字加上前缀，以便于区分原始函数，例如在回溯（backtrace）中。同时，这些函数可以声明为静态的，因为它们不是直接被调用的，不需要全局可见性。
该补丁仅包含真正被修改的函数。但是，这些修改可能需要访问原始源文件中的函数或数据，而这些函数或数据可能仅在本地可访问。这可以通过生成的livepatch模块中的特殊重定位节来解决，详见`Documentation/livepatch/module-elf-format.rst`以获取更多详细信息。

### 4.2 元数据
-------------

补丁由多个结构描述，这些结构将信息分为三个层次：

- `struct klp_func` 定义了每个被修补的函数。它描述了特定函数的原始实现与新实现之间的关系。
  - 结构中包括原始函数的名称（作为字符串）。
  - 函数地址通过 kallsyms 在运行时查找。
  - 然后包括新函数的地址。它是通过直接赋值函数指针定义的。需要注意的是，新函数通常定义在同一源文件中。
  - 作为一个可选参数，可以在 kallsyms 数据库中使用符号的位置来消除同名函数的歧义。这不是数据库中的绝对位置，而是仅针对特定对象（vmlinux 或内核模块）找到的顺序。需要注意的是，kallsyms 允许根据对象名称搜索符号。

- `struct klp_object` 定义了同一对象中的一个修补函数数组（`struct klp_func`）。这里的对象可以是 vmlinux（NULL）或模块名称。
  - 该结构有助于将每个对象的函数分组和处理在一起。需要注意的是，修补后的模块可能会比补丁本身加载得晚，并且相关的函数可能只有在它们可用时才会被修补。

- `struct klp_patch` 定义了一个修补对象数组（`struct klp_object`）。
  - 该结构一致地、最终同步地处理所有修补函数。整个补丁仅在找到所有修补符号时才应用。唯一的例外是没有加载的对象（内核模块）中的符号。
### 有关补丁如何在每个任务基础上应用的更多细节，请参见“一致性模型”部分

### 5. 实时补丁生命周期
#### ==================

实时补丁可以通过五个基本操作来描述：加载、启用、替换、禁用和移除。其中，替换和禁用操作是互斥的。它们对给定补丁的结果相同，但对系统来说结果不同。

#### 5.1. 加载
------------

唯一合理的方式是在加载实时补丁内核模块时启用补丁。为此，需要在`module_init()`回调中调用`klp_enable_patch()`。主要有两个原因：

首先，只有该模块能够轻松访问相关的`struct klp_patch`结构。
其次，在补丁无法启用的情况下，可以使用错误代码拒绝加载该模块。

#### 5.2. 启用
-------------

通过在`module_init()`回调中调用`klp_enable_patch()`来启用实时补丁。在这个阶段，系统将开始使用修补函数的新实现。

首先，根据函数名称查找被修补函数的地址。应用在“新函数”部分提到的特殊重定位。在`/sys/kernel/livepatch/<name>`下创建相关条目。如果上述任何操作失败，则拒绝该补丁。

其次，实时补丁进入过渡状态，在此状态下任务逐渐趋向于修补状态。如果某个原始函数首次被修补，则会创建一个特定于该函数的`struct klp_ops`，并注册一个通用的ftrace处理器\ [#]_。这一阶段由`/sys/kernel/livepatch/<name>/transition`中的值为`1`表示。有关此过程的更多信息，请参见“一致性模型”部分。

最后，一旦所有任务都被修补完毕，`transition`值将变为`0`。

.. [#]
    
    注意，函数可能会被多次修补。对于给定的函数，ftrace处理器仅注册一次。后续的补丁只是向`struct klp_ops`中的列表（参见字段`func_stack`）添加条目。
正确的实现由 ftrace 处理程序选择，请参阅“一致性模型”部分。

尽管如此，强烈建议使用累积型实时补丁，因为它们有助于保持所有更改的一致性。在这种情况下，函数可能仅在过渡期间被修补两次。

5.3 替换
--------

所有已启用的补丁可能会被设置了 `.replace` 标志的累积型补丁替换。
一旦新的补丁被启用并且“过渡”完成，则与被替换的补丁相关的所有函数（struct klp_func）将从相应的 struct klp_ops 中移除。此外，ftrace 处理程序会被注销，并且当相关函数未被新补丁修改且 func_stack 列表变为空时，struct klp_ops 会被释放。

更多详细信息请参见 Documentation/livepatch/cumulative-patches.rst。

5.4 禁用
--------

已启用的补丁可以通过写入 '0' 到 /sys/kernel/livepatch/<name>/enabled 来禁用。
首先，实时补丁进入一个过渡状态，在此状态下任务会收敛到未打补丁的状态。系统开始使用之前启用的补丁代码甚至原始代码。这个阶段通过 /sys/kernel/livepatch/<name>/transition 的值为 '1' 来表示。

有关此过程的更多信息，请参阅“一致性模型”部分。

其次，一旦所有任务都已取消补丁，“transition”值会变为 '0'。所有与即将禁用的补丁相关的函数（struct klp_func）将从相应的 struct klp_ops 中移除。ftrace 处理程序会被注销，并且当 func_stack 列表变为空时，struct klp_ops 会被释放。

最后，sysfs 接口会被销毁。
### 5.5 移除

模块移除只有在没有使用该模块提供的函数时才是安全的。这就是为什么强制特性永久禁用移除的原因。只有当系统成功过渡到新的补丁状态（已打补丁/未打补丁）而没有被强制时，才能保证没有任何任务在旧代码中休眠或运行。

### 6. Sysfs

有关注册补丁的信息可以在 `/sys/kernel/livepatch` 下找到。可以通过写入这些路径来启用和禁用补丁：

```
/sys/kernel/livepatch/<patch>/force
```

管理员可以通过这些属性影响补丁操作。更多详细信息请参阅 `Documentation/ABI/testing/sysfs-kernel-livepatch`。

### 7. 限制

当前的实时补丁实现有以下几个限制：

- 只能修补可以被跟踪的函数。实时补丁基于动态 ftrace。特别是，实现 ftrace 或实时补丁 ftrace 处理器的函数不能被修补。否则，代码会陷入无限循环。潜在的错误通过标记有问题的函数为“notrace”来防止。
- 实时补丁仅在动态 ftrace 位于函数开头时可靠工作。函数需要在修改栈或函数参数之前进行重定向。例如，在 x86_64 上，实时补丁要求使用 `-fentry` gcc 编译器选项。
- 一个例外是 PPC 端口。它使用相对寻址和 TOC。每个函数在调用 ftrace 处理器之前必须处理 TOC 并保存 LR。此操作必须在返回时恢复。
幸运的是，通用的 ftrace 代码存在同样的问题，并且所有这些问题都在 ftrace 层面得到了处理。
- 使用 ftrace 框架的 kretprobes 与被修补的函数冲突。
kretprobes 和 livepatches 都使用了一个修改返回地址的 ftrace 处理器。先使用的用户获胜。如果处理器已经被另一个使用，那么要么是探针被拒绝，要么是补丁被拒绝。
- 当代码被重定向到新实现时，原始函数中的 kprobes 被忽略。
目前有一个正在进行的工作，旨在增加关于这种情况的警告。
