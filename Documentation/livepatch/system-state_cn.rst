====================
系统状态变更
====================

一些用户非常不愿意重启系统。这导致了提供更多的热补丁并保持它们之间的兼容性的需求增加。维护更多的热补丁在使用累积热补丁时会变得容易得多。每个新的热补丁完全替换任何旧的热补丁。它可以保留、添加甚至移除修复内容。通常情况下，由于原子替换功能，可以安全地用任何一个版本的热补丁替换另一个版本的热补丁。问题可能出现在影子变量和回调函数上。它们可能会改变系统的行为或状态，使得回退到使用旧的热补丁或原始内核代码不再安全。此外，任何新的热补丁都必须能够检测已经安装的热补丁所做的更改。

这就是热补丁系统状态跟踪变得有用的地方。它允许：

  - 存储用于操作和恢复系统状态所需的数据

  - 使用变更ID和版本定义热补丁之间的兼容性


1. 热补丁系统状态API
=============================

系统状态可能由多个热补丁回调或新使用的代码修改。还必须能够找到已安装热补丁所做的更改。每个修改的状态由结构体klp_state描述，见include/linux/livepatch.h。
每个热补丁定义了一个结构体klp_state数组。它们指出了热补丁修改的所有状态。
热补丁作者必须为每个结构体klp_state定义以下两个字段：

  - *id*

    - 用于标识受影响系统状态的非零数字
  - *version*

    - 描述给定热补丁支持的系统状态变更变体的数字
可以通过以下两个函数来操作状态：

  - klp_get_state()

    - 获取与给定热补丁和状态ID关联的结构体klp_state
### klp_get_prev_state()

- 获取与给定功能ID和已安装的实时补丁关联的`klp_state`结构体

### 实时补丁兼容性
==========================

系统状态版本用于防止加载不兼容的实时补丁。检查在启用实时补丁时进行。规则如下：

  - 允许任何全新的系统状态修改。
- 对于已经修改过的系统状态，允许相同或更高版本的系统状态修改。
- 累积型实时补丁必须处理所有来自已安装实时补丁的系统状态修改。
- 非累积型实时补丁允许触碰已经修改过的系统状态。

### 支持的场景
======================

实时补丁有其生命周期，系统状态的变化也是如此。每个兼容的实时补丁需要支持以下场景：

  - 当实时补丁启用且状态尚未被正在替换的实时补丁修改时，修改系统状态。
- 当系统状态已经被正在替换的实时补丁修改时，接管或更新该修改。
- 当实时补丁禁用时，恢复原始状态。
- 当转换被撤销时，恢复之前的状态。
### 可能是原始系统状态或由即将被替换的实时补丁所做的状态修改

- 当发生错误且实时补丁无法启用时，移除所有已做的更改

### 预期使用
系统状态通常由实时补丁回调函数进行修改。每个回调函数的预期作用如下：

*pre_patch()*

  - 在必要时分配 *state->data*。分配可能会失败，而 *pre_patch()* 是唯一可以阻止加载实时补丁的回调函数。如果数据已经由先前安装的实时补丁提供，则不需要此分配。
  - 执行新代码在转换完成之前所需的任何其他预备操作。例如，初始化 *state->data*。

系统状态本身通常在 *post_patch()* 中进行修改，此时整个系统能够处理这些修改。
- 在发生错误时清理自己的“烂摊子”。这可以通过自定义代码或显式调用 *post_unpatch()* 来实现。

*post_patch()*

  - 如果 *state->data* 兼容，则从之前的实时补丁中复制 *state->data*。
  - 进行实际的系统状态修改。最终允许新代码使用这些修改。
  - 确保 *state->data* 包含所有必要的信息。
```plaintext
在不再需要时释放 *state->data*，以移除已替换的实时补丁
*pre_unpatch()*

  - 防止由实时补丁添加的代码依赖于系统状态的变化

- 撤销系统状态的修改。
*post_unpatch()*

  - 通过检查 *klp_get_prev_state()* 来区分状态反转和实时补丁禁用
- 在状态反转的情况下，恢复之前的系统状态。这可能意味着什么都不做
- 移除任何不再需要的设置或数据
.. note::

   *pre_unpatch()* 通常执行与 *post_patch()* 对称的操作
   但仅在实时补丁被禁用时调用
   因此它不需要关心之前安装的任何实时补丁
*post_unpatch()* 通常执行与 *pre_patch()* 对称的操作
```

希望这个翻译对你有帮助！如果还有其他问题，请随时告诉我。
它也可能在转换过程中被调用。因此，它需要处理之前安装的实时补丁的状态。
