SPDX 许可证标识符: GPL-2.0

============================
Ceph 分布式文件系统
============================

Ceph 是一个分布式网络文件系统，旨在提供良好的性能、可靠性和可扩展性。
基本功能包括：

 * POSIX 语义
 * 无缝扩展从 1 台到数千台节点
 * 高可用性和可靠性。无单点故障
 * 数据在存储节点之间多路复制
 * 快速从节点故障中恢复
 * 节点添加/移除时自动重新平衡数据
 * 易于部署：大多数文件系统组件都是用户空间守护进程

此外，

 * 灵活的快照（任何目录）
 * 递归计数（嵌套文件、目录、字节）

与依赖所有客户端对共享块设备进行对称访问的集群文件系统（如 GFS、OCFS2 和 GPFS）不同，Ceph 将数据和元数据管理分离为独立的服务器集群，类似于 Lustre。然而，与 Lustre 不同的是，元数据和存储节点完全作为用户空间守护进程运行。文件数据被分成大块条带化存储在存储节点上，以分散工作负载并促进高吞吐量。当存储节点发生故障时，数据会通过存储节点自身以分布式的方式重新复制（由集群监控器进行少量协调），这使得系统极其高效且可扩展。元数据服务器有效地形成一个位于文件命名空间之上的大型、一致的分布式内存缓存，该缓存在应对工作负载变化时能够动态重新分配元数据，并能容忍任意（非拜占庭式的）节点故障。元数据服务器采用了一种非常规的方法来存储元数据，从而显著提高了常见工作负载下的性能。特别是，只有单一链接的inode嵌入到目录中，允许整个目录中的目录项和inode通过一次I/O操作加载到其缓存中。极大规模目录的内容可以被分片并由独立的元数据服务器管理，从而实现可扩展的并发访问。

该系统在从小规模几台节点扩展到数百台节点时提供了自动的数据重新平衡/迁移，无需管理员将数据集划分为静态卷或经历繁琐的数据迁移过程。当文件系统接近满载时，可以轻松添加新节点，一切将“即刻生效”。

Ceph 包含一种灵活的快照机制，允许用户在系统的任何子目录（及其嵌套内容）上创建快照。快照的创建和删除就像执行 `'mkdir .snap/foo'` 和 `'rmdir .snap/foo'` 一样简单。快照名称有以下两个限制：

 * 不能以下划线 ('_') 开头，因为这些名称被 MDS 保留用于内部使用
 * 不能超过 240 个字符。这是因为 MDS 内部使用长快照名称，格式为 `_<SNAPSHOT-NAME>_<INODE-NUMBER>`。由于一般文件名不能超过 255 个字符，而 `<node-id>` 占用 13 个字符，因此长快照名称最多可以达到 255 - 1 - 1 - 13 = 240 个字符

Ceph 还提供了一些针对目录的递归计数功能，支持嵌套文件和字节的统计。你可以运行以下命令：

```
getfattr -n ceph.dir.rfiles /some/dir
getfattr -n ceph.dir.rbytes /some/dir
```

分别获取嵌套文件总数和它们的总大小。这使得识别大磁盘空间占用者相对迅速，无需执行 'du' 或类似的文件系统递归扫描。
最后，Ceph 还允许在系统中的任何目录上设置配额。配额可以限制存储在该目录层次结构下的字节数或文件数。配额可以通过扩展属性 'ceph.quota.max_files' 和 'ceph.quota.max_bytes' 来设置，例如：

```
setfattr -n ceph.quota.max_bytes -v 100000000 /some/dir
getfattr -n ceph.quota.max_bytes /some/dir
```

当前配额实现的一个限制是它依赖于挂载文件系统的客户端的合作，在达到限制时停止写入者。修改过的或恶意的客户端无法被阻止写入其所需的数据。

### 挂载语法
基本的挂载语法如下：

```
# mount -t ceph user@fsid.fs_name=/[subdir] mnt -o mon_addr=monip1[:port][/monip2[:port]]
```

您只需要指定一个监视器，因为客户端在连接时会获取完整的列表。（然而，如果您指定的监视器碰巧离线，则挂载不会成功。）如果监视器使用默认端口，则可以省略端口。因此，如果监视器位于 1.2.3.4：

```
# mount -t ceph cephuser@07fe3187-00d9-42a3-814b-72a4d5e7d5be.cephfs=/ /mnt/ceph -o mon_addr=1.2.3.4
```

就足够了。如果安装了 `/sbin/mount.ceph`，可以使用主机名代替 IP 地址，并且可以省略集群的 FSID（因为挂载助手会通过读取 Ceph 配置文件来填充它）：

```
# mount -t ceph cephuser@cephfs=/ /mnt/ceph -o mon_addr=mon-addr
```

多个监视器地址可以通过每个地址之间用斜杠 (`/`) 分隔：

```
# mount -t ceph cephuser@cephfs=/ /mnt/ceph -o mon_addr=192.168.1.100/192.168.1.101
```

使用挂载助手时，如果可用，可以从 Ceph 配置文件中读取监视器地址。请注意，集群的 FSID（作为设备字符串的一部分传递）会通过与监视器报告的 FSID 对比进行验证。

### 挂载选项
```
mon_addr=ip_address[:port][/ip_address[:port]]
    集群的监视器地址。用于启动到集群的连接。一旦建立连接，就会跟随监视器映射中的监视器地址。
fsid=cluster-id
    集群的 FSID（来自 `ceph fsid` 命令）
ip=A.B.C.D[:N]
    指定客户端应绑定到本地的 IP 和/或端口。通常没有理由这样做。如果不指定 IP，则客户端的 IP 地址将根据其连接到监视器的地址来确定。
wsize=X
    指定最大写入大小（以字节为单位）。默认值：64 MB
rsize=X
    指定最大读取大小（以字节为单位）。默认值：64 MB
rasize=X
    指定最大预读取大小（以字节为单位）。默认值：8 MB
```
```plaintext
mount_timeout=X
    指定在 Ceph 文件系统无响应时的挂载超时值（以秒为单位）。默认值为 60 秒。

caps_max=X
    指定可以持有的最大 caps 数量。当 caps 数量超过限制时，未使用的 caps 将被释放。默认值为 0（无限制）。

rbytes
    当对目录调用 stat() 时，将 st_size 设置为 'rbytes'，即该目录下所有嵌套文件大小的总和。这是默认行为。

norbytes
    当对目录调用 stat() 时，将 st_size 设置为该目录中的条目数量。

nocrc
    禁用数据写入时的 CRC32C 校验计算。如果设置了此选项，则存储节点必须依赖 TCP 的错误校正来检测数据负载中的数据损坏。

dcache
    使用 dcache 内容进行负向查找和 readdir，当客户端缓存了整个目录内容时。这不会改变正确性；客户端仅在租约或能力确保其有效性时使用缓存元数据。

nodcache
    不使用上述 dcache。这避免了大量的复杂代码，牺牲了性能但不影响正确性，有助于追踪 bug。

noasyncreaddir
    不使用上述 dcache 进行 readdir。

noquotadf
    在 statfs 中报告整个文件系统的使用情况，而不是使用根目录配额。

nocopyfrom
    不使用 RADOS 的 'copy-from' 操作执行远程对象复制。目前，它仅用于 copy_file_range，如果使用此选项，将会回退到默认的 VFS 实现。

recover_session=<no|clean>
    设置客户端被列入黑名单时的自动重连模式。可用的模式有 "no" 和 "clean"。默认值为 "no"。
    * no：当客户端检测到自己已被列入黑名单时，从不尝试重新连接。操作通常会在被列入黑名单后失败。
```
* 清理：当客户端检测到自己已被列入阻止列表时，会自动重新连接到 Ceph 集群。在重新连接过程中，客户端会丢弃脏数据/元数据，使页面缓存和可写文件句柄失效。
* 重新连接后，文件锁会变得过时，因为 MDS 会失去对它们的追踪。如果一个inode包含任何过时的文件锁，则不允许对该inode进行读写操作，直到应用程序释放所有过时的文件锁。

更多信息
=========

如需了解有关 Ceph 的更多信息，请访问官方网站：
	https://ceph.com/

Linux 内核客户端源代码可在以下位置获取：
	https://github.com/ceph/ceph-client.git

整个系统的源代码位于：
	https://github.com/ceph/ceph.git
