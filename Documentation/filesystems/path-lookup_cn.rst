路径名查找
===============

本文基于 lwn.net 上发表的三篇文章：

- <https://lwn.net/Articles/649115/> Linux 中的路径名查找
- <https://lwn.net/Articles/649729/> RCU-walk：Linux 中更快的路径名查找
- <https://lwn.net/Articles/650786/> 在符号链接中漫步

由 Neil Brown 撰写，得到了 Al Viro 和 Jon Corbet 的帮助
此后，本文已根据内核的变化进行了更新，包括：

- 每目录并行名称查找
- `openat2()` 解析限制标志

路径名查找简介
==============================

路径名查找最显而易见的特点是其复杂性。只需稍作探究即可发现其中有许多规则、特殊情况和实现选项，这些都使得读者难以理解。计算机科学早就熟悉这种复杂性，并有工具来帮助管理它。我们将大量使用的一个工具就是“分而治之”。在分析的早期部分，我们将把符号链接（symlinks）单独拿出来处理，留到最后一部分再讨论。在我们到达符号链接之前，还有一个基于虚拟文件系统（VFS）锁定方法的主要划分，这将使我们能够分别审查“REF-walk”和“RCU-walk”。但我们言之过早了。首先需要澄清一些重要的低级区别。
有两种类型的 …
--------------------------

.. _openat: http://man7.org/linux/man-pages/man2/openat.2.html

用于标识文件系统中的对象的路径名（有时称为“文件名”）对大多数读者来说都很熟悉。它们包含两种元素：“斜杠”，即一个或多个 “/” 字符的序列，以及“组件”，即一个或多个非 “/” 字符的序列。这些形成了两种类型的路径。以斜杠开头的是“绝对路径”，从文件系统的根开始；其他的是“相对路径”，从当前目录开始，或者从通过传递给“`*at()` 系统调用（如 `openat() <openat_>`_）的文件描述符指定的某个位置开始。
.. _execveat: http://man7.org/linux/man-pages/man2/execveat.2.html

虽然可以认为第二种类型是从组件开始的，但并不总是准确的：路径名可以既没有斜杠也没有组件，换句话说，它可以是空的。这通常在 POSIX 中被禁止，但在 Linux 中的一些“`*at()` 系统调用”允许在给出 `AT_EMPTY_PATH` 标志时这样做。例如，如果你有一个指向可执行文件的打开文件描述符，你可以通过调用 `execveat() <execveat_>`_ 并传递该文件描述符、一个空路径和 `AT_EMPTY_PATH` 标志来执行它。

这些路径可以分为两部分：最后一个组件和其他所有部分。“其他所有部分”是比较简单的部分。在所有情况下，它必须标识一个已经存在的目录，否则会报告错误，如 `ENOENT` 或 `ENOTDIR`。
最后一个组件则不那么简单。不同的系统调用对其解释有很大不同（例如，有些创建它，有些不创建），而且它甚至可能不存在：空路径名或仅包含斜杠的路径名没有最后一个组件。如果它存在，则可能是 “.” 或 “..”，这两种情况与其他组件的处理方式大不相同。
如果路径名以斜杠结尾，例如“`/tmp/foo/`”，可能会让人误以为其最后一个组件为空。在很多情况下，这样做确实能得到正确的结果，但并不总是如此。特别是，`mkdir()` 和 `rmdir()` 分别创建或删除由最后一个组件命名的目录，并且它们必须能够处理以“`/`”结尾的路径名。根据 POSIX_：

  如果一个路径名包含至少一个非斜杠字符，并且以一个或多个尾随的斜杠字符结束，则该路径名只有在尾随的斜杠字符之前的最后一个路径组件命名了一个现有的目录或即将在解析路径后创建的目录条目时，才能成功解析。

Linux 的路径名遍历代码（主要在 `fs/namei.c` 中）处理了所有这些问题：将路径拆分为组件、单独处理“其他所有部分”与最后一个组件，并确保尾随斜杠不会在不允许的地方使用。它还解决了并发访问的重要问题。
当一个进程正在查找一个路径名时，另一个进程可能正在做出影响该查找的更改。一个极端的例子是，如果在另一个进程查找 “a/b/..” 时将 “a/b” 重命名为 “a/c/b”，那么该进程可能会成功解析到 “a/c”。大多数竞争条件要微妙得多，路径名查找的一个重要任务就是防止这些竞争条件产生破坏性的影响。许多潜在的竞争条件在 “dcache” 的上下文中最为明显，理解这一点对于理解路径名查找至关重要。

不仅仅是一个缓存
-------------------

“dcache” 缓存每个文件系统中名称的信息，以便快速进行查找。每个条目（称为“dentry”）包含三个重要的字段：一个组件名称、一个指向父 dentry 的指针以及一个指向 “inode” 的指针，该 inode 包含有关具有给定名称的对象的更多信息。inode 指针可以为 `NULL`，表示该名称不存在于父 dentry 中。虽然目录的 dentry 可能有指向子 dentry 的链接，但这些链接不用于路径名查找，因此在这里不予考虑。

dcache 除了加速查找外还有许多用途。其中一个特别相关的是它与记录挂载位置的挂载表紧密集成。
挂载表实际存储的是哪个 dentry 挂载在另一个 dentry 上。

在考虑 dcache 时，我们又遇到了“两种类型”的区分：有两种类型的文件系统。
某些文件系统确保 dcache 中的信息始终完全准确（尽管不一定完整）。这允许 VFS 在不与文件系统进行检查的情况下确定某个特定文件是否存在，并意味着 VFS 可以保护文件系统免受某些竞争和其他问题的影响。
这些通常是“本地”文件系统，如 ext3、XFS 和 Btrfs。
其他文件系统无法提供这种保证，因为它们做不到。
这些通常是跨网络共享的文件系统，
无论是远程文件系统（如NFS和9P），还是集群文件系统（如ocfs2或cephfs）。这些文件系统允许VFS重新验证缓存的信息，并必须提供自己的保护措施以防止尴尬的竞争。VFS可以通过设置dentry中的“DCACHE_OP_REVALIDATE”标志来检测这些文件系统。
引用计数和自旋锁管理：简单的并发控制
------------------------------------------------

在对所有这些分类进行了仔细分类之后，我们现在可以开始查看沿着路径遍历的实际过程。特别是，我们将从处理路径名中的“其他一切”部分开始，并专注于“REF-walk”方法的并发管理。这段代码可以在`link_path_walk()`函数中找到，前提是忽略所有仅在设置了“`LOOKUP_RCU`”（表示使用RCU-walk）时运行的地方。
.. _Meet the Lockers: https://lwn.net/Articles/453685/

REF-walk在锁和引用计数方面相当直接。虽然不像以前的“大内核锁”时代那样粗暴，但在需要时也并不害怕使用锁。它使用了各种不同的并发控制机制。假定读者对各种原语有一定的背景知识，或者可以从其他地方（例如在`Meet the Lockers`_中）获取这些知识。
REF-walk使用的锁定机制包括：

dentry->d_lockref
~~~~~~~~~~~~~~~~~

这使用了lockref原语来同时提供一个自旋锁和一个引用计数。这个原语的独特之处在于，“lock；inc_ref；unlock；”这个概念上的序列通常可以用单个原子内存操作来完成。
持有dentry的一个引用可以确保dentry不会突然被释放并用于其他用途，因此各个字段中的值会按预期表现。它还保护了指向inode的`->d_inode`引用。
dentry与其inode之间的关联相对永久。
例如，当文件重命名时，dentry和inode将一起移动到新位置。当文件创建时，dentry最初是负的（即`d_inode`为`NULL`），并在创建过程中分配给新的inode。
当文件被删除时，可以通过将`d_inode`设置为`NULL`或从用于查找父目录中名称的哈希表（稍后描述）中移除它来反映在缓存中。
如果dentry仍在使用，则采用第二种选项，因为删除后继续使用打开的文件是完全合法的，并且保留dentry有助于此。只有当dentry没有其他用途（即`d_lockref`中的引用计数为一）时，才会将`d_inode`设置为`NULL`。这样做的方式对于非常常见的情况来说更高效。
### 只要一个计数引用指向 dentry，非空的 `->d_inode` 值将永远不会改变

#### dentry->d_lock

`d_lock` 是上面提到的 `d_lockref` 中自旋锁的同义词。在我们的目的中，持有这个锁可以防止 dentry 被重命名或删除。具体来说，其父节点 (`d_parent`) 和名称 (`d_name`) 不能被更改，并且它不能从 dentry 哈希表中移除。

当在目录中查找一个名称时，REF-walk 会对在哈希表中找到的每个候选 dentry 获取 `d_lock` 然后检查父节点和名称是否正确。因此，在搜索缓存时不需要锁定父节点；只锁定子节点。

当查找给定名称的父节点（处理 "``..``"）时，REF-walk 可以获取 `d_lock` 以获得对 `d_parent` 的稳定引用，但它首先尝试一种更轻量级的方法。如在 `dget_parent()` 中所见，如果可以在父节点上声称一个引用，并且随后发现 `d_parent` 没有改变，则实际上没有必要在子节点上获取锁。

#### rename_lock

在给定目录中查找给定名称涉及根据两个值（名称和目录的 dentry）计算一个哈希值，访问哈希表中的那个槽，并搜索在那里找到的链表。

当 dentry 被重命名时，名称和父 dentry 都可能改变，因此哈希值几乎肯定会改变。这会将 dentry 移动到哈希表中的另一个链表。如果文件名搜索恰好查看了一个这样移动的 dentry，它可能会继续沿着错误的链表进行搜索，从而错过部分正确的链表。

名称查找过程（`d_lookup()`）不试图阻止这种情况发生，而只是检测这种情况的发生。`rename_lock` 是一个序列锁，每当任何 dentry 被重命名时都会更新。如果 `d_lookup` 发现在扫描哈希表中的链表失败时发生了重命名，它就会重新尝试。

`rename_lock` 还用于检测并防御针对 `LOOKUP_BENEATH` 和 `LOOKUP_IN_ROOT` 的潜在攻击（当解析 ".." 时，父目录被移出根目录，绕过 `path_equal()` 检查）。如果在查找过程中 `rename_lock` 被更新并且路径遇到 ".."，则可能发生潜在攻击，`handle_dots()` 将通过 `-EAGAIN` 退出。
```i_rwsem```是一个读写信号量，用于串行化对特定目录的所有更改。这确保了例如```unlink()```和```rename()```不会同时发生。它还保证了在文件系统被要求查找不在dcache中的名称或可选地在检索目录条目列表时使用```readdir()```期间目录的稳定性。
这个信号量的作用与```d_lock```互补：```i_rwsem```保护目录中的所有名称，而```d_lock```只保护目录中的一个名称。大多数对dcache的更改会持有相关目录inode上的```i_rwsem```，并在更改发生时短暂获取一个或多个dentry上的```d_lock```。一个例外是在内存压力下删除空闲dentry时。这仅使用```d_lock```，但```i_rwsem```不起作用。
该信号量以两种不同方式影响路径名查找。首先，它防止在目录中查找名称期间进行更改。```walk_component()```首先使用```lookup_fast()```，该函数检查名称是否在缓存中，仅使用```d_lock```锁定。如果未找到名称，则```walk_component()```回退到```lookup_slow()```，获取```i_rwsem```的共享锁，再次确认名称不在缓存中，然后调用文件系统获取最终答案。无论结果如何，都会将新的dentry添加到缓存中。
其次，当路径名查找到达最后一个组件时，有时需要在执行最后的查找之前获取```i_rwsem```的独占锁，以实现所需的互斥。路径查找选择是否获取```i_rwsem```是后续章节讨论的问题之一。
如果两个线程同时尝试查找同一个名称（该名称尚未在dcache中），```i_rwsem```的共享锁无法阻止它们都添加具有相同名称的新dentry。由于这会导致混乱，因此使用了一个额外的互锁级别，基于次级哈希表（```in_lookup_hashtable```）和每个dentry的标志位（```DCACHE_PAR_LOOKUP```）。
为了在仅持有```i_rwsem```共享锁的情况下将新dentry添加到缓存中，线程必须调用```d_alloc_parallel()```。这会分配一个dentry，存储所需名称和父目录，并检查主次哈希表中是否存在匹配的dentry，如果没有，则将新分配的dentry存储在次级哈希表中，并设置```DCACHE_PAR_LOOKUP```。
如果在主哈希表中找到了匹配的dentry，则返回该dentry，调用者可以知道它在与其他线程的竞争中失败了。如果在任一缓存中均未找到匹配的dentry，则返回新分配的dentry，调用者可以通过检测```DCACHE_PAR_LOOKUP```的存在来判断这种情况。在这种情况下，它知道自己赢得了竞争，并负责请求文件系统执行查找并找到匹配的inode。完成查找后，必须调用```d_lookup_done()```清除标志位并做一些其他清理工作，包括从次级哈希表中移除dentry——此时通常已经将其添加到了主哈希表中。请注意，```struct waitqueue_head```传递给```d_alloc_parallel()```，并且```d_lookup_done()```必须在此```waitqueue_head```仍然有效时调用。
如果在次级哈希表中找到了匹配的dentry，```d_alloc_parallel()```需要做更多的工作。它首先等待```DCACHE_PAR_LOOKUP```被清除，使用传递给赢得竞争的```d_alloc_parallel()```实例的等待队列，并且该队列将由调用```d_lookup_done()```唤醒。然后检查该dentry是否已添加到主哈希表中。如果已添加，则返回dentry，调用者会看到它在竞争中失败了。如果未添加到主哈希表中，最可能的解释是使用```d_splice_alias()```添加了其他dentry。无论如何，```d_alloc_parallel()```会从头开始重复所有的查找，并通常会从主哈希表中返回某项内容。

```mnt->mnt_count```
```mnt_count```是“```mount```”结构的每CPU引用计数器。
这里的每CPU意味着增加计数是廉价的，因为它只使用CPU本地内存，但是检查计数是否为零是昂贵的，因为它需要与每个CPU进行检查。获取```mnt_count```引用可以防止由于常规卸载操作而导致的挂载结构消失，但不能防止“懒惰”卸载。因此，持有```mnt_count```并不能确保挂载在命名空间中，特别是不能稳定指向挂载点的dentry链接。然而，它确实确保了```mount```数据结构保持一致，并提供了指向挂载文件系统的根dentry的引用。因此，通过```->mnt_count```的引用提供了一个稳定的挂载dentry引用，但不是挂载点的dentry。
``mount_lock`` 是一个全局 seqlock（序列锁），类似于 ``rename_lock``。它可以用来检查是否对任何挂载点进行了更改。

在遍历目录树时（远离根目录），当跨越挂载点时会使用这个锁来确保跨越是安全的。也就是说，先读取 seqlock 中的值，然后代码找到当前目录上挂载的挂载点（如果有的话）并递增 `mnt_count`。最后，检查 `mount_lock` 中的值与旧值是否一致。如果没有变化，则说明跨越是安全的；如果有变化，则递减 `mnt_count` 并重试整个过程。

当沿着目录树向上遍历时（朝向根目录），通过跟随 `..` 链接时需要更小心一些。在这种情况下，seqlock（包含一个计数器和一个自旋锁）会被完全锁定，以防止在向上移动时对任何挂载点进行更改。这种锁定是为了稳定指向被挂载的 dentry 的链接，这是挂载自身的引用计数无法保证的。

``mount_lock`` 还用于检测和防御针对 `LOOKUP_BENEATH` 和 `LOOKUP_IN_ROOT` 的潜在攻击，尤其是在解析 `..` 时（父目录被移出根目录，绕过了 `path_equal()` 检查）。如果在查找过程中 `mount_lock` 被更新，并且路径遇到 `..`，则可能发生潜在攻击，`handle_dots()` 将返回 `-EAGAIN`。

RCU
~~~

最终，在某些时候会持有全局（但极其轻量级）的 RCU 读锁，以确保某些数据结构不会意外释放。

特别是，在扫描 dcache 哈希表和挂载点哈希表中的链时会持有此锁。

结合 `struct nameidata`
------------------------

在整个遍历路径的过程中，当前状态存储在 `struct nameidata` 中，“namei” 是传统名称——可以追溯到 [First edition Unix]_ ——将“名称”转换为“inode”的函数。`struct nameidata` 包含（以及其他字段）：

``struct path path``
~~~~~~~~~~~~~~~~~~~~

`path` 包含一个 `struct vfsmount`（嵌入在 `struct mount` 中）和一个 `struct dentry`。这些记录了遍历的当前状态。它们最初指向起始点（当前工作目录、根目录或其他由文件描述符标识的目录），并在每一步更新。始终持有通过 `d_lockref` 和 `mnt_count` 的引用。
``struct qstr last``
~~~~~~~~~~~~~~~~~~~~

这是一个带有长度（即不是 `nul` 终止）的字符串，表示路径名中的“下一个”组件。
``int last_type``
~~~~~~~~~~~~~~~~~

这可以是 `LAST_NORM`、`LAST_ROOT`、`LAST_DOT` 或 `LAST_DOTDOT`。只有当类型为 `LAST_NORM` 时，`last` 字段才有效。
``struct path root``

此结构用于保存对文件系统有效根目录的引用。通常情况下，这个引用并不总是需要，因此该字段仅在首次使用时或请求非标准根目录时才会被赋值。将引用保存在 `nameidata` 结构中确保了在整个路径遍历过程中只有一个根目录生效，即使它与 `chroot()` 系统调用并发执行。

应当注意的是，在 `LOOKUP_IN_ROOT` 或 `LOOKUP_BENEATH` 的情况下，有效根目录变为传递给 `openat2()` 的目录文件描述符（该函数暴露这些 `LOOKUP_` 标志）。当满足以下任一条件时需要根目录：(1) 路径名或符号链接以 `'/'` 开头；或者 (2) 正在处理一个 `".."` 组件，因为从根目录开始的 `".."` 必须始终停留在根目录。通常使用的值是调用进程的当前根目录。也可以提供一个替代根目录，例如当 `sysctl()` 调用 `file_open_root()` 以及 NFSv4 或 Btrfs 调用 `mount_subtree()` 时。在每种情况下，都会在一个非常特定的文件系统部分查找路径，并且不允许该查找逃逸出该子树。这有点像局部的 `chroot()`。

忽略符号链接的处理，我们现在可以描述 `link_path_walk()` 函数，它负责除最后一个组件外的所有组件的查找：

   给定一个路径（`name`）和一个 `nameidata` 结构（`nd`），检查当前目录是否具有执行权限，然后前进 `name` 的一个组件并更新 `last_type` 和 `last`。如果这是最后一个组件，则返回，否则调用 `walk_component()` 并重复上述步骤。

`walk_component()` 的实现更为简单。如果组件为 `LAST_DOTS`，则调用 `handle_dots()` 来进行必要的锁定操作。如果发现 `LAST_NORM` 组件，则首先调用 `lookup_fast()`，该函数仅在 dcache 中查找，但如果是那种类型的文件系统，则会要求文件系统重新验证结果。如果没有得到好的结果，则调用 `lookup_slow()`，该函数获取 `i_rwsem` 锁，重新检查缓存，并要求文件系统找到确定的答案。

在 `walk_component()` 的最后一步，`step_into()` 将直接从 `walk_component()` 或从 `handle_dots()` 被调用。它调用 `handle_mounts()` 来检查和处理挂载点，在此过程中创建一个新的 `struct path`，其中包含对新 dentry 的计数引用以及对新 `vfsmount` 的引用（只有在新的 `vfsmount` 与之前的 `vfsmount` 不同时才计数）。如果有符号链接，`step_into()` 调用 `pick_link()` 来处理它，否则安装新的 `struct path` 到 `struct nameidata` 中，并丢弃不需要的引用。

在获取对新 dentry 的引用之前不丢弃对前一个 dentry 的引用这种“手递手”的顺序可能看起来显而易见，但值得指出，以便我们能够在 RCU-walk 版本中识别其类似之处。

处理最后一个组件
------------------

`link_path_walk()` 只遍历到设置 `nd->last` 和 `nd->last_type` 指向路径的最后一个组件为止。它不会在最后一次调用 `walk_component()`。处理最后一个组件的任务留给了调用者来解决。这些调用者包括 `path_lookupat()`、`path_parentat()` 和 `path_openat()`，每个调用者都处理不同系统调用的不同需求。

显然，`path_parentat()` 是最简单的 — 它只是在 `link_path_walk()` 周围添加了一些管理任务，并将父目录和最后一个组件返回给调用者。调用者要么打算通过 `filename_create()` 创建一个名称，要么删除或重命名一个名称（在这种情况下使用 `user_path_parent()`）。他们会使用 `i_rwsem` 排除其他更改，以验证并执行他们的操作。
``path_lookupat()`` 几乎一样简单 —— 它用于需要获取现有对象的情况，例如通过 ``stat()`` 或 ``chmod()``。它基本上只是通过调用 ``lookup_last()`` 对最终组件调用 ``walk_component()``。``path_lookupat()`` 只返回最终的 dentry。

值得注意的是，当标志 ``LOOKUP_MOUNTPOINT`` 被设置时，``path_lookupat()`` 会取消 nameidata 中的 LOOKUP_JUMPED 标志，以防止在后续路径遍历过程中调用 d_weak_revalidate()。这对于卸载一个不可访问的文件系统（比如由已死的 NFS 服务器提供的）是很重要的。

最后，``path_openat()`` 用于处理 ``open()`` 系统调用；它包含了从 "open_last_lookups()" 开始的一系列支持函数中的所有复杂性，以处理 O_CREAT（带或不带 O_EXCL）、最终的 "``/``" 字符以及尾随符号链接的不同细微之处。我们将在本系列的最后一部分中重新审视这个问题，这部分内容将重点讨论这些符号链接。“open_last_lookups()” 有时会获取 ``i_rwsem`` 锁，但并非总是如此，这取决于它发现的内容。

对于每个函数或调用它们的函数，都需要注意最终组件可能不是 ``LAST_NORM`` 的可能性。如果查找的目标是创建某个东西，则任何非 ``LAST_NORM`` 的 ``last_type`` 值都会导致错误。例如，如果 ``path_parentat()`` 报告了 ``LAST_DOTDOT``，则调用者不会尝试创建该名称。它们还会通过测试 ``last.name[last.len]`` 来检查尾随斜杠。如果在最终组件之后有任何字符，那必须是一个尾随斜杠。

### 重新验证和自动挂载
--------------------------

除了符号链接之外，还有两个“REF-walk”过程未涵盖的部分。一个是处理过期缓存条目的问题，另一个是自动挂载点。

在需要它的文件系统上，查找例程会调用 dentry 方法 ``->d_revalidate()`` 来确保缓存的信息是最新的。这通常会确认有效性或从服务器更新一些细节。在某些情况下，它可能会发现路径更上游的地方发生了变化，从而导致之前认为有效的信息实际上不再有效。当这种情况发生时，整个路径的查找会被中止并重试，并且设置 “``LOOKUP_REVAL``” 标志来强制进行更彻底的重新验证。我们将在下一篇文章中看到更多关于这个重试过程的详细信息。

自动挂载点是文件系统中的位置，在那里尝试查找一个名称可以触发如何处理该查找的变化，特别是通过在那里挂载一个文件系统。Linux 文档树中的 autofs.txt 对此有更详细的介绍，但这里有必要提几个与路径查找相关的具体注意事项。

Linux VFS 有一个“管理”dentry 的概念。这些 dentry 有三个可能有趣的特性，对应于 dentry->d_flags 中可能设置的三个不同标志：

#### ``DCACHE_MANAGE_TRANSIT``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果设置了这个标志，那么文件系统请求在处理任何可能的挂载点之前调用 dentry 操作 ``d_manage()``。这可以执行以下两种特定的服务：

1. 阻塞以避免竞争条件。如果一个自动挂载点正在被卸载，``d_manage()`` 函数通常会在允许新查找继续并可能触发新的自动挂载之前等待该过程完成。
2. 选择性地只允许某些进程通过挂载点。当一个服务器进程在管理自动挂载时，它可能需要访问一个目录而不触发正常的自动挂载处理。该服务器进程可以通过识别自己给 ``autofs`` 文件系统，后者然后通过返回 ``-EISDIR`` 给予其特别通行权限。
``DCACHE_MOUNTED``
~~~~~~~~~~~~~~~~~~

此标志设置在每个被挂载的目录项（dentry）上。由于Linux支持多个文件系统命名空间，因此该目录项可能在这个命名空间中未被挂载，而只是在其他某个命名空间中被挂载。因此，这个标志被视为一种提示，而不是保证。如果设置了此标志，并且`d_manage()`没有返回`-EISDIR`，则会调用`lookup_mnt()`来检查挂载哈希表（遵循前面描述的`mount_lock`），并可能返回一个新的`vfsmount`和一个新的目录项（两者都带有计数引用）。

``DCACHE_NEED_AUTOMOUNT``
~~~~~~~~~~~~~~~~~~~~~~~~~

如果`d_manage()`允许我们进行到这一步，并且`lookup_mnt()`没有找到挂载点，则此标志将导致调用目录项操作`d_automount()`。
`d_automount()`操作可以非常复杂，并且可能会与服务器进程通信等，但最终应该报告错误、没有要挂载的内容，或者提供一个更新的`struct path`，其中包含新的目录项和`vfsmount`。
在后一种情况下，将调用`finish_automount()`来安全地将新的挂载点安装到挂载表中。
这里没有新的导入锁定，并且由于存在长时间延迟的可能性，非常重要的是在此处理过程中不要持有任何锁（只有计数引用）。
这将在下次讨论RCU-walk时变得更加重要，因为RCU-walk对延迟特别敏感。

RCU-walk - Linux中的更快路径名查找
==========================================

RCU-walk是另一种在Linux中执行路径名查找的算法。在许多方面，它与REF-walk相似，并且两者共享大量代码。RCU-walk的一个显著区别在于它如何允许并发访问的可能性。
我们注意到REF-walk之所以复杂是因为有许多细节和特殊情况。RCU-walk通过简单地拒绝处理许多情况来减少这种复杂性——而是回退到REF-walk。RCU-walk的难点来自另一个方向：不熟悉。依赖RCU时的锁定规则与传统锁定有很大的不同，因此当我们讨论这些内容时，我们将花更多的时间。
角色的清晰划分
--------------------------

管理并发最简单的方法是强制阻止任何其他线程更改某个线程正在查看的数据结构。在其他线程根本不会考虑更改数据并且许多不同的线程同时想读取的情况下，这样做可能会非常昂贵。即使使用允许多个并发读取者的锁，更新当前读取者计数的简单操作也可能带来不必要的开销。因此，在读取其他进程未更改的共享数据结构时，目标是完全避免向内存写入任何内容。不获取锁，不增加计数，不留痕迹。
前面描述的REF-walk机制显然没有遵循这一原则，但它实际上是为了解决可能有其他线程修改数据的情况。相比之下，RCU-walk设计用于常见的情况，即有许多频繁的读取者而只有偶尔的写入者。这在整个文件系统树中可能并不常见，但在许多部分是常见的。对于其他部分，重要的是RCU-walk能够快速回退到使用REF-walk。
路径名查找始终以RCU-walk模式开始，但只要它所寻找的内容在缓存中且稳定，则会保持在这种模式。它轻盈地沿着缓存的文件系统映像前进，不留痕迹，并仔细观察其位置，确保不会绊倒。如果它注意到某些内容已更改或正在更改，或者某些内容不在缓存中，则尝试优雅地停止并切换到REF-walk。
这种停止需要获取当前`vfsmount`和`dentry`的计数引用，并确保这些引用仍然有效——即使用REF-walk进行路径遍历时也会找到相同的条目。
这是RCU-walk必须保证的一个不变量。它只能做出REF-walk在同一时间遍历树时也能做出的决定，例如选择下一步。如果优雅停止成功，则使用可靠（尽管稍微缓慢）的REF-walk处理剩余路径。如果RCU-walk发现无法优雅停止，则直接放弃并从顶部重新开始使用REF-walk。
“尝试RCU-walk，如果失败则尝试REF-walk”的模式可以在如`filename_lookup()`、`filename_parentat()`、`do_filp_open()`和`do_file_open_root()`等函数中明显看到。这四个函数大致对应于我们之前遇到的三个`path_*()`函数，每个函数都会调用`link_path_walk()`。这些`path_*()`函数使用不同的模式标志调用，直到找到一个有效的模式。
它们首先使用设置`LOOKUP_RCU`标志来请求“RCU-walk”。如果以错误`ECHILD`失败，则再次调用而不带任何特殊标志来请求“REF-walk”。如果这两种情况中的任何一种报告错误`ESTALE`，则最后尝试设置`LOOKUP_REVAL`（且不带`LOOKUP_RCU`）来确保在缓存中找到的条目被强制重新验证——通常条目仅在文件系统确定它们太旧而不可信任时才会重新验证。
`LOOKUP_RCU`尝试可能会内部取消该标志并切换到REF-walk，但永远不会尝试再切换回RCU-walk。RCU-walk绊倒的地方更可能靠近叶子，因此切换回来几乎不会有太多好处。
RCU和seqlocks：快速而轻量
--------------------------------

不出所料，RCU对RCU-walk模式至关重要。整个RCU-walk过程中都持有`rcu_read_lock()`。它提供的特定保证是，在持有锁期间，关键数据结构——`dentry`、`inode`、`super_block`和`mount`——不会被释放。这些数据结构可能会以某种方式被解除链接或失效，但内存不会被重新利用，因此各个字段中的值仍然有意义。这是RCU提供的唯一保证；其余所有操作都是使用seqlocks完成的。
正如上面所述，REF-walk持有当前`dentry`和当前`vfsmount`的计数引用，并在获取对“下一个”`dentry`或`vfsmount`的引用之前不释放这些引用。它有时还会获取`d_lock`自旋锁。这些引用和锁是为了防止某些更改发生。RCU-walk不能获取这些引用或锁，因此无法阻止此类更改。
相反，它会检查是否发生了更改，并在发生更改时中止或重试。

为了保持上述不变性（即RCU-walk只能做出REF-walk能够做出的决策），它必须在REF-walk持有引用的相同或附近位置进行检查。因此，当REF-walk增加引用计数或获取自旋锁时，RCU-walk会使用`read_seqcount_begin()`或类似函数来采样seqlock的状态。当REF-walk减少计数或释放锁时，RCU-walk会使用`read_seqcount_retry()`或类似函数来检查采样的状态是否仍然有效。

然而，seqlock的作用不仅仅如此。如果RCU-walk访问了seqlock保护结构中的两个不同字段，或者两次访问同一个字段，则这些访问之间没有任何先验的一致性保证。当需要一致性时——通常情况下都需要——RCU-walk必须先复制一份数据，然后使用`read_seqcount_retry()`来验证该副本。

`read_seqcount_retry()`不仅检查序列号，还施加了一个内存屏障，以确保在调用之前的任何内存读取指令不会被延迟到调用之后执行，无论是由CPU还是编译器造成的。一个简单的例子可以在`slow_dentry_cmp()`中看到，对于不使用简单字节级名称比较的文件系统，该函数会调用文件系统来比较名称与dentry。长度和名称指针会被复制到局部变量中，然后调用`read_seqcount_retry()`确认两者的一致性，只有在这之后才会调用`->d_compare()`。当使用标准的文件名比较时，会调用`dentry_cmp()`。值得注意的是，它并没有使用`read_seqcount_retry()`，而是有一个大段注释解释为什么在这种情况下不需要一致性保证。后续的`read_seqcount_retry()`将足以捕获在这个点上可能发生的任何问题。

通过这个关于seqlock的小复习，我们可以看看RCU-walk如何使用seqlock的大局。

### `mount_lock` 和 `nd->m_seq`

我们之前在REF-walk中已经遇到过`mount_lock` seqlock，它用于确保跨过挂载点的安全性。RCU-walk也使用它，但用途更广泛。

RCU-walk不是在遍历树的过程中对每个`vfsmount`获取计数引用，而是在遍历开始时采样`mount_lock`的状态，并将初始序列号存储在`struct nameidata`的`m_seq`字段中。这一个锁和一个序列号用于验证所有对`vfsmount`的访问以及所有跨过挂载点的操作。由于挂载表的变化相对较少，因此任何时候发生“挂载”或“卸载”时，回退到REF-walk是合理的。

在RCU-walk序列结束时（无论是切换到REF-walk继续路径处理还是到达路径末尾），都会检查`m_seq`（使用`read_seqretry()`）。在跨过挂载点向下（在`__follow_mount_rcu()`中）或向上（在`follow_dotdot_rcu()`中）时也会进行检查。如果发现它发生了变化，整个RCU-walk序列将被中止，并且路径将再次由REF-walk处理。

如果RCU-walk发现`mount_lock`没有发生变化，那么它可以确信，即使REF-walk对每个`vfsmount`获取了计数引用，结果也会相同。这确保了不变性至少对于`vfsmount`结构成立。

### `dentry->d_seq` 和 `nd->seq`

作为获取`d_reflock`的计数或锁的替代方案，RCU-walk会采样每个dentry的`d_seq` seqlock，并将序列号存储在nameidata结构的`seq`字段中，因此`nd->seq`应该始终是`nd->dentry`的当前序列号。在复制、使用dentry的名称、父目录或inode之前，需要重新验证这个数字。
我们已经讨论了名字的处理，而父目录仅在 `follow_dotdot_rcu()` 中被访问，该函数相当简单地遵循所需的模式，尽管它适用于三种不同情况。当不在挂载点时，会跟踪 `d_parent` 并收集其 `d_seq`。当我们处于挂载点时，会通过 `mnt->mnt_mountpoint` 链接获取一个新的 dentry 并收集其 `d_seq`。最后，在找到一个要跟踪的 `d_parent` 后，我们必须检查是否落在了一个挂载点上，如果是，则必须找到该挂载点并跟踪 `mnt->mnt_root` 链接。这将意味着一种虽然不常见但完全可能的情况：路径查找的起点位于文件系统的一部分中，而这部分是被挂载的，因此从根目录不可见。

存储在 `->d_inode` 中的inode指针稍微更有趣一些。inode 至少需要访问两次，一次是为了确定它是否为 NULL，另一次是为了验证访问权限。符号链接处理也需要一个经过验证的inode指针。为了避免每次访问时重新验证，第一次访问时会创建一个副本，并将其存储在 `nameidata` 的 `inode` 字段中，这样就可以安全地访问而不需进一步验证。

`lookup_fast()` 是唯一在 RCU 模式下使用的查找例程，因为 `lookup_slow()` 太慢且需要锁。在 `lookup_fast()` 中，我们找到了重要的“手递手”跟踪当前 dentry 的过程。当前的 `dentry` 和当前的 `seq` 编号被传递给 `__d_lookup_rcu()`，成功时返回一个新的 `dentry` 和一个新的 `seq` 编号。然后，`lookup_fast()` 会复制 inode 指针并重新验证新的 `seq` 编号。接着它会最后一次验证旧的 `dentry` 和旧的 `seq` 编号，然后继续执行。获取新 dentry 的 `seq` 编号然后检查旧 dentry 的 `seq` 编号的过程与我们在 REF-walk 中看到的获取对新 dentry 的计数引用并在释放旧 dentry 的引用之前的过程完全镜像。

没有 `inode->i_rwsem` 甚至 `rename_lock`

信号量是一种相对较重的锁，只能在允许睡眠时获取。由于 `rcu_read_lock()` 禁止睡眠，`inode->i_rwsem` 在 RCU-walk 中不起作用。如果其他线程确实获取了 `i_rwsem` 并以 RCU-walk 需要注意的方式修改了目录，结果要么是 RCU-walk 未能找到正在寻找的 dentry，要么是找到的 dentry 无法被 `read_seqretry()` 验证。在这两种情况下，它都会降级到 REF-walk 模式，该模式可以获取所需的锁。尽管 `rename_lock` 可以用于 RCU-walk，因为它不需要任何睡眠，但 RCU-walk 不使用它。REF-walk 使用 `rename_lock` 来防止在搜索 dcache 中的哈希链时发生更改。这可能导致未能找到实际存在的东西。当 RCU-walk 在 dentry 缓存中找不到某物时，无论它是否真的存在，它已经降级到 REF-walk 并使用适当的锁再次尝试。这完美地处理了所有情况，因此在 `rename_lock` 上添加额外的检查不会带来显著的价值。

`unlazy_walk()` 和 `complete_walk()`

“降级到 REF-walk”通常涉及调用 `unlazy_walk()`，之所以这么命名是因为“RCU-walk”有时也被称为“懒惰走”。当沿着路径到达当前的 vfsmount/dentry 对似乎已成功进行，但下一步有问题时，会调用 `unlazy_walk()`。如果下一个名称在 dcache 中找不到，或者在持有 `rcu_read_lock()` 期间（禁止睡眠）无法完成权限检查或名称重新验证，或者发现自动挂载点，或者在涉及符号链接的几种情况下，这都可能发生。

它也在 `complete_walk()` 中被调用，当查找到达最终组件或路径的末端时，具体取决于使用的查找类型。
退出 RCU-walk 的其他原因并不会触发对 ``unlazy_walk()`` 的调用，例如当发现无法立即处理的不一致情况时，如 ``mount_lock`` 或某个 ``d_seq`` 序列锁报告了更改。在这种情况下，相关的函数将返回 ``-ECHILD``，这一错误代码会逐级向上传递，直到触发从头开始的新一轮尝试，使用 REF-walk。

对于那些可以使用 ``unlazy_walk()`` 的情况，它基本上会对持有的每个指针（vfsmount、dentry 以及可能的一些符号链接）获取一个引用，并验证相关的序列锁是否已被更改。如果存在更改，它也会以 ``-ECHILD`` 中止，否则过渡到 REF-walk 成功，查找过程将继续进行。

获取这些指针的引用并不是简单地增加一个计数器那么简单。如果你已经有一个引用（通常是通过另一个对象间接获得），那么增加计数器是可行的，但如果没有实际的计数引用，这样做是不够的。对于 ``dentry->d_lockref``，除非被明确标记为“已死”（即设置计数器为 ``-128``），否则增加引用计数是安全的。“lockref_get_not_dead()”实现了这一点。

对于 ``mnt->mnt_count``，只要随后使用 ``mount_lock`` 验证该引用，则获取引用是安全的。如果验证失败，则可能不能通过标准方式调用 ``mnt_put()`` 来释放该引用——卸载可能已经进展得太远。因此，在 ``legitimize_mnt()`` 中，当它发现所获得的引用可能不安全时，会检查 ``MNT_SYNC_UMOUNT`` 标志来确定是否应该执行简单的 ``mnt_put()`` 操作，或者只是递减计数并假装什么都没发生。

文件系统中的注意事项
-------------------

RCU-walk 几乎完全依赖缓存信息，通常不会调用文件系统。然而除了前面提到的组件名称比较之外，还有两个地方可能会在 RCU-walk 中包含文件系统，且必须小心处理。

如果文件系统有非标准的权限检查要求——例如需要与服务器通信的网络文件系统——则可能会在 RCU-walk 中调用 ``i_op->permission`` 接口。在这种情况下，会传递一个额外的 “MAY_NOT_BLOCK” 标志，使其知道不能睡眠，而是在无法及时完成时返回 ``-ECHILD``。``i_op->permission`` 接口接收的是 inode 指针，而不是 dentry，因此无需担心进一步的一致性检查。但是，如果访问了任何其他文件系统数据结构，必须确保仅持有 ``rcu_read_lock()`` 时它们也是安全可访问的。这通常意味着它们必须使用 ``kfree_rcu()`` 或类似方法释放。

如果文件系统可能需要重新验证 dcache 条目，则在 RCU-walk 中也可能调用 ``d_op->d_revalidate``。此接口确实传递了 dentry，但没有访问 ``inode`` 或 ``nameidata`` 中的 ``seq`` 号码，因此在访问 dentry 中的字段时需要格外小心。这种“额外小心”通常涉及使用 `READ_ONCE() <READ_ONCE_>`_ 访问字段，并在使用之前验证结果不为空。这一模式可以在 ``nfs_lookup_revalidate()`` 中看到。
一对模式
------------------

在REF-walk和RCU-walk的细节中，以及从整体上看，有几种相关的模式值得我们注意。第一种是“快速尝试并检查，如果失败则缓慢尝试”。我们可以在高级方法中看到这一点，即首先尝试RCU-walk，然后尝试REF-walk，并且在使用``unlazy_walk()``将剩余路径切换到REF-walk的地方也能看到这一点。我们之前在跟踪一个“..”链接时，在``dget_parent()``中也见过这种模式，它先尝试一种快速的方法来获取引用，如果需要则回退到锁定。

第二种模式是“快速尝试并检查，如果失败则再次尝试——重复进行”。这在REF-walk中通过使用``rename_lock``和``mount_lock``得以体现。RCU-walk不使用这种模式——如果出现问题，最安全的做法是直接中止并尝试更稳妥的方法。

这里强调的是“快速尝试并检查”。实际上，应该说是“快速且仔细地尝试，然后检查”。需要检查的事实提醒我们系统是动态的，只有有限的事情是安全的。整个过程中最可能出错的原因是假设某件事是安全的，而实际上并非如此。有时需要仔细考虑确保每次访问的安全性到底是什么。

符号链接中的遍历
=========================

为了理解处理符号链接的方式，有几个基本问题需要考察：符号链接栈及其缓存生命周期将帮助我们理解整体的递归处理方式，并引出对最终组件所需的特别关注。然后，我们将讨论访问时间更新，并总结控制查找的各种标志，以完成这个话题。

符号链接栈
-----------------

在路径中的最终组件之前，只有两种文件系统对象是有用的：目录和符号链接。处理目录相当简单：新目录只需成为解释路径中下一个组件的起点。处理符号链接需要多做一点工作。

理论上，符号链接可以通过编辑路径来处理。如果一个组件名指向一个符号链接，则该组件被替换为链接的内容，如果该内容以'/'开头，则路径中所有前面的部分都被丢弃。这就是“`readlink -f`”命令所做的，尽管它也会删除“`.`”和“`..`”组件。

在查找路径时直接编辑路径字符串实际上并不是必需的，而且丢弃早期组件也没有意义，因为无论如何它们都不会被查看。记录所有剩余组件是很重要的，但可以将它们单独保存；没有必要将它们拼接在一起。由于一个符号链接可能指向另一个符号链接，后者又可能指向第三个符号链接，因此我们可能需要保存多个路径的剩余部分，每个都在其前面的部分处理完成后进行处理。这些路径残余部分被保存在一个有限大小的栈上。
在单次路径查找中对符号链接的数量设置限制有两个原因。最明显的原因是为了避免循环。如果一个符号链接直接或通过中介指向自身，那么跟随该符号链接永远无法成功完成——必须返回错误“ELOOP”。虽然可以在不施加限制的情况下检测循环，但限制是最简单的解决方案，并且考虑到第二个限制理由，这些限制已经足够充分。
最近Linus对此进行了详细说明：

   这是因为延迟和拒绝服务（DoS）问题。我们需要很好地应对真正的循环，但也需要应对“非常深”的非循环情况。这与内存使用无关，而是关于用户触发不合理CPU资源消耗的问题。
Linux对任何路径名的长度设定了限制：`PATH_MAX`，即4096。这种限制有多种原因；其中之一是防止内核在一个路径上花费过多时间。通过符号链接可以有效地生成更长的路径，因此出于同样的原因需要某种限制。Linux对任何一次路径查找中的符号链接数量设定了最多40个（`MAXSYMLINKS`）的限制。之前还对递归的最大深度设定了8个的限制，但在实现单独堆栈后提高到40个，因此现在只有一个限制。
我们在前一篇文章中遇到的`nameidata`结构包含一个小堆栈，可用于存储最多两个符号链接的剩余部分。在许多情况下，这已经足够。如果不够，则会分配一个具有40个符号链接容量的单独堆栈。路径名查找永远不会超出该堆栈，因为一旦检测到第40个符号链接，就会返回错误。
可能看起来只需要将名称残余部分存储在这个堆栈上，但实际上我们需要更多内容。要理解这一点，我们需要继续探讨缓存生命周期。

缓存符号链接的存储和生命周期
-------------------------------

像其他文件系统资源（如inode和目录条目）一样，符号链接也被Linux缓存以避免重复访问外部存储的成本。对于RCU-walk来说，能够找到并暂时持有这些缓存条目尤为重要，这样就不需要降到REF-walk中。
虽然每个文件系统可以选择自己的方式，但符号链接通常存储在两个地方之一。短符号链接通常直接存储在inode中。当文件系统分配一个`struct inode`时，它通常会分配额外的空间来存储私有数据（这是内核中常见的`面向对象设计模式`）。这有时包括存储符号链接的空间。另一个常见位置是在页面缓存中，页面缓存通常存储文件的内容。符号链接中的路径名可以视为该符号链接的内容，并可以像文件内容一样轻松地存储在页面缓存中。
当这两种情况都不适合时，下一个最有可能的情况是文件系统将分配一些临时内存，并在需要时将符号链接内容复制或构建到该内存中。
当符号链接存储在inode中时，它的生命周期与inode相同，而inode本身受到RCU或dentry计数引用的保护。这意味着路径名查找用于安全访问dcache和icache（inode缓存）的机制对于安全访问某些缓存的符号链接已经足够。在这种情况下，inode中的`i_link`指针被设置为指向符号链接存储的位置，并且在需要时可以直接访问。
当符号链接存储在页面缓存或其他地方时，情况就不再那么简单了。对目录项（dentry）或甚至文件节点（inode）的引用并不意味着对该inode缓存页面的引用，并且即使使用`rcu_read_lock()`也无法确保该页面不会消失。因此，对于这些符号链接，路径名查找代码需要请求文件系统提供一个稳定的引用，并且在完成操作后释放该引用。

在RCU遍历模式下获取缓存页面的引用通常是可能的。这确实需要修改内存，这是最好避免的，但这不一定是很大的开销，并且比完全退出RCU遍历模式要好。即使是分配空间来复制符号链接的文件系统也可以通过`GFP_ATOMIC`成功分配内存，而无需退出RCU遍历模式。如果文件系统无法在RCU遍历模式下成功获取引用，则必须返回`-ECHILD`，并且会调用`unlazy_walk()`以返回到允许休眠的REF遍历模式。

所有这些发生的地点是inode方法`i_op->get_link()`。这个方法在RCU遍历和REF遍历中都会被调用。在RCU遍历时，`dentry*`参数为NULL，`->get_link()`可以返回`-ECHILD`以退出RCU遍历。与我们之前查看的`i_op->permission()`方法类似，`->get_link()`需要注意它引用的所有数据结构在仅持有RCU锁而不持有计数引用的情况下是否安全访问。一个`struct delayed_call`回调将传递给`->get_link()`：文件系统可以通过`set_delayed_call()`设置自己的`put_link`函数及其参数。稍后，当VFS想要释放链接时，它将调用`do_delayed_call()`来调用该回调函数并传入参数。

为了在遍历完成后无论是在RCU遍历还是REF遍历时能够释放每个符号链接的引用，符号链接堆栈需要包含以下内容，除了路径残留部分：

- `struct path`以提供对前一路径的引用
- `const char *`以提供对前一名字的引用
- `seq`以允许路径从RCU遍历安全切换到REF遍历
- `struct delayed_call`以供后续调用

这意味着每个符号链接堆栈条目需要保存五个指针和一个整数，而不是仅仅一个指针（路径残留）。在一个64位系统上，每个条目大约占用40字节；如果有40个条目，总共占用1600字节，不到半个页面大小。所以虽然看起来很多，但实际上并不算过分。

请注意，在给定的堆栈帧中，路径残留（`name`）并不是其他字段所引用的符号链接的一部分。它是解析完当前符号链接后需要继续遍历的部分。

### 遍历符号链接

`link_path_walk()`中的主循环无缝地遍历路径中的所有组件和非最终符号链接。在处理符号链接时，`name`指针会被调整以指向新的符号链接，或者从堆栈恢复，因此循环的大部分不需要注意到这一点。将`name`变量压入和弹出堆栈非常直接；而压入和弹出引用指针（inode、cookie等）则稍微复杂一些。

当找到符号链接时，`walk_component()`通过`step_into()`调用`pick_link()`来从文件系统获取链接。如果操作成功，旧的`name`值会被压入堆栈，新的值将作为`name`使用一段时间。当到达路径末尾（即`*name`为`'\0'`）时，旧的`name`值会从堆栈恢复，并继续遍历路径。

压入和弹出引用指针（inode、cookie等）更为复杂，部分原因是希望处理尾递归。当符号链接的最后一部分本身指向另一个符号链接时，我们希望先弹出刚刚完成的符号链接，然后再压入新发现的符号链接，以避免留下空的路径残留，以免妨碍后续操作。
在发现符号链接时，最方便的做法是在`walk_component()`中立即将新的符号链接引用推入栈中；`walk_component()`也是最后一个需要查看旧符号链接的代码段，因为它正在遍历最后一个组件。因此，对于`walk_component()`来说，在推送新符号链接的引用信息之前释放旧符号链接并弹出引用是非常方便的。这一过程由三个标志指导：`WALK_NOFOLLOW`禁止它在发现符号链接时进行跟踪，`WALK_MORE`表示现在还太早释放当前的符号链接，`WALK_TRAILING`表示它正在处理查找的最后一个组件，因此我们将检查用户空间标志`LOOKUP_FOLLOW`来决定是否跟踪它是符号链接，并调用`may_follow_link()`检查我们是否有权限跟踪它。

没有最终组件的符号链接
~~~~~~~~~~~~~~~~~~~~~~~~~~

一对特殊的符号链接值得进一步解释。这两种情况都会导致在`nameidata`中设置一个新的`struct path`（包括挂载点和目录项），并且导致`pick_link()`返回`NULL`。
更明显的情况是指向“`/`”的符号链接。所有以“`/`”开头的符号链接都会在`pick_link()`中被检测到，该函数会将`nameidata`重置为指向有效的文件系统根目录。如果符号链接只包含“`/`”，那么就没有什么可做的了，没有任何组件，因此返回`NULL`表示可以释放该符号链接并丢弃栈帧。

另一种情况涉及`/proc`中的某些内容，它们看起来像符号链接但实际上不是（因此通常被称为“魔法链接”）：

    $ ls -l /proc/self/fd/1
    lrwx------ 1 neilb neilb 64 Jun 13 10:19 /proc/self/fd/1 -> /dev/pts/4

任何进程中的每个打开的文件描述符在`/proc`中都表现为一个看起来像符号链接的对象。实际上，这是一个对目标文件的引用，而不仅仅是其名称。当你对这些对象执行`readlink`操作时，你会得到一个可能指向相同文件的名称——除非该文件已被删除或覆盖。当`walk_component()`跟踪其中一个时，“procfs”中的`->get_link()`方法不会返回字符串名称，而是调用`nd_jump_link()`，该函数会就地更新`nameidata`以指向目标。`->get_link()`随后返回`NULL`。同样没有最终组件，`pick_link()`返回`NULL`。

跟踪最后一个组件中的符号链接
--------------------------------------------

所有这一切导致`link_path_walk()`遍历每一个组件，并跟踪它找到的所有符号链接，直到到达最后一个组件。这会在`nameidata`的`last`字段中返回。
对于一些调用者来说，这正是他们所需要的；他们希望创建这个`last`名称（如果它不存在）或者在存在时给出错误。其他调用者则希望跟踪找到的符号链接，并可能对该符号链接的最后一个组件进行特殊处理，而不是仅仅处理原始文件名的最后一个组件。这些调用者可能需要多次调用`link_path_walk()`，直到找到一个不指向另一个符号链接的符号链接为止。

这种情况由`link_path_walk()`的相关调用者处理，例如`path_lookupat()`、`path_openat()`使用一个循环调用`link_path_walk()`，然后通过调用`open_last_lookups()`或`lookup_last()`来处理最后一个组件。如果是一个需要跟踪的符号链接，`open_last_lookups()`或`lookup_last()`将正确设置一切并返回路径，使循环重复调用`link_path_walk()`。如果每个符号链接的最后一个组件又是另一个符号链接，这种循环最多可以重复40次。

在各种检查最后一个组件的函数中，`open_last_lookups()`是最有趣的，因为它与`do_open()`配合用于打开文件。`open_last_lookups()`的一部分在持有`i_rwsem`的情况下运行，这部分代码在单独的函数`lookup_open()`中实现。

完全解释`open_last_lookups()`和`do_open()`超出了本文的范围，但一些亮点应该有助于有兴趣深入研究代码的人。
1. 与其仅仅找到目标文件，do_open() 在 open_last_lookup() 之后用于打开它。如果文件在 dcache 中被找到，则使用 ``vfs_open()`` 进行此操作。如果没有找到，则 ``lookup_open()`` 将调用 ``atomic_open()``（如果文件系统提供了该函数）将最终查找与打开结合在一起，或者直接执行单独的 ``i_op->lookup()`` 和 ``i_op->create()`` 步骤。在后一种情况下，新找到或创建的文件的实际“打开”操作将由 vfs_open() 执行，就像名称在 dcache 中被找到一样。

2. vfs_open() 可能因缓存信息不够新而返回 ``-EOPENSTALE`` 错误。如果是在 RCU-walk 中，则返回 ``-ECHILD``；否则返回 ``-ESTALE``。当返回 ``-ESTALE`` 时，调用者可以设置 ``LOOKUP_REVAL`` 标志重试。

3. 带有 O_CREAT 的打开操作会在最后一个组件中跟随符号链接，这与其他创建系统调用（如 ``mkdir``）不同。因此，以下序列：

          ln -s bar /tmp/foo
          echo hello > /tmp/foo

   将创建一个名为 ``/tmp/bar`` 的文件。如果设置了 ``O_EXCL`` 则不允许这样做，但其他情况下会像非创建打开一样处理：lookup_last() 或 open_last_lookup() 返回非 ``NULL`` 值，并且调用 link_path_walk()，然后对找到的符号链接继续执行打开过程。

更新访问时间
--------------

我们之前说过，RCU-walk “不加锁、不增加计数、不留痕迹”。后来我们看到，在处理符号链接时，可能需要一些“痕迹”，因为可能需要一个计数引用（甚至是一个内存分配）。但这些痕迹最好保持在最小限度。

另一个可能留下痕迹的地方是更新访问时间，这种情况下不会影响目录。
在 Unix（和 Linux）中，每个文件系统对象都有一个“最后访问时间”，即“``atime``”。通过目录访问其中的文件并不被认为是更新 ``atime`` 的访问；只有列出目录内容才会更新其 ``atime``。

符号链接则不同。读取符号链接（使用 ``readlink()``）以及在前往其他目的地的过程中查找符号链接都可以更新该符号链接的 ``atime``。

关于这一点为何如此，并不清楚；POSIX 对此几乎没有说明。最明确的声明指出，如果某个特定实现在一个未由 POSIX 规定的位置更新了时间戳，则必须进行记录，“除了由于路径名解析引起的变化不需要记录”。这似乎意味着 POSIX 并不关心路径名解析期间的访问时间更新。

历史显示，在 `Linux 1.3.87`_ 之前，至少 ext2 文件系统在跟随链接时不会更新 ``atime``。
不幸的是，我们没有关于该行为改变原因的记录。
无论如何，访问时间现在必须更新，而这一操作可能会相当复杂。尝试在RCU-walk模式下进行此操作最好避免。幸运的是，通常可以跳过“atime”更新。因为“atime”更新在各个领域会引起性能问题，Linux支持“relatime”挂载选项，这通常将文件的“atime”更新限制为每天一次（对于未更改的文件），并且符号链接一旦创建后就不会更改。即使没有“relatime”，许多文件系统也以秒级粒度记录“atime”，因此只需每秒更新一次。

在RCU-walk模式中很容易测试是否需要“atime”更新，并且如果不需要，则可以跳过更新并继续RCU-walk模式。只有当实际需要“atime”更新时，路径遍历才会切换到REF-walk。所有这些都在`get_link()`函数中处理。

一些标志
----------

结束路径遍历之旅的一个合适方式是列出可以在`nameidata`中存储的各种标志，以指导查找过程。其中许多标志仅对最终组件有意义，其他标志则反映了当前路径查找的状态，还有一些适用于路径查找过程中遇到的所有路径组件。

还有`LOOKUP_EMPTY`，这个标志与其他概念不一致。如果不设置它，空路径名会在很早的时候导致错误。如果设置了它，则空路径名不会被视为错误。

全局状态标志
~~~~~~~~~~~~~

我们已经遇到过两个全局状态标志：`LOOKUP_RCU`和`LOOKUP_REVAL`。这些标志选择三种整体查找方法之一：RCU-walk、REF-walk以及带有强制重新验证的REF-walk。

`LOOKUP_PARENT`表示尚未到达最终组件。这主要用于告诉审计子系统特定访问的完整上下文。

`ND_ROOT_PRESET`表示`nameidata`中的`root`字段是由调用者提供的，因此在不再需要时不应释放该字段。

`ND_JUMPED`意味着当前目录项被选中不是因为它具有正确的名称，而是出于其他原因。这发生在跟随“..”、跟随指向“/”的符号链接、跨越挂载点或访问“/proc/$PID/fd/$FD”符号链接（也称为“魔法链接”）的情况下。在这种情况下，文件系统没有被要求重新验证名称（通过`d_revalidate()`）。在这种情况下，inode可能仍然需要重新验证，因此如果在查找完成时设置了`ND_JUMPED`（可能是在最终组件处，或者在创建、删除或重命名时在倒数第二个组件处），则会调用`d_op->d_weak_revalidate()`。

解析限制标志
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

为了允许用户空间保护自己免受某些涉及路径组件更改的竞争条件和攻击场景的影响，有一系列标志可用于限制路径查找过程中遇到的所有路径组件。这些标志通过`openat2()`的`resolve`字段暴露出来。

`LOOKUP_NO_SYMLINKS`阻止所有符号链接遍历（包括魔法链接）。
这与“LOOKUP_FOLLOW”有明显的不同，因为后者仅涉及限制尾随符号链接的跟随。“LOOKUP_NO_MAGICLINKS”则阻止所有魔法链接的遍历。文件系统必须确保在“nd_jump_link()”中返回错误，因为这是实现“LOOKUP_NO_MAGICLINKS”和其他魔法链接限制的方式。“LOOKUP_NO_XDEV”阻止所有“vfsmount”的遍历（这包括绑定挂载和普通挂载）。请注意，“vfsmount”由路径查找到达的第一个挂载点确定——绝对路径从“/”的“vfsmount”开始，而相对路径从“dfd”的“vfsmount”开始。只有当路径的“vfsmount”未改变时，才允许魔法链接。

“LOOKUP_BENEATH”阻止任何解析过程中解析到起始点之外的路径组件。这是通过阻止“nd_jump_root()”以及在会跳转到起始点之外的情况下阻止“..”来实现的。“rename_lock”和“mount_lock”用于检测对“..”解析的攻击。魔法链接也被阻止。

“LOOKUP_IN_ROOT”将所有路径组件解析为好像起始点是文件系统的根目录。“nd_jump_root()”将解析带回起始点，并且起始点处的“..”将作为无效操作。与“LOOKUP_BENEATH”一样，“rename_lock”和“mount_lock”用于检测针对“..”解析的攻击。魔法链接也被阻止。

### 最后组件标志

这些标志中的一些只在考虑最后组件时设置。其他则只在考虑最后组件时检查。

“LOOKUP_AUTOMOUNT”确保如果最后组件是一个自动挂载点，则触发该挂载。某些操作无论如何都会触发它，但像“stat()”这样的操作故意不触发。“statfs()”需要触发挂载，但在其他方面行为类似于“stat()”，因此设置了“LOOKUP_AUTOMOUNT”，“quotactl()”和处理“mount --bind”也是如此。

“LOOKUP_FOLLOW”对于符号链接的功能类似于“LOOKUP_AUTOMOUNT”。一些系统调用隐式设置或清除它，而其他调用则有API标志如“AT_SYMLINK_FOLLOW”和“UMOUNT_NOFOLLOW”来控制它。其效果类似于我们之前遇到的“WALK_GET”，但使用方式不同。

“LOOKUP_DIRECTORY”要求最后组件是一个目录。
各种调用者会设置这个标志，并且当最终组件被发现后面跟着一个斜杠时也会设置。

最后，`LOOKUP_OPEN`、`LOOKUP_CREATE`、`LOOKUP_EXCL` 和 `LOOKUP_RENAME_TARGET` 这些标志不是由 VFS 直接使用的，而是提供给文件系统，特别是提供给 `->d_revalidate()` 方法。如果文件系统知道它很快会被要求打开或创建文件，那么它可以不费力地进行重新验证。这些标志以前对 `->lookup()` 也是有用的，但随着 `->atomic_open()` 的引入，它们在那里的相关性降低了。

终点站
------

尽管其复杂性，所有这些路径名查找代码看起来状态良好——某些部分现在比几个版本前更容易理解。但这并不意味着它是“完成”的。正如前面提到的，RCU-walk 当前仅跟随存储在inode中的符号链接，因此虽然它可以处理许多 ext4 符号链接，但它对 NFS、XFS 或 Btrfs 没有帮助。这种支持不太可能被长期延迟。
