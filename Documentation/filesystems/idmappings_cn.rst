SPDX 许可证标识符: GPL-2.0

Idmappings
==========

大多数文件系统开发人员都会遇到 idmappings。它们用于从磁盘读取或写入所有权、向用户空间报告所有权，或进行权限检查。本文档旨在帮助想要了解 idmappings 工作原理的文件系统开发人员。

正式说明
------------

一个 idmapping 实质上是将一组 id 转换为另一组 id 或相同的 id 组。在用户空间中广泛使用的 idmapping 表示法如下：

```
u:k:r
```

其中，``u`` 表示上层 idmapset ``U`` 中的第一个元素，而 ``k`` 表示下层 idmapset ``K`` 中的第一个元素。参数 ``r`` 表示 idmapping 的范围，即有多少个 id 被映射。从现在起，我们将始终在 id 前面加上 ``u`` 或 ``k``，以明确我们谈论的是上层还是下层 idmapset 中的 id。

为了理解这一点的实际应用，让我们来看以下 idmapping：

```
u22:k10000:r3
```

它生成的映射如下：

```
u22 -> k10000
u23 -> k10001
u24 -> k10002
```

从数学角度来看，``U`` 和 ``K`` 是良序集合，而 idmapping 是从 ``U`` 到 ``K`` 的序同构。因此，``U`` 和 ``K`` 是序同构的。实际上，``U`` 和 ``K`` 总是给定系统上所有可能使用 id 的良序子集。

从数学角度简要分析有助于我们突出一些特性，使我们更容易理解如何在 idmappings 之间进行转换。例如，我们知道逆 idmapping 也是序同构的：

```
k10000 -> u22
k10001 -> u23
k10002 -> u24
```

鉴于我们处理的是序同构以及子集，我们可以将 idmappings 相互嵌套，即可以合理地在不同的 idmappings 之间进行转换。例如，假设我们得到了以下三个 idmappings：

1. ``u0:k10000:r10000``
2. ``u0:k20000:r10000``
3. ``u0:k30000:r10000``

以及由第一个 idmapping 通过将上层 idmapset 的 ``u1000`` 映射到下层 idmapset 的 ``k11000`` 生成的 id ``k11000``。

由于我们处理的是序同构子集，询问 id ``k11000`` 在第二个或第三个 idmapping 中对应的 id 是有意义的。简单的算法是应用第一个 idmapping 的逆操作，将 ``k11000`` 映射回 ``u1000``。之后，我们可以使用第二个或第三个 idmapping 将 ``u1000`` 映射下来。第二个 idmapping 将 ``u1000`` 映射为 ``k21000``。第三个 idmapping 将 ``u1000`` 映射为 ``k31000``。

如果我们被赋予了以下三个 idmappings 的相同任务：

1. ``u0:k10000:r10000``
2. ``u0:k20000:r200``
3. ``u0:k30000:r300``

我们会因为这些集合不再在整个第一个 idmapping 的范围内序同构而无法转换（然而它们在整个第二个 idmapping 的范围内序同构）。第二个和第三个 idmapping 都不包含上层 idmapset ``U`` 中的 ``u1000``。这相当于没有 id 被映射。我们可以简单地说 ``u1000`` 在第二个和第三个 idmapping 中未映射。内核会将未映射的 id 报告为溢出 uid ``(uid_t)-1`` 或溢出 gid ``(gid_t)-1`` 给用户空间。

计算给定 id 映射到什么 id 的算法非常简单。首先，我们需要验证该范围是否可以包含我们的目标 id。为了简化，我们将跳过这一步骤。之后，如果我们想知道 ``id`` 映射到什么 id，我们可以做简单的计算：

- 如果我们想从左到右映射：

```
u:k:r
id - u + k = n
```

- 如果我们想从右到左映射：

```
u:k:r
id - k + u = n
```

我们也可以用“向下”代替“从左到右”，用“向上”代替“从右到左”。显然，向下和向上映射是相互反转的。

为了验证上述简单公式是否有效，考虑以下两个 idmappings：

1. ``u0:k20000:r10000``
2. ``u500:k30000:r10000``

假设我们在第一个 idmapping 的下层 idmapset 中得到 ``k21000``。我们想知道这个 id 在第一个 idmapping 的上层 idmapset 中是从哪个 id 映射过来的。所以我们是在第一个 idmapping 中向上映射：

```
id     - k      + u  = n
k21000 - k20000 + u0 = u1000
```

现在假设我们在第二个 idmapping 的上层 idmapset 中得到 id ``u1100``，并且想知道这个 id 在第二个 idmapping 的下层 idmapset 中映射到什么 id。这意味着我们是在第二个 idmapping 中向下映射：

```
id    - u    + k      = n
u1100 - u500 + k30000 = k30600
```

一般说明
------------

在内核上下文中，idmapping 可以解释为将一组用户空间 id 映射为一组内核 id：

```
用户空间-id:内核-id:范围
```

用户空间 id 总是类型为 ``uid_t`` 或 ``gid_t`` 的 idmapping 的上层 idmapset 中的一个元素，而内核 id 总是类型为 ``kuid_t`` 或 ``kgid_t`` 的 idmapping 的下层 idmapset 中的一个元素。从现在起，“用户空间 id”将用于指代熟知的 ``uid_t`` 和 ``gid_t`` 类型，“内核 id”将用于指代 ``kuid_t`` 和 ``kgid_t``。

内核主要关注内核 id。它们用于执行权限检查，并存储在 inode 的 ``i_uid`` 和 ``i_gid`` 字段中。

另一方面，用户空间 id 是内核报告给用户空间的 id，或者是由用户空间传递给内核的 id，或者是从磁盘读取或写入的原始设备 id。
请注意，我们只关心内核如何存储 ID 映射，而不是用户空间如何指定它们。
在本文档的其余部分中，我们将用 ``u`` 前缀表示所有用户空间 ID，并用 ``k`` 前缀表示所有内核 ID。ID 映射范围将用 ``r`` 前缀表示。因此，一个 ID 映射可以写为 ``u0:k10000:r10000``。

例如，在这个 ID 映射中，ID ``u1000`` 是上层 ID 映射集（或“用户空间 ID 映射集”）中的一个 ID，该映射集以 ``u0`` 开始。它被映射到 ``k11000``，这是一个下层 ID 映射集（或“内核 ID 映射集”）中的内核 ID，该映射集以 ``k10000`` 开始。

一个内核 ID 总是由一个 ID 映射创建的。这样的 ID 映射与用户命名空间相关联。由于我们主要关心 ID 映射是如何工作的，因此我们不会关注 ID 映射是如何创建的，也不会关心它们在文件系统上下文之外是如何使用的。这最好留给用户命名空间的解释。

初始用户命名空间是特殊的。它始终具有以下形式的 ID 映射：

``u0:k0:r4294967295``

这是在整个系统可用 ID 范围上的身份 ID 映射。

其他用户命名空间通常具有非身份 ID 映射，例如：

``u0:k10000:r10000``

当进程创建或想要更改文件的所有权时，或者当文件系统从磁盘读取文件的所有权时，用户空间 ID 会立即根据与相关用户命名空间关联的 ID 映射转换为内核 ID。

例如，考虑一个文件系统存储在磁盘上的文件，该文件由 ``u1000`` 拥有：

- 如果文件系统挂载在初始用户命名空间中（大多数文件系统都是这样），则使用初始 ID 映射。正如我们所见，这只是身份 ID 映射。这意味着从磁盘读取的 ID ``u1000`` 将被映射为 ID ``k1000``。因此，inode 的 ``i_uid`` 和 ``i_gid`` 字段将包含 ``k1000``。
- 如果文件系统使用 ID 映射 ``u0:k10000:r10000`` 挂载，则从磁盘读取的 ``u1000`` 将被映射为 ``k11000``。因此，inode 的 ``i_uid`` 和 ``i_gid`` 将包含 ``k11000``。

### 转换算法

我们已经简要地看到可以在不同的 ID 映射之间进行转换。现在我们将更详细地了解其工作原理。

#### 交叉映射

内核在很多地方都使用这种转换算法。例如，当通过 `stat()` 系统调用族报告文件的所有权给用户空间时就会用到它。
如果我们从一个 ID 映射中得到了 `k11000`，我们可以在另一个 ID 映射中映射这个 ID。为了让这个过程生效，两个 ID 映射需要在它们各自的内核 ID 映射集中包含相同的内核 ID。例如，考虑以下的 ID 映射：

1. u0:k10000:r10000
2. u20000:k10000:r10000

假设我们在第一个 ID 映射中将 `u1000` 映射为 `k11000`。然后我们可以使用第二个 ID 映射中的内核 ID 映射集将 `k11000` 转换为用户空间 ID：

```c
/* 将内核 ID 映射到第二个 ID 映射中的用户空间 ID。 */
from_kuid(u20000:k10000:r10000, k11000) = u21000
```

注意，通过反转算法我们可以回到第一个 ID 映射中的内核 ID：

```c
/* 将用户空间 ID 映射回第二个 ID 映射中的内核 ID。 */
make_kuid(u20000:k10000:r10000, u21000) = k11000

/* 将内核 ID 映射到第一个 ID 映射中的用户空间 ID。 */
from_kuid(u0:k10000:r10000, k11000) = u1000
```

这种算法允许我们回答一个给定的内核 ID 在特定 ID 映射中对应的用户空间 ID 是什么。为了能够回答这个问题，两个 ID 映射需要在其各自的内核 ID 映射集中包含相同的内核 ID。

例如，当内核从磁盘读取一个原始的用户空间 ID 时，它会根据文件系统的 ID 映射将其映射为内核 ID。假设文件系统挂载的 ID 映射是 `u0:k20000:r10000` 并且从磁盘读取了一个所有者为 `u1000` 的文件。这意味着 `u1000` 将被映射为 `k21000`，该值将存储在文件节点的 `i_uid` 和 `i_gid` 字段中。

当用户空间调用 `stat()` 或相关函数获取文件的所有权信息时，内核不能简单地根据文件系统的 ID 映射将 ID 反映射回去，因为这会导致错误的所有者信息（如果调用者使用了不同的 ID 映射）。因此，内核会在调用者的 ID 映射中将 ID 反映射回去。假设调用者有一个不常见的 ID 映射 `u3000:k20000:r10000`，那么 `k21000` 会被映射为 `u4000`。因此，用户会看到这个文件的所有者是 `u4000`。

重映射
~~~~~~~

可以通过两个 ID 映射的用户空间 ID 映射集将一个内核 ID 从一个 ID 映射转换到另一个 ID 映射。这相当于重新映射一个内核 ID。让我们看一个例子。假设我们有以下两个 ID 映射：

1. u0:k10000:r10000
2. u0:k20000:r10000

并且我们得到了第一个 ID 映射中的 `k11000`。为了将这个内核 ID 从第一个 ID 映射转换到第二个 ID 映射，我们需要执行两步操作：

1. 将内核 ID 映射为第一个 ID 映射中的用户空间 ID：

    ```c
    /* 将内核 ID 映射到第一个 ID 映射中的用户空间 ID。 */
    from_kuid(u0:k10000:r10000, k11000) = u1000
    ```

2. 将用户空间 ID 映射为第二个 ID 映射中的内核 ID：

    ```c
    /* 将用户空间 ID 映射为第二个 ID 映射中的内核 ID。 */
    make_kuid(u0:k20000:r10000, u1000) = k21000
    ```

如你所见，我们使用了两个 ID 映射中的用户空间 ID 映射集来将一个 ID 映射中的内核 ID 转换为另一个 ID 映射中的内核 ID。这使得我们可以回答一个问题：我们需要使用什么内核 ID 才能在另一个 ID 映射中得到相同的用户空间 ID？为了能够回答这个问题，两个 ID 映射需要在其各自的用户空间 ID 映射集中包含相同的用户空间 ID。

注意，通过反转算法我们可以很容易地回到第一个 ID 映射中的内核 ID：

1. 将内核 ID 映射为第二个 ID 映射中的用户空间 ID：

    ```c
    /* 将内核 ID 映射到第二个 ID 映射中的用户空间 ID。 */
    from_kuid(u0:k20000:r10000, k21000) = u1000
    ```

2. 将用户空间 ID 映射为第一个 ID 映射中的内核 ID：

    ```c
    /* 将用户空间 ID 映射为第一个 ID 映射中的内核 ID。 */
    make_kuid(u0:k10000:r10000, u1000) = k11000
    ```

另一种看待这种转换的方法是将其视为反转一个 ID 映射并应用另一个 ID 映射，前提是两个 ID 映射都包含了相关的用户空间 ID。这在处理 ID 映射挂载时非常有用。
无效的转换
~~~~~~~~~~~~~~~~~~~~

在某个 ID 映射的内核 ID 映射集中使用另一个或同一 ID 映射的用户空间 ID 映射集中的 ID 是不合法的。虽然内核 ID 映射集始终指示内核 ID 空间中的一个 ID 映射集，但用户空间 ID 映射集指示的是用户空间 ID。因此，以下的映射是被禁止的：

```c
/* 在第一个 ID 映射中将用户空间 ID 映射为内核 ID。*/
make_kuid(u0:k10000:r10000, u1000) = k11000

/* 无效：在第二个 ID 映射中将内核 ID 映射为内核 ID。*/
make_kuid(u10000:k20000:r10000, k110000) = k21000
                                 ~~~~~~~
```

同样错误的是：

```c
/* 在第一个 ID 映射中将内核 ID 映射为用户空间 ID。*/
from_kuid(u0:k10000:r10000, k11000) = u1000

/* 无效：在第二个 ID 映射中将用户空间 ID 映射为用户空间 ID。*/
from_kuid(u20000:k0:r10000, u1000) = k21000
                             ~~~~~
```

由于用户空间 ID 的类型为 `uid_t` 和 `gid_t`，而内核 ID 的类型为 `kuid_t` 和 `kgid_t`，当它们混淆时编译器会抛出错误。因此上述两个例子会导致编译失败。

ID 映射在创建文件系统对象时的作用
-------------------------------------------

映射 ID 下行（down）或上行（up）的概念体现在两个内核函数中，这些函数是文件系统开发者非常熟悉的，并且我们已经在本文档中使用过：

```c
/* 将用户空间 ID 映射为内核 ID。*/
make_kuid(idmapping, uid)

/* 将内核 ID 映射为用户空间 ID。*/
from_kuid(idmapping, kuid)
```

我们将简要探讨 ID 映射在创建文件系统对象时是如何发挥作用的。为了简化说明，我们仅考虑 VFS 已经完成路径查找并即将调用文件系统本身的情况。因此，我们关心的是例如调用 `vfs_mkdir()` 时会发生什么。我们还将假设我们正在创建文件系统对象的目录对所有人都是可读和可写的。

在创建文件系统对象时，调用者会查看调用者的文件系统 ID。这些只是普通的 `uid_t` 和 `gid_t` 用户空间 ID，但它们仅用于确定文件所有权，这就是为什么它们被称为“文件系统 ID”。它们通常与调用者的 UID 和 GID 相同，但也可能不同。为了简化讨论，我们假设它们总是相同的。

当调用者进入内核时，会发生两件事情：

1. 将调用者的用户空间 ID 映射到调用者的 ID 映射中的内核 ID。
（严格来说，内核会查看当前任务凭证中存储的内核 ID，但为了教育目的，我们假设这个转换是即时发生的。）

2. 验证调用者的内核 ID 是否可以映射回文件系统的 ID 映射中的用户空间 ID。
第二步很重要，因为普通文件系统最终需要将内核 ID 映射回用户空间 ID 以写入磁盘。

通过第二步，内核保证了一个有效的用户空间 ID 可以写入磁盘。如果无法做到这一点，内核将拒绝创建请求，以免有任何可能导致文件系统损坏的风险。

敏锐的读者会意识到这只是我们在前面部分提到的跨映射算法的一个变体。首先，内核根据调用者的 ID 映射将调用者的用户空间 ID 映射为内核 ID，然后根据文件系统的 ID 映射将该内核 ID 映射回去。

从实现的角度来看，值得一提的是 ID 映射是如何表示的：
所有 ID 映射都来自相应的用户命名空间。
### 调用者的 ID 映射（通常从 `current_user_ns()` 获取）
- 文件系统的 ID 映射 (`sb->s_user_ns`)
- 挂载点的 ID 映射 (`mnt_idmap(vfsmnt)`）

让我们看一些示例，其中涉及调用者和文件系统的 ID 映射，但不包括挂载点的 ID 映射。这将展示我们可能遇到的一些问题。之后我们将重新审视这些示例，并使用挂载点的 ID 映射来解决之前观察到的问题。

#### 示例 1

```
调用者 ID：           u1000
调用者 ID 映射：      u0:k0:r4294967295
文件系统 ID 映射：    u0:k0:r4294967295
```

调用者和文件系统都使用相同的 ID 映射：

1. 将调用者的用户空间 ID 映射为内核 ID 在调用者的 ID 映射中：
   ```
   make_kuid(u0:k0:r4294967295, u1000) = k1000
   ```

2. 验证调用者的内核 ID 是否可以在文件系统的 ID 映射中映射回用户空间 ID
   对于这一步，内核会调用 `fsuidgid_has_mapping()` 函数，最终归结为调用 `from_kuid()`：
   ```
   from_kuid(u0:k0:r4294967295, k1000) = u1000
   ```

在这个示例中，两个 ID 映射相同，因此没有什么特别之处。最终写入磁盘的用户空间 ID 是 `u1000`。

#### 示例 2

```
调用者 ID：           u1000
调用者 ID 映射：      u0:k10000:r10000
文件系统 ID 映射：    u0:k20000:r10000
```

1. 将调用者的用户空间 ID 映射为内核 ID 在调用者的 ID 映射中：
   ```
   make_kuid(u0:k10000:r10000, u1000) = k11000
   ```

2. 验证调用者的内核 ID 是否可以在文件系统的 ID 映射中映射回用户空间 ID：
   ```
   from_kuid(u0:k20000:r10000, k11000) = u-1
   ```

很明显，虽然调用者的用户空间 ID 可以成功映射为内核 ID，但内核 ID 无法根据文件系统的 ID 映射映射回去。因此，内核将拒绝这个创建请求。
需要注意的是，尽管这个示例不太常见，因为大多数文件系统不能使用非初始 ID 映射进行挂载，但这仍然是一个普遍存在的问题，如下面的示例所示。

#### 示例 3

```
调用者 ID：           u1000
调用者 ID 映射：      u0:k10000:r10000
文件系统 ID 映射：    u0:k0:r4294967295
```

1. 将调用者的用户空间 ID 映射为内核 ID 在调用者的 ID 映射中：
   ```
   make_kuid(u0:k10000:r10000, u1000) = k11000
   ```

2. 验证调用者的内核 ID 是否可以在文件系统的 ID 映射中映射回用户空间 ID：
   ```
   from_kuid(u0:k0:r4294967295, k11000) = u11000
   ```

我们可以看到，转换总是成功的。文件系统最终写入磁盘的用户空间 ID 总是等于在调用者 ID 映射中创建的内核 ID 的值。这主要有两个后果：
首先，我们不能允许调用者最终以另一个用户空间 ID 写入磁盘。我们只能通过挂载整个文件系统来实现这一点，但这仅限于少数文件系统且不够灵活。但在容器化工作负载中这是一个非常重要的用例。
其次，调用者通常无法创建任何具有更严格权限的文件或访问目录，因为文件系统的内核 ID 无法映射为调用者 ID 映射中的有效用户空间 ID。

1. 将原始用户空间 ID 映射为文件系统的内核 ID：
   ```
   make_kuid(u0:k0:r4294967295, u1000) = k1000
   ```

2. 将内核 ID 映射为调用者的用户空间 ID：
   ```
   from_kuid(u0:k10000:r10000, k1000) = u-1
   ```

#### 示例 4

```
文件 ID：             u1000
调用者 ID 映射：      u0:k10000:r10000
文件系统 ID 映射：    u0:k0:r4294967295
```

为了向用户空间报告所有权，内核使用了前面介绍的跨映射算法：

1. 将磁盘上的用户空间 ID 映射为文件系统的内核 ID：
   ```
   make_kuid(u0:k0:r4294967295, u1000) = k1000
   ```

2. 将内核 ID 映射为调用者的用户空间 ID：
   ```
   from_kuid(u0:k10000:r10000, k1000) = u-1
   ```

在这种情况下，跨映射算法失败，因为文件系统的内核 ID 无法映射为调用者的用户空间 ID。因此，内核将报告此文件的所有权为溢出 ID。

#### 示例 5

```
文件 ID：             u1000
调用者 ID 映射：      u0:k10000:r10000
文件系统 ID 映射：    u0:k20000:r10000
```

为了向用户空间报告所有权，内核使用了前面介绍的跨映射算法：

1. 将磁盘上的用户空间 ID 映射为文件系统的内核 ID：
   ```
   make_kuid(u0:k20000:r10000, u1000) = k21000
   ```

2. 将内核 ID 映射为调用者的用户空间 ID：
   ```
   from_kuid(u0:k10000:r10000, k21000) = u-1
   ```

同样，在这种情况下，跨映射算法失败，因为文件系统的内核 ID 无法映射为调用者的用户空间 ID。因此，内核将报告此文件的所有权为溢出 ID。
请注意，在最后两个示例中，如果调用者使用初始 ID 映射，事情会变得简单。对于使用初始 ID 映射挂载的文件系统，这将是简单的。因此，我们只考虑一个具有 `u0:k20000:r10000` ID 映射的文件系统：

1. 将磁盘上的用户空间 ID 映射为文件系统的内核 ID：
   ```
   make_kuid(u0:k20000:r10000, u1000) = k21000
   ```

2. 将内核 ID 映射为调用者的用户空间 ID：
   ```
   from_kuid(u0:k0:r4294967295, k21000) = u21000
   ```

### 挂载点上的 ID 映射

在上一节中，我们看到了调用者的 ID 映射和文件系统的 ID 映射不兼容导致的各种问题。对于一个更复杂但常见的例子，假设主机上启动了两个容器。为了完全防止两个容器互相影响，管理员可能会使用不同的不重叠的 ID 映射：

```
容器 1 ID 映射：  u0:k10000:r10000
容器 2 ID 映射：  u0:k20000:r10000
文件系统 ID 映射：  u0:k30000:r10000
```

管理员希望提供对以下文件集的读写访问权限：

```
目录 ID：       u0
dir/file1 ID： u1000
dir/file2 ID： u2000
```

目前，管理员无法让这两个容器都能访问这些文件。
当然，管理员可以通过 `chown()` 递归地更改所有权。例如，他们可以更改所有权，使 `dir` 及其下的所有文件从文件系统的 ID 映射到容器的 ID 映射中进行交叉映射。假设他们更改了所有权，使其与第一个容器的 ID 映射兼容：

```
dir id:       u10000
dir/file1 id: u11000
dir/file2 id: u12000
```

这样仍然会使 `dir` 对第二个容器毫无用处。实际上，`dir` 及其下的所有文件仍会继续显示为由第二个容器的溢出 ID 所拥有。

或者考虑另一个越来越流行的例子。一些服务管理器（如 systemd）实现了一种称为“便携式主目录”的概念。用户可能希望在不同机器上使用他们的主目录，在这些机器上他们会分配不同的登录用户空间 ID。大多数用户在家庭机器上的登录 ID 通常是 `u1000`，并且主目录中的所有文件通常都由 `u1000` 所有。而在大学或工作地点，他们可能会有另一个登录 ID，如 `u1125`。这使得他们在工作机器上与主目录交互变得相当困难。

在这两种情况下，递归更改所有权会产生严重的后果。最明显的一点是，所有权被全局且永久地更改了。在主目录的情况下，这种所有权变更甚至需要在用户从家庭机器切换到工作机器时每次都发生。对于大量文件来说，这会变得越来越昂贵。

如果用户幸运的话，他们正在处理一个可以在用户命名空间内挂载的文件系统。但这也会全局更改所有权，并且所有权的变更与文件系统的挂载生命周期相关，即超级块。唯一的方法是完全卸载文件系统并在另一个用户命名空间中重新挂载它。这通常是不可能的，因为这意味着当前访问该文件系统的所有用户将无法再访问。而且这也意味着 `dir` 仍然无法在具有不同 ID 映射的两个容器之间共享。

但通常情况下，用户甚至没有这个选项，因为大多数文件系统无法在容器内部挂载。而让它们不可挂载可能是可取的，因为它不需要文件系统处理恶意的文件系统镜像。

但上述提到的用例及其他更多情况可以通过 ID 映射挂载来处理。它们允许在不同的挂载点以不同的所有权暴露相同的 dentry 集。这是通过 `mount_setattr()` 系统调用来标记挂载并设置用户命名空间实现的。相关的 ID 映射用于通过我们上面介绍的重映射算法，将调用者的 ID 映射转换为文件系统的 ID 映射及其反向转换。

ID 映射挂载使得可以在临时和局部的方式下更改所有权。所有权变更仅限于特定的挂载点，并且所有权变更与挂载点的生命周期相关。其他所有用户和位置中的文件系统暴露都不受影响。

支持 ID 映射挂载的文件系统没有任何实际理由支持在用户命名空间内挂载。文件系统可以通过完全在 ID 映射挂载下暴露来达到相同的效果。这种方法的优点在于文件系统可以将超级块的创建留给初始用户命名空间中的特权用户。

然而，完全有可能将 ID 映射挂载与支持在用户命名空间内挂载的文件系统结合起来。我们将在下面进一步讨论这一点。
文件系统类型与 idmapped 挂载类型
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

随着 idmapped 挂载的引入，我们需要区分文件系统的所有权和 VFS 对象（如 inode）的挂载所有权。从文件系统角度来看，inode 的所有者可能与从 idmapped 挂载角度看不同。这种基本概念上的区别几乎应该在代码中明确表达。因此，为了区分 idmapped 挂载的所有权和文件系统的所有权，引入了不同的类型。

如果一个 uid 或 gid 是使用文件系统或调用者的 idmapping 生成的，则我们将使用 `kuid_t` 和 `kgid_t` 类型。然而，如果一个 uid 或 gid 是使用挂载的 idmapping 生成的，则我们将使用专用的 `vfsuid_t` 和 `vfsgid_t` 类型。

所有生成或接受 uid 和 gid 的 VFS 辅助函数都使用 `vfsuid_t` 和 `vfsgid_t` 类型，并且我们可以依赖编译器来捕捉由于混淆文件系统和 VFS 的 uid 和 gid 而产生的错误。

`vfsuid_t` 和 `vfsgid_t` 类型通常映射为 `kuid_t` 和 `kgid_t` 类型，类似于 `kuid_t` 和 `kgid_t` 类型映射为 `uid_t` 和 `gid_t` 类型的方式：

```
uid_t <--> kuid_t <--> vfsuid_t
gid_t <--> kgid_t <--> vfsgid_t
```

当我们基于 `vfsuid_t` 或 `vfsgid_t` 类型报告所有权时（例如，在 `stat()` 过程中），或者根据 `vfsuid_t` 或 `vfsgid_t` 类型将所有权信息存储在一个共享 VFS 对象中（例如，在 `chown()` 过程中），我们可以使用 `vfsuid_into_kuid()` 和 `vfsgid_into_kgid()` 辅助函数。

为了说明这些辅助函数存在的原因，请考虑当我们更改 idmapped 挂载中的 inode 所有权时会发生什么。在我们基于挂载 idmapping 生成了一个 `vfsuid_t` 或 `vfsgid_t` 后，我们随后会将这个 `vfsuid_t` 或 `vfsgid_t` 确定为新的全局所有权。因此，我们正在将 `vfsuid_t` 或 `vfsgid_t` 转换为全局 `kuid_t` 或 `kgid_t`。这可以通过使用 `vfsuid_into_kuid()` 和 `vfsgid_into_kgid()` 来完成。

请注意，每当一个共享 VFS 对象（例如，缓存的 `struct inode` 或缓存的 `struct posix_acl`）存储所有权信息时，必须使用文件系统或“全局” `kuid_t` 和 `kgid_t`。通过 `vfsuid_t` 和 `vfsgid_t` 表达的所有权是特定于 idmapped 挂载的。

我们已经注意到 `vfsuid_t` 和 `vfsgid_t` 类型是基于挂载 idmapping 生成的，而 `kuid_t` 和 `kgid_t` 类型是基于文件系统 idmapping 生成的。为了防止滥用文件系统 idmapping 来生成 `vfsuid_t` 或 `vfsgid_t` 类型，或者滥用挂载 idmapping 来生成 `kuid_t` 或 `kgid_t` 类型，文件系统 idmapping 和挂载 idmapping 也是不同的类型。

所有映射到或从 `vfsuid_t` 和 `vfsgid_t` 类型转换的辅助函数都需要传递一个挂载 idmapping，该 idmapping 的类型为 `struct mnt_idmap`。传递文件系统或调用者的 idmapping 将导致编译错误。
与本文中为所有用户空间 ID 前缀添加 `u`，以及为所有内核 ID 前缀添加 `k` 类似，我们将为所有 VFS ID 添加前缀 `v`。因此，一个挂载的 ID 映射将被写为：`u0:v10000:r10000`

重映射辅助函数
~~~~~~~~~~~~~~

增加了用于在不同 ID 映射之间转换的 ID 映射函数。这些函数利用了我们之前介绍的重映射算法。我们将要探讨以下函数：

- `i_uid_into_vfsuid()` 和 `i_gid_into_vfsgid()`

  `i_*id_into_vfs*id()` 函数将文件系统的内核 ID 转换为挂载 ID 映射中的 VFS ID：

  ```plaintext
  /* 将文件系统的内核 ID 映射到文件系统 ID 映射中的用户空间 ID。 */
  from_kuid(filesystem, kid) = uid

  /* 将文件系统的用户空间 ID 映射到挂载 ID 映射中的 VFS ID。 */
  make_kuid(mount, uid) = kuid
  ```

- `mapped_fsuid()` 和 `mapped_fsgid()`

  `mapped_fs*id()` 函数将调用者的内核 ID 转换为文件系统 ID 映射中的内核 ID。此转换通过使用挂载 ID 映射重映射调用者的 VFS ID 来实现：

  ```plaintext
  /* 将调用者的 VFS ID 映射到挂载 ID 映射中的用户空间 ID。 */
  from_kuid(mount, kid) = uid

  /* 将挂载的用户空间 ID 映射到文件系统 ID 映射中的内核 ID。 */
  make_kuid(filesystem, uid) = kuid
  ```

- `vfsuid_into_kuid()` 和 `vfsgid_into_kgid()`

  每当

请注意这两个函数是互逆的。考虑以下 ID 映射：

```plaintext
调用者 ID 映射：    u0:k10000:r10000
文件系统 ID 映射：  u0:k20000:r10000
挂载 ID 映射：      u0:v10000:r10000
```

假设从磁盘读取了一个由 `u1000` 所拥有的文件。根据其 ID 映射，文件系统会将该 ID 映射为 `k21000`。这是存储在 inode 的 `i_uid` 和 `i_gid` 字段中的值。
当调用者通过 `stat()` 查询该文件的所有权时，内核通常会简单地使用跨映射算法，将文件系统的内核 ID 映射为调用者 ID 映射中的用户空间 ID。
但是当调用者通过 ID 映射挂载访问文件时，内核将首先调用 `i_uid_into_vfsuid()`，从而将文件系统的内核 ID 转换为挂载 ID 映射中的 VFS ID：

```plaintext
i_uid_into_vfsuid(k21000):
  /* 将文件系统的内核 ID 映射为用户空间 ID。 */
  from_kuid(u0:k20000:r10000, k21000) = u1000

  /* 将文件系统的用户空间 ID 映射为挂载 ID 映射中的 VFS ID。 */
  make_kuid(u0:v10000:r10000, u1000) = v11000
```

最后，当内核向调用者报告所有者时，它会将挂载 ID 映射中的 VFS ID 转换为调用者 ID 映射中的用户空间 ID：

```plaintext
k11000 = vfsuid_into_kuid(v11000)
from_kuid(u0:k10000:r10000, k11000) = u1000
```

我们可以通过验证创建新文件时发生的情况来测试这个算法是否真的有效。假设用户正在以 `u1000` 创建一个文件。内核将此映射为调用者 ID 映射中的 `k11000`。通常情况下，内核会应用跨映射，验证 `k11000` 是否可以映射为文件系统 ID 映射中的用户空间 ID。由于 `k11000` 不能直接在文件系统 ID 映射中向上映射，因此此创建请求将失败。
但是当调用者通过 ID 映射挂载访问文件时，内核将首先调用 `mapped_fs*id()`，从而将调用者的内核 ID 根据挂载 ID 映射转换为 VFS ID：

```plaintext
mapped_fsuid(k11000):
  /* 将调用者的内核 ID 映射为挂载 ID 映射中的用户空间 ID。 */
  from_kuid(u0:k10000:r10000, k11000) = u1000

  /* 将挂载的用户空间 ID 映射为文件系统 ID 映射中的内核 ID。 */
  make_kuid(u0:v20000:r10000, u1000) = v21000
```

最终写入磁盘时，内核会将 `v21000` 映射为文件系统 ID 映射中的用户空间 ID：

```plaintext
k21000 = vfsuid_into_kuid(v21000)
from_kuid(u0:k20000:r10000, k21000) = u1000
```

如我们所见，我们得到了一个可逆的、因此是信息保存的算法。通过 ID 映射挂载创建的 `u1000` 文件也将被报告为由 `u1000` 所拥有，反之亦然。
现在让我们简要重新考虑之前在 ID 映射挂载上下文中的失败示例。

重新考虑示例 2
~~~~~~~~~~~~~~

```plaintext
调用者 ID：          u1000
调用者 ID 映射：     u0:k10000:r10000
文件系统 ID 映射：   u0:k20000:r10000
挂载 ID 映射：       u0:v10000:r10000
```

当调用者使用非初始 ID 映射时，通常的做法是将相同的 ID 映射附加到挂载上。我们现在执行三个步骤：

1. 将调用者的用户空间 ID 映射为调用者 ID 映射中的内核 ID：

   ```plaintext
   make_kuid(u0:k10000:r10000, u1000) = k11000
   ```

2. 将调用者的 VFS ID 映射为文件系统 ID 映射中的内核 ID：

   ```plaintext
   mapped_fsuid(v11000):
     /* 将 VFS ID 映射为挂载 ID 映射中的用户空间 ID。 */
     from_kuid(u0:v10000:r10000, v11000) = u1000

     /* 将用户空间 ID 映射为文件系统 ID 映射中的内核 ID。 */
     make_kuid(u0:k20000:r10000, u1000) = k21000
   ```

3. 验证调用者的内核 ID 是否可以映射为文件系统 ID 映射中的用户空间 ID：

   ```plaintext
   from_kuid(u0:k20000:r10000, k21000) = u1000
   ```

因此，写入磁盘的所有权将是 `u1000`。

重新考虑示例 3
~~~~~~~~~~~~~~

```plaintext
调用者 ID：          u1000
调用者 ID 映射：     u0:k10000:r10000
文件系统 ID 映射：   u0:k0:r4294967295
挂载 ID 映射：       u0:v10000:r10000
```

同样的转换算法适用于第三个示例：

1. 将调用者的用户空间 ID 映射为调用者 ID 映射中的内核 ID：

   ```plaintext
   make_kuid(u0:k10000:r10000, u1000) = k11000
   ```

2. 将调用者的 VFS ID 映射为文件系统 ID 映射中的内核 ID：

   ```plaintext
   mapped_fsuid(v11000):
      /* 将 VFS ID 映射为挂载 ID 映射中的用户空间 ID。 */
      from_kuid(u0:v10000:r10000, v11000) = u1000

      /* 将用户空间 ID 映射为文件系统 ID 映射中的内核 ID。 */
      make_kuid(u0:k0:r4294967295, u1000) = k1000
   ```

3. 验证调用者的内核 ID 是否可以映射为文件系统 ID 映射中的用户空间 ID：

   ```plaintext
   from_kuid(u0:k0:r4294967295, k21000) = u1000
   ```

因此，写入磁盘的所有权将是 `u1000`。
### 示例4 重新考虑
~~~~~~~~~~~~~~~~~~~~~~

::
  
  文件ID：              u1000
  调用者ID映射：     u0:k10000:r10000
  文件系统ID映射： u0:k0:r4294967295
  挂载点ID映射：      u0:v10000:r10000

为了向用户空间报告所有权，内核现在使用我们之前介绍的转换算法执行三个步骤：

1. 将用户空间中的文件ID映射到文件系统的内核ID中：
   ```
   make_kuid(u0:k0:r4294967295, u1000) = k1000
   ```

2. 将内核ID转换为挂载点ID映射中的VFS ID：
   ```
   i_uid_into_vfsuid(k1000):
     /* 将内核ID映射为文件系统ID映射中的用户空间ID。 */
     from_kuid(u0:k0:r4294967295, k1000) = u1000

     /* 将用户空间ID映射为挂载点ID映射中的VFS ID。 */
     make_kuid(u0:v10000:r10000, u1000) = v11000
   ```

3. 将VFS ID映射为调用者ID映射中的用户空间ID：
   ```
   k11000 = vfsuid_into_kuid(v11000)
   from_kuid(u0:k10000:r10000, k11000) = u1000
   ```

以前，调用者的内核ID无法在文件系统的ID映射中进行交叉映射。有了映射挂载后，现在可以通过挂载点ID映射将它交叉映射到文件系统的ID映射中。文件现在将以“u1000”创建，根据挂载点的ID映射。

### 示例5 重新考虑
~~~~~~~~~~~~~~~~~~~~~~

::
  
  文件ID：              u1000
  调用者ID映射：     u0:k10000:r10000
  文件系统ID映射： u0:k20000:r10000
  挂载点ID映射：      u0:v10000:r10000

再次，为了向用户空间报告所有权，内核现在使用我们之前介绍的转换算法执行三个步骤：

1. 将用户空间中的文件ID映射到文件系统的内核ID中：
   ```
   make_kuid(u0:k20000:r10000, u1000) = k21000
   ```

2. 将内核ID转换为挂载点ID映射中的VFS ID：
   ```
   i_uid_into_vfsuid(k21000):
     /* 将内核ID映射为文件系统ID映射中的用户空间ID。 */
     from_kuid(u0:k20000:r10000, k21000) = u1000

     /* 将用户空间ID映射为挂载点ID映射中的VFS ID。 */
     make_kuid(u0:v10000:r10000, u1000) = v11000
   ```

3. 将VFS ID映射为调用者ID映射中的用户空间ID：
   ```
   k11000 = vfsuid_into_kuid(v11000)
   from_kuid(u0:k10000:r10000, k11000) = u1000
   ```

以前，文件的内核ID无法在文件系统的ID映射中进行交叉映射。有了映射挂载后，现在可以通过挂载点ID映射将它交叉映射到文件系统的ID映射中。文件现在由“u1000”拥有，根据挂载点的ID映射。

### 更改家庭目录的所有权
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

我们已经看到如何使用映射挂载在调用者、文件系统或两者都使用非初始ID映射时进行ID映射转换。当调用者使用非初始ID映射时存在多种应用场景。这主要发生在容器化工作负载的上下文中。结果是我们已经看到对于使用初始ID映射和非初始ID映射挂载的文件系统，由于内核ID无法在调用者和文件系统的ID映射之间进行交叉映射，因此访问文件系统不起作用。

正如我们所见，映射挂载通过根据挂载点的ID映射重映射调用者或文件系统的ID映射提供了解决方案。除了容器化工作负载外，映射挂载还有一个优点，即即使调用者和文件系统都使用初始ID映射时也能正常工作，这意味着主机上的用户可以根据每个挂载点更改目录和文件的所有权。

假设一个用户的家庭目录位于便携式存储设备上。在家时他们具有ID“u1000”，并且他们家庭目录中的所有文件都属于“u1000”。而在大学或工作中，他们的登录ID是“u1125”。带着他们的家庭目录变得有问题了。他们无法轻松访问文件，可能无法写入磁盘而不应用宽松的权限或ACL，即使可以，他们最终也会得到一个由“u1000”和“u1125”拥有的文件和目录混合体。

映射挂载允许解决这个问题。用户可以在他们的工作站或家庭计算机上创建一个映射挂载，具体取决于他们希望便携式存储设备上的所有权情况。
假设他们希望磁盘上的所有文件都属于“u1000”。当用户在工作站插入便携式存储设备时，他们可以设置一个任务来创建一个最小ID映射“u1000:k1125:r1”的映射挂载。现在当他们创建文件时，内核执行以下步骤：

::
  
  调用者ID：            u1125
  调用者ID映射：     u0:k0:r4294967295
  文件系统ID映射： u0:k0:r4294967295
  挂载点ID映射：      u1000:v1125:r1

1. 将调用者的用户空间ID映射为调用者ID映射中的内核ID：
   ```
   make_kuid(u0:k0:r4294967295, u1125) = k1125
   ```

2. 将调用者的VFS ID映射为文件系统的内核ID：
   ```
   mapped_fsuid(v1125):
     /* 将VFS ID映射为挂载点ID映射中的用户空间ID。 */
     from_kuid(u1000:v1125:r1, v1125) = u1000

     /* 将用户空间ID映射为文件系统ID映射中的内核ID。 */
     make_kuid(u0:k0:r4294967295, u1000) = k1000
   ```

3. 验证调用者的文件系统ID是否可以映射为文件系统ID映射中的用户空间ID：
   ```
   from_kuid(u0:k0:r4294967295, k1000) = u1000
   ```

最终，文件将以“u1000”创建在磁盘上。

现在简要看看ID为“u1125”的调用者在其工作站上看到的所有权：

::
  
  文件ID：              u1000
  调用者ID映射：     u0:k0:r4294967295
  文件系统ID映射： u0:k0:r4294967295
  挂载点ID映射：      u1000:v1125:r1

1. 将用户空间中的文件ID映射到文件系统的内核ID：
   ```
   make_kuid(u0:k0:r4294967295, u1000) = k1000
   ```

2. 将内核ID转换为挂载点ID映射中的VFS ID：
   ```
   i_uid_into_vfsuid(k1000):
     /* 将内核ID映射为文件系统ID映射中的用户空间ID。 */
     from_kuid(u0:k0:r4294967295, k1000) = u1000

     /* 将用户空间ID映射为挂载点ID映射中的VFS ID。 */
     make_kuid(u1000:v1125:r1, u1000) = v1125
   ```

3. 将VFS ID映射为调用者ID映射中的用户空间ID：
   ```
   k1125 = vfsuid_into_kuid(v1125)
   from_kuid(u0:k0:r4294967295, k1125) = u1125
   ```

最终，调用者将被报告文件属于“u1125”，这是调用者在其工作站上的用户空间ID。
写入磁盘的原始用户空间 ID 是 ``u1000``，因此当用户将其家目录带回他们的家用电脑时，在那里他们被分配了 ``u1000`` 这个 ID，并使用初始的 ID 映射挂载文件系统，他们会看到所有这些文件都由 ``u1000`` 所拥有。
