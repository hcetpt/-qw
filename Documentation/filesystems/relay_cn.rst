SPDX 许可证标识符: GPL-2.0

==================================
中继接口（原为 relayfs）
==================================

中继接口提供了一种方式，使得内核应用程序能够通过用户自定义的“中继通道”高效地记录和传输大量数据从内核到用户空间。一个“中继通道”是实现为一组每个CPU的内核缓冲区（“通道缓冲区”的）内核->用户数据中继机制，在用户空间中每个缓冲区表示为一个常规文件（“中继文件”）。内核客户端使用高效的写入函数将数据写入通道缓冲区；这些数据会自动记录到当前CPU的通道缓冲区。用户空间应用程序通过mmap()或read()从中继文件读取数据并检索可用的数据。中继文件本身是在宿主文件系统（例如debugfs）中创建的文件，并且使用下面描述的API与通道缓冲区关联。记录到通道缓冲区的数据格式完全取决于内核客户端；然而，中继接口确实提供了允许内核客户端对缓冲区数据施加一些结构的钩子。中继接口不实现任何形式的数据过滤——这也留给了内核客户端处理。目的是尽可能保持简单。

本文档提供了中继接口API的概述。函数参数的详细信息在中继接口代码中与函数一起进行了文档说明，请参阅该文档获取详情。

语义
=====

每个中继通道每个CPU有一个缓冲区，每个缓冲区有一个或多个子缓冲区。消息被写入第一个子缓冲区，直到它太满而无法容纳新消息，此时如果存在下一个子缓冲区，则写入下一个子缓冲区。消息永远不会跨子缓冲区分割。
此时，可以通知用户空间使其清空第一个子缓冲区，同时内核继续写入下一个子缓冲区。
当通知某个子缓冲区已满时，内核知道其中有多少字节是填充内容，即因为完整的消息无法放入子缓冲区而产生的未使用空间。用户空间可以利用这些知识只复制有效数据。
复制后，用户空间可以通知内核某个子缓冲区已被消费。
中继通道可以以一种模式运行，在这种模式下，它会覆盖尚未被用户空间收集的数据，并且不会等待其被消费。
中继通道本身不提供用户空间与内核之间此类数据通信的机制，允许内核侧保持简单并且不对用户空间强加单一接口。不过，它确实提供了一组示例和一个单独的帮助程序，如下所述。
读取（read）接口既移除填充数据，又内部消耗读取子缓冲区；因此，在使用read(2)清空通道缓冲区的情况下，内核和用户之间无需特殊目的的通信即可进行基本操作。

中继接口的主要目标之一是提供一种低开销机制，将内核数据传输到用户空间。虽然read()接口易于使用，但其效率不如mmap()方法；示例代码试图尽可能缩小这两种方法之间的权衡。

klog和中继应用示例代码
=======================

中继接口本身已经可以使用了，但为了简化操作，提供了几个简单的实用函数和一组示例。中继应用示例包（可在中继的SourceForge网站上找到）包含一系列自包含的示例，每个示例由两个.c文件组成，分别包含用户端和内核端的样板代码。当组合起来时，这两组样板代码能够轻松地将数据流式传输到磁盘，而无需处理繁琐的日常维护任务。

“klog调试功能”补丁（在中继应用示例包中的klog.patch）为内核提供了几个高级日志记录函数，允许无论是否存在可写入的通道或是否编译了中继接口，都能向通道写入格式化文本或原始数据。这些函数使您能够在内核或内核模块的任何位置放置无条件的“跟踪”语句；只有当注册了“klog处理器”时，数据才会被实际记录（请参见klog和kleak示例以了解详细信息）。

当然，也可以从零开始使用中继接口，即不使用任何中继应用示例代码或klog，但您必须实现用户空间和内核之间的通信，让双方能够传达缓冲区的状态（满、空、填充量）。read()接口既移除填充数据又内部消耗读取子缓冲区；因此，在使用read(2)清空中继缓冲区的情况下，对于基本操作来说，内核和用户之间无需特殊目的的通信。不过，诸如缓冲区满的情况仍然需要通过某种方式来传递。

klog和中继应用示例可以在http://relayfs.sourceforge.net 上的中继应用示例包中找到。

中继接口用户空间API
====================

中继接口实现了用户空间访问中继通道缓冲区数据的基本文件操作。以下是可用的文件操作及其行为的一些注释：

=========== ============================================================
open()	    允许用户打开一个_已存在的_通道缓冲区
mmap()      导致通道缓冲区映射到调用者的内存空间。请注意，不能进行部分mmap - 必须映射整个文件，即NRBUF * SUBBUFSIZE
read()      读取通道缓冲区的内容。所读取的字节被读者“消耗”，即后续读取将不再可用。如果通道处于非覆盖模式（默认模式），则即使有活动的内核写入者，也可以随时读取。如果通道处于覆盖模式且有活动的通道写入者，则结果可能不可预测 - 用户应在使用覆盖模式下的read()之前确保所有对通道的日志记录已结束。子缓冲区的填充数据会自动移除，不会被读者看到
sendfile()  将数据从通道缓冲区传输到输出文件描述符。子缓冲区的填充数据会自动移除，不会被读者看到
### poll()
`POLLIN`、`POLLRDNORM` 和 `POLLERR` 支持。当子缓冲区边界被跨越时，用户应用程序会收到通知。

### close()
减少通道缓冲区的引用计数。当引用计数为 0 时（即没有进程或内核客户端打开该缓冲区），通道缓冲区将被释放。

============= ============================================================

为了让用户应用程序能够使用中继文件，宿主文件系统必须挂载。例如：

```
mount -t debugfs debugfs /sys/kernel/debug
```

.. 注意::
   宿主文件系统不需要挂载即可让内核客户端创建或使用通道——只有当用户空间应用程序需要访问缓冲区数据时才需要挂载。

### 中继接口内核API
以下是中继接口为内核客户端提供的API总结：

待定（当前行MT:/API/）
  通道管理函数：
  
  ```c
  relay_open(base_filename, parent, subbuf_size, n_subbufs, callbacks, private_data)
  relay_close(chan)
  relay_flush(chan)
  relay_reset(chan)
  ```
  
  通常由用户空间发起的通道管理：
  
  ```c
  relay_subbufs_consumed(chan, cpu, subbufs_consumed)
  ```

  写入函数：
  
  ```c
  relay_write(chan, data, length)
  __relay_write(chan, data, length)
  relay_reserve(chan, length)
  ```

  回调函数：
  
  ```c
  subbuf_start(buf, subbuf, prev_subbuf, prev_padding)
  buf_mapped(buf, filp)
  buf_unmapped(buf, filp)
  create_buf_file(filename, parent, mode, buf, is_global)
  remove_buf_file(dentry)
  ```

  辅助函数：
  
  ```c
  relay_buf_full(buf)
  subbuf_start_reserve(buf, length)
  ```

### 创建一个通道
`relay_open()` 用于创建一个通道及其每个 CPU 的通道缓冲区。每个通道缓冲区将在宿主文件系统中创建一个关联文件，该文件可以在用户空间中进行映射或读取。这些文件的命名格式为 `basename0...basenameN-1`，其中 N 是在线 CPU 的数量，默认情况下这些文件将创建在文件系统的根目录下（如果父目录参数为 NULL）。如果你想在某个目录结构中包含你的中继文件，你应该使用宿主文件系统的目录创建函数（如 `debugfs_create_dir()`）来创建该目录，并将父目录传递给 `relay_open()`。当通道关闭时，用户负责清理他们创建的任何目录结构——再次使用宿主文件系统的目录删除函数（如 `debugfs_remove()`）。

为了创建一个通道并将其通道缓冲区与宿主文件系统中的文件相关联，用户必须提供两个回调函数的定义：`create_buf_file()` 和 `remove_buf_file()`。

`create_buf_file()` 在 `relay_open()` 调用期间为每个 CPU 缓冲区调用一次，允许用户创建表示相应通道缓冲区的文件。回调应该返回表示通道缓冲区的文件的 dentry。

`remove_buf_file()` 也必须定义；它负责删除在 `create_buf_file()` 中创建的文件，并在 `relay_close()` 期间调用。

以下是一些典型的回调定义示例，这里使用的是 debugfs：

```c
/*
 * create_buf_file() 回调。在 debugfs 中创建中继文件
 */
static struct dentry *create_buf_file_handler(const char *filename,
					      struct dentry *parent,
					      umode_t mode,
					      struct rchan_buf *buf,
					      int *is_global)
{
	return debugfs_create_file(filename, mode, parent, buf,
				   &relay_file_operations);
}

/*
 * remove_buf_file() 回调。从 debugfs 中移除中继文件
 */
static int remove_buf_file_handler(struct dentry *dentry)
{
	debugfs_remove(dentry);

	return 0;
}

/*
 * 中继接口回调
 */
static struct rchan_callbacks relay_callbacks = {
	.create_buf_file = create_buf_file_handler,
	.remove_buf_file = remove_buf_file_handler,
};

一个使用上述回调的 `relay_open()` 调用示例：

```c
chan = relay_open("cpu", NULL, SUBBUF_SIZE, N_SUBBUFS, &relay_callbacks, NULL);
```

如果 `create_buf_file()` 回调失败或未定义，则通道创建和 `relay_open()` 将失败。
每个 per-cpu 缓冲区的总大小是通过将子缓冲区的数量乘以传递给 `relay_open()` 的子缓冲区大小来计算的。

子缓冲区的基本思想是它们基本上是双缓冲扩展到 N 个缓冲区，并且还允许应用程序轻松实现基于缓冲区边界的随机访问方案，这对于某些高吞吐量的应用程序来说可能是很重要的。子缓冲区的数量和大小完全取决于应用程序，并且即使对于同一个应用程序，在不同的情况下也会需要不同的参数值。通常来说，正确的值是在一些实验之后决定的；然而，一般可以假设只有一个子缓冲区是一个不好的选择——你肯定会在覆盖数据或丢失事件之间二选一，具体取决于所使用的通道模式。

`create_buf_file()` 的实现也可以定义为创建一个单一的“全局”缓冲区，而不是默认的 per-cpu 集合。这对于主要关注系统范围内事件的相对顺序而不必担心保存显式时间戳以用于后期处理步骤中的合并/排序的应用程序是有用的。

要让 `relay_open()` 创建一个全局缓冲区，`create_buf_file()` 的实现应该在创建用于表示单个缓冲区的文件的同时，将 `is_global` 输出参数设置为非零值。在这种情况下，`create_buf_file()` 和 `remove_buf_file()` 将只被调用一次。正常的通道写入函数（例如 `relay_write()`）仍然可以使用——任何 CPU 的写入都会透明地进入全局缓冲区——但由于这是一个全局缓冲区，调用者应确保他们使用适当的锁来保护这样的缓冲区，要么通过在自旋锁中包装写入，要么从 `relay.h` 复制一个写入函数并创建一个内部进行适当锁定的本地版本。

传递给 `relay_open()` 的 `private_data` 允许客户端将用户定义的数据与通道关联，并且可以通过 `chan->private_data` 或 `buf->chan->private_data` 立即获得（包括在 `create_buf_file()` 中）。

仅缓冲区通道
--------------

这些通道没有与之关联的文件，并且可以通过 `relay_open(NULL, NULL, ...)` 创建。这种通道在内核早期追踪场景中很有用，例如在 VFS 启动之前。在这种情况下，可以打开一个仅缓冲区的通道，然后在内核准备好处理文件时调用 `relay_late_setup_files()` 来向用户空间暴露已缓冲的数据。

通道“模式”
-------------

`relay` 通道可以使用两种模式之一：“覆盖”模式或“不覆盖”模式。模式完全由 `subbuf_start()` 回调函数的实现决定，如下所述。如果没有定义 `subbuf_start()` 回调，则默认模式为“不覆盖”模式。如果默认模式适合您的需求，并且您计划使用 `read()` 接口来检索通道数据，那么您可以忽略此部分的细节，因为它主要涉及 `mmap()` 实现。

在“覆盖”模式下，也称为“飞行记录仪”模式，写入会不断循环在缓冲区内，并且永远不会失败，但会无条件地覆盖旧数据，无论这些数据是否已被实际消费。在“不覆盖”模式下，如果未消费的子缓冲区数量等于通道中的总子缓冲区数量，则写入将会失败，即数据将会丢失。显然，如果没有消费者或者消费者无法足够快地消费子缓冲区，则数据无论如何都会丢失；唯一的区别在于数据是从缓冲区的开头还是结尾丢失。

如上所述，一个 `relay` 通道由一个或多个 per-cpu 通道缓冲区组成，每个都实现为一个环形缓冲区，并细分为一个或多个子缓冲区。消息通过下面描述的写入函数写入当前 per-cpu 缓冲区的当前子缓冲区。每当消息无法放入当前子缓冲区（因为没有足够的空间），客户端将通过 `subbuf_start()` 回调被告知即将切换到新的子缓冲区。客户端使用此回调来：1) 如果合适则初始化下一个子缓冲区 2) 如果合适则完成前一个子缓冲区 3) 返回一个布尔值以指示是否实际移动到下一个子缓冲区。

为了实现“不覆盖”模式，用户空间客户端可能会提供类似于以下的 `subbuf_start()` 回调实现：

```c
static int subbuf_start(struct rchan_buf *buf,
			void *subbuf,
			void *prev_subbuf,
			unsigned int prev_padding)
{
	if (prev_subbuf)
		*((unsigned *)prev_subbuf) = prev_padding;

	if (relay_buf_full(buf))
		return 0;

	subbuf_start_reserve(buf, sizeof(unsigned int));

	return 1;
}
```

如果当前缓冲区已满，即所有子缓冲区仍未被消费，回调返回 0 表示不应发生缓冲区切换，即直到消费者有机会读取当前准备好的子缓冲区集。为了让 `relay_buf_full()` 函数有意义，消费者负责通过 `relay_subbufs_consumed()` 通知 `relay` 接口何时子缓冲区已被消费。任何后续尝试写入缓冲区的操作都将再次调用 `subbuf_start()` 回调，并带有相同的参数；只有当消费者消费了一个或多个准备好的子缓冲区时，`relay_buf_full()` 才会返回 0，此时缓冲区切换可以继续。
`overwrite`模式下的`subbuf_start()`回调实现非常类似：

```c
static int subbuf_start(struct rchan_buf *buf,
                        void *subbuf,
                        void *prev_subbuf,
                        size_t prev_padding)
{
        if (prev_subbuf)
                *((unsigned *)prev_subbuf) = prev_padding;

        subbuf_start_reserve(buf, sizeof(unsigned int));

        return 1;
}
```

在这种情况下，`relay_buf_full()`检查是没有意义的，并且回调始终返回1，导致缓冲区切换无条件发生。客户端在这种模式下使用`relay_subbufs_consumed()`函数也是没有意义的，因为它从未被调用。
如果客户端未定义任何回调或未定义`subbuf_start()`回调，则使用默认的`subbuf_start()`实现，该实现实现了最简单的“不覆盖”模式，即什么都不做，仅返回0。
可以通过在`subbuf_start()`回调中调用`subbuf_start_reserve()`辅助函数来在每个子缓冲区的开始处预留头信息。这个预留区域可以用来存储客户端想要存储的任何信息。在上面的例子中，在每个子缓冲区中预留了空间来存储该子缓冲区的填充计数。这个值在`subbuf_start()`实现中为前一个子缓冲区填充。前一个子缓冲区的填充值与前一个子缓冲区的指针一起传递给`subbuf_start()`回调，因为直到子缓冲区被填满后，填充值才被知道。当通道打开时，`subbuf_start()`回调也会被调用于第一个子缓冲区，以便给客户端预留空间的机会。在这种情况下，传递给回调的前一个子缓冲区指针将是NULL，因此客户端应该在写入前一个子缓冲区之前检查`prev_subbuf`指针的值。

### 写入通道

内核客户端使用`relay_write()`或`__relay_write()`将数据写入当前CPU的通道缓冲区。`relay_write()`是主要的日志记录函数——它使用`local_irqsave()`来保护缓冲区，并且如果你可能从中断上下文进行日志记录，则应使用它。如果你确定永远不会从中断上下文进行日志记录，你可以使用`__relay_write()`，它只禁用抢占。这些函数不会返回值，因此你无法判断它们是否失败——假设你不想在快速日志路径中检查返回值，而且除非缓冲区已满且处于不覆盖模式，否则它们总是会成功。在这种情况下，你可以在`subbuf_start()`回调中通过调用`relay_buf_full()`辅助函数来检测写入失败。
`relay_reserve()`用于在通道缓冲区中预留一个稍后可以写入的槽。这通常用于需要直接写入通道缓冲区而无需预先将数据暂存到临时缓冲区的应用程序。由于实际写入可能不会在槽预留后立即发生，因此使用`relay_reserve()`的应用程序可以保持一个实际写入字节数的计数，要么在子缓冲区本身中预留的空间中，要么作为一个单独的数组。请参阅http://relayfs.sourceforge.net提供的relay-apps tarball中的“reserve”示例，了解如何实现这一点。由于写入受客户端控制并与其分离，`relay_reserve()`完全不保护缓冲区——由客户端在使用`relay_reserve()`时提供适当的同步。

### 关闭通道

当客户端完成对通道的使用时，调用`relay_close()`关闭通道。当不再有任何对通道缓冲区的引用时，通道及其关联的缓冲区将被销毁。`relay_flush()`强制所有通道缓冲区进行子缓冲区切换，并可用于在关闭通道之前最终处理并处理最后一个子缓冲区。

### 其他

一些应用程序可能希望保留一个通道并重复使用它，而不是每次使用时都打开和关闭一个新的通道。可以使用`relay_reset()`来达到这个目的——它重置通道到初始状态，而不重新分配通道缓冲区内存或销毁现有映射。然而，只有在安全的情况下才能调用它，即当通道当前未被写入时。
最后，还有一些可以用于不同目的的实用回调。`buf_mapped()`在通道缓冲区从用户空间映射时被调用，`buf_unmapped()`在取消映射时被调用。客户端可以使用此通知来触发内核应用程序中的操作，例如启用/禁用对通道的日志记录。

### 资源

有关新闻、示例代码、邮件列表等，请参阅relay接口主页：
http://relayfs.sourceforge.net

### 致谢

relay接口的想法和规范是在以下人员关于跟踪的讨论中产生的：

- Michel Dagenais <michel.dagenais@polymtl.ca>
- Richard Moore <richardj_moore@uk.ibm.com>
- Bob Wisniewski <bob@watson.ibm.com>
- Karim Yaghmour <karim@opersys.com>
- Tom Zanussi <zanussi@us.ibm.com>

同时感谢Hubertus Franke提出了许多有用的建议和错误报告。
当然，请提供您需要翻译的文本。
