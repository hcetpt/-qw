SPDX 许可证标识符: GPL-2.0
.. _xfs_self_describing_metadata:

============================
XFS 自描述元数据
============================

介绍
============

XFS 面临的最大可扩展性问题不是算法的可扩展性问题，而是文件系统结构的验证问题。磁盘上的结构和索引及其迭代算法足以支持包含数十亿inode的PB级文件系统，但正是这种可扩展性导致了验证问题。XFS 上几乎所有的元数据都是动态分配的。唯一固定位置的元数据是分配组头（SB、AGF、AGFL 和 AGI），而其他所有元数据结构需要通过不同的方式遍历文件系统结构来发现。尽管用户空间工具已经用于验证和修复结构，但它们的验证能力有限，这反过来又限制了XFS文件系统可支持的大小。

例如，当试图确定一个损坏问题的根本原因时，完全可以手动使用xfs_db和一些脚本来分析100TB文件系统的结构，但这仍然是一个主要的手动任务，即验证单比特错误或错误写入是否是最终的损坏原因。此类法医分析可能需要几个小时到几天的时间，因此在这种规模下根本原因分析是完全可行的。

然而，如果我们将文件系统扩展到1PB，我们现在有10倍多的元数据需要分析，因此这种分析会扩展到几周甚至几个月的法医工作。大部分分析工作既慢又繁琐，随着分析量的增加，原因更有可能在噪声中丢失。因此，支持PB级文件系统的主要关注点是减少基本的文件系统结构法医分析所需的时间和精力。

自描述元数据
========================

当前元数据格式存在的一个问题是我们除了元数据块中的魔术数字外，没有其他方法来识别它应该是什么。我们甚至无法确定它是否在正确的位置。简单地说，你不能孤立地查看一个元数据块并说“是的，它应该在那里并且内容有效”。

因此，大多数法医分析的时间都花在元数据值的基本验证上，寻找那些在范围内（因此未被自动验证检查检测到）但实际上不正确的值。找到并理解诸如交叉链接的块列表（例如B树中的兄弟指针如何形成循环）是如何出错的关键，但在事后无法判断这些块是以何种顺序链接在一起或写入磁盘的。

因此我们需要记录更多的信息到元数据中，以便能够快速确定元数据是否完好且可以忽略其分析目的。我们不能防止每种可能类型的错误，但我们确保常见类型的错误易于检测。这就是自描述元数据的概念。

自描述元数据的第一个基本要求是元数据对象在一个已知位置包含某种形式的唯一标识符。这使我们能够识别该块的预期内容，并因此解析和验证元数据对象。如果我们不能独立地识别对象中的元数据类型，那么该元数据根本无法很好地描述自身！

幸运的是，几乎所有XFS元数据都已经嵌入了魔术数字——只有AGFL、远程符号链接和远程属性块不包含识别的魔术数字。因此，我们可以更改所有这些对象的磁盘格式以添加更多识别信息，并通过更改元数据对象中的魔术数字来简单地检测这一点。也就是说，如果它包含当前的魔术数字，则元数据不是自描述的。如果它包含新的魔术数字，则它是自描述的，我们可以在运行时、法医分析或修复期间对元数据对象进行更广泛的自动化验证。

作为首要关注点，自描述元数据需要某种形式的整体完整性检查。如果我们不能验证元数据由于外部影响而未被改变，则不能信任该元数据。因此我们需要某种形式的完整性检查，这是通过向元数据块添加CRC32c验证完成的。如果我们能验证块包含其预期的元数据，大量的手动验证工作就可以被省略。
CRC32c 被选中是因为在 XFS 文件系统中，元数据不能超过 64KB 的长度，因此一个 32 位的 CRC 足以检测元数据块中的多位错误。CRC32c 在常见的 CPU 上现在已经被硬件加速，因此它非常快。虽然 CRC32c 并不是所有可用的完整性检查中最强大的，但它对于我们需求来说已经足够，并且开销相对较小。增加更大的完整性字段或算法并不会提供比 CRC32c 更多的价值，但会增加很多复杂性，因此没有提供更改完整性检查机制的功能。

自描述元数据需要包含足够的信息，以便可以在不查看任何其他元数据的情况下验证该元数据块是否位于正确的位置。这意味着它需要包含位置信息。仅仅在元数据中添加块号不足以防止误写——写操作可能会被错误地导向到错误的 LUN，从而写入错误文件系统的“正确块”。因此，位置信息必须包含文件系统标识符以及块号。

在取证分析中另一个关键的信息点是知道元数据块属于谁。我们已经知道类型、位置、有效性/损坏情况以及最近修改的时间。知道块的所有者很重要，因为它可以让我们找到其他相关的元数据来确定损坏的范围。例如，如果我们有一个扩展 B 树对象，我们不知道它属于哪个inode，因此必须遍历整个文件系统来找到块的所有者。更糟糕的是，损坏可能意味着找不到所有者（即孤儿块），因此如果没有元数据中的所有者字段，我们就无法了解损坏的范围。如果我们有元数据对象中的所有者字段，我们可以立即进行从上至下的验证以确定问题的范围。

不同类型的元数据有不同的所有者标识符。例如，目录、属性和扩展树块都由一个inode拥有，而空闲空间 B 树块则由分配组拥有。因此，所有者字段的大小和内容取决于我们正在查看的元数据对象类型。所有者信息还可以识别错放的写入（例如，将空闲空间 B 树块写入了错误的分配组）。

自描述元数据还需要包含其写入到文件系统的时间戳。在进行取证分析时，一个关键的信息点是块最近被修改的时间。根据修改时间对一组损坏的元数据块进行相关性分析非常重要，因为这可以表明这些损坏是否相关，是否有多个导致最终故障的损坏事件，甚至是否存在运行时验证未检测到的损坏。

例如，通过查看包含该块的空闲空间 B 树块最后一次写入的时间与元数据对象本身最后一次写入的时间，我们可以确定一个元数据对象是否应该属于空闲空间还是仍然被分配。如果空闲空间块比对象及其所有者的写入时间更新，那么有很大几率这个块应该从所有者那里移除。

为了提供这个“写入时间戳”，每个元数据块都会记录最后一次修改它的事务的日志序列号（LSN）。这个数字在整个文件系统生命周期内始终递增，唯一重置它的方法是在文件系统上运行 xfs_repair。此外，通过使用 LSN，我们可以判断损坏的元数据是否都属于同一个日志检查点，从而了解从第一个到最后一个损坏元数据实例之间发生了多少修改，进一步了解损坏发生到被检测之间的修改量。
运行时验证
==================

自描述元数据的验证在运行时发生于两个地方：

- 成功从磁盘读取后立即进行
- 在提交写入IO之前立即进行

验证是完全无状态的——它独立于修改过程，并且仅检查元数据是否符合其描述以及元数据字段是否在范围内且内部一致。因此，我们无法捕获所有类型的块内损坏，因为可能存在某些操作状态对元数据施加的限制，或者可能存在跨块关系（例如损坏的兄弟指针列表）的损坏。因此，我们仍然需要在主代码体中进行有状态的检查，但一般来说，大部分的逐字段验证是由验证器处理的。

对于读取验证，调用者需要指定预期看到的元数据类型，而IO完成过程则验证该元数据对象是否符合预期。如果验证失败，则将被读取的对象标记为EFSCORRUPTED。调用者需要捕获此错误（如同IO错误一样），如果因验证错误需要采取特殊措施，则可以通过捕获EFSCORRUPTED错误值来实现。如果我们需要在更高层次上更详细地区分错误类型，我们可以根据需要定义新的错误号。

读取验证的第一步是检查魔数并确定是否需要CRC验证。如果是，则计算CRC32c并与对象本身存储的值进行比较。一旦验证通过，将进一步检查位置信息，然后进行广泛的特定对象元数据验证。如果这些检查中的任何一项失败，则认为缓冲区已损坏，并相应设置EFSCORRUPTED错误。

写入验证与读取验证相反——首先对对象进行全面验证，如果一切正常，则更新对象上次修改时的日志序列号（LSN）。之后，计算CRC并将其插入对象中。一旦完成，允许继续写入IO。如果在此过程中发生任何错误，则再次将缓冲区标记为EFSCORRUPTED错误，供更高层捕获。

结构
======

典型的磁盘结构需要包含以下信息：

```c
struct xfs_ondisk_hdr {
    __be32  magic;       // 魔数
    __be32  crc;         // CRC，不记录
    uuid_t  uuid;        // 文件系统标识符
    __be64  owner;       // 父对象
    __be64  blkno;       // 磁盘上的位置
    __be64  lsn;         // 日志中的最后修改时间，不记录
};
```

根据元数据的不同，这些信息可能是一个单独的头部结构的一部分，或者分布在现有的结构中。后者发生在已经包含部分此类信息的情况下，如超级块和AG头部。

其他元数据可能有不同的格式，但通常提供相同级别的信息。例如：

- 短B树块有一个32位的拥有者（AG编号）和一个32位的块号用于定位。这两个结合在一起提供了与上述结构中的@owner和@blkno相同的信息，但使用了8字节较少的空间。
- 目录/属性节点块有一个16位的魔数，包含魔数的头部还包含其他信息。因此，额外的元数据头部会改变元数据的整体格式。

典型的缓冲读取验证器结构如下：

```c
#define XFS_FOO_CRC_OFF offsetof(struct xfs_ondisk_hdr, crc)

static void
xfs_foo_read_verify(
    struct xfs_buf *bp)
{
    struct xfs_mount *mp = bp->b_mount;

    if ((xfs_sb_version_hascrc(&mp->m_sb) &&
        !xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),
                          XFS_FOO_CRC_OFF)) ||
        !xfs_foo_verify(bp)) {
        XFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, bp->b_addr);
        xfs_buf_ioerror(bp, EFSCORRUPTED);
    }
}
```

代码确保只有在文件系统启用了CRC的情况下才检查CRC，通过检查特征位的超级块，然后如果CRC验证通过（或不需要），则验证块的实际内容。

验证函数的形式取决于是否可以使用魔数来确定块的格式。在无法确定的情况下，代码结构如下：

```c
static bool
xfs_foo_verify(
    struct xfs_buf *bp)
{
    struct xfs_mount *mp = bp->b_mount;
    struct xfs_ondisk_hdr *hdr = bp->b_addr;

    if (hdr->magic != cpu_to_be32(XFS_FOO_MAGIC))
        return false;

    if (!xfs_sb_version_hascrc(&mp->m_sb)) {
        if (!uuid_equal(&hdr->uuid, &mp->m_sb.sb_uuid))
            return false;
        if (bp->b_bn != be64_to_cpu(hdr->blkno))
            return false;
        if (hdr->owner == 0)
            return false;
    }

    /* 对象特定的验证检查在这里 */

    return true;
}
```

如果有不同的魔数对应不同的格式，验证器看起来像这样：

```c
static bool
xfs_foo_verify(
    struct xfs_buf *bp)
{
    struct xfs_mount *mp = bp->b_mount;
    struct xfs_ondisk_hdr *hdr = bp->b_addr;

    if (hdr->magic == cpu_to_be32(XFS_FOO_CRC_MAGIC)) {
        if (!uuid_equal(&hdr->uuid, &mp->m_sb.sb_uuid))
            return false;
        if (bp->b_bn != be64_to_cpu(hdr->blkno))
            return false;
        if (hdr->owner == 0)
            return false;
    } else if (hdr->magic != cpu_to_be32(XFS_FOO_MAGIC))
        return false;

    /* 对象特定的验证检查在这里 */

    return true;
}
```

写入验证器与读取验证器非常相似，只是顺序相反。典型的写入验证器如下：

```c
static void
xfs_foo_write_verify(
    struct xfs_buf *bp)
{
    struct xfs_mount *mp = bp->b_mount;
    struct xfs_buf_log_item *bip = bp->b_fspriv;

    if (!xfs_foo_verify(bp)) {
        XFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, bp->b_addr);
        xfs_buf_ioerror(bp, EFSCORRUPTED);
        return;
    }

    if (!xfs_sb_version_hascrc(&mp->m_sb))
        return;

    if (bip) {
        struct xfs_ondisk_hdr *hdr = bp->b_addr;
        hdr->lsn = cpu_to_be64(bip->bli_item.li_lsn);
    }
    xfs_update_cksum(bp->b_addr, BBTOB(bp->b_length), XFS_FOO_CRC_OFF);
}
```

这将在进一步操作之前验证元数据的内部结构，检测元数据在内存中被修改时发生的损坏。如果元数据验证通过，并且启用了CRC，则更新LSN字段（最后一次修改的时间）并计算元数据的CRC。一旦完成，就可以发出IO请求。
### Inodes 和 Dquots

Inodes 和 dquots 是特殊的雪花。它们每个对象都有自己的 CRC（循环冗余校验）和自我标识符，但它们被打包在一起，使得每个缓冲区中有多个对象。因此，我们不使用每个缓冲区的验证器来完成每个对象的验证和 CRC 计算工作。每个缓冲区的验证器仅执行基本的身份识别——即它们包含的是 inodes 还是 dquots，并且所有预期位置都存在魔法数字。所有进一步的 CRC 和验证检查都在每个 inode 从缓冲区读出或写回时进行。

验证器结构和标识符检查与上面描述的缓冲区代码非常相似。唯一的区别在于它们被调用的位置。例如，inode 的读取验证是在 xfs_inode_from_disk() 中完成的，当 inode 首次从缓冲区中读出并且 struct xfs_inode 被实例化时。inode 在写回过程中已经在 xfs_iflush_int 中进行了广泛的验证，因此这里唯一需要增加的就是在将 inode 复制回缓冲区时添加 LSN 和 CRC。

XXX：inode 未链接列表修改没有重新计算 inode 的 CRC！所有未链接列表的修改都没有检查或更新 CRC，无论是在 unlink 过程中还是在日志恢复期间。因此，这个问题一直没有被注意到。这不会立即产生影响——修复程序可能会抱怨这一点——但它需要得到解决。
