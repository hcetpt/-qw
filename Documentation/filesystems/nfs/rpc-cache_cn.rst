RPC 缓存
========

本文档简要介绍了用于 NFS 认证的 sunrpc 层中的缓存机制。
缓存
======

该缓存取代了旧的导出表，并允许缓存各种各样的值。尽管这些缓存在结构上相似，但在内容和用途上可能有很大不同。有一套通用代码用于管理这些缓存。

可能需要的一些缓例如：

  - 从 IP 地址到客户端名称的映射
  - 从客户端名称和文件系统到导出选项的映射
  - 从 UID 到 GID 列表的映射，以绕过 NFS 的 16 个 GID 限制
  - 在没有统一 UID 分配的站点之间，本地 UID/GID 和远程 UID/GID 之间的映射
  - 从网络标识到加密认证公钥的映射

通用代码处理如下事项：

  - 带正确锁定的一般缓存查找
  - 支持“负”条目以及正条目
  - 允许缓存项设置过期时间，并在它们过期且不再使用时移除
  - 向用户空间发出请求以填充缓存条目
  - 允许用户空间直接设置缓存中的条目
  - 延迟依赖于尚未完成的缓存条目的 RPC 请求，并在缓存条目完成时重放这些请求
  - 在条目过期时清理旧条目

创建一个缓存
--------------

- 一个缓存需要存储的数据。这需要一个结构定义，其中必须包含一个 `struct cache_head` 成员，通常是第一个成员。
  它还将包含一个键和一些内容。
每个缓存元素都有引用计数，并包含用于缓存管理的过期时间和更新时间。
- 缓存需要一个“cache_detail”结构来描述缓存。这个结构存储了哈希表、一些用于缓存管理的参数以及一些操作，这些操作详细说明了如何处理特定的缓存项。

这些操作包括：

    struct cache_head *alloc(void)
      这个函数简单地分配适当的内存，并返回嵌入在结构中的 cache_detail 指针。

    void cache_put(struct kref *)
      当对某项的最后一个引用被释放时调用此函数。传递的指针指向 cache_head 中的 'ref' 字段。cache_put 应该释放由 'cache_init' 创建的所有引用，并且如果设置了 CACHE_VALID 标志，则还应释放由 cache_update 创建的所有引用。然后，它应该释放由 'alloc' 分配的内存。

    int match(struct cache_head *orig, struct cache_head *new)
      测试两个结构中的键是否匹配。如果匹配则返回 1，否则返回 0。

    void init(struct cache_head *orig, struct cache_head *new)
      从 'orig' 设置 'new' 中的 'key' 字段。这可能包括获取共享对象的引用。

    void update(struct cache_head *orig, struct cache_head *new)
      从 'orig' 设置 'new' 中的 'content' 字段。

    int cache_show(struct seq_file *m, struct cache_detail *cd, struct cache_head *h)
      可选。用于提供一个 /proc 文件以列出缓存的内容。这个函数应该显示一个条目，通常只显示在一行上。

    int cache_request(struct cache_detail *cd, struct cache_head *h, char **bpp, int *blen)
      格式化一个请求，以便发送到用户空间以实例化一个条目。*bpp 是一个大小为 *blen 的缓冲区。
      *bpp 应该向前移动覆盖编码的消息，并且 *blen 应该减少以显示剩余的可用空间。成功时返回 0，如果空间不足或其他问题则返回 <0。
```c
int cache_parse(struct cache_detail *cd, char *buf, int len)
    一条来自用户空间的消息已到达，用于填充缓存条目。该消息位于长度为 'len' 的 'buf' 中。
    cache_parse 应解析此消息，使用 sunrpc_cache_lookup_rcu 查找缓存中的项目，并使用 sunrpc_cache_update 更新该项目。

- 缓存需要使用 cache_register() 进行注册。这会将其包含在一个列表中，定期清理以丢弃旧数据。

使用缓存
--------

要查找缓存中的值，请调用 sunrpc_cache_lookup_rcu 并传递一个指向示例项中的缓存头指针，其中 'key' 字段已填写。
这将传递给 ->match 以识别目标条目。如果没有找到条目，则会创建一个新的条目，添加到缓存中，并标记为不包含有效数据。
返回的项目通常会传递给 cache_check，该函数会检查数据是否有效，并可能发起一个上层调用以获取最新数据。
如果条目是负数或需要上层调用但不可能，则 cache_check 将返回 -ENOENT；如果上层调用正在进行，则返回 -EAGAIN；如果数据有效，则返回 0。

cache_check 可以传递一个 "struct cache_req*"。该结构通常嵌入在实际请求中，并可以用来创建请求的延迟副本（struct cache_deferred_req）。
当找到的缓存项不是最新的，但有理由相信用户空间可能会很快提供信息时，就会这样做。当缓存项确实变得有效时，将重新访问延迟副本的请求（->revisit）。
预期这种方法将重新调度请求以进行处理。
sunrpc_cache_lookup_rcu 返回的值也可以传递给 sunrpc_cache_update 以设置项目的内 容。传递第二个项目，该项目应包含内容。
如果 _lookup 找到的项目包含有效数据，则丢弃该项目并创建新项目。这使得任何使用项目的人不必担心在检查过程中内容发生变化。
如果 _lookup 找到的项目不包含有效数据，则复制内容并设置 CACHE_VALID。

sunrpc_cache_lookup_rcu 返回的值还可以传递给 sunrpc_cache_update 以设置项目的内容。传递的第二个项目应该包含内容。
如果 _lookup 找到的项目包含有效数据，则丢弃该项目并创建新项目。这样可以确保任何使用项目的人不必担心在检查过程中内容发生变化。
如果 _lookup 找到的项目不包含有效数据，则复制内容并设置 CACHE_VALID。

填充缓存
--------

每个缓存都有一个名称，当缓存注册时，在 /proc/net/rpc 下会创建一个具有该名称的目录。

该目录包含一个名为 'channel' 的文件，该文件是用于填充缓存的内核与用户空间之间通信的通道。
该目录以后还可能包含其他用于与缓存交互的文件。
```
希望这个翻译对你有所帮助！如果有任何问题或需要进一步修改，请告诉我。
该‘通道’的工作方式有点类似于数据报套接字。每个‘写入’作为一个整体传递给缓存进行解析和解释。
每个缓存可以不同地处理写入请求，但预期一条消息中应包含以下内容：

- 一个键
- 一个过期时间
- 一个内容

其意图是，缓存中具有给定键的项应被创建或更新为具有给定的内容，并且该项的过期时间应被设置。

从通道读取稍微更有趣一些。当缓存查找失败时，或者成功但找到可能很快过期的条目时，会提交一个请求，要求用户空间对该缓存项进行更新。这些请求会出现在通道文件中。
连续的读取将返回连续的请求。
如果没有更多的请求可返回，则读取操作会返回EOF，但是select或poll等待读取的操作会被阻塞，直到另一个请求被添加进来。
因此，用户空间的辅助程序可能会如下操作：

- 打开通道
- 使用select等待可读状态
- 读取一个请求
- 写入一个响应
- 进入循环

如果它崩溃并需要重启，任何未回答的请求仍会出现在文件中，并由新的辅助程序实例读取。
每个缓存都应定义一个“cache_parse”方法，该方法接收从用户空间写入的消息并对其进行处理。它应返回一个错误（该错误会回传到写入系统调用）或0。
每个缓存还应定义一个“cache_request”方法，该方法接收一个缓存项并将请求编码到提供的缓冲区中。

.. note::
  如果缓存所在的通道上没有活跃的读取者，并且超过60秒没有活跃的读取者，则后续的请求将不会被添加到该通道中，而是所有未找到有效条目的查找将会失败。这在一定程度上是为了向后兼容：之前的NFS导出表被视为权威的，查找失败意味着明确的“否”。

请求/响应格式
-----------------------

虽然每个缓存可以自由选择其在通道上传输请求和响应的格式，但以下推荐的做法是适当的，并且提供了支持例程来帮助实现：
每个请求或响应记录应该是可打印的ASCII字符，并且恰好包含一个换行符，该换行符应在记录的末尾。
记录中的字段应用空格分隔，通常为一个空格。
如果字段中需要使用空格、换行符或空字符，则必须进行转义。有两种机制可用：

-  如果一个字段以`\x`开始，则它必须包含偶数个十六进制数字，这些数字对提供字段中的字节。
-  否则，字段中的`\`必须后面跟三个八进制数字，这些数字给出一个字节的代码。其他字符按原样处理。至少，空格、换行符、空字符和`\`必须以这种方式转义。
