### 使文件系统可导出

#### 概览

所有文件系统操作都需要一个（或两个）目录项（dentry）作为起点。本地应用程序通过打开的文件描述符或当前工作目录/根目录持有合适的目录项的引用计数。然而，通过远程文件系统协议（如NFS）访问文件系统的远程应用程序可能无法保持这样的引用，因此需要另一种方式来引用特定的目录项。由于这种替代形式的引用需要在重命名、截断和服务器重启等情况下保持稳定（尽管这些问题是最具挑战性的），所以简单的答案如“文件名”并不适用。

这里讨论的机制允许每个文件系统实现指定如何为任何目录项生成一个不透明（在文件系统之外不可见）的字节串，并且如何为给定的不透明字节串找到一个合适的目录项。

这个字节串将被称为“文件句柄片段”，因为它对应于NFS文件句柄的一部分。

支持文件句柄片段与目录项之间映射的文件系统将被称为“可导出”的。

#### Dcache问题

dcache通常包含任何给定文件系统树的一个正确前缀。这意味着如果某个文件系统对象存在于dcache中，则该对象的所有祖先也存在于dcache中。

由于正常的访问是通过文件名进行的，这个前缀自然会创建并容易维护（每个对象对其父对象保持一个引用计数）。

然而，当通过解释文件句柄片段将对象包含到dcache时，没有自动创建该对象的路径前缀。这导致了dcache中的两个相关但不同的特性，这些特性在正常文件系统访问中不需要：

1. dcache有时必须包含不属于正确前缀的对象，即那些不连接到根的对象。
2. dcache必须准备好新发现（通过`->lookup`）的目录已经有一个（未连接的）目录项，并且能够根据父对象和`->lookup`中的名称将该目录项移动到位。这对于目录尤其重要，因为dcache的一个不变量是目录只有一个目录项。

为了实现这些特性，dcache具有以下功能：

a. 一个目录项标志`DCACHE_DISCONNECTED`，用于标记任何可能不属于正确前缀的目录项。
这是在创建匿名目录项时设置的，并且在注意到一个目录项是属于正确前缀的目录项的子目录项时清除。如果设置了此标志的目录项的引用计数变为零，则该目录项会立即被丢弃，而不是保留在目录缓存中。如果一个不在目录缓存中的目录项通过文件句柄（如NFSD可能会做的那样）被反复访问，那么每次访问都会为它分配一个新的目录项，并在访问结束时丢弃。

请注意，这样的目录项可以在不丢失`DCACHE_DISCONNECTED`标志的情况下获得子目录、名称、祖先等。该标志只有在子树成功重新连接到根目录时才会被清除。在此之前，子树中的目录项仅在有引用时保留；引用计数达到零意味着立即驱逐，与未哈希的目录项相同。这保证了我们在卸载时不需要去查找它们。

b. 创建次级根目录的原语——`d_obtain_root(inode)`
这些不会带有`DCACHE_DISCONNECTED`标志。它们被放置在每个超级块列表（`->s_roots`）上，以便在卸载时可以找到并进行驱逐。

c. 辅助例程用于分配匿名目录项，并帮助在查找时附加松散的目录目录项。它们包括：

- `d_obtain_alias(inode)` 将返回给定inode的目录项。
如果该inode已经有目录项，则返回其中一个；
如果没有，则分配一个新的匿名（IS_ROOT 和 DCACHE_DISCONNECTED）目录项并将其附加。
在处理目录的情况下，确保只有一个目录项能够被附加。

- `d_splice_alias(inode, dentry)` 将把一个新的目录项引入到树中；
要么是传入的目录项，要么是给定inode的现有别名（例如由`d_obtain_alias`创建的匿名目录项），视情况而定。
### 返回值为 NULL 的情况

当传递的 `dentry` 被使用时，返回 NULL，遵循 `->lookup` 的调用约定。

### 文件系统问题

为了让一个文件系统可以导出，它必须满足以下条件：

1. 提供下面描述的文件句柄片段（filehandle fragment）函数。
2. 确保在 `->lookup` 找到给定父目录和名称对应的 inode 时，使用 `d_splice_alias` 而不是 `d_add`。

如果 `inode` 为 NULL，则 `d_splice_alias(inode, dentry)` 等价于：

```c
d_add(dentry, inode), NULL
```

同样地，`d_splice_alias(ERR_PTR(err), dentry)` 等价于 `ERR_PTR(err)`。

通常情况下，`->lookup` 函数将以如下方式结束：

```c
return d_splice_alias(inode, dentry);
```

### 文件系统实现

文件系统的实现通过设置 `struct super_block` 中的 `s_export_op` 字段来声明该文件系统实例是可导出的。该字段必须指向一个 `struct export_operations` 结构体，该结构体包含以下成员：

- `encode_fh`（必需）
  - 接受一个 `dentry` 并创建一个文件句柄片段，该片段以后可用于查找或创建同一个对象的 `dentry`。

- `fh_to_dentry`（必需）
  - 给定一个文件句柄片段，应找到隐含的对象并为其创建一个 `dentry`（可能使用 `d_obtain_alias`）。

- `fh_to_parent`（可选但强烈推荐）
  - 给定一个文件句柄片段，应找到隐含对象的父目录并为其创建一个 `dentry`（可能使用 `d_obtain_alias`）。如果文件句柄片段太小可能会失败。

- `get_parent`（可选但强烈推荐）
  - 给定一个目录的 `dentry`，应返回其父目录的 `dentry`。父目录的 `dentry` 可能是由 `d_alloc_anon` 分配的。默认的 `get_parent` 函数只会返回错误，因此任何需要查找父目录的文件句柄查找都会失败。`->lookup("..")` 不作为默认方法使用，因为它可能会在 `dcache` 中留下难以处理的 `..` 条目。

- `get_name`（可选）
  - 给定一个父目录的 `dentry` 和一个子目录的 `dentry`，应找到父目录标识的目录中的名称，该名称指向子目录标识的对象。如果没有提供 `get_name` 函数，则会提供一个默认实现，该实现使用 `vfs_readdir` 查找潜在的名称，并匹配 inode 编号以找到正确的匹配项。

- `flags`
  - 某些文件系统可能需要与其他文件系统不同的处理方式。`export_operations` 结构体还包括一个 `flags` 字段，允许文件系统向 `nfsd` 传达此类信息。有关更多解释，请参见下面的“导出操作标志”部分。
文件句柄片段由一个或多个4字节的单词数组组成，以及一个字节的“类型”。
decode_fh例程不应依赖传递给它的指定大小。这个大小可能比encode_fh生成的原始文件句柄大，在这种情况下，它会被空字节填充。相反，encode_fh例程应选择一个“类型”，以指示decode_fh多少部分的文件句柄是有效的，以及如何解释这些内容。

导出操作标志
-----------------------
除了操作向量指针外，struct export_operations还包含一个“flags”字段，允许文件系统告知nfsd在处理时可能需要以不同的方式操作。以下定义了以下标志：

  EXPORT_OP_NOWCC - 在此文件系统上禁用NFSv3的WCC属性
    RFC 1813建议服务器在每次操作后始终向客户端发送弱缓存一致性（WCC）数据。服务器应该原子地收集inode的属性，对该inode执行操作，然后再次收集其后的属性。这允许客户端在某些情况下跳过GETATTR请求，但意味着服务器几乎对所有RPC调用都会调用vfs_getattr。对于某些文件系统（特别是集群或网络化的文件系统），这是昂贵的，并且难以保证原子性。此标志告诉nfsd在对此文件系统进行操作时，在NFSv3回复中不向客户端提供WCC属性。考虑在此类具有昂贵的->getattr inode操作的文件系统上启用此选项，或者当无法保证操作前后属性收集之间的原子性时启用此选项。
EXPORT_OP_NOSUBTREECHK - 禁止在此文件系统上进行子树检查
    许多NFS操作涉及文件句柄，服务器必须对其进行验证，以确保它们位于导出树内。当导出包含整个文件系统时，这是微不足道的。nfsd只需确保文件句柄位于该文件系统上即可。然而，当仅导出文件系统的一部分时，nfsd必须遍历inode的祖先节点，以确保其位于导出的子树内。这是一个昂贵的操作，并非所有文件系统都能正确支持它。此标志使文件系统免于子树检查，并导致exportfs尝试启用子树检查时返回错误。
EXPORT_OP_CLOSE_BEFORE_UNLINK - 在unlink前总是关闭缓存的文件
    在某些可导出的文件系统（如NFS）上，删除一个仍处于打开状态的文件可能会导致相当多的额外工作。例如，NFS客户端会执行一个“傻重命名”（sillyrename），以确保文件在仍然打开的情况下不会被删除。在重新导出时，打开的文件由nfsd持有，因此我们通常会执行一次傻重命名，然后在链接计数实际变为零时立即删除傻重命名的文件。有时此删除操作可能会与其他操作（例如删除父目录）发生竞争。此标志使得nfsd在调用vfs进行unlink或替换现有文件的重命名之前关闭此inode上的任何打开文件。
EXPORT_OP_REMOTE_FS - 此文件系统的后端存储是远程的
    PF_LOCAL_THROTTLE用于回环NFSD，其中线程需要写入一个bdi（最终bdi），以便释放排队到另一个bdi（客户端bdi）的写入。这样的线程获得一个私有的脏页余额，以确保客户端bdi的脏页不影响写入最终bdi的守护进程。对于持久存储不在本地的文件系统（如导出的NFS文件系统），此限制会产生负面影响。EXPORT_OP_REMOTE_FS允许导出禁用写回节流。
EXPORT_OP_NOATOMIC_ATTR - 文件系统不能原子地更新属性
    EXPORT_OP_NOATOMIC_ATTR表示导出的文件系统无法提供NFSv4的change_info4中的“原子”布尔值所需的语义。此布尔值告诉客户端返回的更改前和更改后的属性是否与请求的元数据操作（如UNLINK、OPEN/CREATE、MKDIR等）原子地获取。
EXPORT_OP_FLUSH_ON_CLOSE - 文件系统在close(2)时刷新文件数据
    在大多数文件系统上，inode可以在文件关闭后仍然处于写回状态。NFSD依赖于客户端活动或本地刷新线程来处理写回。某些文件系统（如NFS）会在文件最后一次关闭时刷新inode的所有脏数据。此类行为的导出应设置EXPORT_OP_FLUSH_ON_CLOSE，以便NFSD知道在关闭此类文件时无需等待写回。
EXPORT_OP_ASYNC_LOCK —— 表示一个有能力从 lockd 处理异步锁请求的文件系统。只有当文件系统有自己的 ->lock() 功能时，才设置 EXPORT_OP_ASYNC_LOCK，因为核心的 posix_lock_file() 实现目前还不支持异步锁请求处理。关于如何在 ->lock() 文件操作结构中指示异步锁请求的更多信息，请参阅 fs/locks.c 以及 vfs_lock_file() 函数的注释。
