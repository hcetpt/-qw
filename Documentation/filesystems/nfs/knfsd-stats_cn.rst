============================
内核NFS服务器统计信息
============================

:作者: Greg Banks <gnb@sgi.com> - 2009年3月26日

本文档描述了内核NFS服务器向用户空间提供的统计信息的格式和语义。这些统计信息以多个文本形式的伪文件提供，每个文件分别如下所述。

在大多数情况下，您不需要了解这些格式，因为nfs-utils分发包中的nfsstat(8)程序提供了用于提取和打印这些统计信息的命令行界面。

所有下面描述的文件都以一系列由换行符'\n'分隔的文本行格式化。以井号'#'开头的行是供人类阅读的注释，解析程序应忽略这些行。所有其他行包含一个由空白字符分隔的字段序列。

/proc/fs/nfsd/pool_stats
========================

此文件自2.6.30及更高版本的内核起可用，前提是/proc/fs/nfsd文件系统已挂载（通常情况下都应该挂载）。

第一行是一个注释，描述了所有其他行中存在的字段。其他行以一系列无符号十进制数字字段的形式呈现以下数据。每行显示一个NFS线程池的数据。

所有计数器都是64位宽，并自然回卷。没有方法来清零这些计数器，相反，应用程序应该自己进行速率转换。

pool
    此行适用的NFS线程池的ID号。
这个编号不会改变。

线程池ID是一个从零开始的连续小整数集。最大值取决于线程池模式，但目前不能大于系统中的CPU数量。

请注意，默认情况下将有一个包含所有nfsd线程和系统中所有CPU的单个线程池，因此此文件将仅有一行，其pool ID为“0”。
### packets-arrived
统计有多少NFS数据包到达。更确切地说，这是网络堆栈通知sunrpc服务器层可能有新数据到达传输层（例如NFS或UDP套接字或NFS/RDMA端点）的次数。

根据NFS工作负载模式和各种网络堆栈效应（如大接收卸载），这可能比收到的NFS调用次数更多或更少（这个统计数据可以在其他地方找到）。然而，这是衡量由于NFS网络流量对sunrpc服务器层造成的CPU负载的一个更准确且与工作负载相关性较小的指标。

### sockets-enqueued
统计有多少次NFS传输被排队等待nfsd线程处理，即没有可用的nfsd线程。
这个统计数据跟踪的情况表明有NFS网络相关的工作要做，但无法立即完成，从而在处理NFS调用时引入了一个小延迟。这个计数器的理想变化率是零；显著非零的值可能表明存在性能瓶颈。

这种情况可能是因为线程池中的nfsd线程数量不足以应对NFS工作负载（工作负载受线程限制），在这种情况下，配置更多的nfsd线程可能会提高NFS工作负载的性能。

### threads-woken
统计有多少次空闲的nfsd线程被唤醒以尝试从NFS传输中接收数据。
这个统计数据跟踪的是传入的网络相关NFS工作被快速处理的情况，这是一个好的现象。这个计数器的理想变化率接近但小于packets-arrived计数器的变化率。

### threads-timedout
统计有多少次nfsd线程触发了空闲超时，即在一段时间内未被唤醒以处理任何传入的网络数据包。
这个统计数据记录了一种情况，即配置的nfsd线程数量超过了NFS工作负载可以使用的数量。这表明减少nfsd线程的数量不会影响性能。不幸的是，这只是一种线索，并不是一个强烈的指示，原因如下：

- 目前这个计数器递增的速度很慢；空闲超时时间为60分钟。除非NFS工作负载在数小时内保持不变，否则这个计数器不太可能提供仍然有用的信息。
通常，提供一些余量是一种明智的做法，即配置比当前所需更多的nfsd进程，以应对未来负载的增加。

注意，NFS传输上的传入数据包将以三种方式之一进行处理。一个nfsd线程可以被唤醒（threads-woken 计数这种情况），或者传输可以被排队稍后处理（sockets-enqueued 计数这种情况），或者因为传输当前正被某个nfsd线程使用而暂时延迟处理。最后一种情况不是很有趣，并没有明确计数，但可以从其他计数推断出来，如下所示：

```
packets-deferred = packets-arrived - ( sockets-enqueued + threads-woken )
```

更多
====

其他统计文件的描述应放在这里。
