SPDX 许可证标识符: GPL-2.0

=======================
NFSv4 客户端标识符
=======================

本文档解释了 NFSv4 协议如何识别客户端实例，以便在系统重启期间保持文件打开和锁定状态。每个客户端上会维护一个特殊的标识符和主体。这些可以由管理员、站点管理员提供的脚本或 Linux 发行版提供的工具来设置。如果客户端的 NFSv4 标识符及其主体选择不当，将存在风险。

介绍
------------

NFSv4 协议使用“基于租约的文件锁定”。租约帮助 NFSv4 服务器提供文件锁定保证并管理其资源。简单来说，NFSv4 服务器为每个 NFSv4 客户端创建一个租约。服务器在其持有的租约下收集每个客户端的文件打开和锁定状态。客户端负责定期更新其租约。只要租约仍然有效，持有该租约的服务器就会保证客户端创建的文件锁保持不变。如果客户端停止更新其租约（例如，如果它崩溃了），NFSv4 协议允许服务器在一段时间后移除客户端的打开和锁定状态。当客户端重新启动时，它会向服务器表明与先前租约相关的打开和锁定状态不再有效，并且可以立即销毁。

此外，每个 NFSv4 服务器都会管理一个持久的客户端租约列表。当服务器重新启动并且客户端尝试恢复其状态时，服务器会使用此列表来区分在服务器重新启动之前持有状态的客户端和发送新的 OPEN 和 LOCK 请求的客户端。这使得文件锁可以在服务器重启期间安全地持续。

NFSv4 客户端标识符
------------------------

每个 NFSv4 客户端向 NFSv4 服务器呈现一个标识符，以便服务器将其与租约关联起来。每个客户端的标识符包含两个元素：

  - co_ownerid：一个任意但固定的字符串
启动验证器：一个64位的实例验证器，使服务器能够区分同一客户端的不同启动周期。
NFSv4.0 规范将这两个项目称为“nfs_client_id4”。NFSv4.1 规范将这两个项目称为“client_owner4”。
NFSv4 服务器将此标识符与客户端在呈现时使用的主体和安全类型关联起来。服务器使用此主体来授权客户端随后发送的租约修改操作。实际上，这个主体是标识符的第三个组成部分。
作为向服务器展示的身份的一部分，一个好的“co_ownerid”字符串具有几个重要的特性：

- “co_ownerid”字符串在重启恢复期间标识客户端，因此该字符串在客户端重启后仍然持久化。
- “co_ownerid”字符串帮助服务器区分其他客户端，因此该字符串在全球范围内是唯一的。请注意，没有中央机构分配“co_ownerid”字符串。
- 由于它经常在网络中以明文形式出现，“co_ownerid”字符串不会泄露关于客户端本身的私有信息。
- “co_ownerid”字符串的内容在客户端尝试NFSv4挂载之前就已经设置且不变。
- NFSv4 协议对“co_ownerid”字符串的大小限制为1024字节。

保护NFSv4租约状态
-------------------

NFSv4 服务器利用上述描述的“client_owner4”为每个客户端分配一个唯一的租约。在这种方案下，存在一些情况下客户端可能会互相干扰。这种情况被称为“租约盗用”。
如果不同的客户端提供了相同的“co_ownerid”字符串并使用了相同的主体（例如，AUTH_SYS 和 UID 0），服务器无法分辨这些客户端不是同一个。每个不同的客户端提供了不同的启动验证器，因此对于服务器来说，看起来就像是一个频繁重启的客户端。
在这一场景中，任何客户端都无法维持打开或锁定状态。
如果不同的客户端提供相同的 "co_ownerid" 字符串并使用不同的主体，服务器可能会允许第一个客户端正常操作，但拒绝随后具有相同 "co_ownerid" 字符串的客户端。
如果客户端的 "co_ownerid" 字符串或主体不稳定，则在服务器或客户端重启后无法保证状态恢复。
如果客户端意外重启并向服务器提供了不同的 "co_ownerid" 字符串或主体，服务器会将客户端之前的打开和锁定状态标记为孤儿。这会阻止访问被锁定的文件，直到服务器移除这些孤儿状态。
如果服务器重启且客户端向服务器提供的 "co_ownerid" 字符串或主体发生了变化，服务器不会允许客户端重新获取其打开和锁定状态，并且在此期间可能会将这些锁分配给其他客户端。这种情况被称为“锁抢占”。
租约抢占和锁抢占增加了拒绝服务攻击的可能性，在极少数情况下甚至可能导致数据损坏。

选择合适的客户端标识符
-------------------------------

默认情况下，Linux NFSv4 客户端实现构建其 "co_ownerid" 字符串时，首先以“Linux NFS”开头，后面跟着客户端的 UTS 节点名称（恰好也是用于 AUTH_SYS 凭证中的“机器名”）。在小型部署中，这种构造通常是足够的。然而，通常节点名称本身不够唯一，并且可能意外发生变化。问题情况包括：

- NFS 根目录（无盘）客户端，其中本地 DHCP 服务器（或类似设备）没有提供唯一的主机名。
- 单个 Linux 主机内的“容器”。如果每个容器有独立的网络命名空间，但没有使用 UTS 命名空间来提供唯一的主机名，则可能存在多个具有相同主机名的 NFS 客户端实例。
- 访问公共 NFS 服务器的不同管理域中的客户端。如果没有集中分配主机名，则除非包含域名，否则无法保证主机名的唯一性。

Linux 提供了两种机制来增加其 "co_ownerid" 字符串的独特性：

- nfs.nfs4_unique_id
  此模块参数可以通过内核命令行或在加载 "nfs" 模块时设置一个任意的唯一标识字符串。
/sys/fs/nfs/net/nfs_client/identifier  
自 Linux 5.3 起，这个虚拟文件仅在访问它的网络命名空间内有效，因此可以在主机名保持一致的情况下区分不同的网络命名空间（容器）。  
注意，此文件在命名空间创建时是空的。如果容器系统能够访问某种基于容器的身份信息，则可以使用这种唯一标识符。例如，可以在启动时使用容器的内部标识符来生成唯一标识符：

    sha256sum /etc/machine-id | awk '{print $1}' \\
        > /sys/fs/nfs/net/nfs_client/identifier

安全考虑  
-----------------------  
强烈建议在租约管理操作中使用加密安全。  
如果未配置带有 Kerberos 的 NFS，Linux 的 NFSv4 客户端将使用 AUTH_SYS 和 UID 0 作为其客户端身份的主要部分。这种配置不仅不安全，还会增加租约和锁被窃取的风险。然而，对于没有本地持久存储的客户端配置，这可能是唯一的选择。“co_ownerid”字符串的唯一性和持久性在这种情况下至关重要。  
当 Linux NFS 客户端存在 Kerberos 密钥表时，客户端在向服务器进行身份验证时会尝试使用密钥表中的某个主体。该行为不由“sec=”挂载选项控制。另外，具有 Kerberos 主体的单用户客户端可以使用该主体代替客户端的主机主体。  
使用 Kerberos 可以使客户端和服务器在所有“sec=”设置覆盖的操作中使用相同的租约。此外，Linux NFS 客户端使用带有 Kerberos 和完整性 QoS 的 RPCSEC_GSS 安全机制，以防止租约修改请求在传输过程中的篡改。

补充说明  
----------------  
Linux 的 NFSv4 客户端在其访问的每个 NFSv4 服务器上建立一个租约。特定服务器上的 Linux NFSv4 客户端的 NFSv4 挂载共享该租约。  
一旦客户端建立了打开和锁定状态，NFSv4 协议允许租约状态迁移到其他服务器，跟随已迁移的数据。这完全隐藏了数据迁移对运行应用程序的影响。Linux NFSv4 客户端通过向遇到的所有服务器呈现相同的“client_owner4”来促进状态迁移。
参见
========

  - nfs(5)
  - kerberos(7)
  - RFC 7530（NFSv4.0 规范）
  - RFC 8881（NFSv4.1 规范）
