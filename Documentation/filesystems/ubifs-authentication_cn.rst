SPDX 许可证标识符: GPL-2.0

UBIFS 认证  
sigma star gmbh  
2018

============================
UBIFS 认证支持
============================

介绍
============

UBIFS 利用 fscrypt 框架为文件内容和文件名提供保密性。这可以防止攻击者在某个时间点读取文件系统的数据。一个典型的例子是丢失的智能手机，攻击者无法在没有文件系统解密密钥的情况下读取设备上的个人数据。
然而，在当前状态下，UBIFS 加密并不能防止攻击者修改文件系统内容并在用户后续使用设备时发生的攻击。在这种情况下，攻击者可以任意修改文件系统的内容而不被用户察觉。一个例子是修改二进制文件，在执行时执行恶意操作[DMC-CBC-ATTACK]。由于 UBIFS 的大部分文件系统元数据都是明文存储的，这使得交换文件和替换其内容变得相当容易。
其他全盘加密系统如 dm-crypt 覆盖所有文件系统元数据，这使得这类攻击更加复杂但并非不可能，特别是在攻击者可以在多个时间点访问设备的情况下。对于基于 Linux 块 I/O 层的 dm-crypt 和其他文件系统，可以使用 dm-integrity 或 dm-verity 子系统 [DM-INTEGRITY, DM-VERITY] 在块层获得完整的数据认证。这些也可以与 dm-crypt 结合使用 [CRYPTSETUP2]。
本文档描述了一种方法，以实现 UBIFS 文件内容及其全部元数据的认证。由于 UBIFS 使用 fscrypt 进行文件内容和文件名加密，认证系统可以与 fscrypt 集成，以便利用现有功能（如密钥派生）。然而，也应该能够不使用加密而仅使用 UBIFS 认证。
MTD、UBI & UBIFS
----------------

在 Linux 中，MTD（Memory Technology Devices）子系统提供了访问原始闪存设备的统一接口。基于 MTD 的较为著名的子系统之一是 UBI（Unsorted Block Images），它为闪存设备提供卷管理，因此在某种程度上类似于为块设备提供的 LVM。此外，它还处理闪存特有的磨损均衡和透明的 I/O 错误处理。UBI 向其上方的层提供逻辑擦除块（LEB），并将其透明地映射到闪存中的物理擦除块（PEB）。
UBIFS 是一种用于原始闪存的文件系统，运行在 UBI 上方。因此，磨损均衡和一些闪存特性留给 UBI 处理，而 UBIFS 则专注于可扩展性、性能和恢复能力。

```
+------------+ +*******+ +-----------+ +-----+
|            | * UBIFS * | UBI-BLOCK | | ... |
| JFFS/JFFS2 | +*******+ +-----------+ +-----+
|            | +-----------------------------+ +-----------+ +-----+
|            | |              UBI            | | MTD-BLOCK | | ... |
+------------+ +-----------------------------+ +-----------+ +-----+
+------------------------------------------------------------------+
|                  MEMORY TECHNOLOGY DEVICES (MTD)                 |
+------------------------------------------------------------------+
+-----------------------------+ +--------------------------+ +-----+
|         NAND DRIVERS        | |        NOR DRIVERS       | | ... |
+-----------------------------+ +--------------------------+ +-----+

           图 1：Linux 内核处理原始闪存的子系统
```

内部，UBIFS 维护了多个数据结构，这些数据结构被持久化在闪存中：

- *索引*：一个位于闪存上的 B+ 树，其中叶节点包含文件系统数据
- *日志*：一个额外的数据结构，用于收集文件系统的更改，然后更新闪存上的索引，并减少闪存磨损
- *树节点缓存 (TNC)*：一个反映当前文件系统状态的内存中的 B+ 树，以避免频繁的闪存读取。基本上这是索引的内存表示形式，但包含了附加属性
*LEB属性树 (LPT)*：一种用于每个UBI LEB空闲空间管理的闪存上的B+树
在本节的其余部分，我们将详细介绍UBIFS的闪存数据结构。TNC在这里的重要性较低，因为它从未直接持久化到闪存中。更多关于UBIFS的信息也可以在 [UBIFS-WP] 中找到。
UBIFS索引与树节点缓存
~~~~~~~~~~~~~~~~~~~~~~~~

基本的UBIFS闪存实体称为*节点*。UBIFS知道不同类型的节点。例如，数据节点（`struct ubifs_data_node`）存储文件内容的块或inode节点（`struct ubifs_ino_node`）表示VFS的inode。几乎所有类型的节点共享一个通用头部（`ubifs_ch`），包含基本信息如节点类型、节点长度、序列号等（参见内核源码中的`fs/ubifs/ubifs-media.h`）。例外是LPT条目和一些不太重要的节点类型，如用于填充LEB末尾不可用内容的填充节点。
为了避免每次更改时重写整个B+树，它被实现为*游走树*，其中只有更改过的节点被重写，并且之前的版本在不立即擦除的情况下被标记为过时。因此，索引不是存储在闪存的一个固定位置上，而是“游走”在闪存中，并且只要包含它们的LEB没有被UBIFS重用，就会有旧的部分留在闪存上。为了找到索引的最新版本，UBIFS将一个特殊的节点称为*主节点*存储到UBI LEB 1中，该节点始终指向UBIFS索引的最新根节点。为了提高可恢复性，主节点还被复制到LEB 2。因此，挂载UBIFS只是一个简单的读取LEB 1和LEB 2以获取当前主节点的过程，并从那里获取最新的闪存索引的位置。
TNC是闪存索引的内存表示形式。它包含每个节点的一些额外运行时属性，这些属性不会持久化。其中一个属性是一个脏标志，用于标记需要在下次将索引写入闪存时进行持久化的节点。TNC充当回写缓存，所有对闪存索引的修改都通过TNC完成。像其他缓存一样，TNC不必将整个索引镜像到内存中，而是在需要时从闪存读取其部分。一个*提交*是UBIFS更新闪存文件系统结构（如索引）的操作。每次提交时，标记为脏的TNC节点都会写入闪存以更新持久化的索引。
日志
~~~~~~

为了避免磨损闪存，索引只在满足某些条件时才持久化（*提交*）（例如`fsync(2)`）。日志用于记录两次索引提交之间所做的任何更改（以inode节点、数据节点等形式）。在挂载过程中，日志从闪存读取并重新播放到TNC（该TNC按需从闪存索引创建）。
UBIFS专门保留了一些LEB用于日志，称为*日志区域*。日志区域LEB的数量在文件系统创建时（使用`mkfs.ubifs`）配置并在超级块节点中存储。日志区域仅包含两种类型的节点：*引用节点*和*提交开始节点*。每当执行索引提交时都会写入一个提交开始节点。每次更新日志时都会写入引用节点。每个引用节点指向闪存上其他节点（inode节点、数据节点等）的位置，这些节点是这个日志条目的组成部分。这些节点被称为*bud*，描述了实际的文件系统更改及其数据。
日志区域作为一个环来维护。当日志几乎满时，会触发一次提交。这也会写入一个提交开始节点，以便在挂载时，UBIFS会寻找最新的提交开始节点，并仅重放其后的每个引用节点。每个提交开始节点之前的引用节点都将被忽略，因为它们已经是闪存索引的一部分。
在写入日志条目时，UBIFS首先确保有足够的空间来写入该条目的引用节点和bud。然后，写入引用节点，之后写入描述文件更改的bud。
在重播过程中，UBIFS 将记录每个引用节点，并检查被引用的 LEB 的位置以发现芽节点。如果这些节点损坏或丢失，UBIFS 将尝试通过重新读取 LEB 来恢复它们。然而，这仅对日志中的最后一个引用 LEB 进行。只有这个 LEB 可能因为断电而损坏。如果恢复失败，UBIFS 将不会挂载。其他任何 LEB 的错误将直接导致 UBIFS 挂载操作失败。

```
| ----    LOG AREA     ---- | ----------    MAIN AREA    ------------ |
 -----+------+-----+--------+----   ------+-----+-----+---------------
 \    |      |     |        |   /  /      |     |     |               \
 / CS |  REF | REF |        |   \  \ DENT | INO | INO |               /
 \    |      |     |        |   /  /      |     |     |               \
  ----+------+-----+--------+---   -------+-----+-----+----------------
          |     |                  ^            ^
          |     |                  |            |
          +------------------------+            |
                |                               |
                +-------------------------------+

图 2：UBIFS 日志区域的 Flash 布局，包含提交开始节点（CS）和引用节点（REF），指向主区域中的芽节点
```

### LEB 属性树/表

LEB 属性树用于存储每个 LEB 的信息。这包括 LEB 类型以及空闲空间和“脏”（旧的、过时的内容）空间的数量[1]。类型很重要，因为 UBIFS 从不在单个 LEB 上混合索引节点和数据节点，因此每个 LEB 都有特定用途。这有助于空闲空间的计算。更多详细信息请参阅 [UBIFS-WP]。
LEB 属性树也是一个 B+ 树，但比索引小得多。由于其较小的大小，在每次提交时总是作为一个块写入。因此，保存 LPT 是一个原子操作。
[1] 由于 LEB 只能追加而不能覆盖，因此空闲空间与可覆盖的过时内容之间存在区别。前者是指无需擦除即可写入的空间，后者是已写入但无法覆盖的内容，除非先擦除整个 LEB。

### UBIFS 认证

#### 概述

本章介绍 UBIFS 认证，使 UBIFS 能够验证存储在 Flash 中的元数据和文件内容的真实性和完整性。

#### 威胁模型

UBIFS 认证能够检测离线数据修改。虽然它不能阻止这种修改，但它允许（受信任的）代码检查 Flash 中的文件内容和文件系统元数据的完整性和真实性。这涵盖了文件内容被替换的攻击。
UBIFS 认证不会保护 Flash 内容的整体回滚。即攻击者仍然可以转储 Flash 并在稍后的时间恢复而不被检测到。它也不会保护个别索引提交的部分回滚。这意味着攻击者能够部分撤销更改。
这是可能的，因为 UBIFS 不会立即覆盖索引树或日志的过时版本，而是标记为过时，并由垃圾收集在稍后时间删除。攻击者可以通过擦除当前树的部分内容并恢复仍在 Flash 上且尚未被擦除的旧版本来实现这一点。这是可能的，因为每个提交都会写入新的索引根节点和主节点，而不是覆盖旧版本。进一步帮助这一点的是 UBI 的磨损均衡操作，它将内容从一个物理擦除块复制到另一个擦除块，并非原子地擦除第一个擦除块。
UBIFS 认证不涵盖攻击者在提供认证密钥后能够在设备上执行代码的情况。
附加措施如安全启动和受信任的启动必须采取以确保仅执行受信任的代码在设备上。

认证
--------------

为了能够完全信任从闪存中读取的数据，所有存储在闪存中的 UBIFS 数据结构都需要进行认证。具体包括：

- 索引：包含文件内容、扩展属性、文件长度等文件元数据。
- 日志：通过记录对文件系统的更改也包含了文件内容和元数据。
- LPT（逻辑擦除块表）：存储 UBI LEB 元数据，UBIFS 用其进行空闲空间管理。

索引认证
~~~~~~~~~

通过 UBIFS 的游走树概念，它已经负责仅更新和持久化从叶节点到整个 B+ 树根节点的变化部分。这使我们能够在树的索引节点中添加每个节点子节点的哈希值。因此，索引本质上也是一个梅克尔树。由于索引的叶节点包含实际的文件系统数据，它们的父索引节点的哈希值覆盖了所有的文件内容和元数据。当文件发生变化时，UBIFS 索引会相应地从叶节点更新到根节点，包括主节点。此过程可以被挂钩，以便同时仅重新计算每个变化节点的哈希值。每当读取文件时，UBIFS 可以验证从每个叶节点到根节点的哈希值，以确保节点的完整性。

为了确保整个索引的真实性，UBIFS 主节点存储了一个对其自身内容的带密钥的哈希（HMAC）以及索引树根节点的哈希值。如上所述，每当索引被持久化（即，在索引提交时），主节点总是被写入闪存。使用这种方法，只有 UBIFS 索引节点和主节点会被修改以包含一个哈希值。所有其他类型的节点将保持不变。这减少了存储开销，这对于 UBIFS 用户（例如嵌入式设备）来说是宝贵的。

```
                             +---------------+
                             |  Master Node  |
                             |    (hash)     |
                             +---------------+
                                     |
                                     v
                            +-------------------+
                            |  Index Node #1    |
                            |                   |
                            | branch0   branchn |
                            | (hash)    (hash)  |
                            +-------------------+
                               |    ...   |  (fanout: 8)
                               |          |
                       +-------+          +------+
                       |                         |
                       v                         v
            +-------------------+       +-------------------+
            |  Index Node #2    |       |  Index Node #3    |
            |                   |       |                   |
            | branch0   branchn |       | branch0   branchn |
            | (hash)    (hash)  |       | (hash)    (hash)  |
            +-------------------+       +-------------------+
                 |   ...                     |   ...   |
                 v                           v         v
               +-----------+         +----------+  +-----------+
               | Data Node |         | INO Node |  | DENT Node |
               +-----------+         +----------+  +-----------+

           图 3：索引节点哈希和主节点 HMAC 的覆盖区域
```

对于鲁棒性和断电安全性，最重要的是原子性地持久化哈希和文件内容。现有的 UBIFS 逻辑已经为此目的设计了如何持久化变化节点，这样如果断电发生时正在持久化，UBIFS 也能安全恢复。向索引节点添加哈希不会改变这一点，因为每个哈希都将与其相应的节点一起原子性地持久化。

日志认证
~~~~~~~~~~

日志也被进行了认证。由于日志是连续写入的，因此有必要频繁地向日志中添加认证信息，以便在断电情况下不会有太多数据无法认证。

这是通过从提交开始节点开始创建一个连续哈希来实现的，该哈希覆盖前一个参考节点、当前参考节点和芽节点。在适合的时候，会在芽节点之间添加认证节点。这种新的节点类型包含当前哈希链状态的 HMAC。这样，日志可以从最后一个认证节点进行认证。日志尾部可能没有认证节点的部分不能被认证，并且在重放日志时会被跳过。

日志认证示意图如下：
```
,,,,,,,,
,......,..........................................
```
由于散列值还包括引用节点，攻击者无法重新排序或跳过任何日志头进行重放。攻击者只能从日志的末尾移除芽节点（bud nodes）或引用节点，从而将文件系统最多回滚到上次提交的状态。

日志区域的位置存储在主节点中。由于主节点如上所述通过HMAC进行了认证，因此不可能在不被检测的情况下篡改它。日志区域的大小在使用`mkfs.ubifs`创建文件系统时指定，并存储在超级块节点中。

为了避免篡改该区域和其他存储在其中的值，超级块结构中添加了一个HMAC。超级块节点存储在LEB 0中，并且仅在特性标志或其他类似更改时进行修改，但从不在文件更改时进行修改。
LPT 认证
~~~~~~~~~~~~~~~~~~

LPT 根节点在闪存上的位置存储在 UBIFS 主节点中。由于 LPT 在每次提交时都是原子性地写入和读取的，因此无需单独认证树中的各个节点。只需通过存储在主节点中的简单哈希来保护整个 LPT 的完整性即可。由于主节点本身是经过认证的，因此可以通过验证主节点的真实性并将其存储的 LTP 哈希与从闪存上读取的 LPT 计算出的哈希进行比较来验证 LPT 的真实性。

密钥管理
--------------

为了简化起见，UBIFS 认证使用一个密钥来计算超级块、主节点、提交开始和引用节点的 HMAC。这个密钥需要在文件系统创建时（`mkfs.ubifs`）用于认证超级块节点。此外，在挂载文件系统时，也需要这个密钥来验证已认证的节点并为更改生成新的 HMAC。

UBIFS 认证旨在与 UBIFS 加密（fscrypt）并行工作，以提供保密性和真实性。由于 UBIFS 加密采用每个目录不同的加密策略，因此可以有多个 fscrypt 主密钥，并且可能有些文件夹没有加密。另一方面，UBIFS 认证采取全有或全无的方式，即要么认证文件系统的全部内容，要么不认证任何内容。正因为如此，并且考虑到 UBIFS 认证也应能在没有加密的情况下使用，它不共享 fscrypt 的相同主密钥，而是管理一个专用的认证密钥。

提供认证密钥的 API 尚未定义，但密钥可以通过用户空间通过类似 fscrypt 当前实现方式的关键环提供。然而需要注意的是，当前的 fscrypt 方法已经显示出其缺陷，用户空间 API 最终将发生变化 [FSCRYPT-POLICY2]。

尽管如此，用户仍然可以在用户空间中提供一个单一的密码或密钥，以覆盖 UBIFS 认证和加密。这可以通过相应的用户空间工具解决，这些工具除了用于加密的 fscrypt 主密钥外，还会派生出第二个用于认证的密钥。

为了能够在挂载时检查是否拥有正确的密钥，UBIFS 超级块节点还将存储认证密钥的哈希。这种方法类似于为 fscrypt 加密策略 v2 提议的方法 [FSCRYPT-POLICY2]。

未来扩展
=================

在某些情况下，供应商希望向客户提供经过认证的文件系统镜像，而不分享秘密的 UBIFS 认证密钥。相反，除了每个 HMAC 外，还可以存储一个数字签名，其中供应商会随文件系统镜像一起提供公钥。如果这个文件系统之后需要修改，UBIFS 可以在首次挂载时用 HMAC 替换所有数字签名，类似于 IMA/EVM 子系统处理这种情况的方式。此时，HMAC 密钥需要按照常规方式提前提供。

参考文献
==========

[CRYPTSETUP2]        https://www.saout.de/pipermail/dm-crypt/2017-November/005745.html

[DMC-CBC-ATTACK]     https://www.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/

[DM-INTEGRITY]       https://www.kernel.org/doc/Documentation/device-mapper/dm-integrity.rst

[DM-VERITY]          https://www.kernel.org/doc/Documentation/device-mapper/verity.rst

[FSCRYPT-POLICY2]    https://www.spinics.net/lists/linux-ext4/msg58710.html

[UBIFS-WP]           http://www.linux-mtd.infradead.org/doc/ubifs_whitepaper.pdf
