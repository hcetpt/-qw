SPDX 许可声明标识符: GPL-2.0

===============================================================
Inotify —— 强大而简单的文件变更通知系统
===============================================================

文档始于 2005 年 3 月 15 日，由 Robert Love <rml@novell.com> 编写

文档于 2015 年 1 月 4 日由 Zhang Zhen <zhenzhang.zhang@huawei.com> 更新

- 删除了过时的接口，用户界面请参考手册页

(i) 理由

问：
为什么不在被监控对象的打开文件描述符上绑定监控？

答：
监控与打开的 inotify 设备相关联，而不是与打开的文件关联。这样解决了 dnotify 的主要问题：保持文件打开会固定该文件，从而更糟的是固定挂载点。因此，在桌面系统中使用 dnotify 是不可行的，因为无法卸载移动媒体。监控一个文件不应要求它必须是打开状态。

问：
为什么选择每个实例一个文件描述符而不是每个监控一个文件描述符？

答：
每个监控一个文件描述符会迅速消耗掉所有允许的文件描述符，超出实际管理的可行范围，并且超出 select() 能最优处理的数量。虽然 root 可以提高每个进程的文件描述符限制，用户也可以使用 epoll，但要求两者同时满足是一种多余的要求。
监控比打开文件占用的内存少，因此将它们分开是有意义的。当前的设计正是用户空间开发者所需要的：用户只需要初始化一次 inotify，并添加 n 个监控，只需一个文件描述符，无需调整文件描述符限制。初始化 inotify 实例两千次是不合理的。如果我们能干净地实现用户空间的需求——我们确实可以，idr 层让这种操作变得简单——那么我们应该这样做。
还有其他好的理由。通过单个文件描述符，有一个单一的阻塞项，映射到一个事件队列。单个文件描述符返回所有监控事件以及任何潜在的带外数据。如果每个文件描述符是一个单独的监控，

- 就没有办法保证事件顺序。foo 文件和 bar 文件上的事件会触发 poll() 在两个文件描述符上的响应，但没有办法知道哪个事件先发生。一个单一的队列可以轻松地给出顺序。这种顺序对于现有应用程序（如 Beagle）至关重要。想象一下没有顺序的“mv a b ; mv b a”事件。
- 我们需要维护 n 个文件描述符和 n 个内部队列及其状态，相比之下，只有一个要容易得多。在内核中这会变得非常混乱。单一的线性队列才是有意义的数据结构。
- 用户空间开发者更喜欢当前的 API。例如，Beagle 团队非常喜欢它。相信我，我问过他们。这并不令人惊讶：谁愿意通过 select() 来管理和阻塞 1000 个文件描述符？

- 没有办法获取带外数据。
- 1024 仍然太低。;-)

当你谈论设计一个可以扩展到数千个目录的文件变更通知系统时，处理数千个文件描述符显然不是合适的接口。这太重了。
此外，确实可以创建多个实例并处理多个队列，因此可以有多个关联的文件描述符。不需要一对一的进程映射；它是每队列一个文件描述符，一个进程可以很容易地需要多个队列。
问：为什么采用系统调用的方法？

答：糟糕的用户空间接口是 dnotify 的第二大问题。信号（Signals）作为一种文件通知机制非常糟糕，实际上，对于任何用途来说都是如此。从所有角度来看，最理想的解决方案是一个基于文件描述符的接口，它允许基本的文件 I/O 和 poll/select 操作。

获取文件描述符并管理监视点可以通过设备文件或一组新的系统调用来实现。我们决定实现一组新的系统调用，因为这是新内核接口的首选方法。唯一的真正区别在于我们是想使用 open(2) 和 ioctl(2)，还是使用几个新的系统调用。系统调用优于 ioctl。
