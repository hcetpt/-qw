SPDX 许可证标识符: GPL-2.0

===================================
已在挂载的文件系统上缓存
===================================

.. 目录：

 (*) 概览
(*) 要求
(*) 配置
(*) 启动缓存
(*) 需要避免的事情
(*) 缓存剔除
(*) 缓存结构
(*) 安全模型和 SELinux
(*) 关于安全性的说明
(*) 统计信息
(*) 调试
(*) 按需读取
概述
========

CacheFiles 是一个缓存后端，旨在将已挂载的本地类型文件系统（如 Ext3）中的目录用作缓存。CacheFiles 使用用户空间守护进程来执行一些缓存管理任务，例如清理过时的节点和修剪。这个守护进程称为 cachefilesd，位于 /sbin 目录下。
缓存的文件系统和数据完整性仅取决于提供支持服务的文件系统的质量。请注意，CacheFiles 不尝试进行日志记录，因为各种文件系统的日志记录接口具有特定性。
CacheFiles 创建了一个杂项字符设备“/dev/cachefiles”，用于与守护进程通信。一次只能有一个程序打开此设备，在其打开期间，至少部分缓存存在。守护进程打开此设备并发送命令以控制缓存。
CacheFiles 当前仅限于单个缓存。
CacheFiles 尝试保持文件系统中至少一定比例的空闲空间，必要时通过修剪其包含的对象来缩小缓存以腾出空间——详见“缓存修剪”部分。这意味着它可以放置在同一介质上作为活动数据集，并扩展以利用空闲空间，在数据集需要更多空间时自动收缩。
要求
============

使用 CacheFiles 及其守护进程需要系统和缓存文件系统具备以下功能：

- dnotify
- 扩展属性 (xattrs)
### openat() 及其相关函数
- 文件系统中文件的 bmap() 支持（FIBMAP ioctl）
- 使用 bmap() 检测文件末尾的部分页面

强烈建议在用作缓存的 Ext3 文件系统上启用 "dir_index" 选项。

### 配置
配置缓存需要使用位于 /etc/cachefilesd.conf 中的脚本。以下命令用于设置缓存以供使用：

```
brun <N>%, bcull <N>%, bstop <N>%, frun <N>%, fcull <N>%, fstop <N>%
```

这些命令用于配置回收限制。可选。详情请参见回收部分。
默认值分别为 7%（运行）、5%（回收）和 1%（停止）。

以 'b' 开头的命令表示文件空间（块）限制，以 'f' 开头的命令表示文件计数限制。

```
dir <path>
```

指定包含缓存根目录的路径。必填项。

```
tag <name>
```

指定一个标签，以便 FS-Cache 区分多个缓存。可选。默认值为 "CacheFiles"。

```
debug <mask>
```

指定一个数字掩码来控制内核模块中的调试信息。
可选。默认值为零（全部关闭）。以下值可以通过“或”操作符组合到掩码中以收集各种信息：

		==	=================================================
		1	启用函数入口追踪（_enter() 宏）
		2	启用函数出口追踪（_leave() 宏）
		4	启用内部调试点追踪（_debug()）
		==	=================================================

此掩码也可以通过 sysfs 设置，例如：

		echo 5 >/sys/modules/cachefiles/parameters/debug

启动缓存
==================

通过运行守护进程来启动缓存。守护进程打开缓存设备，配置缓存，并告知其开始缓存。此时，缓存将绑定到 fscache 并使缓存生效。守护进程的运行方式如下：

	/sbin/cachefilesd [-d]* [-s] [-n] [-f <configfile>]

标志含义如下：

``-d``
	增加调试级别。可以多次指定该选项，每次指定都会累加
``-s``
	将消息发送到标准错误输出而不是系统日志
``-n``
	不以守护进程模式运行并进入后台
``-f <configfile>``
	使用替代配置文件而非默认文件

需要避免的事情
==================

不要在缓存内挂载其他内容，因为这会导致问题。内核模块包含一个非常简化的路径遍历功能，该功能会忽略挂载点，但守护进程无法避免它们。
不要在缓存处于活动状态时创建、重命名或删除缓存中的文件和目录，因为这可能导致状态变得不确定。
在缓存中重命名文件可能会导致对象看起来像其他对象（文件名是查找键的一部分）。
不要更改或移除缓存文件上附加的扩展属性，因为这会导致缓存状态管理混乱。
不要在缓存中创建文件或目录，以免缓存变得混乱或提供错误的数据。
不要更改缓存中的文件权限。模块使用最小权限创建文件，以防止随机用户直接访问它们。

### 缓存清理
缓存偶尔需要进行清理以腾出空间。这涉及丢弃最近较少使用的缓存对象。清理基于数据对象的访问时间。如果空目录未被使用，则也会被清理。

缓存清理基于底层文件系统中可用块和文件的百分比。有六个“限制”：

- **brun, frun**
  如果缓存中的空闲空间和可用文件数量超过这两个限制，则关闭清理。
  
- **bcull, fcull**
  如果缓存中的可用空间或可用文件数量低于这两个限制中的任何一个，则启动清理。

- **bstop, fstop**
  如果缓存中的可用空间或可用文件数量低于这两个限制中的任何一个，则不允许进一步分配磁盘空间或文件，直到清理使这些数值再次高于这些限制。

这些限制必须这样配置：
```
0 <= bstop < bcull < brun < 100
0 <= fstop < fcull < frun < 100
```

请注意，这些是可用空间和可用文件的百分比，并不显示为 `df` 程序显示的百分比减去 100 的值。

用户空间守护进程会扫描缓存以建立一个可清理对象的表。然后按最近最少使用的顺序进行清理。一旦表中有空间，就会开始新的缓存扫描。如果对象的访问时间发生变化或内核模块表示仍在使用这些对象，则会跳过这些对象。

### 缓存结构
CacheFiles 模块将在给定的目录中创建两个子目录：

- `cache/`
- `graveyard/`

所有活动缓存对象都位于第一个目录中。CacheFiles 内核模块将无法简单删除的已退役或被清理的对象移动到 `graveyard/` 目录，然后由守护进程实际删除它们。

守护进程使用 dnotify 监控 `graveyard/` 目录，并删除出现在该目录中的任何内容。
该模块将索引对象表示为带有文件名 "I..." 或 "J..." 的目录。请注意，"cache/" 目录本身是一个特殊的索引对象。数据对象如果没有任何子对象，则表示为文件；如果有子对象，则表示为目录。它们的文件名都以 "D..." 或 "E..." 开头。如果表示为目录，数据对象将在该目录中有一个名为 "data" 的文件来实际存储数据。特殊对象与数据对象类似，不同之处在于它们的文件名以 "S..." 或 "T..." 开头。

如果一个对象有子对象，则表示为目录。在代表目录中，有一系列以子对象键的哈希值（前面加上 '@'）命名的目录。如果可能的话，子对象的表示将被放置到这个目录中：

```
 /INDEX    /INDEX     /INDEX                            /DATA FILES
/=========/==========/=================================/================
cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400
cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...DB1ry
cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...N22ry
cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...FP1ry
```

如果键太长以至于加上装饰符后超过了 `NAME_MAX`，则会被分成几部分，前几部分用于创建嵌套目录，最后一部分则是最后一个目录中的对象。中间目录的名称将以 '+' 前缀表示：

```
J1223/@23/+xy...z/+kl...m/Epqr
```

请注意，键是原始数据，不仅可能超过 `NAME_MAX` 大小，还可能包含诸如 '/' 和 NUL 字符等，因此它们可能不适合直接转换为文件名。为了处理这个问题，`CacheFiles` 将直接使用合适的可打印文件名，并对不合适的文件名进行 "base-64" 编码。两种版本的对象文件名指示了编码方式：

```
===============	===============	===============
OBJECT TYPE	PRINTABLE	ENCODED
===============	===============	===============
Index		"I..."		"J..."
Data		"D..."		"E..."
Special		"S..."		"T..."
===============	===============	===============
```

中间目录始终为 "@" 或 "+" 之一。
缓存中的每个对象都有一个扩展属性标签，其中包含对象类型 ID（用于区分特殊对象）和从网络文件系统获取的辅助数据。后者用于检测缓存中的陈旧对象并更新或淘汰它们。请注意，`CacheFiles` 会从缓存中删除任何不认识的文件或类型不正确的文件（例如管道文件或设备文件）。

安全模型和 SELinux
==================

`CacheFiles` 实现时充分考虑了 Linux 内核的 LSM 安全特性以及 SELinux 设施。
`CacheFiles` 面临的一个问题是，它通常代表某个进程运行，并且在该进程上下文中执行，这包括一个不适合访问缓存的安全上下文——要么是因为缓存中的文件对该进程不可访问，要么是因为如果该进程在缓存中创建文件，该文件可能对其他进程不可访问。
CacheFiles 的工作原理是暂时更改进程的安全上下文（fsuid、fsgid 和行为者安全标签）——而不改变该进程作为其他进程操作目标时的安全上下文（因此信号和其他类似功能仍然正常工作）。

当 CacheFiles 模块被请求绑定到其缓存时，它会执行以下操作：

1. 找到根缓存目录所附带的安全标签，并使用该标签作为创建文件的安全标签。默认情况下，这个标签为：
   ```
   cachefiles_var_t
   ```

2. 找到发出绑定请求的进程的安全标签（假定为 cachefilesd 守护进程），默认情况下该标签为：
   ```
   cachefilesd_t
   ```
   并要求 LSM 提供一个基于守护进程标签的行为安全 ID。默认情况下，这个安全 ID 为：
   ```
   cachefiles_kernel_t
   ```
   SELinux 根据策略中的规则将守护进程的安全 ID 过渡到模块的安全 ID，例如：
   ```
   type_transition <daemon's-ID> kernel_t : process <module's-ID>;
   ```
   例如：
   ```
   type_transition cachefilesd_t kernel_t : process cachefiles_kernel_t;
   ```

模块的安全 ID 允许它在缓存中创建、移动和删除文件及目录，查找和访问缓存中的目录和文件，设置和访问缓存对象的扩展属性，以及读写缓存中的文件。
守护进程的安全 ID 只赋予了非常有限的权限：它可以扫描目录、获取文件信息并删除文件和目录。它不能读取或写入缓存中的文件，因此无法访问缓存中的数据；也不允许在缓存中创建新文件。

可以在以下位置找到策略源文件：
```
https://people.redhat.com/~dhowells/fscache/cachefilesd-0.8.tar.bz2
```
及其后续版本。在该压缩包中，请查看以下文件：
```
cachefilesd.te
cachefilesd.fc
cachefilesd.if
```
这些文件由 RPM 直接构建和安装。
如果使用的是非 RPM 基础系统，则将上述文件复制到自己的目录中，并运行：
```
make -f /usr/share/selinux/devel/Makefile
semodule -i cachefilesd.pp
```
在构建之前需要安装 checkpolicy 和 selinux-policy-devel。

默认情况下，缓存位于 /var/fscache，但如果希望将其放在其他位置，则需要修改上述策略文件或安装辅助策略来标记缓存的替代位置。
有关如何在 SELinux 强制模式下添加辅助策略以使缓存位于其他位置的说明，请参阅：
```
/usr/share/doc/cachefilesd-*/move-cache.txt
```
当安装 cachefilesd rpm 包时；或者可以在源代码中找到该文档。

安全注意事项
=============

CacheFiles 利用了 task_struct 中的安全分离。它分配了自己的 task_security 结构，并在代表另一个进程在其上下文中操作时将 current->cred 重定向到该结构。
这样做的原因是它调用 vfs_mkdir() 等函数而不是绕过安全直接调用索引节点操作。因此，VFS 和 LSM 可能会拒绝 CacheFiles 访问缓存数据，因为在某些情况下，缓存代码是在发起 netfs 系统调用的进程的安全上下文中运行的。
此外，如果 CacheFiles 创建了一个文件或目录，该对象的安全参数（UID、GID、安全标签）将从发出系统调用的进程派生，这可能会阻止其他进程访问缓存——包括 CacheFiles 的缓存管理守护进程（cachefilesd）。
所需的是暂时覆盖发出系统调用的进程的安全性。然而，我们不能直接修改安全数据，因为这会影响进程作为一个对象，而不仅仅是作为主体。这意味着它可能会丢失信号或ptrace事件等，并且会影响/proc中显示的进程状态。

因此，CacheFiles利用了安全性中的逻辑分离，即客观安全性（task->real_cred）和主观安全性（task->cred）。客观安全性持有进程的内在安全属性，并且永远不会被覆盖。这是在/proc中显示的内容，并且当一个进程成为其他进程操作的目标时（例如SIGKILL），会使用这一部分的安全信息。

主观安全性则持有进程的活动安全属性，并且可以被覆盖。这部分不会对外显示，并且在进程对另一个对象执行操作时使用，例如SIGKILL另一个进程或打开文件。

LSM钩子允许SELinux（或其他类似机制）拒绝CacheFiles以特定安全标签运行的请求，或者创建具有其他安全标签的文件和目录。

### 统计信息

如果FS-Cache编译时启用了以下选项：

```
CONFIG_CACHEFILES_HISTOGRAM=y
```

那么它将收集某些统计信息，并通过一个proc文件 `/proc/fs/cachefiles/histogram` 显示这些信息：

```
cat /proc/fs/cachefiles/histogram
JIFS  SECS  LOOKUPS   MKDIRS    CREATES
===== ===== ========= ========= =========
```

这展示了每个时间段内各种任务执行次数的细分。这些时间段从0 jiffies到HZ-1 jiffies不等。列如下所示：

- - - - -
COLUMN | TIME MEASUREMENT
- - - - -
LOOKUPS | 执行支持文件系统的查找操作所花费的时间
MKDIRS | 执行支持文件系统的mkdir操作所花费的时间
CREATES | 执行支持文件系统的create操作所花费的时间
- - - - -

每一行显示了在特定时间范围内发生的事件数量。每一步的时间跨度为1 jiffies。JIFS列指示覆盖的特定jiffies范围，SECS字段表示相应的秒数。

### 调试

如果启用了 `CONFIG_CACHEFILES_DEBUG`，可以通过调整以下路径中的值来启用CacheFiles的运行时调试：

```
/sys/module/cachefiles/parameters/debug
```

这是一个调试流的位掩码：

- - - - - - - - - - - 
BIT | VALUE | STREAM | POINT
- - - - - - - - - - - 
0 | 1 | General | 函数入口跟踪
1 | 2 | | 函数退出跟踪
2 | 4 | | 通用
- - - - - - - - - - - 

应将合适的值进行按位或运算，并将结果写入控制文件。例如：

```
echo $((1|4|8)) >/sys/module/cachefiles/parameters/debug
```

这将开启所有函数入口的调试。
按需读取
==============

在原始模式下工作时，CacheFiles 作为远程网络文件系统的本地缓存。而在按需读取模式下，CacheFiles 可以提升需要按需读取语义的场景性能，例如容器镜像分发。这两种模式之间的主要区别在于缓存未命中发生时的行为：在原始模式下，网络文件系统会从远程服务器获取数据并写入缓存文件；而在按需读取模式下，获取数据并将其写入缓存的任务委托给用户空间守护进程。

要支持按需读取模式，应启用配置项 `CONFIG_CACHEFILES_ONDEMAND`。

协议通信
----------------------

按需读取模式使用一种简单的协议来实现内核与用户空间守护进程之间的通信。该协议可以表示为：

```
内核 --[请求]--> 用户空间守护进程 --[响应]--> 内核
```

当需要时，CacheFiles 会向用户空间守护进程发送请求。用户空间守护进程应该轮询设备节点（`/dev/cachefiles`）以检查是否有待处理的请求。如果有待处理的请求，则会返回一个 `POLLIN` 事件。用户空间守护进程随后读取设备节点以获取待处理的请求。需要注意的是，每次读取只能获取一个请求。完成请求处理后，用户空间守护进程应将响应写回设备节点。

每个请求都以如下形式的消息头开始：

```c
struct cachefiles_msg {
    __u32 msg_id;
    __u32 opcode;
    __u32 len;
    __u32 object_id;
    __u8  data[];
};
```

其中：
- `msg_id` 是一个唯一标识符，用于标识所有待处理请求中的此请求。
- `opcode` 表示此请求的类型。
- `object_id` 是一个唯一标识符，用于标识被操作的缓存文件。
- `data` 表示此请求的有效载荷。
- `len` 表示整个请求的长度，包括消息头和后续特定类型的负载。
开启按需模式
-------------------------

“bind”命令将提供一个可选参数：

	bind [ondemand]

当“bind”命令没有给出任何参数时，默认为原始模式。当给出“ondemand”参数，即“bind ondemand”时，将启用按需读取模式。

打开请求（OPEN Request）
----------------

当netfs首次打开缓存文件时，会向用户守护进程发送一条带有CACHEFILES_OP_OPEN操作码的请求，即打开请求。其有效载荷格式如下：

    struct cachefiles_open {
        __u32 volume_key_size;
        __u32 cookie_key_size;
        __u32 fd;
        __u32 flags;
        __u8  data[];
    };

其中：

    * ``data`` 包含volume_key，紧随其后的是cookie_key。
    Volume key是一个NUL终止的字符串；cookie key是二进制数据。
    * ``volume_key_size`` 表示volume key的字节大小。
    * ``cookie_key_size`` 表示cookie key的字节大小。
    * ``fd`` 表示一个匿名文件描述符，该文件描述符指向缓存文件，通过它用户守护进程可以对缓存文件执行写入和llseek操作。

用户守护进程可以使用给定的(volume_key, cookie_key)对来区分请求的缓存文件。通过提供的匿名文件描述符，用户守护进程可以在后台获取数据并将其写入缓存文件，即使内核尚未触发缓存未命中也是如此。

请注意，每个缓存文件都有一个唯一的object_id，但它可能有多个匿名文件描述符。用户守护进程可以通过dup()从由@fd字段指示的初始匿名文件描述符复制匿名文件描述符。因此，每个object_id可以映射到多个匿名文件描述符，而用户守护进程本身需要维护这个映射。

在实现用户守护进程时，请注意RLIMIT_NOFILE、``/proc/sys/fs/nr_open`` 和 ``/proc/sys/fs/file-max``。通常这些值不需要很大，因为它们与打开的设备块数量相关，而不是每个独立文件系统的打开文件数量。
用户守护进程应通过在 `devnode` 上发出 `"copen"`（完整打开）命令来回复 `OPEN` 请求：

```plaintext
copen <msg_id>,<cache_size>
```

其中：
- `msg_id` 必须与 `OPEN` 请求中的 `msg_id` 字段匹配。
- 当 `cache_size` 大于等于 0 时，表示缓存文件的大小；当 `cache_size` 小于 0 时，表示用户守护进程中遇到的任何错误代码。

### 关闭请求 (CLOSE Request)

当一个 cookie 被撤销时，会向用户守护进程发送一个 `CLOSE` 请求（操作码为 `CACHEFILES_OP_CLOSE`）。这告诉用户守护进程关闭与给定 `object_id` 相关的所有匿名文件描述符。`CLOSE` 请求没有额外的有效载荷，并且不应进行回复。

### 读取请求 (READ Request)

当在按需读取模式下遇到缓存未命中时，CacheFiles 会向用户守护进程发送一个 `READ` 请求（操作码为 `CACHEFILES_OP_READ`）。这告诉用户守护进程获取请求文件范围的内容。有效载荷的形式如下：

```plaintext
struct cachefiles_read {
    __u64 off;
    __u64 len;
};
```

其中：
- `off` 表示请求文件范围的起始偏移量。
- `len` 表示请求文件范围的长度。

当收到 `READ` 请求时，用户守护进程应获取请求的数据并将其写入由 `object_id` 标识的缓存文件中。

处理完 `READ` 请求后，用户守护进程应通过使用与 `READ` 请求中给定的 `object_id` 相关联的一个匿名文件描述符上的 `CACHEFILES_IOC_READ_COMPLETE` ioctl 来回复。ioctl 的形式如下：

```plaintext
ioctl(fd, CACHEFILES_IOC_READ_COMPLETE, msg_id);
```

其中：
- `fd` 是与给定 `object_id` 相关联的一个匿名文件描述符。
- `msg_id` 必须与 `READ` 请求中的 `msg_id` 字段匹配。
