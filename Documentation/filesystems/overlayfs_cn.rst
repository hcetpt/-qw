SPDX 许可证标识符: GPL-2.0

作者: Neil Brown
请参阅 MAINTAINERS 文件以了解发送问题的位置
覆盖文件系统
==============

本文档描述了一种新的方法的原型，用于在 Linux 中提供覆盖文件系统功能（有时称为联合文件系统）。覆盖文件系统试图呈现一个文件系统，该文件系统是将一个文件系统叠加在另一个文件系统之上的结果。
覆盖对象
------------

覆盖文件系统的方法是“混合”的，因为出现在文件系统中的对象并不总是看起来属于该文件系统。在许多情况下，访问联合文件系统中的对象与直接从原始文件系统访问相应的对象没有区别。这一点最明显地体现在通过 stat(2) 返回的 'st_dev' 字段上。虽然目录会报告来自覆盖文件系统的 st_dev 值，但非目录对象可能会报告来自底层文件系统或提供该对象的上层文件系统的 st_dev 值。同样，st_ino 只有在与 st_dev 结合时才是唯一的，并且这两个值在非目录对象的生命周期中可能会发生变化。许多应用程序和工具忽略这些值，因此不会受到影响。

在所有覆盖层位于同一基础文件系统上的特殊情况下，所有对象都会报告来自覆盖文件系统的 st_dev 值和来自基础文件系统的 st_ino 值。这将使覆盖挂载更符合文件系统扫描器的要求，并且覆盖对象可以与原始文件系统中的相应对象区分开来。

在64位系统上，即使所有覆盖层不在同一个基础文件系统上，也可以通过“xino”特性实现相同的一致行为。“xino”特性通过真实的对象 st_ino 和基础 fsid 编号组合成一个唯一的对象标识。“xino”特性使用高inode号位来表示fsid，因为基础文件系统很少使用高inode号位。如果基础inode号溢出到高xino位，覆盖文件系统将回退到不使用xino的行为。

“xino”特性可以通过 “-o xino=on” 覆盖挂载选项启用。
如果所有底层文件系统都支持NFS文件句柄，则覆盖文件系统对象的`st_ino`不仅唯一，而且在其生命周期内是持久的。"-o xino=auto" 覆盖挂载选项仅在满足持久`st_ino`要求时启用"xino"功能。下表总结了不同覆盖配置中可以预期的情况：

### Inode 属性

| 配置           | 持久 st_ino | 统一 st_dev | st_ino == d_ino | d_ino == i_ino |
|----------------|-------------|-------------|-----------------|----------------|
|                | 目录        | 非目录      | 目录            | 非目录          | 目录且非目录     | 目录             | 非目录            |
|----------------|-------------|-------------|-----------------|----------------|
| 所有层在同一文件系统上 | Y           | Y           | Y               | Y              | Y               | Y                | Y                |
| 不在同一文件系统的层，xino=off | N           | N           | Y               | N              | N               | Y                | N                |
| xino=on/auto   | Y           | Y           | Y               | Y              | Y               | Y                | Y                |
| xino=on/auto，inode溢出 | N           | N           | Y               | N              | N               | Y                | N                |

[*] nfsd v3 readdirplus 验证 d_ino == i_ino。i_ino 通过多个 `/proc` 文件暴露，例如 `/proc/locks` 和一个 inotify 文件描述符的 `/proc/self/fdinfo/<fd>`。

### 上层和下层

覆盖文件系统结合了两个文件系统：一个“上层”文件系统和一个“下层”文件系统。当一个名称在这两个文件系统中都存在时，“上层”文件系统中的对象可见，而“下层”文件系统中的对象则被隐藏或在目录的情况下与“上层”对象合并。

更准确地说，应称之为上层和下层“目录树”，而不是“文件系统”，因为这两个目录树可能位于同一个文件系统中，并且没有要求必须提供文件系统的根作为上层或下层。

Linux 支持的多种文件系统都可以作为下层文件系统，但并非所有可挂载的 Linux 文件系统都具有 OverlayFS 所需的功能。下层文件系统不需要是可写的。下层文件系统甚至可以是另一个 overlayfs。上层文件系统通常需要是可写的，如果是可写的，则必须支持创建 `trusted.*` 和/或 `user.*` 扩展属性，并且必须在 readdir 响应中提供有效的 `d_type`，因此 NFS 不适合。

只读覆盖两个只读文件系统可以使用任何文件系统类型。

### 目录

覆盖主要涉及目录。如果给定名称同时出现在上层和下层文件系统中，并且指向非目录对象，则下层对象将被隐藏——该名称仅指向上层对象。

当上层和下层对象都是目录时，会形成一个合并目录。

在挂载时，作为挂载选项 "lowerdir" 和 "upperdir" 提供的两个目录将组合成一个合并目录：

```sh
mount -t overlay overlay -olowerdir=/lower,upperdir=/upper, workdir=/work /merged
```

"workdir" 必须是一个空目录，并且必须与 "upperdir" 在同一文件系统上。
每当在这样的合并目录中请求查找时，会在每个实际目录中进行查找，并将结果缓存在属于覆盖文件系统的 dentry 中。如果两个实际查找都找到了目录，则会存储这两个目录并创建一个合并目录；否则，只会存储一个：如果上层目录存在，则存储上层目录，否则存储下层目录。

仅合并目录中的名称列表。其他内容（如元数据和扩展属性）只报告上层目录的。下层目录的这些属性被隐藏，通过白色删除项（whiteouts）和不透明目录（opaque directories）实现。

为了支持在不修改下层文件系统的情况下使用 `rm` 和 `rmdir` 命令，覆盖文件系统需要记录上层文件系统中已被删除的文件。这是通过使用白色删除项和不透明目录来实现的（非目录文件总是不透明的）。

一个白色删除项可以创建为设备号为 0/0 的字符设备，或者创建为零大小的普通文件，并设置扩展属性 "trusted.overlay.whiteout"。当在合并目录的上层找到白色删除项时，会忽略下层中与之匹配的名称，并且白色删除项本身也会被隐藏。

通过设置扩展属性 "trusted.overlay.opaque" 为 "y" 来使目录变为不透明。当上层文件系统包含一个不透明目录时，下层文件系统中具有相同名称的任何目录都会被忽略。

不透明目录不应包含任何白色删除项，因为它们没有作用。合并目录中包含带有扩展属性 "trusted.overlay.whiteout" 的普通文件时，应在合并目录本身上设置扩展属性 "trusted.overlay.opaque" 为 "x"。

这是为了避免在常见情况下进行 `readdir` 操作时检查 "trusted.overlay.whiteout" 属性所带来的开销。

### readdir

当对合并目录发出 `readdir` 请求时，分别读取上层和下层目录，并以显而易见的方式合并名称列表（先读取上层，再读取下层——已存在的条目不会重新添加）。这个合并后的名称列表会缓存在 `struct file` 中，并且只要文件保持打开状态，该缓存就会一直存在。如果两个进程同时打开并读取同一个目录，它们会有各自的缓存。对目录执行 `seekdir` 到开头（偏移量为 0）然后进行 `readdir` 操作，会导致缓存被丢弃并重建。

这意味着在读取目录期间，合并目录中的更改不会立即显现。许多程序可能不会注意到这一点。
当读取目录时，偏移量是按顺序分配的。因此，如果：

- 读取部分目录
- 记住一个偏移量，并关闭目录
- 在稍后某个时间重新打开目录
- 定位到记住的偏移量

那么在文件名列表中旧位置和新位置之间可能几乎没有关联性，特别是如果目录中的内容发生了变化。

对于未合并的目录执行 readdir 操作时，直接由底层目录（上层或下层）处理。
重命名目录
------------

当重命名位于下层或已合并的目录（即该目录最初不是在上层创建的）时，overlayfs 可以用两种不同的方式处理：

1. 返回 EXDEV 错误：此错误是在尝试跨文件系统边界移动文件或目录时由 rename(2) 返回的。因此，应用程序通常会准备处理这种错误（例如，mv(1) 会递归复制目录树）。这是默认行为。
2. 如果启用了“redirect_dir”功能，则将目录复制到上层（但不复制内容）。然后设置扩展属性“trusted.overlay.redirect”，其值为从 overlay 根目录到原始位置的路径。最后将目录移动到新位置。

有几种方法可以调整“redirect_dir”功能：
内核配置选项：

- OVERLAY_FS_REDIRECT_DIR：
    如果启用了这个选项，则默认启用 redirect_dir 功能。
- OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW：
    如果启用了这个选项，则默认情况下总是跟随重定向。启用此选项会导致安全性降低。只有在担心与那些具有 redirect_dir 功能且即使关闭也会跟随重定向的内核向后兼容性问题时才启用此选项。

模块选项（也可以通过 /sys/module/overlay/parameters/ 更改）：

- "redirect_dir=BOOL"：
    参见上面的 OVERLAY_FS_REDIRECT_DIR 内核配置选项。
- "redirect_always_follow=BOOL"：
    参见上面的 OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW 内核配置选项。
### 重定向设置：

- `redirect_max=NUM`：
    最大重定向字节数（默认为256）
    
挂载选项：

- `redirect_dir=on`：
    启用重定向
- `redirect_dir=follow`：
    不创建重定向，但跟随重定向
- `redirect_dir=nofollow`：
    不创建重定向且不跟随重定向
- `redirect_dir=off`：
    如果内核/模块配置中启用了`redirect_always_follow`，则`off`等同于`follow`；否则等同于`nofollow`

当启用NFS导出功能时，每个上层目录都会通过下层inode的文件句柄进行索引，并将上层目录的文件句柄存储在索引项的`trusted.overlay.upper`扩展属性中。在查找合并目录时，如果上层目录与索引中存储的文件句柄不匹配，则表明可能存在多个上层目录被重定向到同一个下层目录。在这种情况下，查找会返回错误并警告可能出现的一致性问题。

由于无法通过索引验证下层重定向，在没有上层的覆盖文件系统上启用NFS导出支持需要关闭重定向跟随（例如`redirect_dir=nofollow`）。

### 非目录对象

非目录对象（如文件、符号链接、设备特殊文件等）根据具体情况从上层或下层文件系统呈现。当访问下层文件系统中的文件时，如果需要写入访问（如以写入方式打开、更改元数据等），该文件首先会被从下层文件系统复制到上层文件系统（copy_up）。需要注意的是，创建硬链接也需要进行copy_up，当然创建符号链接不需要。

copy_up过程可能会变得没有必要，例如文件被打开为读写模式但数据未被修改。

copy_up过程首先确保包含该对象的目录在上层文件系统中存在——必要时创建该目录及其父目录。然后使用相同的元数据（所有者、权限、修改时间、符号链接目标等）创建该对象，如果是文件，则从下层文件系统复制数据到上层文件系统。最后复制任何扩展属性。
一旦 `copy_up` 完成，覆盖文件系统就直接提供对新创建文件的访问权限——未来对该文件的操作几乎不会被覆盖文件系统注意到（尽管对文件名称的操作，如重命名或删除链接，当然会被注意到并处理）。

权限模型
---------

覆盖文件系统中的权限检查遵循以下原则：

1) 权限检查应在 `copy_up` 前后返回相同的结果。
2) 创建覆盖挂载的任务不应获得额外的特权。
3) 非挂载任务可能通过覆盖文件系统获得比直接访问底层或上层文件系统时更多的特权。

这是通过在每次访问时进行两次权限检查来实现的：

a) 检查当前任务是否根据本地 DAC（所有者、组、模式和 POSIX ACL）以及 MAC 检查被允许访问。
b) 检查挂载任务是否基于底层文件系统的权限被允许执行实际操作，同样包括 MAC 检查。

检查 (a) 确保了一致性（1），因为所有者、组、模式和 POSIX ACL 在 `copy_up` 时会被复制。然而，这也可能导致服务器强制执行的权限（例如 NFS 使用的权限）被忽略（3）。检查 (b) 确保没有任务会获得挂载任务所不具备的底层权限（2）。这也意味着有可能创建不满足一致性规则（1）的配置；然而，通常情况下，挂载任务将拥有执行所有操作所需的足够权限。

另一种展示此模型的方法是将其与以下命令进行类比：

```
mount -t overlay overlay -olowerdir=/lower,upperdir=/upper,... /merged
```

与

```
cp -a /lower /upper
mount --bind /upper /merged
```

最终的访问权限应该是相同的。区别在于复制的时间（按需复制 vs. 提前复制）。

多个下层
--------

现在可以使用冒号（":"）作为目录名之间的分隔符来指定多个下层。例如：

```
mount -t overlay overlay -olowerdir=/lower1:/lower2:/lower3 /merged
```

如示例所示，“upperdir=” 和 “workdir=” 可以省略。在这种情况下，覆盖将是只读的。

指定的下层目录将从最右侧开始逐层堆叠至左侧。在上述示例中，lower1 将是顶层，lower2 是中间层，而 lower3 是底层。

注意：包含冒号的目录名可以通过在冒号前加上反斜杠来作为下层提供。例如：

```
mount -t overlay overlay -olowerdir=/a\:lower\:\:dir /merged
```

自内核版本 v6.8 起，包含冒号的目录名也可以使用“lowerdir+”挂载选项和新挂载 API 中的 fsconfig 系统调用来配置为下层。例如：

```
fsconfig(fs_fd, FSCONFIG_SET_STRING, "lowerdir+", "/a:lower::dir", 0);
```

在这种情况下，当在 `/proc/self/mountinfo` 中显示时，下层目录名中的冒号将被转义为八进制字符（\072）。

仅元数据复制
--------------

当启用“metacopy”功能时，在执行特定于元数据的操作（如 chown/chmod）时，overlayfs 只会复制元数据（而非整个文件）。完整的文件将在打开文件进行写入操作时复制。

换句话说，这是一种延迟数据复制操作，并且只有在实际需要修改数据时才会复制数据。

有多种方法可以启用或禁用此功能。可以通过设置/取消设置配置选项 CONFIG_OVERLAY_FS_METACOPY 来默认启用/禁用此功能。或者可以在模块加载时通过模块参数 metacopy=on/off 启用/禁用此功能。最后，还有每个挂载选项 metacopy=on/off 来按挂载启用/禁用此功能。
不要在不受信任的上层/下层目录中使用`metacopy=on`。否则，攻击者可能会创建一个带有适当`REDIRECT`和`METACOPY`扩展属性（xattrs）的手工文件，并获得由`REDIRECT`指向的下层文件的访问权限。在本地系统上，这不应该成为可能，因为设置“trusted.”扩展属性需要`CAP_SYS_ADMIN`权限。但对于来自U盘等不受信任的图层来说，则是可能的。

注意：`redirect_dir={off|nofollow|follow[*]}` 和 `nfs_export=on` 挂载选项与 `metacopy=on` 冲突，并将导致错误。
[*] `redirect_dir=follow` 只有在指定了 `upperdir=...` 时才与 `metacopy=on` 冲突。

仅数据下层
----------

启用“metacopy”功能时，overlayfs普通文件可能由最多三层信息组成：

1. 上层文件中的元数据。
2. 下层文件中的 `st_ino` 和 `st_dev` 对象标识符。
3. 另一下层（更下面）中的文件数据。

“下层数据”文件可以位于任何下层，但不能位于最顶下的那一层。
在最顶下的下层之下，可以定义任意数量的最底下的层为“仅数据”下层，使用双冒号（`::`）分隔符。
不允许在“仅数据”下层之下定义常规下层，因此双冒号（`::`）右侧不允许出现单冒号分隔符。
例如：

```
mount -t overlay overlay -olowerdir=/l1:/l2:/l3::/do1::/do2 /merged
```

“仅数据”下层中的文件路径不会出现在合并的overlayfs目录中，“仅数据”下层中的文件元数据和 `st_ino/st_dev` 也不会在overlayfs的inode中可见。
只有当上层的一个“metacopy”文件具有指向“仅数据”下层中“下层数据”文件的绝对路径的“重定向”时，“仅数据”下层中的文件数据才会可见。
从内核版本v6.8开始，还可以使用新的挂载API中的“datadir+”挂载选项和`fsconfig`系统调用来添加“仅数据”下层。
例如：

```
fsconfig(fs_fd, FSCONFIG_SET_STRING, "lowerdir+", "/l1", 0);
fsconfig(fs_fd, FSCONFIG_SET_STRING, "lowerdir+", "/l2", 0);
fsconfig(fs_fd, FSCONFIG_SET_STRING, "lowerdir+", "/l3", 0);
fsconfig(fs_fd, FSCONFIG_SET_STRING, "datadir+", "/do1", 0);
fsconfig(fs_fd, FSCONFIG_SET_STRING, "datadir+", "/do2", 0);
```

fs-verity支持
------------

在复制下层文件的元数据时，如果源文件启用了fs-verity并且overlay验证支持也被启用，则下层文件的摘要将被添加到“trusted.overlay.metacopy”扩展属性中。然后，在每次打开metacopy文件时，该摘要用于验证下层文件的内容。
当包含 verity 扩展属性的层被使用时，意味着上层中的任何此类元复制文件都保证与在复制时下层的内容相匹配。如果在任何时候（例如，在挂载期间、重新挂载之后等）下层中的此类文件被替换或以任何方式修改，访问 overlayfs 中对应的文件将导致 EIO 错误（可能是在打开时由于 overlayfs 的摘要检查，或者在后续读取时由于 fs-verity），并且会在内核日志中打印详细的错误信息。关于 fs-verity 文件访问的更多细节，请参见 :ref:`Documentation/filesystems/fsverity.rst <accessing_verity_files>`。

Verity 可以用作一种通用的健壮性检查，以检测 overlayfs 目录中的意外更改。但是，通过额外的小心处理，它还可以提供更强大的保证。例如，如果上层是完全受信任的（通过使用 dm-verity 或类似方法），那么可以使用不受信任的下层来为所有元复制文件提供经过验证的文件内容。如果进一步指定不受信任的下层目录为“仅数据”，则它们只能提供此类文件内容，并且整个挂载可以信任与上层相匹配。

此功能由 “verity” 挂载选项控制，该选项支持以下值：

- "off":
    不生成也不使用元复制摘要。这是默认行为（如果未指定 verity 选项）
- "on":
    每当元复制文件指定了预期的摘要时，相应的数据文件必须与指定的摘要匹配。在生成元复制文件时，基于源文件（如果有）设置 verity 摘要。
- "require":
    与 "on" 相同，但另外所有元复制文件必须指定一个摘要（否则打开时返回 EIO）。这意味着只有当数据文件启用了 fs-verity 时才会使用元数据复制，否则会使用完整的复制。

共享和复制层
--------------

下层可以在多个 overlay 挂载之间共享，这实际上是一种非常常见的做法。一个 overlay 挂载可以使用与其他 overlay 挂载相同的下层路径，并且可以使用位于另一个 overlay 下层路径之下或之上的下层路径。

使用已由其他 overlay 挂载使用的上层路径和/或工作目录路径是不允许的，并且可能会因 EBUSY 而失败。部分重叠的路径也是不允许的，并且可能会因 EBUSY 而失败。

如果从两个共享或重叠上层和/或工作目录路径的 overlayfs 挂载访问文件，则 overlay 的行为是未定义的，尽管不会导致崩溃或死锁。

允许使用上层路径挂载 overlay，其中上层路径之前曾由另一个使用不同下层路径的已挂载 overlay 使用，除非启用了 "index" 或 "metacopy" 功能。

启用 "index" 功能时，在首次挂载时，下层根目录的 NFS 文件句柄以及下层文件系统的 UUID 将被编码并存储在上层根目录的 "trusted.overlay.origin" 扩展属性中。在随后的挂载尝试中，将比较下层根目录的文件句柄和下层文件系统的 UUID 与存储在上层根目录中的来源。如果无法验证下层根目录的来源，则挂载将因 ESTALE 失败。如果下层文件系统不支持 NFS 导出、下层文件系统没有有效的 UUID 或上层文件系统不支持扩展属性，带有 "index" 功能的 overlayfs 挂载将因 EOPNOTSUPP 失败。
对于“metacopy”特性，在挂载时没有验证机制。因此，如果相同的上层目录与不同的下层目录集一起挂载，挂载可能会成功，但之后可能会出现意外情况。所以不要这样做。

将覆盖层复制到同一或不同底层文件系统的另一个目录树中，甚至复制到另一台机器上，这是一种相当常见的做法。使用“index”特性时，尝试挂载复制的层会导致验证下层根文件句柄失败。

嵌套挂载overlayfs
------------------------

可以使用存储在overlayfs挂载上的下层目录。对于普通文件来说，这不需要任何特殊处理。然而，具有overlayfs属性（如whiteouts或“overlay.*”扩展属性）的文件会被底层的overlayfs挂载解析并移除。为了允许第二个overlayfs挂载看到这些属性，必须进行转义处理。

特定于overlayfs的扩展属性通过使用特殊的前缀“overlay.overlay.”来转义。因此，下层目录中的一个具有“trusted.overlay.overlay.metacopy”扩展属性的文件，在overlayfs挂载中会显示为具有“trusted.overlay.metacopy”扩展属性的普通文件。通过重复前缀可以实现嵌套，因为每次实例化只会移除一个前缀。

包含普通whiteout的下层目录始终由overlayfs挂载处理，因此为了支持在overlayfs挂载中存储有效的whiteout文件，支持一种替代形式的whiteout。这种形式是一个零大小的普通文件，并且设置了“overlay.whiteout”扩展属性，位于设置了“overlay.opaque”扩展属性为“x”的目录内（见`whiteouts和不透明目录`_）。这些替代的whiteout文件不会由overlayfs创建，但可以被用户空间工具（如容器）用于生成下层目录。

这些替代的whiteout文件可以通过标准的扩展属性转义机制进行转义，以正确地嵌套到任意深度。

非标准行为
------------------------

当前版本的overlayfs可以作为一个基本符合POSIX规范的文件系统运行。
以下是overlayfs目前无法处理的情况列表：

a) POSIX规定在读取时需要更新st_atime。当文件位于下层目录时，目前还没有执行这一操作。
b) 如果一个位于下层目录的文件以只读方式打开，并使用MAP_SHARED进行内存映射，则后续对文件的更改不会反映在内存映射中。
c) 如果较低层上的文件正在执行，则打开该文件进行写入或截断文件不会因 ETXTBSY 而被拒绝。

以下选项允许 overlayfs 更像一个符合标准的文件系统：

重定向目录（redirect_dir）
```````````
通过挂载选项或模块选项 "redirect_dir=on" 或内核配置选项 CONFIG_OVERLAY_FS_REDIRECT_DIR=y 启用。
如果禁用此功能，则对较低层或合并目录的 rename(2) 操作将失败并返回 EXDEV（“无效的跨设备链接”）。

索引（index）
``````
通过挂载选项或模块选项 "index=on" 或内核配置选项 CONFIG_OVERLAY_FS_INDEX=y 启用。
如果禁用此功能，并且复制了一个具有多个硬链接的文件，则会“破坏”这个链接。更改不会传播到指向同一inode的其他名称。

扩展inode编号（xino）
`````
通过挂载选项 "xino=auto" 或 "xino=on"，模块选项 "xino_auto=on" 或内核配置选项 CONFIG_OVERLAY_FS_XINO_AUTO=y 启用。如果所有组成覆盖层的底层文件系统使用相同的底层文件系统，则此功能也会隐式启用。
如果禁用此功能或底层文件系统的inode编号中没有足够的空位，则 overlayfs 将无法保证 stat(2) 返回的 st_ino 和 st_dev 值以及 readdir(3) 返回的 d_ino 值像普通文件系统一样工作。例如，同一覆盖层文件系统中的两个对象的 st_dev 值可能不同，并且文件系统对象的 st_ino 值可能不持久，即使在覆盖层文件系统挂载期间也可能发生变化，具体如上表 `Inode 属性` 所述。

对底层文件系统的更改
---------------------
在作为已挂载覆盖层文件系统的一部分时，不允许对底层文件系统进行更改。如果底层文件系统被更改，覆盖层的行为是未定义的，但这不会导致崩溃或死锁。
当覆盖层未挂载时，允许对上层树进行离线更改。只有在未使用 “metacopy”，“index”，“xino” 和 “redirect_dir” 这些功能的情况下才允许对下层树进行离线更改。如果修改了下层树并且使用了这些功能中的任何一个，则覆盖层的行为是未定义的，但这不会导致崩溃或死锁。
当启用覆盖层NFS导出功能时，覆盖文件系统在底层较低层离线更改时的行为与未启用NFS导出时不同。
每次进行copy_up操作时，较低层inode的NFS句柄以及较低层文件系统的UUID将被编码并存储在上层inode的扩展属性"trusted.overlay.origin"中。
当启用NFS导出功能时，对合并目录的查找会验证在查找路径或由"trusted.overlay.redirect"扩展属性指向的路径上找到的较低层目录句柄和较低层文件系统UUID是否与在copy_up时存储的起源句柄匹配。如果找到的较低层目录与存储的起源不匹配，则该目录不会与上层目录合并。

### NFS导出

当底层文件系统支持NFS导出并且启用了"nfs_export"功能时，可以将覆盖文件系统导出到NFS。
通过"nfs_export"功能，在复制任何较低层对象时，会在索引目录下创建一个索引条目。索引条目的名称是copy up起源句柄的十六进制表示。对于非目录对象，索引条目是一个指向上层inode的硬链接。
对于目录对象，索引条目具有扩展属性"trusted.overlay.upper"，其中包含上层目录inode的编码句柄。
当从覆盖文件系统对象编码句柄时，遵循以下规则：

1. 对于非上层对象，编码来自较低层inode的较低层句柄。
2. 对于已索引的对象，编码来自copy up起源的较低层句柄。
3. 对于纯上层对象和现有的非索引上层对象，编码来自上层inode的上层句柄。

编码后的覆盖文件句柄包括：

- 包含路径类型信息（例如较低层/上层）的头部。
- 底层文件系统的UUID。
- 底层文件系统对底层inode的编码。

此编码格式与存储在扩展属性"trusted.overlay.origin"中的文件句柄编码格式相同。
当解码覆盖文件句柄时，遵循以下步骤：

1. 根据UUID和路径类型信息找到底层。
2. 解码底层文件系统的文件句柄以获取底层dentry。
3. 对于较低层文件句柄，在索引目录中通过名称查找该句柄。
4. 如果在索引中发现空白条目（whiteout），则返回ESTALE。这表示一个在其文件句柄被编码后被删除的覆盖层对象。
5. 对于非目录项，从解码后的底层dentry、路径类型和索引inode（如果找到的话）实例化一个断开连接的覆盖层dentry。
6. 对于目录项，使用连接的底层解码dentry、路径类型和索引来查找一个连接的覆盖层dentry。

解码非目录文件句柄可能会返回一个断开连接的dentry副本，该断开连接dentry的copy_up操作会创建一个没有上层别名的上层索引条目。

当覆盖文件系统有多个下层时，中间层目录可能有一个到下层目录的“重定向”。由于中间层的“重定向”未被索引，因此从“重定向”源目录编码的下层文件句柄无法用于查找中间层或上层目录。同样地，从“重定向”源目录的后代目录编码的下层文件句柄也无法用于重构连接的覆盖路径。为了缓解无法从下层文件句柄解码的目录问题，在编码时这些目录会被复制到上层，并作为上层文件句柄进行编码。

在一个没有上层的覆盖文件系统中，这种缓解措施无法使用，这种配置下的NFS导出需要关闭重定向跟随（例如，“redirect_dir=nofollow”）。

覆盖文件系统不支持非目录的可连接文件句柄，因此使用'exportfs'配置中的'subtree_check'导出会因查找文件失败而导致NFS文件查找失败。

当启用NFS导出功能时，所有目录索引条目在挂载时都会被验证，以确保上层文件句柄不是陈旧的。
此验证在某些情况下可能会导致显著的开销。

注意：对于读写挂载点，挂载选项 `index=off` 和 `nfs_export=on` 是冲突的，并将导致错误。
注意：挂载选项 `uuid=off` 可以用于将底层文件系统的 UUID 在文件句柄中替换为 null，并有效地禁用 UUID 检查。这在底层磁盘被复制且复制后的 UUID 被更改的情况下可能有用。但只有当所有下层/上层/工作目录都在同一个文件系统上时，这一选项才适用；否则它将回退到正常行为。

### UUID 和 fsid

overlayfs 实例本身的 UUID 以及由 `statfs(2)` 报告的 fsid 受控于 `uuid` 挂载选项，该选项支持以下值：

- `"null"`:
    overlayfs 的 UUID 为 null。fsid 来自最上层的文件系统。
- `"off"`:
    overlayfs 的 UUID 为 null。fsid 来自最上层的文件系统。忽略底层各层的 UUID。
- `"on"`:
    overlayfs 的 UUID 会被生成并用于报告唯一的 fsid。UUID 存储在扩展属性 `trusted.overlay.uuid` 中，使 overlayfs 的 fsid 唯一且持久。此选项需要支持扩展属性的上层文件系统。
- `"auto"`:（默认）
    如果扩展属性 `trusted.overlay.uuid` 存在，则从中获取 UUID。
    在首次挂载满足前提条件的新 overlay 文件系统时升级为 `uuid=on`。
降级到 "uuid=null" 对于那些从未使用 "uuid=on" 挂载的现有覆盖文件系统

易失性挂载
-----------

通过 "volatile" 挂载选项启用。易失性挂载在崩溃后不保证数据存活。强烈建议仅在能够轻松重新创建覆盖层中写入的数据时使用易失性挂载。
使用 "volatile" 选项挂载的优势在于省略了对上层文件系统的所有同步调用。
为了避免给用户一种虚假的安全感，易失性挂载的 `syncfs`（以及 `fsync`）语义与其他 VFS 的略有不同。如果在易失性挂载之后上层目录的文件系统发生任何回写错误，所有同步函数将返回错误。一旦达到这种状态，文件系统将无法恢复，随后的所有同步调用都将返回错误，即使上层目录自上次同步调用以来没有发生新的错误。
当覆盖层使用 "volatile" 选项挂载时，会创建目录 "$workdir/work/incompat/volatile"。下次挂载时，覆盖层会检查该目录，并在存在时拒绝挂载。这是用户应该丢弃上层和工作目录并创建新目录的一个强烈信号。在非常有限的情况下，如果用户知道系统没有崩溃且上层目录的内容完好无损，则可以删除 "volatile" 目录。

用户扩展属性
-------------

"-o userxattr" 挂载选项强制覆盖文件系统使用 "user.overlay." 扩展属性命名空间而不是 "trusted.overlay."。这对于未授权挂载覆盖文件系统很有用。

测试套件
---------

有一个由 David Howells 最初开发并由 Amir Goldstein 维护的测试套件：

https://github.com/amir73il/unionmount-testsuite.git

以 root 用户身份运行：

```
# cd unionmount-testsuite
# ./run --ov --verify
```
