SPDX 许可声明：GPL-2.0

=======================
Squashfs 4.0 文件系统
=======================

Squashfs 是一个用于 Linux 的压缩只读文件系统。
它使用 zlib、lz4、lzo 或 xz 压缩技术来压缩文件、inode 和目录。系统中的 inode 非常小，并且所有块都进行了打包以最小化数据开销。支持大于 4KB 的块大小，最大可达 1MB（默认块大小为 128KB）。
Squashfs 适用于一般的只读文件系统用途，归档用途（例如，可以使用 .tar.gz 文件的情况），以及在受限的块设备/内存系统（如嵌入式系统）中需要低开销的情况。
邮件列表：squashfs-devel@lists.sourceforge.net
网站：www.squashfs.org

1. 文件系统特性
----------------------

Squashfs 文件系统的特性与 Cramfs 的比较：

============================== 	=========		==========
				Squashfs		Cramfs
============================== 	=========		==========
最大文件系统大小		2^64			256 MB
最大文件大小			约 2 TB			16 MB
最大文件数量			无限			无限
最大目录数量			无限			无限
每个目录的最大条目数		无限			无限
最大块大小			1 MB			4 KB
元数据压缩			是			否
目录索引			是			否
稀疏文件支持			是			否
尾部打包（碎片）		是			否
可导出（NFS 等）		是			否
硬链接支持			是			否
readdir 中的 "." 和 ".."	是			否
真实的 inode 编号		是			否
32 位 UID/GID			是			否
文件创建时间			是			否
扩展属性支持			是			否
ACL 支持			否			否
============================== 	=========		==========

Squashfs 压缩数据、inode 和目录。此外，inode 和目录数据高度紧凑，并且按字节边界进行打包。每个压缩后的 inode 平均长度为 8 字节（确切长度取决于文件类型，即普通文件、目录、符号链接和块/字符设备的 inode 大小不同）。

2. 使用 Squashfs
-----------------

由于 Squashfs 是一个只读文件系统，因此必须使用 mksquashfs 程序来创建已填充的 Squashfs 文件系统。此程序及其他 Squashfs 工具可以从 http://www.squashfs.org 获取。该网站还提供使用说明。
Squashfs-tools 开发树现在位于 kernel.org：
	git://git.kernel.org/pub/scm/fs/squashfs/squashfs-tools.git

2.1 挂载选项
-----------------
===================    =========================================================
errors=%s              指定 Squashfs 错误是否触发内核 panic

		       ==========  =============================================
                         continue  错误不触发 panic（默认）
                            panic  遇到错误时触发 panic，
                                   类似于其他几个文件系统（如 btrfs、ext4、f2fs、GFS2、jfs、ntfs、ubifs）

                                   这允许保存内核转储，
                                   对于分析和调试损坏非常有用
==========  =============================================
threads=%s             选择解压缩模式或线程数量

                       如果设置了 SQUASHFS_CHOICE_DECOMP_BY_MOUNT：

		       ==========  =============================================
                           single  使用单线程解压缩（默认）

                                   一次只能解压缩一个块（数据或元数据）。这将 CPU 和内存使用量降至最低，但在多 CPU 机器上并行 I/O 工作负载时，由于等待解压缩器可用性而性能较差
multi  每个核心最多使用两个并行解压缩器

                                   如果您的工作负载具有并行 I/O，并且系统有足够的内存，则使用此选项可能会提高整体 I/O 性能。它根据需求动态分配解压缩器
percpu  每个核心最多使用一个解压缩器

                                   它使用每核心变量来确保解压缩负载均衡分布在各个核心之间
1|2|3|... 配置用于解压缩的线程数

                           上限是 num_online_cpus() * 2
==========  =============================================

                       如果 SQUASHFS_CHOICE_DECOMP_BY_MOUNT 没有设置，并且
                       SQUASHFS_DECOMP_MULTI 和 SQUASHFS_MOUNT_DECOMP_THREADS 都已设置：

		       ==========  =============================================
                          2|3|... 配置用于解压缩的线程数

                           上限是 num_online_cpus() * 2
==========  =============================================

===================    =========================================================

3. Squashfs 文件系统设计
------------------------

Squashfs 文件系统最多由九个部分组成，按字节对齐打包在一起：

	 ---------------
	|  超级块 	|
	|---------------|
	|  压缩选项  |
	|---------------|
	|  数据块   |
	|  及碎片  |
	|---------------|
	|  索引节点表 	|
	|---------------|
	|   目录表     |
	|---------------|
	|   碎片表     |
	|---------------|
	|   导出表     |
	|---------------|
	|   uid/gid   |
	|  查找表     |
	|---------------|
	|     扩展属性表 |
	 ---------------

在从源目录读取文件时，将压缩后的数据块写入文件系统，并检查重复。一旦所有文件数据都已写入，完整的索引节点、目录、碎片、导出、uid/gid查找和扩展属性表将被写入。

3.1 压缩选项
--------------

压缩器可选地支持特定于压缩的选项（例如字典大小）。如果使用了非默认的压缩选项，则这些选项将存储在这里。

3.2 索引节点
------------

元数据（索引节点和目录）以 8K 字节块的形式进行压缩。每个压缩块前有一个两字节长度的前缀，如果该块未压缩，则最高位被设置。如果设置了 -noI 选项，或者压缩后的块比未压缩的块大，则该块将不被压缩。

索引节点被打包到元数据块中，并且不对齐到块边界，因此索引节点会跨越多个压缩块。索引节点通过一个 48 位的数字来标识，该数字编码了包含该索引节点的压缩元数据块的位置以及该块中的字节偏移量（<块, 偏移>）。

为了最大化压缩效果，为每种文件类型定义了不同的索引节点（常规文件、目录、设备等），索引节点的内容和长度随类型而变化。

为了进一步提高压缩效果，定义了两种类型的常规文件索引节点和目录索引节点：一种是针对频繁出现的常规文件和目录进行了优化，另一种则需要存储额外信息的扩展类型。

3.3 目录
------------

与索引节点类似，目录被打包到压缩的元数据块中，并存储在一个目录表中。通过包含目录的元数据块的起始地址和解压缩块中的偏移量（<块, 偏移>）来访问目录。
目录的组织方式稍微复杂一些，并不仅仅是一个文件名列表。这种组织方式利用了这样一个事实：在大多数情况下，文件的inode将位于同一个压缩元数据块中，因此可以共享起始块。因此，目录是通过两级列表组织的：一个目录头包含共享的起始块值，以及一系列目录项，每个目录项都共享这个共享起始块。一旦inode的起始块发生变化，就会写入一个新的目录头。目录头/目录项列表会根据需要重复多次。

目录是排序的，并且可以包含一个目录索引来加快文件查找速度。目录索存为每个元数据块存储一个条目，每个条目存储从第一个目录头到该元数据块的索引/文件名映射。目录按字母顺序排列，在查找时，索引会被线性扫描以寻找第一个字典序大于待查文件名的文件名。这时，已经找到了包含该文件名的元数据块的位置。

索引的主要目的是确保无论目录长度多长，进行查找时只需要解压缩一个元数据块。这种方法的优势在于不需要额外的内存开销，并且不需要在磁盘上占用太多额外空间。

### 3.4 文件数据

普通文件由一系列连续的压缩块组成，或者是一个压缩片段块（尾部打包块）。每个数据块的压缩大小存储在一个块列表中，该列表包含在文件的inode内。

为了加快读取“大”文件（256 MB或更大）时对数据块的访问速度，代码实现了一个索引缓存，用于缓存从块索引到磁盘上数据块位置的映射。

索引缓存使得Squashfs能够处理大文件（最高可达1.75 TiB），同时保持磁盘上的简单和空间高效的块列表。缓存被分割成多个槽位，最多可缓存八个224 GiB的文件（128 KiB的数据块）。更大的文件使用多个槽位，1.75 TiB的文件使用所有8个槽位。

索引缓存设计得非常节省内存，默认使用16 KiB。
3.5 分片查找表
-------------------------

普通文件可以包含一个分片索引，该索引映射到磁盘上的分片位置和压缩大小，使用分片查找表。这个分片查找表本身被压缩并存储在元数据块中。第二个索引表用于定位这些分片。为了提高访问速度（并且因为它很小），这个第二索引表在挂载时读取并缓存在内存中。

3.6 用户ID/组ID查找表
------------------------

为了节省空间，普通文件存储用户ID（uid）和组ID（gid）的索引，这些索引通过ID查找表转换为32位的uids/gids。这个表被压缩并存储在元数据块中。第二个索引表用于定位这些信息。为了提高访问速度（并且因为它很小），这个第二索引表在挂载时读取并缓存在内存中。

3.7 导出表
----------------

为了使Squashfs文件系统可导出（通过NFS等），文件系统可以选择性地（通过Mksquashfs选项-no-exports禁用）包含一个inode编号到磁盘inode位置的查找表。这是必要的，以便Squashfs能够将从文件句柄传递的inode编号映射到磁盘上的inode位置，这对于导出代码重新实例化已过期或被清除的inode是必需的。
这个表被压缩并存储在元数据块中。第二个索引表用于定位这些信息。为了提高访问速度（并且因为它很小），这个第二索引表在挂载时读取并缓存在内存中。

3.8 扩展属性表（Xattr表）
---------------

扩展属性表（xattr表）包含每个inode的扩展属性。每个inode的xattr存储在一个列表中，每个列表项包含类型、名称和值字段。类型字段编码了xattr前缀（如"user."、"trusted."等），还编码了如何解释名称/值字段。目前，类型指示值是内联存储（在这种情况下，值字段包含xattr值），还是外联存储（在这种情况下，值字段存储指向实际值存储位置的引用）。这允许较大的值外联存储以提高扫描和查找性能，并且还允许值去重，即值只存储一次，所有其他出现的地方都持有对该值的外联引用。
xattr列表被压缩并打包进8K元数据块中。
为了减少inode中的开销，而不是在每个inode中存储xattr列表的磁盘位置，存储了一个32位的xattr ID。这个xattr ID使用第二个xattr ID查找表映射到xattr列表的位置。

4. 待办事项和未解决问题
-------------------------------

4.1 待办事项
-------------

实现ACL支持

4.2 Squashfs内部缓存
---------------------------

Squashfs中的块是压缩的。为了避免反复解压最近访问的数据，Squashfs使用两个小的元数据和分片缓存。
缓存不用于文件的数据块，这些数据块会以常规方式被解压缩并缓存到页面缓存中。缓存用于临时缓存因元数据（即inode或目录）或片段访问而读取的元数据块和片段块。由于元数据和片段是被打包在一起的（以获得更高的压缩率），因此读取特定的元数据或片段时，会同时检索出与之打包在一起的其他元数据/片段。由于局部性原理，这些元数据/片段可能在不久的将来会被读取。临时缓存它们确保了它们可以在不久的将来被访问，而无需进行额外的读取和解压缩操作。

将来，这个内部缓存可能会被替换为使用内核页面缓存的实现。由于页面缓存是以页面大小为单位进行操作的，这可能会在锁定及相关竞态条件方面引入额外的复杂性。
