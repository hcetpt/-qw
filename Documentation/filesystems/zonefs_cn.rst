SPDX 许可证标识符: GPL-2.0

================================================
ZoneFS - 用于分区块设备的分区文件系统
================================================

简介
============

zonefs 是一个非常简单的文件系统，将分区块设备中的每个分区暴露为一个文件。与支持原生分区块设备的传统 POSIX 兼容文件系统（例如 f2fs）不同，zonefs 不会对用户隐藏分区块设备的顺序写入约束。表示设备顺序写入分区的文件必须从文件末尾开始顺序写入（仅追加写入）。因此，zonefs 实质上更接近原始块设备访问接口，而不是一个全功能的 POSIX 文件系统。zonefs 的目标是通过使用更丰富的文件 API 替代原始块设备文件访问来简化应用程序中对分区块设备支持的实现，避免依赖可能对开发者来说更为晦涩的直接块设备文件 ioctls。这种做法的一个例子是在分区块设备上实现 LSM（日志结构合并）树结构（如 RocksDB 和 LevelDB 中使用的），允许 SSTable 存储在一个分区文件中，类似于常规文件系统而不是整个磁盘的一部分。引入更高层次的构造“一个文件是一个分区”可以减少应用程序所需更改的数量，并引入对不同应用程序编程语言的支持。

分区块设备
-------------------

分区存储设备属于一类具有被划分为多个区域的地址空间的存储设备。一个区域是一组连续的 LBA（逻辑块地址），并且所有区域都是连续的（没有 LBA 间隙）。区域可能有不同的类型：
* 常规区域：对属于常规区域的 LBA 没有任何访问限制。任何读取或写入操作都可以执行，类似于常规块设备。
* 顺序区域：这些区域接受随机读取，但必须顺序写入。每个顺序区域都有一个由设备维护的写指针，跟踪下一次写入设备所需的起始 LBA 位置。由于这个写入限制，顺序区域中的 LBA 不能被覆盖。在重新写入之前，顺序区域必须首先使用特殊命令（区域重置）擦除。

分区存储设备可以使用各种记录和介质技术实现。目前最常见的分区存储形式是在叠瓦式磁记录（SMR）硬盘驱动器上使用 SCSI 分区块命令（ZBC）和 Zoned ATA 命令（ZAC）接口。固态硬盘（SSD）存储设备也可以实现分区接口，以减少由于垃圾收集导致的内部写入放大。NVMe 标准委员会的技术提案 NVMe 分区命名空间（ZNS）旨在向 NVMe 协议添加分区存储接口。

ZoneFS 概览
===============

ZoneFS 将分区块设备的分区作为文件暴露出来。表示分区的文件按分区类型分组，这些分区类型本身由子目录表示。这种文件结构完全基于设备提供的分区信息构建，因此不需要复杂的磁盘元数据结构。

磁盘元数据
----------------

zonefs 的磁盘元数据仅限于一个不可变的超级块，该超级块持久化存储一个魔术数字以及可选的功能标志和值。在挂载时，zonefs 使用 blkdev_report_zones() 获取设备的分区配置，并根据此信息仅用静态文件树填充挂载点。文件大小来自设备的分区类型和由设备本身管理的写指针位置。
超级块始终写入磁盘的第0扇区。存储超级块的第一个区域永远不会被zonefs暴露为区域文件。如果包含超级块的区域是顺序写入区域，则mkzonefs格式化工具总是“完成”该区域，即，将该区域转换为满状态以使其只读，防止任何数据写入。

### 区域类型子目录

相同类型的区域文件会被自动分组到同一个在挂载时自动生成的子目录下。
对于常规区域，使用子目录“cnv”。但是，此目录仅当设备具有可用的常规区域时才会创建。如果设备只有一个位于第0扇区的常规区域，该区域不会被暴露为文件，因为它将用于存储zonefs的超级块。对于此类设备，“cnv”子目录也不会被创建。
对于顺序写入区域，使用子目录“seq”。

这两个目录是zonefs中唯一存在的目录。用户不能创建其他目录，也不能重命名或删除“cnv”和“seq”子目录。
通过使用stat()或fstat()系统调用获取的struct stat结构中的st_size字段所指示的目录大小表示该目录下的文件数量。

### 区域文件

区域文件以其代表的特定类型区域集内的编号进行命名。也就是说，“cnv”和“seq”目录都包含名为“0”，“1”，“2”，... 的文件。这些文件编号也代表设备上区域的起始扇区递增。
对区域文件的所有读写操作都不允许超出文件的最大大小，即超出区域容量。任何超过区域容量的访问都会返回-EFBIG错误。
不允许创建、删除、重命名或修改文件和子目录的任何属性。
由stat()和fstat()报告的文件块数表示区域文件的容量，换句话说，就是最大文件大小。
传统区域文件
-----------------------

传统区域文件的大小固定为其所代表区域的大小。传统区域文件不能被截断。
这些文件可以使用任何类型的I/O操作进行随机读写：缓冲I/O、直接I/O、内存映射I/O（mmap）等。除了上述文件大小限制之外，这些文件没有其他I/O限制。

顺序区域文件
---------------------

位于“seq”子目录中的顺序区域文件的大小表示相对于区域起始扇区的文件区域写指针位置。
顺序区域文件只能从文件末尾开始顺序写入，也就是说，写操作只能是追加写。Zonefs不接受随机写入，并且会拒绝任何不符合文件末尾或上一次异步写入结束位置的写请求。
由于页缓存中的脏页回写不能保证顺序写模式，因此Zonefs禁止在顺序文件上使用缓冲写和可写的共享映射。只接受直接I/O写入这些文件。
Zonefs依赖于块层电梯实现的写I/O请求的顺序传递。必须使用实现了顺序写功能的电梯（具有ELEVATOR_F_ZBD_SEQ_WRITE电梯功能）。这种类型的电梯（例如mq-deadline）默认在设备初始化时为分区块设备设置。
对于顺序区域文件的读操作使用的I/O类型没有限制。缓冲I/O、直接I/O和共享读映射都是允许的。
只允许将顺序区域文件截断到0，此时区域重置以将文件区域写指针位置重置到区域的起始位置；或者截断到区域容量，此时文件区域转换为FULL状态（完成区域操作）。

格式化选项
--------------

Zonefs的几个可选功能可以在格式化时启用：
* 传统区域聚合：可以将连续的传统区域范围聚合为一个较大的文件，而不是默认的每个区域一个文件。
* 文件所有权：区域文件的默认所有者UID和GID为0（root），但可以更改为任何有效的UID/GID。
* 文件访问权限：默认的640访问权限可以更改。

IO错误处理
------------

分区块设备可能会因为类似普通块设备的原因导致I/O请求失败，例如坏扇区。然而，除了这些已知的I/O故障模式外，管理分区块设备行为的标准还定义了其他导致I/O错误的情况：
* 区域可能变为只读状态（BLK_ZONE_COND_READONLY）：虽然该区域中已写入的数据仍然可读，但该区域无法再被写入。任何用户对该区域的操作（包括区域管理命令或读写访问）都无法将区域状态恢复到正常的读写状态。尽管标准没有定义设备将区域变为只读状态的具体原因，一个典型的原因为硬盘上的写入头出现故障（该头下的所有区域都会变为只读）。
* 区域可能变为离线状态（BLK_ZONE_COND_OFFLINE）：离线区域既不能读也不能写。任何用户操作都无法将离线区域恢复到正常工作状态。与区域变为只读状态类似，驱动器将区域变为离线状态的原因也是未定义的。一个典型原因为硬盘上的读写头出现故障，导致该盘片下所有区域变得不可访问。
* 对齐写入错误：这些错误是由于主机发出的写入请求起始扇区位置与设备执行写入请求时的区域写指针位置不对应。尽管zonefs强制对顺序区域进行顺序写入，但在非常大的直接I/O操作部分失败并拆分为多个BIOs/请求或异步I/O操作的情况下，仍可能发生对齐写入错误。如果一组连续写入请求中的某个写入请求失败，则之后排队的所有写入请求都会变为不对齐，并且会失败。
* 延迟写入错误：与普通块设备类似，如果启用了设备端的写缓存，在设备写缓存刷新时，例如在调用fsync()时，可能会在之前完成的写入范围内发生写入错误。同样地，延迟写入错误可以通过一个区域中缓存的连续数据流传播，导致从引发错误的扇区之后的所有数据都被丢弃。

zonefs检测到的所有I/O错误都会通过返回错误代码的方式通知用户，该错误代码由触发或检测到错误的系统调用返回。zonefs针对I/O错误采取的恢复措施取决于I/O类型（读取与写入）以及错误原因（坏扇区、对齐写入错误或区域状态变化）。
* 对于读取I/O错误，如果文件区域仍然处于良好状态，并且文件inode大小与其区域写指针位置之间没有不一致，则zonefs不会执行任何特定的恢复操作。
  如果检测到问题，则会执行I/O错误恢复（参见下表）。
* 对于写入I/O错误，zonefs总是会执行I/O错误恢复。
* 区域状态更改为只读或离线时，也会触发zonefs的I/O错误恢复。
* Zonefs最小限度的I/O错误恢复可能会更改文件大小和文件访问权限。
  * 文件大小更改：
    在顺序区域文件中的即时或延迟写入错误可能导致文件inode大小与成功写入文件区域的数据量不一致。例如，多块BIO大写入操作的部分失败会导致区域写指针部分前进，尽管整个写入操作会被报告为失败。在这种情况下，必须更新文件inode大小以反映区域写指针的变化，并最终允许用户从文件末尾重新开始写入。
    文件大小也可能减少以反映在fsync()时检测到的延迟写入错误：在这种情况下，实际写入区域的数据量可能少于最初由文件inode大小指示的数量。发生此类I/O错误后，zonefs始终会修正文件inode大小以反映文件区域中持久存储的数据量。
  * 访问权限更改：
    区域状态更改为只读时，通过更改文件访问权限将其设置为只读。这将禁止对文件属性和数据进行修改。对于离线区域，所有文件的读写权限都将被禁用。
* 用户可以通过"errors=xxx"挂载选项来控制zonefs I/O错误恢复采取的进一步措施。下表总结了根据挂载选项和区域条件处理zonefs I/O错误的结果：

    +--------------+-----------+-----------------------------------------+
    |              |           |            错误后状态                     |
    | "errors=xxx" | 设备      |                 访问权限                |
    | 挂载选项     | 区域状态  | 文件         文件          设备区域      |
    |              |           | 大小     只读    写入    只读    写入    |
    +--------------+-----------+-----------------------------------------+
    |              | 良好      | 固定    是     否       是     是       |
    | remount-ro   | 只读      | 不变    是     否       是     否       |
    | (默认)       | 离线      | 0      否      否       否      否       |
    +--------------+-----------+-----------------------------------------+
    |              | 良好      | 固定    是     否       是     是       |
    | zone-ro      | 只读      | 不变    是     否       是     否       |
    |              | 离线      | 0      否      否       否      否       |
    +--------------+-----------+-----------------------------------------+
    |              | 良好      | 0      否      否       是     是       |
    | zone-offline | 只读      | 0      否      否       是     否       |
    |              | 离线      | 0      否      否       否      否       |
    +--------------+-----------+-----------------------------------------+
    |              | 良好      | 固定    是     是       是     是       |
    | repair       | 只读      | 不变    是     否       是     否       |
    |              | 离线      | 0      否      否       否      否       |
    +--------------+-----------+-----------------------------------------+

其他说明：
* 如果未指定错误挂载选项，则"errors=remount-ro"挂载选项是zonefs I/O错误处理的默认行为。
* 使用"errors=remount-ro"挂载选项时，将文件访问权限更改为只读适用于所有文件。文件系统将以只读方式重新挂载。
* 由于设备转换区域至离线状态而导致的访问权限和文件大小变化是永久性的。重新挂载或使用 mkfs.zonefs（mkzonefs）重新格式化设备不会将离线区域文件恢复到正常状态。
* 由于设备转换区域至只读状态而导致的文件访问权限变更为只读是永久性的。重新挂载或重新格式化设备不会重新启用文件写入权限。
* 使用 remount-ro、zone-ro 和 zone-offline 挂载选项对处于良好状态的区域所隐含的文件访问权限更改是临时的。卸载并重新挂载文件系统会将受影响文件的先前默认（格式化时的值）访问权限恢复。
* 修复（repair）挂载选项仅触发最小的一组 I/O 错误恢复操作，即对处于良好状态的区域进行文件大小修复。设备指示为只读或离线状态的区域仍会导致区域文件访问权限的变化，如上表所示。

### 挂载选项

zonefs 定义了多个挂载选项：
* errors=<behavior>
* explicit-open

### "errors=<behavior>" 选项

"errors=<behavior>" 挂载选项允许用户指定在遇到 I/O 错误、inode 大小不一致或区域状态变化时 zonefs 的行为。定义的行为如下：

* remount-ro（默认）
* zone-ro
* zone-offline
* repair

每个行为在运行时的 I/O 错误处理动作在前文详细说明。挂载时的 I/O 错误将导致挂载操作失败。只读区域在挂载时与运行时的处理方式也有所不同。如果在挂载时发现一个只读区域，该区域始终被视为离线区域处理，即所有访问被禁用，并且区域文件大小设置为 0。这是必要的，因为根据 ZBC 和 ZAC 标准，只读区域的写指针被认为是无效的，无法确定已写入该区域的数据量。对于在运行时发现的只读区域，其文件大小保持上次更新的状态不变，如前文所述。

### "explicit-open" 选项

分区块设备（例如 NVMe 分区命名空间设备）可能对其可激活区域的数量有限制，即处于隐式打开、显式打开或关闭状态的区域数量。这种潜在限制意味着，如果用户发出写请求时文件所在的区域尚未激活，则应用程序可能会因超出此限制而看到写 I/O 错误。
为了避免这些潜在错误，“显式打开”挂载选项强制在首次打开文件进行写入时使用打开区域命令使区域变为活动状态。如果区域打开命令成功，应用程序可以确保写请求会被处理。相反地，当最后一个关闭（close()）操作执行时且该区域既非满也非空时，“显式打开”挂载选项会导致向设备发出区域关闭命令。

运行时 sysfs 属性
------------------------

zonefs 定义了几个用于已挂载设备的 sysfs 属性。所有属性都可供用户读取，并位于目录 /sys/fs/zonefs/<dev>/ 中，其中 <dev> 是已挂载的分区块设备的名称。
定义的属性如下：
* **max_wro_seq_files**：此属性报告可同时打开以进行写入的最大连续区域文件数量。这个数字对应于设备支持的最大显式或隐式打开区域的数量。值为 0 表示设备没有限制，任何区域（任何文件）都可以随时打开并写入，而不考虑其他区域的状态。当使用 *explicit-open* 挂载选项时，zonefs 将拒绝任何打开连续区域文件进行写入的 open() 系统调用，如果此时已打开的连续区域文件数量已达 *max_wro_seq_files* 的限制。
* **nr_wro_seq_files**：此属性报告当前打开以进行写入的连续区域文件数量。当使用 “显式打开” 挂载选项时，这个数量永远不会超过 *max_wro_seq_files*。如果不使用 *explicit-open* 挂载选项，报告的数量可能大于 *max_wro_seq_files*。在这种情况下，应用程序有责任确保同时写入的连续区域文件不超过 *max_wro_seq_files*。否则可能会导致写入错误。
* **max_active_seq_files**：此属性报告处于活动状态的最大连续区域文件数量，即部分写入（既非空也非满）或显式打开区域（仅当使用 *explicit-open* 挂载选项时发生）的连续区域文件数量。这个数字始终等于设备支持的最大活动区域数量。值为 0 表示挂载设备对可以处于活动状态的连续区域文件数量没有限制。
* **nr_active_seq_files**：此属性报告当前处于活动状态的连续区域文件数量。如果 *max_active_seq_files* 不为 0，则 *nr_active_seq_files* 的值永远不能超过 *max_active_seq_files* 的值，无论是否使用 *explicit-open* 挂载选项。

zonefs 用户空间工具
=======================

mkzonefs 工具用于格式化分区块设备以便与 zonefs 一起使用。此工具可以在 Github 上找到：

https://github.com/damien-lemoal/zonefs-tools

zonefs-tools 还包括一个测试套件，可以针对任何分区块设备运行，包括使用分区模式创建的 null_blk 块设备。

示例
--------

以下示例格式化了一个 15TB 主机管理的 SMR 硬盘，分区大小为 256MB，并启用了传统分区聚合功能：

```
# mkzonefs -o aggr_cnv /dev/sdX
# mount -t zonefs /dev/sdX /mnt
# ls -l /mnt/
total 0
dr-xr-xr-x 2 root root     1 Nov 25 13:23 cnv
dr-xr-xr-x 2 root root 55356 Nov 25 13:23 seq
```

子目录的大小指示每种类型区域文件的数量。在此示例中，只有一个传统区域文件（所有传统区域都聚合在一个文件下）：

```
# ls -l /mnt/cnv
total 137101312
-rw-r----- 1 root root 140391743488 Nov 25 13:23 0
```

此聚合的传统区域文件可以像普通文件一样使用：

```
# mkfs.ext4 /mnt/cnv/0
# mount -o loop /mnt/cnv/0 /data
```

“seq” 子目录分组用于连续写入区域的文件，在此示例中有 55356 个区域：

```
# ls -lv /mnt/seq
total 14511243264
-rw-r----- 1 root root 0 Nov 25 13:23 0
-rw-r----- 1 root root 0 Nov 25 13:23 1
-rw-r----- 1 root root 0 Nov 25 13:23 2
```
```
-rw-r----- 1 root root 0 11月 25 13:23 55354
-rw-r----- 1 root root 0 11月 25 13:23 55355

对于顺序写入区域文件，当数据被追加到文件末尾时，文件大小会发生变化，类似于任何常规文件系统：

    # dd if=/dev/zero of=/mnt/seq/0 bs=4096 count=1 conv=notrunc oflag=direct
    1+0 记录输入
    1+0 记录输出
    4096 字节（4.1 千字节，4.0 KiB）复制，0.00044121 秒，9.3 MB/秒

    # ls -l /mnt/seq/0
    -rw-r----- 1 root root 4096 11月 25 13:23 /mnt/seq/0

可以将已写入的文件截断到区域大小，以阻止进一步的写入操作：

    # truncate -s 268435456 /mnt/seq/0
    # ls -l /mnt/seq/0
    -rw-r----- 1 root root 268435456 11月 25 13:49 /mnt/seq/0

将文件截断为0大小可以释放文件区域存储空间，并重新开始追加写入：

    # truncate -s 0 /mnt/seq/0
    # ls -l /mnt/seq/0
    -rw-r----- 1 root root 0 11月 25 13:49 /mnt/seq/0

由于文件在磁盘上静态映射到区域，因此由 stat() 和 fstat() 报告的文件块数指示文件区域的容量：

    # stat /mnt/seq/0
    文件：/mnt/seq/0
    大小：0            块：524288      IO 块：4096   普通空文件
    设备：870h/2160d   索引节点：50431     链接数：1
    访问权限：(0640/-rw-r-----)  用户 ID：(    0/    root)   组 ID：(    0/    root)
    访问时间：2019-11-25 13:23:57.048971997 +0900
    修改时间：2019-11-25 13:52:25.553805765 +0900
    状态更改时间：2019-11-25 13:52:25.553805765 +0900
    创建时间：-

“块”字段中的文件块数（单位为512字节块）给出了最大文件大小 524288 * 512 字节 = 256 MB，这对应于本例中的设备区域容量。需要注意的是，“IO 块”字段始终表示写入的最小 I/O 大小，并对应于设备物理扇区大小。
```
