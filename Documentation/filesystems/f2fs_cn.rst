SPDX 许可证标识符: GPL-2.0

==========================================
什么是闪存友好文件系统（F2FS）？
==========================================

基于NAND闪存的存储设备，如SSD、eMMC和SD卡，已被广泛应用于从移动到服务器系统的各种系统中。由于它们具有与传统旋转磁盘不同的特性，作为存储设备上层的文件系统需要在设计层面适应这些变化。
F2FS是一个利用基于NAND闪存的存储设备的文件系统，它基于日志结构文件系统（LFS）。该设计主要针对LFS中存在的根本问题进行改进，这些问题包括漫游树效应和高清理开销。
由于基于NAND闪存的存储设备根据其内部几何结构或闪存管理方案（即FTL）表现出不同的特性，F2FS及其工具支持多种参数，不仅用于配置磁盘布局，还用于选择分配和清理算法。
以下git仓库提供了文件系统格式化工具（mkfs.f2fs）、一致性检查工具（fsck.f2fs）和调试工具（dump.f2fs）：
- git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs-tools.git

提交补丁时，请使用以下邮件列表：
- linux-f2fs-devel@lists.sourceforge.net

报告错误时，请使用以下F2FS错误跟踪链接：
- https://bugzilla.kernel.org/enter_bug.cgi?product=File%20System&component=f2fs

背景与设计问题
============================

日志结构文件系统（LFS）
--------------------------------
“日志结构文件系统将所有修改按顺序写入磁盘上的日志结构中，从而加快了文件写入和崩溃恢复的速度。日志是磁盘上的唯一结构；它包含索引信息，以便文件可以从日志中高效读取。为了在磁盘上保持大的空闲区域以快速写入，我们将日志分为段，并使用段清理器压缩高度碎片化段中的活动信息。” ——Rosenblum, M. 和 Ousterhout, J. K., 1992, "The design and implementation of a log-structured file system", ACM Trans. Computer Systems 10, 1, 26–52

漫游树问题
----------------------
在LFS中，当文件数据更新并写入日志末尾时，其直接指针块由于位置改变而更新。然后间接指针块也由于直接指针块的更新而更新。以此类推，上层索引结构（如inode、inode映射和检查点块）也会递归地更新。这个问题被称为漫游树问题[1]，为了提高性能，应尽可能消除或减少更新传播。
[1] Bityutskiy, A. 2005. JFFS3 设计问题. http://www.linux-mtd.infradead.org/

清理开销
-----------------
由于LFS基于非就地写入，因此会在整个存储空间中产生大量过时的块。为了提供新的空闲日志空间，需要无缝回收这些过时的块。这个过程称为清理过程。
清理过程包括以下三个操作：
1. 通过引用段使用表选择一个受害者段
2. 它加载由段摘要块识别的受害者数据的所有父索引结构。
3. 它检查数据与其父索引结构之间的交叉引用。
4. 它有选择性地移动有效数据。
此清理工作可能会导致意外的长时间延迟，因此最重要的目标是向用户隐藏这些延迟。同样，它应该减少需要移动的有效数据量，并且快速移动这些数据。

关键特性
========

闪存感知
---------------
- 扩大随机写入区域以提高性能，但提供高空间局部性。
- 尽可能将文件系统数据结构与FTL中的操作单元对齐。

游荡树问题
----------------------
- 使用术语“节点”，表示inode和各种指针块。
- 引入节点地址表（NAT），包含所有“节点”块的位置；这将切断更新传播。

清理开销
-----------------
- 支持后台清理进程。
- 支持贪婪算法和成本效益算法用于受害者选择策略。
- 支持多头日志用于静态/动态热点和冷点数据分离。
- 引入自适应日志记录以实现高效的块分配。

挂载选项
=============

======================== ============================================================
background_gc=%s	 开启/关闭在I/O子系统空闲时触发的后台清理操作，即垃圾回收。如果background_gc=on，则开启垃圾回收；如果background_gc=off，则关闭垃圾回收。如果background_gc=sync，则开启同步垃圾回收运行在后台。
此选项的默认值为on。所以默认情况下垃圾回收是开启的。
gc_merge		 当background_gc开启时，可以启用此选项让后台GC线程处理前台GC请求，这样可以消除由于有限I/O和CPU资源进程触发的慢速前台GC操作带来的迟缓问题。
nogc_merge		 禁用GC合并功能。
disable_roll_forward	 禁用前滚恢复例程。
norecovery		 禁用前滚恢复例程，只读挂载（即-o ro,disable_roll_forward）。
discard/nodiscard	 在f2fs中启用/禁用实时丢弃，如果启用了discard，f2fs将在一个段被清理时发出discard/TRIM命令。
heap/no_heap			（已弃用）
nouser_xattr			禁用扩展用户属性。注意：如果选择了CONFIG_F2FS_FS_XATTR，则默认启用xattr
noacl				禁用POSIX访问控制列表。注意：如果选择了CONFIG_F2FS_FS_POSIX_ACL，则默认启用acl
active_logs=%u			支持配置活动日志的数量。在当前设计中，f2fs仅支持2、4和6个日志
默认数量为6
disable_ext_identify		禁用由mkfs配置的扩展列表，因此f2fs不会识别冷文件（如媒体文件）
inline_xattr			启用内联xattrs功能
noinline_xattr			禁用内联xattrs功能
inline_xattr_size=%u		支持配置内联xattr大小，这取决于灵活的内联xattr功能
inline_data			启用内联数据功能：新创建的小于约3.4k的文件可以写入inode块
inline_dentry		 启用内联目录特性：新创建的目录项中的数据可以写入inode块。用于存储内联dentries的inode块的空间限制为约3.4KB。
noinline_dentry		 禁用内联dentry特性
flush_merge		 尽可能合并并发的cache_flush命令，以消除冗余命令问题。如果底层设备处理cache_flush命令相对较慢，建议启用此选项。
nobarrier		 如果底层存储保证其缓存的数据应被写入非易失性区域，则可以使用此选项。如果设置了此选项，不会发出任何cache_flush命令，但f2fs仍保证所有数据写入的顺序。
barrier		 如果设置了此选项，则允许发出cache_flush命令。
fastboot		 当系统希望尽可能减少挂载时间时使用此选项，即使正常的性能可能会受到影响。
extent_cache		 启用基于红黑树（rb-tree）的范围缓存，它可以缓存每个inode之间连续逻辑地址与物理地址映射的多个范围，从而提高缓存命中率。默认启用。
noextent_cache		 明确禁用基于红黑树（rb-tree）的范围缓存，请参见上述extent_cache挂载选项。
noinline_data		 禁用内联数据特性，默认情况下内联数据特性是启用的。
data_flush		 在检查点之前启用数据刷新，以持久化普通文件和符号链接的数据
reserve_root=%d	 支持配置预留空间，该空间用于特权用户（指定的UID或GID）的分配，单位：4KB，默认限制为用户块的0.2%
resuid=%d		 可使用预留块的用户ID
resgid=%d		 可使用预留块的组ID
fault_injection=%d	 启用所有支持类型的故障注入，并指定注入率
fault_type=%d		 支持配置故障注入类型，应与fault_injection选项一起启用，故障类型值如下所示，支持单个或组合类型
===========================      ===========
			 类型名称                        类型值
			 ===========================      ===========
			 FAULT_KMALLOC                    0x000000001
			 FAULT_KVMALLOC                   0x000000002
			 FAULT_PAGE_ALLOC                 0x000000004
			 FAULT_PAGE_GET                   0x000000008
			 FAULT_ALLOC_BIO                  0x000000010（已弃用）
			 FAULT_ALLOC_NID                  0x000000020
			 FAULT_ORPHAN                     0x000000040
			 FAULT_BLOCK                      0x000000080
			 FAULT_DIR_DEPTH                  0x000000100
			 FAULT_EVICT_INODE                0x000000200
			 FAULT_TRUNCATE                   0x000000400
			 FAULT_READ_IO                    0x000000800
			 FAULT_CHECKPOINT                 0x000001000
			 FAULT_DISCARD                    0x000002000
			 FAULT_WRITE_IO                   0x000004000
			 FAULT_SLAB_ALLOC                 0x000008000
			 FAULT_DQUOT_INIT                 0x000010000
			 FAULT_LOCK_OP                    0x000020000
			 FAULT_BLKADDR_VALIDITY           0x000040000
			 FAULT_BLKADDR_CONSISTENCE        0x000080000
			 FAULT_NO_SEGMENT                 0x000100000
			 ===========================      ===========
mode=%s			 控制块分配模式，支持“adaptive”和“lfs”。在“lfs”模式下，主区域不应有随机写入
“fragment:segment”和“fragment:block”是新添加的选项
这些是开发人员用于实验模拟文件系统碎片化/垃圾回收后情况的选项。开发人员使用这些模式来更好地理解文件系统的碎片化/垃圾回收后的状况，并最终获得一些处理这些情况的见解
在“fragment:segment”模式下，f2fs会在随机位置分配一个新的段。通过这种方式，我们可以模拟垃圾回收后的条件
在 "fragment:block" 模式中，我们可以通过 "max_fragment_chunk" 和 "max_fragment_hole" 这两个 sysfs 节点来分散块分配。为了使其接近真实的 I/O 模式，我们在块和空洞的大小上增加了一些随机性。因此，在这种模式下，f2fs 将在一个连续区域中分配 1 到 <max_fragment_chunk> 个块，并交替地创建长度为 1 到 <max_fragment_hole> 的空洞。通过这种方式，新分配的块将分布在分区的整个范围内。

请注意，“fragment:block” 隐式启用了 “fragment:segment” 选项以增加更多随机性。

请在实验中使用这些选项，并强烈建议在使用这些选项后重新格式化文件系统。

usrquota		 启用普通用户磁盘配额统计
grpquota		 启用普通组磁盘配额统计
prjquota		 启用普通项目配额统计
usrjquota=<file>	 在挂载时指定文件和类型，以便在恢复过程中正确更新配额信息，
grpjquota=<file>	 <quota file>: 必须位于根目录；
prjjquota=<file>	 <quota file>: 必须位于根目录；
jqfmt=<quota type>	 <quota type>: [vfsold,vfsv0,vfsv1]
offusrjquota		 关闭用户日志配额
offgrpjquota		 关闭组日志配额
offprjjquota		 关闭项目日志配额
quota			 启用普通用户磁盘配额计账
noquota			 禁用所有普通磁盘配额选项
alloc_mode=%s		 调整块分配策略，支持 "reuse" 和 "default"
fsync_mode=%s		 控制 fsync 策略。目前支持 "posix"、"strict" 和 "nobarrier"。在 "posix" 模式下，默认情况下，fsync 将遵循 POSIX 语义并执行轻量级操作以提高文件系统性能。
在 "strict" 模式下，fsync 将变得繁重，并且行为与 xfs、ext4 和 btrfs 一致，其中 xfstest generic/342 将通过，但性能会退化。“nobarrier” 基于 “posix”，但对于非原子文件不发出 flush 命令，类似于 "nobarrier" 挂载选项。
test_dummy_encryption
test_dummy_encryption=%s
			 启用虚拟加密，提供一个假的 fscrypt 上下文。这个假的 fscrypt 上下文用于 xfstests 测试。
参数可以是 "v1" 或 "v2"，以便选择相应的 fscrypt 策略版本。
checkpoint=%s[:%u[%]]	 设置为 "disable" 以关闭检查点。设置为 "enable" 以重新启用检查点。默认情况下是启用的。当禁用时，任何卸载或意外关机会导致文件系统内容显示为挂载该选项时的状态。
使用 checkpoint=disable 挂载时，文件系统必须运行垃圾回收以确保所有可用空间都可以使用。如果这需要太多时间，挂载可能会返回 EAGAIN。您可以选择添加一个值来表示您愿意暂时放弃多少磁盘空间以避免额外的垃圾回收。这可以是一个区块数或百分比。例如，使用 checkpoint=disable:100% 挂载将始终成功，但它可能会隐藏所有剩余的空闲空间。实际不可用的空间可以在 /sys/fs/f2fs/<disk>/unusable 中查看。一旦 checkpoint=enable，这些空间会被回收。
### 检查点合并 (checkpoint_merge)

当启用检查点时，此选项可用于创建一个内核守护进程，并尽可能地合并并发的检查点请求，以消除冗余的检查点问题。此外，当在一个具有较低I/O预算和CPU份额的cgroup中执行检查点操作时，我们可以消除由此导致的迟缓问题。为了使这一功能更好，我们将内核守护进程的默认I/O优先级设置为“3”，使其比其他内核线程有更高的优先级。

这与给ext4文件系统的jbd2日志线程分配I/O优先级的方式相同。

### 禁用检查点合并 (nocheckpoint_merge)

禁用检查点合并功能。

### 压缩算法 (compress_algorithm=%s)

控制压缩算法，目前F2FS支持“lzo”、“lz4”、“zstd”和“lzo-rle”算法。

### 压缩算法及其压缩级别 (compress_algorithm=%s:%d)

控制压缩算法及其压缩级别。目前，只有“lz4”和“zstd”支持压缩级别配置。

- **lz4**: 压缩级别范围为3到16。
- **zstd**: 压缩级别范围为1到22。

### 压缩日志大小 (compress_log_size=%u)

支持配置压缩簇大小。大小将为4KB * (1 << %u)。默认和最小大小为16KB。

### 压缩扩展名 (compress_extension=%s)

支持添加指定的扩展名，以便F2FS能够对相应的文件启用压缩。例如，如果所有带有“.ext”的文件都有很高的压缩率，我们可以将“.ext”添加到压缩扩展名列表中，默认启用这些文件的压缩，而不需要通过ioctl命令来启用。

对于其他文件，我们仍然可以通过ioctl命令启用压缩。

注意：有一个保留的特殊扩展名“*”，可以设置为对所有文件启用压缩。

### 禁用压缩扩展名 (nocompress_extension=%s)

支持添加指定的扩展名，以便F2FS能够对相应的文件禁用压缩，这与启用压缩扩展名相反。
如果你确切地知道哪些文件无法被压缩，可以使用以下方法：
相同扩展名不能同时出现在压缩（compress）和不压缩（nocompress）列表中。
如果压缩扩展指定了所有文件，则不压缩扩展指定的类型将被视为特殊情况，并且不会被压缩。
不允许在不压缩扩展中使用“*”来指定所有文件。
添加不压缩扩展（nocompress_extension）后，优先级应为：
dir_flag < comp_extention, nocompress_extension < comp_file_flag, no_comp_file_flag
更多详情请参阅压缩部分。
compress_chksum 支持验证压缩簇中的原始数据校验和。
compress_mode=%s 控制文件压缩模式。支持“fs”和“user”两种模式。在“fs”模式（默认）下，f2fs 对启用压缩功能的文件进行自动压缩。在“user”模式下，f2fs 禁用自动压缩，并允许用户自行选择目标文件和时机。用户可以使用 ioctl 手动对启用压缩功能的文件进行压缩和解压缩。
compress_cache 支持使用文件系统管理的inode地址空间来缓存压缩块，以提高随机读取时的缓存命中率。
inlinecrypt 在可能的情况下，使用 blk-crypto 框架而不是文件系统层加密来加密和解密加密文件的内容。这允许使用内联加密硬件。磁盘上的格式不受影响。更多详细信息，请参阅 Documentation/block/inline-encryption.rst。
### 启用年龄阈值垃圾回收
启用年龄阈值垃圾回收，它在后台垃圾回收中提供了高效性和有效性。

### 控制丢弃单元
`discard_unit=%s` 控制丢弃单元。参数可以是 "block"、"segment" 和 "section"。发出的丢弃命令的偏移量/大小将对齐到该单元。默认情况下设置为 `discard_unit=block`，以启用小规模丢弃功能。
对于 blkzoned 设备，默认设置为 `discard_unit=section`，这有助于大规模 SMR 或 ZNS 设备通过消除文件系统元数据来减少内存成本，并支持小规模丢弃。

### 控制内存模式
`memory=%s` 控制内存模式。支持 "normal" 和 "low" 模式。
"low" 模式用于支持低内存设备。由于低内存设备的特性，在此模式下，f2fs 有时会牺牲性能以节省内存。
"normal" 模式是默认模式，与之前相同。

### 启用年龄范围缓存
`age_extent_cache` 启用基于 rb-tree 的年龄范围缓存。它记录每个 inode 的数据块更新频率，以便为数据块分配提供更好的温度提示。

### 错误处理
`errors=%s` 指定 f2fs 在严重错误时的行为。支持以下模式：
- "panic"：立即触发 panic
- "continue"：继续而不做任何操作
- "remount-ro"：以只读模式重新挂载分区
默认使用 "continue" 模式。

### 错误处理模式表
| 模式       | 继续 (continue)    | 只读重新挂载 (remount-ro) | 立即 panic (panic) |
|------------|-------------------|--------------------------|-------------------|
| 访问操作   | 正常              | 正常                     | 不适用             |
| 系统调用错误 | -EIO              | -EROFS                   | 不适用             |
| 挂载选项   | 读写 (rw)         | 只读 (ro)                | 不适用             |
| 待处理目录写入 | 保留             | 保留                     | 不适用             |
| 待处理非目录写入 | 丢弃             | 保留                     | 不适用             |
| 待处理节点写入 | 丢弃             | 保留                     | 不适用             |
| 待处理元数据写入 | 保留             | 保留                     | 不适用             |

### 调试文件系统条目
`/sys/kernel/debug/f2fs/` 包含所有挂载为 f2fs 的分区的信息。每个文件显示整个 f2fs 的信息。
/sys/kernel/debug/f2fs/status 包含：

- 目前由 f2fs 管理的主要文件系统信息
- 整个段的平均 SIT 信息
- 当前 f2fs 消耗的内存占用情况

Sysfs 条目
==========

已挂载的 f2fs 文件系统的相关信息可以在 /sys/fs/f2fs 中找到。每个已挂载的文件系统都会在其设备名称的基础上在 /sys/fs/f2fs 中有一个目录（例如，/sys/fs/f2fs/sda）。每个设备目录中的文件如下面表格所示。
/sys/fs/f2fs/<devname> 中的文件
（另见 Documentation/ABI/testing/sysfs-fs-f2fs）

使用方法
=====

1. 下载用户空间工具并编译它们
2. 如果 f2fs 已经静态编译到内核中，则跳过此步骤
否则，插入 f2fs.ko 模块：

	# insmod f2fs.ko

3. 创建一个用于挂载的目录：

	# mkdir /mnt/f2fs

4. 格式化块设备，并以 f2fs 文件系统进行挂载：

	# mkfs.f2fs -l label /dev/block_device
	# mount -t f2fs /dev/block_device /mnt/f2fs

mkfs.f2fs
---------
mkfs.f2fs 用于将分区格式化为 f2fs 文件系统，构建基本的磁盘布局。
快速选项包括：

===============    ===========================================================
``-l [label]``     给卷指定标签，最多可使用 512 个 Unicode 字符
``-a [0 或 1]``    为基于堆的分配拆分每个区域的起始位置
默认设置为 1，执行此操作
``-o [int]``       设置相对于卷大小的超额配置比率（百分比）
===============    ===========================================================
``-s [int]``       设置每部分的段数，默认设置为5
``-s [int]``       设置每部分的段数，默认设置为1
``-z [int]``       设置每个区域的部分数，默认设置为1
``-e [str]``       设置基本扩展名列表，例如 "mp3,gif,mov"
``-t [0 或 1]``    禁用丢弃命令与否，默认设置为1，表示启用丢弃
===============    ===========================================================

注意：请参阅 mkfs.f2fs(8) 的手册页以获取完整的选项列表。

fsck.f2fs
---------
`fsck.f2fs` 是一个工具，用于检查格式化为 f2fs 的分区的一致性。它会检查文件系统元数据和用户生成的数据是否正确交叉引用。
请注意，该工具的初始版本不会修复任何不一致性。
快速选项包括：

  -d 调试级别 [默认:0]

注意：请参阅 fsck.f2fs(8) 的手册页以获取完整的选项列表

dump.f2fs
---------
dump.f2fs 显示特定inode的信息，并将SSA和SIT转储到文件中。每个文件分别是 dump_ssa 和 dump_sit。
dump.f2fs 用于调试 f2fs 文件系统的磁盘数据结构。
它显示由给定inode号识别的磁盘inode信息，并能够将所有SSA和SIT条目分别转储到预定义的文件 ./dump_ssa 和 ./dump_sit 中。
选项包括：

  -d 调试级别 [默认:0]
  -i inode 编号（十六进制）
  -s [从 #1~#2（十进制）转储 SIT 段号，对于所有段使用 0~-1]
  -a [从 #1~#2（十进制）转储 SSA 段号，对于所有段使用 0~-1]

示例：

    # dump.f2fs -i [inode] /dev/sdx
    # dump.f2fs -s 0~-1 /dev/sdx （SIT 转储）
    # dump.f2fs -a 0~-1 /dev/sdx （SSA 转储）

注意：请参阅 dump.f2fs(8) 的手册页以获取完整的选项列表

sload.f2fs
----------
sload.f2fs 提供了一种方法，可以在现有的磁盘映像中插入文件和目录。此工具在构建给定编译文件的 f2fs 映像时非常有用。
注意：请参阅 sload.f2fs(8) 的手册页以获取完整的选项列表

resize.f2fs
-----------
resize.f2fs 允许用户调整 f2fs 格式的磁盘映像大小，同时保留存储在映像中的所有文件和目录。
注意：请参阅 resize.f2fs(8) 的手册页以获取完整的选项列表

defrag.f2fs
-----------
defrag.f2fs 可用于整理分散写入的数据以及磁盘上的文件系统元数据。这可以通过提供更多的连续空闲空间来提高写入速度。
注：请参阅 `defrag.f2fs(8)` 的手册页以获取完整的选项列表。

f2fs_io
-------
f2fs_io 是一个简单的工具，用于发出各种文件系统 API 以及特定于 f2fs 的 API，这对 QA 测试非常有用。
注：请参阅 `f2fs_io(8)` 的手册页以获取完整的选项列表。

设计
======
磁盘布局
--------------

F2FS 将整个卷划分为多个段，每个段的大小固定为 2MB。一个区段由连续的段组成，而一个区域则由一组区段组成。默认情况下，区段和区域的大小都设置为一个段的大小，但用户可以通过 mkfs 轻松修改这些大小。

F2FS 将整个卷划分为六个区域，除了超级块之外的所有区域都由多个段组成，如下所示：

```
                                                对齐到区域大小 <-|
                 |-> 对齐到段大小
     _________________________________________________________________________
    |            |            |   Segment   |    Node     |   Segment  |      |
    | Superblock | Checkpoint |    Info.    |   Address   |   Summary  | Main |
    |    (SB)    |   (CP)     | Table (SIT) | Table (NAT) | Area (SSA) |      |
    |____________|_____2______|______N______|______N______|______N_____|__N___|
                                                                       .
                                                                       .
                                                                       .
._________________________________________
|_Segment_|_..._|_Segment_|_..._|_Segment_|
                                    .
                                    ._________._________
                                    |_section_|__...__|_
                                    .
```
.________
|__区域__|

- 超级块（SB）
  位于分区的开始位置，存在两个副本以避免文件系统崩溃。它包含基本的分区信息和f2fs的一些默认参数。
- 检查点（CP）
  包含文件系统信息、有效NAT/SIT集的位图、孤儿inode列表以及当前活动段的摘要条目。
- 段信息表（SIT）
  包含所有段的信息，如有效块计数及其有效性位图。
- 节点地址表（NAT）
  由存储在主区域中的所有节点块的块地址表组成。
- 段摘要区（SSA）
  包含所有存储在主区域中的数据和节点块的所有者信息的摘要条目。
- 主区域
  包含文件和目录数据及其索引。

为了防止文件系统与基于闪存的存储之间的对齐错误，F2FS将CP的起始块地址与段大小对齐。同时，通过在SSA区域预留一些段来将主区域的起始块地址与区域大小对齐。

有关更多技术细节，请参考以下调查：
https://wiki.linaro.org/WorkingGroups/Kernel/Projects/FlashCardSurvey

文件系统元数据结构
-------------------

F2FS采用检查点方案来保持文件系统的一致性。在挂载时，F2FS首先尝试通过扫描CP区域来找到最后一个有效的检查点数据。为了减少扫描时间，F2FS仅使用两份CP副本。
其中一个始终指示最后的有效数据，这被称为影子副本机制。除了CP（检查点）之外，NAT（名称地址转换）和SIT（超级信息表）也采用了影子副本机制。为了确保文件系统的完整性，每个CP都会指向有效的SIT和NAT副本，如下所示：

```
+--------+----------+---------+
|   CP   |    SIT   |   NAT   |
+--------+----------+---------+
.         .          .
.            .              .
.               .                 .
+-------+-------+--------+--------+--------+--------+
| CP #0 | CP #1 | SIT #0 | SIT #1 | NAT #0 | NAT #1 |
+-------+-------+--------+--------+--------+--------+
     |             ^                          ^
     |             |                          |
     `----------------------------------------'
```

### 索引结构

管理数据位置的关键数据结构是“节点”。类似于传统的文件结构，F2FS有三种类型的节点：inode、直接节点和间接节点。F2FS为一个inode块分配了4KB的空间，其中包含923个数据块索引、两个直接节点指针、两个间接节点指针以及一个双间接节点指针，如下面描述的那样。一个直接节点块包含1018个数据块，而一个间接节点块也包含1018个节点块。因此，一个inode块（即一个文件）覆盖的数据量为：

```
4KB * (923 + 2 * 1018 + 2 * 1018 * 1018 + 1018 * 1018 * 1018) := 3.94TB
```

inode块（4KB）
- 数据（923）
- 直接节点（2）
  - 数据（1018）
- 间接节点（2）
  - 直接节点（1018）
    - 数据（1018）
- 双间接节点（1）
  - 间接节点（1018）
    - 直接节点（1018）
      - 数据（1018）

请注意，所有节点块都由NAT映射，这意味着每个节点的位置需要通过NAT表进行转换。考虑到游离树问题，F2FS能够切断由于叶节点数据写入引起的节点更新传播。

### 目录结构

一个目录项占用11字节，包含以下属性：
- hash：文件名的哈希值
- ino：inode编号
- len：文件名长度
- type：文件类型，如目录、符号链接等

一个dentry块包含214个dentry槽和文件名。其中使用位图表示每个dentry是否有效。一个dentry块占用4KB，其组成如下：

```
Dentry Block(4K) = bitmap (27 字节) + reserved (3 字节) +
                  dentries (11 * 214 字节) + 文件名 (8 * 214 字节)
```

```
                         [Bucket]
             +--------------------------------+
             |dentry block 1 | dentry block 2 |
             +--------------------------------+
             .
             .
```
### 目录块结构：4KB
+--------+----------+----------+------------+
| bitmap | reserved | dentries | file names |
+--------+----------+----------+------------+
[目录块：4KB]

+------+------+-----+------+
| hash | ino  | len | type |
+------+------+-----+------+
[目录项结构：11字节]

F2FS 实现了多级哈希表来管理目录结构。每一级都有一个特定数量的哈希桶，如下所示。注意，“A(2B)”表示一个桶包含 2 个数据块。

```
----------------------
A : 桶
B : 块
N : MAX_DIR_HASH_DEPTH
----------------------

第 0 级   | A(2B)
          |
第 1 级   | A(2B) - A(2B)
          |
第 2 级   | A(2B) - A(2B) - A(2B) - A(2B)
          .     |   .       .       .
第 N/2 级 | A(2B) - A(2B) - A(2B) - A(2B) - A(2B) - ... - A(2B)
          .     |   .       .       .
第 N 级   | A(4B) - A(4B) - A(4B) - A(4B) - A(4B) - ... - A(4B)
```

块和桶的数量由以下公式确定：

```
                            ,- 2, 如果 n < MAX_DIR_HASH_DEPTH / 2,
第 n 级中的块数 = |
                            `- 4, 否则

                             ,- 2^(n + dir_level),
			     |        如果 n + dir_level < MAX_DIR_HASH_DEPTH / 2,
第 n 级中的桶数 = |
                             `- 2^((MAX_DIR_HASH_DEPTH / 2) - 1),
			              否则
```

当 F2FS 在目录中查找文件名时，首先计算文件名的哈希值。然后，在第 0 级的哈希表中查找包含该文件名及其inode号的目录项。如果未找到，则在第 1 级的下一个哈希表中进行扫描。以此类推，F2FS 从 1 到 N 逐级扫描哈希表。在每一级中，F2FS 只需扫描一个由以下公式确定的桶，这显示了 O(log(文件数)) 的复杂度：

```
第 n 级要扫描的桶号 = (哈希值) % (第 n 级的桶数)
```

在创建文件的情况下，F2FS 查找覆盖文件名的空连续槽。F2FS 以与查找操作相同的方式在整个级别的哈希表中搜索空槽。
下图显示了两种持有子目录的情况示例：

```
---------------> 目录 <---------------
|                                 |
子目录                             子目录

子目录 - 子目录                     [空位] - 子目录

子目录 - 子目录 - 子目录             [空位] - [空位] - 子目录

情况 1:                           情况 2:
子目录数 = 6,                       子目录数 = 3,
文件大小 = 7                        文件大小 = 7
```

### 默认块分配
在运行时，F2FS 在“主”区域中管理六个活动日志：热节点/温节点/冷节点 和 热数据/温数据/冷数据
- 热节点 包含目录的直接节点块
- 温节点 包含直接节点块，但不包括热节点块
- 冷节点 包含间接节点块
- 热数据 包含目录项块
- 温数据 包含数据块，但不包括热数据和冷数据块
- 冷数据 包含多媒体数据或迁移的数据块

LFS有两种空闲空间管理方案：线程日志和复制压缩。复制压缩方案被称为清理，适用于表现出优异顺序写性能的设备，因为新的数据段会一直用于写入新数据。然而，在高利用率情况下，它会受到清理开销的影响。相反，线程日志方案会遭受随机写入的问题，但不需要清理过程。F2FS采用了一种混合方案，默认采用复制压缩方案，但根据文件系统状态动态切换到线程日志方案。
为了与底层基于闪存的存储对齐，F2FS以区为单位分配段。F2FS期望区大小与FTL中垃圾收集的单元大小相同。此外，关于FTL中的映射粒度，F2FS尽可能从不同区域分配活动日志的每个区，因为FTL可以根据其映射粒度将活动日志中的数据写入一个分配单元。

清理过程
---------

F2FS既按需进行清理也在后台运行清理。按需清理是在没有足够空闲段来满足VFS调用时触发的。后台清理器由内核线程操作，并在系统空闲时触发清理任务。
F2FS支持两种受害者选择策略：贪婪算法和成本效益算法。在贪婪算法中，F2FS选择有效块数最少的受害者段。在成本效益算法中，F2FS根据段年龄和有效块数量选择受害者段，以解决贪婪算法中的日志块翻转问题。F2FS采用贪婪算法进行按需清理，而后台清理器则采用成本效益算法。
为了识别受害者段中的数据是否有效，F2FS管理一个位图。每个比特代表一个块的有效性，该位图是一个覆盖主区域中所有块的位流。

写提示策略
-----------

F2FS始终根据以下策略设置whint：
===================== ======================== ===================
用户                    F2FS                     块
===================== ======================== ===================
无                      META                     WRITE_LIFE_NONE|REQ_META
无                      HOT_NODE                 WRITE_LIFE_NONE
无                      WARM_NODE                WRITE_LIFE_MEDIUM
无                      COLD_NODE                WRITE_LIFE_LONG
ioctl(COLD)            COLD_DATA                WRITE_LIFE_EXTREME
扩展列表                "                        "

-- 缓冲I/O
无                      COLD_DATA                WRITE_LIFE_EXTREME
无                      HOT_DATA                 WRITE_LIFE_SHORT
无                      WARM_DATA                WRITE_LIFE_NOT_SET

-- 直接I/O
WRITE_LIFE_EXTREME     COLD_DATA                WRITE_LIFE_EXTREME
WRITE_LIFE_SHORT       HOT_DATA                 WRITE_LIFE_SHORT
WRITE_LIFE_NOT_SET     WARM_DATA                WRITE_LIFE_NOT_SET
WRITE_LIFE_NONE        "                        WRITE_LIFE_NONE
WRITE_LIFE_MEDIUM      "                        WRITE_LIFE_MEDIUM
WRITE_LIFE_LONG        "                        WRITE_LIFE_LONG
===================== ======================== ===================

fallocate(2) 策略
-------------------

默认策略遵循以下POSIX规则：
分配磁盘空间
    fallocate()的默认操作（即模式为零）在offset和len指定的范围内分配磁盘空间。如果offset+len大于文件大小，则文件大小（如stat(2)所示）将发生变化。offset和len指定范围内的任何未包含数据的子区域将在调用前被初始化为零。这种默认行为类似于posix_fallocate(3)库函数的行为，并旨在作为实现该函数的最佳方法。
然而，一旦 F2FS 收到 ioctl(fd, F2FS_IOC_SET_PIN_FILE)，并在 fallocate(fd, DEFAULT_MODE) 之前，它会分配包含零数据或随机数据的磁盘块地址，这对于以下场景非常有用：

1. 创建文件（create(fd)）
2. 设置文件固定（ioctl(fd, F2FS_IOC_SET_PIN_FILE)）
3. 分配空间（fallocate(fd, 0, 0, size)）
4. 获取块地址（address = fibmap(fd, offset)）
5. 打开块设备（open(blkdev)）
6. 写入块设备（write(blkdev, address)）

压缩实现
--------------

- 定义了一个新的术语“簇”作为压缩的基本单位。文件可以逻辑上划分为多个簇。一个簇包括 4 << n (n >= 0) 个逻辑页，压缩大小也是簇的大小，每个簇可以被压缩或不压缩。
- 在簇元数据布局中，使用一个特殊的块地址来指示该簇是压缩的还是正常的；对于压缩簇，后续的元数据将簇映射到 [1, 4 << n - 1] 物理块，在这些块中 f2fs 存储数据，包括压缩头和压缩后的数据。
- 为了消除重写期间的写放大问题，F2FS 只支持一次性写入文件的压缩。只有当簇中的所有逻辑块都包含有效数据，并且簇的数据压缩比低于指定阈值时，数据才能被压缩。
- 启用普通节点上的压缩有四种方式：

  * 使用 `chattr +c file`
  * 使用 `chattr +c dir; touch dir/file`
  * 挂载时使用 `-o compress_extension=ext; touch file.ext`
  * 挂载时使用 `-o compress_extension=*; touch any_file`

- 禁用普通节点上的压缩有两种方式：

  * 使用 `chattr -c file`
  * 挂载时使用 `-o nocompress_extension=ext; touch file.ext`

- 文件系统压缩标志、扩展名之间的优先级：

  * `compress_extension=so; nocompress_extension=zip; chattr +c dir; touch dir/foo.so; touch dir/bar.zip; touch dir/baz.txt`；则 foo.so 和 baz.txt 应该被压缩，bar.zip 不应该被压缩。`chattr +c dir/bar.zip` 可以启用对 bar.zip 的压缩。
  * `compress_extension=so; nocompress_extension=zip; chattr -c dir; touch dir/foo.so; touch dir/bar.zip; touch dir/baz.txt`；则 foo.so 应该被压缩，bar.zip 和 baz.txt 不应该被压缩。`chattr +c dir/bar.zip` 和 `chattr +c dir/baz.txt` 可以启用对 bar.zip 和 baz.txt 的压缩。

- 目前，压缩特性不会直接向用户暴露压缩空间，以确保以后可能的数据更新。相反，主要目标是尽可能减少数据写入闪存盘，从而延长磁盘寿命并缓解 I/O 拥塞。作为一种替代方案，我们添加了 ioctl(F2FS_IOC_RELEASE_COMPRESS_BLOCKS) 接口来回收压缩空间，并在设置了特殊标志后将其显示给用户。一旦压缩空间被释放，该标志将阻止向文件写入数据，直到通过 ioctl(F2FS_IOC_RESERVE_COMPRESS_BLOCKS) 预留压缩空间或将文件大小截断为零。

压缩元数据布局如下所示：

```
				[Dnode 结构]
	+-----------------------------------------------+
	| 簇 1 | 簇 2 | ......... | 簇 N |
	+-----------------------------------------------+
	.           .                       .
.                      .                .
```
压缩簇          .        .        正常簇
+----------+---------+---------+---------+  +---------+---------+---------+---------+
| 压缩标志位 | 块 1    | 块 2    | 块 3    |  | 块 1    | 块 2    | 块 3    | 块 4    |
+----------+---------+---------+---------+  +---------+---------+---------+---------+
       .
.
.
+-------------+-------------+----------+----------------------------+
| 数据长度     | 数据校验和   | 保留字段   |      压缩数据               |
+-------------+-------------+----------+----------------------------+

压缩模式
--------------------------

f2fs 支持 “fs” 和 “user” 两种压缩模式，并通过 “compression_mode” 挂载选项来启用。
通过此选项，f2fs 提供了选择压缩已启用压缩功能的文件的方式（参见“压缩实现”部分以了解如何在常规inode上启用压缩）。

1) compress_mode=fs
这是默认选项。f2fs 在写回已启用压缩功能的文件时自动进行压缩。

2) compress_mode=user
这会禁用自动压缩，并让用户自行决定目标文件及时间。用户可以使用以下 ioctl 命令手动对已启用压缩功能的文件进行压缩/解压缩：
- 要解压缩一个文件，

```c
int fd = open(filename, O_WRONLY, 0);
int ret = ioctl(fd, F2FS_IOC_DECOMPRESS_FILE);
```

- 要压缩一个文件，

```c
int fd = open(filename, O_WRONLY, 0);
int ret = ioctl(fd, F2FS_IOC_COMPRESS_FILE);
```

NVMe 分区命名空间设备
----------------------------

- ZNS 定义了每个分区的容量，它可以等于或小于分区大小。分区容量是指该分区内可用块的数量。
f2fs 会在初始挂载时检查分区容量是否小于分区大小，如果是，则任何在分区容量之后开始的段都会在空闲段位图中标记为不可用。这些段会被永久标记为已使用，因此不会被分配用于写入，也不需要进行垃圾回收。如果分区容量没有对齐到默认段大小（2MB），则一个段可以在分区容量之前开始并跨越分区容量边界。
这样的跨段也被视为可用段。所有超过区域容量的块在这些段中被视为不可用。
