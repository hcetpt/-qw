SPDX 许可证标识符: GPL-2.0

日志（jbd2）
--------------

ext3 中引入了日志，ext4 文件系统使用日志来保护文件系统免受系统崩溃导致的元数据不一致问题。可以在文件系统内部预留最多 10,240,000 个文件系统块作为“重要”数据写入磁盘的地方，以便尽可能快地将这些数据写入磁盘。一旦重要的数据事务完全写入磁盘并从磁盘写缓存中刷新，该数据的提交记录也会被写入日志。在某个时间点，日志代码会将事务写入磁盘上的最终位置（这可能涉及大量的寻道或大量的小读写擦除），然后再删除提交记录。如果系统在第二次慢写过程中崩溃，可以通过重放日志直到最新的提交记录，保证通过日志写入磁盘的所有内容的原子性。这样可以确保文件系统不会在元数据更新中途卡住。

出于性能原因，默认情况下 ext4 只通过日志写入文件系统的元数据。这意味着文件的数据块在崩溃后不能保证处于任何一致状态。如果这个默认保证级别（`data=ordered`）不令人满意，有一个挂载选项可以控制日志行为。如果设置为 `data=journal`，所有数据和元数据都会通过日志写入磁盘。这种方式较慢但最安全。如果设置为 `data=writeback`，脏数据块不会在元数据通过日志写入磁盘之前被刷新到磁盘。

在 `data=ordered` 模式下，ext4 还支持快速提交，有助于显著减少提交延迟。默认的 `data=ordered` 模式通过将元数据块记录到日志来工作。在快速提交模式下，ext4 只存储重建受影响元数据所需的最小增量信息，并将其存储在与 jbd2 共享的快速提交空间中。

一旦快速提交区域填满，或者快速提交不可能发生，或者 jbd2 提交计时器触发，ext4 将执行传统的完整提交。一个完整的提交会取消之前的所有快速提交，从而使快速提交区域为空以进行进一步的快速提交。此功能需要在创建文件系统时启用。

日志索引节点通常是索引节点 8。日志索引节点的前 68 字节复制到了 ext4 超级块中。日志本身是文件系统中的一个普通（但隐藏的）文件。该文件通常占用整个块组，尽管 mke2fs 试图将其放在磁盘中间。

jbd2 中的所有字段都以大端字节序写入磁盘。这与 ext4 相反。

注意：ext4 和 ocfs2 都使用 jbd2。

嵌入在 ext4 文件系统中的日志的最大大小为 2^32 个块。jbd2 本身似乎并不关心这一点。

布局
~~~~~~

一般来说，日志具有以下格式：

.. list-table::
   :widths: 16 48 16
   :header-rows: 1

   * - 超级块
     - 描述块（数据块或撤销块）[更多数据或撤销] 提交块
     - [更多事务...]
   * - 
     - 单个事务
     -

请注意，一个事务开始于描述块和一些数据，或者是一个块撤销列表。一个完成的事务总是以提交结束。如果没有提交记录（或校验和不匹配），则在重放期间会丢弃该事务。
外部日志
~~~~~~~~~~~~~~~~

可选地，ext4 文件系统可以使用外部日志设备创建（相对于使用预留inode的内部日志）。在这种情况下，在文件系统的设备上，`s_journal_inum` 应该为零，并且 `s_journal_uuid` 应该被设置。在日志设备上将有一个位于常规位置的ext4超级块，并且具有匹配的UUID。日志超级块将位于超级块之后的一个完整的块中。
.. list-table::
   :widths: 12 12 12 32 12
   :header-rows: 1

   * - 1024字节填充
     - ext4超级块
     - 日志超级块
     - 描述块（数据块或撤销块）[更多数据或撤销记录] 提交块
     - [更多事务...]
   * - 
     -
     -
     - 一个事务
     -

块头
~~~~~~~~~~~~

日志中的每个块都以一个通用的12字节头部开始，即 `struct journal_header_s`：

.. list-table::
   :widths: 8 8 24 40
   :header-rows: 1

   * - 偏移量
     - 类型
     - 名称
     - 描述
   * - 0x0
     - __be32
     - h_magic
     - jbd2 魔术数，值为 0xC03B3998
* - 0x4
     - __be32
     - h_blocktype
     - 描述了这个块包含的内容。参见下面的 jbd2_blocktype_ 表
* - 0x8
     - __be32
     - h_sequence
     - 与这个块关联的事务ID
.. _jbd2_blocktype:

日志块类型可以是以下之一：

.. list-table::
   :widths: 16 64
   :header-rows: 1

   * - 值
     - 描述
   * - 1
     - 描述符。这个块在事务期间通过日志写入的一系列数据块之前出现
* - 2
     - 块提交记录。这个块表示一个事务的完成
* - 3
     - 日志超级块，版本1
* - 4
     - 日志超级块，版本2
* - 5
     - 阻止撤销记录。这通过允许日志跳过写入随后被重写的块来加快恢复速度
超级块 (Super Block)
~~~~~~~~~~~

对于日志的日志超级块比 ext4 的简单得多。其中的关键数据包括日志的大小以及事务日志起始位置的信息。日志超级块记录为 `struct journal_superblock_s`，长度为 1024 字节：

.. list-table::
   :widths: 8 8 24 40
   :header-rows: 1

   * - 偏移量
     - 类型
     - 名称
     - 描述
   * -
     -
     -
     - 描述日志的静态信息
* - 0x0
     - journal_header_t (12 字节)
     - s_header
     - 公共头部，标识这是一个超级块
* - 0xC
     - __be32
     - s_blocksize
     - 日志设备块大小
* - 0x10
     - __be32
     - s_maxlen
     - 此日志中的总块数
* - 0x14
     - __be32
     - s_first
     - 日志信息的第一个块
* -
     -
     -
     - 描述当前日志状态的动态信息
* - 0x18
     - __be32
     - s_sequence
     - 日志中预期的第一个提交 ID
* - 0x1C
     - __be32
     - s_start
     - 日志起始位置的块号。与注释相反，该字段为零并不意味着日志是干净的！
   * - 0x20
     - __be32
     - s_errno
     - 错误值，由 jbd2_journal_abort() 设置
* -
     -
     -
     - 剩余字段仅在 v2 超级块中有效
* - 0x24
     - __be32
     - s_feature_compat
     - 兼容特性集。参见下面的 jbd2_compat_ 表格
* - 0x28
     - __be32
     - s_feature_incompat
     - 不兼容特性集。参见下面的 jbd2_incompat_ 表格
* - 0x2C
     - __be32
     - s_feature_ro_compat
     - 只读兼容特性集。目前没有此类特性
* - 0x30
     - __u8
     - s_uuid[16]
     - 日志的 128 位 UUID。在挂载时会与 ext4 超级块中的副本进行比较
* - 0x40
     - __be32
     - s_nr_users
     - 共享此日志的文件系统数量
* - 0x44
     - __be32
     - s_dynsuper
     - 动态超级块副本的位置。（未使用？）
   * - 0x48
     - __be32
     - s_max_transaction
     - 每次事务的日志块限制。（未使用？）
   * - 0x4C
     - __be32
     - s_max_trans_data
     - 每次事务的数据块限制。（未使用？）
   * - 0x50
     - __u8
     - s_checksum_type
     - 日志使用的校验和算法。参见 jbd2_checksum_type_ 获取更多信息
* - 0x51
     - __u8[3]
     - s_padding2
     -
   * - 0x54
     - __be32
     - s_num_fc_blocks
     - 日志中的快速提交块数量
* - 0x58
     - __be32
     - s_head
     - 日志头部（第一个未使用的块）的块号，仅在日志为空时是最新的
* - 0x5C
    - __u32
    - s_padding[40]
    -
* - 0xFC
    - __be32
    - s_checksum
    - 整个超级块的校验和，此字段设置为零
* - 0x100
    - __u8
    - s_users[16*48]
    - 共享日志的所有文件系统的ID。e2fsprogs/Linux不允许共享外部日志，但想象Lustre（或ocfs2？），它们使用jbd2代码，可能会允许
.. _jbd2_compat:

日志兼容特性是以下各项的组合：

.. list-table::
   :widths: 16 64
   :header-rows: 1

   * - 值
     - 描述
   * - 0x1
     - 日志维护数据块上的校验和 (JBD2_FEATURE_COMPAT_CHECKSUM)

.. _jbd2_incompat:

日志不兼容特性是以下各项的组合：

.. list-table::
   :widths: 16 64
   :header-rows: 1

   * - 值
     - 描述
   * - 0x1
     - 日志包含块撤销记录 (JBD2_FEATURE_INCOMPAT_REVOKE)
   * - 0x2
     - 日志可以处理64位块号 (JBD2_FEATURE_INCOMPAT_64BIT)
   * - 0x4
     - 日志异步提交 (JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)
   * - 0x8
     - 此日志使用第2版的磁盘上校验和格式。每个日志元数据块都有自己的校验和，描述符表中的块标签包含日志中每个数据块的校验和 (JBD2_FEATURE_INCOMPAT_CSUM_V2)
   * - 0x10
     - 此日志使用第3版的磁盘上校验和格式。这与第2版相同，但无论块号大小如何，日志块标签大小是固定的 (JBD2_FEATURE_INCOMPAT_CSUM_V3)
   * - 0x20
     - 日志包含快速提交块 (JBD2_FEATURE_INCOMPAT_FAST_COMMIT)

.. _jbd2_checksum_type:

日志校验和类型代码是以下之一。crc32或crc32c是最可能的选择
.. list-table::
   :widths: 16 64
   :header-rows: 1

   * - 值
     - 描述
   * - 1
     - CRC32
   * - 2
     - MD5
   * - 3
     - SHA1
   * - 4
     - CRC32C

描述符块
~~~~~~~~~

描述符块包含一个日志块标签数组，这些标签描述了随后的日志数据块的最终位置。描述符块是开放编码的，而不是完全由数据结构描述的，但这里还是给出了块结构。描述符块至少占用36字节，但使用一个完整的块：

.. list-table::
   :widths: 8 8 24 40
   :header-rows: 1

   * - 偏移量
     - 类型
     - 名称
     - 描述符
   * - 0x0
     - journal_header_t
     - (开放编码)
     - 公共块头
* - 0xC
     - struct journal_block_tag_s
     - 开放编码数组[]
     - 足够的标签以填满整个块或描述此描述符块之后的所有数据块
日志块标签具有以下任何一种格式，具体取决于设置的日志特性和块标签标志
如果设置了JBD2_FEATURE_INCOMPAT_CSUM_V3，则日志块标签定义为`struct journal_block_tag3_s`，其结构如下所示。大小为16或32字节
```markdown
.. list-table::
   :widths: 8 8 24 40
   :header-rows: 1

   * - 偏移量
     - 类型
     - 名称
     - 描述
   * - 0x0
     - __be32
     - t_blocknr
     - 对应数据块在磁盘上应结束位置的低32位
   * - 0x4
     - __be32
     - t_flags
     - 与描述符相关的标志。更多信息请参见表 `jbd2_tag_flags`
   * - 0x8
     - __be32
     - t_blocknr_high
     - 对应数据块在磁盘上应结束位置的高32位。如果未启用 JBD2_FEATURE_INCOMPAT_64BIT，则此字段为零
   * - 0xC
     - __be32
     - t_checksum
     - 日志 UUID、序列号和数据块的校验和
   * -
     -
     -
     - 此字段似乎未编码。它始终位于标签末尾，在 t_checksum 之后。如果设置了“相同 UUID”标志，则此字段不存在
   * - 0x8 或 0xC
     - char
     - uuid[16]
     - 与此标签关联的一个 UUID。此字段似乎是从 `struct journal_s` 中的 `j_uuid` 字段复制的，但只有 tune2fs 会修改该字段

.. _jbd2_tag_flags:

日志标签标志是以下组合中的任意一种：

.. list-table::
   :widths: 16 64
   :header-rows: 1

   * - 值
     - 描述
   * - 0x1
     - 磁盘上的块被转义了。数据块的前四个字节恰好匹配 jbd2 的魔数
   * - 0x2
     - 此块具有与前一个相同的 UUID，因此省略了 UUID 字段
   * - 0x4
     - 数据块被事务删除。（未使用？）
   * - 0x8
     - 这是此描述符块中的最后一个标签

如果未设置 JBD2_FEATURE_INCOMPAT_CSUM_V3，则日志块标签定义为 `struct journal_block_tag_s`，如下所示。大小为 8、12、24 或 28 字节：

.. list-table::
   :widths: 8 8 24 40
   :header-rows: 1

   * - 偏移量
     - 类型
     - 名称
     - 描述
   * - 0x0
     - __be32
     - t_blocknr
     - 对应数据块在磁盘上应结束位置的低32位
```
* - 0x4
     - __be16
     - t_checksum
     - 日志UUID、序列号和数据块的校验和
注意：仅存储低16位
* - 0x6
     - __be16
     - t_flags
     - 与描述符相关的标志。更多信息请参见表 jbd2_tag_flags_
* -
     -
     -
     - 如果超级块指示支持64位块号，则下一个字段才存在
* - 0x8
     - __be32
     - t_blocknr_high
     - 对应数据块在磁盘上的位置的高32位
* -
     -
     -
     - 此字段似乎是开放编码的。它总是出现在标签的末尾，在 t_flags 或 t_blocknr_high 之后。如果设置了“相同UUID”标志，则此字段不存在
* - 0x8 或 0xC
     - char
     - uuid[16]
     - 与此标签关联的一个UUID。此字段似乎是从 `struct journal_s` 中的 ``j_uuid`` 字段复制过来的，但只有 tune2fs 会修改该字段
如果设置了 JBD2_FEATURE_INCOMPAT_CSUM_V2 或 JBD2_FEATURE_INCOMPAT_CSUM_V3，则块的末尾是一个 `struct jbd2_journal_block_tail`，其结构如下：

.. list-table::
   :widths: 8 8 24 40
   :header-rows: 1

   * - 偏移量
     - 类型
     - 名称
     - 描述符
   * - 0x0
     - __be32
     - t_checksum
     - 日志UUID加上描述符块的校验和，此字段设为零

数据块
~~~~~~

通常情况下，通过日志写入磁盘的数据块会被逐字写入日志文件中，位于描述符块之后。但是，如果块的前四个字节与 jbd2 魔术数字匹配，则这四个字节将被替换为零，并且描述符块标签中的“转义”标志会被设置。
### 撤销块

撤销块用于防止在早期事务中重放某个块。此机制用于标记那些曾经被记录但不再被记录的块。通常，当一个元数据块被释放并重新分配为文件数据块时会发生这种情况；在这种情况下，在文件块写入磁盘后进行日志重放会导致数据损坏。
**注意**：该机制并不是用来表示“这个日志块被另一个日志块取代”，正如作者（djwong）错误地认为的那样。任何添加到事务中的块都会导致该块所有现有的撤销记录被移除。撤销块在 `struct jbd2_journal_revoke_header_s` 中描述，至少有 16 字节长，但使用一个完整的块：

| 偏移量 | 类型          | 名称    | 描述                                   |
|--------|---------------|---------|----------------------------------------|
| 0x0    | journal_header_t | r_header | 公共块头                             |
| 0xC    | __be32        | r_count | 本块中使用的字节数                     |
| 0x10   | __be32 或 __be64 | blocks[0] | 需要撤销的块                           |

在 `r_count` 后是一个线性数组，包含由该事务撤销的块号。每个块号的大小为 8 字节（如果超级块支持 64 位块号），否则为 4 字节。

如果设置了 `JBD2_FEATURE_INCOMPAT_CSUM_V2` 或 `JBD2_FEATURE_INCOMPAT_CSUM_V3`，撤销块的末尾是一个 `struct jbd2_journal_revoke_tail`，其格式如下：

| 偏移量 | 类型 | 名称     | 描述                                       |
|--------|------|----------|--------------------------------------------|
| 0x0    | __be32 | r_checksum | 日志 UUID 和撤销块的校验和                 |

### 提交块

提交块是一个哨兵，表示事务已完全写入日志。一旦这个提交块到达日志，与该事务相关的数据就可以写入其最终位置。

提交块由 `struct commit_header` 描述，长度为 32 字节（但使用一个完整的块）：

| 偏移量 | 类型          | 名称    | 描述                                       |
|--------|---------------|---------|--------------------------------------------|
| 0x0    | journal_header_s | (内联编码) | 公共块头                                 |
| 0xC    | unsigned char | h_chksum_type | 用于验证事务中数据块完整性的校验和类型。更多信息见 `jbd2_checksum_type_` |
| 0xD    | unsigned char | h_chksum_size | 校验和使用的字节数，通常是 4 字节           |
* - 0xE
    - unsigned char
    - h_padding[2]
    -
  * - 0x10
    - __be32
    - h_chksum[JBD2_CHECKSUM_BYTES]
    - 32字节的空间用于存储校验和。如果设置了JBD2_FEATURE_INCOMPAT_CSUM_V2或JBD2_FEATURE_INCOMPAT_CSUM_V3，第一个``__be32``是日志UUID和整个提交块的校验和，此字段为零。如果设置了JBD2_FEATURE_COMPAT_CHECKSUM，则第一个``__be32``是已写入事务的所有块的crc32。
* - 0x30
    - __be64
    - h_commit_sec
    - 事务提交的时间，从纪元开始的秒数
* - 0x38
    - __be32
    - h_commit_nsec
    - 上述时间戳的纳秒部分

快速提交
~~~~~~~~~~~~

快速提交区域按标签长度值的日志形式组织。每个TLV以一个存储标签和整个字段长度的``struct ext4_fc_tl``开头，后面跟着可变长度的特定标签值。以下是支持的标签及其含义：

.. list-table::
   :widths: 8 20 20 32
   :header-rows: 1

   * - 标签
     - 含义
     - 值结构
     - 描述
   * - EXT4_FC_TAG_HEAD
     - 快速提交区域头
     - ``struct ext4_fc_head``
     - 存储这些快速提交应在其后应用的事务TID
* - EXT4_FC_TAG_ADD_RANGE
     - 将范围添加到inode
     - ``struct ext4_fc_add_range``
     - 存储要添加到该inode的inode编号和范围
   * - EXT4_FC_TAG_DEL_RANGE
     - 删除inode的逻辑偏移量
     - ``struct ext4_fc_del_range``
     - 存储inode编号和需要删除的逻辑偏移量范围
   * - EXT4_FC_TAG_CREAT
     - 为新创建的文件创建目录项
     - ``struct ext4_fc_dentry_info``
     - 存储父inode编号、inode编号和新创建文件的目录项
   * - EXT4_FC_TAG_LINK
     - 将目录项链接到inode
     - ``struct ext4_fc_dentry_info``
     - 存储父inode编号、inode编号和目录项
   * - EXT4_FC_TAG_UNLINK
     - 解除inode的目录项链接
     - ``struct ext4_fc_dentry_info``
     - 存储父inode编号、inode编号和目录项

   * - EXT4_FC_TAG_PAD
     - 填充（未使用区域）
     - 无
     - 快速提交区域中的未用字节
* - EXT4_FC_TAG_TAIL
     - 标记快速提交的结束
     - ``struct ext4_fc_tail``
     - 存储代表此标签结束的提交TID以及此快速提交的CRC

快速提交重播幂等性
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果恢复代码遵循某些规则，快速提交标签本质上是幂等的。提交路径在提交时遵循的主要原则是存储特定操作的结果而不是存储过程。让我们考虑这个重命名操作：'mv /a /b'。假设目录项'/a'与inode 10关联。在快速提交过程中，我们不是将此操作存储为“将a重命名为b”的过程，而是将其存储为一系列结果：

- 将目录项b链接到inode 10
- 解除目录项a的链接
- inode 10具有有效的引用计数

当恢复代码运行时，它需要在文件系统上“强制”这种状态。这就是保证快速提交重播幂等性的原因。让我们来看一个非幂等过程的例子，并看看快速提交是如何使其幂等的。考虑以下操作序列：

1) rm A
2) mv B A
3) read A

如果我们按原样存储此操作序列，则重播不是幂等的。假设在(2)之后崩溃了。在第二次重播中，文件A（实际上是由于“mv B A”操作而创建的）会被删除。因此，在尝试读取A时，名为A的文件将不存在。所以，此操作序列不是幂等的。但是，如上所述，快速提交不是存储过程而是存储每个过程的结果。因此，上述过程的快速提交日志如下：

（假设在重播之前，目录项A链接到了inode 10，目录项B链接到了inode 11）

1) 解除A的链接
2) 将A链接到inode 11
3) 解除B的链接
4) inode 11

如果我们(3)之后崩溃了，我们将有文件A链接到inode 11。在第二次重播期间，我们将删除文件A（inode 11）。但是我们会重新创建它并使其指向inode 11。我们找不到B，所以我们只会跳过那一步。此时，inode 11的引用计数不可靠，但通过最后的inode 11标签的重播可以修复这一点。因此，通过将非幂等过程转换为一系列幂等结果，快速提交确保了重播期间的幂等性。
### 日志检查点

进行日志检查点确保所有事务及其关联的缓冲区都被提交到磁盘。正在进行中的事务将被等待并包含在检查点中。检查点在文件系统的关键更新过程中内部使用，包括日志恢复、文件系统调整大小以及释放 journal_t 结构。

用户空间可以通过 ioctl（EXT4_IOC_CHECKPOINT）触发一个日志检查点。这个 ioctl 接受一个 u64 类型的参数作为标志。目前支持三种标志：

1. EXT4_IOC_CHECKPOINT_FLAG_DRY_RUN 可以用于验证 ioctl 的输入。如果有任何无效输入，它会返回错误；否则，在不执行任何检查点操作的情况下返回成功。这可以用来检查系统上是否存在该 ioctl，并验证参数或标志是否有问题。
2. 另外两个标志是 EXT4_IOC_CHECKPOINT_FLAG_DISCARD 和 EXT4_IOC_CHECKPOINT_FLAG_ZEROOUT。这两个标志分别会导致在完成日志检查点后丢弃日志块或将日志块清零。EXT4_IOC_CHECKPOINT_FLAG_DISCARD 和 EXT4_IOC_CHECKPOINT_FLAG_ZEROOUT 不能同时设置。
   
当对系统进行快照或者为了符合内容删除 SLO（服务水平目标）时，这个 ioctl 可能是有用的。
