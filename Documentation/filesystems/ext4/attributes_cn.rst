SPDX 许可证标识符: GPL-2.0

扩展属性
-------------------

扩展属性（xattrs）通常存储在磁盘上的单独数据块中，并通过 `inode.i_file_acl*` 从节点（inode）进行引用。扩展属性的首次使用似乎是用于存储文件访问控制列表（ACL）和其他安全数据（如 SELinux）。通过 `user_xattr` 挂载选项，用户可以在所有属性名称以“user”开头的情况下存储扩展属性；不过，这一限制似乎在 Linux 3.0 版本后已经消失。

扩展属性可以出现在两个位置。第一个位置是在每个节点条目末尾与下一个节点条目开始之间。例如，如果 `inode.i_extra_isize = 28` 且 `sb.inode_size = 256`，则有 `256 - (128 + 28) = 100` 字节的空间可用于节点内扩展属性存储。第二个位置是在由 `inode.i_file_acl` 指向的块中。截至 Linux 3.11，该块不可能包含指向第二个扩展属性块的指针（甚至集群中的剩余块）。理论上，每个属性的值可以存储在一个单独的数据块中，但截至 Linux 3.11，代码不允许这样做。

键通常假定为 ASCIIZ 字符串，而值可以是字符串或二进制数据。

当扩展属性存储在节点之后时，它们有一个 4 字节长的头 `ext4_xattr_ibody_header`：

|---------------------|------------------|-----------------|---------------------------|
|   偏移量            |    类型          | 名称            | 描述                      |
|---------------------|------------------|-----------------|---------------------------|
| 0x0                 | __le32           | h_magic         | 识别用的魔法数字，0xEA020000。这个值是由 Linux 驱动程序设置的，不过 e2fsprogs 似乎不检查它（？）|

扩展属性块的起始部分位于 `struct ext4_xattr_header` 中，长度为 32 字节：

|---------------------|------------------|-----------------|---------------------------|
|   偏移量            |    类型          | 名称            | 描述                      |
|---------------------|------------------|-----------------|---------------------------|
| 0x0                 | __le32           | h_magic         | 识别用的魔法数字，0xEA020000|
| 0x4                 | __le32           | h_refcount      | 引用计数                  |
| 0x8                 | __le32           | h_blocks        | 使用的磁盘块数量          |
| 0xC                 | __le32           | h_hash          | 所有属性的哈希值          |
| 0x10                | __le32           | h_checksum      | 扩展属性块的校验和        |
| 0x14                | __u32            | h_reserved[3]   | 保留位，应为零            |
校验和是根据文件系统UUID、扩展属性块的64位块号以及整个块（包括头部+条目）计算得出的。
在`struct ext4_xattr_header`或`struct ext4_xattr_ibody_header`之后是一个`struct ext4_xattr_entry`数组；每个这样的条目至少有16字节长。当存储在一个外部块中时，`struct ext4_xattr_entry`条目必须按排序顺序存储。排序顺序首先是`e_name_index`，然后是`e_name_len`，最后是`e_name`。
存储在inode内的属性不需要按排序顺序存储。

.. list-table::
   :widths: 8 8 24 40
   :header-rows: 1

   * - 偏移量
     - 类型
     - 名称
     - 描述
   * - 0x0
     - __u8
     - e_name_len
     - 名称长度
   * - 0x1
     - __u8
     - e_name_index
     - 属性名称索引。下面有关于此的讨论
   * - 0x2
     - __le16
     - e_value_offs
     - 此属性值在存储块上的位置
       多个属性可以共享相同的值。对于inode属性，此值相对于第一个条目的起始位置；对于块，此值相对于块的起始位置（即头部）
   * - 0x4
     - __le32
     - e_value_inum
     - 存储该值的inode。零表示值与该条目在同一块中。仅当启用INCOMPAT_EA_INODE特性时才使用此字段
   * - 0x8
     - __le32
     - e_value_size
     - 属性值长度
   * - 0xC
     - __le32
     - e_hash
     - 属性名称和属性值的哈希值。内核不更新inode内属性的哈希值，因此在这种情况下，此值必须为零，因为e2fsck会验证任何非零哈希值，无论扩展属性存储在哪里
* - 0x10
  - char
  - e_name[e_name_len]
  - 属性名称。不包括末尾的 NULL

属性值可以跟在条目表的末尾。看起来有一个要求，即这些值必须对齐到 4 字节边界。这些值从块的末尾开始存储，并向 xattr_header/xattr_entry 表的方向增长。当两者发生冲突时，溢出的部分会被放到单独的磁盘块中。如果磁盘块已满，文件系统会返回 -ENOSPC。

`ext4_xattr_entry` 的前四个字段被设置为零以标记键列表的结束。

属性名称索引
~~~~~~~~~~~~~~~~~~~~~~

从逻辑上讲，扩展属性是一系列键值对。键被假定为以 NULL 结尾的字符串。为了减少键占用的磁盘空间，键字符串的开头部分与属性名称索引进行匹配。如果找到匹配项，则设置属性名称索引字段，并将匹配的字符串从键名中移除。以下是从名称索引值到键前缀的映射：

.. list-table::
   :widths: 16 64
   :header-rows: 1

   * - 名称索引
     - 键前缀
   * - 0
     - （无前缀）
   * - 1
     - "user."
   * - 2
     - "system.posix_acl_access"
   * - 3
     - "system.posix_acl_default"
   * - 4
     - "trusted."
   * - 6
     - "security."
   * - 7
     - "system."（仅内联数据？）
   * - 8
     - "system.richacl"（仅 SuSE 内核？）

例如，如果属性键是 "user.fubar"，则属性名称索引设置为 1，并将 "fubar" 名称记录到磁盘上。

POSIX 访问控制列表
~~~~~~~~~~

POSIX 访问控制列表以简化版的 Linux 内核（和 libacl）内部 ACL 格式存储。主要的区别在于版本号不同（1），并且 `e_id` 字段仅在命名用户和组的 ACL 中存储。
