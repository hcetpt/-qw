```
SPDX 许可证标识符: GPL-2.0

====================
读写 HPFS 2.09
====================

1998-2004, 米库拉斯·帕托卡

:email: mikulas@artax.karlin.mff.cuni.cz
:主页: https://artax.karlin.mff.cuni.cz/~mikulas/vyplody/hpfs/index-e.cgi

致谢
=======
克里斯·史密斯，1993年，最初的只读 HPFS 文件系统，部分代码和 HPFS 结构文件来自该文件系统

雅克·吉莱纳，MS-DOS 的 mmap，受 fs/nfs/mmap.c（乔恩·汤布斯 1993 年 8 月 15 日）启发

沃纳·阿尔梅斯伯格，1992-1993年，MS-DOS 选项解析器和 CR/LF 转换

挂载选项

uid=xxx,gid=xxx,umask=xxx（默认值为 uid=gid=0 umask=default_system_umask）
设置没有在扩展属性中指定所有者/组/模式的文件的所有者/组/模式。模式是反向的 umask - 例如 umask 027 给予所有者所有权限、组读取权限以及其他人无访问权限。注意，对于文件，模式与 0666 进行 AND 操作。如果您希望文件具有 'x' 权限，您必须使用扩展属性。
case=lower,asis（默认值为 asis）
在 readdir 中将文件名转换为小写
conv=binary,text,auto（默认值为 binary）
CR/LF -> LF 转换，如果设置为 auto，则根据扩展名进行决策 - 有一个文本扩展名列表（我认为不转换文本文件总比损坏二进制文件好）。如果您想更改此列表，请在源代码中更改。最初的只读 HPFS 包含一些奇怪的启发式算法，我将其移除了。我认为让计算机决定文件是文本还是二进制文件是有风险的。例如，DJGPP 二进制文件开头包含少量文本信息，在某些情况下可能会被误识别并损坏。
check=none,normal,strict（默认值为 normal）
检查级别。选择 none 将只会带来少许速度提升但存在较大风险。我尽力使它在 check=normal 时即使面对损坏的文件系统也不会崩溃。check=strict 表示许多冗余检查 - 用于调试（例如在访问文件时检查文件是否在位图中分配）。
errors=continue,remount-ro,panic（默认值为 remount-ro）
发现文件系统错误时的行为
chkdsk=no,errors,always（默认值为 errors）
何时标记文件系统为脏以便 OS/2 检查
eas=no,ro,rw（默认值为 rw）
如何处理扩展属性。'no' - 忽略它们并始终使用 uid/gid/mode 选项中指定的值。'ro' - 读取扩展属性但不创建它们。'rw' - 当您在文件系统上使用 chmod/chown/chgrp/mknod/ln -s 时创建扩展属性。
timeshift=(-)nnn（默认值为 0）
将时间偏移 nnn 秒。例如，如果您在 Linux 下看到的时间比在 OS/2 下多一个小时，请使用 timeshift=-3600

文件名
======

如同在 OS/2 中一样，文件名不区分大小写。然而，shell 认为名称区分大小写，因此当您创建一个名为 FOO 的文件时，可以使用 'cat FOO'、'cat Foo'、'cat foo' 或 'cat F*'，但不能使用 'cat f*'。请注意，您也无法在 HPFS 上编译 Linux 内核（也许还有其他东西），因为内核会创建像 bootsect.S 和 bootsect.s 这样的不同文件。当搜索名称中有字符 >= 128 的文件时，使用代码页 - 详见以下内容
OS/2 忽略文件名末尾的点和空格，因此这个驱动程序也这样做。如果您创建 'a. ...'，则会创建名为 'a' 的文件，但您仍然可以通过 'a.'、'a..'、'a .  . . ' 等名称访问它。
```
扩展属性
===================

在HPFS分区上，OS/2可以为每个文件关联一种特殊信息，称为扩展属性。扩展属性是由（键，值）对组成的，其中键是一个ASCII字符串，用于标识该属性，而值是可以变长的任意字节串。OS/2在那里存储窗口和图标位置以及文件类型。那么为什么不将其用于特定于Unix的信息，如文件所有者或访问权限呢？这个驱动程序可以做到这一点。如果你在一个HPFS分区上执行chown/chgrp/chmod操作，就会创建带有键“UID”、“GID”或“MODE”的扩展属性，并且值是两个字节。只有那些值与挂载选项中指定的默认值不同的扩展属性才会被创建。一旦创建了这些扩展属性，它们永远不会被删除，只是被修改。这意味着当你默认的uid=0时，输入类似“chown luser file; chown root file”的命令后，文件将包含扩展属性UID=0。当你卸载文件系统并再次以uid=luser_uid挂载时，文件仍然属于root！如果你将文件的权限设置为444，扩展属性“MODE”不会被设置，这是通过设置只读标志来实现的一个特殊情况。当你创建一个块设备或字符设备时，除了“MODE”之外，还会创建一个包含设备编号的特殊4字节扩展属性“DEV”。目前这个驱动程序无法调整扩展属性的大小——这意味着如果有人（我不知道是谁？）设置了不同大小的“UID”、“GID”、“MODE”或“DEV”属性，它们将不会被重写，更改这些值也无法生效。

符号链接
========

你可以在HPFS分区上创建符号链接，符号链接是通过设置名为“SYMLINK”的扩展属性来实现的，其值为符号链接的目标。像ext2一样，你可以对符号链接执行chown和chgrp操作，但我不知道这有什么用。对符号链接进行chmod操作会改变符号链接指向的文件的权限。这些符号链接仅适用于Linux使用，并且与OS/2不兼容。由于OS/2 PmShell符号链接是以非常复杂的方式存储的，因此不支持它们。他们试图做到当文件移动时链接也会变化……有时候有效。但是链接部分存储在目录的扩展属性中，部分存储在OS2SYS.INI中。我不愿意（也不知道如何）分析或更改OS2SYS.INI。

代码页
=========

HPFS可以包含多个用于不同代码页的大写表，每个文件都有一个指向其名称所使用的代码页的指针。然而，OS/2是在美国创建的，在那里人们对代码页不太关心，因此多代码页支持相当有缺陷。我有一个安装在磁盘上的捷克版OS/2，它使用代码页852。有一次我启动了一个运行在代码页850下的英文版OS/2，并在我的852分区上创建了一个文件。它将文件名的代码页标记为850——这是好的。但是当我再次启动捷克版OS/2时，这个文件完全无法访问，无论用什么名称都无法访问。似乎OS/2使用其系统代码页（852）大写搜索模式，并使用其代码页（850）大写要比较的文件名。这些永远不可能匹配。这真的是IBM开发人员想要的结果吗？但问题还在继续。当我在捷克版OS/2中在同一目录下创建另一个文件时，那个文件也无法访问。OS/2在搜索放置文件的位置时（注意，HPFS目录中的文件必须排序）可能使用了不同的大写方法，并在搜索文件时也使用了不同的方法。最后，当我在这个目录中打开PmShell时，PmShell崩溃了（有趣的是，重启后，PmShell试图再次打开这个目录）。chkdsk愉快地忽略了这些错误，只有低级别的磁盘修改才救了我。永远不要在同一系统上混合使用不同语言版本的OS/2，尽管HPFS设计允许这样做。

好吧，我可以为这个驱动程序实现复杂的代码页支持，但我认为这种在OS/2中实现有缺陷的功能会引起更多问题而不是带来好处。所以这个驱动程序简单地使用它找到的第一个代码页来进行大写和小写转换，不管文件的代码页索引是什么。通常所有文件名都在这个代码页中——只要你没有尝试我上面描述的操作。

已知的问题
==========

不支持OS/2服务器上的HPFS386。安装在普通OS/2客户端上的HPFS386应该可以工作。如果你有OS/2服务器，请仅使用只读模式。我不知道如何处理某些HPFS386结构，例如访问控制列表或扩展权限列表，我不知道如何在文件删除时删除它们，也不知道如何在创建扩展属性时不覆盖它们。请给我一些关于这些结构的信息，我会解决这些问题。不过，这个驱动程序应该能够检测到HPFS386结构的存在，重新以只读模式挂载，并且不破坏它们（我希望）。
当没有足够的空间来存储扩展属性时，它们会被截断，并且不会返回错误。
OS/2无法访问路径长度超过约256个字符的文件，但这个驱动程序允许这样做。chkdsk会忽略这样的错误。
有时你可能无法删除一个非常满的文件系统中的某些文件（返回错误ENOSPC）。这是因为目录树中的非叶节点中的文件在删除时必须被另一个节点替换。而新文件的名称可能比旧文件更长，因此新的名称无法适应目录节点（dnode）。这会导致目录树分裂，从而占用磁盘空间。解决办法是删除其他叶节点文件（文件是非叶节点的概率约为1/50），或者先截断文件以腾出一些空间。
只有在你有很多目录以至于预分配的目录带区已满时，你才会遇到这个问题，即：

    目录数量 / 文件系统的大小（MB）> 4
你不能删除打开的目录  
你不能覆盖重命名目录（这有什么用？）  
仅更改大小写的文件重命名无法工作。这个驱动程序支持它，但虚拟文件系统（VFS）不支持。类似`mv file FILE`的操作不会生效  
所有访问时间（atime）和目录修改时间（mtime）都不会更新。这是出于性能原因。如果你非常希望更新它们，请告诉我，我可以写代码来实现（但这会很慢）  
当系统内存不足且交换空间也耗尽时，文件系统可能会轻微损坏（丢失文件、不平衡的目录）。我认为所有文件系统都可能这样  
编译时，你会看到警告：函数声明不是原型。有人知道这意味着什么吗？

“不平衡树”消息是什么意思？
=============================

此驱动程序的老版本有时会创建不平衡的 dnode 树。OS/2 的 `chkdsk` 在树不平衡时不会报错（有时也会创建不平衡的树），但 HPFS 和 HPFS386 中有一个bug，即在树不平衡时偶尔会导致崩溃。此驱动程序正确处理不平衡的树，并在发现不平衡树时发出警告。如果你看到这个消息，这可能是由于使用老版本驱动程序创建的目录造成的。解决方法是将该目录中的所有文件移动到另一个目录中，然后再移回来。请在 Linux 中操作，而不是在 OS/2 中！如果你在一个完全由此驱动程序创建的目录中看到这个消息，那是一个BUG——请告知我

OS/2 中的 Bug
==============

当你有两个或多个丢失的目录相互指向对方时，`chkdsk` 会在修复文件系统时卡住  
有时（我认为是随机的），当你在 OS/2 下创建一个单字符名称的文件时，OS/2 会将其标记为“长”文件名。`chkdsk` 然后会移除这个标志，并报告“已修正次要文件系统错误”  
像"a .b"这样的文件名会被 OS/2 标记为“长”文件名，但 `chkdsk` 会“修正”它，并将其标记为短文件名（并写入“已修正次要文件系统错误”）。这个 Bug 不在 HPFS386 中
代码页错误描述
=============================

如果您不安装修复包，会有更多的问题出现。
历史记录
=======

版本 | 描述
--- | ---
0.90 | 第一个公开发布版
0.91 | 修复了在打开的inode上调用write_inode时导致内存射击的bug（很少发生）
0.92 | 修复了解除目录inode时的小内存泄漏
0.93 | 修复了当文件名前15个字符相同时锁定机器的问题  
| 修复了在文件末尾之后写入时将文件置零的问题
0.94 | 修复了尝试删除繁忙文件或目录时的小内存泄漏
0.95 | 修复了移动文件时i_hpfs_parent_dir未更新的bug
1.90 | 适用于2.1.1xx内核的第一个版本
1.91 | 修复了chk_sectors在磁盘末尾时失败的bug  
| 修复了在删除文件时调用write_inode的竞态条件  
| 修复了在文件名中使用0xff时可能发生的bug（概率极低）  
| 重写了锁机制以避免竞态条件  
| 挂载选项'eas'现在可用  
| fsync不再返回错误  
| 以'.'开头的文件被标记为隐藏  
| 添加了重新挂载支持  
| 文件系统接近满时分配不再那么慢  
| 不再更新atime，因为它会减慢操作速度  
| 代码清理（移除了所有注释掉的调试打印）
1.92 | 修复了在关闭文件之前调用sync时的bug
1.93 | 修改以兼容内核>=2.1.131，不确定是否与早期版本兼容  
| 修复了可能影响大于64GB磁盘的问题（但没有测试环境）  
| 修复了文件超过2GB时的溢出问题  
| 添加了新选项'timeshift'  
| 改变了对HPFS386的支持：现在可以以只读模式操作HPFS386  
| 修复了一个导致分配变慢并阻止完全分配空间的bug（此bug不具破坏性）
1.94 | 添加了一个针对Linux中的bug的解决方案  
| 修复了一个缓冲区泄漏  
| 修复了一些与大型扩展属性的不兼容问题（但仍然不是100%兼容，没有相关信息且OS/2不愿意创建它们）  
| 重写了分配机制  
| 修复了i_blocks的一个bug（du有时无法显示正确的值）  
| 目录不再设置归档属性（某些程序不喜欢这样）  
| 修复了大型anode树中设置标志的bug（不具破坏性）
1.95 | 修复了在损坏文件系统上可能出现的缓冲区泄漏  
| 修复了1.94中分配中的一个bug
1.96 | 添加了一个针对OS/2中bug的解决方案（HPFS会锁定，HPFS386在PMSHELL中打开目录时有时会报告错误）  
| 修复了可能的位图竞态  
| 修复了可能影响大磁盘的问题  
| 现在可以删除打开的文件  
| 修复了rename中的非破坏性竞态
1.97 | 支持HPFS v3（在大分区上）  
| 修复了不允许创建大于128MB文件的bug（应为2GB）
1.97.1 | 更改了全局符号的名称  
| 修复了chmod或chown根目录时的bug
1.98 | 修复了使用old_readdir时的死锁  
| 改进了目录处理；为OS/2中的“不平衡树”bug提供了解决方案
1.99 | 修正了删除文件时空间不足可能导致的问题  
| 现在如果删除时空间不足，会尝试截断文件  
| 移除了大量冗余代码
2.00 | 修复了自1.96以来存在的rename bug  
| 改进了防碎片策略
2.01 | 修复了通过NFS列出目录时的问题  
| 目录lseek现在检查正确的参数  
| 修复了缓冲区代码中的竞态条件——此问题存在于Linux的所有文件系统中；在读取设备（如cat /dev/hda）时创建文件，文件可能会损坏
2.02 | 针对Linux中breada的bug提供了解决方案。breada可能会导致访问超出分区末尾
2.03 | 字符、块设备和管道正确创建  
| 修复了unlink中的非崩溃竞态（Alexander Viro）  
| 现在支持日文版OS/2
2.04 | 修复了使用ftruncate扩展文件时的错误
2.05 | 修复了获取没有等号的挂载参数时的崩溃  
| 修复了由于磁盘满而导致anode分配失败时的崩溃  
| 修复了块I/O或inode分配失败时的一些崩溃
2.06 | 修复了损坏磁盘结构引起的一些崩溃  
| 改进的分配策略  
| 添加了重新调度点，以避免长时间锁定CPU  
| 应该能在Warp Server上以只读模式工作
2.07 | 更多针对Warp Server的修复。现在真正可用
2.08 | 在大磁盘上创建新文件不再那么慢  
| 尝试同步已删除文件不会生成文件系统错误
2.09 | 修复了极度碎片化文件的错误
