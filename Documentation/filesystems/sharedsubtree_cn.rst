SPDX 许可证标识符: GPL-2.0

===============
共享子树
===============

.. 目录:
    1) 概览
    2) 特性
    3) 设置挂载状态
    4) 使用案例
    5) 详细语义
    6) 测验
    7) 常见问题解答
    8) 实现

1) 概览
-----------
考虑以下情况：

一个进程希望克隆自己的命名空间，但仍然希望访问最近挂载的光盘。共享子树语义提供了实现上述目标所需的机制。
它为诸如按用户命名空间和版本化文件系统等功能提供了必要的构建模块。

2) 特性
-----------
共享子树提供了四种不同类型的挂载；具体来说是 `struct vfsmount` 的不同变体。

    a. 共享挂载
    b. 从属挂载
    c. 私有挂载
    d. 不可绑定挂载

2a) 共享挂载可以复制到多个挂载点，并且所有副本都完全相同。
这里有一个例子：

假设 `/mnt` 上有一个共享挂载：

    `mount --make-shared /mnt`

注意：mount(8) 命令现在支持 `--make-shared` 标志，
因此示例程序 'smount' 不再需要并已被移除：
    
    `# mount --bind /mnt /tmp`

上面的命令将 `/mnt` 上的挂载复制到挂载点 `/tmp`，并且两个挂载的内容保持一致：
    
    `# ls /mnt`
    `a b c`

    `# ls /tmp`
    `a b c`

现在假设我们在 `/tmp/a` 上挂载了一个设备：

    `# mount /dev/sd0 /tmp/a`

    `# ls /tmp/a`
    `t1 t2 t3`

    `# ls /mnt/a`
    `t1 t2 t3`

注意该挂载也传播到了 `/mnt` 上的挂载。
当 `/dev/sd0` 挂载在 `/mnt/a` 上时也是如此。内容也会在 `/tmp/a` 下可见。

2b) 从属挂载类似于共享挂载，只是挂载和卸载事件仅向其传播。
所有从属挂载都有一个主挂载，这个主挂载是共享的。
这里有一个例子：

假设 `/mnt` 上有一个共享挂载：
```bash
# 将 /mnt 设置为共享挂载点
mount --make-shared /mnt

# 将 /mnt 绑定挂载到 /tmp
mount --bind /mnt /tmp

# 新的挂载点 /tmp 成为了一个共享挂载点，它是 /mnt 挂载点的副本

# 现在让我们将 /tmp 设置为 /mnt 的从属挂载点
mount --make-slave /tmp

# 将 /dev/sd0 挂载到 /mnt/a
mount /dev/sd0 /mnt/a

# 查看 /mnt/a 的内容
# ls /mnt/a
t1 t2 t3

# 查看 /tmp/a 的内容
# ls /tmp/a
t1 t2 t3

# 注意挂载事件已经传播到了 /tmp 的挂载点

# 不过让我们看看如果我们在 /tmp 的挂载点上挂载其他设备会发生什么情况
# mount /dev/sd1 /tmp/b

# 查看 /tmp/b 的内容
# ls /tmp/b
s1 s2 s3

# 查看 /mnt/b 的内容
# ls /mnt/b

# 注意挂载事件没有传播到 /mnt 的挂载点

2c) 私有挂载不会转发或接收传播
这是我们熟悉的默认类型的挂载。
2d) 不可绑定挂载是一种不可绑定的私有挂载

假设我们有一个挂载点 /mnt 并将其设置为不可绑定的：

    # mount --make-unbindable /mnt

现在尝试在其他地方绑定挂载这个挂载点：

    # mount --bind /mnt /tmp
    mount: 错误的文件系统类型、选项错误、/mnt 上的超级块错误，或者挂载的文件系统太多

绑定一个不可绑定的挂载是无效的操作
3) 设置挂载状态
-----------------------

`mount` 命令（util-linux 软件包）可以用来设置挂载状态：

    mount --make-shared 挂载点
    mount --make-slave 挂载点
    mount --make-private 挂载点
    mount --make-unbindable 挂载点

4) 使用场景
------------

A) 进程希望克隆自己的命名空间，但仍然能够访问最近挂载的 CD
解决方案：

    系统管理员可以使 /cdrom 的挂载变为共享挂载：

        mount --bind /cdrom /cdrom
        mount --make-shared /cdrom

    现在任何克隆新命名空间的进程都将拥有一个与父命名空间中的相同挂载点的 /cdrom 挂载
因此当一张 CD 插入并挂载到 /cdrom 时，该挂载会传播到所有其他克隆命名空间中的 /cdrom 挂载点

B) 进程希望其挂载点对其他进程不可见，但仍能查看其他系统的挂载点
解决方案：

    首先，管理员可以将整个挂载树标记为共享：

        mount --make-rshared /

    新进程可以克隆一个新的命名空间，并将其命名空间的一部分标记为从属：

        mount --make-rslave /myprivatetree

    从此以后，进程在 /myprivatetree 内部进行的任何挂载都不会出现在其他命名空间中。但是，在父命名空间下的 /myprivatetree 中进行的挂载仍然会在进程的命名空间中显示出来。

除了上述语义之外，此功能还提供了以下问题的基础构建模块：

C) 每用户命名空间

    上述语义允许一种跨命名空间共享挂载的方法。但命名空间与进程相关联。如果使命名空间成为一级对象，并提供用户 API 来关联/解除关联一个命名空间与用户 ID，则每个用户都可以拥有自己的命名空间，并根据需求定制它。这需要在 PAM 中得到支持
```
D) 版本化的文件

    如果整个挂载树在多个位置可见，则底层版本化文件系统可以根据用于访问该文件的路径返回不同版本的文件。
一个例子是：

        mount --make-shared /
        mount --rbind / /view/v1
        mount --rbind / /view/v2
        mount --rbind / /view/v3
        mount --rbind / /view/v4

    如果 `/usr` 挂载了一个版本化文件系统，那么这个挂载也会出现在 `/view/v1/usr`、`/view/v2/usr`、`/view/v3/usr` 和 `/view/v4/usr`。

    用户可以通过访问 `/view/v3/usr/fs/namespace.c` 请求 `/usr/fs/namespace.c` 的 v3 版本。底层版本化文件系统可以解析出请求的是 v3 版本的文件系统，并返回相应的 inode。

5) 详细语义
---------------------
    以下部分解释了 bind、rbind、move、mount、umount 和 clone-namespace 操作的详细语义。

注意：本文档中，“vfsmount” 和名词 “mount” 被用来表示相同的事物。

5a) 挂载状态

    给定的挂载可以处于以下几种状态之一：

    1) 共享（shared）
    2) 从属（slave）
    3) 共享和从属（shared and slave）
    4) 私有（private）
    5) 不可绑定（unbindable）

    “传播事件” 定义为在某个 vfsmount 上生成并导致其他 vfsmount 进行挂载或卸载操作的事件。

    “对等组” 定义为一组相互传播事件的 vfsmount。

(1) 共享挂载

    “共享挂载” 定义为属于某个“对等组”的 vfsmount。
例如：

        mount --make-shared /mnt
        mount --bind /mnt /tmp

    在 `/mnt` 和 `/tmp` 的挂载都是共享的，并且属于同一个对等组。在 `/mnt` 或 `/tmp` 下进行的任何挂载或卸载操作都会反映在其对等组的所有其他挂载上。

(2) 从属挂载

    “从属挂载” 定义为接收传播事件但不转发传播事件的 vfsmount。
如其名称所示，从属挂载有一个主挂载，从该主挂载接收挂载/卸载事件。事件不会从从属挂载传播到主挂载。只有通过执行以下命令的共享挂载才能成为从属挂载：

        mount --make-slave mount

    被设置为从属的共享挂载不再共享，除非被修改为共享状态。
(3) 共享和从属

一个vfsmount可以是共享的也可以是从属的。这种状态表示该挂载是从属于某个vfsmount的，并且有自己的对等组。这个vfsmount会从其主vfsmount接收传播事件，并将这些事件转发给其“对等组”和从属vfsmount。
严格来说，vfsmount是共享的并且有自己的对等组，而这个对等组又是其他对等组的从属。
只有从属vfsmount可以通过执行以下命令或将其移动到共享vfsmount下变为“共享和从属”：

```shell
mount --make-shared mount
```

(4) 私有挂载

私有挂载定义为不接收或转发任何传播事件的vfsmount。

(5) 不可绑定挂载

不可绑定挂载定义为不接收或转发任何传播事件并且不能被绑定挂载的vfsmount。

状态图：

下面的状态图解释了在各种命令作用下挂载的状态转换：

```plaintext
-----------------------------------------------------------------------
|             |make-shared |  make-slave  | make-private |make-unbindab|
-----------------------------------------------------------------------
|shared      |shared      |*slave/private|   private    | unbindable  |
|-------------|------------|--------------|--------------|-------------|
|slave       |shared      | **slave      |    private   | unbindable  |
|             |and slave   |              |              |             |
|-------------|------------|--------------|--------------|-------------|
|shared      |shared      | slave        |    private   | unbindable  |
|and slave   |and slave   |              |              |             |
|-------------|------------|--------------|--------------|-------------|
|private     |shared      |  **private   |    private   | unbindable  |
|-------------|------------|--------------|--------------|-------------|
|unbindable  |shared      |**unbindable  |    private   | unbindable  |
------------------------------------------------------------------------

* 如果共享挂载是其对等组中的唯一挂载，则将其设为从属会自动使其变为私有。请注意，没有可以从中派生的主vfsmount。
** 将非共享挂载设置为从属不会对该挂载产生影响。
除了下面列出的命令外，“移动”操作也会根据目标挂载的类型改变挂载的状态。具体细节见第5d节。
5b) 绑定语义

考虑以下命令：

```shell
mount --bind A/a  B/b
```

其中'A'是源挂载，'a'是挂载'A'中的目录项，'B'是目标挂载，'b'是目标挂载中的目录项。
结果取决于'A'和'B'的挂载类型。下表提供快速参考：

```plaintext
--------------------------------------------------------------------------
|         BIND MOUNT OPERATION                                           |
|************************************************************************|
|source(A)->| shared      |       private  |       slave    | unbindable |
| dest(B)  |              |                |                |            |
|   |      |              |                |                |            |
|   v      |              |                |                |            |
|************************************************************************|
|  shared  | shared       |     shared     | shared & slave |  invalid   |
|          |              |                |                |            |
|non-shared| shared       |      private   |      slave     |  invalid   |
--------------------------------------------------------------------------
```

详细说明：

1. 'A'是一个共享挂载，'B'也是一个共享挂载。创建一个新的挂载'C'，它是'A'的克隆，其根目录项为'a'。'C'挂载在挂载'B'上的目录项'b'处。同时创建新的挂载'C1'、'C2'、'C3'等。
1. 在所有'B'传播到的挂载点上，在目录项'b'处创建并挂载新的挂载点'C'。创建一个新的传播树，包含'C1', ..., 'Cn'。这个传播树与'B'的传播树相同。最后，将'C'的对等组与'A'的对等组合并。

2. 'A'是一个私有挂载点，而'B'是一个共享挂载点。创建一个'A'的克隆挂载点'C'，其根目录项为'a'。在'B'的目录项'b'处挂载'C'。同时在所有'B'传播到的地方，在目录项'b'处创建并挂载新的挂载点'C1', 'C2', 'C3' ...。设置一个新的传播树，包含所有新的挂载点'C', 'C1', ..., 'Cn'，配置与'B'的传播树完全相同。

3. 'A'是挂载点'Z'的一个从属挂载点，而'B'是一个共享挂载点。创建一个'A'的克隆挂载点'C'，其根目录项为'a'。在'B'的目录项'b'处挂载'C'。同时在所有'B'传播到的地方，在目录项'b'处创建并挂载新的挂载点'C1', 'C2', 'C3' ...。创建一个新的传播树，包含新的挂载点'C', 'C1', ..., 'Cn'，这个传播树与'B'的传播树相同。最后，将挂载点'C'及其对等组设为挂载点'Z'的从属挂载点。换句话说，挂载点'C'处于“从属且共享”的状态。

4. 'A'是一个不可绑定挂载点，而'B'是一个共享挂载点。这是一个无效的操作。

5. 'A'是一个私有挂载点，而'B'是一个非共享挂载点（私有、从属或不可绑定）。创建一个'A'的克隆挂载点'C'，其根目录项为'a'。在'B'的目录项'b'处挂载'C'。

6. 'A'是一个共享挂载点，而'B'是一个非共享挂载点。创建一个'A'的克隆挂载点'C'，其根目录项为'a'。在'B'的目录项'b'处挂载'C'。将'C'设为'A'的对等组成员。

7. 'A'是挂载点'Z'的一个从属挂载点，而'B'是一个非共享挂载点。创建一个'A'的克隆挂载点'C'，其根目录项为'a'。在'B'的目录项'b'处挂载'C'。同时将'C'设为挂载点'Z'的从属挂载点。换句话说，'A'和'C'都是挂载点'Z'的从属挂载点。所有在'Z'上的挂载/卸载事件都会传播到'A'和'C'。但在'A'上的挂载/卸载事件不会传播到其他地方。同样，在'C'上的挂载/卸载事件也不会传播到其他地方。
8. 'A' 是一个不可绑定挂载点，而 'B' 是一个非共享挂载点。这是一个无效操作。不可绑定的挂载点不能被绑定挂载。

5c) Rbind 语义

rbind 和 bind 类似。Bind 复制指定的挂载点。Rbind 则复制指定挂载点树中的所有挂载点。
Rbind 挂载是将 bind 挂载应用于树中的所有挂载点。
如果 rbind 的源树中包含一些不可绑定的挂载点，则在新位置下这些不可绑定挂载点下的子树会被剪枝。
例如：

假设我们有以下挂载树：

```
    A
   /   \
   B   C
  / \ / \
  D E F G
```

假设除了 C 之外的所有挂载点都是非不可绑定类型。
如果这个树被 rbind 到 Z，

那么在新位置我们将得到如下树：

```
    Z
    |
    A'
   /
   B'		注意 C 下的子树在新位置被剪枝了
  / \ 
 D' E'
```

5d) Move 语义

考虑以下命令：

```
mount --move A B/b
```

其中 'A' 是源挂载点，'B' 是目标挂载点，'b' 是目标挂载点中的目录项。
结果取决于 'A' 和 'B' 的挂载类型。下面的表格是一个快速参考：

```
---------------------------------------------------------------------------
|           MOVE MOUNT OPERATION                                         |
|**************************************************************************
| source(A)->| shared      |       private  |       slave    | unbindable |
| dest(B)  |               |                |                |            |
|   |      |               |                |                |            |
|   v      |               |                |                |            |
|**************************************************************************
|  shared  | shared        |     shared     |shared and slave|  invalid   |
|          |               |                |                |            |
|non-shared| shared        |      private   |    slave       | unbindable |
***************************************************************************
```

.. Note:: 将位于共享挂载点下的挂载点移动是无效的。
详细情况如下：

1. 'A' 是一个共享挂载点，而 'B' 也是一个共享挂载点。挂载点 'A' 被挂载到 'B' 的目录项 'b' 上。同时创建新的挂载点 'A1', 'A2'... 'An' 并在所有接收来自 'B' 的传播的挂载点的目录项 'b' 上进行挂载。创建一个新的传播树，其配置与 'B' 完全相同。这个新的传播树包含所有新的挂载点 'A1', 'A2'... 'An'，并且这个新的传播树被附加到 'A' 已有的传播树上。
2. 'A' 是一个私有挂载点，而 'B' 是一个共享挂载点。挂载点 'A' 被挂载到 'B' 的目录项 'b' 上。同时创建新的挂载点 'A1', 'A2'... 'An' 并在所有接收来自 'B' 的传播的挂载点的目录项 'b' 上进行挂载。挂载点 'A' 变为共享挂载点，并创建一个与 'B' 相同的新传播树。这个新的传播树包含所有新的挂载点 'A1', 'A2'... 'An'。
3. 'A' 是 'Z' 的从属挂载点，而 'B' 是共享挂载点。挂载点 'A' 被挂载在 'B' 的 dentry 'b' 上。同时创建新的挂载点 'A1', 'A2' ... 'An' 并挂载在所有接收来自 'B' 的传播的挂载点上的 dentry 'b' 处。一个新的传播树被创建，并且其配置与 'B' 完全相同。这个新的传播树包含所有的新挂载点 'A1', 'A2' ... 'An'。并且这个新的传播树被附加到 'A' 已有的传播树上。挂载点 'A' 仍然是 'Z' 的从属挂载点，但它同时也成为共享挂载点。

4. 'A' 是不可绑定的挂载点，而 'B' 是共享挂载点。此操作无效。因为在共享挂载点 'B' 上挂载任何内容都会创建新的挂载点，并将这些新挂载点挂载在所有接收来自 'B' 的传播的挂载点上。由于挂载点 'A' 是不可绑定的，因此无法将其克隆到其他挂载点。

5. 'A' 是私有挂载点，而 'B' 是非共享挂载点（私有、从属或不可绑定）。挂载点 'A' 被挂载在 'B' 的 dentry 'b' 上。

6. 'A' 是共享挂载点，而 'B' 是非共享挂载点。挂载点 'A' 被挂载在 'B' 的 dentry 'b' 上。挂载点 'A' 仍然保持为共享挂载点。

7. 'A' 是 'Z' 的从属挂载点，而 'B' 是非共享挂载点。挂载点 'A' 被挂载在 'B' 的 dentry 'b' 上。挂载点 'A' 仍然是 'Z' 的从属挂载点。

8. 'A' 是不可绑定的挂载点，而 'B' 是非共享挂载点。挂载点 'A' 被挂载在 'B' 的 dentry 'b' 上。挂载点 'A' 仍然保持为不可绑定的挂载点。

5e) 挂载语义

考虑以下命令：

    mount device B/b

其中 'B' 是目标挂载点，'b' 是目标挂载点中的 dentry。
上述操作与绑定操作相同，唯一的区别是源挂载点始终是私有挂载点。

5f) 卸载语义

考虑以下命令：

    umount A

其中 'A' 是在挂载点 'B' 的 dentry 'b' 上挂载的一个挂载点。
如果挂载点 'B' 是共享的，则所有最近挂载在 dentry 'b' 上的挂载点（这些挂载点接收来自挂载点 'B' 的传播，并且它们内部没有子挂载）将被卸载。

举例来说：假设 'B1'、'B2' 和 'B3' 是相互传播的共享挂载点。
假设 'A1'、'A2' 和 'A3' 分别首先挂载在挂载点 'B1'、'B2' 和 'B3' 的 dentry 'b' 上。
假设 'C1'、'C2' 和 'C3' 分别接下来挂载在同一 dentry 'b' 上的挂载点 'B1'、'B2' 和 'B3' 上。
如果 'C1' 被卸载，那么所有最近挂载在 'B1' 以及 'B1' 传播到的挂载点上的挂载都将被卸载。
'B1' 传播到 'B2' 和 'B3'。而在 'B2' 的 dentry 'b' 上最近挂载的是 'C2'，在 'B3' 上是 'C3'。
因此，'C1'、'C2' 和 'C3' 都应该被卸载。
如果 'C2' 或 'C3' 中有任何一个有子挂载，则该挂载不会被卸载，但所有其他挂载会被卸载。然而，如果要求卸载 'C1' 并且 'C1' 有子挂载，则卸载操作将完全失败。

5g) 克隆命名空间

克隆的命名空间包含与父命名空间中相同的挂载点。
假设 'A' 和 'B' 分别是父命名空间和子命名空间中的对应挂载点。
### 翻译

#### 如果 'A' 是共享挂载，则 'B' 也是共享挂载，且 'A' 和 'B' 相互传播
如果 'A' 是 'Z' 的从属挂载，则 'B' 也是 'Z' 的从属挂载
如果 'A' 是私有挂载，则 'B' 也是私有挂载
如果 'A' 是不可绑定挂载，则 'B' 也是不可绑定挂载

#### 练习
---

**A. 下列命令序列的结果是什么？**

```
mount --bind /mnt /mnt
mount --make-shared /mnt
mount --bind /mnt /tmp
mount --move /tmp /mnt/1
```

`/mnt`、`/mnt/1` 和 `/mnt/1/1` 的内容应该是什么？
它们是否完全相同？还是只有 `/mnt` 和 `/mnt/1` 相同？

**B. 下列命令序列的结果是什么？**

```
mount --make-rshared /
mkdir -p /v/1
mount --rbind / /v/1
```

`/v/1/v/1` 的内容应该是什么？

**C. 下列命令序列的结果是什么？**

```
mount --bind /mnt /mnt
mount --make-shared /mnt
mkdir -p /mnt/1/2/3 /mnt/1/test
mount --bind /mnt/1 /tmp
mount --make-slave /mnt
mount --make-shared /mnt
mount --bind /mnt/1/2 /tmp1
mount --make-slave /mnt
```

此时我们有一个挂载在 `/tmp`，其根目录项为 1。我们将这个挂载称为 'A'。
然后我们有一个挂载在 `/tmp1`，其根目录项为 2。我们将这个挂载称为 'B'。
接着我们有一个挂载在 `/mnt`，其根目录项为 `mnt`。我们将这个挂载称为 'C'。

'B' 是 'A' 的从属挂载，而 'C' 是 'B' 的从属挂载：A -> B -> C。

此时如果执行以下命令：

```
mount --bind /bin /tmp/test
```

尝试在 'A' 上进行挂载。

挂载是否会传播到 'B' 和 'C'？

`/mnt/1/test` 的内容会是什么？

### 常见问题解答
---

**Q1. 为什么需要绑定挂载？它与符号链接有何不同？**
符号链接会在目标挂载被卸载或移动时失效。绑定挂载即使其他挂载被卸载或移动仍然存在。

**Q2. 为什么不能使用 exportfs 实现共享子树？**
exportfs 是实现共享子树的一部分功能的一种较重的方法。我无法想象如何使用 exportfs 实现从属挂载的语义。

**Q3. 为什么需要不可绑定挂载？**
假设我们要在同一子树中的多个位置复制挂载树。如果在同一子树中 n 次 rbind 挂载一个树，创建的挂载数量是 n 的指数函数。使用不可绑定挂载可以剪枝不必要的绑定挂载。以下是一个示例：

**步骤 1:**
假设根树只有两个目录，并且只有一个 vfsmount:

```
    root
   /    \
  tmp    usr
```

并且我们希望在 `/root/tmp` 下的多个挂载点复制该树。

**步骤 2:**
```
mount --make-shared /root
mkdir -p /tmp/m1
mount --rbind /root /tmp/m1
```

新树现在看起来像这样:

```
    root
   /    \
  tmp    usr
 /
m1
/  \
tmp  usr
 /
m1
```

有两个 vfsmounts。

**步骤 3:**
```
mkdir -p /tmp/m2
mount --rbind /root /tmp/m2
```

新树现在看起来像这样:

```
    root
   /    \
  tmp    usr
 /    \
m1     m2
 / \      /  \
tmp  usr  tmp  usr
 / \         /
m1  m2      m1
 /  \     /  \
tmp usr  tmp   usr
 /        / \
m1       m1  m2
/  \
tmp   usr
/  \
m1   m2
```

有六个 vfsmounts。

**步骤 4:**
```
mkdir -p /tmp/m3
mount --rbind /root /tmp/m3
```

我不画这棵树了，但它有 24 个 vfsmounts。

在第 i 步，vfsmounts 的数量 V[i] = i * V[i-1]。
这是一个指数函数，而且这棵树的挂载比实际所需的多得多。
可以使用一系列的 `umount` 命令在每个步骤中卸载不需要的挂载点。但有更好的解决方案：不可克隆的挂载点在这里很有用。

步骤1：
假设根目录树只有两个目录，其中包含一个 `vfsmount`：

```
    root
   /    \
  tmp    usr
```

如何在 `/root/tmp` 下的多个位置设置相同的树结构？

步骤2：
```
mount --bind /root/tmp /root/tmp
mount --make-rshared /root
mount --make-unbindable /root/tmp
mkdir -p /tmp/m1
mount --rbind /root /tmp/m1
```

新的树现在看起来像这样：
```
    root
   /    \
  tmp    usr
 /
m1
/  \
tmp  usr
```

步骤3：
```
mkdir -p /tmp/m2
mount --rbind /root /tmp/m2
```

新的树现在看起来像这样：
```
    root
   /    \
  tmp    usr
 /   \
m1     m2
/  \     / \
tmp  usr tmp usr
```

步骤4：
```
mkdir -p /tmp/m3
mount --rbind /root /tmp/m3
```

新的树现在看起来像这样：
```
      root
     /     \
    tmp     usr
   /    \    \
m1     m2     m3
/  \     / \    /  \
tmp  usr tmp usr tmp usr
```

8）实现
--------------

8A）数据结构

引入了四个新字段到 `struct vfsmount`：

* `->mnt_share`
* `->mnt_slave_list`
* `->mnt_slave`
* `->mnt_master`

`->mnt_share`
链接所有从该 `vfsmount` 接收/发送传播事件的挂载点

`->mnt_slave_list`
链接所有该 `vfsmount` 向其传播的挂载点

`->mnt_slave`
链接所有其主 `vfsmount` 向其传播的所有从属挂载点

`->mnt_master`
指向该 `vfsmount` 从中接收传播的主 `vfsmount`

`->mnt_flags`
增加两个标志以指示 `vfsmount` 的传播状态。`MNT_SHARE` 表示该 `vfsmount` 是共享的。`MNT_UNCLONABLE` 表示该 `vfsmount` 不能被复制

所有同辈组中的共享 `vfsmount` 通过 `->mnt_share` 形成循环列表

所有具有相同 `->mnt_master` 的 `vfsmount` 形成一个循环列表，该列表锚定在 `->mnt_master->mnt_slave_list` 并通过 `->mnt_slave` 连接

`->mnt_master` 可以指向主同辈组中的任意（且可能是不同的）成员。要找到同辈组的所有直接从属，需要遍历其成员的所有 `->mnt_slave_list`。
概念上，它只是一个单一的集合 —— 在各个列表中的分布不会影响传播或操作对传播树的修改。
所有处于同一对等组中的vfsmount具有相同的->mnt_master。如果它非空，则它们形成从属列表的一个连续（有序）片段。
一个示例传播树如下图所示：
[注意：虽然看起来像一片森林，但如果我们把所有的共享挂载视为一个名为'pnode'的概念实体，它就变成了一个树]：

		A <--> B <--> C <---> D
	       /|\	      /|      |\
	      / F G	     J K      H I
	     /
	    E<-->K
	   /|\
		  M L N

在上图中，A、B、C和D都是共享的，并且相互之间传播。'A'有3个从属挂载'E'、'F'和'G'；'C'有两个从属挂载'J'和'K'；'D'有两个从属挂载'H'和'I'。
'E'也与'K'共享，并且它们相互之间传播。'K'有3个从属挂载'M'、'L'和'N'。

A的->mnt_share链接到'B'、'C'和'D'的->mnt_share。

A的->mnt_slave_list链接到'E'、'K'、'F'和'G'的->mnt_slave。

E的->mnt_share链接到K的->mnt_share。

'E'、'K'、'F'和'G'的->mnt_master指向A的struct vfsmount。

'M'、'L'和'N'的->mnt_master指向K的struct vfsmount。

K的->mnt_slave_list链接到'M'、'L'和'N'的->mnt_slave。

C的->mnt_slave_list链接到'J'和'K'的->mnt_slave。

J和K的->mnt_master指向C的struct vfsmount。

最后，D的->mnt_slave_list链接到'H'和'I'的->mnt_slave。

'H'和'I'的->mnt_master指向D的struct vfsmount。
注意：传播树与挂载树是正交的。
8B 锁定：

->mnt_share、->mnt_slave、->mnt_slave_list、->mnt_master由namespace_sem保护（修改时独占，读取时共享）
通常我们通过vfsmount_lock来序列化->mnt_flags的修改。
有两个例外：do_add_mount()和clone_mnt()
前者修改的是尚未在任何共享数据结构中可见的vfsmount。
后者持有 `namespace_sem`，而对 `vfsmount` 的所有引用都在无法在没有 `namespace_sem` 的情况下遍历的列表中。

8C 算法：

实现的核心在于绑定（rbind）/移动（move）操作。
整个算法将操作分为三个阶段：（参见 `attach_recursive_mnt()` 和 `propagate_mnt()`）

1. 准备阶段
2. 提交阶段
3. 中止阶段

准备阶段：

对于源树中的每个挂载点：

   a) 创建必要的挂载树数量，以便将其附加到接收来自目标挂载点传播的所有挂载点上。
   b) 不要将任何树附加到其目标。但是记录下它的 `->mnt_parent` 和 `->mnt_mountpoint`。
   c) 将所有新挂载点链接起来形成一个与目标挂载点传播树相同的传播树。

如果这个阶段成功，则应该有 `n` 个新的传播树；其中 `n` 是源树中挂载点的数量。进入提交阶段。

此外，还应该有 `m` 个新的挂载树，其中 `m` 是目标挂载点传播到的挂载点的数量。
如果有任何内存分配失败，则进入中止阶段。
提交阶段  
将每个挂载树附接到其对应的挂载目标

中止阶段  
删除所有新创建的树

.. 注意::
      所有与传播相关的功能都位于文件 pnode.c 中


------------------------------------------------------------------------

版本 0.1  （创建初始文档，Ram Pai linuxram@us.ibm.com）

版本 0.2  （采纳了 Al Viro 的意见）
