路径遍历和名称查找锁定
====================================

路径解析是指通过执行路径遍历来找到与路径名字符串对应的目录项（dentry）。通常，对于每个 open()、stat() 等系统调用，都会解析路径名。路径是通过从已知目录项（例如根或当前工作目录）开始遍历命名空间树，并查找该目录项的子目录项，其名称为路径字符串中的下一个组件。然后重复这个查找过程，直到找到最后一个元素。

由于这是多用户环境和 Web 服务器等应用场景中频繁的操作，因此优化这段代码非常重要。

路径遍历同步历史：
在 2.5.10 版本之前，dcache_lock 在 d_lookup（dcache 哈希查找）中被获取，因此在路径查找的每个组件期间都会获取锁。自 2.5.10 版本以来，快速遍历算法改变了这一点，通过在开始时持有 dcache_lock 并尽可能多地遍历缓存的路径组件目录项。这显著减少了获取 dcache_lock 的次数。然而，这也显著增加了锁的持有时间，并影响了大型 SMP 机器上的性能。

自 2.5.62 内核版本起，dcache 开始使用一种新的锁定模型，利用 RCU 使 dcache 查找无锁化。
所有上述算法都需要对查找的目录项进行加锁并增加引用计数，以便作为遍历下一个路径元素的基础。这既低效又不可扩展。它低效是因为每个目录项元素所需的锁和原子操作会减慢速度。它不可扩展是因为许多并行应用程序在进行路径遍历时倾向于从一个共同的目录项（通常是根 "/" 或当前工作目录）开始。因此，这些常见路径元素上的争用会导致锁和缓存行排队。

自 2.6.38 版本起，RCU 被用来使整个路径遍历（包括 dcache 查找）的大部分过程完全“无写入”（即无锁、无原子操作、甚至无需向常见目录项的缓存行写入）。这被称为“rcu-walk”路径遍历。

路径遍历概述
=====================

一个名称字符串指定了一个起点（根目录、当前工作目录、文件描述符相对）以及一系列元素（目录项名称），它们共同指向命名空间中的一个路径。路径表示为一个（目录项，vfsmount）元组。名称元素是由 '/' 分隔的子字符串。

名称查找的目标是找到一个名称字符串所指的特定路径（通常是最后一个元素或最后一个元素的父目录）。这是通过将名称的起点（我们事先知道的——例如当前进程的工作目录或根目录）作为查找的第一个父目录。然后对于每个后续的名称元素，查找当前父目录的具有给定名称的子目录项，并如果这不是所需条目，则将其作为下一次查找的父目录。

当然，父目录必须是一个目录，并且我们必须对该父目录节点有适当的权限才能进入它。
将子节点转换为父节点以进行下一次查找需要更多的检查和程序。符号链接（Symlinks）基本上是在名称字符串中用符号链接名替换目标名，并且需要一些递归路径遍历。挂载点必须被跟踪进入（从而改变后续路径元素所指向的vfsmount），从挂载点路径切换到特定已挂载vfsmount的根目录。这些行为根据确切的路径遍历标志有所不同。

路径遍历大致需要完成以下几个特定任务：
- 找到遍历的起点；
- 对inode执行权限和有效性检查；
- 在dcache哈希表中对(父节点，名称元素)元组进行查找；
- 遍历挂载点；
- 遍历符号链接；
- 按需查找和创建路径中缺失的部分

安全无存储查找的dcache哈希表
============================================

dcache名称查找
------------------
为了查找一个dcache中的(parent, name)元组，我们对该元组进行哈希运算，并使用该哈希值选择dcache-hash表中的一个桶。然后遍历该桶中的条目列表，并对每个条目与我们的(parent, name)元组进行全面比较。
哈希列表受RCU保护，因此列表遍历不会与并发更新（插入、删除哈希中的条目）同步。这是标准的RCU列表应用，除了重命名操作，下面将详细说明。
dentry的父节点和名称成员、其在dcache哈希表中的成员资格以及其inode由每个dentry的d_lock自旋锁保护。在验证字段时获取dentry的引用，这稳定了其d_inode指针和实际inode。这样就为我们提供了稳定的点来执行下一步路径遍历。
这些成员还受到d_seq seqlock的保护，尽管这提供的是只读保护，并且结果不具备持久性，因此在使用d_seq进行同步时需要小心（参见基于seqcount的查找）

重命名
-------
回到重命名的情况。在通常的RCU保护列表中，对对象唯一可能的操作是插入，然后最终从列表中移除。直到RCU宽限期完成后，该对象才可能被重用。
这确保了RCU列表遍历原语可以在对象上无问题地运行（详见RCU文档的工作原理）。
然而当一个dentry被重命名时，其哈希值可能会改变，需要将其移动到新的哈希列表中。分配并插入一个新的别名将是昂贵且对目录dentry来说也存在问题的。在移除dentry后等待一个宽限期再将其插入新哈希桶之前，延迟会过高。因此所做的操作是立即将dentry插入到新的列表中。
然而，在未等待宽限期的情况下更新dentry的列表指针使其指向新列表中的对象，可能导致并发RCU查找从旧列表转向新的（不正确）列表，并错过列表中剩余的dentry。
走错目录列表本身没有根本性的问题，因为目录项（dentry）比较永远不会匹配。但是错过一个匹配的目录项是致命的。因此使用了一个序列锁（seqlock）来检测重命名是否发生，从而可以重新进行查找。
1      2      3
        +---+  +---+  +---+
hlist-->| N-+->| N-+->| N-+->
head <--+-P |<-+-P |<-+-P |
        +---+  +---+  +---+

目录项2的重命名可能需要将其从上述列表中删除，并插入到一个新的列表中。删除2后，列表如下所示：
1             3
        +---+         +---+     （不用担心，较长的指针不会对现代CPU造成可测量的性能开销）
hlist-->| N-+-------->| N-+->
head <--+-P |<--------+-P |
        +---+         +---+
          ^      2      ^
          |    +---+    |
          |    | N-+----+
          +----+-P |
               +---+

这是一个标准的RCU列表删除操作，它保留了被删除对象的指针，因此当前正在查看对象2的并发列表遍历器在遍历下一个对象时会正确地继续到对象3。
然而，在将对象2插入到新列表时，我们得到以下结果：

         1             3
        +---+         +---+
hlist-->| N-+-------->| N-+->
head <--+-P |<--------+-P |
        +---+         +---+
                 2
               +---+
               | N-+---->
          <----+-P |
               +---+

由于我们没有等待优雅期，可能存在一个并发查找仍在2处。现在当它跟随2的“next”指针时，它会进入另一个列表而从未检查过对象3。

一个相关但明显不同的问题是重命名原子性与查找操作的关系。如果一个文件从“A”重命名为“B”，查找必须只能找到“A”或“B”。因此，如果查找“A”返回NULL，则随后查找“B”必须成功（注意相反的情况不成立）。
在从旧哈希列表删除目录项并将其插入新哈希列表之间，查找可能会发现既没有“A”也没有“B”匹配该目录项。同样的重命名序列锁也用于以类似的方式处理这种竞争情况，通过重试负查找结果来解决正在进行中的重命名问题。

基于序列计数的查找
----------------------
在引用计数（refcount）为基础的目录缓存（dcache）查找中，使用`d_lock`来串行化对目录项的访问，在比较其名称和父目录并获取引用计数时稳定该目录项（引用计数然后提供了一个稳定的起点，用于开始路径遍历的下一部分）。
如上所述，我们希望在路径遍历时不需要锁定或获取中间目录项的引用计数。为此，每个目录项使用一个序列锁（d_seq）来获取目录项的“一致快照”（其名称、父目录和inode）。然后使用该快照开始路径遍历的下一部分。在加载`d_seq`下的快照时，必须注意预先加载成员，并使用这些指针而不是稍后从目录项重新加载（否则会出现有趣的情况，例如名称被取消链接后`d_inode`变为NULL）。
同样重要的是避免执行任何破坏性操作（基本上：不对共享数据进行非原子写入），并在完成操作时重新检查序列计数。如果序列计数不匹配，则重试或中止。
避免执行破坏性或更改操作意味着我们可以轻松地从失败中回退。
这意味着，只要调用者持有 RCU 锁以防止 dentry 对象消失，就可以执行基于 seqcount 的查找，而不会增加 dentry 的引用计数或以任何方式写入 dentry。返回的 dentry 可用于后续操作，前提是该操作完成后重新检查 d_seq。

inode 也是通过 RCU 释放的，因此可以查询 seqcount 查找得到的 dentry 的 inode 来获取权限。

有了这两部分拼图，我们可以在不加锁或不增加 dentry 元素引用计数的情况下进行路径查找。

### RCU-walk 路径遍历设计

路径遍历代码现在有两种模式：ref-walk 和 rcu-walk。ref-walk 是传统的[*] 进行 dcache 查找的方法，使用 d_lock 来序列化并发修改 dentry 并增加其引用计数。ref-walk 简单明了，并且在路径遍历过程中可能会休眠、加锁等。rcu-walk 使用基于 seqcount 的 dentry 查找，可以在不向 dentry 或 inode 中存储任何数据的情况下查找中间元素。rcu-walk 不能应用于所有情况，例如，如果文件系统必须休眠或执行非平凡的操作，则需要将 rcu-walk 切换到 ref-walk 模式。

[*] 在 ref-walk 中仍然使用 RCU 进行 dentry 哈希查找，但不进行完整的路径遍历。

ref-walk 使用稳定的、带引用计数的“父”dentry 来遍历剩余的路径字符串，而 rcu-walk 使用由 d_seq 保护的快照。在查找此父快照的子节点时，我们首先打开子节点的 d_seq 关键区段，然后关闭父节点的 d_seq 关键区段。这样就形成了一个互锁的快照梯度来向下遍历。

```
proc 101
      /----------------\
     / comm:    "vi"    \
    /  fs.root: dentry0  \
    \  fs.cwd:  dentry2  /
     \                  /
      \----------------/
```

当 vi 想要打开 "/home/npiggin/test.c" (O_RDWR) 时，它将从当前->fs->root 开始，这是一个固定的 dentry。或者 "./test.c" 将从 cwd 开始；这两个名称在 proc101 的上下文中指向相同的路径。

```
dentry 0
    +---------------------+   rcu-walk 从这里开始，我们记录 d_seq，检查 inode 的权限，然后查找下一个路径元素 "home"...
    | name:    "/"        |
    | inode:   10         |
| children:"home", ...|
    +---------------------+

              |
     dentry 1 V
    +---------------------+   ... 这样我们来到这里。我们通过哈希查找找到 dentry1，然后记录 d_seq 并比较名称字符串和父指针。当我们匹配时，
    | name:    "home"     |   我们重新检查 dentry0 的 d_seq。然后我们检查 inode 并查找下一个元素。
    | inode:   678        |
    | children:"npiggin"  |
    +---------------------+

|
     dentry2  V
    +---------------------+   注意：如果 dentry0 现在被修改了，查找不一定无效，所以我们只需要保留一个父节点用于 d_seq 验证，祖父母节点可以被忘记。
    | name:    "npiggin"  |
    | inode:   543        |
    | children:"a.c", ... |
    +---------------------+
```
+---------------------+
              |
     dentry3  V
    +---------------------+   在这一点上，我们已经有了目标 dentry
| 名称:    "a.c"      |   接下来我们获取它的 d_lock，并验证这个
    | inode:   14221      |   dentry 的 d_seq。如果检查通过，我们可以增加
    | 子节点:NULL       |   它的引用计数，因为我们持有 d_lock
+---------------------+

在rcu-walk模式下通过获取其 d_lock、重新检查其 d_seq 并随后增加其引用计数来获取 dentry 的引用计数被称为“释放 rcu”或从 rcu-walk 模式进入 ref-walk 模式。这在某种程度上有点像纸牌屋。如果父快照的 seqcount 检查失败，纸牌屋就会倒塌，因为我们已经关闭了祖父节点上的 d_seq 区段，所以我们没有剩下任何可以依赖的东西。在这种情况下，路径遍历必须完全重启（我们在 ref-walk 模式中进行重启以避免活锁）。完全重启的成本很高，但幸运的是这种情况非常罕见。
当我们到达需要睡眠或文件系统回调需要 ref-walk 的点时，我们不会重启遍历，而是尝试在最后一个已知良好的 dentry 上释放 rcu。在这些情况下避免 ref-walk 中的完全重启对于性能和可扩展性至关重要，因为创建和删除操作并不少见。
rcu-walk 的详细设计如下：
* 设置 nd->flags 中的 LOOKUP_RCU，以此区分 rcu-walk 和 ref-walk
* 获取整个路径遍历的 RCU 锁，从获取起始路径（例如根目录/当前工作目录/文件描述符路径）开始。因此现在不需要 dentry 引用计数来保证 dentry 的持久性
* 在注销文件系统时调用 synchronize_rcu，以便我们可以在 rcu-walk 中访问 d_ops 和 i_ops
* 同样获取整个路径遍历的 vfsmount 锁。因此现在不需要 mnt 引用计数来保证持久性。同时我们可以自由地执行挂载查找，并假设路径上下文中的 dentry 挂载点和挂载根是稳定的
* 每个 dentry 都有一个 seqlock 来保护 dentry 名称、父节点和 inode，这样我们可以原子加载这个元组，并且还可以检查其成员是否发生变化
* 目录项查找（基于父目录和候选字符串元组）在找到子目录后会重新检查父目录的序列，以防在路径遍历过程中父目录发生了变化。
* inode 也受到 RCU 保护，因此我们可以加载 d_inode 并在有限的情况下使用 inode。
* 可以在路径遍历时测试 i_mode、i_uid 和 i_gid 的执行权限。
* 可以加载 i_op。
* 当到达目标目录项时，在那里释放 RCU（即获取 d_lock，验证 d_seq，并增加引用计数）。
* 如果路径中的任何位置发生 seqlock 验证失败，则需要完全重启路径查找，并进入 ref-walk 模式。通常使用 -ECHILD（因为没有更好的错误码）来表示 RCU-walk 失败。
* 无法继续进行 RCU-walk 的情况包括：
  * 空目录项（即任何未缓存的路径元素）
  * 跟踪符号链接

最终可能可以实现跟踪符号链接时的 RCU-walk 意识。
未缓存的路径元素始终需要切换到 ref-walk 模式，至少因为需要获取 i_mutex 并分配对象。
最后说明：
“无存储”路径遍历实际上并不是完全无存储的。我们需要获取 vfsmount 锁和引用计数（这两个都可以做成每 CPU 的），我们还会对栈进行写入（这基本上是 CPU 局部的），并且在最终目录项上还需要获取锁并增加引用计数。
关键在于，尽可能地不对共享数据加锁或写入。结果是路径解析性能和可扩展性得到了显著提升。
有趣的数据统计
======================

下表列出了几种简单工作负载下的 RCU 查找统计数据（2s12c24t Westmere，Debian 非图形化系统）。Ungraceful 表示由于 d_seq 失败且需要重新查找整个路径而导致的 RCU 下降失败。其他情况是在最终元素之前的成功 RCU 下降，nodentry 表示缺少 dentry 的情况，revalidate 表示文件系统重新验证例程需要 RCU 下降的情况，permission 表示权限检查需要下降的情况，link 表示符号链接遍历需要下降的情况。

| RCU 查找 | 重启 | nodentry | link | revalidate | permission |
|---------|------|----------|------|------------|------------|
| 启动     | 47121 | 0        | 4624 | 1010       | 10283      | 7852     |
| dbench  | 25386793 | 0        | 6778659 (26.7%) | 55       | 549      | 1156     |
| kbuild  | 2696672  | 10       | 64442 (2.3%) | 108764 (4.0%) | 1      | 1590    |
| git diff | 39605  | 0        | 28     | 2         | 0          | 106     |
| vfstest | 24185492 | 4945     | 708725 (2.9%) | 1076136 (4.4%) | 0      | 2651   |

这表明失败的 RCU 路径查找（即需要完全重试 ref-walk 的那些）非常罕见。即使是专门用于并发执行重命名、创建目录、删除目录等操作以测试这类竞争条件的“vfstest”案例，也没有显示出大量的重试次数。

从 RCU 路径转换到 ref-walk 意味着我们遇到了一个需要获取引用计数的 dentry。这可能是因为我们已经到达了路径的目标位置，或者是因为我们在 RCU 路径模式下无法解决某个条件。理想情况下，我们只在到达目标 dentry 时才转换为 ref-walk，因此其他统计数据展示了在哪些情况下没有发生这种情况。

需要注意的是，由于 dentry 不存在而优雅地退出 RCU 路径模式并不一定意味着 RCU 路径方案的失败，因为路径中的某些元素可能已经在 RCU 路径模式下被遍历过了。离常用路径元素（如当前工作目录或根目录）越远，dentry 越不可能被争用。离常用路径元素越近，它们越有可能存在于 dentry 缓存中。

关于 dcache 锁定的论文和其他文档
==================================

1. 使用 RCU 扩展 dcache（[https://linuxjournal.com/article.php?sid=7124](https://linuxjournal.com/article.php?sid=7124)）
2. [http://lse.sourceforge.net/locking/dcache/dcache.html](http://lse.sourceforge.net/locking/dcache/dcache.html)

3. 本目录中的 `path-lookup.md` 文件
