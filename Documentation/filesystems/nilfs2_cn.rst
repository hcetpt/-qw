SPDX 许可声明标识符: GPL-2.0

======
NILFS2
======

NILFS2 是一种支持连续快照的日志结构文件系统（LFS）。除了整个文件系统的版本控制功能外，用户甚至可以恢复几秒钟前被误覆盖或破坏的文件。由于 NILFS2 能像传统的 LFS 一样保持一致性，因此可以在系统崩溃后实现快速恢复。
NILFS2 每隔几秒或在每次同步写入时创建多个检查点（除非没有变化）。用户可以选择在连续创建的检查点中重要的版本，并将它们转换为快照，直到这些快照被重新变回检查点。
在卷未满之前，快照的数量没有限制。每个快照可以与它的可写挂载同时作为一个只读文件系统进行挂载，这一特性对于在线备份非常方便。
用户空间工具包含在 nilfs-utils 包中，可以从以下下载页面获取。至少需要 "mkfs.nilfs2"、"mount.nilfs2"、"umount.nilfs2" 和 "nilfs_cleanerd"（也称为清理器或垃圾收集器）。关于这些工具的详细信息，请参阅包中包含的手册页。

:项目网页:    https://nilfs.sourceforge.io/
:下载页面:       https://nilfs.sourceforge.io/en/download.html
:邮件列表信息:     http://vger.kernel.org/vger-lists.html#linux-nilfs

注意事项
=======

NILFS2 目前不支持的功能包括：

- 文件访问时间记录（atime）
- 扩展属性
- POSIX 访问控制列表（ACLs）
- 配额
- 文件系统检查和修复工具（fsck）
- 碎片整理

挂载选项
=======

NILFS2 支持以下挂载选项：
(*) 表示默认值

======================= =======================================================
barrier(*)		启用/禁用写屏障的使用。这
nobarrier		要求 I/O 栈能够支持屏障，并且如果 nilfs 在写屏障操作时遇到错误，它会发出警告并再次禁用屏障
errors=continue		在文件系统错误时继续运行
errors=remount-ro(*)	在发生错误时将文件系统重新挂载为只读
errors=panic		在发生错误时触发系统崩溃并停止机器
cp=n			指定要挂载的快照的检查点编号。检查点和快照可以通过用户命令 lscp 列出。只有标记为快照的检查点才能使用此选项挂载。快照是只读的，因此必须同时指定只读挂载选项
order=relaxed(*)	应用松散顺序语义，在没有元数据更新的情况下允许修改的数据块写入磁盘。这种模式等同于 ext3 文件系统的有序数据模式，只是对数据块的更新仍然保持原子性。这将提高覆盖写入时的同步写入性能
======================= =======================================================
### 订单=严格
应用严格的顺序语义，保留所有文件操作的序列，包括数据块的覆盖。这意味着，在崩溃后的恢复文件系统中，不会发生事件的超越来保证顺序。

### 禁用恢复
禁用挂载时的文件系统恢复。对于只读挂载或快照，这会禁用设备上的所有写入访问。此选项在脏数据卷上进行读/写挂载时将失败。

### 抛弃
启用/禁用使用抛弃/TRIM命令。当释放块时，这些命令会被发送到底层的块设备。这对于SSD设备和稀疏/精简配置的逻辑单元号（LUN）非常有用。

### 不抛弃(*)
当释放块时，抛弃/TRIM命令被发送到底层块设备。这对于SSD设备和稀疏/精简配置的逻辑单元号（LUN）非常有用。

### I/O 控制

NILFS2有一些特定的功能可以通过系统调用接口由应用程序访问。下表列出了所有NILFS2特有的I/O控制命令：

### NILFS2特有的I/O控制命令表：

| I/O 控制                     | 描述                                                                 |
|------------------------------|----------------------------------------------------------------------|
| NILFS_IOCTL_CHANGE_CPMODE    | 改变给定检查点的状态，可以在检查点和快照状态之间切换。此I/O控制用于chcp和mkcp工具。|
| NILFS_IOCTL_DELETE_CHECKPOINT| 从NILFS2文件系统中删除检查点。此I/O控制用于rmcp工具。                  |
| NILFS_IOCTL_GET_CPINFO       | 返回请求的检查点信息。此I/O控制用于lscp工具和nilfs_cleanerd守护进程。   |
NILFS_IOCTL_GET_CPSTAT         返回检查点统计信息。此ioctl由lscp、rmcp工具及nilfs_cleanerd守护进程使用。
NILFS_IOCTL_GET_SUINFO         返回请求段的段使用信息。此ioctl在lssu、nilfs_resize工具及nilfs_cleanerd守护进程中使用。
NILFS_IOCTL_SET_SUINFO         修改请求段的段使用信息。此ioctl由nilfs_cleanerd守护进程使用，以跳过不必要的段清理操作，减少因冗余移动使用中的块而导致的性能损失或闪存设备磨损。
NILFS_IOCTL_GET_SUSTAT         返回段使用统计信息。此ioctl在lssu、nilfs_resize工具及nilfs_cleanerd守护进程中使用。
NILFS_IOCTL_GET_VINFO          返回虚拟块地址的信息。此ioctl由nilfs_cleanerd守护进程使用。
NILFS_IOCTL_GET_BDESCS         返回关于磁盘块号描述符的信息。此ioctl由nilfs_cleanerd守护进程使用。
NILFS_IOCTL_CLEAN_SEGMENTS     在用户空间请求参数的环境下执行垃圾回收操作。此ioctl由nilfs_cleanerd守护进程使用。
NILFS_IOCTL_SYNC               创建一个检查点。此ioctl在mkcp工具中使用。
NILFS_IOCTL_RESIZE             调整NILFS2卷大小。此ioctl由nilfs_resize工具使用。
NILFS_IOCTL_SET_ALLOC_RANGE 定义段的下限（以字节为单位）和上限（以字节为单位）。此ioctl由nilfs_resize工具使用。

============================== ===============================================

NILFS2 的用法
=============

要将nilfs2用作本地文件系统，只需执行以下操作：

```
# mkfs -t nilfs2 /dev/block_device
# mount -t nilfs2 /dev/block_device /dir
```

这还将通过挂载辅助程序（mount.nilfs2）调用清理程序。
检查点和快照由以下命令管理：
它们的手册页包含在上面提到的nilfs-utils包中。
====     ===========================================================
  lscp     列出检查点或快照
mkcp     创建一个检查点或快照
chcp     将现有的检查点更改为快照或反之亦然
rmcp     使指定的检查点失效
====     ===========================================================

要挂载一个快照：

```
# mount -t nilfs2 -r -o cp=<cno> /dev/block_device /snap_dir
```

其中 `<cno>` 是快照的检查点编号。
要卸载NILFS2的挂载点或快照，只需执行：

```
# umount /dir
```

然后，卸载辅助程序（umount.nilfs2）会自动关闭清理守护进程。
磁盘格式
===========

一个nilfs2卷除了超级块（SB）和第0段之外，被均分为多个段。一个段是日志的容器。每个日志由汇总信息块、负载块以及一个可选的超级根块（SR）组成：

```
   ______________________________________________________
  | |SB| | Segment | Segment | Segment | ... | Segment | |
  |_|__|_|____0____|____1____|____2____|_____|____N____|_|
  0 +1K +4K       +8M       +16M      +24M  +(8MB x N)
       .             .            （典型4KB块偏移）
    .
.______________________
| log | log |... | log |
  |__1__|__2__|____|__m__|
        .
.
.
.______________________________
| Summary | Payload blocks  |SR|
  |_blocks__|_________________|__|
```

负载块按文件组织，并且每个文件由数据块和B树节点块组成：

```
    |<---       File-A        --->|<---       File-B        --->|
   _______________________________________________________________
    | Data blocks | B-tree blocks | Data blocks | B-tree blocks | ..
_|_____________|_______________|_____________|_______________|_
```

由于日志中只写入修改过的块，因此可能存在没有数据块或B树节点块的文件。块的组织结构记录在汇总信息块中，这些块包含一个头部结构（nilfs_segment_summary）、每个文件的结构（nilfs_finfo）以及每个块的结构（nilfs_binfo）：

```
  _________________________________________________________________________
 | Summary | finfo | binfo | ... | binfo | finfo | binfo | ... | binfo |..
|_blocks__|___A___|_(A,1)_|_____|(A,Na)_|___B___|_(B,1)_|_____|(B,Nb)_|___
```

日志包括普通文件、目录文件、符号链接文件以及若干元数据文件。元数据文件用于维护文件系统的元数据。当前版本的NILFS2使用以下元数据文件：

1) 索引节点文件（ifile） —— 存储磁盘上的索引节点
2) 检查点文件（cpfile） —— 存储检查点
3) 段使用文件（sufile） —— 存储段的分配状态
4) 数据地址转换文件（DAT） —— 将虚拟块号映射到常规块号。此文件用于使磁盘上的块可重定位
以下图示展示了一个典型的日志组织结构：

```
_____________________________________________________________________________
| 摘要 | 普通文件 | 文件  | ... | ifile | cpfile | sufile | DAT | SR |
|_blocks__|_或目录_|_______|_____|_______|________|________|_____|__|
```

为了跨越段边界，这个文件序列可能会被拆分成多个日志。这些日志在逻辑上被视为一个整体的日志，其边界由段摘要中的标志标记。nilfs2 的恢复代码会查看这些边界信息以确保更新的原子性。
超级根块会在每个检查点插入。它包含了三个特殊的inode：DAT、cpfile和sufile的inode。普通文件、目录、符号链接和其他特殊文件的inode包含在ifile中。ifile自身的inode包含在对应的检查点条目中。因此，NILFS2文件之间的层次关系如下所示：

```
超级块 (SB)
    |
    v
超级根块（最新cno=xx）
   |-- DAT
   |-- sufile
   `-- cpfile
           |-- ifile (cno=c1)
           |-- ifile (cno=c2) ---- file (ino=i1)
           :        :          |-- file (ino=i2)
           `-- ifile (cno=xx)  |-- file (ino=i3)
                               :        :
                               `-- file (ino=yy)
                                 （普通文件、目录或符号链接）
```

关于每个文件的具体格式，请参见位于`include/uapi/linux`目录下的`nilfs2_ondisk.h`文件。
对于NILFS2的设计，我们没有任何专利或其他知识产权保护。允许复制设计，希望其他操作系统能够共享（挂载、读取、写入等）这种格式存储的数据。
