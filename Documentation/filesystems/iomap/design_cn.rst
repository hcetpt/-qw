SPDX 许可证标识符: GPL-2.0
.. _iomap_design:

.

一些笔记以保持作者的理智：
        请尝试在单独的行上开始句子，以便在 diff 中句子更改不会导致颜色混杂
标题装饰在 sphinx.rst 中有文档说明
==============
库设计
==============

.. contents:: 目录
   :local:

介绍
============

iomap 是一个用于处理常见文件操作的文件系统库。
该库有两个层次：

1. 一个较低的层次，提供遍历文件偏移范围的迭代器
    这一层试图从文件系统获取每个文件范围到存储的映射，但存储信息不一定是必需的。
2. 一个较高的层次，基于较低层次迭代器提供的空间映射进行操作
    迭代可能涉及将文件的逻辑偏移范围映射到物理范围，但存储层信息不一定必需，例如，在遍历缓存文件信息时。

该库提供了多种 API 来实现文件操作，如：

 * 页面缓存读取和写入
 * 将 Folio 写入故障发送到页面缓存
 * 脏页回写
 * 直接 I/O 读取和写入
 * fsdax I/O 读取、写入、加载和存储
 * FIEMAP
 * lseek 的 `SEEK_DATA` 和 `SEEK_HOLE`
 * 交换文件激活

这个库起源于 XFS 曾经使用的一个文件 I/O 路径；现在已经扩展为覆盖其他多个操作。
谁应该阅读本文？
=====================

本文的目标读者是文件系统、存储和页面缓存程序员及代码审查者。
如果你正在处理 PCI、机器架构或设备驱动程序，你很可能找错了地方。

这有何改进？
==============

与经典的 Linux I/O 模型不同，后者将文件 I/O 分割成小单位（通常是内存页或块），并基于这些单位查找空间映射；iomap 模型则请求文件系统为特定的文件操作创建尽可能大的空间映射，并在此基础上启动操作。这种策略提高了文件系统对正在进行的操作大小的可见性，使其能够在可能的情况下通过更大的空间分配来对抗碎片化。更大的空间映射通过将映射函数调用的成本分摊到更大数量的数据上来提高运行时性能。从高层次上看，一个 iomap 操作如下所示：

1. 对于操作范围内的每个字节...
    1. 通过 `->iomap_begin` 获取空间映射
    
    2. 对于每个子工作单元...
        1. 必要时重新验证映射并返回步骤 (1)
    
    到目前为止，只有页缓存操作需要这样做。
2. 执行工作
    1. 增加操作游标
    
    2. 必要时通过 `->iomap_end` 释放映射

下面将详细讨论每个 iomap 操作。
这个库之前由一篇 [LWN 文章](https://lwn.net/Articles/935934/) 和一个 [KernelNewbies 页面](https://kernelnewbies.org/KernelProjects/iomap) 覆盖过。
本文档的目标是简要讨论iomap的设计和功能，随后提供一个更详细的iomap接口目录。
如果您对iomap进行了更改，请更新此设计文档。

文件范围迭代器
===============

定义
----

* **buffer head**：旧缓冲区缓存的碎片
* **``fsblock``**：文件的块大小，也称为``i_blocksize``
* **``i_rwsem``**：VFS中的``struct inode``读写信号量
进程以共享模式持有此信号量来读取文件状态和内容
某些文件系统可能允许在写入时使用共享模式
进程通常以独占模式持有此信号量来修改文件状态和内容
* **``invalidate_lock``**：页缓存中的``struct address_space``读写信号量，用于保护支持在EOF下方打孔删除页的文件系统中页的插入和移除
希望插入页的进程必须以共享模式持有此锁以防止页被移除，尽管并发插入是允许的
希望移除页表项（folios）的进程必须以独占模式持有此锁，以防止插入操作。
并发移除操作是不允许的。
* ``dax_read_lock``：这是 DAX 采用的 RCU 读锁，用于防止设备预关机钩子在其他线程释放资源之前返回。
* **文件系统映射锁**：这个同步原语属于文件系统内部，必须在采样映射数据时保护文件映射数据不受更新影响。
文件系统作者必须确定这种协调应该如何进行；它不一定是一个实际的锁。
* **iomap 内部操作锁**：这是指在持有映射时 iomap 函数所采用的同步原语的一个通用术语。
一个具体的例子是在读写页缓存时获取页表项锁。
* **纯覆盖**：这是一种写入操作，不需要在提交或完成过程中执行任何元数据或清零操作。
这意味着文件系统必须已经在磁盘上分配了空间作为 ``IOMAP_MAPPED``，并且文件系统对 I/O 对齐或大小不应施加任何限制。
唯一对 I/O 对齐有约束的是设备级别的（最小 I/O 大小和对齐，通常是扇区大小）。
文件系统通过以下结构与 iomap 迭代器通信，描述文件字节范围到存储设备字节范围的映射：

```c
struct iomap {
    u64                 addr;        // 映射地址
    loff_t              offset;      // 文件偏移量（以字节为单位）
    u64                 length;      // 范围长度（以字节为单位）
    u16                 type;        // 空间映射类型
    u16                 flags;       // 标志
    struct block_device *bdev;       // 块设备指针
    struct dax_device   *dax_dev;    // DAX 设备指针
    void                *inline_data;// 内联数据指针
    void                *private;    // 私有数据指针
    const struct iomap_folio_ops *folio_ops;  // folio 操作指针
    u64                 validity_cookie;  // 有效性校验值
};
```

字段说明如下：

- `offset` 和 `length` 描述了此映射所覆盖的文件偏移量范围（以字节为单位）。
  这些字段必须始终由文件系统设置。

- `type` 描述空间映射的类型：

  - **IOMAP_HOLE**：没有分配任何存储空间。
    此类型在响应 `IOMAP_WRITE` 操作时绝不能返回，因为写入操作必须分配和映射空间，并返回该映射。
    `addr` 字段必须设置为 `IOMAP_NULL_ADDR`。iomap 不支持向空洞写入（无论是通过页缓存还是直接 I/O）。

  - **IOMAP_DELALLOC**：承诺在稍后的时间分配空间（“延迟分配”）。
    如果文件系统在此处返回 IOMAP_F_NEW 并且写入失败，则 `->iomap_end` 函数必须删除该预留。
    `addr` 字段必须设置为 `IOMAP_NULL_ADDR`。

  - **IOMAP_MAPPED**：文件范围映射到存储设备上的特定空间。
该设备通过 ``bdev`` 或 ``dax_dev`` 返回。
设备地址（以字节为单位）通过 ``addr`` 返回。

* **IOMAP_UNWRITTEN**：文件范围映射到存储设备上的特定空间，但该空间尚未被初始化。
该设备通过 ``bdev`` 或 ``dax_dev`` 返回。
设备地址（以字节为单位）通过 ``addr`` 返回。
对于这种类型的映射，读取操作会返回零值给调用者。
对于写入或回写操作，ioend 应该将映射更新为 MAPPED。
更多详细信息请参阅关于 ioend 的部分。
* **IOMAP_INLINE**：文件范围映射到由 ``inline_data`` 指定的内存缓冲区。
对于写入操作，``->iomap_end`` 函数据推测负责持久化数据。
```addr`` 字段必须设置为 ``IOMAP_NULL_ADDR``

* ``flags`` 描述了空间映射的状态
这些标志应该在 ``->iomap_begin`` 中由文件系统设置：

   * **IOMAP_F_NEW**：映射下的空间是新分配的
未被写入的区域必须清零
如果写入失败并且映射是一个空间预留，则必须删除该预留
* **IOMAP_F_DIRTY**：inode 将包含访问任何已写入数据所需的未提交元数据
需要调用 fdatasync 将这些更改提交到持久存储
这需要考虑到可能在 I/O 完成时发生的元数据更改，例如直接 I/O 引起的文件大小更新
* **IOMAP_F_SHARED**：映射下的空间是共享的
为了防止破坏其他文件数据，需要使用写时复制机制
```
* **IOMAP_F_BUFFER_HEAD**：此映射需要在页缓存操作中使用缓冲区头
不再增加对此的使用
* **IOMAP_F_MERGED**：多个连续块映射被合并为单个映射
这仅对 FIEMAP 有用
* **IOMAP_F_XATTR**：该映射用于扩展属性数据，而非普通文件数据
这仅对 FIEMAP 有用
* **IOMAP_F_PRIVATE**：从这个值开始，高位可以由文件系统根据自身目的设置
这些标志可以在文件操作期间由 iomap 自身设置
如果文件系统需要观察这些标志，则应提供一个 `->iomap_end` 函数：

   * **IOMAP_F_SIZE_CHANGED**：由于使用了此映射，文件大小发生了变化
* **IOMAP_F_STALE**：发现该映射已过时
iomap 会调用 ``->iomap_end`` 来结束这个映射，然后调用 ``->iomap_begin`` 来获取一个新的映射。
目前，这些标志仅由页面缓存操作设置。
* ``addr`` 描述设备地址，以字节为单位。
* ``bdev`` 描述该映射对应的块设备。
这仅需要在已映射或未写入的操作中设置。
* ``dax_dev`` 描述该映射对应的 DAX 设备。
这仅需要在已映射或未写入的操作中设置，并且仅适用于 fsdax 操作。
* ``inline_data`` 指向用于涉及 ``IOMAP_INLINE`` 映射的 I/O 的内存缓冲区。
对于其他所有映射类型，此值将被忽略。
* ``private`` 是指向 `文件系统私有信息 <https://lore.kernel.org/all/20180619164137.13720-7-hch@lst.de/>`_ 的指针。
此值将被原样传递给 `->iomap_end`。

* `folio_ops` 将在关于页缓存操作的部分中进行介绍。
* `validity_cookie` 是文件系统设置的一个用于检测陈旧映射的神奇新鲜度值。
  对于页缓存操作，这是至关重要的，因为可能会发生缺页异常，这意味着在 `->iomap_begin` 和 `->iomap_end` 之间不应该持有文件系统锁。
  完全静态映射的文件系统无需设置这个值。
  只有页缓存操作会重新验证映射；详情请参阅关于 `iomap_valid` 的部分。

`struct iomap_ops`
----------------------

每个 iomap 函数都需要文件系统传递一个操作结构来获取映射（以及可选地释放映射）：

```c
struct iomap_ops {
    int (*iomap_begin)(struct inode *inode, loff_t pos, loff_t length,
                       unsigned flags, struct iomap *iomap,
                       struct iomap *srcmap);

    int (*iomap_end)(struct inode *inode, loff_t pos, loff_t length,
                     ssize_t written, unsigned flags,
                     struct iomap *iomap);
};
```

`->iomap_begin`
~~~~~~~~~~~~~~~~~

iomap 操作调用 `->iomap_begin` 来为文件 `inode` 中由 `pos` 和 `length` 指定的字节范围获取一个文件映射。
该映射应通过 `iomap` 指针返回。
映射必须至少覆盖提供的文件范围的第一个字节，但不需要覆盖整个请求的范围。
每个 iomap 操作都会通过 `flags` 参数描述所请求的操作。
``flags`` 的确切值将在下面的操作特定部分中详细说明。这些标志原则上可以普遍适用于 iomap 操作：

 * 当调用者希望对块存储执行文件 I/O 时，设置 ``IOMAP_DIRECT``。
 * 当调用者希望对类似内存的存储执行文件 I/O 时，设置 ``IOMAP_DAX``。
 * 当调用者希望尽可能避免任何会导致提交任务阻塞的操作时，设置 ``IOMAP_NOWAIT``。
   这与网络 API 中的 ``O_NONBLOCK`` 类似，其目的是让异步应用程序继续执行其他工作，而不是等待特定的不可用文件系统资源变得可用。

实现 ``IOMAP_NOWAIT`` 语义的文件系统需要使用 trylock 算法。
它们需要能够通过单个 iomap 映射来满足整个 I/O 请求范围。
它们需要避免同步读取或写入元数据。
它们需要避免阻塞内存分配。
它们需要避免等待事务预留以允许修改发生。
他们可能不应该分配新的空间，
等等。

如果文件系统开发者对任何特定的“`IOMAP_NOWAIT`”操作是否最终会阻塞有任何疑问，
那么他们应该尽早返回“-EAGAIN”，而不是开始操作并迫使提交任务阻塞。

“`IOMAP_NOWAIT`”通常代表“`IOCB_NOWAIT`”或“`RWF_NOWAIT`”设置。
如果有必要从设备上的另一个设备或地址范围读取现有文件内容，则文件系统应通过“`srcmap`”返回该信息。
只有页缓存（pagecache）和fsdax操作支持从一个映射读取并写入另一个映射。

`->iomap_end`
~~~~~~~~~~~~~~~

在操作完成后，如果存在`->iomap_end`函数，则会调用它来表示iomap已经完成了对映射的操作。
通常，实现会使用此函数来撤销在`->iomap_begin`中设置的任何上下文。
例如，写操作可能希望提交所操作字节的预留，并取消未操作的空间的预留。
如果没有触及任何字节，“`written`”可能为零。
``flags`` 将包含传递给 ``->iomap_begin`` 的相同值。
对于读取操作，iomap ops 不太可能需要提供此函数。
这两个函数在出错时应返回一个负的 errno 代码，在成功时返回零。

准备文件操作
=============

iomap 仅处理映射和 I/O 操作。
文件系统仍需调用 VFS 来检查输入参数和文件状态，然后才开始 I/O 操作。
它不处理获取文件系统冻结保护、更新时间戳、剥离权限或访问控制。

锁定层次结构
=============

iomap 要求文件系统提供自己的锁定模型。
就 iomap 而言，同步原语有三个类别：

* **上层** 原语由文件系统提供，用于协调对不同 iomap 操作的访问。
具体的原语取决于文件系统和操作，但通常是 VFS inode、页缓存失效或 folio 锁。
例如，文件系统可能会在调用 ``iomap_file_buffered_write`` 和 ``iomap_file_unshare`` 之前获取 ``i_rwsem``，以防止这两种文件操作相互覆盖。
页缓存回写可能会锁定一个页表项（folio），以防止其他线程在回写进行期间访问该页表项。
* 较低级别的原语由文件系统在 `->iomap_begin` 和 `->iomap_end` 函数中获取，以协调对文件空间映射信息的访问。
  在持有这个原语时，应填充 iomap 对象的字段。
  如果存在较高层次的同步原语，则在获取较低层次的同步原语时仍然保持该较高层次的原语。
  例如，XFS 在采样映射时会获取 `ILOCK_EXCL`，而 ext4 会获取 `i_data_sem`。
  拥有不可变映射信息的文件系统可能不需要在这里进行同步。
* 操作原语由 iomap 操作获取，以协调对其内部数据结构的访问。
  如果存在较高层次的同步原语，则在获取此原语时仍然保持该较高层次的原语。
  获取此原语时不持有较低层次的原语。
  例如，页缓存写操作将获取文件映射，然后获取并锁定一个页表项以复制新内容。
它还可能锁定内部文件状态对象以更新元数据。
具体的锁定要求取决于文件系统；对于某些操作，可以省略其中的一些锁。
所有进一步提到的锁定都是*建议*，而非强制规定。
每个文件系统作者必须自行确定其锁定策略。

错误和限制
===========

 * 不支持 fscrypt
* 不支持压缩
* 尚不支持 fsverity
* 对 IO 应该像在 XFS 中那样工作的假设过于强烈
* iomap 是否真的适用于非常规文件数据？

欢迎提交补丁！
