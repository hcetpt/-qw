SPDX 许可声明标识符: GPL-2.0

====
FUSE
====

定义
===========

用户空间文件系统:
  一个数据和元数据由普通用户空间进程提供的文件系统。可以通过内核接口正常访问该文件系统。
文件系统守护进程:
  提供文件系统数据和元数据的进程（或进程组）。
非特权挂载（或用户挂载）:
  由非特权（非root）用户挂载的用户空间文件系统。文件系统守护进程以挂载用户的权限运行。注意：这与/etc/fstab 中允许的带有"user"选项的挂载不同，这里不讨论后者。
文件系统连接:
  文件系统守护进程与内核之间的连接。此连接在守护进程终止或文件系统卸载之前一直存在。请注意，分离（或懒惰卸载）文件系统并不会中断连接，在这种情况下，它会一直存在直到最后一个对文件系统的引用被释放。
挂载所有者:
  进行挂载操作的用户。
用户:
  执行文件系统操作的用户。

什么是 FUSE？
=============

FUSE 是一个用户空间文件系统框架。它包括一个内核模块（fuse.ko）、一个用户空间库（libfuse.*）和一个挂载工具（fusermount）。
FUSE 最重要的功能之一是允许安全的非特权挂载。这为文件系统的使用开辟了新的可能性。一个很好的例子是 sshfs：使用 sftp 协议的安全网络文件系统。
用户空间库和工具可以从 FUSE 官方网站获取：[FUSE homepage](https://github.com/libfuse/)

文件系统类型
===============

传递给 mount(2) 的文件系统类型可以是以下之一：

    fuse
      这是挂载 FUSE 文件系统的常规方式。mount 系统调用的第一个参数可以包含任意字符串，内核不会对其进行解释。
fuseblk
文件系统基于块设备。挂载系统调用的第一个参数被解释为设备的名称。

挂载选项
==========

fd=N
  用于用户空间文件系统与内核之间通信的文件描述符。该文件描述符必须通过打开 FUSE 设备（如 '/dev/fuse'）来获取。
rootmode=M
  文件系统根目录的文件模式，以八进制表示。
user_id=N
  挂载所有者的数字用户 ID。
group_id=N
  挂载所有者的数字组 ID。
default_permissions
  默认情况下，FUSE 不检查文件访问权限，文件系统可以自由实现其访问策略或将其留给底层文件访问机制（例如在网络文件系统中）。此选项启用权限检查，根据文件模式限制访问。通常与 'allow_other' 挂载选项一起使用时有用。
allow_other
  此选项覆盖了限制文件访问仅限于挂载文件系统的用户的安全措施。默认情况下，只有 root 用户允许使用此选项，但可以通过一个（用户空间）配置选项取消此限制。
max_read=N
  使用此选项可以设置读取操作的最大大小，默认值是无限的。请注意，读取请求的大小无论如何都会限制在 32 个页面以内（在 i386 上为 128 KB）。
blksize=N
  设置文件系统的块大小，默认值为 512。此选项仅适用于 'fuseblk' 类型的挂载。
控制文件系统
=============

FUSE有一个控制文件系统，可以通过以下命令进行挂载：

```shell
mount -t fusectl none /sys/fs/fuse/connections
```

将其挂载在`/sys/fs/fuse/connections`目录下可保持与早期版本的向后兼容性。

在FUSE控制文件系统中，每个连接都有一个以唯一编号命名的目录。对于每个连接，在该目录内存在以下文件：

- `waiting`
  等待传输到用户空间或正在由文件系统守护进程处理的请求数量。如果没有文件系统活动且`waiting`不为零，则表明文件系统已挂起或死锁。
- `abort`
  向此文件写入任何内容将终止文件系统连接。这意味着所有等待中的请求将被终止，并对所有已终止和新的请求返回错误。

只有挂载点的所有者可以读取或写入这些文件。

中断文件系统操作
##################

如果发出FUSE文件系统请求的进程被中断，将会发生以下情况：

- 如果请求尚未发送到用户空间并且信号是致命的（SIGKILL或未处理的致命信号），则请求将被取消排队并立即返回。
- 如果请求尚未发送到用户空间并且信号不是致命的，则为该请求设置中断标志。当请求成功传输到用户空间且该标志已设置时，将排队一个INTERRUPT请求。
- 如果请求已经发送到用户空间，则排队一个INTERRUPT请求。

INTERRUPT请求优先于其他请求，因此用户空间文件系统将在处理其他请求之前接收到排队的INTERRUPT请求。

用户空间文件系统可以选择完全忽略INTERRUPT请求，或者通过向*原始*请求发送回复来处理它们，并将错误设置为EINTR。
也有可能在处理原始请求和其INTERRUPT请求之间存在竞争。有两种可能性：

  1. INTERRUPT请求在原始请求被处理之前被处理

  2. INTERRUPT请求在原始请求已被响应之后被处理

如果文件系统无法找到原始请求，它应该等待一段时间或一定数量的新请求到达后，然后用EAGAIN错误回复给INTERRUPT请求。在第1种情况下，INTERRUPT请求将重新排队。在第2种情况下，INTERRUPT响应将被忽略。

终止文件系统连接
==================

可能会遇到某些情况，文件系统没有响应。原因可能包括：

  a) 用户空间文件系统实现有误

  b) 网络连接断开

  c) 偶然的死锁

  d) 恶意死锁

（关于c）和d），请参阅后面的章节）

在这些情况下，终止与文件系统的连接可能是有用的。有几种方法可以做到这一点：

  - 终止文件系统守护进程。适用于a) 和 b) 的情况

  - 终止文件系统守护进程及其所有用户。适用于除某些恶意死锁外的所有情况

  - 使用强制卸载（umount -f）。适用于所有情况，但仅当文件系统仍然挂载时有效（尚未懒惰卸载）

  - 通过FUSE控制文件系统来终止文件系统。这是最强大的方法，总是有效

非特权挂载是如何工作的？
=====================

由于mount()系统调用是一个特权操作，因此需要一个辅助程序（fusermount），该程序以root权限运行。
提供非特权挂载的含义是，挂载者不能利用此功能危害系统。由此产生的明显要求包括：

 A) 挂载者不应能够通过已挂载的文件系统获得提升的权限

 B) 挂载者不应能够非法访问其他用户和超级用户的进程信息

 C) 挂载者不应能够导致其他用户或超级用户的进程出现不希望的行为

如何满足这些要求？
===================

A) 挂载者可以通过以下方式之一获得提升的权限：

    1. 创建包含设备文件的文件系统，然后打开这个设备

    2. 创建包含具有setuid或setgid属性的应用程序的文件系统，然后执行这个应用程序

解决办法是不允许打开设备文件，并在执行程序时忽略setuid和setgid位。为此，fusermount始终为非特权挂载添加"nosuid"和"nodev"选项。
B) 如果其他用户正在访问文件系统中的文件或目录，那么服务请求的文件系统守护进程可以记录操作的确切序列和时间。这些信息通常对挂载者是不可访问的，因此这被视为信息泄露。
这个问题的解决方案将在C)的第2点中介绍。
C) 挂载者可以通过多种方式导致其他用户的进程出现不希望的行为，例如：

     1) 在挂载者本来无法修改的文件或目录上挂载文件系统（或者只能进行有限的修改）
这个问题在fusermount中得到解决，通过检查挂载点的访问权限，并且只有当挂载者可以无限制地进行修改（对挂载点具有写入权限，并且挂载点不是“粘滞”目录）时才允许挂载。

     2) 即使解决了1)，挂载者仍然可以改变其他用户的进程行为：
i) 它可以使文件系统操作变慢或无限期延迟，从而对用户或整个系统造成拒绝服务攻击。例如，一个setuid应用程序锁定一个系统文件，然后访问挂载者的文件系统，可能导致该应用程序停止，从而使系统文件永远处于锁定状态。
ii) 它可以呈现无限长度的文件或目录，或无限深度的目录结构，可能导致系统进程消耗磁盘空间、内存或其他资源，再次造成拒绝服务攻击。
### 解决方案以及 B）是不允许进程访问文件系统，否则这些进程将无法被挂载所有者监控或操控。因为如果挂载所有者可以对一个进程进行 ptrace，那么它无需使用 FUSE 挂载就可以完成上述所有操作，因此可以使用与 ptrace 相同的标准来检查一个进程是否允许访问文件系统。

注意，*ptrace* 检查对于防止 C/2/i 并非严格必要，只要检查挂载所有者是否有足够的权限向访问文件系统的进程发送信号即可，因为 *SIGSTOP* 可以产生类似的效果。

我认为这些限制是不可接受的？

-------------------------------------------

如果系统管理员足够信任用户，或者可以通过其他措施确保系统进程永远不会进入非特权挂载，它可以以多种方式放宽最后一项限制：

  - 通过配置选项 'user_allow_other'。如果设置了这个配置选项，挂载用户可以添加 'allow_other' 挂载选项，从而禁用对其他用户进程的检查。
  用户命名空间与 'allow_other' 的交互是非直观的：通常受限于不能使用 'allow_other' 挂载的无特权用户可以在其有特权的用户命名空间中这样做。如果任何进程都可以访问这种 'allow_other' 挂载，这将赋予挂载用户在他们无特权的用户命名空间中操控进程的能力。出于这个原因，'allow_other' 限制了仅同一用户命名空间或其子命名空间中的用户的访问。
  - 通过模块选项 'allow_sys_admin_access'。如果设置了这个选项，超级用户的进程无论 'allow_other' 设置或挂载用户的用户命名空间如何，都对挂载具有不受限的访问权。

请注意，这两种放宽都会使系统暴露于潜在的信息泄露或 *DoS* 攻击，如前一节中的 B 和 C/2/i-ii 所述。

### 内核 - 用户空间接口

以下图示展示了在 FUSE 中执行文件系统操作（本例为 unlink）的过程：

```
|  "rm /mnt/fuse/file"               |  FUSE 文件系统守护进程
|                                    |
|                                    |  >sys_read()
|                                    |    >fuse_dev_read()
|                                    |      >request_wait()
|                                    |        [在 fc->waitq 上睡眠]
|                                    |
|  >sys_unlink()                     |
|    >fuse_unlink()                  |
|      [从 fc->unused_list 获取请求] |
|      >request_send()               |
|        [将请求排队到 fc->pending] |
|        [唤醒 fc->waitq]            |        [被唤醒]
|        >request_wait_answer()      |
|          [在 req->waitq 上睡眠]    |
|                                    |      <request_wait()
|                                    |      [从 fc->pending 移除请求]
|                                    |      [将请求复制到读缓冲区]
|                                    |      [将请求添加到 fc->processing]
|                                    |    <fuse_dev_read()
|                                    |  <sys_read()
|                                    |
|                                    |  [执行 unlink]
|                                    |
|                                    |  >sys_write()
|                                    |    >fuse_dev_write()
|                                    |      [在 fc->processing 中查找请求]
|                                    |      [从 fc->processing 移除]
|                                    |      [将写缓冲区复制到请求]
|          [被唤醒]                  |      [唤醒 req->waitq]
|                                    |    <fuse_dev_write()
|                                    |  <sys_write()
|        <request_wait_answer()      |
|      <request_send()               |
|      [将请求添加到 fc->unused_list]|
|    <fuse_unlink()                  |
|  <sys_unlink()                     |
```

.. note:: 上述描述大大简化了实际过程。

存在几种死锁 FUSE 文件系统的方式。由于我们谈论的是无特权用户空间程序，必须解决这些问题。

**场景 1 - 简单死锁**：
```
|  "rm /mnt/fuse/file"               |  FUSE 文件系统守护进程
|                                    |
|  >sys_unlink("/mnt/fuse/file")     |
|    [获取 "file" 的inode信号量]    |
|    >fuse_unlink()                  |
|      [在 req->waitq 上睡眠]        |
|                                    |  <sys_read()
|                                    |  >sys_unlink("/mnt/fuse/file")
|                                    |    [获取 "file" 的inode信号量]
|                                    |    * 死锁 *
```

解决方案是允许文件系统被中断。

**场景 2 - 复杂死锁**

这需要精心设计的文件系统。这是上述情况的一种变体，只是回调到文件系统的调用不是显式的，而是由页错误触发的：
```
|  自毁文件系统线程 1               |  自毁文件系统线程 2
|                                    |
|  [fd = open("/mnt/fuse/file")]     |  [请求正常服务]
|  [mmap fd 到 'addr']               |
|  [关闭 fd]                         |  [FLUSH 触发 'magic' 标志]
|  [从 addr 读取一个字节]            |
|    >do_page_fault()                |
|      [查找或创建页面]              |
|      [锁定页面]                    |
|      >fuse_readpage()              |
|         [排队 READ 请求]           |
|         [在 req->waitq 上睡眠]     |
|                                    |  [将读请求复制到缓冲区]
|                                    |  [在 addr 前创建回复头]
|                                    |  >sys_write(addr - headerlength)
|                                    |    >fuse_dev_write()
|                                    |      [在 fc->processing 中查找请求]
|                                    |      [从 fc->processing 移除]
|                                    |      [将写缓冲区复制到请求]
|                                    |        >do_page_fault()
|                                    |           [查找或创建页面]
|                                    |           [锁定页面]
|                                    |           * 死锁 *
```

解决方案基本上与上述相同。
一个额外的问题是，在将写缓冲区复制到请求的过程中，该请求不能被中断/中止。这是因为请求返回后，复制的目标地址可能不再有效。
为了解决这个问题，需要原子地进行复制，并在使用 get_user_pages() 将写缓冲区所属的页面进行错误处理时允许中止。'req->locked' 标志表示复制正在进行，中止操作会延迟到这个标志被清除时才执行。
