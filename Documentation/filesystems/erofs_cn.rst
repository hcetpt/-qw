SPDX 许可证标识符: GPL-2.0

======================================
EROFS - 增强型只读文件系统
======================================

概述
========

EROFS 文件系统代表增强型只读文件系统。它的目标是为各种只读用例提供一个通用的只读文件系统解决方案，而不仅仅是专注于存储空间的节省而不考虑运行时性能的副作用。它旨在满足灵活性、功能扩展性和用户友好性等方面的需求。除此之外，它仍然保持为一个简单的随机访问友好型高性能文件系统，以避免不必要的 I/O 放大和内存驻留开销。与类似的方法相比，它在以下场景中是一个更好的选择：

- 只读存储介质或

- 完全受信任的只读解决方案的一部分，这意味着它需要是不可变的，并且位对位地与官方金像（golden image）相同，这是出于安全或其他方面的考虑。

- 希望通过紧凑布局、透明文件压缩和直接访问来最小化额外存储空间并保证端到端性能，特别是对于那些内存有限的嵌入式设备和具有大量容器的高密度主机。

以下是 EROFS 的主要特点：

- 小端字节序的磁盘设计；

- 支持基于块的分布和基于文件的分布（通过 fscache）；

- 支持多个设备引用外部 blob，可用于容器镜像；

- 每个设备支持 32 位块地址，因此目前最多可以有 16 TiB 的地址空间（假设块大小为 4 KiB）；

- 两种 inode 布局以满足不同需求：

  =====================  ============  ======================================
                          紧凑型（v1）  扩展型（v2）
  =====================  ============  ======================================
  Inode 元数据大小       32 字节        64 字节
  最大文件大小           4 GiB         16 EiB（也受限于最大卷大小）
  最大 uid/gid 数量     65536         4294967296
  每个 inode 时间戳      不支持         支持（64 + 32 位时间戳）
  最大硬链接数量         65536         4294967296
  预留元数据             8 字节         18 字节
  =====================  ============  ======================================

- 支持扩展属性作为选项；

- 支持布隆过滤器以加速负面扩展属性查找；

- 使用扩展属性支持 POSIX.1e 访问控制列表（ACL）；

- 支持透明数据压缩作为选项：可以按文件使用 LZ4、MicroLZMA 和 DEFLATE 算法；此外，还支持原位解压缩以避免压缩缓冲区的跳跃和不必要的页面缓存抖动；

- 支持基于块的数据去重和滚动哈希压缩数据去重；

- 支持尾部打包内联相对于字节寻址的未对齐元数据或较小块大小的替代方案；

- 支持将尾部数据合并到特殊 inode 中作为片段；

- 支持大 folio 对于未压缩文件；

- 支持未压缩文件上的直接 I/O 以避免循环设备的双重缓存；

- 支持未压缩映像上的 FSDAX 以实现安全容器和 RAM 磁盘，从而消除不必要的页面缓存；

- 支持基于文件的按需加载与 Fscache 基础设施；

以下 Git 仓库提供了正在开发中的文件系统用户空间工具，如格式化工具（mkfs.erofs）、磁盘一致性及兼容性检查工具（fsck.erofs）以及调试工具（dump.erofs）：

- git://git.kernel.org/pub/scm/linux/kernel/git/xiang/erofs-utils.git

更多信息，请参阅文档网站：

- https://erofs.docs.kernel.org

欢迎报告错误和提交补丁，请发送至以下邮件列表：

- linux-erofs 邮件列表 <linux-erofs@lists.ozlabs.org>

挂载选项
=============

===================    =========================================================
(user_xattr) (no)       设置扩展用户属性。注意：如果选择了 CONFIG_EROFS_FS_XATTR，则默认启用 xattr。
(acl) (no)              设置 POSIX 访问控制列表。注意：如果选择了 CONFIG_EROFS_FS_POSIX_ACL，则默认启用 acl。
```cache_strategy=%s      选择从现在起用于缓存解压缩的策略：

		       ==========  =============================================
                         disabled  仅使用原地I/O解压缩；
                        readahead  缓存最后一个不完整压缩物理簇以供进一步读取。其余压缩物理簇仍进行原地I/O解压缩；
                       readaround  缓存不完整压缩物理簇两端的数据以供进一步读取。其余压缩物理簇仍进行原地I/O解压缩
==========  =============================================

dax={always,never}     使用直接访问（无页面缓存）。详见
                       文档文件系统/dax.rst
dax                    一个遗留选项，等同于 ``dax=always``
device=%s              指定一个附加设备的路径以供联合使用
fsid=%s                指定Fscache后端的文件系统映像ID
domain_id=%s           在fscache模式下指定一个域ID，以便具有相同blob的不同映像在给定的域ID下共享存储
===================    =========================================================

Sysfs条目
==========

已挂载的erofs文件系统的相关信息可以在/sys/fs/erofs中找到
每个已挂载的文件系统将在/sys/fs/erofs中有一个基于其设备名称的目录（例如，/sys/fs/erofs/sda）
（详见文档/ABI测试/sysfs-fs-erofs）

磁盘上的详细信息
=================

概述
-----
与其他只读文件系统不同，EROF文件卷设计得尽可能简单::

                                |-> 对齐到块大小
   ____________________________________________________________
  | |SB| | ... | 元数据 | ... | 数据 | 元数据 | ... | 数据 |
  |_|__|_|_____|__________|_____|______|__________|_____|______|
  0 +1K

所有数据区域应与块大小对齐，但元数据区域可能不对齐。目前所有元数据可以在两个不同的空间（视图）中观察到：

 1. 索引节点元数据空间

    每个有效的索引节点都应与一个索引节点槽对齐，这是一个固定值（32字节），设计时考虑了紧凑的索引节点大小
```
每个inode可以通过以下公式直接找到：
         inode偏移量 = meta_blkaddr * 块大小 + 32 * nid

    ::

                                 |-> 对齐到8字节
                                            |-> 紧接着
     + meta_blkaddr 块                                      |-> 另一个槽位
       ___________________________________
     |  ...   | inode |  xattrs  | extents  | data inline | ... | inode ..
|________|_______|(可选)|(可选)|__(可选)_|_____|__________|
              |-> 对齐到inode槽位大小
                   .
.
.
.
.
.
.____________________________________________________|-> 对齐到4字节
       | xattr_ibody_header | 共享xattrs | 内联xattrs |
       |____________________|_______________|_______________|
       |->    12字节    <-|->x * 4字节<-|
.                .
.                      .
### 翻译成中文：

```
.                           .
.______________________________.______________________
| id | id | id | id |  ... | id | ent | ... | ent| ... |
            |____|____|____|____|______|____|_____|_____|____|_____|
                                            |-> 对齐至 4 字节
                                                        |-> 对齐至 4 字节

索引节点（inode）可以是 32 字节或 64 字节，可以通过所有版本的索引节点都具有的一个通用字段 `i_format` 来区分：

        __________________               __________________
       |     i_format     |             |     i_format     |
       |__________________|             |__________________|
       |        ...       |             |        ...       |
       |                  |             |                  |
       |__________________| 32 字节     |                  |
                                        |                  |
                                        |__________________| 64 字节

扩展属性（xattrs）、扩展信息（extents）和内联数据放置在相应的索引节点之后，并且具有适当的对齐。它们对于不同的数据映射可能是可选的。
目前支持总共 5 种数据布局：

    ==  ====================================================================
     0  没有内联数据的平文件数据（无扩展信息）；
     1  固定大小输出数据压缩（带有未压缩的索引）；
     2  尾部打包内联数据的平文件数据（无扩展信息）；
     3  固定大小输出数据压缩（带有压缩的索引，v5.3+）；
     4  基于块的文件（v5.15+）
==  ====================================================================

可选的扩展属性的大小由索引节点头中的 `i_xattr_count` 指示。大的扩展属性或多个不同文件共享的扩展属性可以存储在共享的扩展属性元数据中，而不是直接内联在索引节点之后。

### 2. 共享扩展属性元数据空间

共享扩展属性空间类似于上述的索引节点空间，从由 `xattr_blkaddr` 指定的特定块开始，按适当的对齐方式组织。
每个共享扩展属性也可以通过以下公式直接找到：
         扩展属性偏移量 = xattr_blkaddr * 块大小 + 4 * 扩展属性 ID

::

                           |-> 对齐至 4 字节
    + xattr_blkaddr 块                      |-> 对齐至 4 字节
     __________________________________________________________
    |  ...   | 扩展属性条目 | 扩展属性数据 | ... | 扩展属性条目 | 扩展属性数据 ...
|________|_____________|_____________|_____|______________|_______________|

### 目录
所有目录现在都以紧凑的磁盘格式组织。注意，每个目录块分为索引区和名称区，以支持随机文件查找，并且所有目录项严格按字母顺序记录，以支持改进的前缀二分搜索算法（参见相关源代码）。

::

                  ___________________________
                 /                           |
                /              ______________|________________
               /              /              | nameoff1       | nameoffN-1
  ____________.______________._______________v________________v__________
 | 目录项 | 目录项 | ... | 目录项 | 文件名 | 文件名 | ... | 文件名 |
 |___.0___|____1___|_____|___N-1__|____0_____|____1_____|_____|___N-1____|
      \                           ^
       \                          |                           * 可能有尾部 '\0'
        \                         |                             字符
         \________________________| nameoff0
                             目录块

注意，除了第一个文件名的偏移量外，nameoff0 还指示了此块中目录项的总数，因为没有必要引入另一个磁盘字段。

### 基于块的文件
为了支持基于块的数据去重，自 Linux v5.15 起支持了一种新的索引节点数据布局：文件被分割为等大小的数据块，索引节点元数据中的 `extents` 区域指明如何获取这些块的数据：这可以是一个简单的 4 字节块地址数组或 8 字节块索引形式（详见 erofs_fs.h 中的结构体 `erofs_inode_chunk_index`）。

顺便说一句，目前所有基于块的文件都是未压缩的。
```
长扩展属性名称前缀
-------------------------------------
存在一些使用场景，其中具有不同值的扩展属性（如overlayfs的xattrs）可能只有少数共同的前缀。在这些情况下，预定义的前缀在镜像大小和运行时性能方面都表现得不够高效。引入长xattr名称前缀功能正是为了解决这一问题。总体思路是，除了现有的预定义前缀外，xattr条目还可以引用用户指定的长xattr名称前缀，例如“trusted.overlay”。

当引用一个长xattr名称前缀时，erofs_xattr_entry.e_name_index的最高位（第7位）会被设置，而较低位（第0-6位）作为一个整体表示所有长名称前缀中的索引。因此，除了长xattr名称前缀之外，只存储名称的尾部部分，在erofs_xattr_entry.e_name中，如果完整xattr名称与长xattr名称前缀完全匹配，则这部分可以为空。

所有长xattr前缀都会在一个有效的打包inode中依次存储，或者在其他情况下存储在元inode中。磁盘超级块上的xattr_prefix_count指示长xattr名称前缀的总数，而(xattr_prefix_start * 4)则指示打包/元inode中长名称前缀的起始偏移量。需要注意的是，如果xattr_prefix_count为0，则禁用长扩展属性名称前缀。

每个长名称前缀以ALIGN({__le16 len, data}, 4)的格式存储，其中len表示数据部分的总大小。数据部分实际上由'struct erofs_xattr_long_prefix'表示，其中base_index表示预定义xattr名称前缀的索引，例如对于“trusted.overlay”的长名称前缀，其base_index为EROFS_XATTR_INDEX_TRUSTED，而infix字符串保留了去除短前缀后的剩余字符串，例如上述例子中的“overlay”。

数据压缩
----------------
EROFS实现了固定输出大小的压缩，它从可变大小的输入生成固定大小的压缩数据块，这与现有的固定输入大小解决方案不同。由于现代流行的数据压缩算法大多基于LZ77，使用固定输出大小压缩可以获得相对更高的压缩比，并且这种固定输出方法可以从历史字典（即滑动窗口）中受益。

具体来说，原始（未压缩）数据被转换成多个可变大小的范围（extents），同时被压缩成物理簇（pclusters）。为了记录每个可变大小的范围，引入逻辑簇（lclusters）作为压缩索引的基本单位，用于指示新范围是否在该范围内生成（HEAD）或不在该范围内生成（NONHEAD）。逻辑簇现在固定为块大小，如下图所示：

          |<-    可变大小范围    ->|<-       VLE         ->|
        clusterofs                        clusterofs              clusterofs
          |                                 |                       |
 _________v_________________________________v_______________________v________
 ... |    .         |              |        .     |              |  .   ..
____|____._________|______________|________.___ _|______________|__.________
     |-> lcluster <-|-> lcluster <-|-> lcluster <-|-> lcluster <-|
          (HEAD)        (NONHEAD)       (HEAD)        (NONHEAD)
```
CBLKCNT
_______._____________________________.______________._________________
          ... |              |              |              | ..
_______|______________|______________|______________|_________________
              |->      大物理簇       <-|-> 物理簇 <-|

一个物理簇可以看作是物理压缩块的容器，其中包含压缩数据。之前，只支持大小为 lcluster（4KB）的物理簇（pcluster）。自从引入大物理簇功能（自 Linux v5.13 起可用），物理簇可以是 lcluster 大小的倍数。
对于每个头部 lcluster，记录 clusterofs 来指示新范围的起始位置，并使用 blkaddr 寻找压缩数据。对于每个非头部（NONHEAD）lcluster，使用 delta0 和 delta1 代替 blkaddr 来指示其与头部 lcluster 及下一个头部 lcluster 的距离。PLAIN lcluster 也是一种头部 lcluster，但其数据是未压缩的。详见 erofs_fs.h 中 "struct z_erofs_vle_decompressed_index" 周围的注释。
如果启用了大物理簇，则需要记录以 lcluster 为单位的物理簇大小。让第一个非头部 lcluster 的 delta0 存储带有特殊标志的压缩块计数，称为 CBLKCNT 非头部 lcluster。如下图所示，很容易理解其 delta0 始终为 1：

   __________________________________________________________
  | 头部 |  非头部  | 非头部 | ... | 非头部 | 头部 | 头部 |
  |__:___|_(CBLKCNT)_|_________|_____|_________|__:___|____:_|
     |<----- 一个带 CBLKCNT 的大物理簇 ----->|<--  -->|
           一个不带 CBLKCNT 的 lcluster 大小的物理簇 ^

如果另一个头部 lcluster 紧跟在一个头部 lcluster 后面，则没有空间来记录 CBLKCNT，但很容易知道这种物理簇的大小也是一个 lcluster。
自 Linux v6.1 起，每个物理簇可以用于多个变长范围，因此可以用于压缩数据的去重。
```
