目录锁定
=================

用于目录操作的锁定方案基于两种类型的锁——每inode锁（->i_rwsem）和每文件系统锁（->s_vfs_rename_mutex）。
当对多个非目录对象获取i_rwsem时，我们总是按照地址递增的顺序获取这些锁。我们将这种顺序称为“inode指针”顺序。

基本原语
========

对于我们的目的而言，所有操作可以归为以下六类：

1. 读取访问。锁定规则：
    * 锁定我们要访问的目录（共享）

2. 对象创建。锁定规则：
    * 锁定我们要访问的目录（独占）

3. 对象移除。锁定规则：
    * 锁定父目录（独占）
    * 找到要移除的对象
    * 锁定该对象（独占）

4. 链接创建。锁定规则：
    * 锁定父目录（独占）
    * 确认源对象不是目录
    * 锁定源对象（独占；可能可以放宽为共享）

5. 不跨目录的重命名。锁定规则：
    * 锁定父目录（独占）
    * 找到源对象和目标对象
    * 决定需要锁定的是源对象还是目标对象
      如果源对象是非目录，则需要锁定；如果目标对象是非目录或即将被移除，则需要锁定
    * 获取必要的锁（独占），按inode指针顺序获取锁（仅在源对象和目标对象都是非目录的情况下才可能发生这种情况——源对象因为其他情况下不需要锁定，而目标对象因为混合目录和非目录只有在RENAME_EXCHANGE情况下允许，而这不会移除目标）

6. 跨目录重命名。这是最复杂的一种情况。锁定规则：
    * 锁定文件系统
    * 如果父目录没有共同的祖先，则失败
    * 按“祖先优先”的顺序锁定父目录（独占）。如果两者互不为祖先，则先锁定源对象的父目录
    * 找到源对象和目标对象
    * 确认源对象不是目标对象的后代，且目标对象不是源对象的后代；否则失败
    * 锁定涉及的子目录（独占），源对象之前锁定

以上就是目录操作中的锁定策略。
* 锁定所有非目录项（排他），按inode指针顺序
上述规则显然保证了所有将被读取、修改或删除的目录都将由调用者锁定

拼接
====

还有一件事情需要考虑——拼接。这并不是一个独立的操作；它可能作为查找的一部分发生。我们谈论的是对目录树的操作，但显然我们并没有这些操作的全貌——特别是对于网络文件系统。我们所拥有的是一些在dcache中可见的子树，并且锁定是基于这些子树进行的。随着操作的进行，这些树会增长；内存压力则会修剪它们。通常这不是问题，但有一个棘手的情况——当一个正在增长的树达到另一个树的根时该怎么办？这种情况可以在多种场景下发生，从“有人挂载了来自同一个NFS4服务器的嵌套子树，在其中一个子树中进行查找时达到了另一个子树的根”开始；还有通过文件句柄打开的情况，以及一种可能性，即我们在某处看到的一个目录被服务器移动到另一处，并在我们进行查找时遇到它。

出于很多原因，我们希望dcache中只存在一个目录的一个实例。不允许有多个别名。因此，当查找遇到一个已有别名的子目录时，需要对dcache树做一些处理。查找已经持有了父目录的锁。如果别名是一个单独树的根，则将其附加到我们正在查找的目录下，并使用我们查找的名字。如果别名已经是我们在查找的目录的子目录，则将其名称更改为我们要查找的名字。这两种情况都不涉及额外的锁定。
然而，如果它是另一个目录的子目录，事情就变得复杂了。首先，我们确认它不是我们目录的祖先，并且如果是则失败查找。然后我们尝试锁定文件系统和别名的当前父目录。如果任一trylock失败，则查找失败。
如果trylock成功，我们将别名从其当前父目录分离，并以我们查找的名字附加到我们的目录下。
需要注意的是，拼接不涉及任何文件系统的修改；我们改变的只是dcache中的视图。此外，排他地锁定目录可以防止涉及其子目录的更改，而锁定文件系统可以防止任何树拓扑的变化，除了一个树的根成为另一个目录的子目录。特别地，如果在获取文件系统锁后发现两个dentry具有共同的祖先，它们之间的关系将保持不变直到锁被释放。因此，从目录操作的角度来看，拼接几乎是无关紧要的——唯一相关的地方是在跨目录重命名的一个步骤中；我们需要在检查父目录是否有共同祖先时小心。

多文件系统
==========

对于某些文件系统，一个方法可能涉及对另一个文件系统执行目录操作；可能是ecryptfs在其底层文件系统上执行操作，overlayfs对其层进行操作，网络文件系统使用本地文件系统作为缓存等。在所有这些情况下，对其他文件系统的操作必须遵循相同的锁定规则。更重要的是，“在此文件系统上执行目录操作可能涉及在另一个文件系统上的目录操作”应该是一种不对称关系（或者，可以说，应该可以对文件系统进行排序，使得在一个文件系统上的目录操作只能触发更高排序级别的文件系统上的目录操作——在这种情况下，overlayfs的排序低于其层，网络文件系统的排序低于其缓存的对象等）。

避免死锁
=======

如果没有目录是其自身的祖先，则上述方案是无死锁的。
证明：

存在一种对锁的排序，所有原语按照非递减的顺序获取这些锁。具体来说，

  * 对于给定文件系统中的非目录inode，按inode指针顺序获取->i_rwsem
  * 对于同一文件系统中的所有目录，其->i_rwsem具有相同的等级，并且低于该文件系统中任何非目录的->i_rwsem
  * 将->s_vfs_rename_mutex设置为比同一文件系统中任何->i_rwsem更低的等级
  * 对不同文件系统上的锁，使用这些文件系统的相对等级
例如，如果我们在本地文件系统上有一个NFS文件系统缓存，则有

  1. NFS文件系统的->s_vfs_rename_mutex
  2. 该NFS文件系统上所有目录的->i_rwsem，具有相同的等级
  3. 该文件系统上非目录的->i_rwsem，按inode地址升序排列
  4. 本地文件系统的->s_vfs_rename_mutex
  5. 本地文件系统上所有目录的->i_rwsem，具有相同的等级
  6. 本地文件系统上非目录的->i_rwsem，按inode地址升序排列
可以很容易地验证操作永远不会获取一个已经持有的锁的较低等级
假设死锁是可能的。考虑最小的死锁线程集合。这是一个若干线程的循环，每个线程都被下一个线程持有的锁阻塞
由于锁定顺序与排名一致，最小死锁中的所有争用锁将具有相同的等级，即它们都是同一文件系统上目录的->i_rwsem
此外，不失一般性，我们可以假设所有操作都是直接针对该文件系统的，没有任何操作实际达到了方法调用
换句话说，我们有一个线程循环T1,..., Tn，以及相同数量的目录（D1,...,Dn），使得

  * T1被D1阻塞，而D1由T2持有
  * T2被D2阻塞，而D2由T3持有
  * ..
Tn 在 Dn 上被阻塞，而 Dn 被 T1 持有。

在最小循环中的每个操作都至少锁定了一个目录，并在尝试锁定另一个目录时被阻塞。这只剩下三种可能的操作：目录删除（先锁定父目录，然后锁定子目录）、同一目录下的重命名删除子目录（同上）以及跨目录重命名的某种形式。

在这一组操作中必须有一个跨目录重命名；实际上，如果所有操作都是“先锁定父目录，然后锁定子目录”的形式，那么我们会得到 Dn 是 D1 的父目录，D1 是 D2 的父目录，D2 是 D3 的父目录，...，Dn 又是 Dn 的父目录。从获得目录锁的那一刻起，关系就不能改变，因此在死锁发生时，这些关系会同时存在，从而形成一个循环。

由于所有操作都在同一个文件系统上进行，因此它们之间不可能有多于一个跨目录重命名。不失一般性，我们可以假设 T1 正在执行跨目录重命名，其他所有操作都是“先锁定父目录，然后锁定子目录”的形式。

换句话说，我们有一个跨目录重命名操作，它锁定了 Dn 并尝试锁定 D1 时被阻塞，D1 是 D2 的父目录，D2 是 D3 的父目录，...，Dn 是 Dn 的父目录。D1 到 Dn 之间的所有关系在死锁发生时都同时存在。此外，跨目录重命名不会锁定任何目录，直到它获取了文件系统锁并验证了涉及的目录具有共同的祖先，这保证了它们之间的祖先关系一直稳定。

考虑跨目录重命名锁定目录的顺序；首先是父目录，然后可能是它们的子目录。
Dn 和 D1 必须在其中，且 Dn 在 D1 之前被锁定。
这对目录能是什么？

它们不能是父目录——事实上，因为 D1 是 Dn 的祖先，所以 D1 会是第一个被锁定的父目录。因此至少有一个子目录必须参与进来，因此这两个目录都不能是彼此的后代——否则该操作不会进展到锁定父目录。
它们也不能是一个父目录和它的子目录；否则我们会有一个循环，因为父目录在子目录之前被锁定，所以父目录会成为其子目录的后代。
它们也不能是一个父目录和另一个父目录的子目录。
否则，所讨论的父节点的孩子本应是另一个孩子的后代。
这只剩下一种可能性——即Dn和D1都在孩子中，只是顺序不同。但这同样是不可能的，因为没有一个孩子是另一个孩子的后代。
这就完成了证明，因为具有所需属性以形成最小死锁的操作集是不可能存在的。
请注意，在跨目录重命名时检查是否有共同祖先非常重要——如果没有这个检查，可能会出现死锁。确实，假设父节点最初在不同的树中；我们会锁定源的父节点，然后尝试锁定目标的父节点，结果一个无关的查找将源的一个远祖节点嫁接到目标父节点的某个远后代上。此时，我们持有对源的父节点的锁，并试图锁定其远祖节点。再加上对所有中间目录的一系列rmdir()尝试（如果它们获得了锁，都会因-ENOTEMPTY而失败），那么我们就有了一个死锁。

### 避免循环
######

这些操作保证不会创建循环。实际上，唯一可能引入循环的操作是跨目录重命名。
假设在操作之后出现了循环；由于之前并没有这样的循环，因此循环中的至少一个节点必须更改了其父节点。换句话说，循环必须经过源节点，或者在交换的情况下，可能经过目标节点。
由于操作成功了，源节点和目标节点都不能是对方的祖先。因此，从源的父节点开始的祖先链不能经过目标节点，反之亦然。另一方面，任何节点的祖先链也不能经过该节点本身，否则我们在操作之前就会有循环。但是除了源和目标之外的所有其他节点在操作后保持了相同的父节点，所以操作不会改变源和目标的（前）父节点的祖先链。特别是，这些链必须在有限步数内结束。
现在考虑由操作产生的循环。它会经过源或目标；循环中的下一个节点将是目标或源的（前）父节点。之后，循环会跟随那个父节点的祖先链。但正如我们刚才所示，那个链必须在有限步数内结束，这意味着它不能成为任何循环的一部分。证毕。
虽然这种锁定方案适用于任意有向无环图（DAG），但它依赖于能够检查目录是否为另一对象的后代的能力。当前实现假定目录图是一棵树。这一假设也被所有操作（不会引入循环的跨目录重命名会保留树结构，link() 对目录无效）所保持。
请注意，“目录”在此处指的是“任何可能有子节点的东西”，因此如果我们打算引入混合对象，我们需要确保link(2) 对它们不起作用，或者修改is_subdir() 使其即使在这种情况下也能正常工作。
当然，请提供您需要翻译的文本。
