SPDX 许可证标识符：GPL-2.0

============================
Glock 内部锁定规则
============================

本文档介绍了 glock 状态机内部的基本原理。每个 glock（在 fs/gfs2/incore.h 中定义的 struct gfs2_glock）有两个主要（内部）锁：

1. 一个自旋锁（gl_lockref.lock），用于保护内部状态，例如 gl_state、gl_target 和持有者列表（gl_holders）
2. 一个非阻塞位锁（GLF_LOCK），用于防止其他线程同时调用 DLM 等。如果一个线程获取了这个锁，则必须在释放时调用 run_queue（通常通过工作队列）以确保任何待处理的任务完成

gl_holders 列表包含所有排队的锁请求（不仅仅是持有者），这些请求与 glock 相关。如果有任何持有的锁，则它们将作为连续条目位于列表头部。锁是严格按照排队顺序授予的。

用户可以请求三种锁状态，即共享（SH）、延迟（DF）和独占（EX）。这些状态对应于以下 DLM 锁模式：

==========	====== =====================================================
Glock 模式      DLM    锁模式
==========	====== =====================================================
    UN          IV/NL  未锁定（没有关联的 DLM 锁）或 NL
    SH          PR     （受保护读取）
    DF          CW     （并发写入）
    EX          EX     （独占）
==========	====== =====================================================

因此，DF 基本上是一种与“正常”共享锁模式（SH）不兼容的共享模式。在 GFS2 中，DF 模式专门用于直接 I/O 操作。glocks 基本上是一个锁加上一些处理缓存管理的例程。对于缓存，以下规则适用：

==========      ==============   ==========   ==========   ==============
Glock 模式      缓存元数据       缓存数据     脏数据       脏元数据
==========      ==============   ==========   ==========   ==============
    UN                No            No            No            No
    DF                Yes           No            No            No
    SH                Yes           Yes           No            No
    EX                Yes           Yes           Yes           Yes
==========      ==============   ==========   ==========   ==============

这些规则是通过各种 glock 操作来实现的，这些操作为每种类型的 glock 定义。并非所有类型的 glock 都使用所有模式。例如，只有 inode glock 使用 DF 模式。

以下是 glock 操作及其类型常量的表格：

==============     =============================================================
字段              目的
==============     =============================================================
go_sync            在远程状态更改前调用（例如同步脏数据）
go_xmote_bh        在远程状态更改后调用（例如重新填充缓存）
go_inval           如果远程状态更改需要使缓存失效则调用
go_instantiate     当 glock 被获取时调用
go_held            每次获取 glock 持有者时调用
go_dump            为了调试文件打印对象内容，或者在错误时将 glock 打印到日志中
go_callback        如果 DLM 发送回调以释放此锁
go_unlocked        当 glock 解锁时调用（dlm_unlock()）
go_type            glock 的类型，“LM_TYPE_*”
go_flags           如果 glock 关联了一个地址空间，则设置 GLOF_ASPACE
==============     =============================================================

每个锁的最小持有时间是在远程锁授予之后忽略远程降级请求的时间。这是为了防止锁在集群节点间来回传递而没有任何节点取得进展的情况。这种情况最常出现在多个节点正在写入的共享内存映射文件中。通过延迟对远程回调的降级响应，这给了用户空间程序一些时间来进行处理，然后再解除页面映射。

最终，我们希望使 glock 的“EX”模式在本地共享，使得任何本地锁定都通过 i_mutex 进行而不是通过 glock。

glock 操作的锁定规则：

==============   ======================    =============================
操作              GLF_LOCK 位锁持有       gl_lockref.lock 自旋锁持有
==============   ======================    =============================
go_sync               是                       否
go_xmote_bh           是                       否
go_inval              是                       否
go_instantiate        否                       否
go_held               否                       否
go_dump               有时                      是
go_callback           有时（不适用）            是
go_unlocked           是                       否
==============   ======================    =============================

.. 注意::

   操作不应在进入时释放任一锁。go_dump 和 do_demote_ok 永远不应阻塞。
注意，go_dump 只会在 glock 的状态表明它正在缓存最新数据时被调用。

GFS2 中的 glock 锁定顺序：

1. i_rwsem（如果需要）
2. 重命名 glock（仅用于重命名）
3. inode glock（父节点先于子节点，在同一级别的 inode 按照相同父节点的锁序号排序）
4. rgrp glock（用于分配/回收操作）
5. 事务 glock（通过 gfs2_trans_begin 对于非读取操作）
6. i_rw_mutex（如果需要）
7. 页面锁（始终最后，非常重要！）

每个 inode 有两个 glock。一个用于锁定 inode 本身（锁定顺序如上），另一个称为 iopen glock，与 inode 中的 i_nlink 字段一起使用，以确定特定 inode 的生命周期。inode 的锁定是按 inode 进行的。rgrp 的锁定是按 rgrp 进行的。

一般来说，我们倾向于在集群锁之前锁定本地锁。
Glock 统计
----------------

统计信息分为两组：与超级块相关的统计和与单个 Glock 相关的统计。超级块统计是按 CPU 进行的，以尽量减少收集这些数据时产生的开销。它们还进一步按 Glock 类型进行划分。所有时间都以纳秒为单位。对于超级块统计和 Glock 统计而言，在每种情况下收集的信息相同。超级块定时统计用于为 Glock 定时统计提供默认值，以便新创建的 Glock 尽可能具有合理的初始值。每个 Glock 的计数器在创建 Glock 时初始化为零。当 Glock 从内存中被弹出时，其统计信息将丢失。

统计信息分为三对均值和方差，再加上两个计数器。均值/方差对是平滑指数估计，并且所用算法对于熟悉网络代码往返时间计算的人来说会非常熟悉。详见《TCP/IP详解 卷一》，W. Richard Stevens 著，第 21.3 节“往返时间测量”，第 299 页及以后；以及卷二，第 25.10 节，第 838 页及以后。

与《TCP/IP详解》中的情况不同，这里的均值和方差不进行缩放，而是以整数纳秒为单位。
三对均值/方差衡量以下内容：

1. DLM 锁定时间（非阻塞请求）
2. DLM 锁定时间（阻塞请求）
3. 请求间的时间（同样针对 DLM）

非阻塞请求是指无论 DLM 锁的状态如何都会立即完成的请求。目前这意味着当（a）锁当前状态为独占，即锁降级；（b）请求的状态为 null 或未锁定（再次降级）；或（c）设置了“尝试锁定”标志时的所有请求。阻塞请求涵盖所有其他锁请求。

有两个计数器。第一个主要用于显示有多少锁请求，从而了解有多少数据进入了均值/方差计算。另一个计数器用于计算 Glock 代码顶层持有者的排队情况。希望这个数字远大于发出的 DLM 锁请求的数量。

为什么需要收集这些统计信息？有几个原因让我们希望能够更好地了解这些定时信息：

1. 更好地设置 Glock 的“最小持有时间”
2. 更容易发现性能问题
3. 改进选择资源组分配的算法（基于锁等待时间，而不是盲目使用“尝试锁定”）

由于更新的平滑作用，样本中某个输入量的骤变只有在 8 次采样后（或对于方差来说是 4 次）才会被完全考虑进来。因此，在解释结果时必须谨慎。

知道一个锁请求完成所需的时间以及 Glock 的锁请求之间的平均时间意味着我们可以计算节点能够使用 Glock 的总百分比与集群其余部分占用其份额的时间。这在设置锁最小持有时间时将非常有用。

为了确保尽可能准确地测量我们想要的确切数量，已经采取了极大的小心。任何测量系统总是会有不准确性，但希望这是我们在合理范围内能达到的最大精确度。
以下是翻译：

每个超级块（sb）的统计信息可以在以下路径找到：

    /sys/kernel/debug/gfs2/<fsname>/sbstats

每个锁（glock）的统计信息可以在以下路径找到：

    /sys/kernel/debug/gfs2/<fsname>/glstats

假设调试文件系统（debugfs）挂载在/sys/kernel/debug，并且<fsname>替换为相应的GFS2文件系统的名称。

输出中使用的缩写如下：

=========  ================================================================
srtt       非阻塞DLM请求的平滑往返时间
srttvar    srtt的方差估计值
srttb      （可能）阻塞DLM请求的平滑往返时间
srttvarb   srttb的方差估计值
sirt       DLM请求的平滑请求间隔时间
sirtvar    sirt的方差估计值
dlm        发出的DLM请求数量（glstats文件中的dcnt）
queue      排队的锁请求数量（glstats文件中的qcnt）
=========  ==============================================================

sbstats文件包含每种锁类型的这些统计信息（每种类型8行）以及每个CPU的统计信息（每列对应一个CPU）。glstats文件包含每把锁的这些统计信息，格式类似于glocks文件，但使用均值/方差的形式表示每个定时统计信息。

gfs2_glock_lock_time追踪点会打印出当前锁的统计信息值，以及接收到的每个DLM回复的一些附加信息：

======   =======================================
status   DLM请求的状态
flags    DLM请求标志
tdiff    这个特定请求所花费的时间
======   =======================================

（其余字段参见上述列表）
