FPGA 设备特性列表（DFL）框架概览
==================================

作者：

- 恩诺·卢伯斯 <enno.luebbers@intel.com>
- 肖光荣 <guangrong.xiao@linux.intel.com>
- 吴浩 <hao.wu@intel.com>
- 徐一伦 <yilun.xu@intel.com>

设备特性列表（DFL）FPGA框架（以及根据此框架的驱动程序）隐藏了低层硬件的细节，为用户空间提供了统一的接口。应用程序可以使用这些接口在实现了DFL的设备内存平台中配置、枚举、打开和访问FPGA加速器。此外，DFL框架使系统级别的管理功能成为可能，例如FPGA重新配置。

设备特性列表（DFL）概览
========================

设备特性列表（DFL）在设备MMIO空间内定义了一个特性头链接列表，以提供一种可扩展的方式添加特性。软件可以通过遍历这些预定义的数据结构来枚举FPGA特性：FPGA接口单元（FIU）、加速功能单元（AFU）和私有特性，如下面所示：

    头部          头部          头部          头部
 +----------+  +-->+----------+  +-->+----------+  +-->+----------+
 |   类型   |  |   |  类型    |  |   |  类型    |  |   |  类型    |
 |   FIU    |  |   | 私有     |  |   | 私有     |  |   | 私有     |
 +----------+  |   | 特性     |  |   | 特性     |  |   | 特性     |
 | Next_DFH |--+   +----------+  |   +----------+  |   +----------+
 +----------+      | Next_DFH |--+   | Next_DFH |--+   | Next_DFH |--> NULL
 |    ID    |      +----------+      +----------+      +----------+
 +----------+      |    ID    |      |    ID    |      |    ID    |
 | Next_AFU |--+   +----------+      +----------+      +----------+
 +----------+  |   | 特性     |      | 特性     |      | 特性     |
 |  头部    |  |   | 寄存器   |      | 寄存器   |      | 寄存器   |
 | 寄存器   |  |   | 集合     |      | 集合     |      | 集合     |
 | 集合     |  |   +----------+      +----------+      +----------+
 +----------+  |       头部
               +-->+----------+
                   |   类型   |
                   |   AFU    |
                   +----------+
                   | Next_DFH |--> NULL
                   +----------+
                   |   GUID   |
                   +----------+
                   |  头部    |
                   | 寄存器   |
                   | 集合     |
                   +----------+

FPGA接口单元（FIU）代表了用于与FPGA接口的独立功能单元，例如FPGA管理引擎（FME）和端口（关于FME和端口的更多描述将在后续部分给出）
加速功能单元（AFU）代表一个FPGA可编程区域，并且总是作为其父节点的FIU（例如端口）的子节点连接，如上图所示。
私有特性表示FIU和AFU的子特性。它们可以是具有不同ID的各种功能块，但所有属于同一FIU或AFU的私有特性必须通过下一个设备特性头（Next_DFH）指针链接到一个列表中。
每个FIU、AFU和私有特性都可以实现自己的功能寄存器。
对于FIU和AFU的功能寄存器集，被命名为头部寄存器集，例如FME头部寄存器集；而对于私有特性，则被命名为特性寄存器集，例如FME部分重构特性寄存器集。
此设备特性列表提供了一种将特性链接在一起的方式，软件通过遍历此列表方便地定位每个特性，并且可以在任何FPGA设备的寄存器区域中实现。
设备特性头 - 第0版
==================

第0版（DFHv0）是设备特性头的原始版本。
DFHv0中的所有多字节量都是小端格式。
DFHv0的格式如下所示：

    +-----------------------------------------------------------------------+
    |63 类型 60|59 DFH 版本 52|51 保留 41|40 结束标志|39 Next 16|15 修订号 12|11 ID 0| 0x00
    +-----------------------------------------------------------------------+
    |63                                 GUID_L                             0| 0x08
    +-----------------------------------------------------------------------+
    |63                                 GUID_H                             0| 0x10
    +-----------------------------------------------------------------------+

- 偏移量0x00

  * 类型 - DFH的类型（例如FME、AFU或私有特性）
* DFH VER - DFH 的版本
* Rsvd - 当前未使用
* EOL - 若DFH为设备特性列表(DFL)的结尾，则设置该标志
* Next - DFL中下一个DFH相对于当前DFH起始位置的字节偏移量，
    并且一个DFH的起始必须对齐到8字节边界
    如果设置了EOL，Next则表示列表中最后一个特性的MMIO大小
* REV - 与该头部相关联特性的修订版本
* ID - 如果Type是私有特性，则表示特性ID
- 偏移量 0x08

  * GUID_L - 128位全局唯一标识符的最低有效64位
    （仅当Type为FME或AFU时存在）
- 偏移量 0x10

  * GUID_H - 128位全局唯一标识符的最高有效64位
    （仅当Type为FME或AFU时存在）
设备特性头 - 版本1
=================================
设备特性头的版本1 (DFHv1) 添加了以下功能：

* 提供了一种标准化的机制来让特性向软件描述参数/能力
* 对所有DFHv1类型标准化使用GUID
* 将DFH位置与特性本身的寄存器空间解耦
DFHv1中的所有多字节数量均采用小端格式
下面展示了设备特性头（DFH）版本1的格式：

    +-----------------------------------------------------------------------+
    |63 类型 60|59 DFH 版本 52|51 保留 41|40 结束标志|39 下一个 16|15 版本 12|11 ID 0| 0x00
    +-----------------------------------------------------------------------+
    |63                               GUID_L                              0| 0x08
    +-----------------------------------------------------------------------+
    |63                               GUID_H                              0| 0x10
    +-----------------------------------------------------------------------+
    |63                   寄存器地址/偏移量                    1| 相对   0| 0x18
    +-----------------------------------------------------------------------+
    |63       寄存器大小         32|参数 31|30 组     16|15 实例编号       0| 0x20
    +-----------------------------------------------------------------------+
    |63 下一个    35|34保留33|结束标志32|31 参数版本 16|15 参数ID           0| 0x28
    +-----------------------------------------------------------------------+
    |63                参数数据                                          0| 0x30
    +-----------------------------------------------------------------------+

                                  ..
+-----------------------------------------------------------------------+
    |63 下一个    35|34保留33|结束标志32|31 参数版本 16|15 参数ID           0|
    +-----------------------------------------------------------------------+
    |63                参数数据                                          0|
    +-----------------------------------------------------------------------+

- 偏移量 0x00

  * 类型 - DFH的类型（例如，FME，AFU或私有特性）
* DFH 版本 - DFH的版本号
* 保留 - 当前未使用
* 结束标志 - 如果DFH是设备特性列表（DFL）的结尾，则设置此位
* 下一个 - 从DFH起始到DFL中下一个DFH的字节偏移量，
    并且DFH的起始必须对齐到8字节边界
如果设置了结束标志，下一个字段表示列表中最后一个特性的MMIO大小
* REV - 与本标题相关的特性修订版本
* ID - 如果类型为私有特性，则为特性ID
- 偏移量 0x08

  * GUID_L - 128位全局唯一标识符的最低有效64位
- 偏移量 0x10

  * GUID_H - 128位全局唯一标识符的最高有效64位
- 偏移量 0x18

  * 寄存器地址/偏移量 - 如果Rel位被设置，那么该值为特性的寄存器组16位对齐绝对地址的高63位。否则，该值是从DFH开始到特性的寄存器组的偏移量
- 偏移量 0x20

  * 寄存器大小 - 特性寄存器集的字节大小
* Params - 如果DFH具有参数块列表，则设置此字段
* Group - 如果特性是某个组的一部分，则为此组的ID
* Instance - 在组内特性实例的ID
- 如果特性有参数，则偏移量为0x28

  * Next - 下一个参数块的偏移量，以8字节为单位。如果EOP被设置，则表示最后一个参数的大小，以8字节为单位
* 参数版本 - 参数ID的版本
* 参数ID - 参数的ID
- 偏移量 0x30

* 参数数据 - 参数数据，其大小和格式由参数的版本和ID定义
FIU - FME（FPGA 管理引擎）
============================
FPGA管理引擎执行重配置和其他基础设施功能。每个FPGA设备只有一个FME。
用户空间应用程序可以使用open()获取对FME的独占访问，并使用close()释放它。
以下函数通过ioctl暴露：

- 获取驱动程序API版本（DFL_FPGA_GET_API_VERSION）
- 检查扩展（DFL_FPGA_CHECK_EXTENSION）
- 编程比特流（DFL_FPGA_FME_PORT_PR）
- 将端口分配给PF（DFL_FPGA_FME_PORT_ASSIGN）
- 从PF释放端口（DFL_FPGA_FME_PORT_RELEASE）
- 获取FME全局错误的中断数量（DFL_FPGA_FME_ERR_GET_IRQ_NUM）
- 设置FME错误的中断触发器（DFL_FPGA_FME_ERR_SET_IRQ）

通过sysfs暴露更多函数
(/sys/class/fpga_region/regionX/dfl-fme.n/)：

读取比特流ID（bitstream_id）
     bitstream_id指示静态FPGA区域的版本
读取比特流元数据（bitstream_metadata）
     bitstream_metadata包括静态FPGA区域的详细信息，例如合成日期和种子
读取端口数量（ports_num）
     一个FPGA设备可能有多个端口，此sysfs接口指示FPGA设备有多少个端口
全局错误报告管理（errors/）
     错误报告sysfs接口允许用户读取硬件检测到的错误，并清除记录的错误
电源管理（dfl_fme_power hwmon）
     电源管理hwmon sysfs接口允许用户读取电源管理信息（功耗、阈值、阈值状态、限制等），并为不同的节流级别配置电源阈值
### 热管理 (dfl_fme_thermal hwmon)
热管理 hwmon sysfs 接口允许用户读取热管理信息（当前温度、阈值、阈值状态等）。

### 性能报告
性能计数器通过 perf PMU API 暴露。标准的 perf 工具可用于监控所有可用的 perf 事件。请参阅下面的性能计数器部分以获取更详细的信息。

### FIU - 端口
端口代表静态 FPGA 布局与包含 AFU 的部分可重构区域之间的接口。它控制从软件到加速器的通信，并提供诸如重置和调试等功能。每个 FPGA 设备可能有多个端口，但每个端口始终只有一个 AFU。

### AFU
AFU 附属于端口 FIU，并暴露一个固定长度的 MMIO 区域供加速器特定的控制寄存器使用。
用户空间应用程序可以通过对端口设备节点使用 `open()` 来获得对连接到端口的 AFU 的独占访问权，并使用 `close()` 释放该访问权。
以下功能通过 ioctl 暴露：

- 获取驱动程序 API 版本 (DFL_FPGA_GET_API_VERSION)
- 检查扩展 (DFL_FPGA_CHECK_EXTENSION)
- 获取端口信息 (DFL_FPGA_PORT_GET_INFO)
- 获取 MMIO 区域信息 (DFL_FPGA_PORT_GET_REGION_INFO)
- 映射 DMA 缓冲区 (DFL_FPGA_PORT_DMA_MAP)
- 取消映射 DMA 缓冲区 (DFL_FPGA_PORT_DMA_UNMAP)
- 重置 AFU (DFL_FPGA_PORT_RESET)
- 获取端口错误 irq 的数量 (DFL_FPGA_PORT_ERR_GET_IRQ_NUM)
- 设置端口错误的中断触发 (DFL_FPGA_PORT_ERR_SET_IRQ)
- 获取 UINT irq 的数量 (DFL_FPGA_PORT_UINT_GET_IRQ_NUM)
- 设置 UINT 的中断触发 (DFL_FPGA_PORT_UINT_SET_IRQ)

**DFL_FPGA_PORT_RESET：**
重置 FPGA 端口及其 AFU。用户空间可以在任何时候进行端口重置，例如在 DMA 或部分重新配置期间。但这不应导致任何系统级问题，只应导致功能性故障（例如 DMA 或 PR 操作失败），并且应能够从故障中恢复。
用户空间应用程序也可以通过 `mmap()` 映射加速器的 MMIO 区域。
通过 sysfs 暴露了更多功能：
(`/sys/class/fpga_region/<regionX>/<dfl-port.m>/`):

- **读取加速器 GUID (afu_id)**
  afu_id 表示编程到此 AFU 的 PR 位流。
- **错误报告 (errors/)**
  错误报告 sysfs 接口允许用户读取硬件检测到的端口/AFU 错误，并清除记录的错误。

### DFL 框架概览

DFL 框架在内核中提供了通用接口来创建容器设备（FPGA 基础区域），从给定的设备特征列表中发现特征设备及其私有特征，并为特征设备（如 FME、端口和 AFU）创建平台设备以及在容器设备下分配相关资源。它还抽象了私有特征的操作，并向特征设备驱动程序暴露通用操作。
FPGA DFL 设备可能是指不同的硬件类型，例如 PCIe 设备、平台设备等。一旦系统创建了该设备，其驱动模块就会首先加载。这个驱动在驱动架构中扮演基础设施的角色。它定位设备内存中的DFL，并处理这些DFL及相关资源，为DFL框架提供通用接口以进行枚举（请参阅 `drivers/fpga/dfl.c` 获取详细的枚举API）。

FPGA管理引擎（FME）驱动是一个平台驱动，在从DFL设备模块创建FME平台设备后会自动加载。它提供了FPGA管理的关键功能，包括：

a) 暴露静态FPGA区域信息，如版本和元数据。
用户可以通过FME驱动暴露的sysfs接口读取相关信息。
b) 部分重构。FME驱动在初始化部分重构（PR）子特性时创建FPGA管理器、FPGA桥接器和FPGA区域。一旦收到用户发送的 DFL_FPGA_FME_PORT_PR ioctl 请求，它将调用来自FPGA区域的通用接口函数来完成给定端口的部分重构操作。

与FME驱动类似，FPGA加速功能单元（AFU）驱动会在AFU平台设备创建后被探测。此模块的主要功能是为用户空间应用程序提供访问各个加速器的接口，包括基本的端口重置控制、AFU MMIO区域导出以及DMA缓冲区映射服务功能。

在创建功能平台设备后，相应的平台驱动会自动加载以处理不同的功能。关于已经在该DFL框架下实现的功能单元的详细信息，请参阅后续章节。

部分重构
==========
如上所述，可以通过部分重构一个PR位流文件来重新配置加速器。PR位流文件必须为确切的静态FPGA区域和目标可重构区域（端口）生成，否则，重构操作将失败并可能导致系统不稳定。这种兼容性可以通过比较PR位流文件头部记录的兼容性ID与目标FPGA区域暴露的compat_id来进行检查。这种检查通常由用户空间在调用重构IOCTL之前执行。

FPGA虚拟化 - PCIe SRIOV
=========================
本节描述了基于DFL的FPGA设备上的虚拟化支持，以便应用程序能够在虚拟机（VM）中访问加速器。本节仅描述具有SRIOV支持的PCIe基FPGA设备。

特定FPGA设备支持的功能通过设备特征列表暴露，如下图所示：

::

    +-------------------------------+  +-------------+
    |              PF               |  |     VF      |
    +-------------------------------+  +-------------+
        ^            ^         ^              ^
        |            |         |              |
  +-----|------------|---------|--------------|-------+
  |     |            |         |              |       |
  |  +-----+     +-------+ +-------+      +-------+   |
  |  | FME |     | Port0 | | Port1 |      | Port2 |   |
  |  +-----+     +-------+ +-------+      +-------+   |
  |                  ^         ^              ^       |
  |                  |         |              |       |
  |              +-------+ +------+       +-------+   |
  |              |  AFU  | |  AFU |       |  AFU  |   |
  |              +-------+ +------+       +-------+   |
  |                                                   |
  |            DFL 基于 FPGA 的 PCIe 设备             |
  +---------------------------------------------------+

FME始终通过物理功能（PF）访问。
端口（及其相关的AFU）默认通过PF进行访问，但也可以通过PCIe SRIOV经由虚拟功能（VF）设备暴露。每个VF仅包含1个端口和1个AFU以实现隔离。用户可以通过PCIe SRIOV接口创建的单独VF（加速器），分配给虚拟机。

下面展示了在虚拟化情况下的驱动程序组织：

```
+-------++------++------+             |
| FME   || FME  || FME  |             |
| FPGA  || FPGA || FPGA |             |
|Manager||Bridge||Region|             |
+-------++------++------+             |
+-----------------------+  +--------+ |             +--------+
|          FME          |  |  AFU   | |             |  AFU   |
|         Module        |  | Module | |             | Module |
+-----------------------+  +--------+ |             +--------+
          +-----------------------+       |       +-----------------------+
          | FPGA Container Device |       |       | FPGA Container Device |
          |  (FPGA Base Region)   |       |       |  (FPGA Base Region)   |
          +-----------------------+       |       +-----------------------+
            +------------------+          |         +------------------+
            | FPGA PCIE Module |          | Virtual | FPGA PCIE Module |
            +------------------+   Host   | Machine +------------------+
   -------------------------------------- | ------------------------------
             +---------------+            |          +---------------+
             | PCI PF Device |            |          | PCI VF Device |
             +---------------+            |          +---------------+
```

一旦检测到FPGA PCIe PF或VF设备，FPGA PCIe设备驱动程序总是首先加载。它：
- 使用DFL框架的通用接口完成FPGA PCIe PF和VF设备的枚举。
- 支持SRIOV。

FME设备驱动程序在此驱动程序架构中扮演管理角色，它提供ioctl来从PF释放端口并将其分配给PF。在从PF释放端口后，通过PCIe SRIOV sysfs接口将此端口暴露给VF是安全的。

为了使应用程序能够从VM中访问加速器，必须按照以下步骤将相应AFU的端口分配给VF：

1. 默认情况下，PF拥有所有AFU端口。任何需要重新分配给VF的端口，必须先通过在FME设备上使用DFL_FPGA_FME_PORT_RELEASE ioctl进行释放。
2. 一旦N个端口从PF中释放，用户可以使用以下命令启用SRIOV和VF。每个VF只拥有一个带有AFU的端口：

```
echo N > $PCI_DEVICE_PATH/sriov_numvfs
```
3. 将VF传递给VMs。
4. VF下的AFU可以从VM中的应用程序访问（使用VF内部相同的驱动程序）。

请注意，FME不能分配给VF，因此PR和其他管理功能只能通过PF获得。

设备枚举
========
本节介绍了应用程序如何从/sys/class/fpga_region下的sysfs层次结构中枚举fpga设备。

在下面的例子中，主机中安装了两个基于DFL的FPGA设备。每个fpga设备有一个FME和两个端口（AFUs）。
FPGA区域在`/sys/class/fpga_region/`下创建：

	/sys/class/fpga_region/region0
	/sys/class/fpga_region/region1
	/sys/class/fpga_region/region2
	..
应用程序需要搜索每个regionX文件夹，如果发现特征设备（例如找到“dfl-port.n”或“dfl-fme.m”），则它就是代表FPGA设备的基础FPGA区域。
每个基础区域有一个FME和两个端口（AFU）作为子设备：

	/sys/class/fpga_region/region0/dfl-fme.0
	/sys/class/fpga_region/region0/dfl-port.0
	/sys/class/fpga_region/region0/dfl-port.1
	..
/sys/class/fpga_region/region3/dfl-fme.1
	/sys/class/fpga_region/region3/dfl-port.2
	/sys/class/fpga_region/region3/dfl-port.3
	..
通常，FME/AFU的sysfs接口按以下方式命名：

	/sys/class/fpga_region/<regionX>/<dfl-fme.n>/
	/sys/class/fpga_region/<regionX>/<dfl-port.m>/

其中'n'连续编号所有FME，'m'连续编号所有端口。
用于ioctl()或mmap()的设备节点可以通过以下方式引用：

	/sys/class/fpga_region/<regionX>/<dfl-fme.n>/dev
	/sys/class/fpga_region/<regionX>/<dfl-port.n>/dev

性能计数器
==========
性能报告是FME中实现的一个私有特性。它可以支持硬件中的多个独立、系统范围的设备计数集，以监控和计算性能事件，包括“基本”、“缓存”、“结构”、“vtd”和“vtd_sip”计数器。用户可以使用标准的perf工具来监控FPGA的缓存命中率、事务数量、AFU的接口时钟计数和其他FPGA性能事件。
不同的FPGA设备可能具有不同的计数集，这取决于硬件实现。例如，某些离散FPGA卡没有缓存。用户可以使用“perf list”检查目标硬件支持哪些性能事件。
为了允许用户使用标准的perf API访问这些性能计数器，驱动程序创建了一个perf PMU，并在`/sys/bus/event_source/devices/dfl_fme*`中创建了相关的sysfs接口，以描述可用的性能事件和配置选项。
“format”目录描述了struct perf_event_attr的config字段的格式。对于config有3个位字段：“evtype”定义了性能事件所属的类型；“event”是事件在其类别内的标识；“portid”被引入以决定是在FPGA整体数据上还是在特定端口上监视计数器集。
“events”目录描述了可用于与perf工具直接使用的所有可用事件的配置模板。例如，fab_mmio_read的配置为“event=0x06,evtype=0x02,portid=0xff”，这表明此事件属于结构类型（0x02），本地事件ID为0x06，且适用于整体监控（portid=0xff）。
示例使用perf命令：

```
$# perf list | grep dfl_fme

dfl_fme0/fab_mmio_read/                              [内核PMU事件]
<...>
dfl_fme0/fab_port_mmio_read,portid=?/                [内核PMU事件]
<...>
```

```
$# perf stat -a -e dfl_fme0/fab_mmio_read/ <command>
或
$# perf stat -a -e dfl_fme0/event=0x06,evtype=0x02,portid=0xff/ <command>
或
$# perf stat -a -e dfl_fme0/config=0xff2006/ <command>
```

另一个例子，fab_port_mmio_read监控特定端口的mmio读取。因此其配置模板是"event=0x06,evtype=0x01,portid=?"。portid应该明确设置。
使用perf的示例：

```
$# perf stat -a -e dfl_fme0/fab_port_mmio_read,portid=0x0/ <command>
或
$# perf stat -a -e dfl_fme0/event=0x06,evtype=0x02,portid=0x0/ <command>
或
$# perf stat -a -e dfl_fme0/config=0x2006/ <command>
```

请注意对于fabric计数器，总体perf事件（fab_*）和端口perf事件（fab_port_*）实际上在硬件中共享一组计数器，所以不能同时监控两者。如果这组计数器被配置为监控总体数据，则不支持每端口的perf数据。请参阅下面的例子：

```
$# perf stat -e dfl_fme0/fab_mmio_read/,dfl_fme0/fab_port_mmio_write,portid=0/ sleep 1

系统范围内的性能计数器统计：

         3      dfl_fme0/fab_mmio_read/
<不支持>      dfl_fme0/fab_port_mmio_write,portid=0x0/

       1.001750904 秒钟已过去
```

驱动程序还提供了一个"cpumask"sysfs属性，其中只包含用于访问这些perf事件的一个CPU ID。由于它们是FPGA设备上的系统范围计数器，不允许在多个CPU上进行计数。
当前驱动程序不支持采样。因此"perf record"不受支持。

中断支持
========
一些FME和AFU私有特性能够生成中断。如上所述，用户可以调用ioctl（DFL_FPGA_*_GET_IRQ_NUM）来了解此私有特性是否支持以及支持多少个中断。驱动程序也实现了基于eventfd的中断处理机制，当发生中断时用户可以通过该机制获得通知。用户可以通过ioctl（DFL_FPGA_*_SET_IRQ）将eventfds设置到驱动程序，然后轮询/选择这些eventfds等待通知。
在当前的DFL中，3个子特性（端口错误、FME全局错误和AFU中断）支持中断。

添加新的功能单元(FIUs)支持
==================
开发人员可能在DFL框架下制作了一些新的功能块（FIUs），那么需要为新功能设备（FIU）开发新的平台设备驱动程序，遵循现有功能设备驱动程序（例如FME和端口/AFU平台设备驱动程序）的方式。除此之外，还需要修改DFL框架的枚举代码，以便检测新的FIU类型并创建相关的平台设备。

添加新的私有特性支持
======================
在某些情况下，我们可能需要向现有的FIUs（例如FME或端口）添加一些新的私有特性。开发人员无需触及DFL框架中的枚举代码，因为每个私有特性都会自动解析，并且可以在由DFL框架创建的FIU平台设备下找到相关的mmio资源。
开发人员只需提供一个与特征ID匹配的子特性驱动程序即可。
FME部分重构子特性驱动程序（见drivers/fpga/dfl-fme-pr.c）可作为参考。

有关现有特征ID表和申请新特征ID的指南，请参阅以下链接。
PCI 设备上的 DFL 位置
======================

最初，寻找 PCI 设备上 DFL（Device Feature List）的方法假设第一个 DFL 从 bar 0 的偏移量 0 开始。如果 DFL 的第一个节点是 FME（Field Management Entity），那么端口中的其他 DFL 由 FME 头部寄存器指定。或者，可以使用 PCIe 的供应商特定功能结构来指定设备上所有 DFL 的位置，为 DFL 中起始节点的类型提供了灵活性。Intel 为此目的保留了 VSEC ID 0x43。供应商特定数据以一个 4 字节的供应商特定寄存器开始，用于存储 DFL 的数量，接着是每个 DFL 的 4 字节 Offset/BIR 供应商特定寄存器。Offset/BIR 寄存器的位 2:0 表示 BAR，位 31:3 形成了 8 字节对齐的偏移，其中位 2:0 是零。
::

        +----------------------------+
        |31     DFL 数量         0|
        +----------------------------+
        |31     偏移量     3|2 BAR  0|
        +----------------------------+
                      . .
+----------------------------+
        |31     偏移量     3|2 BAR  0|
        +----------------------------+

考虑过在每个 BAR 上指定多个 DFL，但最终确定这种使用场景没有提供价值。为每个 BAR 指定单个 DFL 简化了实现，并允许进行额外的错误检查。

用户空间驱动支持 DFL 设备
==========================

FPGA 的目的是被重新编程以包含新开发的硬件组件。新的硬件可以在 DFL 中实例化一个新的私有特性，然后在系统中呈现一个 DFL 设备。在某些情况下，用户可能需要用户空间驱动程序来驱动 DFL 设备：

* 用户可能需要运行一些硬件诊断测试
* 用户可能在用户空间中原型化内核驱动
* 有些硬件是为特定目的设计的，不符合标准内核子系统的任何一种
这要求直接访问 MMIO 空间和来自用户空间的中断处理。uio_dfl 模块为此目的暴露了 UIO 设备接口。

目前，uio_dfl 驱动程序仅支持无硬件中断的 Ether Group 子特性。因此，在此驱动程序中未添加中断处理。应选择 UIO_DFL 来启用 uio_dfl 模块驱动程序。要通过 UIO 直接访问支持新的 DFL 特性，其特性 ID 应添加到驱动程序的 id_table 中。
开放讨论
===============
FME 驱动现在为部分重构向用户导出了一个 ioctl（DFL_FPGA_FME_PORT_PR）。将来，如果添加了统一的用户重构接口，FME 驱动应当从 ioctl 接口切换到这些统一接口。
