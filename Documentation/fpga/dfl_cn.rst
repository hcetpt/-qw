FPGA 设备特性列表 (DFL) 框架概览
==================================

作者：

- 恩诺·卢伯斯 <enno.luebbers@intel.com>
- 肖光荣 <guangrong.xiao@linux.intel.com>
- 吴浩 <hao.wu@intel.com>
- 徐一伦 <yilun.xu@intel.com>

设备特性列表 (DFL) 的 FPGA 框架（以及根据该框架的驱动程序）隐藏了低层硬件的具体细节，并为用户空间提供了统一的接口。应用程序可以使用这些接口来配置、枚举、打开和访问在设备内存中实现了 DFL 的平台上 FPGA 加速器。除此之外，DFL 框架还支持系统级别的管理功能，例如 FPGA 的重新配置。

设备特性列表 (DFL) 概览
==========================

设备特性列表 (DFL) 在设备 MMIO 空间内定义了一个特性头链接列表，以提供一种可扩展的方式来添加特性。软件可以通过遍历这些预定义的数据结构来枚举 FPGA 特性：FPGA 接口单元 (FIU)、加速功能单元 (AFU) 和私有特性，如下面所示：

    头部          头部          头部          头部
 +----------+  +-->+----------+  +-->+----------+  +-->+----------+
 |   类型   |  |   |  类型    |  |   |  类型    |  |   |  类型    |
 |   FIU    |  |   | 私有特性 |  |   | 私有特性 |  |   | 私有特性 |
 +----------+  |   +----------+  |   +----------+  |   +----------+
 | Next_DFH |--+   +----------+  |   +----------+  |   +----------+
 +----------+      | Next_DFH |--+   | Next_DFH |--+   | Next_DFH |--> NULL
 |    ID    |      +----------+      +----------+      +----------+
 +----------+      |    ID    |      |    ID    |      |    ID    |
 | Next_AFU |--+   +----------+      +----------+      +----------+
 +----------+  |   | 特性     |      | 特性     |      | 特性     |
 |  头部    |  |   | 寄存器集 |      | 寄存器集 |      | 寄存器集 |
 | 寄存器集 |  |   +----------+      +----------+      +----------+
 |   集合   |  |      头部
 +----------+  |   +----------+
               +-->+----------+
                   |   类型   |
                   |   AFU    |
                   +----------+
                   | Next_DFH |--> NULL
                   +----------+
                   |   GUID   |
                   +----------+
                   |  头部    |
                   | 寄存器集 |
                   |   集合   |
                   +----------+

FPGA 接口单元 (FIU) 表示一个独立的功能单元，用于与 FPGA 接口，例如 FPGA 管理引擎 (FME) 和端口（关于 FME 和端口的更多描述请参见后文）。
加速功能单元 (AFU) 表示一个可编程的 FPGA 区域，并且总是作为 FIU（例如端口）的子单元连接到 FIU 上，如上图所示。
私有特性表示 FIU 和 AFU 的子特性。它们可以是具有不同 ID 的各种功能块，但是属于同一 FIU 或 AFU 的所有私有特性必须通过下一个设备特性头部 (Next_DFH) 指针链接到一个列表中。
每个 FIU、AFU 和私有特性都可以实现其自身的功能寄存器。
FIU 和 AFU 的功能寄存器集被称为头部寄存器集，例如 FME 头部寄存器集；而私有特性的则被称为特性寄存器集，例如 FME 部分重配置特性寄存器集。
此设备特性列表提供了一种将特性链接在一起的方式，软件通过遍历这个列表方便地定位每个特性，并且可以在任何 FPGA 设备的寄存器区域中实现。

设备特性头部 —— 版本 0
======================

版本 0 (DFHv0) 是设备特性头部的原始版本。
DFHv0 中的所有多字节量都是小端格式。
DFHv0 的格式如下所示：

    +-----------------------------------------------------------------------+
    |63 类型 60|59 DFH 版本 52|51 保留 41|40 结束标志|39 Next 16|15 版本 12|11 ID 0| 0x00
    +-----------------------------------------------------------------------+
    |63                                 GUID_L                             0| 0x08
    +-----------------------------------------------------------------------+
    |63                                 GUID_H                             0| 0x10
    +-----------------------------------------------------------------------+

- 偏移 0x00

  * 类型 —— DFH 的类型（例如 FME、AFU 或私有特性）
* DFH VER - DFH 的版本
* Rsvd - 当前未使用
* EOL - 若DFH为设备特性列表(DFL)的结尾，则设置该标志
* Next - DFL中下一个DFH相对于当前DFH起始位置的字节偏移量，
    并且一个DFH的起始位置必须对齐到8字节边界
如果设置了EOL，Next则表示列表中最后一个特性的MMIO大小
* REV - 与该头文件关联的特性的修订版本
* ID - 如果Type是私有特性，则为特性ID
- 偏移 0x08

  * GUID_L - 128位全局唯一标识符的最低有效64位
    （仅当Type为FME或AFU时存在）
- 偏移 0x10

  * GUID_H - 128位全局唯一标识符的最高有效64位
    （仅当Type为FME或AFU时存在）
设备特性头文件 - 版本1
=================================
设备特性头文件版本1 (DFHv1) 添加了以下功能：

* 提供了一种标准化机制，使得特性能够向软件描述参数/能力信息
* 对所有DFHv1类型标准化使用GUID
* 将DFH的位置与特性本身的寄存器空间解耦
DFHv1中的所有多字节数据量均为小端格式
下面展示了设备特性头（DFH）版本1的格式：

    +-----------------------------------------------------------------------+
    |63 类型 60|59 DFH 版本 52|51 保留 41|40 结束标志|39 下一个 16|15 修订版 12|11 ID 0| 0x00
    +-----------------------------------------------------------------------+
    |63                               GUID_L                              0| 0x08
    +-----------------------------------------------------------------------+
    |63                               GUID_H                              0| 0x10
    +-----------------------------------------------------------------------+
    |63                   寄存器地址/偏移                      1|  相对  0| 0x18
    +-----------------------------------------------------------------------+
    |63       寄存器大小       32|参数 31|30 组    16|15 实例编号      0| 0x20
    +-----------------------------------------------------------------------+
    |63 下一个    35|34保留33|结束标志32|31 参数版本 16|15 参数ID           0| 0x28
    +-----------------------------------------------------------------------+
    |63                 参数数据                                          0| 0x30
    +-----------------------------------------------------------------------+

                                  ..
+-----------------------------------------------------------------------+
    |63 下一个    35|34保留33|结束标志32|31 参数版本 16|15 参数ID           0|
    +-----------------------------------------------------------------------+
    |63                 参数数据                                          0|
    +-----------------------------------------------------------------------+

- 偏移 0x00

  * 类型 - DFH的类型（例如FME、AFU或私有特性）
* DFH 版本 - DFH的版本
* 保留 - 当前未使用
* 结束标志 - 如果DFH是设备特性列表（DFL）的结尾，则设置此位
* 下一个 - 从DFH开始到DFL中下一个DFH的字节偏移，且DFH的起始位置必须以8字节为单位对齐
如果设置了结束标志，则"下一个"表示列表中最后一个特性的MMIO大小
* REV - 与本表头相关的特性的修订版本
* ID - 如果类型为私有特性，则为特性ID
- 偏移量 0x08

  * GUID_L - 128位全局唯一标识符的最低有效64位
- 偏移量 0x10

  * GUID_H - 128位全局唯一标识符的最高有效64位
- 偏移量 0x18

  * 寄存器地址/偏移量 - 如果Rel位被设置，则该值为特性的寄存器16位对齐绝对地址的高63位。否则，该值是从DFH开始到特性的寄存器的偏移量
- 偏移量 0x20

  * 寄存器大小 - 特性寄存器集的大小（以字节为单位）
* Params - 如果DFH包含一系列参数块，则设置此标志
* Group - 如果特性是某个组的一部分，则为该组的ID
* Instance - 在组内的特性实例ID
- 如果特性有参数，则偏移量为0x28

  * Next - 到下一个参数块的偏移量（以8字节为单位）。如果EOP被设置，则表示最后一个参数的大小（以8字节为单位）
* 参数版本 - 参数ID的版本
* 参数ID - 参数的ID
- 偏移量 0x30

* 参数数据 - 参数数据，其大小和格式由参数的版本和ID定义
FIU - FME（FPGA 管理引擎）
============================
FPGA管理引擎执行重配置和其他基础设施功能。每个FPGA设备只有一个FME。
用户空间应用程序可以使用`open()`获取对FME的独占访问权，并使用`close()`释放它。
以下函数通过ioctl接口暴露：

- 获取驱动API版本 (`DFL_FPGA_GET_API_VERSION`)
- 检查扩展 (`DFL_FPGA_CHECK_EXTENSION`)
- 编程位流 (`DFL_FPGA_FME_PORT_PR`)
- 将端口分配给PF (`DFL_FPGA_FME_PORT_ASSIGN`)
- 从PF释放端口 (`DFL_FPGA_FME_PORT_RELEASE`)
- 获取FME全局错误中断的数量 (`DFL_FPGA_FME_ERR_GET_IRQ_NUM`)
- 设置FME错误中断触发器 (`DFL_FPGA_FME_ERR_SET_IRQ`)

更多函数通过sysfs接口暴露
(`/sys/class/fpga_region/regionX/dfl-fme.n/`):

读取位流ID (`bitstream_id`)
     `bitstream_id`指示静态FPGA区域的版本
读取位流元数据 (`bitstream_metadata`)
     `bitstream_metadata`包含静态FPGA区域的详细信息，例如合成日期和种子
读取端口数量 (`ports_num`)
     一个FPGA设备可能有多个端口，此sysfs接口指示FPGA设备有多少个端口
全局错误报告管理 (`errors/`)
     错误报告sysfs接口允许用户读取硬件检测到的错误，并清除记录的错误
电源管理 (`dfl_fme_power hwmon`)
     电源管理hwmon sysfs接口允许用户读取电源管理信息（功耗、阈值、阈值状态、限制等），并为不同的节流级别配置电源阈值
### 热管理 (dfl_fme_thermal hwmon)
热管理 hwmon sysfs 接口允许用户读取热管理信息（当前温度、阈值、阈值状态等）。

### 性能报告
性能计数器通过 perf PMU API 暴露。标准的 perf 工具可用于监控所有可用的 perf 事件。请参阅下面的性能计数器部分以获取更详细的信息。

### FIU - 端口
端口代表静态 FPGA 布局与包含 AFU 的部分可重构区域之间的接口。它控制从软件到加速器的通信，并提供诸如复位和调试等功能。每个 FPGA 设备可能有多个端口，但每个端口始终只有一个 AFU。

### AFU
AFU 附属于端口 FIU，并暴露一个固定长度的 MMIO 区域供加速器特定的控制寄存器使用。
用户空间应用程序可以通过对端口设备节点使用 `open()` 来获得对连接到端口的 AFU 的独占访问权，并使用 `close()` 释放该访问权。
以下功能通过 ioctl 暴露：

- 获取驱动程序 API 版本 (DFL_FPGA_GET_API_VERSION)
- 检查扩展功能 (DFL_FPGA_CHECK_EXTENSION)
- 获取端口信息 (DFL_FPGA_PORT_GET_INFO)
- 获取 MMIO 区域信息 (DFL_FPGA_PORT_GET_REGION_INFO)
- 映射 DMA 缓冲区 (DFL_FPGA_PORT_DMA_MAP)
- 取消映射 DMA 缓冲区 (DFL_FPGA_PORT_DMA_UNMAP)
- 复位 AFU (DFL_FPGA_PORT_RESET)
- 获取端口错误中断的数量 (DFL_FPGA_PORT_ERR_GET_IRQ_NUM)
- 设置端口错误中断触发 (DFL_FPGA_PORT_ERR_SET_IRQ)
- 获取 UINT 中断的数量 (DFL_FPGA_PORT_UINT_GET_IRQ_NUM)
- 设置 UINT 中断触发 (DFL_FPGA_PORT_UINT_SET_IRQ)

**DFL_FPGA_PORT_RESET：**
复位 FPGA 端口及其 AFU。用户空间可以在任何时候进行端口复位，例如在 DMA 或部分重构过程中。但它不应导致任何系统级别的问题，只应导致功能性失败（例如 DMA 或 PR 操作失败），并且可以从失败中恢复。
用户空间应用程序还可以通过 `mmap()` 映射加速器 MMIO 区域。
通过 sysfs 暴露了更多功能：
(`/sys/class/fpga_region/<regionX>/<dfl-port.m>/`)：

- 读取加速器 GUID (afu_id)
  `afu_id` 表示编程到此 AFU 的 PR 位流。
- 错误报告 (errors/)
  错误报告 sysfs 接口允许用户读取硬件检测到的端口/AFU 错误，并清除记录的错误。

### DFL 框架概览

DFL 框架在内核中提供了通用接口来创建容器设备（FPGA 基础区域），从给定的设备特性列表中发现特性设备及其私有特性，并为特性设备（例如 FME、端口和 AFU）创建平台设备，并在容器设备下分配相关资源。它还抽象了私有特性的操作，并向特性设备驱动程序暴露通用操作。
FPGA DFL 设备可能是指不同的硬件类型，例如 PCIe 设备、平台设备等。一旦系统创建了该设备，其驱动模块就会首先加载。这个驱动在驱动架构中扮演基础设施的角色。它定位设备内存中的DFL，并处理这些DFL及相关资源，为DFL框架提供通用接口以进行枚举（请参阅 `drivers/fpga/dfl.c` 获取详细的枚举API）。

FPGA管理引擎（FME）驱动是一个平台驱动，在从DFL设备模块创建FME平台设备后会自动加载。它提供了FPGA管理的关键功能，包括：

a) 暴露静态FPGA区域信息，如版本和元数据
用户可以通过由FME驱动暴露的sysfs接口读取相关信息。
b) 部分重构。FME驱动在初始化PR子功能时创建FPGA管理器、FPGA桥接器和FPGA区域。一旦收到用户发起的DFL_FPGA_FME_PORT_PR ioctl调用，它将调用来自FPGA区域的通用接口函数来完成给定端口的部分重构操作。

与FME驱动类似，FPGA加速功能单元（AFU）驱动在AFU平台设备创建后也会被探测到。此模块的主要功能是为用户空间应用程序提供访问各个加速器的接口，包括基本的端口重置控制、AFU MMIO区域导出以及DMA缓冲区映射服务功能。

在创建功能平台设备后，相应的平台驱动会自动加载以处理不同的功能。关于已经在该DFL框架下实现的功能单元的详细信息，请参阅后续章节。

部分重构
==========
如上所述，可以通过部分重构PR比特流文件来重新配置加速器。PR比特流文件必须是为确切的静态FPGA区域和目标可重构区域（端口）生成的，否则，重构操作将会失败并可能导致系统不稳定。这种兼容性可以通过比较PR比特流文件头部中记录的兼容性ID与目标FPGA区域暴露的compat_id来进行检查。通常情况下，这项检查会在用户空间调用重构IOCTL之前完成。

FPGA虚拟化 - PCIe SRIOV
==========================
本节描述了基于DFL的FPGA设备上的虚拟化支持，以使运行在虚拟机（VM）中的应用程序能够访问加速器。本节仅描述支持SRIOV的PCIe基FPGA设备。
特定FPGA设备支持的功能通过设备特性列表暴露，如下图所示：

```
+-------------------------------+  +-------------+
|              PF               |  |     VF      |
+-------------------------------+  +-------------+
    ^            ^         ^              ^
    |            |         |              |
+-----|------------|---------|--------------|-------+
|     |            |         |              |       |
|  +-----+     +-------+ +-------+      +-------+   |
|  | FME |     | Port0 | | Port1 |      | Port2 |   |
|  +-----+     +-------+ +-------+      +-------+   |
|                  ^         ^              ^       |
|                  |         |              |       |
|              +-------+ +------+       +-------+   |
|              |  AFU  | |  AFU |       |  AFU  |   |
|              +-------+ +------+       +-------+   |
|                                                   |
|            基于DFL的FPGA PCIe 设备                |
+---------------------------------------------------+
```

FME始终通过物理功能（PF）进行访问。
端口（及其相关的AFU）默认通过PF进行访问，但也可以通过PCIe SRIOV经由虚拟功能（VF）设备暴露。每个VF仅包含1个端口和1个AFU以实现隔离。用户可以通过PCIe SRIOV接口创建单独的VF（加速器），并将其分配给虚拟机。
下面图示了在虚拟化情况下的驱动程序组织：

```
+-------++------++------+             |
| FME   || FME  || FME  |             |
| FPGA  || FPGA || FPGA |             |
|Manager||Bridge||Region|             |
+-------++------++------+             |
+-----------------------+  +--------+ |             +--------+
|          FME          |  |  AFU   | |             |  AFU   |
|         Module        |  | Module | |             | Module |
+-----------------------+  +--------+ |             +--------+
          +-----------------------+       |       +-----------------------+
          | FPGA Container Device |       |       | FPGA Container Device |
          |  (FPGA Base Region)   |       |       |  (FPGA Base Region)   |
          +-----------------------+       |       +-----------------------+
            +------------------+          |         +------------------+
            | FPGA PCIE Module |          | Virtual | FPGA PCIE Module |
            +------------------+   Host   | Machine +------------------+
   -------------------------------------- | ------------------------------
             +---------------+            |          +---------------+
             | PCI PF Device |            |          | PCI VF Device |
             +---------------+            |          +---------------+
```

一旦检测到FPGA PCIe PF或VF设备，FPGA PCIe设备驱动程序总是最先加载。它：
* 使用来自DFL框架的通用接口完成对FPGA PCIe PF和VF设备的枚举
* 支持SRIOV
在该驱动程序架构中，FME设备驱动程序扮演管理角色，它提供了ioctl来从PF释放端口并将端口分配给PF。在从PF释放一个端口之后，就可以安全地通过PCIe SRIOV的sysfs接口将此端口暴露给VF。
为了使应用程序能够在虚拟机中访问加速器，需要按照以下步骤将相应AFU的端口分配给VF：

1. 默认情况下，PF拥有所有AFU端口。任何需要重新分配给VF的端口都必须首先通过在FME设备上执行DFL_FPGA_FME_PORT_RELEASE ioctl来释放。
2. 一旦从PF释放了N个端口，那么用户可以使用下面的命令来启用SRIOV和VF。每个VF只拥有一个带有AFU的端口：

```
echo N > $PCI_DEVICE_PATH/sriov_numvfs
```

3. 将VF传递给VM。

4. 在VF下的AFU可以从VM中的应用程序访问（使用VF内部相同的驱动程序）
需要注意的是，FME不能分配给VF，因此PR和其他管理功能只能通过PF获得。
### 设备枚举
本节介绍应用程序如何从/sys/class/fpga_region下的sysfs层次结构枚举FPGA设备。
在下面的例子中，主机安装了两个基于DFL的FPGA设备。每个FPGA设备有一个FME和两个端口（AFU）。
FPGA区域在`/sys/class/fpga_region/`下创建：

	/sys/class/fpga_region/region0
	/sys/class/fpga_region/region1
	/sys/class/fpga_region/region2
	..
应用程序需要搜索每个`regionX`文件夹，如果找到特征设备（例如，“dfl-port.n”或“dfl-fme.m”被找到），则它是代表FPGA设备的基本FPGA区域。
每个基本区域都有一个FME和两个端口（AFU）作为子设备：

	/sys/class/fpga_region/region0/dfl-fme.0
	/sys/class/fpga_region/region0/dfl-port.0
	/sys/class/fpga_region/region0/dfl-port.1
	..
/sys/class/fpga_region/region3/dfl-fme.1
	/sys/class/fpga_region/region3/dfl-port.2
	/sys/class/fpga_region/region3/dfl-port.3
	..

通常情况下，FME/AFU的sysfs接口以如下方式命名：

	/sys/class/fpga_region/<regionX>/<dfl-fme.n>/
	/sys/class/fpga_region/<regionX>/<dfl-port.m>/

其中'n'连续编号所有FME，'m'连续编号所有端口。
用于ioctl()或mmap()的设备节点可以通过以下方式引用：

	/sys/class/fpga_region/<regionX>/<dfl-fme.n>/dev
	/sys/class/fpga_region/<regionX>/<dfl-port.n>/dev

性能计数器
===========
性能报告是FME中实现的一个私有特性。它可以支持多个独立的、系统范围内的硬件设备计数集来监控和统计性能事件，包括“基本”、“缓存”、“结构”、“vtd”和“vtd_sip”计数器。用户可以使用标准的perf工具来监控FPGA的缓存命中率、事务数量、AFU接口时钟计数等其他FPGA性能事件。
不同的FPGA设备可能有不同的计数集，这取决于硬件实现。例如，一些离散FPGA卡没有缓存。用户可以使用“perf list”检查目标硬件支持哪些性能事件。
为了允许用户使用标准的perf API访问这些性能计数器，驱动程序创建了一个perf PMU，并在`/sys/bus/event_source/devices/dfl_fme*`中创建了相关的sysfs接口，以描述可用的性能事件和配置选项。
“format”目录描述了struct `perf_event_attr`中的config字段的格式。config有3个位字段：`evtype`定义了性能事件属于哪种类型；`event`是该类别内事件的身份标识；`portid`被引入以决定是在FPGA整体数据还是特定端口上监视计数集。
“events”目录描述了所有可用事件的配置模板，可以直接与perf工具一起使用。例如，fab_mmio_read具有配置“event=0x06,evtype=0x02,portid=0xff”，这表明此事件属于结构类型（0x02），本地事件ID为0x06，并且用于整体监控（portid=0xff）。
示例使用 `perf` 命令:

  ```
  $ perf list | grep dfl_fme
  
  dfl_fme0/fab_mmio_read/                              [内核性能监控单元事件]
  <...>
  dfl_fme0/fab_port_mmio_read,portid=?/                [内核性能监控单元事件]
  <...>
  
  $ perf stat -a -e dfl_fme0/fab_mmio_read/ <command>
  或
  $ perf stat -a -e dfl_fme0/event=0x06,evtype=0x02,portid=0xff/ <command>
  或
  $ perf stat -a -e dfl_fme0/config=0xff2006/ <command>
  ```

另一个例子，`fab_port_mmio_read` 监控特定端口的内存映射I/O读取。因此
其配置模板为 "event=0x06,evtype=0x01,portid=?"。端口号
应当明确设定。
使用 `perf` 的方法如下:

  ```
  $ perf stat -a -e dfl_fme0/fab_port_mmio_read,portid=0x0/ <command>
  或
  $ perf stat -a -e dfl_fme0/event=0x06,evtype=0x02,portid=0x0/ <command>
  或
  $ perf stat -a -e dfl_fme0/config=0x2006/ <command>
  ```

请注意对于结构化计数器而言，整体性能事件（fab_*）和端口性能事件
（fab_port_*）在硬件中实际上共用一组计数器，所以不能同时监控这两者。如果这组计数器被配置来监控整体数据，则不支持每个端口的性能数据。请看下面的例子:

  ```
  $ perf stat -e dfl_fme0/fab_mmio_read/,dfl_fme0/fab_port_mmio_write,portid=0/ sleep 1
  
  系统范围内的性能计数统计:
  
                 3      dfl_fme0/fab_mmio_read/
   <不支持>      dfl_fme0/fab_port_mmio_write,portid=0x0/
  
       1.001750904 秒已过
  ```

驱动程序还提供了一个 "cpumask" 的 sysfs 属性，其中只包含一个用于访问这些性能事件的 CPU ID。不允许多个 CPU 进行计数，因为它们是 FPGA 设备上的系统范围计数器。
当前驱动程序不支持采样。因此，“perf record” 不受支持。

中断支持
=========
一些 FME 和 AFU 特性能够生成中断。如上所述，用户可以调用 ioctl (DFL_FPGA_*_GET_IRQ_NUM) 来了解该特性是否支持以及支持多少个中断。驱动程序还实现了基于 eventfd 的中断处理机制，当发生中断时用户可以通过这种方式得到通知。用户可以通过 ioctl (DFL_FPGA_*_SET_IRQ) 将 eventfds 设置到驱动程序，并随后通过轮询或 select 这些 eventfds 来等待通知。
在当前的 DFL 中，有三个子特性（端口错误、FME 全局错误和 AFU 中断）支持中断。

添加新的功能接口单元 (FIU) 支持
=================================
有可能开发者会在 DFL 框架下开发一些新的功能模块 (FIU)，那么就需要为这个新特性设备 (FIU) 开发一个新的平台设备驱动，方式与现有的特性设备驱动相同（例如：FME 和端口/AFU 平台设备驱动）。除此之外，还需要修改 DFL 框架中的枚举代码以检测新的 FIU 类型并创建相关的平台设备。

添加新的私有特性支持
=====================
在某些情况下，我们可能需要向现有的功能接口单元 (FIU) 添加一些新的私有特性（例如：FME 或端口）。开发者不需要修改 DFL 框架中的枚举代码，因为每个私有特性都会被自动解析，并且相关内存映射 I/O 资源可以在由 DFL 框架创建的功能接口单元平台设备下找到。
开发者只需要提供与特征 ID 匹配的子特性驱动即可。
FME 部分重构子特性驱动（参见 drivers/fpga/dfl-fme-pr.c）可以作为一个参考。

请参考以下链接获取现有特征 ID 表格及申请新特征 ID 的指南。
PCI 设备上的 DFL 位置
======================

最初查找 PCI 设备上 DFL 的方法假设第一个 DFL 从 BAR 0 的偏移量 0 开始。如果 DFL 的第一个节点是 FME，则端口中的其他 DFL 由 FME 头部寄存器指定。或者，可以使用 PCIe 的供应商特定功能结构来指定设备上所有 DFL 的位置，这为 DFL 中起始节点的类型提供了灵活性。Intel 已经为此目的预留了 VSEC ID 0x43。供应商特定数据以一个 4 字节的供应商特定寄存器开始，用于记录 DFL 的数量，随后是每个 DFL 的 4 字节偏移/BAR (BIR) 供应商特定寄存器。偏移/BIR 寄存器的位 2:0 表示 BAR，而位 31:3 表示 8 字节对齐的偏移量，其中位 2:0 为零。
```
+----------------------------+
|31     Number of DFLS      0|
+----------------------------+
|31     Offset     3|2 BIR  0|
+----------------------------+
                      . .
+----------------------------+
|31     Offset     3|2 BIR  0|
+----------------------------+
```

考虑过允许每个 BAR 指定多个 DFL，但最终认为该用例没有提供价值。为每个 BAR 指定单个 DFL 简化了实现，并允许进行额外的错误检查。

用户空间驱动程序支持 DFL 设备
==================================

FPGA 的目的是被重新编程以集成新开发的硬件组件。新的硬件可以在 DFL 中实例化一个新的私有特性，并在系统中呈现一个 DFL 设备。在某些情况下，用户可能需要一个用户空间驱动程序来驱动 DFL 设备：

- 用户可能需要为他们的硬件运行一些诊断测试
- 用户可能希望在用户空间中原型化内核驱动程序
- 有些硬件是为特定用途设计的，并不符合标准内核子系统的任何一种
这要求直接访问 MMIO 空间和来自用户空间的中断处理。uio_dfl 模块为此目的暴露了 UIO 设备接口。

目前，uio_dfl 驱动程序仅支持 Ether Group 子特性，该特性在硬件中没有 IRQ。因此，此驱动程序中未添加中断处理。

应选择 UIO_DFL 来启用 uio_dfl 模块驱动程序。为了通过 UIO 直接访问支持新的 DFL 特性，应将它的特征 ID 添加到驱动程序的 id_table 中。
开放讨论
===============
FME 驱动现在为部分重构向用户导出了一个 ioctl（DFL_FPGA_FME_PORT_PR）。将来，如果添加了统一的用户界面用于重构，FME 驱动应当从 ioctl 接口切换到这些统一接口。
