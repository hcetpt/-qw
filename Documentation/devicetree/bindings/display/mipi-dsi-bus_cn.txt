MIPI DSI（显示串行接口）总线
==========================================

MIPI 显示串行接口指定了一个串行总线及协议，用于主机与最多四个外围设备之间的通信。本文档将定义在设备树中表示DSI总线所使用的语法。本文档仅描述DSI总线特有的属性或在DSI总线的上下文中定义现有的标准属性。
每个DSI主机提供一条DSI总线。DSI主机控制器节点包含一系列表征该总线特性的属性。子节点则描述该总线上各个外围设备。
以下假设只有一个外围设备连接到DSI主机。经验表明，对于大多数配置情况这是正确的。
DSI主机
========

除了标准属性以及由DSI主机的父总线定义的属性外，下列属性适用于代表DSI主机的节点：
必需属性：
- #address-cells：表示总线上地址所需的单元格数量。DSI外围设备通过2位虚拟通道号进行寻址，因此单个总线上最多可以寻址4个设备。因此，此属性的值应为1。
- #size-cells：应当是0。存在一些特殊情况，使用其他值可能是有意义的，详情见下文。
可选属性：
- clock-master：布尔值。如果主机与其他DSI主机一起使用以驱动同一外围设备，则应当启用此属性。支持此类配置的硬件通常需要两个总线上的数据由同一个时钟驱动。仅控制该时钟的DSI主机实例应该包含此属性。
DSI外围设备
==============

具有DSI作为控制总线，或者没有控制总线的外围设备
------------------------------------------------------

具有DSI总线作为主要控制总线的外围设备，或者虽无控制总线但使用DSI总线传输像素数据的外围设备，被表示为DSI主机节点的子节点。此处描述的属性适用于所有DSI外围设备，但个别绑定可能希望定义额外的、特定于设备的属性。
必需属性：
- reg：DSI外围设备的虚拟通道号。必须位于0至3的范围内。
一些DSI外设对不止一个虚拟通道作出响应。在这种情况下，可以选择两种表示方式：
- `reg` 属性可以有多个条目，每个该外设响应的虚拟通道对应一个条目。
- 如果外设响应的虚拟通道是连续的，可以将 `#size-cells` 设置为1。`reg` 属性中的每个条目的第一个单元是第一个虚拟通道的编号，第二个单元是连续虚拟通道的数量。

具有不同控制总线的外设
------------------------

有些外设有I2C/SPI（或某些非DSI总线）作为主要控制总线，但也连接到DSI总线（主要用于数据路径）。这种外设与DSI主机之间的连接可以通过图绑定[1]、[2]来表示。

支持双通道DSI的外设
----------------------

对于带宽需求较高的外设，可以连接到两个DSI总线上。每个DSI总线/通道驱动一部分像素数据（通常是显示屏每一行的左半部分或右半部分，或者偶数行或奇数行）。
应使用图绑定来表示连接到这类外设的多个DSI总线。每个DSI主机的输出端点可以链接到DSI外设的输入端点。

示例
----

- (1)、(2) 和 (3) 是DSI主机和外设在DSI总线上的示例，具有不同的虚拟通道配置。
- (4) 是一个通过of-graph绑定连接到DSI主机的I2C控制总线上的外设的示例。
- (5) 是一个使用I2C作为其主要控制总线的双通道DSI外设由两个DSI主机驱动的示例。

1)
```
dsi-host {
	..
#address-cells = <1>;
	#size-cells = <0>;

	/* 外设响应虚拟通道 0 */
	peripheral@0 {
		compatible = "...";
		reg = <0>;
	};

	..
}
```

在这个示例中，`dsi-host` 表示DSI主机节点，并且有一个外设（`peripheral@0`）连接到它。`reg` 属性中的值 `<0>` 表示这个外设响应虚拟通道 0。
Here are the translations for the provided Device Tree fragments:

2)
```yaml
dsi-host {
    ..
#address-cells = <1>;
    #size-cells = <0>;

    /* 外设响应虚拟通道 0 和 2 */
    peripheral@0 {
        compatible = "...";
        reg = <0, 2>;
    };

    ..
};
```

3)
```yaml
dsi-host {
    ..
#address-cells = <1>;
    #size-cells = <1>;

    /* 外设响应虚拟通道 1、2 和 3 */
    peripheral@1 {
        compatible = "...";
        reg = <1 3>;
    };

    ..
};
```

4)
```yaml
i2c-host {
    ..
dsi-bridge@35 {
        compatible = "...";
        reg = <0x35>;

        ports {
            ..
port {
                bridge_mipi_in: endpoint {
                    remote-endpoint = <&host_mipi_out>;
                };
            };
        };
    };
};

dsi-host {
    ..
ports {
        ..
port {
            host_mipi_out: endpoint {
                remote-endpoint = <&bridge_mipi_in>;
            };
        };
    };
};
```

5)
```yaml
i2c-host {
    dsi-bridge@35 {
        compatible = "...";
        reg = <0x35>;

        ports {
            #address-cells = <1>;
            #size-cells = <0>;

            port@0 {
                reg = <0>;
                dsi0_in: endpoint {
                    remote-endpoint = <&dsi0_out>;
                };
            };

            port@1 {
                reg = <1>;
                dsi1_in: endpoint {
                    remote-endpoint = <&dsi1_out>;
                };
            };
        };
    };
};

dsi0-host {
    ..
/*
     * 这个 DSI 实例为两个主机控制器提供时钟信号
     */
    clock-master;

    ports {
        ..
```
Please note that the last fragment is incomplete in your original text, so the translation also ends with the incomplete part. If you have more details or need further clarification, feel free to ask!
这段配置似乎是用在设备树（Device Tree）中的描述，用于定义硬件连接关系。下面是对这段配置的中文翻译：

```
{
  端口 {
    dsi0_out: 终端点 {
      远程终端点 = <&dsi0_in>;
    };
  };
};

{
  dsi1-主机 {
    ...
  端口 {
    ...
    端口 {
      dsi1_out: 终端点 {
        远程终端点 = <&dsi1_in>;
      };
    };
  };
  };
}
```

简单解释一下：
- `port`：表示一个物理端口。
- `endpoint`：表示一个终端点或端点。
- `remote-endpoint`：表示与当前终端点相对应的另一个终端点。
- `dsi0_out` 和 `dsi1_out`：表示输出方向的终端点名称。
- `dsi0_in` 和 `dsi1_in`：表示输入方向的终端点名称。

这意味着 `dsi0_out` 与 `dsi0_in` 是一对相互连接的终端点，而 `dsi1_out` 与 `dsi1_in` 同样是另一对相互连接的终端点。
