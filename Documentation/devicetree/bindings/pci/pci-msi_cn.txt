此文档描述了用于描述 PCI 设备与 MSI 控制器之间关系的通用设备树绑定。
根复合体下的每个 PCI 设备通过其请求者 ID（简称 RID）唯一标识。请求者 ID 是由总线号、设备号和功能号组成的三元组。
为了本文件的目的，当作为数值处理时，RID 的格式如下：

* 位 [15:8] 是总线号
* 位 [7:3] 是设备号
* 位 [2:0] 是功能号
* 任何用于填充所需的其他位必须为零

MSI 可以部分地通过随写操作附带的边带数据来区分。对于 PCI 设备而言，这种边带数据可以源自请求者 ID。需要一种机制将设备与其可以寻址的 MSI 控制器以及与其对这些控制器的写操作相关的边带数据关联起来。
关于通用 MSI 绑定，请参阅 Documentation/devicetree/bindings/interrupt-controller/msi.txt
PCI 根复合体
=============

可选属性
---------

- msi-map：将一个请求者 ID 映射到一个 MSI 控制器及其关联的 msi-specifier 数据。该属性是任意数量的元组 (rid-base, msi-controller, msi-base, length)，其中：

  * rid-base 是一个单元格，描述该条目匹配的第一个 RID
  * msi-controller 是指向一个 MSI 控制器的单个 phandle

  * msi-base 是一个 msi-specifier，描述该条目匹配的第一个 RID 所产生的 msi-specifier
* `length` 是一个单个单元，描述紧接着 `rid-base` 后匹配的连续 RID 数量。
    任何位于区间 `[rid-base, rid-base + length)` 内的 RID `r` 都与列出的 `msi-controller` 相关联，并且具有 `msi-specifier` 值 `(r - rid-base + msi-base)`
* `msi-map-mask`: 一个在每个请求者 ID 被映射到 `msi-specifier` 之前需要应用的掩码，根据 `msi-map` 属性进行映射。
* `msi-parent`: 描述了根复合体自身的 MSI 父级。当根复合体和 MSI 控制器不通过侧带数据来写入 MSI 时，此属性可用于描述根复合体下 PCI 设备所使用的 MSI 控制器（如果在根复合体绑定中如此定义的话）。

示例 (1)
========

```
/ {
	#address-cells = <1>;
	#size-cells = <1>;

	msi: msi-controller@a {
		reg = <0xa 0x1>;
		compatible = "vendor,some-controller";
		msi-controller;
		#msi-cells = <1>;
	};

	pci: pci@f {
		reg = <0xf 0x1>;
		compatible = "vendor,pcie-root-complex";
		device_type = "pci";

		/*
		 * 提供给 MSI 控制器的侧带数据是 RID，采用身份映射
*/
		msi-map = <0x0 &msi_a 0x0 0x10000>,
	};
};
```

示例 (2)
========

```
/ {
	#address-cells = <1>;
	#size-cells = <1>;

	msi: msi-controller@a {
		reg = <0xa 0x1>;
		compatible = "vendor,some-controller";
		msi-controller;
		#msi-cells = <1>;
	};

	pci: pci@f {
		reg = <0xf 0x1>;
		compatible = "vendor,pcie-root-complex";
		device_type = "pci";

		/*
		 * 提供给 MSI 控制器的侧带数据是 RID，被掩码以仅保留设备和功能位
*/
		msi-map = <0x0 &msi_a 0x0 0x100>,
		msi-map-mask = <0xff>
	};
};
```

示例 (3)
========

```
/ {
	#address-cells = <1>;
	#size-cells = <1>;

	msi: msi-controller@a {
		reg = <0xa 0x1>;
		compatible = "vendor,some-controller";
		msi-controller;
		#msi-cells = <1>;
	};

	pci: pci@f {
		reg = <0xf 0x1>;
		compatible = "vendor,pcie-root-complex";
		device_type = "pci";

		/*
		 * 提供给 MSI 控制器的侧带数据是 RID，但忽略总线编号的高位
*/
		msi-map = <0x0000 &msi 0x0000 0x8000>,
			  <0x8000 &msi 0x0000 0x8000>;
	};
};
```

示例 (4)
========

```
/ {
	#address-cells = <1>;
	#size-cells = <1>;

	msi: msi-controller@a {
		reg = <0xa 0x1>;
		compatible = "vendor,some-controller";
		msi-controller;
		#msi-cells = <1>;
	};

	pci: pci@f {
		reg = <0xf 0x1>;
		compatible = "vendor,pcie-root-complex";
		device_type = "pci";

		/*
		 * 提供给 MSI 控制器的侧带数据是 RID，但取反总线编号的高位
*/
		msi-map = <0x0000 &msi 0x8000 0x8000>,
			  <0x8000 &msi 0x0000 0x8000>;
	};
};
```

示例 (5)
========

```
/ {
	#address-cells = <1>;
	#size-cells = <1>;

	msi_a: msi-controller@a {
		reg = <0xa 0x1>;
		compatible = "vendor,some-controller";
		msi-controller;
		#msi-cells = <1>;
	};

	msi_b: msi-controller@b {
		reg = <0xb 0x1>;
		compatible = "vendor,some-controller";
		msi-controller;
		#msi-cells = <1>;
	};

	msi_c: msi-controller@c {
		reg = <0xc 0x1>;
		compatible = "vendor,some-controller";
		msi-controller;
		#msi-cells = <1>;
	};

	pci: pci@f {
		reg = <0xf 0x1>;
		compatible = "vendor,pcie-root-complex";
		device_type = "pci";

		/*
		 * 提供给 MSI 控制器 a 的侧带数据是 RID，但取反总线编号的高位
* 提供给 MSI 控制器 b 的侧带数据是 RID，采用身份映射
```
这段代码似乎是某种配置或者描述语言的一部分（如 Device Tree Blob (DTB) 在 Linux 内核中用于硬件描述），涉及到MSI（Message Signaled Interrupts）控制器的映射。以下是中文翻译：

```
* MSI 控制器 C 不可寻址
*
* msi 映射 = <0x0000 &msi_a 0x8000 0x08000>,
*             <0x8000 &msi_a 0x0000 0x08000>,
*             <0x0000 &msi_b 0x0000 0x10000>;
* };
* };
```

这里的注释说明了 `MSI 控制器 C` 无法被访问（即不可寻址）。接下来的部分定义了其他 MSI 控制器（可能是 A 和 B）的映射关系，这些数字和符号是用来描述特定的内存区域或中断范围的。
