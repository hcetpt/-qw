此文档描述了内核内的设备树覆盖功能的实现，该功能位于`drivers/of/overlay.c`中，并且是与Documentation/devicetree/dynamic-resolution-notes.rst[1]配套的文档。

### 覆盖的工作原理

设备树覆盖的目的在于修改内核的实时树，并使这些修改以反映变化的方式影响内核的状态。由于内核主要处理设备，因此任何新的设备节点如果导致一个活动设备的出现，应该创建相应的设备；如果设备节点被禁用或完全移除，则受影响的设备应该被注销。
我们来看一个例子，有一个名为foo的板子，其基本的设备树如下所示：

```plaintext
---- foo.dts ---------------------------------------------------------------
/* FOO平台 */
/dts-v1/;
/ {
    compatible = "corp,foo";

    /* 共享资源 */
    res: res {
    };

    /* 片上外设 */
    ocp: ocp {
        /* 始终实例化的外设 */
        peripheral1 { ... };
    };
};
---- foo.dts ---------------------------------------------------------------
```

覆盖文件bar.dts通过标签定位目标位置：
```plaintext
---- bar.dts - overlay target location by label ----------------------------
/dts-v1/;
/plugin/;
&ocp {
    /* bar外设 */
    bar {
        compatible = "corp,bar";
        ... /* 各种属性和子节点 */
    };
};
---- bar.dts ---------------------------------------------------------------
```

加载并解析（如[1]所述）后，应该得到foo+bar.dts：

```plaintext
---- foo+bar.dts -----------------------------------------------------------
/* FOO平台 + bar外设 */
/ {
    compatible = "corp,foo";

    /* 共享资源 */
    res: res {
    };

    /* 片上外设 */
    ocp: ocp {
        /* 始终实例化的外设 */
        peripheral1 { ... };

        /* bar外设 */
        bar {
            compatible = "corp,bar";
            ... /* 各种属性和子节点 */
        };
    };
};
---- foo+bar.dts -----------------------------------------------------------
```

由于覆盖操作，一个新的设备节点（bar）被创建，因此会注册一个bar平台设备，如果加载了匹配的设备驱动程序，则会按预期创建该设备。
如果基础设备树没有使用-@选项编译，则"&ocp"标签将不可用于解析覆盖节点到基础设备树中的正确位置。在这种情况下，可以提供目标路径。使用标签语法来指定目标位置是首选方式，因为这样可以在包含该标签的任何基础设备树中应用覆盖，无论该标签在设备树中的位置如何。
上述bar.dts示例修改为使用显式路径语法：

```plaintext
---- bar.dts - overlay target location by explicit path --------------------
/dts-v1/;
/plugin/;
&{/ocp} {
    /* bar外设 */
    bar {
        compatible = "corp,bar";
        ... /* 各种属性和子节点 */
    }
};
---- bar.dts ---------------------------------------------------------------
```

### 内核API

API非常易于使用：
1. 调用`of_overlay_fdt_apply()`来创建并应用覆盖更改集。返回值是一个错误或者一个标识此覆盖的cookie。
2. 调用`of_overlay_remove()`来删除并清理之前通过调用`of_overlay_fdt_apply()`创建的覆盖更改集。不允许删除被其他覆盖堆叠的覆盖更改集。
最后，如果你需要一次性移除所有覆盖，只需调用`of_overlay_remove_all()`，它将以正确的顺序移除每一个覆盖。
可以选择注册在覆盖操作时被调用的通知器。详情见`of_overlay_notifier_register/unregister`和枚举`of_overlay_notify_action`。
对于OF_OVERLAY_PRE_APPLY、OF_OVERLAY_POST_APPLY或OF_OVERLAY_PRE_REMOVE的通知器回调可以存储覆盖中设备树节点的指针或其内容，但这些指针必须在OF_OVERLAY_POST_REMOVE通知器回调之后不再持久化。在调用了OF_OVERLAY_POST_REMOVE通知器之后，覆盖的内存会被`kfree()`释放。请注意，即使OF_OVERLAY_POST_REMOVE通知器返回错误，内存也会被`kfree()`释放。
动态配置文件 `drivers/of/dynamic.c` 中的变化集通知器是第二种可能因应用或移除覆盖层而被触发的通知器类型。这些通知器不允许存储覆盖层内的设备树节点指针或其内容。覆盖层代码没有保护措施来防止在移除覆盖层导致相关内存被释放时，这类指针仍然有效。

任何保留指向覆盖层节点或数据的指针的其他代码都被认为是错误，因为在移除覆盖层后，该指针将指向已释放的内存。

使用覆盖层的用户必须特别注意系统上发生的整体操作，以确保其他内核代码不会保留任何指向覆盖层节点或数据的指针。一个无意中使用这类指针的例子是：如果一个驱动程序或子系统模块在应用了覆盖层之后被加载，并且该驱动程序或子系统扫描整个设备树或其很大一部分，包括覆盖层节点。
