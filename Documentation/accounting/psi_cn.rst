### PSI - 压力停滞信息

**日期：** 2018年4月  
**作者：** Johannes Weiner <hannes@cmpxchg.org>

当CPU、内存或I/O设备资源紧张时，工作负载会经历延迟峰值、吞吐量损失，并且面临因内存不足而被终止的风险。如果没有准确的压力衡量指标，用户不得不选择保守地使用硬件资源以避免过载，或者冒险承受过度使用导致的频繁中断。

PSI（压力停滞信息）功能识别并量化了由资源紧张造成的干扰及其对复杂工作负载乃至整个系统时间上的影响。通过准确地衡量因资源稀缺而导致的生产力损失，可以帮助用户根据硬件规模调整工作负载，或按照工作负载的需求来配置硬件。

由于PSI可以实时汇总这些信息，因此可以通过诸如卸载负载、将任务迁移到其他系统或数据中心，或战略性地暂停或终止低优先级或可重启的批量作业等方法来动态管理系统。这样可以在不牺牲工作负载健康或避免重大中断（如内存不足杀进程）的情况下最大化硬件利用率。

### 压力接口

每种资源的压力信息都通过`/proc/pressure/`目录下的相应文件导出 —— 包括CPU、内存和I/O。
其格式如下：

```
some avg10=0.00 avg60=0.00 avg300=0.00 total=0
full avg10=0.00 avg60=0.00 avg300=0.00 total=0
```

`some` 行表示至少有一些任务在给定资源上停滞的时间占比。
`full` 行表示所有非空闲任务同时在给定资源上停滞的时间占比。在这种状态下，实际的CPU周期正在浪费，长时间处于这种状态的工作负载被认为是处于挣扎状态。这对性能有严重影响，并且区分这种情况与仅有一部分任务停滞但CPU仍在做有效工作的状态非常有用。因此，专门跟踪并在此停滞子状态中花费的时间，并在`full`平均值中导出。
系统级别的CPU全停滞是未定义的，但从5.13版本开始报告，因此为了向后兼容性，将其设置为零。
这些比例（以百分比表示）在最近的十秒、六十秒和三百秒窗口内作为趋势进行跟踪，这有助于了解短期事件以及中长期趋势。总的绝对停滞时间（以微秒为单位）也被跟踪并导出，以便检测那些不一定会影响平均时间或自定义时间段内的平均趋势的延迟峰值。

### 监控压力阈值

用户可以注册触发器并使用`poll()`来在资源压力超过特定阈值时被唤醒。
一个触发器描述了在特定时间窗口内的最大累计停滞时间，例如，在任何500毫秒窗口内总停滞时间为100毫秒，以此来生成唤醒事件。
为了注册一个触发器，用户需要打开代表要监控资源的`/proc/pressure/`下的psi接口文件，并写入所需的阈值和时间窗口。应当使用打开的文件描述符通过`select()`、`poll()`或`epoll()`等待触发器事件。
以下是一个格式示例：

	<some|full> <停滞量（微秒）> <时间窗口（微秒）>

例如，在`/proc/pressure/memory`中写入“some 150000 1000000”会为在1秒时间窗口内测量的部分内存停滞添加150毫秒的阈值。而在`/proc/pressure/io`中写入“full 50000 1000000”则会为在1秒时间窗口内测量的完全I/O停滞添加50毫秒的阈值。
可以在多个psi指标上设置触发器，也可以为相同的psi指标指定多个触发器。但是，对于每个触发器都需要一个单独的文件描述符，以便能够独立于其他触发器进行轮询，因此即使打开的是同一个psi接口文件，对于每个触发器也应分别调用`open()`系统调用。向已存在psi触发器的文件描述符执行写操作将会因为EBUSY而失败。
当系统进入所监控的psi指标的停滞状态时，监控器才会激活，并且在退出停滞状态时停用。当系统处于停滞状态时，以每跟踪窗口10次的速率监测psi信号的增长。
内核接受的时间窗口范围从500毫秒到10秒，因此最小的监控更新间隔是50毫秒，最大的是1秒。最小限制是为了防止过于频繁的轮询。最大限制选择了一个足够高的数值，在这个数值之后，大多数情况下不再需要监控器，而可以使用psi平均值。
非特权用户也可以创建监控器，唯一的限制是时间窗口必须是2秒的倍数，以防止过度使用资源。
当激活时，psi监控器至少保持活动一个跟踪窗口的持续时间，以避免系统在停滞状态与非停滞状态之间反复切换时的重复激活和停用。
向用户空间的通知被限制速率，每个跟踪窗口仅通知一次。
当用于定义触发器的文件描述符被关闭时，触发器将注销。

用户空间监控器使用示例
===============================

::

  #include <errno.h>
  #include <fcntl.h>
  #include <stdio.h>
  #include <poll.h>
  #include <string.h>
  #include <unistd.h>

  /*
   * 使用1秒的跟踪窗口大小和150毫秒的阈值来监控内存部分阻塞
*/

int main() {
	const char trig[] = "some 150000 1000000";
	struct pollfd fds;
	int n;

	fds.fd = open("/proc/pressure/memory", O_RDWR | O_NONBLOCK);
	if (fds.fd < 0) {
		printf("/proc/pressure/memory 打开错误: %s\n",
			strerror(errno));
		return 1;
	}
	fds.events = POLLPRI;

	if (write(fds.fd, trig, strlen(trig) + 1) < 0) {
		printf("/proc/pressure/memory 写入错误: %s\n",
			strerror(errno));
		return 1;
	}

	printf("等待事件...\n");
	while (1) {
		n = poll(&fds, 1, -1);
		if (n < 0) {
			printf("poll 错误: %s\n", strerror(errno));
			return 1;
		}
		if (fds.revents & POLLERR) {
			printf("收到 POLLERR, 事件源已消失\n");
			return 0;
		}
		if (fds.revents & POLLPRI) {
			printf("事件触发!\n");
		} else {
			printf("接收到未知事件: 0x%x\n", fds.revents);
			return 1;
		}
	}

	return 0;
}

Cgroup2 接口
=================

在具有CONFIG_CGROUPS=y内核配置且挂载了cgroup2文件系统的系统中，压力阻塞信息也会针对分组到cgroup中的任务进行追踪。cgroupfs挂载点下的每个子目录都包含cpu.pressure、memory.pressure和io.pressure文件；这些文件的格式与/proc/pressure/中的文件相同。
每cgroup的压力阻塞监控器可以以与系统范围内的监控器相同的方式指定和使用。
