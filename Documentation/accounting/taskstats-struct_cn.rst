### 结构体 taskstats

####

本文档包含了对结构体 taskstats 各字段的解释。

在结构体 taskstats 中有三类不同的字段组：

1) 常规和基础会计字段
   - 如果设置了 CONFIG_TASKSTATS，那么 taskstats 接口将会被启用，并且在任务退出时（do_exit()）收集常规字段和基础会计字段的数据以交付。
   
2) 延迟会计字段
   - 这些字段位于以下两个注释之间：
     ```
     /* 延迟会计字段开始 */
     /* 延迟会计字段结束 */
     ```
   - 它们的值仅在配置了 CONFIG_TASK_DELAY_ACCT 的情况下被收集。

3) 扩展会计字段
   - 这些字段位于以下两个注释之间：
     ```
     /* 扩展会计字段开始 */
     /* 扩展会计字段结束 */
     ```
   - 它们的值仅在配置了 CONFIG_TASK_XACCT 的情况下被收集。

4) 每个任务和每个线程上下文切换计数统计

5) SMT 机器的时间会计

6) 内存回收的扩展延迟会计字段

未来的扩展应当在 taskstats 结构体末尾添加字段，不应改变结构体内各字段的相对位置。

```
struct taskstats {
1) 常规和基础会计字段:
   ```
   /* 该结构体的版本号。这个字段始终设置为 TAKSTATS_VERSION，定义于 <linux/taskstats.h> */
   __u16	version;

   /* 任务的退出码。 */
   __u32	ac_exitcode;		/* 退出状态 */

   /* 任务的会计标志，如 <linux/acct.h> 中定义的 AFORK, ASU, ACOMPAT, ACORE, 和 AXSIG 等。 */
   __u8	ac_flag;		/* 记录标志 */

   /* 任务的 nice 值。 */
   __u8	ac_nice;		/* task_nice */

   /* 启动该任务的命令名称。 */
   char	ac_comm[TS_COMM_LEN];	/* 命令名 */

   /* 任务的调度策略，如 task->policy 字段中所设置的。 */
   __u8	ac_sched;		/* 调度策略 */

   __u8	ac_pad[3];
   __u32	ac_uid;			/* 用户ID */
   __u32	ac_gid;			/* 组ID */
   __u32	ac_pid;			/* 进程ID */
   __u32	ac_ppid;		/* 父进程ID */

   /* 任务开始的时间，自1970年以来的秒数。 */
   __u32	ac_btime;		/* 开始时间 [自1970年以来的秒数] */

   /* 任务的运行时间，以微秒为单位。 */
   __u64	ac_etime;		/* 运行时间 [微秒] */

   /* 任务的用户CPU时间，以微秒为单位。 */
   __u64	ac_utime;		/* 用户CPU时间 [微秒] */

   /* 任务的系统CPU时间，以微秒为单位。 */
   __u64	ac_stime;		/* 系统CPU时间 [微秒] */

   /* 任务的小型页错误计数，如 task->min_flt 中所设置的。 */
   __u64	ac_minflt;		/* 小型页错误计数 */

   /* 任务的主要页错误计数，如 task->maj_flt 中所设置的。 */
   __u64	ac_majflt;		/* 主要页错误计数 */


2) 延迟会计字段:
   ```
   /* 延迟会计字段开始
    *
    * 直到 “延迟会计字段结束” 注释的所有值仅在启用了延迟会计的情况下可用，
    * 即使最后几个字段并不是延迟。
    *
    * xxx_count 是记录的延迟值的数量
    * xxx_delay_total 是对应的累积延迟，单位为纳秒
    *
    * xxx_delay_total 在溢出时会回绕至零
    * xxx_count 不论是否溢出都会递增
    */

   /* 等待 CPU 的延迟，当任务可运行时
    * count 和 delay_total 不是原子更新的
    */
   __u64	cpu_count;
   __u64	cpu_delay_total;

   /* 下面四个字段使用 task->delays->lock 原子更新 */

   /* 等待同步块 I/O 完成的延迟
    * 不包括 I/O 提交过程中的延迟
    */
   __u64	blkio_count;
   __u64	blkio_delay_total;

   /* 等待页面故障 I/O（仅限交换入）的延迟 */
   __u64	swapin_count;
   __u64	swapin_delay_total;

   /* CPU “实际”运行时间
    * 在某些架构上，此值会根据虚拟化导致的内核非自愿等待调整 CPU 时间
    * 累积值，单位为纳秒，没有对应的计数值，在溢出时无声地回绕至零
    */
   __u64	cpu_run_real_total;

   /* CPU “虚拟”运行时间
    * 使用内核所见的时间间隔，即不调整由于虚拟化导致的内核非自愿等待
    */
   __u64	cpu_run_virtual_total;
}
```
### 会计信息结构

1) **基本会计字段：**

    - `cpu_run_virtual_total`: 这个64位无符号整数表示CPU运行虚拟时间的累积值，单位为纳秒。该值会在溢出时默默地回绕到零，并且没有对应的计数。

    - **延迟会计字段结束**

    - 版本1在此结束

2) **扩展会计字段：**

    - **扩展会计字段开始**

    - `coremem`: 这个64位无符号整数表示任务持续时间内累积的RSS内存使用量（以兆字节-微秒为单位）。每当一个时钟周期被记入任务的系统时间时，当前的RSS使用量会被累加到这个计数器中。因此，在最后我们可以得到内存使用量乘以系统时间的结果。这样就可以计算出每个系统时间单位的平均使用量。

    - `virtmem`: 这个64位无符号整数表示任务持续时间内累积的虚拟内存使用量（以兆字节-微秒为单位）。与`coremem`类似，但是记录的是虚拟内存的使用情况。

    - `hiwater_rss`: 这个64位无符号整数表示任务持续时间内RSS使用的最高水位（以千字节为单位）。

    - `hiwater_vm`: 这个64位无符号整数表示任务持续时间内虚拟内存使用的最高水位（以千字节为单位）。

    - 下面四个字段是任务的I/O统计：

        - `read_char`: 读取的字节数。
        - `write_char`: 写入的字节数。
        - `read_syscalls`: 读取系统调用次数。
        - `write_syscalls`: 写入系统调用次数。

    - **扩展会计字段结束**

3) **每任务和每线程统计：**

    - `nvcsw`: 自愿上下文切换计数器（64位无符号整数）。
    - `nivcsw`: 非自愿上下文切换计数器（64位无符号整数）。

4) **SMT机器的时间会计：**

    - `ac_utimescaled`: 用户时间根据频率等进行缩放（64位无符号整数）。
    - `ac_stimescaled`: 系统时间根据频率等进行缩放（64位无符号整数）。
    - `cpu_scaled_run_real_total`: 根据频率等缩放后的`cpu_run_real_total`（64位无符号整数）。

5) **内存回收的扩展延迟会计字段：**

    - `freepages_count`: 等待内存回收的页数（64位无符号整数）。
    - `freepages_delay_total`: 等待内存回收的总延迟时间（64位无符号整数）。

### 结构体结束
}
