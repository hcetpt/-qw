=============================
每任务统计接口
=============================

Taskstats 是一个基于 netlink 的接口，用于从内核向用户空间发送每任务和每进程的统计信息。Taskstats 设计的主要优点包括：

- 在任务生命周期中高效地提供统计信息，并在任务退出时提供。
- 为多个会计子系统提供统一的接口。
- 可扩展性，以便未来的会计补丁可以使用。

术语
----

"pid"、"tid" 和 "task" 可以互换使用，指的是由 struct task_struct 定义的标准 Linux 任务。每个 pid 的统计与每个任务的统计相同。
"tgid"、"process" 和 "thread group" 可以互换使用，指的是共享同一个 mm_struct 的任务，即传统的 Unix 进程。尽管使用了 tgid，但对线程组领导者的任务并没有特殊处理 —— 只要该进程还有属于它的任何任务存在，就认为该进程是存活的。

用法
----

为了在任务生命周期中获取统计信息，用户空间需要打开一个单播 netlink 套接字（NETLINK_GENERIC 家族），并发送命令指定一个 pid 或 tgid。
响应将包含针对特定任务的统计信息（如果指定了 pid）或针对该进程所有任务统计信息的总和（如果指定了 tgid）。
为了获取即将退出的任务的统计信息，用户空间监听器发送一个注册命令并指定一个 cpumask（CPU 面具）。每当在 cpumask 中的一个 CPU 上有任务退出时，其每任务的统计信息就会被发送到注册的监听器。使用 cpumasks 能够限制单个监听器接收到的数据量，并有助于通过 netlink 接口进行流量控制，这将在下面详细解释。
如果退出的任务是其线程组中的最后一个线程，则还会向用户空间发送一条额外记录，其中包含该线程组的每 tgid 统计信息。
这条记录包含了线程组中所有线程（无论是过去的还是现在的）的每 pid 统计信息的总和。
getdelays.c 是一个简单的实用程序，演示了如何使用 taskstats 接口来报告延迟会计统计信息。用户可以注册 cpumasks，发送命令并处理响应，监听每 tid 或 tgid 的退出数据，将接收到的数据写入文件，并通过增加接收缓冲区大小来进行基本的流量控制。

接口
----

用户与内核之间的接口封装在 `include/linux/taskstats.h` 中。

为了避免随着接口的演进使这份文档过时，这里只给出了当前版本的大纲。`taskstats.h` 总是会覆盖这里的描述。
`struct taskstats` 是针对每个进程 ID（pid）和每个线程组 ID（tgid）数据的通用会计结构。它是版本化的，并且可以随着每个添加到内核中的会计子系统的扩展而扩展。字段及其语义定义在 `taskstats.h` 文件中。

用户空间与内核空间之间交换的数据是一个属于 `NETLINK_GENERIC` 家族的 netlink 消息，并使用 netlink 属性接口。
消息格式如下：

    +----------+- - -+-------------+-------------------+
    | nlmsghdr | Pad |  genlmsghdr | taskstats payload |
    +----------+- - -+-------------+-------------------+

`taskstats` 负载有以下三种类型之一：

1. **命令**：从用户空间发送到内核空间。获取 pid 或 tgid 数据的命令包含一个类型为 `TASKSTATS_CMD_ATTR_PID/TGID` 的属性，该属性的有效载荷包含了一个 32 位的 pid 或 tgid。这个 pid 或 tgid 表示用户空间想要获取统计信息的任务或进程。注册/注销对一组 CPU 的退出数据兴趣的命令包含一个类型为 `TASKSTATS_CMD_ATTR_REGISTER/DEREGISTER_CPUMASK` 的属性，并且包含一个 CPU 面具作为其有效载荷。CPU 面具被指定为逗号分隔的 CPU 范围的 ASCII 字符串，例如要监听来自 CPU 1、2、3、5、7 和 8 的退出数据，则 CPU 面具将是 "1-3,5,7-8"。如果用户空间忘记在关闭监听套接字之前注销对 CPU 的兴趣，内核会随时间清理其兴趣集合。然而，为了效率，显式注销是可取的。
   
2. **对命令的响应**：由内核响应用户空间命令发送。负载是一系列三个类型的属性：
   
   a) `TASKSTATS_TYPE_AGGR_PID/TGID`：不包含有效载荷但表明接下来将跟随一些关于 pid 或 tgid 的统计信息
   b) `TASKSTATS_TYPE_PID/TGID`：其有效载荷是返回统计信息的 pid 或 tgid
   c) `TASKSTATS_TYPE_STATS`：其有效载荷是一个 `struct taskstats` 结构。该结构同时用于每个 pid 和每个 tgid 的统计信息
   
3. **每当任务退出时由内核发送的新消息**。负载由以下类型的属性组成：
   
   a) `TASKSTATS_TYPE_AGGR_PID`：表示接下来两个属性将是 pid 和统计信息
   b) `TASKSTATS_TYPE_PID`：包含退出任务的 pid
   c) `TASKSTATS_TYPE_STATS`：包含退出任务的每个 pid 的统计信息
   d) `TASKSTATS_TYPE_AGGR_TGID`：表示接下来两个属性将是 tgid 和统计信息
   e) `TASKSTATS_TYPE_TGID`：包含任务所属进程的 tgid
   f) `TASKSTATS_TYPE_STATS`：包含退出任务所属进程的每个 tgid 的统计信息

### 每个 tgid 的统计信息

除了提供每个任务的统计信息外，`taskstats` 还提供了每个进程的统计信息，因为资源管理通常是在进程粒度上进行的，并且仅在用户空间汇总任务统计信息可能是低效的且可能不准确（由于缺乏原子性）。但是，在内核中维护每个进程以及每个任务的统计信息存在空间和时间开销。为了解决这个问题，`taskstats` 代码会在任务退出时累积其统计信息到一个进程级别的数据结构中。当进程的最后一个任务退出时，所累积的进程级数据也会被发送到用户空间（连同每个任务的数据一起）。
当用户查询以获取每个线程组标识符（tgid）的数据时，该组中所有其他活动线程的总和会被累加，并添加到同一线程组之前已退出线程的累积总数中。

扩展 taskstats 接口
-------------------

有两种方法可以扩展 taskstats 接口以导出更多的每任务/进程统计信息，随着收集这些统计信息的补丁被加入内核，这些方法也会随之发展：

1. 在现有 `taskstats` 结构体的末尾添加更多字段。通过结构体内部的版本号来确保向后兼容性。用户空间将仅使用对应于其使用的版本的结构体字段。
2. 定义单独的统计信息结构体，并使用 netlink 属性接口返回它们。由于用户空间独立处理每个 netlink 属性，因此它总是可以忽略那些类型不理解的属性（因为它使用的是旧版本的接口）。

在 1 和 2 之间做出选择是灵活性与开销之间的权衡。如果只需要添加少量字段，则 1 是更可取的选择，因为内核和用户空间不需要承担处理新 netlink 属性的开销。但如果新字段显著扩大了现有结构体的大小，导致不同的用户空间会计工具不得不接收对其无兴趣的大结构体，则扩展属性结构将是值得的。

taskstats 的流量控制
----------------------

当任务退出率变得非常高时，监听器可能无法跟上内核发送每个线程标识符（tid）或线程组标识符（tgid）退出数据的速度，从而导致数据丢失。当 taskstats 结构体扩展并且 CPU 数量大幅增加时，这种情况会变得更加严重。

为了避免丢失统计信息，用户空间应该执行以下一项或多项操作：

- 增加用于接收退出数据的 netlink 套接字的接收缓冲区大小。
- 创建更多的监听器并减少每个监听器监听的 CPU 数量。极端情况下，可以为每个 CPU 配置一个监听器。
- 用户还可以考虑设置监听器的 CPU 亲和性，使其仅绑定到监听的那部分 CPU 上，特别是当监听器只监听单个 CPU 时。

即使采取了这些措施，如果用户空间仍然收到表示接收缓冲区溢出的 ENOBUFS 错误消息，那么它应该采取措施来处理数据丢失的问题。
