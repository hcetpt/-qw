======================
不可变的生物向量（biovecs）与生物向量迭代器
======================

肯特·奥弗斯特里特 <kmo@daterainc.com>

自3.13版本起，提交后的生物向量（biovecs）不应再被修改。
相反，我们引入了一个新的结构体`bvec_iter`来表示一个生物向量的一部分——随着生物请求（bio）的完成，该迭代器将被修改，而不是直接修改生物向量。
更具体地说，旧代码如果需要部分完成一个生物请求，则会更新`bi_sector`和`bi_size`，并将`bi_idx`递增到下一个生物向量。如果它在一个生物向量中间结束处理，那么它会增加`bv_offset`并减少`bv_len`以反映在该生物向量中已完成的字节数。
在新的方案中，所有为了部分完成生物请求而必须改变的内容都被隔离到了结构体`bvec_iter`中：`bi_sector`、`bi_size`和`bi_idx`已经被移动到这里；而不是修改`bv_offset`和`bv_len`，结构体`bvec_iter`有一个`bi_bvec_done`字段，用来表示当前生物向量中已完成的字节数。
有一系列新的辅助宏来隐藏这些细节——特别是呈现部分完成的生物向量的假象，以便常规代码不必处理`bi_bvec_done`。
* 驱动代码不应该直接引用生物向量；我们现在有了`bio_iovec()`和`bio_iter_iovec()`宏，它们返回实际的结构体`biovec`，这些是根据原始的生物向量构建的，但同时考虑了`bi_bvec_done`和`bi_size`的影响。
`bio_for_each_segment()`已经更新为接受`bvec_iter`参数，而不是整数（对应于`bi_idx`）；对于很多代码来说，转换只需要更改`bio_for_each_segment()`参数的类型即可。
* 移动`bvec_iter`的操作通过`bio_advance_iter()`进行；`bio_advance()`是一个围绕`bio_advance_iter()`的封装函数，它操作`bio->bi_iter`，同时也推进了存在的生物完整性迭代器。
存在一个较低级别的前进函数——`bvec_iter_advance()`——它接受指向生物向量的指针，而不是生物请求；这个函数被生物完整性代码所使用。
自5.12版本起，不支持长度为零的`bv_len`的生物向量段。
这一切给我们带来了什么？
=======================

拥有真正的迭代器，并使生物向量（biovecs）成为不可变的，有以下几个优点：

 * 以前，在不是一次处理一个生物向量（bvec）的情况下遍历生物（bios）非常繁琐——例如，在`block/bio.c`中的`bio_copy_data()`函数，该函数将一个生物的内容复制到另一个中。因为这些生物向量不一定大小相同，所以旧代码十分复杂——它必须同时遍历两个不同的生物，为每个生物维护`bi_idx`和当前生物向量中的偏移量。
现在的代码更为简洁明了——你可以看一下。这种模式在很多地方都会出现；许多驱动程序实际上是在自行实现生物向量迭代器，而有了通用的实现方法极大地简化了许多代码。
* 以前，任何可能需要在完成生物后使用生物向量的代码（可能是为了将数据复制到其他地方，或者如果出现错误则重新提交到其他地方）都必须保存整个生物向量数组——这在很多地方都在这样做。
* 生物向量可以在多个生物之间共享——一个生物向量迭代器可以表示现有生物向量的一个任意范围，既可以从中途开始也可以从中途结束。这是高效分割任意生物的基础。需要注意的是，这意味着我们只使用`bi_size`来确定何时到达生物的末尾，而不是`bi_vcnt`——并且`bio_iovec()`宏在构造生物向量时考虑到了`bi_size`。
* 现在，分割生物变得简单多了。旧的`bio_split()`甚至不能处理包含多于一个生物向量的生物！现在，我们可以高效地分割任意大小的生物——因为新生物可以共享旧生物的生物向量。
在分割生物时，必须小心确保在分割的生物仍在使用生物向量时不要释放它，以防原始生物先完成。在这种情况下，使用`bio_chain()`分割生物会有所帮助。
* 现在，提交部分完成的生物完全没有问题——这种情况偶尔会在堆叠块驱动程序和其他代码（例如，md和bcache）中出现，并且之前有一些难看的解决办法。
以前，提交部分完成的生物对_大多数_设备来说工作得还可以，但由于访问原始生物向量是常态，不是所有驱动程序都会尊重`bi_idx`，那些不遵守的驱动程序就会出现问题。现在，既然所有驱动程序_必须_通过生物向量迭代器进行操作——并且已经进行了审核以确保它们这样做——提交部分完成的生物完全没问题。

其他影响：
===================

 * 几乎所有使用`bi_idx`的情况现在都是不正确的，并已被删除；相反，以前你可能会使用`bi_idx`的地方现在应该使用生物向量迭代器（bvec_iter），很可能将其传递给其中一个辅助宏。
也就是说，不再使用`bio_iovec_idx()`（或`bio->bi_iovec[bio->bi_idx]`），而是使用`bio_iter_iovec()`，它接受一个生物向量迭代器并返回一个实际的`struct bio_vec`——从原始生物向量动态构建而成，但考虑到了`bi_bvec_done`（以及`bi_size`）。
* `bi_vcnt` 不能被驱动代码所信赖或依赖 —— 即任何不实际拥有 `bio` 的东西。原因有二：首先，它实际上已不再需要用于遍历 `bio` —— 我们现在只使用 `bi_size`。其次，在克隆一个 `bio` 并重用（部分）原始 `bio` 的 `biovec` 时，为了计算新 `bio` 的 `bi_vcnt`，我们必须遍历新 `bio` 中的所有 `biovec` —— 这是毫无意义的，因为这并不需要。因此，请不要再使用 `bi_vcnt`。
* 当前接口允许块层按需分割 `bio`，因此我们可以消除许多复杂性，特别是在堆叠驱动中。创建 `bio` 的代码可以创建任意大小的 `bio`，更重要的是，堆叠驱动不必同时处理它们自己的 `bio` 大小限制和底层设备的限制。因此，为单个块驱动定义 `->merge_bvec_fn()` 回调函数就没有必要了。

辅助函数的使用：
=================

* 下列后缀带有 `_all` 的辅助函数只能在非 `BIO_CLONED` 的 `bio` 上使用。它们通常由文件系统代码使用。驱动不应该使用这些函数，因为 `bio` 在到达驱动之前可能已经被分割。
::
    bio_for_each_segment_all()
    bio_for_each_bvec_all()
    bio_first_bvec_all()
    bio_first_page_all()
    bio_first_folio_all()
    bio_last_bvec_all()

* 下列辅助函数遍历单页段。在迭代过程中，传递的 `struct bio_vec` 将包含单页 I/O 向量。
::
    bio_for_each_segment()
    bio_for_each_segment_all()

* 下列辅助函数遍历多页 `bvec`。在迭代过程中，传递的 `struct bio_vec` 将包含多页 I/O 向量。
::
    bio_for_each_bvec()
    bio_for_each_bvec_all()
    rq_for_each_bvec()
