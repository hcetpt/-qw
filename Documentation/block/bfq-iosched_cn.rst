BFQ (预算公平队列)

==========================

BFQ 是一种比例共享的 I/O 调度器，具备一些额外的低延迟能力。除了对 cgroups（blkio 或 io 控制器）的支持外，BFQ 的主要特点包括：

- BFQ 保证了系统的高度响应性以及应用程序的低延迟，对于时间敏感的应用程序（如音频或视频播放器）尤其如此；
- BFQ 分配带宽，而不仅仅是时间，给进程或组（在需要保持高吞吐量时会切换回时间分配）
默认配置下，BFQ 更倾向于降低延迟而非提高吞吐量。因此，在需要达到更低延迟的情况下，BFQ 可能会构建导致较低吞吐量的调度计划。如果你的目标是让某个设备始终实现最大可能的吞吐量，那么可以通过将 low_latency 设置为 0 来关闭该设备上所有的低延迟启发式算法。详情请参阅第 3 部分，了解如何根据所需权衡来配置 BFQ 以平衡延迟和吞吐量，或者如何最大化吞吐量。

与其他 I/O 调度器一样，BFQ 在每个 I/O 请求处理中会增加一些开销。为了说明这种开销，BFQ 的单锁保护下的每请求处理总时间——即插入、调度和完成钩子执行时间之和——例如，在 Intel Core i7-2760QM@2.40GHz（一款笔记本电脑用的旧处理器；通过简单的代码工具测量，并使用 S 套件[1]中的 throughput-sync.sh 脚本进行性能分析）上的时间是 1.9 微秒。作为参考，blk-mq 中最轻量级的 I/O 调度器 mq-deadline 的单锁保护下的每请求执行总时间是 0.7 微秒（mq-deadline 约 800 行代码，而 BFQ 则有大约 10500 行代码）。

调度开销进一步限制了 CPU 可以处理的最大 IOPS（已经受到 I/O 栈其余部分执行的限制）。为了说明 BFQ 下的这些限制，在较慢或平均性能的 CPU 上，以下是启用完全层级支持（即设置了 CONFIG_BFQ_GROUP_IOSCHED）但未设置 CONFIG_BFQ_CGROUP_DEBUG 时，三种不同 CPU 上 BFQ 的极限：
- Intel i7-4850HQ：400 KIOPS
- AMD A8-3850：250 KIOPS
- ARM CortexTM-A53 八核：80 KIOPS

如果设置了 CONFIG_BFQ_CGROUP_DEBUG（当然同时也启用了完全层级支持），则 BFQ 的可持续吞吐量会下降，因为所有 blkio.bfq* 统计数据都会被创建和更新（见第 4-2 部分）。对于 BFQ，这会导致以下最大可持续吞吐量，同样在上述系统上：
- Intel i7-4850HQ：310 KIOPS
- AMD A8-3850：200 KIOPS
- ARM CortexTM-A53 八核：56 KIOPS

BFQ 同样适用于多队列设备。

1. BFQ 在何时可能有用？
==========================

BFQ 在个人和服务器系统中提供了以下好处：

1-1 个人系统
-------------

**对于交互式应用的低延迟**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

无论实际背景工作负载如何，BFQ 保证对于交互任务而言，存储设备的响应性几乎就像空闲时一样。例如，即使正在执行一个或多个以下背景工作负载：

- 正在读取、写入或复制一个或多个大文件，
- 正在编译一个源文件树，
- 一个或多个虚拟机正在进行 I/O 操作，
- 正在进行软件更新，
- 索引守护进程正在扫描文件系统并更新其数据库，

启动应用程序或从应用程序内部加载文件所需的时间与存储设备空闲时大致相同。相比之下，在相同条件下，使用 CFQ、NOOP 或 DEADLINE 时，应用程序可能会遇到高延迟，甚至在背景工作负载结束之前变得无响应（即使是在 SSD 上也是如此）。
**对于软实时应用的低延迟**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
软实时应用（如音频和视频播放器/流媒体器）也能享受到低延迟和低丢帧率，无论背景 I/O 工作负载如何。因此，这些应用几乎不会因背景工作负载而出现任何故障。
**代码开发任务的更高速度**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
如果恰好有其他工作负载并行运行，则 BFQ 执行典型的代码开发任务（如编译、检出、合并等）相关的 I/O 组件比 CFQ、NOOP 或 DEADLINE 快得多。
**高吞吐量**
^^^^^^^^^^^^^^^
在硬盘上，BFQ 实现的吞吐量比 CFQ 高达 30%，比 DEADLINE 和 NOOP 高达 150%，这是基于我们测试中考虑的所有顺序工作负载。对于随机工作负载以及所有闪存设备的工作负载，BFQ 实现的吞吐量与其它调度器大致相同。
### 强公平性、带宽和延迟保证

BFQ 分配设备吞吐量，而不仅仅是设备时间，根据I/O受限应用的权重成比例地分配给它们，在任何工作负载下且不论设备参数如何。从这些带宽保证中，可以通过一个简单的公式计算出每个I/O请求的精确延迟保证。如果没有配置严格的服务质量保证，BFQ会切换到基于时间的资源共享（仅限于）那些可能会导致吞吐量损失的应用程序。

#### 1-2 服务器系统

对于服务器系统的大多数好处都源于上述相同的服务特性。特别是，无论是否正在为可能很重的额外工作负载提供服务，BFQ都能确保：

* 音频和视频流传输具有零或非常低的抖动和丢包率；
* 快速检索网页和嵌入对象；
* 实时记录数据到实时转储应用程序（例如，数据包日志记录）；
* 在本地和远程访问服务器时保持响应性。

### 2. BFQ是如何工作的？

BFQ是一种按比例分配的I/O调度器，其总体结构以及大量代码都是从CFQ借鉴来的。
- 每个在设备上进行I/O操作的进程都与一个权重和一个 `队列(bfq_队列)` 相关联；
- BFQ在一段时间内授予一个队列（进程）对设备的独占访问权，并通过为每个队列分配一个以扇区数量衡量的预算来实现这种服务模型；
- 当一个队列被授予对设备的访问权后，该队列的预算会在每次调度请求时根据请求的大小递减；
- 正在接受服务的队列只有在以下事件发生时才会过期，即服务暂停：1) 队列耗尽其预算；2) 队列为空；3) “预算超时”触发；
- 预算超时防止了执行随机I/O的进程长时间占用设备并显著降低吞吐量；
- 实际上，就像在CFQ中一样，与发出同步请求的进程相关联的队列在其为空时可能不会立即过期。相反，BFQ可能会让设备空闲一小段时间，如果进程及时发出新请求，则有机会继续获得服务。设备空闲通常会提高旋转设备和非队列闪存设备上的吞吐量，如果进程进行同步和顺序I/O操作。此外，在BFQ下，设备空闲对于保证发出同步请求的进程所需的吞吐量份额也是关键的（有关`slice_idle`可调参数的详细描述，请参见本文档或[1, 2]）；
- 关于为了服务保证而空闲设备，如果有多个进程同时竞争设备，但所有进程和组的权重相同，则BFQ可以在不使设备空闲的情况下保证预期的吞吐量分布。因此，在这种常见情况下，吞吐量尽可能高。
- 对于基于闪存的存储设备，其内部命令排队（通常是NCQ），设备空闲总是对吞吐量有害。因此，对于这类设备，BFQ仅在严格需要提供服务保证时执行空闲操作，即确保低延迟或公平性。在这种情况下，整体吞吐量可能不是最优的。目前还没有解决方案能够在具有内部排队的设备上同时提供强大的服务保证和最优的吞吐量。
- 如果启用了低延迟模式（默认配置），BFQ会执行一些特殊启发式算法来检测交互式和软实时应用（例如视频或音频播放器/流媒体），并降低这些应用的延迟。为了达到这个目标，最重要的行动是给与这些应用相关的队列分配超过它们应得份额的设备吞吐量。为了简洁起见，我们将BFQ采取的所有特权措施统称为“权重提升”。具体而言，BFQ为交互式应用提供较温和形式的权重提升，而对于软实时应用则提供更强烈的权重提升。
- BFQ自动为那些在创建队列的突发中诞生的队列禁用空闲功能。实际上，这些队列通常与从高吞吐量中获益最大的应用和服务进程相关联。例如，在启动过程中systemd或者使用git grep等场景。
- 与CFQ类似，BFQ合并执行交错I/O的队列，即进行随机I/O但合并后主要变为顺序I/O的操作。不同于CFQ，BFQ通过一个更为响应性的机制——早期队列合并（EQM）来实现这一目标。EQM能够非常快速地检测到交错I/O（合作进程），使得BFQ即使对于CFQ需要采用抢占机制才能获得高吞吐量的队列，也能够通过队列合并达到高吞吐量。因此，EQM是一种统一的机制，用于通过交错I/O实现高吞吐量。
- 队列根据B-WF2Q+（一种WF2Q+的变体）进行调度，并且使用增强的红黑树实现以保持O(log N)的整体复杂度。更多细节请参阅[2]。B-WF2Q+也为层次化调度做好了准备，详情见第4节。
- B-WF2Q+保证了相对于理想、完全公平和平滑的服务的紧密偏差。特别是，B-WF2Q+保证每个队列获得与其权重成比例的设备吞吐量份额，即使吞吐量波动，也不受设备参数、当前工作负载以及分配给队列的预算的影响。
- 最后，预算独立性属性（尽管最初可能看起来有些违反直觉）确实是有益的，原因如下：

    - 首先，对于任何按比例分配的调度器来说，相对于理想服务的最大偏差与分配给队列的最大预算（切片）成正比。因此，BFQ不仅因为B-WF2Q+的准确服务而能保持这种偏差的紧密性，而且因为BFQ*不需要*给队列分配更大的预算来让队列获得更高份额的设备吞吐量。
- 其次，BFQ可以自由选择为每个进程（队列）分配最适合该进程需求或最能利用该进程I/O模式的预算。具体而言，BFQ使用一个简单的反馈环路算法更新队列的预算，使高吞吐量得以实现的同时，仍为时间敏感的应用程序提供紧密的延迟保证。当服务中的队列到期时，该算法计算下一个队列预算以便：

      - 让较大的预算最终分配给执行顺序I/O的I/O密集型应用所关联的队列：事实上，这些应用一旦获得设备访问权，服务时间越长，吞吐量就越高。
- 让较小的预算最终分配给与时间敏感应用（通常执行偶发且短暂的I/O）相关的队列，因为分配给等待服务的队列的预算越小，B-WF2Q+将越早为该队列提供服务（参见[2]中的子节3.3）。
- 如果多个进程同时竞争设备，但所有进程及其组权重相同，则BFQ无需使设备空闲即可保证预期的吞吐量分布。它使用抢占机制代替。在这种常见场景下，吞吐量要高得多。
I/O优先级类按照严格的优先级顺序提供服务，即，只要存在更高优先级的队列，较低优先级的队列就不会被服务。在同一类中的队列之间，带宽则根据每个队列的权重按比例分配。然而，为防止空闲类（Idle class）饿死，会保证其极少量的额外带宽。

3. BFQ 的可调参数是什么？如何正确配置 BFQ？
=============================================================

大多数BFQ的可调参数影响服务质量保证（主要指延迟和公平性）及吞吐量。有关如何选择所需的服务保证与吞吐量之间的权衡的详细信息，请参阅参数`slice_idle`、`strict_guarantees`和`low_latency`。有关如何最大化吞吐量的详情，请查看`slice_idle`、`timeout_sync`和`max_budget`。其他性能相关的参数是从CFQ继承而来的，并且主要保留以保持与CFQ的兼容性。截至目前，更改这些参数后在BFQ中尚未报告过性能提升。
特别是下面的可调参数`back_seek_max`、`back_seek_penalty`、`fifo_expire_async`和`fifo_expire_sync`与CFQ相同。它们的描述直接从CFQ复制而来。`slice_idle`的一些考虑因素也从CFQ复制过来。

### 每进程I/O优先级和权重
---------------------------------

除非使用cgroups接口（参见“4. BFQ组调度”），否则只能通过I/O优先级间接地为进程分配权重，具体关系如下：
权重 = (IOPRIO_BE_NR - ioprio) * 10
请注意，如果设置了`low_latency`，那么BFQ会自动提高与交互式和软实时应用相关联的队列的权重。如果你需要/想要控制权重，则应取消设置此可调参数。

### slice_idle
------------------------

此参数指定当某些同步BFQ队列变为空时，BFQ应为下一个I/O请求空闲多久。默认情况下，`slice_idle`是一个非零值。空闲具有双重目的：提高吞吐量并确保遵循所需的吞吐量分配（参见BFQ的工作原理描述，如有需要，可以参考其中提到的相关论文）。
就吞吐量而言，在高度寻址的介质上，如单轴SATA/SAS硬盘，空闲非常有用，因为它可以减少整体寻址次数，从而提高吞吐量。
将`slice_idle`设置为0将消除所有队列上的空闲时间，应该可以在更快的存储设备（如硬件RAID配置下的多个SATA/SAS硬盘以及带有内部命令队列（和并行性）的基于闪存的存储）上看到总体吞吐量的提升。
因此，根据存储类型和工作负载，可能有必要将`slice_idle`设置为0。通常对于SATA/SAS硬盘及其软件RAID，启用`slice_idle`是有用的。对于任何有多个轴支持单一逻辑单元号（主机硬件RAID控制器或存储阵列）的情况，或者使用基于闪存的高速存储时，将`slice_idle`设置为0可能会带来更好的吞吐量和可接受的延迟。
然而，为了在不同权重或不同I/O请求长度的情况下强制执行服务质量保证，空闲是必要的。
要理解这一点，假设给定的BFQ队列A必须为每个队列B的服务请求提供多个I/O请求服务。空闲确保了，如果A在变为空之后立即产生新的I/O请求，则不会在此期间调度队列B的任何请求，因此A不会失去在队列B的下一个请求被调度之前调度多个请求的可能性。需要注意的是，空闲仅能从I/O请求调度的角度保证队列所期望的差异化处理。为了确保实际的服务顺序与调度顺序一致，还必须设置`strict_guarantees`参数。

空闲有一个重要的负面影响：除了上述对吞吐量有益的情况外，空闲可能会严重影响吞吐量。一个重要的例子是随机工作负载。由于这个问题，BFQ倾向于尽可能避免空闲（除非这对吞吐量也有益，具体细节请参阅第2节）。这种行为的结果，以及关于`strict_guarantees`参数进一步讨论的问题，可能导致短期服务保障偶尔被违反。在某些情况下，这些保障可能比确保最大吞吐量更重要。例如，在视频播放/流媒体中，极低的丢帧率可能比最大吞吐量更为重要。在这种情况下，请考虑设置`strict_guarantees`参数。

### slice_idle_us

控制与`slice_idle`相同的调优参数，但以微秒为单位。
任一参数都可用于设置空闲行为。设置后，另一个参数将在sysfs中反映出新设置的值。

### strict_guarantees

如果设置了此参数（默认：未设置），则BFQ：

- 当正在服务的队列变为空时始终执行空闲；

- 强制设备一次只服务一个I/O请求，只有在没有未完成请求的情况下才调度新的请求。

在存在差异化的权重或I/O请求大小的情况下，上述两个条件都是必要的，以确保每个BFQ队列都能获得其应有的带宽份额。第一个条件的原因已在`slice_idle`参数描述中解释。第二个条件是必要的，因为所有现代存储设备都会重新排序内部队列中的请求，这可能简单地破坏I/O调度器强制实施的服务保障。

设置`strict_guarantees`显然可能会影响吞吐量。

### back_seek_max

该参数以千字节(KB)为单位指定向后查找的最大“距离”。
距离是指当前磁头位置到距离上位于“向后”的扇区之间的空间量。
此参数允许调度器预知“向后”方向上的请求，并将它们视为“下一个”请求，只要它们在这个距离之内。
### back_seek_penalty

此参数用于计算反向查找的成本。如果请求的反向距离仅为一个“前端”请求的1/back_seek_penalty，那么这两个请求的查找成本将被视为等同。因此，调度器不会偏向任何一个请求（否则调度器会偏向前端请求）。back_seek_penalty的默认值为2。

### fifo_expire_async

此参数用于设置异步请求的超时时间。其默认值为250毫秒。

### fifo_expire_sync

此参数用于设置同步请求的超时时间。其默认值为125毫秒。为了优先处理同步请求而非异步请求，可以适当减小这个值与fifo_expire_async之间的差距。

### low_latency

此参数用于启用或禁用BFQ的低延迟模式。默认情况下，低延迟模式是启用的。如果启用，则交互式和软实时应用程序会被赋予更高的优先级，从而降低延迟，这一点在BFQ的工作原理中详细解释。如果需要完全控制带宽分配，请禁用此模式。实际上，如果启用了该模式，BFQ会自动增加被优先考虑的应用程序的带宽份额，以此作为确保它们获得更低延迟的主要手段。此外，如本文档开头所述，如果唯一的目标是实现高吞吐量，则也应禁用此模式。事实上，优先处理某些应用的I/O可能会导致总体吞吐量下降。为了在非旋转设备上实现尽可能高的吞吐量，可能还需要将slice_idle设置为0（但这样就放弃了对公平性和低延迟的强保证）。

### timeout_sync

一旦选定任务（队列）进行服务后，可为其分配的最大设备时间。对于寻道成本较高的设备，增加这个时间通常会提高最大吞吐量。相反地，增加这个时间会粗化短期带宽和延迟保证的粒度，尤其是当以下参数被设置为零时。

### max_budget

一旦BFQ队列被选中进行服务，所能提供的最大服务量（以扇区为单位），当然，这必须在上述超时限制内。根据算法描述，较大的值会按顺序I/O请求的比例增加吞吐量。较大的值的代价是它们会粗化短期带宽和延迟保证的粒度。
默认值是0，这会启用自动调整：BFQ根据估计的峰值速率设置`max_budget`为在`timeout_sync`期间可以服务的最大扇区数。
对于特定设备，一些用户偶尔报告通过明确设置`max_budget`（即，将`max_budget`设置为大于0的值）达到了更高的吞吐量。具体来说，他们将`max_budget`设置为比BFQ使用自动调整时所设值更高的值。另一种达到此目的的方法是仅增加`timeout_sync`的值，同时保持`max_budget`等于0。

4. 使用BFQ进行组调度
============================

BFQ支持cgroups-v1和cgroups-v2中的I/O控制器，即`blkio`和`io`。特别是，BFQ支持基于权重的比例分配。要激活cgroups支持，请设置`BFQ_GROUP_IOSCHED`。

4-1 提供的服务保证
-------------------------------

使用BFQ时，比例分配意味着按照组的权重真正地分配设备带宽。例如，权重为200的组获得的带宽是权重为100的组两倍的带宽，而不仅仅是时间上的两倍。
BFQ支持任意深度的层次结构（组树）。带宽以预期的方式在各组及其进程之间分配：对于每个组，该组的所有子组按其权重共享整个组的带宽。特别地，这意味着对于每个叶子组，组内的每个进程接收相同份额的整个组的带宽，除非修改了进程的ioprio。
组的资源分享保证可能部分或完全从带宽转换为时间，如果提供带宽保证给组会过多降低吞吐量。这种转换是以每个进程为基础的：如果一个叶子组中的进程在其服务方式下接收不到其应得的带宽份额时导致吞吐量损失，则BFQ会将该进程切换回仅基于时间的比例分配。

4-2 接口
-------------

为了使某个设备上的带宽能够按比例共享，当然需要确保BFQ是该设备上活动的调度器。

在每个组目录中，与BFQ特有的cgroup参数和统计信息相关的文件名都以"bfq."前缀开始。因此，在cgroups-v1或cgroups-v2中，BFQ特有的文件的完整前缀是"blkio.bfq."或"io.bfq."。例如，使用BFQ设置组权重的组参数是`blkio.bfq.weight`或`io.bfq.weight`。

至于cgroups-v1（`blkio`控制器），创建的确切统计文件集以及由bfq维护的文件集取决于是否设置了`CONFIG_BFQ_CGROUP_DEBUG`。如果设置了该配置项，则bfq会创建文档中列出的所有统计文件（参见`Documentation/admin-guide/cgroup-v1/blkio-controller.rst`）。如果没有设置`CONFIG_BFQ_CGROUP_DEBUG`，则bfq仅创建以下文件：

```
blkio.bfq.io_service_bytes
blkio.bfq.io_service_bytes_recursive
blkio.bfq.io_serviced
blkio.bfq.io_serviced_recursive
```

`CONFIG_BFQ_CGROUP_DEBUG`的值对bfq可持续的最大吞吐量有很大影响，因为更新`blkio.bfq.*`统计信息相当昂贵，尤其是对于某些由`CONFIG_BFQ_CGROUP_DEBUG`启用的统计信息。

参数
----------

对于每个组，可以设置以下参数：

  * `weight`：这指定了组在其父组内的默认权重。
可用值：1..1000（默认：100）
对于cgroup v1，通过向`blkio.bfq.weight`写入值来设置
对于cgroup v2，通过向`io.bfq.weight`写入值来设置
（可选前缀为`default`和一个空格）
在可调参数部分开头描述的ioprio与权重之间的线性映射仍然有效，但是所有高于
IOPRIO_BE_NR*10的权重都将映射到ioprio 0
回想一下，如果设置了低延迟，则BFQ会自动提高与交互式和软实时
应用程序关联的队列的权重。如果你需要/想要控制权重，请取消设置此可调参数
weight_device
这指定了cgroup的每个设备的权重。语法是`次要编号:主要编号 权重`。可以使用权重`0`来重置为默认权重
对于cgroup v1，通过向`blkio.bfq.weight_device`写入值来设置
对于cgroup v2，文件名是`io.bfq.weight`
[1]
    P. 瓦伦特, A. 阿万津尼, "BFQ 存储 I/O 调度程序的演进", 第一届移动系统技术研讨会(MST-2015)论文集, 五月 2015年
提供的链接指向特定的技术文档和资源，但实际的文本内容并没有给出。不过，我可以根据您给出的英文内容提供一个大致的中文翻译。

---

### 参考文献
2. 
   - 帕. 瓦伦特 和 马. 安德雷奥利, "通过BFQ磁盘I/O调度器提升应用响应性", 第五届国际系统与存储年会（SYSTOR '12）论文集, 2012年6月
   - 稍作扩展的版本：
     - [http://algogroup.unimore.it/people/paolo/disk_sched/bfq-v1-suite-results.pdf](http://algogroup.unimore.it/people/paolo/disk_sched/bfq-v1-suite-results.pdf)

3. 
   - [https://github.com/Algodev-github/S](https://github.com/Algodev-github/S)

请注意，由于第3条参考文献中的链接不完整，我无法提供更具体的上下文信息。如果需要对这部分进行详细的翻译，请提供完整的链接或者更多的上下文信息。

以上翻译仅供参考，具体的专业术语可能需要根据实际文档内容进行调整。
