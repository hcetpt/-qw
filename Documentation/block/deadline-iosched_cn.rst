==============================
Deadline IO 调度程序可调参数
==============================

本小节试图记录 Deadline IO 调度程序的工作方式，
特别是，它将阐明可能对高级用户感兴趣的暴露出来的可调参数的意义。
选择 IO 调度器
-----------------------
有关在每个设备上选择 IO 调度器的信息，请参阅 `Documentation/block/switching-sched.rst`。
------------------------------------------------------------------------------

read_expire（毫秒）
-----------------------

Deadline IO 调度程序的目标是尝试保证请求开始服务的时间。由于我们主要关注读取延迟，因此这是一个可调节的参数。当一个读请求首次进入 IO 调度程序时，会为其分配一个截止时间，该时间为当前时间加上以毫秒为单位的 `read_expire` 值。
write_expire（毫秒）
-----------------------

与上面提到的 `read_expire` 类似，但针对写操作。
fifo_batch（请求数量）
------------------------------------

请求按特定的数据方向（读或写）被分组到“批次”中，并按照递增的扇区顺序进行服务。为了限制额外的寻道，仅在批次之间检查截止时间。`fifo_batch` 控制每个批次的最大请求数量。
此参数调整了单个请求延迟与总吞吐量之间的平衡。当低延迟是最主要的关注点时，较小的值更好（其中值为 1 表示先进先出的行为）。增加 `fifo_batch` 通常可以提高吞吐量，但会增加延迟变化。
writes_starved（调度次数）
--------------------------------------

当我们需要将请求从 IO 调度队列移动到块设备调度队列时，我们总是优先考虑读取。然而，我们也不想无限期地让写入等待。因此，`writes_starved` 控制了我们多少次优先考虑读取而非写入。当这个动作发生了 `writes_starved` 规定的次数后，我们会根据与读取相同的准则来调度一些写入。
front_merges（布尔值）
-----------------------

有时，一个请求进入 IO 调度器时，会与队列中已有的某个请求相邻。它要么适合位于那个请求之后，要么适合位于其之前。这被称为后合并候选者或前合并候选者。由于文件的典型布局方式，后合并远比前合并常见。对于某些工作负载，您甚至可能知道花费任何时间尝试前合并请求都是浪费时间。将 `front_merges` 设置为 0 禁用此功能。
由于通过缓存的 `last_merge` 提示，前合并仍可能发生，但这基本上是零成本的，所以我们保留此功能。当调用 IO 调度程序的合并函数时，我们仅仅禁用了 rbtree 的前扇区查找。
2002年11月11日，詹斯·阿克贝（jens.axboe@oracle.com）
