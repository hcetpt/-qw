==========================
显式易失性写回缓存控制
==========================

简介
------------

许多存储设备，特别是在消费市场中，都带有易失性写回缓存。这意味着在数据实际写入非易失性存储之前，设备就已经向操作系统报告了I/O操作完成。这种行为显然可以加速各种工作负载的处理，但也意味着当操作系统执行诸如`fsync`、`sync`或卸载等数据完整性操作时，需要将数据强制写入非易失性存储。
Linux块层提供了两种简单的机制，让文件系统能够控制存储设备的缓存行为。这些机制包括强制缓存刷新和请求中的Force Unit Access (FUA) 标志。

显式缓存刷新
----------------------

可以通过在从文件系统提交的bio的读写标志中使用OR运算符添加`REQ_PREFLUSH`标志来确保在实际I/O操作开始之前已刷新存储设备的易失性缓存。这明确保证了之前已完成的写请求已经位于非易失性存储上，然后再开始带有该标志的bio。此外，可以在一个空的bio结构上设置`REQ_PREFLUSH`标志，这仅会导致显式的缓存刷新而没有依赖的I/O操作。推荐使用`blkdev_issue_flush()`辅助函数进行纯缓存刷新。

强制单元访问
------------------

可以通过在从文件系统提交的bio的读写标志中使用OR运算符添加`REQ_FUA`标志来确保仅在数据已被提交到非易失性存储之后才为该请求报告I/O完成。

文件系统的实现细节
------------------------------

文件系统只需简单地设置`REQ_PREFLUSH`和`REQ_FUA`位即可，无需担心底层设备是否需要显式的缓存刷新以及如何实现强制单元访问。可以在单个bio上同时设置`REQ_PREFLUSH`和`REQ_FUA`标志。

块驱动程序的功能设置
----------------------------------

对于不支持易失性写缓存的设备，不需要驱动程序支持，块层会在进入驱动程序之前完成空的`REQ_PREFLUSH`请求，并从有负载的请求中剥离`REQ_PREFLUSH`和`REQ_FUA`位。

对于带有易失性写缓存的设备，驱动程序需要通过在队列限制的特性字段中设置

   `BLK_FEAT_WRITE_CACHE`

标志来告诉块层它支持缓存刷新。对于也支持FUA位的设备，还需要在队列限制结构的特性字段中设置

   `BLK_FEAT_FUA`

标志以指示块层传递`REQ_FUA`位。

基于bio的块驱动程序的实现细节
--------------------------------------------------

对于基于bio的驱动程序，如果驱动程序设置了`BLK_FEAT_WRITE_CACHE`标志，则`REQ_PREFLUSH`和`REQ_FUA`位会被直接传递给驱动程序，并且驱动程序需要处理它们。
*注意*：即使未设置`BLK_FEAT_FUA`标志，`REQ_FUA`位也会被传递。任何设置了`BLK_FEAT_WRITE_CACHE`的基于bio的驱动程序也需要处理`REQ_FUA`。
对于重映射驱动程序，需要将`REQ_FUA`位传播到底层设备，并为设置了`REQ_PREFLUSH`标志的bio实现全局刷新。
### 黑队（块设备多队列）驱动的实现细节

当设置了`BLK_FEAT_WRITE_CACHE`标志时，带有负载的`REQ_OP_WRITE | REQ_PREFLUSH`请求会被块层自动转换为一个`REQ_OP_FLUSH`请求序列，随后是实际的写操作。

当设置了`BLK_FEAT_FUA`标志时，对于`REQ_OP_WRITE`请求，`REQ_FUA`位将被直接传递。否则，在带有`REQ_FUA`位设置的写请求完成之后，块层会发送一个`REQ_OP_FLUSH`请求用于生物对象（bio）提交。
