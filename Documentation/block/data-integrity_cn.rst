数据完整性
=============

1. 引言
=============

现代文件系统通过数据和元数据的校验和来防止数据损坏。然而，对损坏的检测通常在读取时进行，这可能是数据写入后的几个月之后。此时，应用程序试图写入的原始数据很可能已经丢失。
解决方案是确保磁盘实际存储的内容正是应用程序所期望的。SCSI家族协议（SBC 数据完整性字段、SCC 保护提案）以及 SATA/T13（外部路径保护）最近增加的支持试图通过为 I/O 添加完整性元数据来解决这个问题。完整性元数据（在 SCSI 术语中称为保护信息）包括每个扇区的校验和以及一个递增计数器，以确保各个扇区按正确的顺序写入。对于某些保护方案来说，还包括确保 I/O 被写入磁盘上的正确位置。
当前的存储控制器和设备实施了各种保护措施，例如校验和和擦除检查。但这些技术通常在其独立的领域内工作，或者最多在 I/O 路径中的相邻节点之间工作。DIF 和其他完整性扩展的有趣之处在于，保护格式被明确定义，并且 I/O 路径中的每个节点都可以验证 I/O 的完整性并在检测到损坏时拒绝它。这不仅允许防止损坏，还可以隔离故障点。
2. 数据完整性扩展
=====================

如文档所述，协议扩展只保护控制器与存储设备之间的路径。但是，许多控制器实际上允许操作系统与完整性元数据（IMD）交互。我们一直在与几家 FC/SAS HBA 厂商合作，使他们能够将保护信息从/到其控制器进行传输。
SCSI 数据完整性字段通过向每个扇区附加 8 字节的保护信息来工作。数据加完整性元数据以 520 字节的扇区形式存储在磁盘上。数据与 IMD 在控制器和目标之间传输时交错。T13 提案与此类似。
因为操作系统处理 520 字节（和 4104 字节）扇区非常不方便，所以我们联系了几家 HBA 厂商，鼓励他们允许分离数据和完整性元数据的散列-聚合列表。
控制器将在写入时交错缓冲区，并在读取时拆分它们。这意味着 Linux 可以将数据缓冲区 DMA 到主机内存而无需修改页面缓存。
此外，SCSI 和 SATA 规范规定的 16 位 CRC 校验和在软件中计算起来相当繁重。基准测试发现，在多个工作负载下计算这个校验和对系统性能产生了显著影响。一些控制器允许在与操作系统接口时使用更轻量级的校验和。例如，Emulex 支持 TCP/IP 校验和。
从操作系统接收的 IP 校验和在写入时转换为 16 位 CRC，反之亦然。这使得 Linux 或应用程序可以低成本生成完整性元数据（与软件 RAID5 相当）。
就检测位错误而言，IP 校验和比 CRC 较弱。然而，真正的优势在于数据缓冲区与完整性元数据的分离。这两个不同的缓冲区必须匹配才能完成 I/O 操作。
数据和完整性元数据缓冲区的分离以及校验和的选择被称为数据完整性扩展。这些扩展超出了协议主体（T10、T13）的范围，因此Oracle及其合作伙伴正在尝试在存储网络行业协会内将其标准化。

3. 内核变更
=============

Linux中的数据完整性框架使保护信息能够与I/O绑定，并发送给/接收自支持该功能的控制器。
SCSI和SATA的完整性扩展的优势在于，它们使我们能够从应用程序到存储设备的整个路径进行保护。但同时这也是最大的劣势。这意味着保护信息必须以磁盘能够理解的格式存在。
通常情况下，Linux/POSIX应用程序对所访问的存储设备的具体细节一无所知。虚拟文件系统切换和块层使硬件扇区大小和传输协议对应用程序完全透明。
然而，在准备发送给磁盘的保护信息时，需要这种级别的详细信息。因此，端到端保护方案的概念本身就是一种层次违规。
让一个应用程序意识到它是在访问SCSI还是SATA磁盘是完全不合理的。
在Linux中实现的数据完整性支持试图将这一点隐藏起来。对于应用程序（以及在某种程度上对于内核而言），完整性元数据是附着于I/O上的不透明信息。
当前的实现允许块层自动为任何I/O生成保护信息。最终的目标是将用户数据的完整性元数据计算移至用户空间。而起源于内核内部的元数据和其他I/O仍将使用自动生成接口。
一些存储设备允许每个硬件扇区被标记为16位值。这个标签空间的所有者是块设备的所有者，即大多数情况下的文件系统。文件系统可以利用这个额外的空间按需标记扇区。因为标签空间有限，块接口通过交错的方式允许标记更大的数据块。这样，一个典型的4KB文件系统块可以附加8*16位的信息。
这也意味着像fsck和mkfs这样的应用程序需要从用户空间访问来操作这些标签。目前正在进行这项传递接口的工作。
4. 块层实现细节
=====================

4.1 Bio
-------

当启用`CONFIG_BLK_DEV_INTEGRITY`时，数据完整性补丁向`struct bio`添加了一个新字段。`bio_integrity(bio)`返回一个指向`struct bip`的指针，其中包含bio的数据完整性负载。基本上，`bip`是一个简化版的`struct bio`，它持有一个包含完整性元数据及其所需维护信息（如bvec池、向量计数等）的`bio_vec`。

内核子系统可以通过调用`bio_integrity_alloc(bio)`来为`bio`启用数据完整性保护。这将分配并附加`bip`到`bio`。
随后可以使用`bio_integrity_add_page()`附加包含完整性元数据的单个页面。
`bio_free()`会自动释放`bip`。

4.2 块设备
----------------

块设备可以在`queue_limits`结构的`integrity`子结构中设置完整性信息。
分层块设备需要选择一个适用于所有子设备的配置文件。`queue_limits_stack_integrity()`可以帮助实现这一点。目前支持DM和MD线性、RAID0和RAID1。由于应用标签的原因，RAID4/5/6将需要额外的工作。

5.0 块层完整性API
=============================

5.1 普通文件系统
---------------------

普通文件系统不知道底层块设备能够发送/接收完整性元数据。在WRITE操作中，IMD将在`submit_bio()`时由块层自动生成。READ请求将在完成时验证I/O完整性。

可以通过以下标志切换IMD生成和验证：

```
/sys/block/<bdev>/integrity/write_generate
```

和

```
/sys/block/<bdev>/integrity/read_verify
```

5.2 具有完整性感知的文件系统
------------------------------

具有完整性感知的文件系统可以准备带有IMD的I/O。如果块设备支持的话，还可以利用应用标签空间。

`bool bio_integrity_prep(bio);`

为了在WRITE时生成IMD并在READ时设置缓冲区，文件系统必须调用`bio_integrity_prep(bio)`。
在调用此函数之前，必须设置生物数据（bio data）的方向和起始扇区，并且生物对象（bio）应添加所有数据页。确保在 I/O 操作进行时生物对象（bio）不发生变化的责任在于调用者。

如果由于某种原因准备失败，则需使用错误信息完成生物对象（bio）。

### 5.3 传递现有的完整性元数据

对于那些能够生成自己的完整性元数据或能够从用户空间传输 IMD（Integrity Metadata）的文件系统来说，可以使用以下调用：

```c
struct bip * bio_integrity_alloc(bio, gfp_mask, nr_pages);
```
此函数分配生物完整性负载，并将其挂载到生物对象（bio）上。`nr_pages` 表示需要存储在完整性生物向量列表（bio_vec list）中的保护数据页面的数量（类似于 `bio_alloc()`）。完整性负载将在 `bio_free()` 时释放。

```c
int bio_integrity_add_page(bio, page, len, offset);
```
此函数将包含完整性元数据的页面附加到已存在的生物对象（bio）上。生物对象（bio）必须已存在一个 `bip` 结构，即必须已经调用过 `bio_integrity_alloc()`。对于写操作，页面中的完整性元数据必须以目标设备可理解的格式存在，值得注意的是，扇区号将在请求穿越 I/O 栈的过程中被重新映射。这意味着通过此调用添加的页面将在 I/O 过程中被修改！完整性元数据中的第一个引用标签必须具有值 `bip->bip_sector`。
只要在 `bip` 生物向量数组中还有空间，就可以使用 `bio_integrity_add_page()` 添加页面（根据 `nr_pages`）。
读操作完成后，附加的页面将包含从存储设备接收到的完整性元数据。接收方有责任处理这些元数据并在操作完成后验证数据的完整性。

---

2007-12-24 Martin K. Petersen <martin.petersen@oracle.com>
