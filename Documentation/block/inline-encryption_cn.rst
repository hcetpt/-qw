SPDX 许可证标识符: GPL-2.0

内联加密

背景
======

内联加密硬件从逻辑上位于内存和磁盘之间，可以在数据进出磁盘时进行加密或解密。对于每个I/O请求，软件可以精确地控制内联加密硬件如何对数据进行加密或解密，包括使用的密钥、算法、数据单元大小（加密或解密的粒度）以及数据单元编号（确定初始化向量的值）。有些内联加密硬件可以直接在低级I/O请求中接受所有加密参数，包括原始密钥。然而，大多数内联加密硬件具有固定数量的“密钥槽”，并要求首先将密钥、算法和数据单元大小编程到密钥槽中。每个低级I/O请求只包含一个密钥槽索引和数据单元编号。需要注意的是，内联加密硬件与通过内核加密API支持的传统加密加速器非常不同。传统加密加速器对内存区域进行操作，而内联加密硬件则对I/O请求进行操作。因此，内联加密硬件需要由块层管理，而不是内核加密API。内联加密硬件也与基于TCG Opal或ATA安全标准等的“自加密驱动器”有很大区别。自加密驱动器不提供加密的细粒度控制，并且无法验证生成的密文是否正确。相比之下，内联加密硬件提供了加密的细粒度控制，包括为每个扇区选择密钥和初始化向量的能力，并且可以对其进行正确性的测试。

目标
======

我们希望在内核中支持内联加密。为了简化测试，我们也希望在没有实际内联加密硬件的情况下能够回退到内核加密API。我们还希望内联加密能与分层设备（如设备映射器和环回设备）一起工作（即如果底层设备存在内联加密硬件，则使用该硬件进行加密/解密，否则回退到加密API进行加密/解密）。

约束与说明
==============

- 我们需要一种方法让上层（例如文件系统）指定用于加密/解密生物对象（bio）的加密上下文，设备驱动程序（例如UFSHCD）在处理请求时需要能够使用该加密上下文。加密上下文还引入了对生物对象合并的约束；块层需要意识到这些约束。
- 不同的内联加密硬件支持不同的算法、数据单元大小、最大数据单元编号等。我们将这些属性称为“加密能力”。我们需要一种通用的方法让设备驱动程序向上层宣传其加密能力。
- 内联加密硬件通常（但并非总是）要求在使用前将密钥编程到密钥槽中。由于编程密钥槽可能较慢且密钥槽数量可能有限，我们不应该为每个I/O请求都编程密钥，而是应该跟踪哪些密钥已经在密钥槽中，并尽可能重用已经编程的密钥槽。
- 上层通常会为加密密钥定义特定的有效期，例如
当一个加密目录被锁定或一个密码映射被撤销时，此时密钥会从内存中清除。我们必须提供一种机制让上层也能将存在于任何密钥槽中的密钥驱逐出去。

在可能的情况下，设备映射器（device-mapper）设备必须能够传递底层设备的内联加密支持。然而，对于设备映射器设备来说，拥有自己的密钥槽是没有意义的。

基本设计
========

我们引入`struct blk_crypto_key`来表示一个内联加密密钥及其使用方式。这包括密钥的实际字节、密钥大小、将与之一起使用的算法和数据单元大小，以及表示该密钥将用于的最大数据单元编号所需的字节数。

我们引入`struct bio_crypt_ctx`来表示一个加密上下文。它包含一个数据单元编号和指向一个`blk_crypto_key`的指针。我们在`struct bio`和`struct request`中添加指向`bio_crypt_ctx`的指针；这允许块层的用户（例如文件系统）在创建`bio`时提供加密上下文，并将其向下传递给块层和设备驱动程序进行处理。注意，加密上下文没有明确指出是加密还是解密，因为这是从`bio`的方向隐含的：WRITE意味着加密，READ意味着解密。

我们还引入`struct blk_crypto_profile`来包含特定内联加密设备的所有通用内联加密相关状态。`blk_crypto_profile`作为内联加密硬件驱动程序宣传其加密能力并向上层提供某些函数（例如，编程和驱逐密钥的函数）的方式。每个希望支持内联加密的设备驱动程序都会构建一个`blk_crypto_profile`，然后将其与磁盘的请求队列关联起来。

`blk_crypto_profile`还管理硬件的密钥槽（如果适用）。

这发生在块层中，因此块层的用户只需要指定加密上下文，而不需要了解密钥槽，设备驱动程序也不需要关心密钥槽管理的大多数细节。

具体而言，对于每个密钥槽，块层（通过`blk_crypto_profile`）跟踪该密钥槽包含哪个`blk_crypto_key`（如果有），以及有多少正在处理的I/O请求正在使用它。当块层为具有加密上下文的`bio`创建一个`request`时，如果可能的话，它会获取一个已经包含该密钥的密钥槽。否则，它会等待一个空闲的密钥槽（即没有被任何I/O使用的密钥槽），然后使用设备驱动程序提供的函数将密钥编程到最近最少使用的空闲密钥槽中。

在这两种情况下，最终的密钥槽会被存储在`request`的`crypt_keyslot`字段中，在那里它可以被设备驱动程序访问，并在请求完成后释放。
```struct request``` 同时包含指向原始 bio_crypt_ctx 的指针。
请求可以从多个 bio 构建，并且块层在尝试合并 bio 和请求时必须考虑加密上下文。要使两个 bio/请求能够合并，它们必须具有兼容的加密上下文：两者都未加密，或者两者都使用相同的密钥加密并且数据单元编号连续。请求中的第一个 bio 的加密上下文被保留，因为剩余的 bio 已经被验证与第一个 bio 具有合并兼容性。

为了使内联加密能够与基于 request_queue 的分层设备协同工作，当一个请求被克隆时，其加密上下文也被克隆。当克隆的请求被提交时，它将按照常规方式处理；这包括如果需要的话从克隆的目标设备获取密钥槽。

### blk-crypto-fallback

希望能够在没有真实内联加密硬件的情况下测试上层（例如文件系统）的内联加密支持，同时也希望测试块层的密钥槽管理逻辑。同样地，也希望允许上层始终使用内联加密，而不是必须以多种方式实现加密。

因此，我们还引入了 *blk-crypto-fallback*，这是使用内核加密 API 实现内联加密的一种方法。blk-crypto-fallback 被构建到块层中，因此它可以在任何块设备上运行而无需特殊设置。

基本上，当带有加密上下文的 bio 提交给不支持该加密上下文的块设备时，块层会使用 blk-crypto-fallback 来处理 bio 的加密和解密。

对于加密，数据不能就地加密，因为调用者通常依赖于数据保持不变。相反，blk-crypto-fallback 分配跳转页（bounce pages），用这些跳转页填充一个新的 bio，然后将数据加密到这些跳转页中，并提交这个“跳转”bio。当跳转 bio 完成时，blk-crypto-fallback 完成原始 bio。如果原始 bio 过大，则可能需要多个跳转 bio；具体细节请参阅代码。

对于解密，blk-crypto-fallback “包装”了 bio 的完成回调（``bi_complete``）和私有数据（``bi_private``），取消设置了 bio 的加密上下文，然后提交 bio。如果读取成功完成，blk-crypto-fallback 恢复 bio 的原始完成回调和私有数据，然后使用内核加密 API 就地解密 bio 的数据。解密发生在工作队列中，因为它可能会休眠。

之后，blk-crypto-fallback 完成 bio。
在两种情况下，blk-crypto-fallback提交的生物体（bios）不再具有加密上下文。因此，较低层只能看到标准的未加密I/O。blk-crypto-fallback还定义了自己的blk_crypto_profile，并有自己的“密钥插槽”；其密钥插槽包含“struct crypto_skcipher”对象。这样做的原因有两个。首先，它允许在没有实际内联加密硬件的情况下测试密钥插槽管理逻辑。其次，类似于实际的内联加密硬件，加密API不会直接在请求中接受密钥，而是需要提前设置密钥，而设置密钥可能很昂贵；此外，由于需要锁定，crypto_skcipher的分配不能在输入输出路径上发生。因此，对于blk-crypto-fallback来说，密钥插槽的概念仍然有意义。

请注意，无论使用真正的内联加密硬件还是blk-crypto-fallback，写入磁盘的密文（以及因此的数据在磁盘上的格式）都将相同（前提是内联加密硬件的实现和内核加密API使用的算法实现都遵循规范并正确工作）

blk-crypto-fallback是可选的，由内核配置选项`CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK`控制。面向块层用户提供的API
=============================================

`blk_crypto_config_supported()`允许用户提前检查特定的加密设置是否可以在特定的block_device上使用内联加密——无论是通过硬件还是通过blk-crypto-fallback。此函数接收一个`struct blk_crypto_config`，类似于blk_crypto_key，但不包含实际的密钥字节，而是包含算法、数据单元大小等信息。如果禁用了blk-crypto-fallback，这个函数会很有用。

`blk_crypto_init_key()`允许用户初始化blk_crypto_key。
用户必须在真正开始在block_device上使用blk_crypto_key之前调用`blk_crypto_start_using_key()`（即使在此之前已经调用了`blk_crypto_config_supported()`）。这需要初始化blk-crypto-fallback，如果需要的话。这个函数不能从数据路径调用，因为这可能会导致死锁，因为它可能需要分配资源。

接下来，为了将加密上下文附加到bio，用户应该调用`bio_crypt_set_ctx()`。这个函数会在给定blk_crypto_key和用于加密/解密的数据单元编号时分配bio_crypt_ctx并将其附加到bio。用户不需要担心稍后释放bio_crypt_ctx，因为当bio被释放或重置时，这会自动发生。

最后，在完成对block_device上的blk_crypto_key的内联加密操作后，用户必须调用`blk_crypto_evict_key()`。这确保了将密钥从所有可能编程进入并从任何可能链接到内核数据结构中的密钥插槽中移除。

简而言之，对于块层的用户，blk_crypto_key的生命周期如下：

1. `blk_crypto_config_supported()`（可选）
2. `blk_crypto_init_key()`
3. `blk_crypto_start_using_key()`
4. `bio_crypt_set_ctx()`（可能多次）
5. `blk_crypto_evict_key()`（在所有I/O完成后）
6. 将blk_crypto_key零化（没有专门的功能）

如果blk_crypto_key在多个block_device上使用，则`blk_crypto_config_supported()`（如果使用），`blk_crypto_start_using_key()`和`blk_crypto_evict_key()`必须在每个block_device上进行调用。
### 向设备驱动程序呈现的 API

要支持内联加密的设备驱动程序必须在其设备的`request_queue`中设置一个`blk_crypto_profile`。为此，它首先需要调用`blk_crypto_profile_init()`（或其资源管理变体`devm_blk_crypto_profile_init()`），并提供密钥槽的数量。接下来，它需要通过设置`blk_crypto_profile`中的字段来宣传其加密能力，例如`modes_supported`和`max_dun_bytes_supported`。然后，它需要在`blk_crypto_profile`的`ll_ops`字段中设置函数指针，以告诉上层如何控制内联加密硬件，例如如何编程和清除密钥槽。大多数驱动程序都需要实现`keyslot_program`和`keyslot_evict`。详情请参阅`struct blk_crypto_ll_ops`的注释。

一旦驱动程序使用`request_queue`注册了一个`blk_crypto_profile`，通过该队列接收到的I/O请求可能具有加密上下文。所有加密上下文都将与在`blk_crypto_profile`中声明的加密能力兼容，因此驱动程序无需担心处理不支持的请求。此外，如果在`blk_crypto_profile`中声明了非零数量的密钥槽，则所有具有加密上下文的I/O请求也将具有一个已使用适当密钥编程的密钥槽。

如果驱动程序实现了运行时挂起，并且其`blk_crypto_ll_ops`在设备处于运行时挂起状态时不工作，则驱动程序还必须将`blk_crypto_profile`的`dev`字段设置为指向将在执行任何低级操作之前恢复的`struct device`。

如果内联加密硬件丢失了其密钥槽的内容，例如设备重置等情况，驱动程序必须处理重新编程密钥槽。为此，驱动程序可以调用`blk_crypto_reprogram_all_keys()`。

最后，如果驱动程序使用的是`blk_crypto_profile_init()`而不是`devm_blk_crypto_profile_init()`，那么当不再需要加密配置文件时，它有责任调用`blk_crypto_profile_destroy()`。

### 层次设备

像dm-rq这样的基于请求队列的层次设备如果希望支持内联加密，需要为其`request_queue`创建自己的`blk_crypto_profile`，并暴露其所选择的功能。当一个层次设备想要将该请求的一个克隆传递给另一个`request_queue`时，blk-crypto将会按需初始化并准备这个克隆。

### 内联加密与blk完整性之间的交互

截至本补丁发布之时，没有真正支持这两个特性的硬件。然而，这些特性确实相互作用，要使它们共同正常工作并非完全简单。特别是，当一个WRITE bio希望在一个同时支持这两个特性的设备上使用内联加密时，bio将具有指定的加密上下文，之后计算其完整性信息（使用明文数据，因为加密将在写入数据时发生），并将数据和完整性信息发送到设备。显然，在数据被加密之前必须验证完整性信息。数据加密后，设备不应存储随明文数据一起接收的完整性信息，因为这可能会泄露关于明文数据的信息。因此，它必须从密文数据重新生成完整性信息并将其存储在磁盘上。另一个问题是存储明文数据的完整性信息会改变磁盘上的格式，这取决于是否存在硬件内联加密支持或是否使用内核加密API的回退（如果使用回退，设备将接收到密文的完整性信息，而不是明文的）。

由于目前还没有真正的硬件，似乎谨慎的做法是假设硬件实现可能无法正确地同时支持这两个特性，因此现在禁止这种组合。每当一个设备支持完整性时，内核将假装该设备不支持硬件内联加密（通过将设备的`request_queue`中的`blk_crypto_profile`设置为NULL）。
当加密API回退功能启用时，这意味着所有带有加密上下文的生物识别操作（bio）都将使用此回退功能，并且输入输出操作将像通常一样完成。当回退功能被禁用时，带有加密上下文的生物识别操作（bio）将会失败。 

这里稍微调整了一下表述以更符合中文习惯，"生物识别操作（bio）"实际应理解为“生物对象（bio）”，这是一个在存储系统的上下文中使用的术语。
