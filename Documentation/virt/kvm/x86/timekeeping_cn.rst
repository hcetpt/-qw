SPDX 许可声明标识符: GPL-2.0

======================================================
基于 x86 的架构的时间保持虚拟化
======================================================

:作者: Zachary Amsden <zamsden@redhat.com>
:版权: (c) 2010, Red Hat. 保留所有权利
.. 目录

   1) 概述
   2) 定时设备
   3) TSC 硬件
   4) 虚拟化问题

1. 概述
===========

x86 平台中最复杂的一部分，尤其是该平台的虚拟化，是多种可用定时设备的存在以及模拟这些设备的复杂性。此外，时间的虚拟化引入了一套新的挑战，因为它引入了超出客户机 CPU 控制范围的时间多路复用划分。首先，我们将描述各种可用的时间保持硬件，然后提出一些出现的问题及解决方案，并对某些类别的 KVM 客户机给出具体建议。本文档的目的是收集与时间保持相关且可能在其他地方难以找到的数据和信息，特别是与 KVM 和基于硬件的虚拟化相关的信息。

2. 定时设备
=================

首先讨论基本的硬件设备。TSC 及其相关的 KVM 时钟具有特殊性，值得详细说明，在下一节中将进行描述。

2.1. i8254 - PIT
----------------

最早出现的定时器设备之一是可编程中断定时器（PIT）。PIT 具有固定的频率 1.193182 MHz 基准时钟和三个可以编程以提供周期性或一次性中断的通道。这三个通道可以配置为不同的模式，并具有独立的计数器。在最初的 IBM PC 中，通道 1 和 2 不供通用使用，而是连接到控制 RAM 刷新和 PC 扬声器。现在 PIT 通常作为模拟芯片组的一部分集成，不再使用单独的物理 PIT。

PIT 使用 I/O 端口 0x40 - 0x43。通过单字节或多字节访问 I/O 端口来访问 16 位计数器。共有 6 种模式可用，但并非所有模式都适用于所有定时器，因为只有定时器 2 有连接的门输入，这是模式 1 和 5 所必需的。门线由端口 61h 的第 0 位控制，如下图所示：

```
  --------------             ----------------
  |            |           |                |
  |  1.1932 MHz|---------->| CLOCK      OUT | ---------> IRQ 0
  |    Clock   |   |       |                |
  --------------   |    +->| GATE  TIMER 0  |
                   |        ----------------
                   |
                   |        ----------------
                   |       |                |
                   |------>| CLOCK      OUT | ---------> 66.3 KHZ DRAM
                   |       |                |            (即 /dev/null)
                   |    +->| GATE  TIMER 1  |
                   |        ----------------
                   |
                   |        ----------------
                   |       |                |
                   |------>| CLOCK      OUT | ---------> 端口 61h, 第 5 位
                           |                |      |
  端口 61h, 第 0 位 -------->| GATE  TIMER 2  |       \_.----   ____
                            ----------------         _|    )--|LPF|---Speaker
                                                    / *----   \___/
  端口 61h, 第 1 位 ---------------------------------/
```

下面描述定时器模式：
模式 0：单次超时
这是一种一次性的软件超时，当门信号高（对于定时器 0 和 1 总是对的）时开始倒计数。当计数达到零时，输出变为高电平
模式 1：触发单次
输出最初设置为高电平。当门控线被设置为高电平时，开始一个倒计时（即使门控线降低也不会停止），在此期间输出设置为低电平。当计数达到零时，输出变为高电平。

模式 2：频率发生器
输出最初设置为高电平。当倒计时到达 1 时，输出在一个计数周期内变为低电平然后返回高电平。值会被重新加载，并且倒计时会自动恢复。如果门控线变为低电平，则计数停止。如果门控线降低时输出为低电平，则输出自动变为高电平（这仅影响定时器 2）。

模式 3：方波
这会产生一个高低交替的方波。计数确定脉冲的长度，在达到零时在高电平和低电平之间切换。只有当门控线为高电平时，计数才会进行，并且在达到零时自动重新加载。每个时钟周期计数递减两次以生成完整的高低周期。
如果计数值是偶数，则时钟保持高电平 N/2 个计数周期，低电平 N/2 个计数周期；如果计数值是奇数，则时钟保持高电平 (N+1)/2 个计数周期，低电平 (N-1)/2 个计数周期。计数器只锁定偶数值，因此读取时不会观察到奇数值。这是定时器 2 的预期模式，通过低通滤波方波输出可以生成类似正弦波的声音。

模式 4：软件选通
在编程此模式并加载计数器后，输出保持高电平直到计数器达到零。然后输出在一个时钟周期内变为低电平并返回高电平。计数器不会重新加载。计数只在门控线为高电平时进行。
模式 5：硬件脉冲

编程并加载计数器后，输出保持高电平。当门被抬起时，开始倒计时（即使门落下也不会停止）。当计数器归零时，输出在 1 个时钟周期内变为低电平，然后恢复为高电平。计数器不会重新加载。

除了普通的二进制计数外，PIT 还支持 BCD 计数。命令端口 0x43 用于设置三个定时器的计数器和模式。

发送到端口 0x43 的 PIT 命令使用以下位编码：

  位 7-4：命令（参见下表）
  位 3-1：模式（000 = 模式 0，101 = 模式 5，11X = 未定义）
  位 0：二进制（0）/ BCD（1）

命令表：

  0000 - 锁定定时器 0 的计数值到端口 0x40
  将要读取的计数值采样并保持；直到计数值被读取前忽略其他命令；模式位被忽略
  0001 - 设置定时器 0 的低位模式到端口 0x40
  设置定时器仅读取低位，并将高位强制为零；模式位设置定时器模式
  0010 - 设置定时器 0 的高位模式到端口 0x40
  设置定时器仅读取高位，并将低位强制为零；模式位设置定时器模式
  0011 - 设置定时器 0 的 16 位模式到端口 0x40
  设置定时器先读取低位，再读取高位；模式位设置定时器模式
  0100 - 锁定定时器 1 的计数值到端口 0x41 — 如上所述
  0101 - 设置定时器 1 的低位模式到端口 0x41 — 如上所述
  0110 - 设置定时器 1 的高位模式到端口 0x41 — 如上所述
  0111 - 设置定时器 1 的 16 位模式到端口 0x41 — 如上所述
  1000 - 锁定定时器 2 的计数值到端口 0x42 — 如上所述
  1001 - 设置定时器 2 的低位模式到端口 0x42 — 如上所述
  1010 - 设置定时器 2 的高位模式到端口 0x42 — 如上所述
  1011 - 设置定时器 2 的 16 位模式到端口 0x42 — 如上所述
  1101 - 通用计数器锁定
  将计数器组合锁定到相应的端口
  位 3 = 计数器 2
  位 2 = 计数器 1
  位 1 = 计数器 0
  位 0 = 未使用
  1110 - 锁定定时器状态
  将计数器模式组合锁定到相应的端口
  位 3 = 计数器 2
  位 2 = 计数器 1
  位 1 = 计数器 0

  发出此命令后，端口 0x40-0x42 的输出将是：

  位 7 = 输出引脚
  位 6 = 计数已加载（计时器过期则为 0）
  位 5-4 = 读/写模式
      01 = 仅高位
      10 = 仅低位
      11 = 低位/高位（16 位）
  位 3-1 = 模式
  位 0 = 二进制（0）/ BCD 模式（1）

2.2 RTC
--------

原始 PC 中可用的第二个设备是 MC146818 实时时钟。原始设备现已过时，通常由系统芯片组模拟，有时由 HPET 和一些复杂的 IRQ 路由来实现。
RTC 通过 CMOS 变量访问，它使用一个索引寄存器来控制哪些字节被读取。由于只有一个索引寄存器，因此 CMOS 读取和 RTC 读取需要锁保护（此外，允许用户空间工具如 hwclock 直接访问 RTC 是危险的，因为它们可能会破坏内核对 CMOS 内存的读写）。
RTC 生成一个通常路由到 IRQ 8 的中断。该中断可以作为周期性计时器、每日一次的警报，并且可以在 MC146818 更新 CMOS 寄存器后发出中断。
中断类型在 RTC 状态寄存器中指示。
即使系统关闭，RTC 也会通过电池供电更新当前时间字段。不应在更新过程中读取当前时间字段，这在状态寄存器中有所指示。
时钟使用 32.768 kHz 的晶体，因此如果 RTC 要计秒，则应将寄存器 A 的位 6-4 编程为 32 kHz 分频器。
这是RTC/CMOS原始使用的RAM映射表：

| 地址 | 大小 | 描述 |
| --- | --- | --- |
| 00h | 字节 | 当前秒（BCD） |
| 01h | 字节 | 秒报警（BCD） |
| 02h | 字节 | 当前分钟（BCD） |
| 03h | 字节 | 分钟报警（BCD） |
| 04h | 字节 | 当前小时（BCD） |
| 05h | 字节 | 小时报警（BCD） |
| 06h | 字节 | 当前星期几（BCD） |
| 07h | 字节 | 当前日期（BCD） |
| 08h | 字节 | 当前月份（BCD） |
| 09h | 字节 | 当前年份（BCD） |
| 0Ah | 字节 | 寄存器A <br> 位7 = 更新进行中 <br> 位6-4 = 时钟分频器 <br> 000 = 4.194 MHz <br> 001 = 1.049 MHz <br> 010 = 32 kHz <br> 10X = 测试模式 <br> 110 = 重置/禁用 <br> 111 = 重置/禁用 <br> 位3-0 = 周期中断速率选择 <br> 000 = 周期定时器禁用 <br> 001 = 3.90625 μs <br> 010 = 7.8125 μs <br> 011 = 0.122070 ms <br> 100 = 0.244141 ms <br> ... <br> 1101 = 125 ms <br> 1110 = 250 ms <br> 1111 = 500 ms |
| 0Bh | 字节 | 寄存器B <br> 位7 = 运行(0)/停止(1) <br> 位6 = 周期中断使能 <br> 位5 = 报警中断使能 <br> 位4 = 更新结束中断使能 <br> 位3 = 方波中断使能 <br> 位2 = BCD日历(0)/二进制(1) <br> 位1 = 12小时制(0)/24小时制(1) <br> 位0 = 0（夏令时关闭）/1（夏令时启用） |
| 0Ch | 字节 | 寄存器C（只读） <br> 位7 = 中断请求标志（IRQF） <br> 位6 = 周期中断标志（PF） <br> 位5 = 报警中断标志（AF） <br> 位4 = 更新中断标志（UF） <br> 位3-0 = 预留 |
| 0Dh | 字节 | 寄存器D（只读） <br> 位7 = RTC有电源 <br> 位6-0 = 预留 |
| 32h | 字节 | 当前世纪（BCD）(*) <br> (*) 地址由供应商特定，并且现在从ACPI全局表中确定 |

2.3. APIC
---------
在Pentium及之后的处理器上，每个CPU都有一个内置的定时器作为高级可编程中断控制器的一部分。APIC通过内存映射寄存器访问，并为每个CPU提供中断服务，用于IPIs和本地定时器中断。尽管理论上APIC是一个安全稳定的本地中断源，但实际上由于APIC CPU本地内存映射硬件的特殊性，许多错误和故障已经发生。请注意，CPU错误可能会影响APIC的使用，并且可能需要解决方法。此外，一些这些解决方法对虚拟化提出了独特的约束——要么从额外的内存映射I/O读取中产生额外开销，要么需要实现可能更加计算密集的功能。由于APIC在Intel和AMD手册中有很好的文档记录，我们在这里避免重复细节。应当指出的是，APIC定时器是通过LVT（本地向量定时器）寄存器编程的，能够进行单次或周期操作，并基于总线时钟通过可编程分频寄存器分频。

2.4. HPET
---------
HPET非常复杂，最初旨在替代X86 PC中的PIT/RTC支持。目前尚不确定是否会这样，因为PC硬件的事实标准是模拟这些较旧的设备。某些被指定为无遗留系统的系统可能仅支持HPET作为硬件定时器设备。
HPET规范相当松散和模糊，要求至少有3个硬件定时器，但允许实现自由以支持更多。它也不对定时器频率施加固定速率，但对频率、误差和斜率施加了一些极端值。
一般来说，HPET作为高精度（与PIT/RTC相比）的时间源被推荐，它是独立于局部变化的（因为任何给定系统中只有一个HPET）。HPET也是内存映射的，其存在通过ACPI表由BIOS指示。
详细的HPET规范超出了本文档当前的范围，因为它在其他地方也有很好的文档记录。

2.5. 外置定时器
----------------
一些卡，包括专有的（看门狗板）和常见的（e1000），内置了定时芯片，其寄存器可能可以由内核或用户驱动程序访问。据作者所知，利用它们生成Linux或其他内核的时钟源尚未尝试，并且通常不被鼓励，因为这不符合游戏规则。这种定时器设备需要额外的支持才能正确地进行虚拟化，在当前阶段并不重要，因为没有已知的操作系统这样做。

3. TSC硬件
===============
TSC（时间戳计数器）在理论上相对简单；它计数由处理器发出的指令周期，可以作为时间度量。实际上，由于一些问题，它是最复杂的计时设备。
时间戳计数器（TSC）在内部表示为一个64位的模型特定寄存器（MSR），可以通过RDMSR、RDTSC或RDTSCP（如果可用的话）指令读取。在过去，硬件限制使得可以写入TSC，但在旧硬件上通常只能写入64位计数器的低32位，而高32位被清零。然而，现在在Intel处理器家族0Fh中的型号3、4和6以及家族06h中的型号e和f中，这一限制已被取消，所有64位都可以写入。在AMD系统中，写入TSC MSR的能力并不是架构上的保证。

TSC可以从CPL-0访问，并且在CPL > 0时通过CR4.TSD位有条件地访问，当启用此位时，会禁用CPL > 0对TSC的访问。
一些供应商实现了一个额外的指令RDTSCP，该指令不仅原子地返回TSC，还返回一个与处理器编号对应的指示符。这可以在SMP系统中用于索引到TSC变量数组以确定偏移信息，特别是在TSC不同步的情况下。
CPUID功能位必须用来确定该指令的存在。

VMX和SVM都在虚拟化硬件中提供了扩展字段，允许将客体可见的TSC通过一个常量进行偏移。较新的实现承诺允许TSC被缩放，但这种硬件尚未广泛可用。

### 3.1 TSC同步

在大多数实现中，TSC是一个CPU本地时钟。这意味着，在SMP平台上，不同CPU的TSC可能根据CPU何时上电而开始于不同的时间。一般来说，同一芯片上的CPU会共享同一个时钟，但并非总是如此。
BIOS可能会尝试在上电过程中重新同步TSC，操作系统或其他系统软件也可能这样做。
几个硬件限制使问题更加复杂——如果无法写入完整的64位TSC，则可能无法使新到达的CPU中的TSC与其他系统中的TSC匹配，导致TSC不同步。这可能由BIOS或系统软件完成，但实际上，除非所有值都从同一个时钟读取，否则不可能得到完全同步的TSC，这通常只在单插槽系统或具有特殊硬件支持的系统中才可能实现。

### 3.2 TSC与CPU热插拔

如前所述，晚于系统启动时间到达的CPU可能没有与系统其余部分同步的TSC值。
系统软件、BIOS或SMM代码实际上可能试图将TSC设置为与系统其余部分相匹配的值，但完美的匹配通常无法保证。这可能导致系统从TSC同步状态回到TSC同步缺陷（即使很小）可能暴露给操作系统和任何虚拟化环境的状态。
3.3. TSC 和多插槽 / NUMA系统
----------------------------

在多插槽系统中，特别是在大型多插槽系统中，很可能会有单独的时钟源而不是单一的全局时钟。由于这些时钟由不同的晶体驱动，它们的频率不会完全一致，并且温度和电气变化会导致CPU时钟以及TSC随时间漂移。根据具体的时钟和总线设计，这种漂移可能是绝对误差固定的，也可能会随着时间积累。

此外，非常大的系统可能会故意调整单个核心的时钟。这种技术称为展频时钟（spread-spectrum clocking），可以减少时钟频率及其谐波处的电磁干扰（EMI），这可能是为了满足联邦通信委员会（FCC）对电信和计算机设备的标准要求。

因此，出于上述原因，建议不要信任NUMA或多插槽系统中的TSC保持同步。

3.4. TSC 和 C 状态
---------------------

处理器的C状态，尤其是C1E和更深的休眠状态，也可能给TSC带来问题。在这样的状态下，TSC可能停止前进，导致在恢复执行时，其TSC落后于其他CPU。操作系统必须基于CPU和芯片组标识检测并标记此类CPU。

在这种情况下，可以通过将TSC与已知的外部时钟源对齐来校正TSC。

3.5. TSC 频率变化 / P 状态
--------------------------

为了使情况稍微复杂一些，某些CPU可能会改变频率。它们可能以相同的速度运行TSC，也可能不这样做。由于频率变化可能是交错或渐变的，在某些时刻，TSC速率可能只知道落在某个值范围内。在这种情况下，TSC将不是一个稳定的时钟源，并且必须通过已知、稳定的外部时钟进行校准才能作为可用的时间源。

TSC是否以恒定速率运行或随P状态变化取决于具体模型，并且需要通过检查CPUID、芯片组或供应商特定的MSR字段来确定。

此外，一些供应商已知存在这样的bug：在正常操作期间P状态实际上得到了适当补偿，但在处理器不活动时，P状态可能会暂时提高以服务来自其他处理器的缓存缺失。在这种情况下，停机CPU上的TSC可能比非停机处理器的TSC更快前进。AMD Turion处理器已知存在此问题。

3.6. TSC 和 STPCLK / T 状态
------------------------------

发送给处理器的外部信号也可能导致TSC停止。这通常是为了防止过热条件而进行的热紧急电源控制，并且通常没有方法来检测这种情况的发生。
### 3.7 TSC 虚拟化 - VMX
-----------------------------

VMX 提供了对 RDTSC、RDMSR、WRMSR 和 RDTSCP 指令的条件捕获，这足以实现任何形式的 TSC 完全虚拟化。此外，VMX 允许传递主机 TSC 并加上 VMCS 中指定的一个额外的 TSC_OFFSET 字段。必须使用特殊指令来读取和写入 VMCS 字段。

### 3.8 TSC 虚拟化 - SVM
-----------------------------

SVM 提供了对 RDTSC、RDMSR、WRMSR 和 RDTSCP 指令的条件捕获，这足以实现任何形式的 TSC 完全虚拟化。此外，SVM 允许传递主机 TSC 并加上 SVM 控制块中指定的一个额外偏移字段。

### 3.9 Linux 中的 TSC 特征位
------------------------------

总的来说，除非架构明确保证，否则无法确保 TSC 始终保持完美的同步。即使如此，在多插槽或 NUMA 系统中，TSC 仍然可能独立运行，尽管它们在本地是一致的。以下是 Linux 用来表示各种 TSC 属性的特征位，但这些特征位仅适用于单处理器或多节点系统：

| 特征位                  | 描述                                                         |
|-------------------------|--------------------------------------------------------------|
| X86_FEATURE_TSC         | 硬件中可用 TSC                                                |
| X86_FEATURE_RDTSCP      | 可用 RDTSCP 指令                                              |
| X86_FEATURE_CONSTANT_TSC| TSC 速率不随 P 状态变化                                       |
| X86_FEATURE_NONSTOP_TSC | TSC 在 C 状态下不停止                                          |
| X86_FEATURE_TSC_RELIABLE| 跳过 TSC 同步检查（适用于 VMware）                             |

### 4. 虚拟化问题
==========================

时间管理对于虚拟化尤其具有挑战性，因为存在许多问题。最明显的问题是时间现在被主机和潜在的多个虚拟机共享。因此，虚拟操作系统并没有以 100% 的 CPU 使用率运行，尽管它可能会假定这一点。当禁用中断源时，它可能期望这种情况始终成立，但实际上只有其虚拟中断源被禁用，并且机器仍可能随时被抢占。这导致实际时间流逝、中断注入以及相关时钟源与真实时间不再完全同步的问题。

在一定程度上，这个问题也会出现在原生硬件上，例如在 BIOS 使用 SMM 模式时，X86 系统上的 SMM 模式可能会占用周期，但不会像虚拟化那样极端。然而，由于 SMM 模式可能导致类似虚拟化的问题，因此这是解决许多裸机问题的好理由。

#### 4.1 中断时钟
-----------------------

对于遗留操作系统来说，一个最直接的问题是系统时间管理例程通常是通过计数周期性中断来跟踪时间的。这些中断可能来自 PIT 或 RTC，但问题相同：主机虚拟化引擎可能无法提供每秒正确的中断数量，从而导致来宾时间落后。如果选择高中断率（如 1000 Hz），这将特别有问题，不幸的是，这是许多 Linux 来宾系统的默认设置。

解决这个问题有三种方法：首先，可以简单地忽略它。如果来宾有一个单独的时间来源来跟踪“墙钟”或“实时”，则可能不需要调整其中断以维持正确的时间。如果这还不够，则可能需要向来宾注入额外的中断以提高有效的中断率。这种方法在极端条件下会导致复杂情况，即主机负载或来宾滞后太多以至于无法补偿，因此另一种解决方案应运而生：来宾需要意识到丢失的滴答并内部进行补偿。虽然理论上很有前景，但在 Linux 中实施这种策略非常容易出错，许多常用 Linux 系统中分布着一些有缺陷的丢失滴答补偿变体。

Windows 使用周期性的 RTC 时钟作为内部计时手段，因此需要中断滑动来保持准确的时间。它使用的频率足够低（编辑注：是 18.2 Hz 吗？），因此在实践中还没有成为问题。

#### 4.2 TSC 采样和序列化
-----------------------------------

作为最高精度的时间源，CPU 的周期计数器引起了开发者的极大兴趣。正如上面解释的那样，这个计时器由于其本地、可能不稳定且可能不同步的特性而存在许多独特的问题。还有一个并非 TSC 独有的问题，但由于其非常精确的性质而显得尤为突出，那就是采样延迟。按定义，一旦读取计数器，它就已经过时了。然而，计数器也可能在实际使用结果之前被读取。
这是指令流超量级执行的结果，这种执行可能会乱序执行指令。这样的执行被称为非序列化执行。为了使用时间戳计数器（TSC）进行精确测量，必须强制进行序列化执行，这需要一个序列化指令，例如 CPUID 或对模型特定寄存器（MSR）的读取。
由于 CPUID 可能通过陷阱和模拟机制被虚拟化，这种序列化可能会给硬件虚拟化带来性能问题。因此，在某些情况下可能无法获得准确的时间戳计数器读数，并且实现中可能需要防止其他 CPU 观察到的 TSC “向后”读取，即使在其他方面系统是完全同步的情况下也是如此。

### 4.3 时间规范别名

此外，TSC 缺乏序列化在使用 TSC 结果与另一个时间源进行对比时带来了另一个挑战。由于 TSC 的精度要高得多，因此当另一个时钟仍然显示相同值时，TSC 可能会读取许多不同的值。
也就是说，您可能会在外部时钟 C 保持相同值的情况下读取 (T, T+10)。
由于非序列化的读取，您实际上可能会得到一个波动的范围——从 (T-1 到 T+10)。因此，任何基于 TSC 计算但校准于外部值的时间可能具有一个有效的值范围。
重新校准此计算实际上可能导致校准后计算出的时间相对于校准前计算出的时间倒退。
这个问题在 Linux 中特别明显，Linux 内部有一个时间源——内核时间，它以理论上高分辨率的时间规范表示，但其更新间隔要大得多，有时以滴答为单位，甚至在追赶模式下，以更大的步长更新。
这种别名要求在 KVM 时钟和其他基于 TSC 计算得出的值（如 TSC 虚拟化本身）的计算和重新校准时格外小心。

### 4.4 迁移

虚拟机的迁移会在两个方面给时间管理带来问题。
首先，迁移本身可能需要时间，在此期间无法传递中断，并且之后可能需要赶上客户机的时间。在这种情况下，NTP 可能在一定程度上有所帮助，因为所需的时钟修正通常足够小，可以落在 NTP 可修正范围内。
### 额外的担忧

基于TSC（或HPET，如果原始总线时钟被暴露）的定时器现在可能以不同的速率运行，这要求在虚拟机监视程序中通过某种方式对这些定时器进行虚拟化补偿。此外，迁移到更快的机器可能会排除使用直通TSC的可能性，因为无法在不使时间比平常更快前进的情况下将更快的时钟显示给客户机。较慢的时钟问题较小，因为它始终可以赶上原始速率。KVM时钟通过简单地存储与TSC相关的倍数和偏移量来避免这些问题，以便将客座操作系统转换回纳秒分辨率值。

#### 4.5 调度

由于调度可能基于精确的时间和中断触发，操作系统的调度算法可能会受到虚拟化的不利影响。理论上，这种影响是随机的且应普遍分布，但在一些人为的和真实场景（如客户设备访问、导致虚拟化退出的原因、可能的情境切换）中，情况并非总是如此。这种影响尚未得到充分研究。

为了解决这个问题，一些实现提供了半虚拟化的调度时钟，它揭示了虚拟机实际运行的CPU时间。

#### 4.6 看门狗

在硬件虚拟化下运行时，像Linux中的锁检测器这样的看门狗定时器可能会因定时器中断延迟或对实际时间流逝的误解而意外触发。通常，这些警告是误报，可以忽略，但在某些情况下可能需要禁用此类检测。

#### 4.7 延迟和精确计时

在虚拟化系统中，精确计时和延迟可能无法实现。这可能发生在系统控制物理硬件或发出延迟以补偿设备之间较慢的I/O时。第一个问题是对于虚拟化系统来说通常无法解决；没有一个完整的实时操作系统，硬件控制软件无法被充分虚拟化，而这需要一个实时感知的虚拟化平台。

第二个问题可能会导致性能问题，但这不大可能是显著的问题。在许多情况下，这些延迟可以通过配置或半虚拟化来消除。

#### 4.8 隐蔽信道和信息泄露

除了上述问题外，在任何完美的虚拟化时间实现之外，时间信息必然会泄露给客户机。这可能会让客户机推断出存在虚拟机监视程序（如同“红色药丸”类型的检测），并且可能通过CPU利用率作为信号通道来在客户机之间泄露信息。防止这类问题需要完全隔离的虚拟时间，这可能不再跟踪实际时间。这在某些安全或质量保证上下文中可能是有用的，但一般不推荐用于实际部署场景。
