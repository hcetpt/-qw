SPDX 许可证标识符: GPL-2.0

==============================
使用 KVM 运行嵌套虚拟机
==============================

嵌套虚拟机是指在另一个虚拟机内部运行一个虚拟机（它可以基于 KVM 或其他虚拟化技术）。一个简单的例子是在一个 KVM 虚拟机上运行另一个 KVM 虚拟机（本文档其余部分以此为例）：

```
              .----------------.  .----------------
|                |  |                |
              |      L2        |  |      L2        |
              | (Nested Guest) |  | (Nested Guest) |
              |                |  |                |
              |----------------'--'----------------|
              |                                    |
              |       L1 (Guest Hypervisor)        |
              |          KVM (/dev/kvm)            |
              |                                    |
      .------------------------------------------------------
|                 L0 (Host Hypervisor)                 |
      |                    KVM (/dev/kvm)                    |
      |------------------------------------------------------|
      |        Hardware (with virtualization extensions)     |
      '------------------------------------------------------'
```

术语说明：

- L0 – 第 0 层；裸金属主机，运行 KVM
- L1 – 第 1 层虚拟机；运行在 L0 上的虚拟机；也称为“虚拟机管理程序”，因为它本身能够运行 KVM
- L2 – 第 2 层虚拟机；运行在 L1 上的虚拟机，这是“嵌套虚拟机”

.. note:: 上图是基于 x86 架构建模的；
          s390x、ppc64 和其他架构可能有不同的嵌套设计。
          例如，s390x 始终有一个运行在裸金属上的 LPAR（逻辑分区）虚拟机管理程序，
          增加了一层，并且在嵌套配置中至少有四层——L0（裸金属，运行 LPAR 虚拟机管理程序）、
          L1（主机虚拟机管理程序）、L2（虚拟机管理程序）、L3（嵌套虚拟机）
          本文档将为所有架构坚持三层术语（L0、L1 和 L2），并将主要关注 x86

用例
---------

嵌套 KVM 在以下几种场景中有用：

- 作为开发者，您想在不同的操作系统（OS）上测试您的软件。与其从云提供商租用多个虚拟机（VM），
  使用嵌套 KVM 可以让您租用一个足够大的“虚拟机管理程序”（第 1 层虚拟机）。
  这样您可以创建多个嵌套虚拟机（第 2 层虚拟机），运行不同的操作系统，
  在这些系统上开发和测试您的软件。
- “虚拟机管理程序”及其嵌套虚拟机的实时迁移，用于负载均衡、灾难恢复等。
- VM 镜像创建工具（如 `virt-install` 等）通常会运行自己的虚拟机，
  用户期望这些工具能够在虚拟机内部工作。
- 某些操作系统内部使用虚拟化来提高安全性（例如，让应用程序安全地隔离运行）。
启用“嵌套”（x86）
-----------------------

从Linux内核版本4.20开始，默认启用了针对Intel和AMD的“嵌套”KVM参数。（尽管您的Linux发行版可能会覆盖此默认设置。）

如果您运行的是低于4.19版本的Linux内核，为了启用嵌套，请将KVM模块参数`nested`设置为`Y`或`1`。为了使此设置在重新启动后仍然有效，可以在配置文件中添加如下所示：

1. 在裸金属主机（L0）上列出内核模块并确保KVM模块已加载：

   ```shell
   $ lsmod | grep -i kvm
   kvm_intel             133627  0
   kvm                   435079  1 kvm_intel
   ```

2. 显示`kvm_intel`模块的信息：

   ```shell
   $ modinfo kvm_intel | grep -i nested
   parm:           nested:bool
   ```

3. 为了使嵌套KVM配置在重新启动后仍然有效，请在`/etc/modprobe.d/kvm_intel.conf`文件中放置以下内容（如果该文件不存在则创建它）：

   ```shell
   $ cat /etc/modprobe.d/kvm_intel.conf
   options kvm-intel nested=y
   ```

4. 卸载并重新加载KVM Intel模块：

   ```shell
   $ sudo rmmod kvm-intel
   $ sudo modprobe kvm-intel
   ```

5. 验证KVM的`nested`参数是否已启用：

   ```shell
   $ cat /sys/module/kvm_intel/parameters/nested
   Y
   ```

对于AMD主机，过程与上述相同，只是模块名称为`kvm-amd`。

其他与嵌套相关的内核参数（x86）
--------------------------------

如果您的硬件足够先进（例如Intel Haswell处理器或更高版本，具有更新的硬件虚拟化扩展），以下额外功能也将默认启用：“影子VMCS（虚拟机控制结构）”，裸金属主机（L0）上的APIC虚拟化。Intel主机的参数如下：

```shell
$ cat /sys/module/kvm_intel/parameters/enable_shadow_vmcs
Y

$ cat /sys/module/kvm_intel/parameters/enable_apicv
Y

$ cat /sys/module/kvm_intel/parameters/ept
Y
```

.. note:: 如果您怀疑您的L2（即嵌套虚拟机）运行较慢，请确保上述参数已启用（特别是`enable_shadow_vmcs`和`ept`）。

启动嵌套虚拟机（x86）
-----------------------

一旦您的裸金属主机（L0）配置了嵌套，您应该能够通过以下命令启动一个L1虚拟机：

```shell
$ qemu-kvm -cpu host [...]
```

这会将主机CPU的功能直接传递给虚拟机，或者为了更好的实时迁移兼容性，可以使用QEMU支持的命名CPU模型。例如：

```shell
$ qemu-kvm -cpu Haswell-noTSX-IBRS,vmx=on
```

然后，虚拟机管理程序将能够在加速KVM的支持下运行嵌套虚拟机。

启用“嵌套”（s390x）
-----------------------

1. 在主机管理程序（L0）上启用s390x的`nested`参数：

   ```shell
   $ rmmod kvm
   $ modprobe kvm nested=1
   ```

   .. note:: 在s390x上，内核参数`hpage`与`nested`参数互斥——即要启用`nested`，必须禁用`hpage`参数。

2. L1管理程序（L1）必须提供`sie` CPU特性——使用QEMU时，可以通过命令行`-cpu host`来实现“主机直通”。

3. 现在可以在L1（管理程序）中加载KVM模块：

   ```shell
   $ modprobe kvm
   ```

带有嵌套KVM的实时迁移
------------------------------

对于Intel x86系统，从Linux内核5.3和QEMU 4.2.0开始，将包含活动嵌套虚拟机（L2）的L1虚拟机迁移到另一台裸金属主机是可行的，而对于s390x甚至在更早版本中也支持。

在AMD系统上，一旦L1虚拟机启动了一个L2虚拟机，则不应再迁移或保存L1虚拟机（参考QEMU文档中的“savevm”/“loadvm”）。尝试在L2虚拟机运行时迁移或保存L1虚拟机将导致未定义的行为。您可能会在`dmesg`中看到一个`kernel BUG!`条目、内核‘oops’或直接的内核崩溃。这样的迁移或加载后的L1虚拟机将不再被认为是稳定或安全的，并且必须重启。

仅配置了支持嵌套但实际没有运行L2虚拟机的L1虚拟机，在AMD系统上预计可以正常工作，但在启动虚拟机后可能会失败。

迁移L2虚拟机总是期望成功，因此即使在AMD系统上，以下所有场景都应能正常工作：

- 将嵌套虚拟机（L2）迁移到同一裸金属主机上的另一个L1虚拟机。
- 将嵌套虚拟机（L2）迁移到不同裸金属主机上的另一个L1虚拟机。
将嵌套虚拟机（L2）迁移到裸金属主机
从嵌套环境中报告错误
-----------------------------------

调试“嵌套”问题可能涉及在L0、L1和L2的日志文件中筛选信息；这可能导致错误报告者与修复者之间的繁琐来回沟通。
- 提及您处于“嵌套”环境。如果您运行任何类型的“嵌套”，请明确说明。不幸的是，这需要特别指出，因为在报告错误时，人们往往会忘记提及他们使用了嵌套虚拟化。
- 确认您实际是在KVM上运行KVM。有时人们没有为其客户机管理程序（L1）启用KVM，导致他们以纯模拟模式或QEMU所称的“TCG”模式运行，但他们认为自己是在运行嵌套KVM。因此，“嵌套Virt”（也可能是指QEMU在KVM上运行）与“嵌套KVM”（KVM在KVM上运行）被混淆。

收集的信息（通用）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

以下不是详尽列表，但却是非常好的起点：

  - L0上的内核、libvirt和QEMU版本

  - L1上的内核、libvirt和QEMU版本

  - L1上的QEMU命令行——当使用libvirt时，可以在以下位置找到：``/var/log/libvirt/qemu/instance.log``

  - L2上的QEMU命令行——同样地，当使用libvirt时，获取完整的由libvirt生成的QEMU命令行

  - L0上的``cat /sys/cpuinfo``输出

  - L1上的``cat /sys/cpuinfo``输出

  - L0上的``lscpu``输出

  - L1上的``lscpu``输出

  - L0上的完整``dmesg``输出

  - L1上的完整``dmesg``输出

特定于x86的信息收集
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

下面两个命令，“x86info”和“dmidecode”，应该在大多数Linux发行版上具有相同名称：

  - L0上的``x86info -a``输出

  - L1上的``x86info -a``输出

  - L0上的``dmidecode``输出

  - L1上的``dmidecode``输出

特定于s390x的信息收集
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

除了前面提到的通用信息外，还推荐以下内容：

  - L1上的``/proc/sysinfo``；这也包括L0的信息
