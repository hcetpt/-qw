SPDX 许可证标识符: GPL-2.0

======================
x86 KVM 阴影MMU
======================

MMU（在arch/x86/kvm中的mmu.[ch]和paging_tmpl.h文件）负责向客户机呈现标准的x86 MMU，同时将客户机物理地址转换为主机物理地址。MMU代码试图满足以下要求：

- 正确性：
         客户机不应能够确定其运行在一个模拟的MMU上，除了时间方面（我们试图符合规范，而不是模拟特定实现如TLB大小的特性）
- 安全性：
         客户机不得访问分配给它的主机内存之外的任何内存
- 性能：
         最小化MMU带来的性能开销
- 扩展性：
         需要扩展到大内存和多VCPU的客户机
- 硬件支持：
         支持全部范围的x86虚拟化硬件
- 整合：
         Linux内存管理代码必须控制客户机内存，以便交换、页面迁移、页面合并、透明大页等特性无需修改即可工作
- 脏页跟踪：
         报告对客户机内存的写入以启用实时迁移和基于帧缓冲的显示
- 内存占用：
         保持内核固定内存的数量低（大多数内存应可压缩）
- 可靠性：
         避免多页或GFP_ATOMIC分配

缩略语
========

====  ====================================================================
PFN   主机页框号
HPA   主机物理地址
HVA   主机虚拟地址
GFN   客户机帧号
GPA   客户机物理地址
GVA   客户机虚拟地址
NGPA  嵌套客户机物理地址
NGVA  嵌套客户机虚拟地址
PTE   页表项（也用于泛指分页结构条目）
GPTE  客户机PTE（指GFN）
S_PTE  阴影PTE（指PFN）
TDP   二维分页（用于表示NPT和EPT的供应商中立术语）
====  ====================================================================

支持的虚拟和实际硬件
=====================

MMU支持第一代MMU硬件，允许在进入客户机时原子切换当前分页模式和CR3，以及二维分页（AMD的NPT和Intel的EPT）。所模拟的硬件是传统的2/3/4级x86 MMU，支持全局页、PAE、PSE、PSE36、CR0.WP和1GB页。模拟的硬件还能够在支持NPT的主机上暴露支持NPT的硬件。

地址转换
=========

MMU的主要任务是编程处理器的MMU以进行客户机地址的转换。不同的时间需要不同的转换：

- 当客户机分页被禁用时，我们将客户机物理地址转换为主机物理地址（GPA->HPA）
- 当客户机分页被启用时，我们将客户机虚拟地址转换为客户机物理地址，再转换为主机物理地址（GVA->GPA->HPA）
- 当客户机启动自己的客户机时，我们将嵌套客户机虚拟地址转换为嵌套客户机物理地址，再转换为客户机物理地址，最后转换为主机物理地址（NGVA->NGPA->GPA->HPA）

主要挑战是在仅支持1（传统）和2（TDP）次转换的硬件中编码1到3次转换。当所需的转换次数与硬件匹配时，MMU处于直接模式；否则它处于阴影模式（见下文）。

内存
======

客户机内存（GPA）是使用KVM的进程用户地址空间的一部分。用户空间定义了客户机地址与用户地址之间的转换（GPA->HVA）；请注意，两个GPA可能别名为同一个HVA，但反之则不行。
这些HVA可以使用主机可用的任何方法支持：匿名内存、文件支持内存和设备内存。主机可以在任何时候对内存进行分页。

事件
======

MMU由事件驱动，有些来自客户机，有些来自主机。
客户机生成的事件：

- 对控制寄存器（特别是CR3）的写操作
- INVLPG/INVLPGA指令执行
- 访问缺失或受保护的转换

主机生成的事件：

- GPA->HPA转换的变化（通过GPA->HVA变化或通过HVA->HPA变化）
- 内存压力（压缩器）

阴影页
==========

主要的数据结构是阴影页，'struct kvm_mmu_page'。一个阴影页包含512个S_PTE，这些可以是叶或非叶S_PTE。一个阴影页可以包含叶和非叶S_PTE的混合。
非叶S_PTE允许硬件MMU到达叶页，并且不直接与转换相关。它指向其他阴影页。
叶S_PTE对应于一个或两个编码在单个分页结构条目中的转换。这些总是转换堆栈的最低级别，更高层次的可选转换留给NPT/EPT处理。叶PTE指向客户机页。
以下表格展示了由叶页表项（leaf ptes）编码的转换，括号中表示更高层级的转换：

非嵌套来宾（Non-nested guests）:

  - 非分页模式：gpa -> hpa
  - 分页模式：gva -> gpa -> hpa
  - 分页模式 + TDP：(gva ->) gpa -> hpa

嵌套来宾（Nested guests）:

  - 非TDP：ngva -> gpa -> hpa  （*）
  - TDP：(ngva ->) ngpa -> gpa -> hpa

  - (*) 如果没有NPT，则来宾Hypervisor会将其ngva -> gpa转换编码到其页表中

影子页面包含以下信息：
  - role.level:
    这个影子页面所属的影子分页层次中的级别
    1 = 4K spte, 2 = 2M spte, 3 = 1G spte等
  - role.direct:
    如果设置，从这个页面可达的叶spte是针对一个线性范围的
    示例包括实模式转换、大来宾页面由小主机页面支持以及在NPT或EPT激活时的gpa -> hpa转换
    线性范围从(gfn << PAGE_SHIFT)开始，其大小由role.level决定（第一级为2MB，第二级为1GB，第三级为0.5TB，第四级为256TB）
    如果未设置，则该页面对应由gfn字段指定的一个来宾页表
  - role.quadrant:
    当role.has_4_byte_gpte = 1时，来宾使用32位gpte而主机使用64位spte。这意味着一个来宾页表包含的pte比主机多，因此需要多个影子页面来映射一个来宾页表
    对于第一级影子页面，role.quadrant可以是0或1，并表示来宾页表中的第一个或第二个512-gpte块。对于第二级页表，每个32位gpte被转换为两个64位spte（因为每个第一级来宾页由两个第一级影子页映射），所以role.quadrant取值范围为0..3。每个象限映射1GB虚拟地址空间
  - role.access:
    以uwx形式继承自父pte的来宾访问权限
    注意执行权限是正的，不是负的
  - role.invalid:
    页面无效且不应使用。这是一个当前被固定（由指向它的CPU硬件寄存器固定）的根页面；一旦它被解除固定，它将被销毁
`role.has_4_byte_gpte`:
    反映该页面有效的访客PTE的大小，即如果使用直接映射或64位gptes，则为`0`；如果使用32位gptes，则为`1`。

`role.efer_nx`：
    包含该页面有效的efer.nx值。

`role.cr0_wp`：
    包含该页面有效的cr0.wp值。

`role.smep_andnot_wp`：
    包含cr4.smep && !cr0.wp的有效值。对于此值为真的页面与其他页面不同（请参阅下面对cr0.wp=0的处理）。

`role.smap_andnot_wp`：
    包含cr4.smap && !cr0.wp的有效值。对于此值为真的页面与其他页面不同（请参阅下面对cr0.wp=0的处理）。

`role.smm`：
    如果页面在系统管理模式下有效，则为1。该字段确定了用于构建此影子页的kvm_memslots数组中的哪一项；它也用于从struct kvm_mmu_page通过kvm_memslots_for_spte_role宏和__gfn_to_memslot函数返回到memslot。

`role.ad_disabled`：
    如果MMU实例不能使用A/D位，则为1。EPT在Haswell之前没有A/D位；如果L1虚拟机不启用A/D位，影子EPT页表也不能使用A/D位。

`role.guest_mode`：
    表示该影子页是为嵌套访客创建的。

`role.passthrough`：
    该页面不由访客页表支持，但其第一个条目指向一个访客页表。如果NPT使用5级页表（主机CR4.LA57=1）并模拟L1的4级NPT（L1 CR4.LA57=0），则设置此标志。

`mmu_valid_gen`：
    此页面的MMU代数，用于快速清除VM内的所有MMU页面而不阻塞vCPU太长时间。具体来说，KVM更新每个VM的有效MMU代数，这会导致每个MMU页面的mmu_valid_gen不匹配，从而使所有现有MMU页面失效。失效的页面无法使用。因此，vCPU必须在重新进入访客之前加载一个新的有效根。MMU代数只可能是`0`或`1`。注意，TDP MMU不使用此字段，因为非根TDP MMU页面只能从其所有者根访问。因此，对于TDP MMU而言，在根页面中使用role.invalid来使所有MMU页面失效就足够了。
gfn:
要么包含被该页遮挡的访客页表中的转换项，要么是线性转换的基本页框。详见role.direct。

spt:
一个包含64位spte（二级页表项）的页，这些spte包含该页的转换信息。由KVM和硬件共同访问。
spt所指向的页的page->private将回指到阴影页结构。
spt中的spte指向访客页或低级别的阴影页。
具体来说，如果sp1和sp2是阴影页，则sp1->spt[n]可能指向__pa(sp2->spt)。sp2则通过parent_pte回指sp1。
spt数组形成一个DAG结构，其中阴影页作为节点，访客页作为叶子。

shadowed_translation:
一个包含512个阴影转换条目的数组，每个有效pte对应一个条目。用于从pte逆向映射到gfn以及其访问权限。当设置role.direct时，不分配shadow_translation数组。这是因为此数组中任何元素所包含的gfn可以在使用时从gfn字段计算得出。此外，当设置role.direct时，KVM不对每个gfn跟踪访问权限。详见role.direct和gfn。

root_count / tdp_mmu_root_count:
root_count是Shadow MMU中根阴影页的引用计数器。
vCPUs在获取将用作根页的阴影页时增加引用计数，即直接加载到硬件中的页（如CR3、PDPTRs、nCR3、EPTP）。只要引用计数非零，根页就不能被销毁。详见role.invalid。tdp_mmu_root_count类似，但仅在TDP MMU中作为原子引用计数器使用。
### parent_ptes:
这是指向该页的 SPT（页表项）的反向映射。如果 `parent_ptes` 的第 0 位为零，则只有一个 SPT 指向该页，并且 `parent_ptes` 指向这个单一的 SPT；否则，存在多个 SPT 指向该页，且 `(parent_ptes & ~0x1)` 指向一个包含父 SPT 列表的数据结构。

### ptep:
这是指向该影子页的 SPTE（影子页表项）的内核虚拟地址。此字段仅由 TDP MMU 使用，并与 `parent_ptes` 构成联合体。

### unsync:
如果为真，则该页中的转换可能与来宾的转换不匹配。这等同于 PTE 改变但 TLB 条目尚未刷新时的 TLB 状态。因此，在来宾执行 `invlpg` 或通过其他方式刷新其 TLB 时，会同步未同步的 PTE。此字段适用于叶页面。

### unsync_children:
该页中有多少个 SPT 指向了未同步的页面（或具有未同步子页面的页面）。

### unsync_child_bitmap:
这是一个位图，指示 SPT 中哪些 SPT 指向（直接或间接）可能未同步的页面。用于快速定位从给定页面可达的所有未同步页面。

### clear_spte_count:
仅在 32 位主机上存在，因为 64 位 SPT 无法原子写入。读取者在运行时不持有 MMU 锁的情况下使用此字段来检测正在进行的更新并重试，直到写入者完成写入。

### write_flooding_count:
来宾可能会多次写入页表，如果需要对该页进行写保护（见下面的“同步和未同步页面”），则会导致大量模拟。叶页面可以设置为未同步状态以避免频繁模拟，但对于非叶页面来说这是不可能的。此字段记录自上次实际使用页表以来触发的模拟次数；如果在此页上触发的模拟过于频繁，KVM 将取消映射该页以避免未来的模拟。

### tdp_mmu_page:
如果影子页是 TDP MMU 页，则此值为 1。此变量用于在遍历任何可能包含 TDP MMU 和影子 MMU 页面的数据结构时分叉控制流。

### 反向映射
==========
MMU 维护了一个反向映射，使得可以通过给定的 GFN 访问所有映射该页的 PTE。例如，在交换出一个页时会用到这一点。
同步与非同步页面
=====================

客户机使用两个事件来同步其TLB和页表：TLB刷新和页面失效（invlpg）。
TLB刷新意味着我们需要同步从客户机的CR3可达的所有SPT条目。这是昂贵的操作，因此我们保持所有客户机页表写保护，并在写入GPT条目时同步SPT条目到GPT条目。
一个特殊情况是当一个客户机页表可以从当前的客户机CR3到达。在这种情况下，客户机必须在使用转换之前发出invlpg指令。我们通过取消对客户机页面的写保护并允许客户机自由修改它来利用这一点。
我们在客户机调用invlpg时同步修改过的GPT条目。这减少了当客户机修改多个GPT条目或客户机页面不再作为页表使用而是用于随机客户机数据时我们必须进行的模拟量。
作为副作用，我们必须在TLB刷新时重新同步所有可达的非同步影子页面。

事件反应
==================

- 客户机页面错误（或NPT页面错误，或EPT违规）

这是最复杂的事件。页面错误的原因可能是：

  - 真实的客户机故障（客户机转换不允许访问）
  - 访问缺失的转换
  - 访问受保护的转换
    - 当记录脏页面时，内存被写保护
    - 同步影子页面被写保护
  - 访问不可翻译的内存（MMIO）

  （*）直接模式下不适用

处理页面错误的过程如下：

- 如果错误代码的RSV位被设置，则页面错误是由客户机访问MMIO引起的并且缓存的MMIO信息可用
- 走访影子页表
   - 检查SPT条目的有效代号（见下面的“快速无效化MMIO SPT条目”）
   - 将信息缓存到vcpu->arch.mmio_gva、vcpu->arch.mmio_access和vcpu->arch.mmio_gfn，并调用模拟器

- 如果错误代码中的P位和R/W位都被设置，这可能可以作为一个“快速页面错误”来处理（无需获取MMU锁）。详见Documentation/virt/kvm/locking.rst中的描述
- 如有必要，走访客户机页表以确定客户机转换（gva->gpa或ngpa->gpa）

   - 如果权限不足，将错误反射回客户机

- 确定主机页面

   - 如果这是一个MMIO请求，则没有主机页面；将信息缓存到vcpu->arch.mmio_gva、vcpu->arch.mmio_access和vcpu->arch.mmio_gfn

- 走访影子页表以找到转换的SPT条目，必要时实例化缺失的中间页表

   - 如果这是一个MMIO请求，将MMIO信息缓存到SPT条目，并在SPT条目上设置一些保留位（参见kvm_mmu_set_mmio_spte_mask的调用者）

- 尝试使页面非同步

   - 如果成功，我们可以让客户机继续并修改GPT条目

- 模拟指令

   - 如果失败，解除阴影页面并让客户机继续

- 更新任何由指令修改的转换

invlpg处理：

  - 走访影子页层次结构并丢弃受影响的转换
  - 尝试重新实例化指示的转换，希望客户机会在不久的将来使用它

客户机控制寄存器更新：

- 移动到CR3

  - 查找新的影子根
  - 同步新可达的影子页面

- 移动到CR0/CR4/EFER

  - 设置新的分页模式的MMU上下文
  - 查找新的影子根
  - 同步新可达的影子页面

主机转换更新：

  - 使用更新后的HVA调用MMU通知器
  - 通过反向映射查找受影响的SPT条目
  - 丢弃（或更新）转换

模拟cr0.wp
================

如果TDP未启用，主机必须保持cr0.wp=1，以便客户机内核的页面写保护有效，而不是客户机用户空间。当客户机cr0.wp=1时，这不会有问题。然而，当客户机cr0.wp=0时，我们无法将gpte.u=1，gpte.w=0映射为任何SPT条目（语义要求允许任何客户机内核访问加上用户读取访问）
我们通过根据故障类型将其权限映射为两种可能的SPT条目之一来处理这个问题：

- 内核写入故障：spte.u=0，spte.w=1（允许完全内核访问，禁止用户访问）
- 读取故障：spte.u=1，spte.w=0（允许完全读取访问，禁止内核写入访问）

（用户写入故障会生成#PF）

在第一种情况下还有两个额外的复杂性：

- 如果CR4.SMEP被启用：由于我们已将页面变为内核页面，内核现在可以执行它。我们通过也设置spte.nx来处理这个问题
如果我们遇到用户获取或读取故障，我们将改变spte.u=1并将spte.nx=gpte.nx改回来。为此工作，KVM在使用影子分页时强制EFER.NX为1。
如果 CR4.SMAP 被禁用：由于该页面已更改为内核页面，因此在启用 CR4.SMAP 时无法重用。我们通过设置 CR4.SMAP && !CR0.WP 来避免这种情况。请注意，在这里我们不关心 CR4.SMAP 已启用的情况，因为 KVM 会直接因权限检查失败而向客户机注入 #PF。

为了防止一个被转换为内核页面（cr0.wp=0）的 spte 在 cr0.wp 变为 1 后被内核写入，我们将 cr0.wp 的值作为页面角色的一部分。这意味着使用特定 cr0.wp 值创建的 spte 不能在 cr0.wp 具有不同值时使用 —— 它将被影子页表查找代码忽略。当使用 cr0.wp=0 和 cr4.smep=0 创建的 spte 在更改 cr4.smep 为 1 后使用时也存在类似的问题。为了避免这种情况，!cr0.wp && cr4.smep 的值也被作为页面角色的一部分。

大页
=====

MMU 支持所有组合的客户机和主机的大页和小页。
支持的页大小包括 4K、2M、4M 和 1G。4M 页被视为两个独立的 2M 页，因为在客户机和主机上 MMU 总是使用 PAE 分页。

为了实例化一个大 spte，必须满足四个约束条件：

- spte 必须指向一个大的主机页；
- 客户机 pte 必须是一个至少等效大小的大 pte（如果启用了 tdp，则没有客户机 pte，此条件自动满足）；
- 如果 spte 将具有写权限，那么大页帧不得与任何写保护页重叠；
- 客户机页必须完全包含在一个单一内存槽中。

为了检查最后两个条件，MMU 为每个内存槽和大页大小维护了一个 `->disallow_lpage` 数组。每有一个写保护页都会使其对应的 `disallow_lpage` 计数器递增，从而阻止大 spte 的实例化。未对齐内存槽末尾的帧人为地增加了 `->disallow_lpages`，使它们永远无法实例化。

MMIO spte 的快速无效化
=======================

如上文“事件响应”所述，KVM 会在叶 spte 中缓存 MMIO 信息。当添加新的内存槽或现有内存槽发生改变时，这些信息可能会过时并需要被无效化。这需要在遍历所有影子页时持有 MMU 锁，并且通过类似的技术来提高可扩展性。

MMIO spte 拥有几个备用位，用于存储一个代号。全局代号存储在 `kvm_memslots(kvm)->generation` 中，并在客户机内存信息发生变化时递增。

当 KVM 找到一个 MMIO spte 时，它会检查该 spte 的代号。
如果 spte 的代号不等于全局代号，它将忽略缓存的 MMIO 信息并通过慢路径处理页面错误。

由于在 MMIO spte 上只使用了 18 位来存储代号，所以在溢出时所有页面都会被清除。
不幸的是，一次内存访问可能会多次访问 `kvm_memslots(kvm)`，最后一次发生在检索并存储生成号到 MMIO SPT（页表项）时。因此，MMIO SPT 可能是基于过时的信息创建的，但具有最新的生成号。

为了避免这种情况，在 `synchronize_srcu` 返回后再次递增生成号；因此，在 memslot 更新期间，`kvm_memslots(kvm)->generation` 的第 63 位被设置为 1，而此时一些 SRCU 读取器可能还在使用旧的副本。我们不希望使用带有奇数生成号的 MMIO SPT，并且可以在不损失 MMIO SPT 中的一个比特的情况下实现这一点。生成号中的“更新进行中”位没有存储在 MMIO SPT 中，因此当从 SPT 中提取生成号时，该位默认为零。如果 KVM 不幸地在更新过程中创建了 MMIO SPT，则下一次对该 SPT 的访问将始终是缓存未命中。例如，在更新窗口期间的后续访问会因为进行中的标志分歧而未命中，而在更新窗口关闭后的访问将具有更高的生成号（与 SPT 相比）。

进一步阅读
=============

- 2008 年 KVM 论坛上的 NPT 演示文稿
  https://www.linux-kvm.org/images/c/c8/KvmForum2008%24kdf2008_21.pdf
