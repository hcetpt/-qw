SPDX 许可证标识符: GPL-2.0

===========================
KVM 停止轮询系统
===========================

KVM 停止轮询系统在 KVM 中提供了一种功能，可以在某些情况下通过在主机上进行一段时间的轮询来减少来宾的延迟。也就是说，当一个来宾 vCPU 已经让出 CPU，或者在 PowerPC 情况下，当单个 vcore 上的所有 vCPUs 都已让出 CPU 时，主机内核会在将 CPU 交给调度程序之前进行唤醒条件的轮询，以允许其他任务运行。轮询在可以快速再次运行来宾的情况下提供了延迟优势，至少可以节省一次通过调度程序的时间，通常在几微秒的范围内，尽管性能优势取决于工作负载。如果在轮询期间没有收到任何唤醒源或运行队列中的其他任务变得可运行，则会调用调度程序。因此，停止轮询对于具有非常短的唤醒周期的工作负载特别有用，在这种情况下，轮询所花费的时间被最小化，并且不调用调度程序的时间节省是可区分的。

通用的停止轮询代码实现在：

`virt/kvm/kvm_main.c: kvm_vcpu_block()`

PowerPC KVM-HV 的特定情况实现在：

`arch/powerpc/kvm/book3s_hv.c: kvmppc_vcore_blocked()`

停止轮询间隔
=====================

在调用调度程序之前进行轮询的最大时间，称为停止轮询间隔，会根据轮询效果的好坏进行增加和减少，以限制无意义的轮询。这个值存储在 vCPU 结构中：

`kvm_vcpu->halt_poll_ns`

或者在 PowerPC KVM-HV 的情况下，存储在 vcore 结构中：

`kvmppc_vcore->halt_poll_ns`

因此这是一个每 vCPU（或 vcore）的值。在轮询期间，如果在停止轮询间隔内收到了唤醒源，则间隔保持不变。如果没有在轮询间隔内收到唤醒源（从而调用了调度程序），有两种情况：要么轮询间隔和总阻塞时间小于全局最大轮询间隔（参见下面的模块参数），要么总阻塞时间大于全局最大轮询间隔。

如果轮询间隔和总阻塞时间都小于全局最大轮询间隔，则可以增加轮询间隔，希望下次在更长的轮询间隔内能够收到唤醒源并获得延迟优势。轮询间隔在函数 `grow_halt_poll_ns()` 中增长，并乘以模块参数 `halt_poll_ns_grow` 和 `halt_poll_ns_grow_start`。

如果总阻塞时间大于全局最大轮询间隔，则主机永远不会轮询足够长的时间（受全局最大值限制）来在轮询间隔内唤醒，因此最好缩小轮询间隔以避免无意义的轮询。轮询间隔在函数 `shrink_halt_poll_ns()` 中缩小，并除以模块参数 `halt_poll_ns_shrink`，或者如果 `halt_poll_ns_shrink == 0` 则设置为 0。

值得注意的是，这一调整过程试图确定某个稳态轮询间隔，但对于以大致恒定速率到来的唤醒才会真正有效，否则将不断调整轮询间隔。

[0] 总阻塞时间：
从调用停止轮询函数到收到唤醒源之间的时间（无论在此过程中是否调用了调度程序）。
模块参数
=================

KVM 模块有 3 个可调的模块参数，用于调整全局最大轮询间隔以及轮询间隔的增长和缩小速率。这些变量定义在 `include/linux/kvm_host.h` 中，并作为模块参数出现在 `virt/kvm/kvm_main.c` 或者 `arch/powerpc/kvm/book3s_hv.c`（针对 PowerPC KVM-HV 情况）中。

+-----------------------+---------------------------+-------------------------+
| 模块参数              | 描述                      | 默认值                  |
+-----------------------+---------------------------+-------------------------+
| halt_poll_ns          | 全局最大轮询间隔，定义了    | KVM_HALT_POLL_NS_DEFAULT|
|                       | 轮询间隔的上限值，即每个    |                         |
|                       | VCPU 的轮询间隔的最大值。   | （按架构的默认值）       |
+-----------------------+---------------------------+-------------------------+
| halt_poll_ns_grow     | 增大 halt 轮询间隔时所乘的 | 2                       |
|                       | 数值，在 `grow_halt_poll_ns()`|                         |
|                       | 函数中使用。               |                         |
+-----------------------+---------------------------+-------------------------+
| halt_poll_ns_grow_start| 初始值，在 `grow_halt_poll_ns()`| 10000                   |
|                       | 函数中从零开始增长的值。    |                         |
+-----------------------+---------------------------+-------------------------+
| halt_poll_ns_shrink   | 缩小 halt 轮询间隔时所除的 | 0                       |
|                       | 数值，在 `shrink_halt_poll_ns()`|                         |
|                       | 函数中使用。               |                         |
+-----------------------+---------------------------+-------------------------+

这些模块参数可以通过 `/sys/module/kvm/parameters/` 目录下的 sysfs 文件进行设置。

注意：这些模块参数是系统范围内的值，无法针对每个虚拟机单独调整。
对这些参数所做的任何更改将在下次 VCPU 停止时被新的和现有的 VCPU 捕获，但使用 KVM_CAP_HALT_POLL 的虚拟机除外（参见下一节）。

KVM_CAP_HALT_POLL
=================

KVM_CAP_HALT_POLL 是一个虚拟机功能，允许用户空间在每个虚拟机基础上覆盖 `halt_poll_ns`。使用 KVM_CAP_HALT_POLL 的虚拟机会完全忽略 `halt_poll_ns`（但仍遵守 `halt_poll_ns_grow`、`halt_poll_ns_grow_start` 和 `halt_poll_ns_shrink`）。
有关此功能的更多信息，请参阅 `Documentation/virt/kvm/api.rst`。

进一步说明
=============

- 设置 `halt_poll_ns` 模块参数时应谨慎，因为较大的值可能会导致在一个本来几乎空闲的机器上 CPU 使用率达到 100%。这是因为即使客户机在唤醒期间执行的工作很少且间隔较远，如果间隔时间短于全局最大轮询间隔（`halt_poll_ns`），则主机将始终在整个时间段内进行轮询，从而导致 CPU 利用率上升到 100%。
- 停止轮询基本上是在功耗和延迟之间的一种权衡，应该使用模块参数来调整这种倾向。空闲的 CPU 时间实际上被转换为主机内核时间，目的是减少进入客户机时的延迟。
- 当其他任务在该 CPU 上不可运行时，主机才会进行停止轮询，否则轮询会立即停止并调用调度程序以允许其他任务运行。因此，这不会让客户机导致 CPU 的拒绝服务攻击。
