SPDX 许可声明标识符: GPL-2.0

===========================================================
POWER9 外部中断虚拟化引擎 (XIVE 第一代)
===========================================================

支持的设备类型：
  - KVM_DEV_TYPE_XIVE     POWER9 XIVE 中断控制器第一代

此设备充当虚拟机中断控制器。它提供了 KVM 接口来配置底层 POWER9 XIVE 中断控制器中的虚拟机中断源。
仅能实例化一个 XIVE 实例。一个来宾 XIVE 设备需要一个 POWER9 主机，并且来宾操作系统应支持 XIVE 本机利用中断模式。如果不支持，则应使用称为 XICS（POWER7/8）的传统中断模式。
* 设备映射

  KVM 设备暴露了 XIVE 硬件的不同 MMIO 范围，这些范围对于中断管理是必需的。这些范围通过带有自定义 VM 故障处理程序的 VMAs 暴露给来宾。
1. 线程中断管理区 (TIMA)

  每个线程都有一个与之关联的线程中断管理上下文，该上下文由一组寄存器组成。这些寄存器使线程能够处理优先级管理和中断确认。最重要的寄存器包括：

      - 待处理中断缓冲区 (IPB)
      - 当前处理器优先级 (CPPR)
      - 通知源寄存器 (NSR)

  它们以四种不同的页面形式暴露给软件，每个页面提供不同特权级别的视图。第一页用于物理线程上下文，第二页用于虚拟机监控程序。只有第三页（操作系统）和第四页（用户级别）暴露给来宾。
2. 事件状态缓冲区 (ESB)

  每个源都与一个事件状态缓冲区 (ESB) 关联，该缓冲区提供了一对偶数/奇数页面，用于管理源：触发、结束中断 (EOI) 或关闭源等命令。
3. 设备直通

  当设备被直通到来宾时，源中断来自不同的硬件控制器（PHB4），暴露给来宾的 ESB 页面应适应这种变化。
  当设备硬件中断被映射到或从来宾中断编号空间中取消映射时，会调用 passthru_irq 辅助函数 kvmppc_xive_set_mapped() 和 kvmppc_xive_clr_mapped()。KVM 设备扩展了这些辅助函数，以清除正在映射的来宾中断编号的 ESB 页面，然后让 VM 故障处理程序重新填充这些页面。
  处理程序将插入对应于正在直通设备的硬件中断的 ESB 页面，或者如果设备已被移除，则插入初始的 IPI ESB 页面。
  ESB 重映射对来宾和设备驱动程序是完全透明的。所有处理都在 VFIO 和 KVM-PPC 上述辅助函数中完成。
* 组：

1. KVM_DEV_XIVE_GRP_CTRL
     提供对设备的全局控制

  属性：
    1.1 KVM_DEV_XIVE_RESET（只写）
    重置源和事件队列的中断控制器配置。用于 kexec 和 kdump。
错误：无

1.2 KVM_DEV_XIVE_EQ_SYNC（仅写入）
同步所有源和队列，并标记EQ页面为脏。这是为了确保在迁移虚拟机时捕获一致的内存状态。

错误：无

1.3 KVM_DEV_XIVE_NR_SERVERS（仅写入）
kvm_device_attr.addr指向一个__u32值，该值表示中断服务器数量（即，最高的可能vcpu id加一）。

错误：

| 错误代码 | 描述 |
|---------|----------------------------------|
| -EINVAL | 值大于KVM_MAX_VCPU_IDS          |
| -EFAULT | attr->addr的用户指针无效         |
| -EBUSY  | 已有一个vCPU连接到设备           |

2. KVM_DEV_XIVE_GRP_SOURCE（仅写入）
初始化XIVE设备中的新源并将其屏蔽。
属性：
中断源编号（64位）

kvm_device_attr.addr指向一个__u64值：

| 位数:    | 63 ... 2 | 1 | 0  |
|----------|----------|---|----|
| 值:      | 未使用   | 类型 | 级别 |

- 类型: 0:MSI 1:LSI
- 级别: 在LSI情况下的断言级别

错误：

| 错误代码 | 描述 |
|---------|----------------------------|
| -E2BIG  | 中断源编号超出范围          |
| -ENOMEM | 无法创建新的源块            |
| -EFAULT | attr->addr的用户指针无效     |
| -ENXIO  | 无法分配底层硬件中断        |

3. KVM_DEV_XIVE_GRP_SOURCE_CONFIG（仅写入）
配置源定位。

属性：
中断源编号（64位）

kvm_device_attr.addr指向一个__u64值：

| 位数:    | 63 ... 33 | 32 | 31 ... 3 | 2 ... 0 |
|----------|-----------|----|-----------|----------|
| 值:      | eisn      | 遮罩 | 服务器 | 优先级   |

- 优先级: 0-7 中断优先级
- 服务器: 选择处理中断的CPU编号
- 遮罩: 遮罩标志（未使用）
- eisn: 有效中断源编号

错误：

| 错误代码 | 描述 |
|---------|-----------------------------|
| -ENOENT | 未知源编号                  |
| -EINVAL | 未初始化的源编号             |
| -EINVAL | 无效的优先级                 |
| -EINVAL | 无效的CPU编号                |
| -EFAULT | attr->addr的用户指针无效      |
### 错误信息说明

```
-ENXIO   CPU事件队列未配置或底层硬件中断配置失败
-EBUSY   没有可用的CPU来处理中断
```

### 4. KVM_DEV_XIVE_GRP_EQ_CONFIG（读写）
#### 配置一个CPU的事件队列

**属性：**
- 事件队列描述符标识符（64位）

事件队列描述符标识符是一个元组（server, priority）：

```
位:     | 63   ....  32 | 31 .. 3 |  2 .. 0
值:     |    未使用     |  server | priority
```

`kvm_device_attr.addr` 指向以下结构：

```c
struct kvm_ppc_xive_eq {
    __u32 flags;
    __u32 qshift;
    __u64 qaddr;
    __u32 qtoggle;
    __u32 qindex;
    __u8  pad[40];
};
```

- `flags`: 队列标志
  - `KVM_XIVE_EQ_ALWAYS_NOTIFY`（必需）
    强制通知而不使用XIVE提供的END ESB机制进行合并
- `qshift`: 队列大小（2的幂）
- `qaddr`: 队列的真实地址
- `qtoggle`: 当前队列切换位
- `qindex`: 当前队列索引
- `pad`: 保留供将来使用

**错误：**

```
-ENOENT  无效的CPU编号
-EINVAL  优先级无效
-EINVAL  标志无效
-EINVAL  队列大小无效
-EINVAL  队列地址无效
-EFAULT  attr->addr 的用户指针无效
-EIO     底层硬件配置失败
```

### 5. KVM_DEV_XIVE_GRP_SOURCE_SYNC（只写）
#### 同步源以刷新事件通知

**属性：**
- 中断源编号（64位）

**错误：**

```
-ENOENT  未知源编号
-EINVAL  未初始化的源编号
```

### *VCPU状态*

XIVE IC 维护VP中断状态在一个内部结构中，称为NVT。当一个VP未被分配到硬件处理器线程时，如果VP是事件通知的目标，该结构可以由硬件更新。在迁移过程中，捕获NVT中的缓存IPB非常重要，因为它综合了待处理中断的优先级。我们捕获更多一些内容以报告调试信息。

`KVM_REG_PPC_VP_STATE (2 * 64bits)`：

```
位:     |  63  ....  32  |  31  ....  0  |
值:     |   TIMA word0   |   TIMA word1  |
位:     | 127       ..........       64  |
值:     |            未使用              |
```

### *迁移：*

使用XIVE原生利用模式保存VM的状态应遵循特定的顺序。当VM停止时：

1. 屏蔽所有源（PQ=01）以停止事件流。
2. 使用KVM控制`KVM_DEV_XIVE_EQ_SYNC`同步XIVE设备，以刷新任何在途事件通知并稳定EQs。此时，标记EQ页面为脏页，以确保它们在迁移序列中被传输。
3. 捕获目标源、EQ配置和线程中断上下文寄存器的状态。

恢复过程类似：

1. 恢复EQ配置。因为目标依赖于它。
2. 恢复目标。
3. 恢复线程中断上下文。
4. 恢复源状态。
5. 让vCPU运行。
