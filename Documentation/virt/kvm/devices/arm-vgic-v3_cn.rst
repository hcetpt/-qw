SPDX 许可证标识符: GPL-2.0

==============================================================
ARM 虚拟通用中断控制器版本 3 及以上 (VGICv3)
==============================================================

支持的设备类型：
  - KVM_DEV_TYPE_ARM_VGIC_V3     ARM 通用中断控制器版本 3.0

通过此 API 只能实例化一个 VGIC。创建的 VGIC 将作为虚拟机的中断控制器，要求模拟用户空间设备将中断注入到 VGIC 而不是直接注入到 CPU。在同一虚拟机上创建 GICv3 和 GICv2 是不可能的。创建一个 GICv3 客户端设备需要主机也支持 GICv3。

组：
  KVM_DEV_ARM_VGIC_GRP_ADDR
   属性：

    KVM_VGIC_V3_ADDR_TYPE_DIST（可读写，64位）
      GICv3 分配器寄存器映射在客户机物理地址空间中的基地址。仅对 KVM_DEV_TYPE_ARM_VGIC_V3 有效。
      此地址需要对齐到 64K，并且该区域覆盖 64 KB。
      
    KVM_VGIC_V3_ADDR_TYPE_REDIST（可读写，64位）
      GICv3 重分配器寄存器映射在客户机物理地址空间中的基地址。每个 VCPU 有两个 64K 页面，并且所有重分配器页面都是连续的。
      仅对 KVM_DEV_TYPE_ARM_VGIC_V3 有效。
      此地址需要对齐到 64K。

    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION（可读写，64位）
      kvm_device_attr.addr 指向的属性数据是一个 __u64 值，格式如下：

        位： | 63 ... 52 | 51 ... 16 | 15 - 12 | 11 - 0
        值： |     count |     base   |  flags  | index

      - index 编码了唯一的重分配器区域索引。
      - flags：保留供将来使用，目前为 0。
      - base 字段编码了区域内第一个重分配器的客户机物理基地址的 [51:16] 位。
      - count 编码了区域内重分配器的数量。必须大于 0。
      
      每个区域内的重分配器有两页 64K，并且这些重分配器在区域内是连续布局的。区域按照索引顺序填充重分配器。所有区域 count 字段之和必须大于或等于 VCPU 的数量。重分配器区域必须按递增索引顺序注册，从索引 0 开始。
特定重分配区域的特性可以通过预设 `attr` 数据中的索引字段来读取。
仅适用于 KVM_DEV_TYPE_ARM_VGIC_V3。
混合使用 KVM_VGIC_V3_ADDR_TYPE_REDIST 和 KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION 属性是无效的。
注意，为了获得可重复的结果（相同的 VCPU 在保存/恢复操作中与相同的重分配器关联），必须保留 VCPU 创建顺序、重分配区域创建顺序以及 VCPU 和区域创建之间的相应交错。任何顺序的变化都可能导致不同的 vcpu_id/重分配器关联，从而导致在恢复时无法运行的虚拟机。

错误：

    =======  =============================================================
    -E2BIG   地址超出可寻址 IPA 范围
    -EINVAL  地址对齐不正确，重分配区域计数/索引错误，混合使用重分配区域属性
    -EEXIST  地址已配置
    -ENOENT  尝试读取不存在的重分配区域的特性
    -ENXIO   该设备或硬件不支持此组或属性，或者缺少硬件支持
    -EFAULT  attr->addr 的用户指针无效
    =======  =============================================================

KVM_DEV_ARM_VGIC_GRP_DIST_REGS, KVM_DEV_ARM_VGIC_GRP_REDIST_REGS
属性：

`kvm_device_attr` 结构中的 `attr` 字段编码了两个值：

      bits:     | 63   ....  32  |  31   ....    0 |
      values:   |      mpidr     |      offset     |

所有分发器寄存器都是 (rw, 32位)，并且 `kvm_device_attr.addr` 指向一个 `__u32` 值。64位寄存器必须通过分别访问低字和高字来访问。
对只读寄存器的写入会被内核忽略。
`KVM_DEV_ARM_VGIC_GRP_DIST_REGS` 访问主分发器寄存器。
`KVM_DEV_ARM_VGIC_GRP_REDIST_REGS` 访问由 mpidr 指定的 CPU 的重分配器。
偏移量相对于 GICv3/4 规范中定义的 "[Re]Distributor 基地址"。读取或设置此类寄存器的效果与在实际硬件上读取或写入寄存器相同，除了以下寄存器：GICD_STATUSR、GICR_STATUSR、GICD_ISPENDR、GICR_ISPENDR0、GICD_ICPENDR 和 GICR_ICPENDR0。通过此接口访问这些寄存器时，其行为与架构定义的行为不同，以允许软件完全查看 VGIC 的内部状态。

mpidr 字段用于指定访问哪个重分配器。对于分配器，mpidr 被忽略。mpidr 编码基于架构定义的 MPIDR 中的亲和性信息，并且字段编码如下：

```
| 63 .... 56 | 55 .... 48 | 47 .... 40 | 39 .... 32 |
|    Aff3    |    Aff2    |    Aff1    |    Aff0    |
```

请注意，分配器字段不是分组的，而是无论使用哪个 mpidr 访问寄存器都返回相同的值。

当 KVM 实现发生直接可被客户机或用户空间观察到的变化时，GICD_IIDR.Revision 会被更新。用户空间应该从 KVM 读取 GICD_IIDR 并将读取的值写回，以确认其预期行为与 KVM 实现一致。用户空间应在设置其他任何寄存器之前设置 GICD_IIDR，以确保预期行为。

GICD_STATUSR 和 GICR_STATUSR 寄存器在架构上定义为清除位的写入没有效果，而设置位的写入会清除该值。为了允许用户空间自由设置这两个寄存器的值，使用这些寄存器的偏移量设置属性时，仅将非保留位设置为写入的值。

对 GICD_ISPENDR 寄存器区域和 GICR_ISPENDR0 寄存器的访问（读取和写入）获取/设置中断的锁定待处理状态的值。

这与边缘触发中断的 ISPENDR 客户机读取返回的值相同，但对于电平触发中断可能有所不同。对于边缘触发中断，一旦中断变为待处理状态（无论是由于检测到输入线上的边缘还是由于客户机写入 ISPENDR），这种状态就会“锁定”，并且只有在中断被激活或客户机写入 ICPENDR 时才会清除。电平触发中断可能是由于设备保持高电平输入，或者是由于客户机写入 ISPENDR 寄存器。只有 ISPENDR 写入是锁定的；如果设备降低了线路电平，则中断不再待处理，除非客户机也写入了 ISPENDR，反之，写入 ICPENDR 或激活中断不会清除待处理状态，如果线路电平仍然保持高电平。（这些规则记录在 GICv3 规范中 ICPENDR 和 ISPENDR 寄存器的描述中。）对于电平触发中断，这里访问的值是 ISPENDR 设置并由 ICPENDR 或中断激活清除的锁定值，而客户机从 ISPENDR 读取返回的值是锁定值与输入线路电平的逻辑或。

提供对锁定状态的原始访问权限是为了让用户空间能够保存和恢复整个 GIC 内部状态（由当前输入线路电平和锁定状态组合定义，并且无法仅从线路电平和 ISPENDR 寄存器值推断出来）。

对 GICD_ICPENDR 寄存器区域和 GICR_ICPENDR0 寄存器的访问具有 RAZ/WI 语义，这意味着读取总是返回 0，写入总是被忽略。
错误：

    ======  =====================================================
    -ENXIO  获取或设置该寄存器尚不支持
    -EBUSY  一个或多个VCPUs正在运行
    ======  =====================================================

KVM_DEV_ARM_VGIC_GRP_CPU_SYSREGS
属性：

    kvm_device_attr的attr字段编码了两个值：

      bits:     | 63      ....       32 | 31  ....  16 | 15  ....  0 |
      values:   |         mpidr         |      RES     |    instr    |

    mpidr字段根据架构定义的MPIDR中的亲和信息编码CPU ID，并且该字段编码如下：

      | 63 .... 56 | 55 .... 48 | 47 .... 40 | 39 .... 32 |
      |    Aff3    |    Aff2    |    Aff1    |    Aff0    |

    instr字段根据A64指令集编码中定义的系统寄存器访问字段编码要访问的系统寄存器（RES表示这些位保留用于将来使用，应为零）：

      | 15 ... 14 | 13 ... 11 | 10 ... 7 | 6 ... 3 | 2 ... 0 |
      |   Op 0    |    Op1    |    CRn   |   CRm   |   Op2   |

    通过此API访问的所有系统寄存器都是（读写，64位），并且kvm_device_attr.addr指向一个__u64值。
KVM_DEV_ARM_VGIC_GRP_CPU_SYSREGS访问由mpidr字段指定的CPU的CPU接口寄存器。
AArch32模式下未实现CPU接口寄存器访问。
在AArch32模式下访问时返回错误-ENXIO。
错误：

    =======  =====================================================
    -ENXIO   获取或设置此寄存器尚未支持
    -EBUSY   VCPU正在运行
    -EINVAL  提供的mpidr或寄存器值无效
    =======  =====================================================

KVM_DEV_ARM_VGIC_GRP_NR_IRQS
属性：

    描述此GIC实例中断数量（SGI、PPI和SPI）的一个值，范围从64到1024，以32为增量。
kvm_device_attr.addr指向一个__u32值。
错误：

    =======  ======================================
    -EINVAL  设置的值超出预期范围
    -EBUSY   值已设置
    =======  ======================================

KVM_DEV_ARM_VGIC_GRP_CTRL
属性：

    KVM_DEV_ARM_VGIC_CTRL_INIT
      请求初始化VGIC，kvm_device_attr.addr中没有附加参数。必须在所有VCPUs创建后调用。
KVM_DEV_ARM_VGIC_SAVE_PENDING_TABLES
      将所有LPI待处理位保存到待处理表中的guest RAM。
该操作不会改变待处理表的前一千字节。
错误：

    =======  ========================================================
    -ENXIO   在调用此属性之前，VGIC 未按要求正确配置
    -ENODEV  没有在线的 VCPU
    -ENOMEM  分配 VGIC 内部数据时内存不足
    -EFAULT  无效的客户机内存访问
    -EBUSY   一个或多个 VCPU 正在运行
    =======  ========================================================

KVM_DEV_ARM_VGIC_GRP_LEVEL_INFO

属性：

`kvm_device_attr` 的 `attr` 字段编码以下值：

    bits:     | 63      ....       32 | 31   ....    10 | 9  ....  0 |
    values:   |         mpidr         |      info       |   vINTID   |

`vINTID` 指定报告的一组中断（IRQ）。

`info` 字段指定了用户空间想要通过此接口获取或设置的信息。目前我们支持以下 `info` 值：

- VGIC_LEVEL_INFO_LINE_LEVEL：获取/设置一组连续编号的 32 个中断的输入级别。
`vINTID` 必须是 32 的倍数。
`kvm_device_attr.addr` 指向一个 `__u32` 值，该值将包含一个位图，其中设置的位表示中断级别被断言。
位 `[n]` 表示中断 `vINTID + n` 的状态。
SGI 以及任何具有高于支持中断数量的更高 ID 的中断将被重置为零/写入无效（RAZ/WI）。LPI 总是边沿触发的，因此不支持此接口。
根据 `mpidr` 字段指定的 PPI 将按 VCPU 报告，而 SPI 不管 `mpidr` 如何指定，都将使用相同的值报告。
`mpidr` 字段根据架构定义的 MPIDR 中的亲和性信息编码 CPU ID，并且字段编码如下：

    | 63 .... 56 | 55 .... 48 | 47 .... 40 | 39 .... 32 |
    |    Aff3    |    Aff2    |    Aff1    |    Aff0    |

错误：

    =======  =============================================
    -EINVAL  `vINTID` 不是 32 的倍数或者 `info` 字段不是 `VGIC_LEVEL_INFO_LINE_LEVEL`
    =======  =============================================
