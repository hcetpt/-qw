SPDX 许可证标识符: GPL-2.0

=======================================
内核与 HYP 之间的内部 ABI
=======================================

此文件记录了当 Linux 作为虚拟机监视器（例如 KVM）运行时，Linux 内核与虚拟机监视器层之间的交互。它不涵盖当作为来宾（在 Xen、KVM 或任何其他虚拟机监视器上）运行时内核与虚拟机监视器的交互，也不涵盖当内核作为主机使用时任何特定于虚拟机监视器的交互。
注意：KVM/arm 已从内核中移除。此处描述的 API 仍然有效，因为它允许内核在启动到 HYP 时进行 kexec。如果需要，也可以被非 KVM 的虚拟机监视器使用。
在 arm 和 arm64（没有 VHE）上，内核不会以虚拟机模式运行，但仍需与其交互，以允许安装或拆除内置的虚拟机监视器。
为了实现这一点，内核必须在 HYP（arm）或 EL2（arm64）下启动，以便它可以安装一组存根，然后再降级到 SVC/EL1。这些存根可以通过使用 'hvc #0' 指令访问，并且仅对单个 CPU 起作用。
除非另有说明，任何内置的虚拟机监视器都必须实现以下功能（参见 arch/arm{,64}/include/asm/virt.h）：

* ::

    r0/x0 = HVC_SET_VECTORS
    r1/x1 = vectors

  将 HVBAR/VBAR_EL2 设置为 'vectors' 以启用虚拟机监视器。'vectors' 必须是一个物理地址，并且要符合架构的对齐要求。仅由初始存根实现，而不是由 Linux 虚拟机监视器实现。
* ::

    r0/x0 = HVC_RESET_VECTORS

  关闭 HYP/EL2 MMU 并将 HVBAR/VBAR_EL2 重置为初始存根的异常向量值。这有效地禁用了现有的虚拟机监视器。
* ::

    r0/x0 = HVC_SOFT_RESTART
    r1/x1 = 重启地址
    x2 = 进入下一个有效负载时 x0 的值（arm64）
    x3 = 进入下一个有效负载时 x1 的值（arm64）
    x4 = 进入下一个有效负载时 x2 的值（arm64）

  屏蔽所有异常，禁用 MMU，清除 I+D 位，将参数放置到位（仅 arm64），然后在 HYP/EL2 下跳转到重启地址。此超调用不期望返回给调用者。
* ::

    x0 = HVC_FINALISE_EL2 （仅 arm64）

  根据命令行选项完成配置 EL2，包括尝试通过启用 VHE 模式将内核的异常级别从 EL1 升级到 EL2。这取决于 CPU 支持 VHE、EL2 MMU 关闭以及 VHE 未因其他原因（如命令行选项）被禁用。
r0/x0 的任何其他值都会触发特定于虚拟机监视器的处理，这些处理在此处不予记录。
存根超调用的返回值保存在寄存器 r0/x0 中，在成功时为 0，失败时为 HVC_STUB_ERR。存根超调用允许破坏任何由调用者保存的寄存器（在 arm64 上为 x0-x18，在 arm 上为 r0-r3 和 ip）。因此，建议使用函数调用来执行超调用。
