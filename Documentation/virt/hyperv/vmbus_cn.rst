SPDX 许可证标识符: GPL-2.0

VMBus
=====
VMBus 是 Hyper-V 提供给客户机虚拟机（VM）的一种软件结构。它包括一个控制路径和合成设备所使用的通用设施，这些设备由 Hyper-V 向客户机虚拟机展示。控制路径用于向客户机虚拟机提供合成设备，并在某些情况下撤销这些设备。通用设施包括软件通道，用于客户机虚拟机中的设备驱动程序与 Hyper-V 中的合成设备实现之间的通信，以及允许 Hyper-V 和客户机互相中断的信号原语。

在 Linux 中，VMBus 被建模为一个总线，在运行中的 Linux 客户机中有一个预期的 `/sys/bus/vmbus` 目录条目。VMBus 驱动程序 (`drivers/hv/vmbus_drv.c`) 建立了与 Hyper-V 主机的 VMBus 控制路径，然后将自己注册为 Linux 总线驱动程序。它实现了标准的总线功能，用于向总线添加和移除设备。

大多数由 Hyper-V 提供的合成设备都有相应的 Linux 设备驱动程序。这些设备包括：

* SCSI 控制器
* 网络接口控制器（NIC）
* 图形帧缓冲区
* 键盘
* 鼠标
* PCI 设备直通
* 心跳
* 时间同步
* 关机
* 内存气球
* 与 Hyper-V 的键值对（KVP）交换
* Hyper-V 在线备份（即 VSS）

客户机虚拟机可能有多个合成 SCSI 控制器、合成 NIC 和 PCI 直通设备的实例。其他合成设备每个虚拟机仅限一个实例。未列出的是 Hyper-V 提供给仅适用于 Windows 客户机的少量合成设备，Linux 没有对应的驱动程序。

Hyper-V 使用术语“VSP”和“VSC”来描述合成设备。“VSP”指的是实现特定合成设备的 Hyper-V 代码，而“VSC”指的是客户机虚拟机中的设备驱动程序。例如，合成 NIC 的 Linux 驱动程序被称为“netvsc”，合成 SCSI 控制器的 Linux 驱动程序称为“storvsc”。这些驱动程序包含类似 `storvsc_connect_to_vsp` 的函数名。

VMBus 通道
--------------
一个合成设备实例使用 VMBus 通道在 VSP 和 VSC 之间进行通信。通道是双向的，用于传递消息。大多数合成设备使用单个通道，但合成 SCSI 控制器和合成 NIC 可能使用多个通道以实现更高的性能和更大的并行性。

每个通道由两个环形缓冲区组成。这些是大学数据结构教科书中经典的环形缓冲区。如果读写指针相等，则认为该环形缓冲区为空，因此满的环形缓冲区始终至少有一个字节未被使用。

“入”环形缓冲区用于从 Hyper-V 主机到客户机的消息，“出”环形缓冲区用于从客户机到 Hyper-V 主机的消息。在 Linux 中，“入”和“出”的标识是从客户机一侧来看的。环形缓冲区是客户机和主机之间共享的内存，并遵循标准范式，其中内存由客户机分配，组成环形缓冲区的 GPA 列表被通知给主机。每个环形缓冲区包含一个 4 Kbyte 的头部页面，带有读取和写入索引及一些控制标志，接着是实际环的内存。环的大小由客户机中的 VSC 确定，并且对于每个合成设备都是特定的。组成环的 GPA 列表通过 VMBus 控制路径作为 GPA 描述符列表（GPADL）发送给 Hyper-V 主机。参见函数 `vmbus_establish_gpadl()`。

每个环形缓冲区被映射到连续的 Linux 内核虚拟空间中，分为三个部分：1）4 Kbyte 的头部页面，2）构成环本身的内存，3）构成环本身的内存的第二个映射。由于（2）和（3）在内核虚拟空间中是连续的，因此复制数据进出环形缓冲区的代码不必关心环形缓冲区的回绕问题。

一旦复制操作完成，读或写索引可能需要重置以指向第一个映射，但实际的数据复制不需要分成两部分。这种方法还允许直接在环中轻松访问复杂的数据结构，而不必处理回绕问题。

在 arm64 上，当页大小 > 4 Kbytes 时，头部页面仍需作为 4 Kbytes 区域传递给 Hyper-V。但实际环的内存必须对齐到 `PAGE_SIZE` 并且大小是 `PAGE_SIZE` 的倍数，以便可以执行重复映射技巧。因此，头部页面的一部分未被使用且不通知给 Hyper-V。这种情况由 `vmbus_establish_gpadl()` 函数处理。
Hyper-V 对通过 GPADLs 与主机共享的来宾内存总量施加了限制。这一限制确保了一个恶意来宾不会消耗过多的主机资源。对于 Windows Server 2019 及以后的版本，这一限制大约为 1280 MB。对于 Windows Server 2019 之前的版本，限制大约为 384 MB。

### VMBus 通道消息
所有在 VMBus 通道中发送的消息都有一个标准头，其中包括消息长度、消息有效载荷的偏移量、一些标志以及事务ID。消息头部之后的部分是每个 VSP/VSC 对特有的。
消息遵循以下两种模式之一：

- **单向**：任一方发送一条消息且不期望收到响应。
- **请求/响应**：一方（通常是来宾）发送一条消息并期望收到响应。

事务ID（又称为“请求ID”）用于匹配请求和响应。某些合成设备允许同时处理多个请求，因此来宾在发送请求时会指定一个事务ID。Hyper-V 在对应的响应中返回相同的事务ID。
VSP 和 VSC 之间传递的消息是控制消息。例如，从 storvsc 驱动程序发送的消息可能是“执行此 SCSI 命令”。如果消息还涉及到来宾和 Hyper-V 主机之间的数据传输，则实际要传输的数据可以嵌入到控制消息中，也可以作为 Hyper-V 主机将通过 DMA 操作访问的单独数据缓冲区。前者适用于数据量较小且复制数据到环形缓冲区的成本最小的情况。例如，来自 Hyper-V 主机到来宾的时间同步消息包含实际时间值。当数据较大时，则使用单独的数据缓冲区。在这种情况下，控制消息包含一个描述数据缓冲区的 GPA 列表。例如，storvsc 驱动程序采用这种方法来指定用于磁盘 I/O 的数据缓冲区。
存在三个函数用于发送 VMBus 通道消息：

1. `vmbus_sendpacket()`：仅控制消息和带有嵌入数据的消息——没有 GPA。
2. `vmbus_sendpacket_pagebuffer()`：包含 GPA 列表以标识要传输的数据。每个 GPA 都有关联的偏移量和长度，以便可以针对来宾内存中的多个不连续区域。
3. `vmbus_sendpacket_mpb_desc()`：包含 GPA 列表以标识要传输的数据。GPA 列表有一个单一的偏移量和长度，这些 GPA 必须描述一个逻辑上的来宾内存区域。

历史上，Linux 来宾信任 Hyper-V 发送的格式正确且有效的消息，而合成设备的 Linux 驱动程序并未完全验证这些消息。随着引入了完全加密来宾内存并允许来宾不信任虚拟机管理程序的技术（如 AMD SEV-SNP、Intel TDX），信任 Hyper-V 主机不再是有效的假设。VMBus 合成设备的驱动程序正在更新以完全验证从与 Hyper-V 共享的内存中读取的所有值，包括 VMBus 设备的消息。为了便于此类验证，来宾从“输入”环形缓冲区读取的消息会被复制到一个不与 Hyper-V 共享的临时缓冲区。在此临时缓冲区中进行验证，避免 Hyper-V 在验证后但使用前恶意修改消息的风险。

### 合成中断控制器 (synic)
Hyper-V 为每个来宾 CPU 提供了一个合成中断控制器，用于 VMBus 的主机-来宾通信。尽管每个 synic 定义了 16 个合成中断（SINT），但 Linux 只使用其中一个（VMBUS_MESSAGE_SINT）。所有与 Hyper-V 主机和来宾 CPU 之间通信相关的中断都使用该 SINT。
SINT 映射到每个 CPU 的一个架构中断（即，8 位 x86/x64 中断向量或 arm64 PPI INTID）。由于来宾中的每个 CPU 都有一个 synic 并可能接收 VMBus 中断，因此在 Linux 中最好将其建模为每个 CPU 的中断。这个模型在 arm64 上运行良好，在这里为 VMBUS_MESSAGE_SINT 分配了一个每个 CPU 的 Linux IRQ。此 IRQ 在 /proc/interrupts 中显示为标记为“Hyper-V VMbus”的 IRQ。由于 x86/x64 缺乏对每个 CPU IRQ 的支持，因此在所有 CPU 上静态分配了一个 x86 中断向量（HYPERVISOR_CALLBACK_VECTOR），并显式编码以调用 vmbus_isr()。在这种情况下，没有 Linux IRQ，并且中断在 /proc/interrupts 的“HYP”行中汇总显示。
synic 提供了一种将架构中断解复用为一个或多个逻辑中断，并将逻辑中断路由到 Linux 中适当的 VMBus 处理程序的方法。这种解复用由 vmbus_isr() 和相关函数完成，它们访问 synic 数据结构。
### Synic 在 Linux 中的实现

Synic 在 Linux 中并不是以中断芯片或中断域的形式建模的，因此其分用的逻辑中断不是标准的 Linux IRQ。因此，它们不会出现在 `/proc/interrupts` 或 `/proc/irq` 中。这些逻辑中断的 CPU 亲和性是通过 `/sys/bus/vmbus` 下的一个条目来控制的，具体方法如下：

### VMBus 中断

VMBus 提供了一种机制，使得当来宾操作系统在环形缓冲区中排队了新消息时，可以中断主机。主机期望来宾仅在“输出”环形缓冲区从空变为非空时发送中断。如果来宾在其他时间发送中断，主机将认为这些中断是不必要的。如果来宾发送过多不必要的中断，主机可能会通过暂停其执行几秒钟来限制该来宾，以防止拒绝服务攻击。

同样地，当主机通过 VMBus 控制路径发送新消息或 VMBus 通道的“输入”环形缓冲区因主机插入新的 VMBus 通道消息而从空变为非空时，主机将通过 synic 中断来宾。控制消息流和每个 VMBus 通道的“输入”环形缓冲区都是单独的逻辑中断，由 `vmbus_isr()` 进行分用。它首先通过调用 `vmbus_chan_sched()` 检查通道中断，该函数查看 synic 的位图来确定哪些通道在此 CPU 上有待处理的中断。

如果有多个通道有待处理的中断，它们将依次进行处理。当所有通道中断都已处理后，`vmbus_isr()` 会检查并处理任何通过 VMBus 控制路径接收到的消息。

### VMBus 通道的 CPU 选择

VMBus 通道将中断的来宾 CPU 是在创建通道时由来宾选择的，并且主机被告知这一选择。VMBus 设备大致分为两类：

1. **“慢速”设备**：这类设备只需要一个 VMBus 通道。例如键盘、鼠标、心跳和时间同步设备，它们生成的中断相对较少。它们的 VMBus 通道都被分配给中断 `VMBUS_CONNECT_CPU`（通常是 CPU 0）。
   
2. **“高速”设备**：这类设备可能使用多个 VMBus 通道以提高并行性和性能。例如合成 SCSI 控制器和合成网卡。它们的 VMBus 通道中断被分配到分布在虚拟机中的可用 CPU 上，以便多个通道的中断可以并行处理。

VMBus 通道中断到 CPU 的分配是在 `init_vp_index()` 函数中完成的。这种分配是在标准的 Linux 中断亲和性机制之外完成的，因此这些中断既不是“未管理”的也不是“管理”的中断。

可以通过以下路径查看 VMBus 通道将中断的 CPU：
```
/sys/bus/vmbus/devices/<deviceGUID>/channels/<channelRelID>/cpu
```

在运行较新版本的 Hyper-V 时，可以通过写入新的值来更改这个 sysfs 条目。因为 VMBus 通道中断不是 Linux IRQ，所以在 `/proc/interrupts` 或 `/proc/irq` 中没有与单个 VMBus 通道中断对应的条目。

### 在线 CPU 的管理

在 Linux 来宾操作系统中，在线的 CPU 如果有 VMBus 通道中断分配给它，则不能将其下线。必须先手动将这些通道中断重新分配到另一个 CPU，如上所述。当没有通道中断分配给该 CPU 时，才能将其下线。
VMBus 通道中断处理代码设计为即使在非指定 CPU 上接收到中断也能正常工作。具体来说，该代码不使用基于 CPU 的排他性来保证正确性。在正常操作中，Hyper-V 将中断分配给指定的 CPU。但是当通过 sysfs 更改分配给通道的 CPU 时，客户机无法确切知道 Hyper-V 何时会进行切换。即使 Hyper-V 开始中断新 CPU 之前存在时间延迟，代码也必须能够正确工作。详见 `target_cpu_store()` 中的注释。

VMBus 设备创建/删除
--------------------
Hyper-V 和 Linux 客户机之间有一个单独的消息传递路径用于合成设备的创建和删除。这条路径不使用 VMBus 通道。详见 `vmbus_post_msg()` 和 `vmbus_on_msg_dpc()`。

第一步是客户机连接到通用的 Hyper-V VMBus 机制。在此过程中，客户机和 Hyper-V 约定将使用的 VMBus 协议版本。这种协商允许较新的 Linux 内核运行在较旧的 Hyper-V 版本上，反之亦然。

然后，客户机告诉 Hyper-V“发送报价”。Hyper-V 向客户机发送一条报价消息，对应于 VM 配置中的每个合成设备。每个 VMBus 设备类型都有一个固定的 GUID 称为“类 ID”，并且每个 VMBus 设备实例也由一个 GUID 标识。来自 Hyper-V 的报价消息包含这两个 GUID，以唯一地（在 VM 内）标识设备。

每个设备实例有一条报价消息，因此具有两个合成网卡的 VM 将收到两条带有网卡类 ID 的报价消息。报价消息的顺序可能因启动而异，在 Linux 代码中不应假设其一致性。由于 Hyper-V 支持向正在运行的 VM 添加设备（如合成网卡），报价消息也可能在 Linux 初次启动后很久才到达。新的报价消息由 `vmbus_process_offer()` 处理，间接调用 `vmbus_add_channel_work()`。

收到报价消息后，客户机根据类 ID 识别设备类型，并调用正确的驱动程序设置设备。驱动程序/设备匹配使用标准的 Linux 机制。

设备驱动程序探测函数打开到相应 VSP 的主 VMBus 通道。它为通道环形缓冲区分配客户机内存，并通过向主机提供环形缓冲区内存的 GPA 列表与 Hyper-V 主机共享环形缓冲区。详见 `vmbus_establish_gpadl()`。

一旦环形缓冲区设置好，设备驱动程序和 VSP 通过主通道交换设置消息。这些消息可能包括协商 Linux VSC 和 Hyper-V 主机上的 VSP 之间要使用的设备协议版本。设置消息还可能包括创建附加的 VMBus 通道，这些通道被称为“子通道”，尽管它们在创建后功能上等同于主通道。

最后，设备驱动程序可能会像任何其他设备驱动程序一样在 `/dev` 中创建条目。

Hyper-V 主机可以向客户机发送“撤销”消息来移除之前提供的设备。Linux 驱动程序必须随时处理此类撤销消息。撤销设备会调用设备驱动程序的“移除”函数来干净地关闭并移除设备。一旦合成设备被撤销，Hyper-V 和 Linux 都不会保留关于其先前存在的状态。这样的设备稍后可能会重新添加，在这种情况下，它将被视为全新的设备。详见 `vmbus_onoffer_rescind()`。
当然，请提供你需要翻译的文本。
