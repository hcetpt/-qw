.. _kernel_hacking_hack:

============================================
不可靠的Linux内核黑客指南
============================================

:作者: Rusty Russell

介绍
============

欢迎，亲爱的读者，来到Rusty的极其不可靠的Linux内核黑客指南。本文档描述了内核代码中的常见例程和一般要求：其目标是为有经验的C程序员提供Linux内核开发的入门指导。我避免讨论实现细节：因为代码本身已经说明了一切，并且我忽略了许多有用的例程。

在阅读本文之前，请理解我并不情愿写这份文档，因为我明显不够资格，但我一直希望能读到它，而这似乎是我唯一能实现的方式。我希望它能够发展成为一个包含最佳实践、常用起点和随机信息的汇编。

参与者
===========

在任何时候，系统中的每个CPU可以处于以下几种状态：

-  与任何进程无关，正在处理硬件中断；

-  与任何进程无关，正在处理软中断或任务项；

-  在内核空间运行，与一个进程（用户上下文）相关联；

-  在用户空间运行一个进程。
这些状态之间有一个顺序关系。下面两种状态可以互相抢占，但在此之上是一个严格的层次结构：每种状态只能被上面的状态抢占。例如，在一个软中断正在运行时，不会有其他软中断来抢占它，但硬件中断可以。然而，系统中的任何其他CPU都是独立执行的。

我们将看到多种方式，使用户上下文能够阻塞中断，从而变得真正不可抢占。

用户上下文
------------

当您从一个系统调用或其他陷阱进入时，您就处于用户上下文：像用户空间一样，您可以被更重要的任务或中断抢占。您可以通过调用 :c:func:`schedule()` 来睡眠。

.. note::

    您总是在模块加载和卸载以及对块设备层的操作中处于用户上下文。
在用户上下文中，`current` 指针（指示当前执行的任务）是有效的，并且 :c:func:`in_interrupt()` （`include/linux/preempt.h`）返回假（false）。
.. warning::

    注意，如果您禁用了抢占或软中断（见下文），:c:func:`in_interrupt()` 可能会返回假阳性结果。

硬件中断（硬IRQ）
-------------------------------

定时器滴答声、网卡和键盘等都是产生中断的真实硬件示例。内核运行中断处理程序以服务硬件。内核保证这个处理程序不会被重入：如果相同的中断到达，则会被排队（或丢弃）。由于它禁用了中断，这个处理程序必须快速完成：通常情况下，它只是确认中断，标记一个“软件中断”供执行，然后退出。
你可以判断自己处于硬件中断中，因为 `in_hardirq()` 返回 true。

.. warning::

    注意，如果中断被禁用，这将返回假阳性（详见下文）。

软件中断上下文：软中断和任务项
-----------------------------------

每当系统调用即将返回用户空间，或者硬件中断处理程序退出时，任何标记为待处理的“软件中断”（通常由硬件中断触发）都会运行（`kernel/softirq.c`）。大量的实际中断处理工作是在这里完成的。在向SMP（对称多处理）过渡的早期阶段，只有“下半部”（BHs），它们没有充分利用多个CPU。在我们从火柴棍和鼻涕制成的风车计算机转向现代计算机不久后，我们放弃了这种限制，转而使用“软中断”。

`include/linux/interrupt.h` 列出了不同的软中断。一个非常重要的软中断是定时器软中断（`include/linux/timer.h`）：你可以在给定的时间长度后注册让其调用你的函数。

软中断通常处理起来很麻烦，因为相同的软中断可能会同时在多个CPU上运行。因此，任务项（`include/linux/interrupt.h`）更常被使用：它们是动态可注册的（意味着你可以有任意多的任务项），并且还保证任何任务项在同一时间只在一个CPU上运行，尽管不同的任务项可以同时运行。

.. warning::

    名称“任务项”具有误导性：它们与“任务”无关。

你可以使用 C 宏 `in_softirq()` （`include/linux/preempt.h`）来判断自己是否处于软中断（或任务项）中。

.. warning::

    注意，如果持有 :ref:`下半部锁 <local_bh_disable>`，这将返回假阳性。

一些基本规则
==============

没有内存保护
    如果你在用户上下文或中断上下文中破坏了内存，整个机器将会崩溃。你确定不能在用户空间中实现你的需求吗？

没有浮点运算或MMX
    FPU（浮点单元）上下文没有保存；即使在用户上下文中，FPU状态可能也不对应当前进程：你会干扰某个用户进程的FPU状态。如果你真的想这样做，你必须显式地保存/恢复完整的FPU状态（并避免上下文切换）。这通常是不好的做法；首先尝试使用定点算术。
### 刚性的栈限制

根据配置选项，内核栈对于大多数32位架构大约是3K到6K：对于大多数64位架构大约是14K，并且通常与中断共享，因此你不能完全使用它。

避免深度递归和在栈上分配巨大的局部数组（应该动态分配它们）。

### Linux内核的可移植性

让我们保持这种状态。你的代码应该是64位兼容的，并且字节序无关的。你也应该尽量减少CPU特定的内容，例如内联汇编应该被干净地封装并最小化以方便移植。一般来说，它应该仅限于内核树中的架构相关部分。

### ioctl：不是编写新的系统调用

#### 系统调用通常如下所示：

```c
asmlinkage long sys_mycall(int arg)
{
        return 0;
}
```

首先，在大多数情况下你并不想创建一个新的系统调用。你应该创建一个字符设备并为其实现一个适当的ioctl。
这比系统调用更灵活，不需要在每个架构的`include/asm/unistd.h`和`arch/kernel/entry.S`文件中进行登记，并且更有可能被Linus接受。

如果所有你的程序做的只是读取或写入一些参数，请考虑实现一个:c:func:`sysfs()`接口。

在ioctl内部，你处于进程的用户上下文。当发生错误时，你返回一个负数的errno（参见`include/uapi/asm-generic/errno-base.h`、`include/uapi/asm-generic/errno.h`和`include/linux/errno.h`），否则返回0。

睡眠之后你应该检查是否发生了信号：Unix/Linux处理信号的方式是暂时退出系统调用并返回`-ERESTARTSYS`错误。系统调用入口代码将切换回用户上下文，处理信号处理器，然后重新启动你的系统调用（除非用户禁用了这一点）。因此你应该准备好处理重启，例如如果你正在操作某个数据结构：

```c
if (signal_pending(current))
        return -ERESTARTSYS;
```

如果你正在进行较长的计算：首先考虑用户空间。如果你**真的**想在内核中完成它，你应该定期检查是否需要放弃CPU（记住每个CPU上有合作式的多任务调度）。
惯用法：

```c
cond_resched(); /* 将会睡眠 */
```

关于接口设计的一个简短说明：UNIX系统调用的格言是“提供机制而非策略”。
### 死锁食谱

你不能调用任何可能会休眠的例程，除非：

- 你在用户上下文中
- 你没有拥有任何自旋锁
- 你已经启用了中断（实际上，Andi Kleen 说调度代码会为你启用它们，但这可能不是你想要的结果）

请注意，某些函数可能会隐式地休眠：常见的有用户空间访问函数（\*_user）和不带 ``GFP_ATOMIC`` 的内存分配函数。

你应该始终在编译内核时启用 ``CONFIG_DEBUG_ATOMIC_SLEEP`` 配置项，这样如果你违反了这些规则它会警告你。如果你确实违反了这些规则，最终会导致系统锁定。

### 常用例程

#### :c:func:`printk()`

定义于 ``include/linux/printk.h``

:c:func:`printk()` 将内核消息发送到控制台、dmesg 和 syslog 守护进程。它用于调试和报告错误，并且可以在中断上下文中使用，但请谨慎使用：一台被 printk 消息淹没的机器将变得不可用。它使用一个与 ANSI C printf 大致兼容的格式字符串，并通过 C 字符串连接提供第一个“优先级”参数，例如：

```c
printk(KERN_INFO "i = %u\n", i);
```

参见 ``include/linux/kern_levels.h``；其他 ``KERN_`` 值；这些值会被 syslog 解释为级别。特殊情况：打印 IP 地址时使用：

```c
__be32 ipaddress;
printk(KERN_INFO "my ip: %pI4\n", &ipaddress);
```

:c:func:`printk()` 内部使用了一个 1K 缓冲区，并且不会捕获溢出。确保这足够用。

.. note::

    当你在用户程序中开始把 `printf` 错写成 `printk` 时，你就知道你已经成为真正的内核黑客了 :)

.. note::

    另外一个小提示：原始的 Unix Version 6 源码在其 `printf` 函数顶部有一个注释：“不要用 printf 聊天”。你应该遵循这条建议

#### :c:func:`copy_to_user()` / :c:func:`copy_from_user()` / :c:func:`get_user()` / :c:func:`put_user()`

定义于 ``include/linux/uaccess.h`` / ``asm/uaccess.h``

**[SLEEPS]**

:c:func:`put_user()` 和 :c:func:`get_user()` 用于从用户空间获取和放入单个值（如 int、char 或 long）。用户空间中的指针不应简单地解引用：数据应该使用这些例程进行复制。这两个函数都返回 ``-EFAULT`` 或 0。

:c:func:`copy_to_user()` 和 :c:func:`copy_from_user()` 更通用：它们可以复制任意数量的数据到用户空间或从用户空间复制。
.. warning::

    与 :c:func:`put_user()` 和 :c:func:`get_user()` 不同，这些函数返回未复制的数据量（即 0 仍然表示成功）。
    [这种令人反感的接口让我感到不适。每隔几年就会引发一场争论。--RR.]

这些函数可能会隐式地休眠。绝不应该在用户上下文之外（没有意义）、中断被禁用或持有自旋锁的情况下调用它们。
:c:func:`kmalloc()` / :c:func:`kfree()`
-------------------------------------

定义在 `include/linux/slab.h`

**[可能会休眠：见下文]**

这些例程用于动态请求指针对齐的内存块，类似于用户空间中的 malloc 和 free 的操作，但 :c:func:`kmalloc()` 多了一个标志字。重要的值包括：

``GFP_KERNEL``
    可能会休眠并交换以释放内存。仅允许在用户上下文中使用，但这是最可靠的分配内存的方式。
``GFP_ATOMIC``
    不会休眠。不如 ``GFP_KERNEL`` 可靠，但可以在中断上下文中调用。你应该 **确实** 有一个良好的内存不足错误处理策略。
``GFP_DMA``
    分配低于 16MB 的 ISA DMA 内存。如果你不知道这是什么，你就不需要它。非常不可靠。

如果你看到一个关于从无效上下文调用休眠函数的警告信息，那么可能是你在中断上下文中调用了休眠分配函数而没有使用 ``GFP_ATOMIC``。你真的应该修复这个问题。

快跑，不要走

如果你分配至少为 ``PAGE_SIZE``（`asm/page.h` 或 `asm/page_types.h`）字节，考虑使用 :c:func:`__get_free_pages()`（`include/linux/gfp.h`）。它接受一个阶数参数（0 表示页面大小，1 表示双页，2 表示四页等）和上述相同的内存优先级标志字。

如果你分配超过一页的字节数，可以使用 :c:func:`vmalloc()`。它会在内核映射中分配虚拟内存。这个块在物理内存中不是连续的，但由于 MMU 的作用，对你来说看起来是连续的（因此它只对 CPU 看起来是连续的，对外部设备驱动程序不是）。如果你确实需要大块连续的物理内存来支持某些奇怪的设备，那你就有问题了：Linux 对此支持较差，因为随着时间的推移，运行中的内核中的内存碎片使得这变得困难。最好的方法是在启动过程的早期通过 :c:func:`alloc_bootmem()` 函数分配这块内存。

在发明自己的常用对象缓存之前，请考虑使用 `include/linux/slab.h` 中的 slab 缓存。

:c:macro:`current`
------------------

定义在 `include/asm/current.h`

这个全局变量（实际上是宏）包含指向当前任务结构的指针，因此仅在用户上下文中有效。例如，当一个进程调用系统调用时，这将指向调用进程的任务结构。在中断上下文中它是 **非空** 的。
:c:func:`mdelay()`/:c:func:`udelay()`
-------------------------------------

定义在 ``include/asm/delay.h`` / ``include/linux/delay.h``

:c:func:`udelay()` 和 :c:func:`ndelay()` 函数可用于小暂停。不要使用大值，因为这可能会导致溢出 —— 辅助函数 :c:func:`mdelay()` 在这种情况下很有用，或者考虑使用 :c:func:`msleep()`

:c:func:`cpu_to_be32()`/:c:func:`be32_to_cpu()`/:c:func:`cpu_to_le32()`/:c:func:`le32_to_cpu()`
-----------------------------------------------------------------------------------------------

定义在 ``include/asm/byteorder.h``

:c:func:`cpu_to_be32()` 家族（其中的 "32" 可以替换为 64 或 16，而 "be" 可以替换为 "le"）是内核中进行字节序转换的一般方法：它们返回转换后的值。所有变体都提供了反向转换：
:c:func:`be32_to_cpu()` 等。

这些函数有两个主要变体：指针变体，如 :c:func:`cpu_to_be32p()`，它接受指向给定类型的指针，并返回转换后的值。另一个变体是“原地”家族，如 :c:func:`cpu_to_be32s()`，它转换由指针引用的值，并返回 void。

:c:func:`local_irq_save()`/:c:func:`local_irq_restore()`
--------------------------------------------------------

定义在 ``include/linux/irqflags.h``

这些例程在本地 CPU 上禁用硬中断并恢复它们。它们是可重入的；将之前的中断状态保存在一个 `unsigned long flags` 参数中。如果你知道中断是启用的，可以简单地使用 :c:func:`local_irq_disable()` 和 :c:func:`local_irq_enable()`

.. _local_bh_disable:

:c:func:`local_bh_disable()`/:c:func:`local_bh_enable()`
--------------------------------------------------------

定义在 ``include/linux/bottom_half.h``

这些例程在本地 CPU 上禁用软中断并恢复它们。它们是可重入的；如果软中断之前已被禁用，在调用这对函数后它们仍然会被禁用。
它们阻止软中断和任务在当前 CPU 上运行。

:c:func:`smp_processor_id()`
----------------------------

定义在 ``include/linux/smp.h``

:c:func:`get_cpu()` 禁止抢占（因此你不会突然被移动到另一个 CPU），并返回当前处理器编号，介于 0 和 ``NR_CPUS`` 之间。请注意，CPU 编号不一定是连续的。当你完成时，通过 :c:func:`put_cpu()` 将其释放。

如果你知道你不会被另一个任务抢占（例如你在中断上下文中，或已禁用抢占），你可以使用 smp_processor_id()

``__init``/``__exit``/``__initdata``
------------------------------------

定义在 ``include/linux/init.h``

启动后，内核会释放一个特殊部分；标记为 ``__init`` 的函数和标记为 ``__initdata`` 的数据结构会在启动完成后被丢弃：类似地，模块在初始化后也会丢弃这部分内存。``__exit`` 用于声明仅在退出时需要的函数：如果此文件不是作为模块编译，则该函数将被丢弃。请参阅头文件中的使用说明。请注意，将标记为 ``__init`` 的函数通过 :c:func:`EXPORT_SYMBOL()` 或 :c:func:`EXPORT_SYMBOL_GPL()` 导出到模块是没有意义的——这会导致问题。
### `:c:func:`__initcall()`/:c:func:`module_init()`

定义于`include/linux/init.h` / `include/linux/module.h`

内核的许多部分都可以作为模块来很好地服务（即内核中可动态加载的部分）。使用`:c:func:`module_init()`和`:c:func:`module_exit()`宏，可以轻松编写代码，在不需要`#ifdef`的情况下既可以作为模块运行也可以编译进内核。

`:c:func:`module_init()`宏定义了在模块插入时（如果文件被编译为模块）或启动时（如果文件未被编译为模块）要调用的函数。如果文件不是以模块形式编译的，则`:c:func:`module_init()`宏等同于`:c:func:`__initcall()`宏，通过链接器魔法确保该函数在启动时被调用。

该函数可以返回一个负数错误码来导致模块加载失败（不幸的是，如果模块被编译到内核中，这没有效果）。这个函数在用户上下文中调用，并且中断是启用的，因此它可以休眠。

`:c:func:`module_exit()`
-----------------------

定义于`include/linux/module.h`

此宏定义了在模块移除时（或者在文件被编译到内核中时不被调用）要调用的函数。只有当模块的使用计数达到零时才会调用它。此函数也可以休眠，但不能失败：必须在其返回前清理所有内容。

注意，此宏是可选的：如果没有它，你的模块将不可移除（除非使用`rmmod -f`）。

`:c:func:`try_module_get()`/:c:func:`module_put()`
-------------------------------------------------

定义于`include/linux/module.h`

这些宏操作模块的使用计数，以防止移除（如果另一个模块使用了其导出符号，该模块也不能被移除：见下文）。在调用模块代码之前，你应该对该模块调用`:c:func:`try_module_get()`；如果失败，则表示该模块正在被移除，你应该当作它不存在。

否则，你可以安全地进入模块，并在完成后调用`:c:func:`module_put()`。

大多数可注册结构都有一个`owner`字段，例如在`:c:type:`struct file_operations <file_operations>`结构中。将该字段设置为宏`THIS_MODULE`。

### Wait Queues `include/linux/wait.h`
====================================

**[SLEEPS]**

等待队列用于等待某个条件变为真时被唤醒。它们必须谨慎使用以确保没有竞态条件。你需要声明一个`:c:type:`wait_queue_head_t`，然后想要等待该条件的进程声明一个指向自身的`:c:type:`wait_queue_entry_t`，并将其放入队列中。
声明
---------
你可以使用 :c:func:`DECLARE_WAIT_QUEUE_HEAD()` 宏或在初始化代码中使用 :c:func:`init_waitqueue_head()` 函数来声明一个 ``wait_queue_head_t``。

排队
-------
将自己加入等待队列是相当复杂的，因为你必须在检查条件之前先把自己加入队列。有一个宏可以做到这一点：:c:func:`wait_event_interruptible()`（`include/linux/wait.h`）。第一个参数是等待队列头，第二个参数是一个表达式，该表达式会被求值；当这个表达式为真时，宏返回 0，如果收到信号则返回 ``-ERESTARTSYS``。:c:func:`wait_event()` 版本会忽略信号。

唤醒排队的任务
----------------------
调用 :c:func:`wake_up()`（`include/linux/wait.h`），这将唤醒队列中的每一个进程。例外情况是如果其中一个设置了 ``TASK_EXCLUSIVE`` 标志，则其余的队列不会被唤醒。在同一头文件中还有其他变体函数可用。

原子操作
=================
某些操作在所有平台上都是保证原子性的。第一类操作是在 :c:type:`atomic_t` 上进行的（`include/asm/atomic.h`）；它包含一个有符号整数（至少 32 位长），你必须使用这些函数来操纵或读取 :c:type:`atomic_t` 变量。:c:func:`atomic_read()` 和 :c:func:`atomic_set()` 分别获取和设置计数器，:c:func:`atomic_add()`、:c:func:`atomic_sub()`、:c:func:`atomic_inc()`、:c:func:`atomic_dec()` 以及 :c:func:`atomic_dec_and_test()`（如果递减到零则返回真）。
是的，如果原子变量为零则返回真（即！= 0）。
请注意，这些函数比正常的算术运算慢，因此不应不必要的使用它们。

第二类原子操作是对 ``unsigned long`` 的原子位操作，定义在 `include/linux/bitops.h` 中。这些操作通常需要一个指向位模式的指针和一个位号：0 是最低有效位。:c:func:`set_bit()`、:c:func:`clear_bit()` 和 :c:func:`change_bit()` 分别设置、清除和翻转给定的位。:c:func:`test_and_set_bit()`、:c:func:`test_and_clear_bit()` 和 :c:func:`test_and_change_bit()` 做同样的事情，但会返回真如果位之前已被设置；这对于原子地设置标志特别有用。

可以使用大于 ``BITS_PER_LONG`` 的位索引来调用这些操作。但在大端平台上结果行为会很奇怪，所以最好不要这样做。

符号
=======
在内核内部，正常的链接规则适用（即除非使用 ``static`` 关键字声明为文件作用域，否则可以在内核中的任何地方使用符号）。但是，对于模块，维护了一个特殊的导出符号表，限制了进入内核的入口点。模块也可以导出符号。
### `EXPORT_SYMBOL()`
-------------------------
定义于 `include/linux/export.h`

这是导出符号的经典方法：动态加载的模块将能够像平常一样使用该符号。

### `EXPORT_SYMBOL_GPL()`
-----------------------------
定义于 `include/linux/export.h`

类似于 `EXPORT_SYMBOL()`，但通过 `EXPORT_SYMBOL_GPL()` 导出的符号只能被指定了与 GPL 兼容许可证的模块看到。这表明该函数被视为内部实现问题，而不是真正的接口。然而，某些维护者和开发者在添加任何新的 API 或功能时可能会要求使用 `EXPORT_SYMBOL_GPL()`。

### `EXPORT_SYMBOL_NS()`
----------------------------
定义于 `include/linux/export.h`

这是 `EXPORT_SYMBOL()` 的变体，允许指定符号命名空间。符号命名空间在 `Documentation/core-api/symbol-namespaces.rst` 中有详细文档。

### `EXPORT_SYMBOL_NS_GPL()`
--------------------------------
定义于 `include/linux/export.h`

这是 `EXPORT_SYMBOL_GPL()` 的变体，允许指定符号命名空间。符号命名空间在 `Documentation/core-api/symbol-namespaces.rst` 中有详细文档。

### 常规和约定
#### 双向链表 `include/linux/list.h`
--------------------------------------------

内核头文件中曾经有三套链表操作例程，但这一套是最终胜出者。如果你没有特别迫切需要单链表的需求，这是一个不错的选择。特别是 `list_for_each_entry()` 非常有用。

#### 返回约定
------------------
对于在用户上下文中调用的代码，常常违反 C 语言的惯例，成功时返回 0，失败时返回一个负的错误码（例如 `-EFAULT`）。这在一开始可能不太直观，但在内核中非常普遍。
使用 `ERR_PTR()`（位于 `include/linux/err.h`）将负错误码编码到指针中，并使用 `IS_ERR()` 和 `PTR_ERR()` 将其解码出来：这样可以避免单独的指针参数来传递错误号。虽然有点别扭，但却是好的方式。

#### 打破编译
------------------
林纳斯和其他开发者有时会在开发内核中更改函数或结构的名字；这不是为了让大家保持警觉，而是反映了根本性的变化（例如不能再带中断调用，或者增加了额外的检查，或者不再执行之前捕获的检查）。通常这种情况会伴随一个相当完整的说明发送到相应的内核开发邮件列表；可以搜索归档。简单地全局替换文件中的内容通常会使情况变得更糟。

#### 初始化结构成员
------------------------------
初始化结构的最佳方法是使用 ISO C99 定义的指定初始化器，例如：

```c
static struct block_device_operations opt_fops = {
        .open               = opt_open,
        .release            = opt_release,
        .ioctl              = opt_ioctl,
        .check_media_change = opt_media_change,
};
```

这样便于使用 `grep` 查找，并且清楚地表明了设置了哪些结构字段。你应该这样做，因为它看起来很酷。

#### GNU 扩展
--------------
GNU 扩展在 Linux 内核中是明确允许的。请注意，一些更复杂的扩展由于缺乏广泛使用而不怎么受支持，但以下扩展被认为是标准的（详见 GCC 文档页面中的“C Extensions”部分 - 是的，确实是文档页面，而不仅仅是简短总结）：
- 内联函数
- 表达式语句（即 `{` 和 `}` 构造）
### 声明函数/变量/类型的属性
(__attribute__)

-  typeof

-  零长度数组

-  宏变长参数

-  对空指针进行算术运算

-  非常量初始化器

-  汇编指令（不在arch/ 和 include/asm/ 外使用）

-  函数名作为字符串 (__func__)
-  __builtin_constant_p()

#### 注意事项
在内核中使用 `long long` 时要小心，GCC 生成的代码很糟糕，并且更糟糕的是，在 i386 上除法和乘法不起作用，因为内核环境中缺少 GCC 的运行时函数。

### C++
在内核中使用 C++ 通常是一个坏主意，因为内核没有提供必要的运行时环境，并且头文件也没有经过测试。尽管仍然可以使用，但不推荐这样做。如果你确实想这样做，请至少忽略异常。

### #if
通常认为在头文件（或 .c 文件顶部）中使用宏来抽象函数比在整个源代码中使用 `#if` 预处理语句更为清晰。

### 将你的代码放入内核
为了让代码能够正式包含到内核中，或者制作一个整洁的补丁，需要完成一些管理工作：

- 确定你修改的代码的所有者。查看源文件顶部、`MAINTAINERS` 文件以及最后的 `CREDITS` 文件。你应该与这些人协调，确保不会重复工作或尝试已经被拒绝的功能。
- 在创建或显著修改的任何文件顶部添加你的名字和电子邮件地址。这是人们发现错误或想要进行更改时首先会查看的地方。
- 通常你需要为内核中的黑客功能设置一个配置选项。编辑相应目录下的 `Kconfig` 文件。Config 语言通过剪切和粘贴很容易使用，并且在 `Documentation/kbuild/kconfig-language.rst` 中有完整的文档。
- 在选项描述中，确保同时考虑到专家用户和对你的功能一无所知的用户。
- 提及不兼容性和问题。**一定要**在描述末尾加上“如果不确定，请选择 N”（偶尔可以选择 Y），这是为了那些不知道你在说什么的人。
- 编辑 `Makefile`：CONFIG 变量在这里被导出，因此你通常只需添加一行 "obj-$(CONFIG_xxx) += xxx.o"。语法在 `Documentation/kbuild/makefiles.rst` 中有详细说明。
如果你认为你所做的工作值得一提，通常超出单个文件的范围，请将自己加入到“CREDITS”中（无论如何，你的名字应该出现在源文件的顶部）。“MAINTAINERS”意味着当你希望在子系统变更时被咨询，并被告知有关bug的信息；这表明你对代码的一部分有持续的关注。

最后，不要忘了阅读“Documentation/process/submitting-patches.rst”。

Kernel Cantrips
===============

以下是浏览内核源码时的一些最爱。欢迎添加到这个列表中：

``arch/x86/include/asm/delay.h``::

    #define ndelay(n) (__builtin_constant_p(n) ? \
            ((n) > 20000 ? __bad_ndelay() : __const_udelay((n) * 5ul)) : \
            __ndelay(n))


``include/linux/fs.h``::

    /*
     * 内核指针包含冗余信息，因此我们可以使用一种方案，在相同的返回值中返回错误代码或dentry指针
     *
     * 这应该是架构特定的事情，允许不同的错误和指针决策
     */
     #define ERR_PTR(err)    ((void *)((long)(err)))
     #define PTR_ERR(ptr)    ((long)(ptr))
     #define IS_ERR(ptr)     ((unsigned long)(ptr) > (unsigned long)(-1000))

``arch/x86/include/asm/uaccess_32.h``::

    #define copy_to_user(to,from,n)                         \
            (__builtin_constant_p(n) ?                      \
             __constant_copy_to_user((to),(from),(n)) :     \
             __generic_copy_to_user((to),(from),(n)))

``arch/sparc/kernel/head.S``::

    /*
     * Sun的人拼写糟糕透顶。“compatability”确实如此
     * 至少我们知道我们不会拼写，并且使用了拼写检查器
     */

    /* 呃，实际上Linus，是我不会拼写。太多的晦涩Sparc汇编会导致这种情况 */
    C_LABEL(cputypvar):
            .asciz "compatibility"

    /* 在SS-5、SS-10上测试过。可能Sun的某个人应用了拼写检查器。 */
            .align 4
    C_LABEL(cputypvar_sun4m):
            .asciz "compatible"


``arch/sparc/lib/checksum.S``::

            /* Sun，你就是打不过我，放弃吧
             * 我是认真的，我会把你打得落花流水，游戏结束，灯灭人散 */

感谢
======

感谢Andi Kleen提供了这个想法，回答了我的问题，纠正了我的错误，填充了内容等。Philipp Rumpf进行了更多的拼写和清晰度修正，并提出了一些优秀的非显而易见的观点。Werner Almesberger为我提供了一个关于:c:func:`disable_irq()` 的精彩总结，Jes Sorensen 和 Andrea Arcangeli 添加了注意事项。Michael Elizabeth Chastain 检查并补充了Configure部分的内容。Telsa Gwynne 教会了我DocBook。
