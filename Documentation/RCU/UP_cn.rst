.. _up_doc:

RCU在单处理器系统上的应用
===========================

一个常见的误解是，在单处理器（UP）系统上，`call_rcu()` 原语可以立即调用其函数。这种误解的基础在于，由于只有一个CPU，因此似乎没有必要等待其他任务完成，因为没有其他CPU可以执行其他任务。尽管这种方法在某些情况下“似乎”能工作，但总体来说这是一个非常糟糕的做法。本文档通过三个示例来具体说明这种做法的严重性。

示例1：软中断自杀
--------------------------

假设一个基于RCU的算法在进程上下文中扫描包含元素A、B和C的链表，并且可以在软中断上下文中从同一链表中删除元素。假设进程上下文中的扫描在被软中断处理中断时正在引用元素B，该中断删除了元素B，并随后调用 `call_rcu()` 在经过一个宽限期后释放元素B。

如果 `call_rcu()` 直接调用其参数，则在从软中断返回时，链表扫描将发现自己正在引用一个刚刚被释放的元素B。这种情况可能会大大缩短内核的寿命。

同样的问题也可能发生在硬件中断处理程序中调用 `call_rcu()` 的情况下。

示例2：函数调用致命错误
-----------------------------

当然，可以通过仅当 `call_rcu()` 被从进程上下文调用时直接调用其参数来避免上述示例中的自杀情况。然而，这同样可能导致类似的问题。

假设一个基于RCU的算法再次在进程上下文中扫描包含元素A、B和C的链表，并且在扫描每个元素时调用一个函数。进一步假设这个函数从链表中删除元素B，然后将其传递给 `call_rcu()` 进行延迟释放。这可能有点不常见，但这是完全合法的RCU使用方式，因为 `call_rcu()` 必须等待一个宽限期才能调用其参数。

因此，在这种情况下，允许 `call_rcu()` 立即调用其参数会导致其无法保证RCU的基本保证，即 `call_rcu()` 将延迟调用其参数，直到所有当前正在执行的RCU读侧临界区完成。

快速问答#1：
	为什么在这种情况下调用 `synchronize_rcu()` 是非法的？

:ref:`快速问答答案 <answer_quick_quiz_up>`

示例3：死锁导致的死亡
-----------------------------

假设在持有某个锁的情况下调用了 `call_rcu()`，并且回调函数必须获取相同的锁。在这种情况下，即使从一个完整的宽限期后的另一个 `call_rcu()` 调用中直接调用回调函数，结果也会导致自死锁。

在某些情况下，可以通过重构代码使 `call_rcu()` 的调用延迟到锁释放之后。然而，有些情况下这样做会很复杂：

1. 如果需要在同一临界区内向 `call_rcu()` 传递多个项，则代码需要创建一个项列表，然后在锁释放后遍历该列表。
### 在某些情况下，锁会跨越一些内核API持有，因此将`call_rcu()`的调用延迟到锁释放时，需要通过一个通用API将数据项传递上去

最好保证回调函数在没有任何锁被持有的情况下被调用，而不是修改这些API以允许任意的数据项通过它们被传递回去。如果`call_rcu()`直接调用回调函数，则需要进行繁琐的锁定限制或API更改。

快速问答2：
RCU回调函数必须遵守什么锁定限制？

:ref:`快速问答答案 <answer_quick_quiz_up>`

需要注意的是，用户空间中的RCU实现确实允许`call_rcu()`直接调用回调函数，但前提是自这些回调被排队以来已经过了一整个恩典期。这是因为在某些用户空间环境中资源非常有限。尽管如此，强烈建议编写用户空间RCU实现的人避免从`call_rcu()`中调用回调函数，从而获得上述提到的避免死锁的好处。

### 总结

允许`call_rcu()`立即调用其参数会破坏RCU机制，即使是在单处理器系统（UP）上也是如此。因此不要这样做！即使在单处理器系统上，RCU基础设施也**必须**尊重恩典期，并且**必须**在没有锁被持有的已知环境中调用回调函数。
请注意，在单处理器系统上，包括在单处理器系统上运行的抢占式SMP构建中，`synchronize_rcu()`立即返回是安全的。

快速问答3：
为什么在运行抢占式RCU的单处理器系统上`同步RCU()`不能立即返回？

.. _answer_quick_quiz_up:

### 快速问答1的答案：
为什么在这种情况下调用`synchronize_rcu()`是不合法的？

因为调用函数正在扫描一个由RCU保护的链表，因此它处于RCU读端临界区中。因此，被调用的函数在RCU读端临界区内被调用，不允许阻塞。

### 快速问答2的答案：
RCU回调函数必须遵守什么锁定限制？

在RCU回调函数中获取的任何锁必须使用自旋锁原语的_bh变体在其他地方获取。
例如，如果“mylock”被一个RCU回调函数获取，则在进程上下文中获取该锁必须使用类似于spin_lock_bh()的方法。请注意，也可以使用spinlock的_irq变体，例如spin_lock_irqsave()。

如果进程上下文代码简单地使用spin_lock()，那么由于RCU回调可以从软中断上下文调用，回调可能会从中断了进程上下文临界区的软中断中被调用。这将导致自死锁。

这一限制可能看起来有些多余，因为很少有RCU回调直接获取锁。然而，许多RCU回调是通过间接方式获取锁的，例如，通过kfree()原语。

快速测验#3的答案：
为什么在可抢占RCU运行的UP系统上，synchronize_rcu()不能立即返回？

因为在RCU读端临界区中间，其他任务可能已经被抢占。如果synchronize_rcu()立即返回，它会过早地发出结束宽限期的信号，这对那个重新开始运行的其他线程来说将是一个不愉快的意外。
