树形RCU快速优雅周期之旅
================================

简介
============

本文档描述了RCU的快速优雅周期。
与接受长延迟以实现高效率和最小干扰的RCU正常优雅周期不同，快速优雅周期接受较低的效率和显著的干扰以实现更短的延迟。
RCU有两种类别（RCU-preempt和RCU-sched），早期的第三种类别RCU-bh则是基于其他两个类别实现的。
每个实现都在各自的章节中进行了介绍。
快速优雅周期设计
=============================

快速RCU优雅周期的设计不能被称为微妙，因为它实际上是对所有尚未为当前快速优雅周期提供静默状态的CPU进行“敲打”。
值得庆幸的是，“敲打”的力度随着时间有所减小：旧的调用`try_stop_cpus()`已经被一系列对`smp_call_function_single()`的调用所取代，每次调用都会向目标CPU发送一个IPI（中断请求）。
相应的处理函数会检查CPU的状态，并尽可能地激励更快进入静默状态，并触发该静默状态的报告。
对于RCU来说，一旦所有CPU都花费了一段时间在静默状态下，快速优雅周期即宣告完成。
`smp_call_function_single()`处理函数的具体操作细节取决于RCU的类别，如下节所述。
RCU-preempt 快速优雅周期
===================================

启用`CONFIG_PREEMPTION=y`的内核实现了RCU-preempt。
处理给定CPU的RCU抢占快速优雅周期的整体流程如下图所示：

.. kernel-figure:: ExpRCUFlow.svg

实线箭头表示直接操作，例如函数调用。
虚线箭头表示间接操作，例如IPI或经过一段时间后达到的状态。
如果给定的CPU处于离线或空闲状态，`synchronize_rcu_expedited()` 将忽略它，因为空闲和离线的CPU已经处于静默状态。
否则，快速优雅周期将使用 `smp_call_function_single()` 向CPU发送一个IPI，该IPI由 `rcu_exp_handler()` 处理。
然而，由于这是可抢占的RCU，`rcu_exp_handler()` 可以检查当前CPU是否正在运行在RCU读端临界区内。
如果不是，则处理程序可以立即报告静默状态。
如果是，则设置标志，以便最外层的 `rcu_read_unlock()` 调用能够提供所需的静默状态报告。
这种标志设置避免了之前所有可能处于RCU读端临界区的CPU被强制抢占的情况。
此外，这种标志设置是为了避免增加通过调度器常见情况快路径的开销。
再次，由于这是可抢占的RCU，RCU读端临界区可能会被抢占。
当这种情况发生时，RCU 将会将任务入队，该任务将继续阻塞当前的快速优雅周期，直到它恢复并找到最外层的 `rcu_read_unlock()`。CPU 在将任务入队后会报告一个静默状态，因为此时 CPU 不再阻塞优雅周期。而是被抢占的任务在进行阻塞。被阻塞任务的列表由 `rcu_preempt_ctxt_queue()` 管理，该函数由 `rcu_preempt_note_context_switch()` 调用，后者又由 `rcu_note_context_switch()` 调用，最终由调度器调用。

+-----------------------------------------------------------------------+
| **快速问答**：                                                      |
+-----------------------------------------------------------------------+
| 为什么不直接让快速优雅周期检查所有 CPU 的状态？毕竟这样可以避免     |
| 那些实时不友好的 IPI（中断请求）。                                   |
+-----------------------------------------------------------------------+
| **答案**：                                                           |
+-----------------------------------------------------------------------+
| 因为我们希望 RCU 读端临界区能够快速运行，这意味着不能有内存屏障。   |
| 因此无法安全地从其他 CPU 检查状态。即使能安全检查状态，仍然需要     |
| 通过 IPI 安全地与即将发生的 `rcu_read_unlock()` 调用交互，这意味着   |
| 远程状态检测不会改善实时应用程序关心的最坏情况延迟。                 |
|                                                                       |
| 要防止您的实时应用程序受到这些 IPI 的影响，可以在编译内核时设置       |
| `CONFIG_NO_HZ_FULL=y`。RCU 将认为运行您应用程序的 CPU 处于空闲状态， |
| 并且能够安全地检测到该状态而无需 IPI。                                |
+-----------------------------------------------------------------------+

请注意，这只是总体流程：由于 CPU 变为空闲或离线等原因，可能会出现其他复杂情况。
RCU-sched 快速优雅周期
-----------------------------

`CONFIG_PREEMPTION=n` 内核实现了 RCU-sched。RCU-sched 快速优雅周期处理给定 CPU 的整体流程如下图所示：

.. kernel-figure:: ExpSchedFlow.svg

与 RCU-preempt 类似，RCU-sched 的 `synchronize_rcu_expedited()` 函数忽略了离线和空闲的 CPU，因为它们处于可远程检测的静默状态。但是，由于 `rcu_read_lock_sched()` 和 `rcu_read_unlock_sched()` 没有留下任何调用痕迹，通常无法判断当前 CPU 是否处于 RCU 读端临界区内。RCU-sched 的 `rcu_exp_handler()` 所能做到的最佳情况是检查 CPU 是否为空闲，以防 IPI 在传输过程中 CPU 变为空闲。如果 CPU 是空闲的，则 `rcu_exp_handler()` 报告静默状态；否则，该处理器通过设置当前任务的线程标志中的 NEED_RESCHED 标志和 CPU 抢占计数器来强制未来的上下文切换。在上下文切换时，CPU 报告静默状态。如果 CPU 先离线，则会在离线时报告静默状态。
快速优雅周期与 CPU 热插拔
--------------------------------------

快速优雅周期的快速性质要求与 CPU 热插拔操作之间有更紧密的交互，而不是像普通优雅周期那样。此外，尝试向离线 CPU 发送 IPI 会导致崩溃，但未能向在线 CPU 发送 IPI 可能导致优雅周期过短。这两种情况在生产内核中都是不可接受的。

快速优雅周期与 CPU 热插拔操作之间的交互发生在多个层面：

1. 曾经在线的 CPU 数量由 `rcu_state` 结构体的 `->ncpus` 字段跟踪。`rcu_state` 结构体的 `->ncpus_snap` 字段跟踪 RCU 快速优雅周期开始时曾经在线的 CPU 数量。注意这个数字至少在没有时间机器的情况下永远不会减少。
2. 曾经在线的 CPU 身份由 `rcu_node` 结构体的 `->expmaskinitnext` 字段跟踪。`rcu_node` 结构体的 `->expmaskinit` 字段跟踪最近一次 RCU 快速优雅周期开始时至少在线一次的 CPU 身份。`rcu_state` 结构体的 `->ncpus` 和 `->ncpus_snap` 字段用于检测是否有新的 CPU 第一次上线，即 `rcu_node` 结构体的 `->expmaskinitnext` 字段自上次 RCU 快速优雅周期开始以来是否发生了变化，这将触发每个 `rcu_node` 结构体的 `->expmaskinit` 字段从其 `->expmaskinitnext` 字段更新。
### 加速恩赐期的改进

#### 空闲CPU检查

每个加速恩赐期在最初形成需要发送IPI的CPU掩码时以及在发送IPI之前都会检查空闲CPU（这两个检查都由`sync_rcu_exp_select_cpus()`执行）。如果在这两个时间点之间任一时刻CPU是空闲的，则该CPU不会被IPI。相反，推动恩赐期前进的任务会在传递给`rcu_report_exp_cpu_mult()`的掩码中包含这些空闲CPU。

对于RCU-sched，还有一个额外的检查：如果IPI中断了空闲循环，则`rcu_exp_handler()`会调用`rcu_report_exp_rdp()`来报告相应的静止状态。

对于RCU-preempt，在IPI处理器（`rcu_exp_handler()`）中没有特定的空闲检查，但由于不允许在空闲循环内存在RCU读侧临界区，如果`rcu_exp_handler()`发现CPU处于RCU读侧临界区内，则该CPU不可能是空闲的。否则，`rcu_exp_handler()`会调用`rcu_report_exp_rdp()`来报告相应的静止状态，无论该静止状态是否是因为CPU空闲。

总结来说，RCU加速恩赐期在构建必须被IPI的CPU掩码时、在发送每个IPI之前以及（显式或隐式地）在IPI处理器内部都会检查空闲CPU。

#### 通过序列计数器进行批处理

如果每个恩赐期请求都是单独执行的，那么加速恩赐期将具有极差的可扩展性和高负载特性。由于每次恩赐期操作可以服务无限数量的更新，因此重要的是要*批量*处理请求，使得单个加速恩赐期操作可以覆盖对应批次中的所有请求。
这种批处理由 `rcu_state` 结构中的一个序列计数器 `->expedited_sequence` 控制。当有一个快速优雅期正在进行时，该计数器的值为奇数；否则为偶数，因此将计数器的值除以二即可得到已完成的优雅期数量。在任何给定的更新请求期间，计数器必须从偶数变为奇数，然后再变回偶数，从而表明一个优雅期已经过去。因此，如果计数器的初始值为 `s`，更新者必须等待直到计数器达到至少 `(s+3)&~0x1` 的值。这个计数器由以下访问函数管理：

1. `rcu_exp_gp_seq_start()`，标记快速优雅期的开始。
2. `rcu_exp_gp_seq_end()`，标记快速优雅期的结束。
3. `rcu_exp_gp_seq_snap()`，获取计数器的快照。
4. `rcu_exp_gp_seq_done()`，如果自上次调用 `rcu_exp_gp_seq_snap()` 以来一个完整的快速优雅期已过去，则返回 `true`。

同样，在一个批次中只需要一个请求实际执行优雅期操作，这意味着必须有一种有效的方法来识别哪些并发请求将发起优雅期，并且其余请求需要有有效的方式等待该优雅期完成。然而，这是下一节的主题：漏斗锁和等待/唤醒。

确定一批更新者中哪个将发起快速优雅期的自然方法是使用 `rcu_node` 组合树，这通过 `exp_funnel_lock()` 函数实现。第一个到达某个 `rcu_node` 结构对应于特定优雅期的更新者会将其所需的优雅期序列号记录在 `->exp_seq_rq` 字段中，并移动到树的下一层。否则，如果 `->exp_seq_rq` 字段已经包含所需优雅期或其之后的序列号，更新者会在 `->exp_wq[]` 数组中的四个等待队列之一上阻塞，使用倒数第二位和倒数第三位作为索引。`rcu_node` 结构中的 `->exp_lock` 字段同步对这些字段的访问。

下图展示了空的 `rcu_node` 树，其中白色单元格代表 `->exp_seq_rq` 字段，红色单元格代表 `->exp_wq[]` 数组的元素。
.. kernel-figure:: Funnel0.svg

下一个图展示了 Task A 和 Task B 分别到达最左边和最右边的叶 `rcu_node` 结构后的情况。当前 `rcu_state` 结构的 `->expedited_sequence` 字段的值为零，因此加上三并清除最低位后的结果为二，两个任务都将此值记录在各自的 `rcu_node` 结构的 `->exp_seq_rq` 字段中：
.. kernel-figure:: Funnel1.svg

每个任务都会移动到根 `rcu_node` 结构。假设 Task A 赢了，记录了它所需的优雅期序列号，结果如下图所示：
.. kernel-figure:: Funnel2.svg

现在 Task A 前进以启动一个新的优雅期，而 Task B 移动到根 `rcu_node` 结构，并看到其所需的序列号已经被记录下来，于是阻塞在 `->exp_wq[1]` 上。
+-----------------------------------------------------------------------+
| **快速测验**：                                                     |
+-----------------------------------------------------------------------+
| 为什么使用 ``->exp_wq[1]``？鉴于这些任务期望的序列号是二，它们   |
| 不应该阻塞在 ``->exp_wq[2]`` 上吗？                                  |
+-----------------------------------------------------------------------+
| **答案**：                                                            |
+-----------------------------------------------------------------------+
| 不是。                                                                |
| 回忆一下，期望的序列号的最低位表示是否正在进行宽限期。因此，需   |
| 要将序列号向右移一位以获取宽限期编号。这导致了 ``->exp_wq[1]`` 的 |
| 使用。                                                               |
+-----------------------------------------------------------------------+

如果任务 C 和 D 也到达这一点，它们将计算出相同的期望宽限期序列号，并发现两个叶子 ``rcu_node`` 结构已经记录了该值。因此，它们将分别在各自的 ``rcu_node`` 结构的 ``->exp_wq[1]`` 字段上阻塞，如下图所示：

.. kernel-figure:: Funnel3.svg

任务 A 现在获取 ``rcu_state`` 结构的 ``->exp_mutex`` 并启动宽限期，这将使 ``->expedited_sequence`` 增加。因此，如果任务 E 和 F 到达，它们将计算出期望的序列号为 4，并记录该值，如下图所示：

.. kernel-figure:: Funnel4.svg

任务 E 和 F 将沿着 ``rcu_node`` 合并树传播，其中任务 F 在根 ``rcu_node`` 结构上阻塞，而任务 E 等待任务 A 完成以便开始下一个宽限期。结果状态如下图所示：

.. kernel-figure:: Funnel5.svg

一旦宽限期完成，任务 A 开始唤醒等待该宽限期完成的任务，增加 ``->expedited_sequence``，获取 ``->exp_wake_mutex`` 并释放 ``->exp_mutex``。这导致以下状态：

.. kernel-figure:: Funnel6.svg

然后任务 E 可以获取 ``->exp_mutex`` 并将 ``->expedited_sequence`` 增加到值三。如果新任务 G 和 H 到达并同时沿合并树移动，状态将如下图所示：

.. kernel-figure:: Funnel7.svg

注意，根 ``rcu_node`` 结构的三个等待队列现在已被占用。然而，在某个时刻，任务 A 将唤醒在 ``->exp_wq`` 等待队列上阻塞的任务，导致如下状态：

.. kernel-figure:: Funnel8.svg

执行将继续进行，任务 E 和 H 完成它们的宽限期并执行唤醒操作
+-----------------------------------------------------------------------+
| **快速测验**：                                                     |
+-----------------------------------------------------------------------+
| 如果任务 A 在执行唤醒操作时花费的时间过长，以至于任务 E 的宽限期  |
| 完成了会发生什么？                                                    |
+-----------------------------------------------------------------------+
| **答案**：                                                            |
+-----------------------------------------------------------------------+
| 那么任务 E 将阻塞在 ``->exp_wake_mutex`` 上，这也阻止它释放        |
| ``->exp_mutex``，进而阻止下一个宽限期的开始。这是防止                |
| ``->exp_wq[]`` 数组溢出的重要因素。                                   |
+-----------------------------------------------------------------------+

工作队列的使用
~~~~~~~~~~~~~~~

在早期实现中，请求加速宽限期的任务也负责将其驱动到完成。这种简单的方法有一个缺点，即需要处理发送给用户任务的 POSIX 信号，因此最近的实现使用 Linux 内核的工作队列（参见 Documentation/core-api/workqueue.rst）
请求任务仍然执行计数器快照和漏斗锁处理，但到达漏斗锁顶部的任务会调用 ``schedule_work()``（从 ``_synchronize_rcu_expedited()`` 中调用），这样工作队列线程可以执行实际的宽限期处理。由于工作队列线程不接受 POSIX 信号，因此不需要考虑宽限期等待处理中的 POSIX 信号。此外，这种方法允许前一个加速宽限期的唤醒与下一个加速宽限期的处理重叠。由于只有四组等待队列，因此必须确保前一个宽限期的唤醒在下一个宽限期的唤醒开始之前完成。这通过让 ``->exp_mutex`` 保护加速宽限期处理而 ``->exp_wake_mutex`` 保护唤醒来实现。关键点是 ``->exp_mutex`` 直到第一次唤醒完成才被释放，这意味着此时 ``->exp_wake_mutex`` 已经被获取。这种方法确保了可以在当前宽限期进行的同时执行前一个宽限期的唤醒，但这些唤醒将在下一个宽限期开始之前完成。这意味着只需要三个等待队列，从而保证提供的四个等待队列是足够的。
停滞警告
~~~~~~~~~~~~~~~

加速宽限期并不能加快当 RCU 读取者花费时间过长的情况，因此加速宽限期也会检查停滞情况，就像正常的宽限期一样
+-----------------------------------------------------------------------+
| **快速测验**：                                                     |
+-----------------------------------------------------------------------+
| 但是为什么不直接让正常的宽限期机制检测停滞，因为任何读取者都必   |
| 须阻塞正常和加速宽限期？                                             |
+-----------------------------------------------------------------------+
| **答案**：                                                            |
+-----------------------------------------------------------------------+
| 因为有可能在某一时刻没有正常的宽限期在进行，因此正常的宽限期不   |
| 能发出停滞警告。                                                      |
+-----------------------------------------------------------------------+

函数 ``synchronize_sched_expedited_wait()`` 循环等待加速宽限期结束，但设置了一个当前 RCU CPU 停滞警告时间的超时。如果这个时间被超过，任何阻塞当前宽限期的 CPU 或 ``rcu_node`` 结构将被打印出来
每次停滞警告都会导致循环再次运行，但第二次及后续的循环使用更长的停滞时间
启动中期操作
~~~~~~~~~~~~~~~

使用工作队列的一个优点是加速宽限期代码不必担心 POSIX 信号。不幸的是，相应的缺点是在工作队列初始化之前不能使用它们，而这发生在调度程序生成第一个任务之后的一段时间。鉴于内核的一部分确实希望在启动中期“死区”期间执行宽限期，加速宽限期在此期间必须采取其他措施
它们所做的就是退回到旧的做法，要求请求任务驱动加速宽限期，就像使用工作队列之前的那样。然而，请求任务仅在启动中期死区内驱动宽限期。在启动中期之前，同步宽限期是一个空操作。在启动中期之后的一段时间内，使用工作队列
非加速非 SRCU 同步宽限期也必须在启动中期正常运行。这是通过让非加速宽限期在启动中期采用加速代码路径来处理的。
当前代码假设在启动中期的死区阶段不会有POSIX信号。然而，如果对POSIX信号的需求突然变得非常迫切，可以对快速延时警告代码进行适当的调整。其中一种调整是在启动中期的死区阶段重新启用预先的延时警告检查。
通过这种改进，可以在内核生命周期中的几乎任何时候从任务上下文中使用同步的宽限期。也就是说，除了在挂起、休眠或关机代码路径中的一些特定点之外。

总结
~~~~~~~

快速宽限期采用序列号的方法来促进批处理，使得单个宽限期操作能够服务多个请求。使用一个漏斗锁（funnel lock）来高效地识别出并发组中的某个任务，该任务将请求宽限期。组的所有成员将在 `rcu_node` 结构中提供的等待队列上阻塞。实际的宽限期处理由一个工作队列完成。
为了防止快速宽限期和CPU热插拔操作之间需要紧密同步，CPU热插拔操作被懒惰地记录。动态滴答空闲计数器用于避免向空闲CPU发送IPI，至少在常见情况下是这样。RCU抢占和RCU调度使用不同的IPI处理器和不同的代码来响应这些处理器执行的状态变化，但除此之外它们使用相同的代码。
使用 `rcu_node` 树来跟踪静默状态，并且一旦所有必要的静默状态都被报告，等待这个快速宽限期的所有任务将被唤醒。一对互斥锁用于允许一个宽限期的唤醒与下一个宽限期的处理同时进行。
这种机制组合使快速宽限期能够较为高效地运行。然而，对于非时间敏感的任务，应使用正常的宽限期，因为其较长的持续时间允许更高的批处理程度，从而大大降低每个请求的开销。
