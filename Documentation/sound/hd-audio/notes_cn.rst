关于HD-Audio驱动的更多说明
=============================

Takashi Iwai <tiwai@suse.de>

概述
=======

HD-Audio是现代PC上继AC97之后的新一代板载音频组件标准。尽管Linux早已支持HD-Audio，但新机器上仍常出现一些问题。部分问题是由于BIOS存在问题，其余则是驱动实现的问题。本文档解释了HD-Audio硬件的基本故障排查和调试方法。

HD-Audio组件由两部分组成：控制器芯片和HD-Audio总线上的编解码器芯片。Linux为所有控制器提供了一个单一驱动程序：snd-hda-intel。尽管驱动程序名称中包含一个知名硬件供应商的名字，但它不仅限于该供应商，而是适用于其他公司的所有控制器芯片。由于HD-Audio控制器应该是兼容的，因此单个snd-hda-driver在大多数情况下应该能正常工作。然而，不出所料的是，每种控制器类型都存在已知的错误和问题。snd-hda-intel驱动程序包含了许多针对这些问题的解决方案，如下所述。

一个控制器可能有多个编解码器。通常你有一个音频编解码器，并且可选地有一个调制解调器编解码器。理论上，可能存在多个音频编解码器，例如用于模拟输出和数字输出，驱动程序可能因为混合器元素冲突而无法正常工作。如果这种硬件确实存在，未来应该会修复这个问题。

snd-hda-intel驱动程序有几种不同的编解码器解析器，具体取决于编解码器。它有一个通用解析器作为回退选项，但目前这个功能相对有限。通常使用特定于编解码器的解析器（在patch_*.c文件中编码）来处理特定于编解码器的实现。关于特定编解码器问题的详细信息将在后续章节中解释。

如果你对深入调试HD-Audio感兴趣，请首先阅读HD-Audio规范。可以在Intel的网页上找到该规范，例如：

* https://www.intel.com/standards/hdaudio/

HD-Audio控制器
==================

DMA位置问题
---------------------
控制器最常见的问题是不准确的DMA指针报告。可以通过两种方式读取播放和捕获的DMA指针，一种是通过LPIB寄存器，另一种是通过位置缓冲区映射。默认情况下，驱动程序尝试从IO映射的位置缓冲区读取，并在位置缓冲区似乎无效时回退到LPIB。然而，在某些设备上这种检测并不完美。在这种情况下，你可以通过`position_fix`选项更改默认方法。

`position_fix=1`表示显式使用LPIB方法。
`position_fix=2`表示使用位置缓冲区。
`position_fix=3`表示使用两种方法的组合，某些VIA控制器需要这种方法。通过比较LPIB和位置缓冲区的值来校正捕获流的位置。
``position_fix=4`` 是所有控制器可用的另一种组合，使用 LPIB 进行回放，并使用位置缓冲区进行捕获流。

``position_fix=5`` 仅适用于 Intel 平台，目前针对 Skylake 及以后的平台。它应用了延迟计算以实现精确的位置报告。

``position_fix=6`` 是用于修正固定 FIFO 大小的位置问题，主要针对最近的 AMD 控制器。

0 是所有其他控制器的默认值，自动检查并回退到 LPIB，如上所述。如果你遇到重复声音的问题，这个选项可能会有所帮助。

除此之外，每个控制器在唤醒定时方面都存在问题。它会在实际处理缓冲区中的数据之前提前唤醒几个采样。这导致了许多问题，例如与 ALSA dmix 或 JACK 的问题。自 2.6.27 内核以来，驱动程序在唤醒定时中添加了一个人工延迟。此延迟通过 `bdl_pos_adj` 选项进行控制。

当 `bdl_pos_adj` 为负值（默认情况下）时，它会被分配一个根据控制器芯片适当调整的值。对于 Intel 芯片，该值为 1，而对于其他芯片则为 32。通常情况下这能正常工作。只有在不起作用并且你收到警告信息的情况下，你需要将此参数更改为其他值。

Codec 探测问题
---------------------
较少见但更为严重的问题是 Codec 探测问题。当 BIOS 错误地报告可用的 Codec 插槽时，驱动程序会变得混乱，并尝试访问不存在的 Codec 插槽。这通常会导致完全混乱，并破坏进一步与 Codec 芯片的通信。症状通常表现为以下错误信息：
::

    hda_intel: azx_get_response timeout, switching to polling mode:
          last cmd=0x12345678
    hda_intel: azx_get_response timeout, switching to single_cmd mode:
          last cmd=0x12345678

第一行是一个警告，通常是相对无害的。这意味着 Codec 响应没有通过 IRQ 通知。驱动程序使用显式的轮询方法来读取响应。这会产生非常轻微的 CPU 开销，但你不太可能注意到。

第二行则是致命错误。如果发生这种情况，通常意味着确实出了问题。最有可能的情况是你正在访问一个不存在的 Codec 插槽。
因此，如果出现第二个错误消息，请尝试通过 `probe_mask` 选项来缩小探测的编解码器插槽范围。这是一个位掩码，每个比特位对应一个编解码器插槽。例如，要仅探测第一个插槽，请传递 `probe_mask=1`。要探测第一个和第三个插槽，请传递 `probe_mask=5`（其中 5 = 1 | 4），依此类推。自2.6.29内核以来，驱动程序有了更稳健的探测方法，因此这种错误可能很少发生。

在具有故障BIOS的机器上，有时需要强制驱动程序探测硬件未报告使用的编解码器插槽。在这种情况下，请打开 `probe_mask` 选项的第8位（0x100）。然后剩下的8个比特位将无条件地作为要探测的编解码器插槽传递。例如，`probe_mask=0x103` 将会强制探测编解码器插槽0和1，无论硬件报告什么。

中断处理
---------
HD-audio驱动程序自2.6.33内核以来默认使用MSI（如果可用），因为MSI在某些机器上表现更好，总体来说对性能更有利。然而，Nvidia控制器在使用MSI时出现了严重的退化问题（特别是在与AMD芯片组结合使用时），因此我们禁用了它们的MSI功能。

似乎还有其他设备不支持MSI。如果你在最近的内核中遇到音质退化（如卡顿等）或锁定的问题，请尝试传递 `enable_msi=0` 选项来禁用MSI。如果这样有效，你可以将已知的不良设备添加到hda_intel.c中定义的黑名单里。在这种情况下，请报告并把补丁反馈给上游开发者。

HD-Audio 编解码器
==================

模型选项
----------
关于HD-audio驱动程序最常见的问题是不支持的编解码器特性或设备配置不匹配。大多数编解码器特定代码都有几个预设模型，要么覆盖BIOS设置，要么提供更全面的功能。驱动程序会检查PCI SSID，并遍历静态配置表，直到找到任何匹配项。如果你有一台新机器，可能会看到如下信息：
::

    hda_codec: ALC880: BIOS auto-probing
与此同时，在早期版本中，你会看到类似如下的信息：

    hda_codec: 对于ALC880，未知的模型，尝试从BIOS进行自动探测...

即使你看到这样的消息，也不要惊慌。深呼吸，保持冷静。首先，这是一个信息性消息，并不是警告或错误。这意味着你的设备的PCI SSID没有列在已知的预设模型（白名单）中。但这并不意味着驱动程序有问题。许多编解码器驱动程序都提供了基于BIOS设置的自动配置机制。

高清音频编解码器通常有“引脚”小部件，而BIOS会设置每个引脚的默认配置，这些配置指出了位置、连接类型、插孔颜色等信息。高清音频驱动程序可以根据这些默认配置值来判断正确的连接方式。

然而——有些编解码器支持代码（例如patch_analog.c）还不支持自动探测（截至2.6.28版本）。并且，BIOS经常会出现问题，它可能会设置错误的值，从而导致驱动程序出错。

预设模型（最近被称为“修复”）基本上是为了应对这种情况而提供的。当找到匹配的预设模型时，驱动程序会假设该预设模型的静态配置及其正确的引脚设置等。

因此，如果你有一台较新的机器，其PCI SSID（或编解码器SSID）与现有的略有不同，你有可能有机会复用相同的模型。你可以通过传递`model`选项来指定预设模型，而不是通过PCI（和编解码器）SSID查找。

可用的`model`选项值取决于编解码器芯片。检查codec proc文件（参见下面的“Codec Proc-File”部分），它会显示你的编解码器芯片的供应商/产品名称。然后，查看Documentation/sound/hd-audio/models.rst文件中的高清音频驱动程序部分。你可以找到属于每个编解码器的编解码器列表和`model`选项。例如，对于Realtek ALC262编解码器芯片，可以为兼容Samsung Q1 Ultra的设备传递`model=ultra`。

因此，对于任何全新的、不受支持且无法正常工作的高清音频硬件，你可以做的第一件事就是检查高清音频编解码器以及几种不同的`model`选项值。如果运气好的话，其中一些可能非常适合你的设备。

有几个特殊的`model`选项值：

* 当传递`nofixup`时，会跳过编解码器解析器中的特定设备修复。
当传递“generic”时，会跳过编解码器特定的解析器，仅使用通用解析器。

自5.15内核引入的一种新的模型选项风格是通过`model=XXXX:YYYY`的形式传递PCI或编解码器SSID，其中XXXX和YYYY分别是十六进制形式的子供应商和子设备ID。这是一种对其他设备的别名；当给出这种形式时，驱动程序将引用该SSID作为特性表的参考。尤其在目标特性未列在模型表中时，这会很有用。例如，传递`model=103c:8862`将应用HP ProBook 445 G8的特性（截至撰写时，该特性并未出现在模型表中），前提是该设备由同一驱动程序同等处理。

扬声器和耳机输出
-----------------
HD音频中最常见的（也是最明显的）问题是内置扬声器或耳机插孔无声输出。通常，你应该先尝试耳机输出。扬声器输出通常需要更多的附加控制，如外部放大器位。因此，耳机输出有稍高的成功几率。

在提交错误报告之前，请务必检查混音器是否设置正确。最近版本的snd-hda-intel驱动程序主要提供了“主”音量控制以及“前置”音量控制（前置表示前置声道）。此外，还可能有个别的“耳机”和“扬声器”控制。

对于扬声器输出也是如此。某些编解码器上可能有“外部放大器”的开关。如果存在，请打开它。

另一个相关的问题是插入耳机后自动静音扬声器输出。此功能在大多数情况下已实现，但并非所有预设模型或编解码器支持代码都有此功能。

无论如何，如果你遇到此类问题，请尝试不同的模型选项。其他一些模型可能更匹配，并提供更多功能。如果现有的模型都不起作用，请提交错误报告。详情请参阅错误报告部分。

如果你有足够的毅力来调试驱动程序问题，请注意以下几点：

* 扬声器（以及耳机）输出通常需要外部放大器。这通常可以通过EAPD动词或某个GPIO来设置。如果编解码器引脚支持EAPD，则通过SET_EAPD_BTL动词（0x70c）有更高的成功率。在其他情况下，GPIO引脚（通常是GPIO0或GPIO1）可能会开启/关闭EAPD。
* 某些Realtek编解码器需要特定的供应商特定系数来开启放大器。详见patch_realtek.c。
* IDT 解码器的每个模拟引脚上可能有额外的电源启用/禁用控制。参见 `patch_sigmatel.c`
* 非常罕见，但有些设备在未触发的情况下不接受引脚检测命令。发送 GET_PIN_SENSE 命令（0xf09）可能会导致解码器通信停滞。一些例子可以在 `patch_realtek.c` 中找到

捕获问题
---------
捕获问题通常是因为缺少混音器设置。因此，在提交错误报告之前，请确保正确设置了混音器。例如，“捕获音量”和“捕获开关”必须正确设置，此外还需要选择正确的“捕获源”或“输入源”。某些设备具有“麦克风增益”音量或开关。
当通过“默认”PCM（没有脉冲音频插件）打开 PCM 设备时，你可能会有一个“数字捕获音量”控制。
这为信号提供了额外的增益/衰减控制，特别是在没有硬件音量控制的输入设备（如数字麦克风）中。除非确实需要，否则应将其设置为恰好 50%，对应于 0dB ——既没有额外的增益也没有衰减。当你使用“hw”PCM（即原始访问 PCM）时，此控制将不起作用。
已知某些解码器/设备具有相当差的模拟电路，记录的声音包含一定的直流偏移。这不是驱动程序的错误。
大多数现代笔记本电脑没有模拟 CD 输入连接。因此，尽管驱动程序提供了从 CD 输入进行捕获的功能，但在许多情况下，从 CD 输入进行录音将无法工作。请改用 CDDA。
自动切换内置和外部麦克风的功能在某些解码器型号上实现，但并非所有型号都支持。部分原因是我的懒惰，但主要是缺乏测试人员。欢迎提交改进补丁给作者。

直接调试
---------
如果没有任何模型选项能给你更好的结果，并且你是一个敢于与邪恶斗争的人，可以尝试通过向设备发送原始 HD-Audio 解码器命令来进行调试。有一些工具可用：`hda-emu` 和 `hda-analyzer`。详细描述见下面的部分。你需要启用 hwdep 才能使用这些工具。参见“内核配置”部分。
其他问题
============

内核配置
--------------------
通常，我建议您启用声音调试选项 `CONFIG_SND_DEBUG=y`，无论您是否在调试。
这会启用 `snd_printd()` 宏和其他功能，并且您会在探测时获得更多的内核消息。
此外，您还可以启用 `CONFIG_SND_DEBUG_VERBOSE=y`。但这会给您带来更多的消息。因此，只有当您确定需要时才开启此选项。
不要忘记启用适当的 `CONFIG_SND_HDA_CODEC_*` 选项。请注意，每个选项对应的是编解码器芯片，而不是控制器芯片。因此，即使 `lspci` 显示的是 Nvidia 控制器，您可能仍需要选择其他厂商的选项。如果您不确定，请全部选为“是”。
`CONFIG_SND_HDA_HWDEP` 是一个用于调试驱动程序的有用选项。
当启用此选项时，驱动程序会为每个编解码器创建硬件相关的设备文件（每个编解码器一个）。例如，对于第一张卡（#0）上的第二个编解码器槽位，将创建名为 `hwC0D2` 的设备文件。对于调试工具如 `hda-verb` 和 `hda-analyzer`，必须启用 hwdep 设备。因此，最好始终启用此选项。
`CONFIG_SND_HDA_RECONFIG` 是一个新选项，并且依赖于上面的 hwdep 选项。当启用此选项时，您将在相应的 hwdep 目录下获得一些 sysfs 文件。请参阅下面的“HD 音频重新配置”部分。
`CONFIG_SND_HDA_POWER_SAVE` 选项启用了省电功能。请参阅下面的“省电”部分。
### Codec Proc-File
-----------------
Codec proc-file 是调试 HD 音频的宝库。它显示了每个 codec 小部件的大部分有用信息。proc 文件位于 `/proc/asound/card*/codec#*`，每个 codec 插槽对应一个文件。你可以通过这个文件了解 codec 的供应商、产品 ID 和名称、每个小部件的类型、功能等。

然而，到目前为止，这个文件还不显示插孔感应状态。这是因为插孔感应可能依赖于触发状态。此文件会被调试工具读取，并且可以作为主要的 codec 信息输入到模拟器中。详见下面的调试工具部分。

此外，此 proc 文件还可以用来检查是否使用了通用解析器。当使用通用解析器时，供应商/产品 ID 名称将显示为“Realtek ID 0262”，而不是“Realtek ALC262”。

### HD-Audio 重配置
------------------------
这是一个实验性功能，允许你在不重新加载驱动程序的情况下动态地重新配置 HD 音频 codec。以下 sysfs 文件可以在每个 codec-hwdep 设备目录下找到（例如 `/sys/class/sound/hwC0D0`）：

- `vendor_id`
  显示 32 位 codec 供应商 ID 的十六进制数字。你可以通过写入此文件来更改供应商 ID 的值。
  
- `subsystem_id`
  显示 32 位 codec 子系统 ID 的十六进制数字。你可以通过写入此文件来更改子系统 ID 的值。
  
- `revision_id`
  显示 32 位 codec 修订 ID 的十六进制数字。你可以通过写入此文件来更改修订 ID 的值。
afg  
显示AFG ID。这是只读的。

mfg  
显示MFG ID。这是只读的。

name  
显示编解码器名称字符串。可以通过写入此文件来更改。

modelname  
显示当前设置的 `model` 选项。可以通过写入此文件来更改。

init_verbs  
初始化时要执行的附加动词。可以通过写入此文件来添加一个动词。传递三个数字：nid、动词和参数（用空格分隔）。

hints  
显示/存储编解码器解析器用于任何用途的提示字符串。
其格式为 `key = value`。例如，传递 `jack_detect = no` 将完全禁用机器的插孔检测。

init_pin_configs  
显示由BIOS设置的初始引脚默认配置值。

driver_pin_configs  
显示由编解码器解析器显式设置的引脚默认值。
这里不显示所有引脚值，仅显示被解析器更改的值。也就是说，如果解析器本身没有更改引脚默认配置值，则这里将没有任何内容。
### 用户引脚配置 (`user_pin_configs`)
显示用于覆盖BIOS设置的默认引脚配置值。写入两个数字（NID和值）会添加新的值。在下次重新配置时，将使用给定的值而不是初始的BIOS值。请注意，此配置还会覆盖驱动程序的引脚配置。

### 重新配置 (`reconfig`)
触发编解码器的重新配置。当向此文件写入任何值时，驱动程序会重新初始化并再次解析编解码器树。所有通过sysfs条目所做的更改都会被考虑进去。

### 清除 (`clear`)
重置编解码器，移除指定编解码器的混音器元素和PCM组件，并清除所有初始化动词和提示信息。

例如，如果您想将引脚小部件0x14的默认配置值更改为0x9993013f，并让驱动程序基于该状态进行重新配置，请执行以下命令：
```
# echo 0x14 0x9993013f > /sys/class/sound/hwC0D0/user_pin_configs
# echo 1 > /sys/class/sound/hwC0D0/reconfig
```

### 提示字符串 (`Hint Strings`)
编解码器解析器有几个开关和调整旋钮，以更好地匹配实际编解码器或设备的行为。其中许多可以通过上述部分提到的“提示”字符串动态调整。例如，通过sysfs或补丁文件传递 `jack_detect = no` 字符串可以禁用插孔检测，从而使编解码器解析器跳过自动静音或麦克风自动切换等功能。作为布尔值，可以传递 `yes`, `no`, `true`, `false`, `1` 或 `0`。

通用解析器支持以下提示：

- **jack_detect** (布尔值)：指定是否在本机上提供插孔检测；默认为true。
- **inv_jack_detect** (布尔值)：表示插孔检测逻辑是反向的。
- **trigger_sense** (布尔值)：表示插孔检测需要显式调用AC_VERB_SET_PIN_SENSE动词。
- **inv_eapd** (布尔值)：表示EAPD是按反向逻辑实现的。
- **pcm_format_first** (布尔值)：在流标签和通道ID之前设置PCM格式。
- **sticky_stream** (布尔值)：尽可能保持PCM格式、流标签和ID；默认为true。
- **spdif_status_reset** (布尔值)：每次设置SPDIF流时重置SPDIF状态位。
- **pin_amp_workaround** (布尔值)：输出引脚可能有多个放大器值。
- **single_adc_amp** (布尔值)：ADC只能有一个输入放大器。
- **auto_mute** (布尔值)：启用或禁用耳机自动静音功能；默认为true。
- **auto_mic** (布尔值)：启用或禁用麦克风自动切换功能；默认为true。
- **line_in_auto_switch** (布尔值)：启用或禁用线路输入自动切换功能；默认为false。
- **need_dac_fix** (布尔值)：根据声道数量限制DAC的数量。
- **primary_hp** (布尔值)：将耳机插孔作为主要输出进行探测；默认为true。
- **multi_io** (布尔值)：尝试探测多I/O配置（例如共享线路输入/环绕声、麦克风/低频效果插孔）。
- **multi_cap_vol** (布尔值)：提供多个捕获音量。
- **inv_dmic_split** (布尔值)：为相位反转的数字麦克风提供拆分内部麦克风音量/开关。
- **indep_hp** (布尔值)：如果可用，提供独立的耳机PCM流及其对应的混音器控制。
- **add_stereo_mix_input** (布尔值)：如果可用，将立体声混合（模拟回环混合）添加到输入多路复用器。
- **add_jack_modes** (布尔值)：为每个I/O插孔添加“xxx插孔模式”枚举控件，允许更改耳机放大器和麦克风偏置VREF能力。
- **power_save_node** (布尔值)：针对每个小部件的高级电源管理，根据实际引脚和流状态控制每个小部件节点的电源状态（D0/D3）。
- **power_down_unused** (布尔值)：关闭未使用的组件，这是`power_save_node`的一个子集，并将在未来被删除。
- **add_hp_mic** (布尔值)：如果可能，将耳机添加到捕获源。
- **hp_mic_detect** (布尔值)：启用或禁用hp/mic共享输入，适用于单个内置麦克风的情况；默认为true。
- **vmaster** (布尔值)：启用或禁用虚拟主控；默认为true。
- **mixer_nid** (整数)：指定模拟回环混音器的小部件NID。

### 早期修补 (`Early Patching`)
当`CONFIG_SND_HDA_PATCH_LOADER=y`设置时，您可以传递一个补丁文件作为固件文件，在初始化编解码器之前修改HD音频设置。这基本上类似于上面通过sysfs进行的重新配置，但在第一次编解码器配置之前执行。

补丁文件是一个纯文本文件，如下所示：
```
[codec]
0x12345678 0xabcd1234 2

[model]
auto

[pincfg]
0x12 0x411111f0

[verb]
0x20 0x500 0x03
0x20 0x400 0xff

[hint]
jack_detect = no
```

文件需要包含一行`[codec]`。下一行应包含三个数字，表示编解码器供应商ID（如0x12345678）、编解码器子系统ID（0xabcd1234）和编解码器地址（2）。其余的补丁条目将应用于此指定的编解码器，直到给出另一个编解码器条目。向第一个或第二个值传递0或负数会使相应的字段检查被跳过，这对于那些无法正确初始化SSID的故障设备很有用。

`[model]`行允许更改每个编解码器的模型名称。在上面的例子中，它会被更改为`model=auto`。

请注意，这会覆盖模块选项。
在``[pincfg]``行之后的内容被解析为初始默认的引脚配置，就像上面提到的``user_pin_configs`` sysfs条目一样。这些值也可以在``user_pin_configs`` sysfs文件中显示。

同样地，``[verb]``行之后的内容被解析为``init_verbs`` sysfs条目，而``[hint]``行之后的内容则被解析为``hints`` sysfs条目。

另一个例子是将编解码器的供应商ID从0x12345678更改为0xdeadbeef，如下所示：
::

    [codec]
    0x12345678 0xabcd1234 2

    [vendor_id]
    0xdeadbeef

类似地，您可以通过``[subsystem_id]``来覆盖编解码器子系统ID，通过``[revision_id]``来覆盖修订ID。此外，还可以通过``[chip_name]``行重写编解码器芯片名称，如下所示：
::

    [codec]
    0x12345678 0xabcd1234 2

    [subsystem_id]
    0xffff1111

    [revision_id]
    0x10

    [chip_name]
    My-own NEWS-0002

高清音频驱动程序通过`request_firmware()`读取该文件。因此，补丁文件必须位于适当的固件路径下，通常是`/lib/firmware`。例如，当您传递选项`patch=hda-init.fw`时，必须存在文件`/lib/firmware/hda-init.fw`。
补丁模块选项针对每个卡实例是特定的，您需要为每个实例提供一个文件名，并用逗号分隔。例如，如果您有两张卡，一张用于板载模拟输出，另一张用于HDMI视频板，您可以像下面这样传递补丁选项：
::

    options snd-hda-intel patch=on-board-patch,hdmi-patch

节能
-----
节能功能类似于设备的自动休眠。当设备在一段时间内未使用时，会自动关闭以节省电力。通过`power_save`模块选项指定关机时间，此选项可通过sysfs动态更改。
在某些编解码器上，当启用模拟回环时，节能功能可能不起作用。如果您希望启用节能功能，请确保静音所有不必要的信号路径。
根据设备的不同，在每次电源开关过程中可能会产生可听见的咔嗒声。有些问题可以解决，但有些问题则较难解决。某些发行版（如openSUSE）会在拔掉电源线时自动启用节能功能。如果听到噪音，请首先怀疑节能功能。查看`/sys/module/snd_hda_intel/parameters/power_save`以检查当前值。如果该值非零，则表示该功能已启用。
最近的内核支持高清音频控制器芯片的运行时电源管理（PM）。这意味着高清音频控制器也可以动态地开启/关闭电源。此功能仅对某些控制器芯片（如Intel LynxPoint）启用。您可以通过设置`power_save_controller`选项来强制启用或禁用此功能，该选项也可在`/sys/module/snd_hda_intel/parameters`目录中找到。

### Tracepoints
高清音频驱动提供了几个基本的追踪点：
- `hda:hda_send_cmd` 追踪每次CORB写入。
- `hda:hda_get_response` 追踪从RIRB读取的响应（仅当从编解码器驱动程序读取时）。
- `hda:hda_bus_reset` 追踪由于致命错误导致的总线重置等事件。
- `hda:hda_unsol_event` 追踪未请求的事件。
- `hda:hda_power_down` 和 `hda:hda_power_up` 追踪通过节能行为的电源关闭/开启。

要启用所有追踪点，可以执行以下命令：
```sh
# echo 1 > /sys/kernel/tracing/events/hda/enable
```

然后，在执行一些命令后，可以从`/sys/kernel/tracing/trace`文件中获取追踪信息。例如，如果您想追踪发送了哪些编解码器命令，可以启用追踪点：
```sh
# cat /sys/kernel/tracing/trace
# tracer: nop
#
#       TASK-PID    CPU#    TIMESTAMP  FUNCTION
#          | |       |          |         |
	   <...>-7807  [002] 105147.774889: hda_send_cmd: [0:0] val=e3a019
	   <...>-7807  [002] 105147.774893: hda_send_cmd: [0:0] val=e39019
	   <...>-7807  [002] 105147.999542: hda_send_cmd: [0:0] val=e3a01a
	   <...>-7807  [002] 105147.999543: hda_send_cmd: [0:0] val=e3901a
	   <...>-26764 [001] 349222.837143: hda_send_cmd: [0:0] val=e3a019
	   <...>-26764 [001] 349222.837148: hda_send_cmd: [0:0] val=e39019
	   <...>-26764 [001] 349223.058539: hda_send_cmd: [0:0] val=e3a01a
	   <...>-26764 [001] 349223.058541: hda_send_cmd: [0:0] val=e3901a
```

这里的`[0:0]`表示卡号和编解码器地址，而`val`显示发送给编解码器的值。该值是一个打包的值，您可以使用hda-emu包中的hda-decode-verb程序对其进行解码。例如，值e3a019表示将左输出放大器的值设置为25：
```sh
% hda-decode-verb 0xe3a019
raw value = 0x00e3a019
cid = 0, nid = 0x0e, verb = 0x3a0, parm = 0x19
raw value: verb = 0x3a0, parm = 0x19
verbname = set_amp_gain_mute
amp raw val = 0xa019
output, left, idx=0, mute=0, val=25
```

### 开发树
最新的高清音频开发代码可以在以下Git仓库中找到：
- `git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound.git`

通常情况下，master分支或for-next分支可以用作主要开发分支，而对于当前和下一个内核版本的开发则分别在for-linus和for-next分支中进行。

### 提交Bug报告
如果任何模型或模块选项对您的设备不起作用，是时候向开发者提交一个Bug报告了。请在Bug报告中提供以下信息：
- 硬件供应商、产品和型号名称
- 内核版本（以及ALSA驱动版本，如果您是外部构建的话）
- `alsa-info.sh` 输出；运行时带上 `--no-upload` 选项。有关`alsa-info`的详细信息，请参见下面的部分。

如果这是一个回归问题，最好同时提交工作正常和不正常的内核的`alsa-info`输出。这非常有帮助，因为我们可以直接比较编解码器寄存器。

提交Bug报告的方式如下：
- kernel-bugzilla：https://bugzilla.kernel.org/
- alsa-devel邮件列表：alsa-devel@alsa-project.org

### 调试工具
本节介绍了一些可用于调试高清音频问题的工具。

#### alsa-info
脚本`alsa-info.sh`是一个非常有用的工具，用于收集音频设备信息。它包含在alsa-utils包中。最新版本可以在以下Git仓库中找到：
- `git://git.alsa-project.org/alsa-utils.git`

也可以直接从以下URL获取该脚本：
- https://www.alsa-project.org/alsa-info.sh

以root用户身份运行此脚本，它将收集重要信息，如模块列表、模块参数、proc文件内容（包括编解码器proc文件）、混音器输出和控制元素。默认情况下，它会将信息存储在alsa-project.org上的Web服务器上。但如果提交Bug报告，最好使用`--no-upload`选项，并附上生成的文件。

还有一些其他有用的选项。详细信息请查看`--help`选项的输出。
当探测错误发生或驱动程序明显分配了不匹配的模型时，使用 `probe_only=1` 选项加载驱动程序（最好在冷重启之后）并在此状态下运行 alsa-info 会很有帮助。通过这个选项，驱动程序不会配置混音器和 PCM，而只是尝试探测编解码器插槽。探测后，可以访问 `/proc` 文件，因此可以在驱动程序修改之前获取原始的编解码器信息。当然，启用 `probe_only=1` 时驱动程序是不可用的。但是，如果启用了 hda-reconfig 选项，则可以通过 hwdep 的 sysfs 文件继续配置。使用 `probe_only` 掩码 2 可以跳过 HDA 编解码器的重置（使用 `probe_only=3` 作为模块选项）。hwdep 接口可用于确定 BIOS 初始化的编解码器。

### hda-verb
hda-verb 是一个小型程序，允许您直接访问 HD 音频编解码器。您可以使用此程序执行一个原始的 HD 音频编解码器命令。此程序访问 hwdep 设备，因此您需要预先启用内核配置 `CONFIG_SND_HDA_HWDEP=y`。

hda-verb 程序接受四个参数：hwdep 设备文件、小部件 NID、命令和参数。当您访问第 0 张卡的第 2 个插槽上的编解码器时，通常将 `/dev/snd/hwC0D2` 传递给第一个参数。（然而，实际路径名取决于系统。）

第二个参数是要访问的小部件编号。第三个参数可以是一个十六进制/数字或对应于命令的字符串。类似地，最后一个参数是要写入的值，或者可以是一个字符串表示参数类型：
```
% hda-verb /dev/snd/hwC0D0 0x12 0x701 2
nid = 0x12, verb = 0x701, param = 0x2
value = 0x0

% hda-verb /dev/snd/hwC0D0 0x0 PARAMETERS VENDOR_ID
nid = 0x0, verb = 0xf00, param = 0x0
value = 0x10ec0262

% hda-verb /dev/snd/hwC0D0 2 set_a 0xb080
nid = 0x2, verb = 0x300, param = 0xb080
value = 0x0
```

虽然您可以使用此程序发出任何命令，但驱动程序的状态并不总是更新。例如，音量值通常在驱动程序中缓存，因此直接通过 hda-verb 更改小部件的放大器值不会更改混音器值。

hda-verb 程序现在包含在 alsa-tools 中：
* git://git.alsa-project.org/alsa-tools.git

此外，旧的独立包可以在 FTP 目录中找到：
* ftp://ftp.suse.com/pub/people/tiwai/misc/

还有一个 git 仓库可用：
* git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/hda-verb.git

有关 hda-verb 程序的更多详细信息，请参阅 tarball 中的 README 文件。

### hda-analyzer
hda-analyzer 提供了一个基于 pyGTK2 绑定的图形界面来访问原始的 HD 音频控制。它是 hda-verb 的更强大版本。该程序提供了一个易于使用的 GUI 来显示小部件信息和调整放大器值，以及与 proc 兼容的输出。

hda-analyzer：
* https://git.alsa-project.org/?p=alsa.git;a=tree;f=hda-analyzer

是 alsa-project.org 上 alsa.git 仓库的一部分：
* git://git.alsa-project.org/alsa.git

### Codecgraph
Codecgraph 是一个用于生成图表并可视化编解码器芯片中的编解码器节点连接的实用程序。当没有适当的规格书进行分析或调试编解码器时，它特别有用。该程序解析给定的编解码器 proc 文件并通过 graphviz 转换为 SVG。

tarball 和 GIT 树可以在网页上找到：
* http://helllabs.org/codecgraph/

### hda-emu
hda-emu 是一个 HD 音频仿真器。此程序的主要目的是在没有实际硬件的情况下调试 HD 音频编解码器。因此，它不会模拟实际音频 I/O 的行为，而是仅在探测和操作 HD 音频驱动程序时记录编解码器寄存器变化和 ALSA 驱动程序内部变化。
该程序需要一个编解码器处理文件（proc-file）来进行模拟。请提前获取目标编解码器的处理文件，或者从压缩包中的编解码器处理文件集合中挑选一个示例编解码器。然后，使用该处理文件运行程序，`hda-emu` 程序将开始解析编解码器文件并模拟 HD 音频驱动：

```
% hda-emu codecs/stac9200-dell-d820-laptop
# 解析中。
hda_codec: 对于 STAC9200，未知模型，使用 BIOS 默认设置
    hda_codec: pin nid 08 的 BIOS 引脚配置为 40c003fa
    ...
```

该程序仅提供一个非常简单的命令行界面。你可以获取当前状态下的处理文件转储，获取控制（混音器）元素列表，设置/获取控制元素值，模拟 PCM 操作，模拟插孔插入等。

该程序可以在以下 Git 仓库中找到：

* `git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/hda-emu.git`

有关 `hda-emu` 程序的更多详细信息，请参阅仓库中的 README 文件。

### hda-jack-retask

`hda-jack-retask` 是一个用户友好的图形界面程序，用于操作 HD 音频引脚控制以重新分配插孔功能。如果你遇到插孔分配问题，可以尝试这个程序，并检查是否能获得有用的结果。一旦确定了正确的引脚分配，可以通过静态修改驱动代码或通过传递固件补丁文件来固定（详见“早期打补丁”部分）。

该程序现在包含在 alsa-tools 中：

* `git://git.alsa-project.org/alsa-tools.git`
