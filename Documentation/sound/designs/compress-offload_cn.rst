=========================
ALSA 压缩卸载 API
=========================

Pierre-Louis.Bossart <pierre-louis.bossart@linux.intel.com>

Vinod Koul <vinod.koul@linux.intel.com>

概述
=====
自从 ALSA API 最初定义以来，它主要是为 PCM 支持或像 IEC61937 这样的恒定比特率负载设计的。参数和返回值通常以帧为单位，这使得将现有 API 扩展到压缩数据流变得具有挑战性。近年来，音频数字信号处理器（DSP）被集成到系统级芯片（SoC）设计中，并且 DSP 也被集成到了音频编解码器中。在这样的 DSP 上处理压缩数据与主机处理相比可以显著降低功耗。Linux 对这种硬件的支持一直不够好，主要是因为主线内核中缺乏一个通用的 API。

为了避免通过更改 ALSA PCM 接口导致兼容性问题，引入了一个新的“压缩数据”API 来为音频 DSP 提供控制和数据流接口。这个 API 的设计受到了 Intel Moorestown SoC 两年使用经验的启发，经过多次修正后，将其从实验性树移至主线内核，并使其可供其他人使用。

要求
=====
主要的要求包括：

- 字节计数与时间的分离。压缩格式可能每个文件、每帧有一个头部，或者根本没有头部。有效载荷大小可能从一帧到另一帧有所不同。因此，在处理压缩数据时无法可靠地估计音频缓冲区的持续时间。需要专门的机制来实现可靠的音视频同步，这要求能够精确报告任意时刻渲染的样本数量。
- 多种格式的处理。PCM 数据只需要指定采样率、声道数和每样本位数。相比之下，压缩数据有多种格式。音频 DSP 可能会提供对有限数量的音频编码器和解码器的固件支持，或者通过动态下载库来支持更多的选择。
- 关注主流格式。此 API 支持用于音频和视频捕获和播放的最流行格式。随着音频压缩技术的发展，可能会添加新的格式。
- 多种配置的处理。即使是对于 AAC 这样的给定格式，某些实现可能支持多声道 AAC 但仅支持双声道 HE-AAC。同样，WMA10 级别 M3 可能需要太多内存和 CPU 周期。新 API 需要提供一种通用的方式来列出这些格式。
- 仅渲染/抓取。此 API 不提供任何硬件加速功能，其中 PCM 样本被返回到用户空间进行额外处理。相反，该 API 专注于将压缩数据流传输到 DSP，假设解码后的样本会被路由到物理输出或逻辑后端。
- 隐藏复杂性。现有的用户空间多媒体框架都有针对每种压缩格式的枚举/结构。这个新 API 假设存在一个平台特定的兼容层来暴露、转换并利用音频 DSP 的能力，例如 Android HAL 或 PulseAudio 沉淀。原则上，普通应用程序不应直接使用此 API。
设计
======
新的API与PCM API在流量控制方面共享了许多概念。无论内容如何，启动、暂停、恢复、排空和停止命令的语义保持一致。
内存环形缓冲区分为多个片段的概念借鉴自ALSA PCM API。然而，只能指定以字节为单位的大小。
寻址/特技模式假定由主机处理。
倒带/快进的概念不被支持。提交到环形缓冲区的数据不能被作废，除非丢弃所有缓冲区。
压缩数据API不对数据如何传输到音频DSP做任何假设。可以实现从主存到嵌入式音频集群或通过SPI接口到外部DSP的DMA传输。与ALSA PCM类似，公开了一组核心例程；每个驱动程序开发者需要编写一组强制性例程的支持，并可能使用可选例程。
主要的新增功能包括：

get_caps
  此例程返回支持的音频格式列表。查询捕获流上的编解码器将返回编码器，而播放流上将列出解码器。
get_codec_caps
  对于每个编解码器，此例程返回其能力列表。目的是确保所有能力都对应于有效的设置，并尽量减少配置失败的风险。例如，对于像AAC这样复杂的编解码器，支持的声道数量可能取决于特定的配置文件。如果用单一描述符来暴露这些能力，则可能会出现某些配置文件/声道/格式组合不被支持的情况。同样地，嵌入式DSP有有限的内存和CPU周期，因此一些实现可能会使能力列表动态化并依赖现有的工作负载。除了编解码器设置外，此例程还返回实现所处理的最小缓冲区大小。这些信息可以是DMA缓冲区大小、同步所需的字节数等函数的结果，并可用于用户空间定义在开始播放之前需要写入环形缓冲区的内容量。
set_params
  此例程设置针对特定编解码器选择的配置。参数中最重要的是编解码器类型；大多数情况下，解码器会忽略其他字段，而编码器则严格遵循设置。
get_params
  此例程返回DSP实际使用的设置。对设置的更改应保持例外。
get_timestamp
  时间戳变为一个多字段结构。它列出了已传输的字节数、处理的样本数以及渲染/抓取的样本数。所有这些值都可以用于确定平均比特率、判断是否需要重新填充环形缓冲区或由于DSP上的解码/编码/输入输出造成的延迟。
请注意，编解码器/配置文件/模式列表是从OpenMAX AL规范中得出的，而不是重新发明轮子。
修改包括：
- 添加FLAC和IEC格式
- 编码器/解码器功能的合并
- 将配置文件/模式列为位掩码以使描述符更紧凑
- 为解码器添加set_params（OpenMAX AL中缺失）
- 添加AMR/AMR-WB编码模式（OpenMAX AL中缺失）
- 添加WMA的格式信息
- 在需要时添加编码选项（源自OpenMAX IL）
- 添加rateControlSupported（OpenMAX AL中缺失）

状态机
=============

压缩音频流的状态机如下所示：

```
                                        +----------+
                                        |          |
                                        |   OPEN   |
                                        |          |
                                        +----------+
                                             |
                                             |
                                             | compr_set_params()
                                             |
                                             v
         compr_free()                  +----------+
  +------------------------------------|          |
  |                                    |   SETUP  |
  |          +-------------------------|          |<-------------------------+
  |          |       compr_write()     +----------+                          |
  |          |                              ^                                |
  |          |                              | compr_drain_notify()           |
  |          |                              |        或                      |
  |          |                              |     compr_stop()               |
  |          |                              |                                |
  |          |                         +----------+                          |
  |          |                         |          |                          |
  |          |                         |   DRAIN  |                          |
  |          |                         |          |                          |
  |          |                         +----------+                          |
  |          |                              ^                                |
  |          |                              |                                |
  |          |                              | compr_drain()                  |
  |          |                              |                                |
  |          v                              |                                |
  |    +----------+                    +----------+                          |
  |    |          |    compr_start()   |          |        compr_stop()      |
  |    | PREPARE  |------------------->|  RUNNING |--------------------------+
  |    |          |                    |          |                          |
  |    +----------+                    +----------+                          |
  |          |                            |    ^                             |
  |          |compr_free()                |    |                             |
  |          |              compr_pause() |    | compr_resume()              |
  |          |                            |    |                             |
  |          v                            v    |                             |
  |    +----------+                   +----------+                           |
  |    |          |                   |          |         compr_stop()      |
  +--->|   FREE   |                   |  PAUSE   |---------------------------+
       |          |                   |          |
       +----------+                   +----------+
```

无缝播放
================
当通过专辑播放时，解码器有能力跳过编码延迟和填充，并直接从一个音轨内容切换到另一个。最终用户可以感知这种无缝播放，因为我们在从一个音轨切换到另一个时没有静音。

此外，由于编码可能会有低强度噪音。对于所有类型的压缩数据来说，完美的无缝播放难以实现，但对于大多数音乐内容来说效果很好。解码器需要知道编码延迟和编码填充，所以我们需要将这些信息传递给DSP。这些元数据是从ID3/MP4头部提取的，默认情况下不在比特流中，因此需要一个新的接口来传递这些信息。同时，DSP和用户空间需要在音轨之间进行切换并开始使用第二条音轨的数据。

主要添加项包括：

set_metadata
  此函数设置编码延迟和编码填充。解码器可以利用这些信息去除静音。这需要在音轨数据写入之前设置。
set_next_track
  此函数告诉DSP，在此之后发送的元数据和写操作对应于下一个音轨。
partial_drain
  当到达文件末尾时调用此函数。用户空间可以通知DSP已到达EOF，此时DSP可以开始跳过填充延迟。接下来的写入数据属于下一个音轨。

无缝播放的序列流程如下：
- 打开
- 获取功能/编解码器功能
- 设置参数
- 设置第一个音轨的元数据
- 填充第一个音轨的数据
- 触发启动
- 用户空间完成发送所有数据后，
- 通过发送set_next_track指示下一个音轨的数据
- 设置下一个音轨的元数据
- 然后调用partial_drain以清除DSP中的大部分缓冲区
- 填充下一个音轨的数据
- DSP切换到第二个音轨

（注意：partial_drain和下一个音轨写入的顺序也可以互换）

无缝播放状态机
==================

对于无缝播放，我们从运行状态切换到部分排空状态再返回，并设置元数据和发出切换到下一音轨的信号：

```
                                        +----------+
                compr_drain_notify()    |          |
              +------------------------>|  RUNNING |
              |                         |          |
              |                         +----------+
              |                              |
              |                              |
              |                              | compr_next_track()
              |                              |
              |                              V
              |                         +----------+
              |    compr_set_params()   |          |
              |             +-----------|NEXT_TRACK|
              |             |           |          |
              |             |           +--+-------+
              |             |              | |
              |             +--------------+ |
              |                              |
              |                              | compr_partial_drain()
              |                              |
              |                              V
              |                         +----------+
              |                         |          |
              +------------------------ | PARTIAL_ |
                                        |  DRAIN   |
                                        +----------+
```

不支持的功能
=============
- 不支持VoIP/电路交换通话。动态比特率变化的支持需要DSP与主机栈之间的紧密耦合，限制了功耗节省。
- 不支持包丢失掩盖。这需要一个额外的接口让解码器在网络传输中丢失帧时合成数据。这可能在未来增加。
- 音量控制/路由不由本API处理。暴露压缩数据接口的设备将被视为常规ALSA设备；音量变化和路由信息将通过常规ALSA控件提供。
- 内嵌音频效果。无论输入是PCM还是压缩格式，此类效果应以相同方式启用。
- 多声道IEC编码。尚不清楚是否需要。
- 如上所述，不支持编码/解码加速。可以将解码器输出路由到捕获流，甚至实现转码功能。此路由将通过ALSA控件启用。
- 不提供音频策略/资源管理。此API不提供查询音频DSP利用率或任何抢占机制的接口。
### 无欠载/过载概念
由于写入的字节是经过压缩的，并且写入/读取的数据无法直接转换为实时渲染输出，因此这里不处理欠载/过载问题，可能需要在用户库中处理。

### 致谢
- Mark Brown 和 Liam Girdwood 对此API需求的讨论
- Harsha Priya 在 intel_sst 压缩API方面的工作
- Rakesh Ughreja 提供了宝贵的反馈
- Sing Nallasellan、Sikkandar Madar 和 Prasanna Samaga 展示并量化了在实际平台上进行音频卸载的好处
