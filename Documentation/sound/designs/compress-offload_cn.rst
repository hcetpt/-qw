=========================
ALSA 压缩卸载 API
=========================

Pierre-Louis.Bossart <pierre-louis.bossart@linux.intel.com>

Vinod Koul <vinod.koul@linux.intel.com>


概述
=====
自从 ALSA API 最初定义以来，它主要考虑的是 PCM 支持或像 IEC61937 这样的恒定比特率负载。以帧为单位的参数和返回值是常态，这使得将现有 API 扩展到压缩数据流变得具有挑战性。
近年来，音频数字信号处理器（DSP）被集成到了系统级芯片设计中，并且 DSP 也被集成到了音频编解码器中。在这样的 DSP 上处理压缩数据与主机端处理相比可以极大地降低功耗消耗。Linux 中对这种硬件的支持并不好，主要是因为主线内核中缺乏一个通用的 API。
为了避免 ALSA PCM 接口的 API 变更导致的兼容性问题，我们引入了一个新的“压缩数据”API 来为音频 DSP 提供控制和数据流接口。
该 API 的设计受到了 Intel Moorestown SOC 两年使用经验的启发，经过多次修正后使其适合合并到主线内核而非测试树中，并使其他人能够使用。

要求
=====
主要的要求包括：

- 字节计数和时间的分离。压缩格式可能有文件级别的头部、帧级别的头部或者根本没有头部。每帧的有效负载大小也可能不同。因此，在处理压缩数据时无法可靠地估计音频缓冲区的持续时间。需要专门机制来确保可靠的音视频同步，这就要求能够精确报告任何给定时间点已渲染的样本数量。
- 多种格式的支持。PCM 数据只需要指定采样率、通道数和每样本位数。相比之下，压缩数据有多种不同的格式。音频 DSP 可能提供有限数量的嵌入固件中的音频编码器和解码器支持，也可能通过动态下载库的方式支持更多选择。
- 关注主流格式。此 API 支持最流行的用于音频和视频捕获及播放的格式。随着音频压缩技术的发展，可能会添加新格式。
- 多配置的支持。即使是对于像 AAC 这样的特定格式，某些实现可能支持多声道 AAC 但不支持 HE-AAC 立体声。类似地，WMA10 级别 M3 可能会消耗过多的内存和 CPU 资源。新的 API 需要提供一种通用的方式来列出这些格式。
- 仅渲染/抓取。此 API 不提供任何硬件加速手段，即不会将 PCM 样本返回给用户空间进行额外处理。相反，此 API 专注于将压缩数据流传输到 DSP，并假设解码后的样本会被路由到物理输出或逻辑后端。
- 隐藏复杂性。现有的用户空间多媒体框架通常为每种压缩格式都有现成的枚举/结构。这个新的 API 假设存在一个平台特定的兼容层来暴露、转换并利用音频 DSP 的能力，例如 Android HAL 或 PulseAudio 沉淀。原则上，常规应用程序不应该直接使用此 API。
设计
======
新的 API 与用于流控制的 PCM API 共享许多概念。开始、暂停、恢复、排空和停止命令无论内容如何都具有相同的语义。
分段内存环形缓冲区的概念借鉴自 ALSA PCM API。然而，只能指定以字节为单位的大小。
假设寻址/特殊播放模式由主机处理。
不支持倒带/快进的概念。已提交到环形缓冲区的数据不能被取消，除非丢弃所有缓冲区。
压缩数据 API 对数据如何传输至音频 DSP 不做任何假设。可以进行从主存到嵌入式音频集群或外部 DSP 的 SPI 接口的 DMA 传输。如同 ALSA PCM 情况一样，公开了一套核心例程；每个驱动程序开发者需要编写一套必选例程的支持，并可能使用可选例程。
主要的新增功能包括：

get_caps
  此例程返回支持的音频格式列表。对捕获流上的编解码器进行查询将返回编码器，而播放流上将列出解码器。
get_codec_caps
  对于每个编解码器，此例程返回一系列能力。目的是确保所有能力对应于有效的设置，并尽量减少配置失败的风险。例如，对于像 AAC 这样复杂的编解码器，支持的声道数量可能取决于特定的配置文件。如果用单个描述符暴露这些能力，则可能会出现某些特定组合的配置文件/声道/格式不受支持的情况。同样地，嵌入式 DSP 有有限的内存和 CPU 周期，很可能一些实现会使得能力列表动态变化并依赖于现有的工作负载。除了编解码器设置之外，此例程还返回实现所处理的最小缓冲区大小。这些信息可能是 DMA 缓冲区大小、同步所需的字节数等因素的函数，并可用于用户空间来定义在开始播放之前需要写入环形缓冲区的数量。
set_params
  此例程设置特定编解码器所选择的配置。参数中最重要的字段是编解码器类型；大多数情况下解码器会忽略其他字段，而编码器则严格遵守设置。

get_params
  此例程返回 DSP 使用的实际设置。对设置的更改应保持例外状态。
get_timestamp
  时间戳变成一个多字段结构。它列出了传输的字节数、处理的样本数以及渲染/抓取的样本数。所有这些值都可以用来确定平均比特率、判断是否需要重新填充环形缓冲区或计算由于 DSP 上的解码/编码/I/O 而导致的延迟。
请注意，编解码器/配置文件/模式的列表是从 OpenMAX AL 规范中派生的，而不是重新发明轮子。
修改包括：
- 添加FLAC和IEC格式
- 编码器/解码器功能的合并
- 将配置文件/模式以位掩码列出，使描述符更加紧凑
- 为解码器添加set_params（OpenMAX AL中缺失）
- 添加AMR/AMR-WB编码模式（OpenMAX AL中缺失）
- 添加WMA格式信息
- 在必要时添加编码选项（源自OpenMAX IL）
- 添加rateControlSupported（OpenMAX AL中缺失）

状态机
=============

下面描述了压缩音频流的状态机 ::

                                        +----------+
                                        |          |
                                        |   OPEN   |
                                        |          |
                                        +----------+
                                             |
                                             |
                                             | compr_set_params()
                                             |
                                             v
         compr_free()                  +----------+
  +------------------------------------|          |
  |                                    |   SETUP  |
  |          +-------------------------|          |<-------------------------+
  |          |       compr_write()     +----------+                          |
  |          |                              ^                                |
  |          |                              | compr_drain_notify()           |
  |          |                              |        或                      |
  |          |                              |     compr_stop()               |
  |          |                              |                                |
  |          |                         +----------+                          |
  |          |                         |          |                          |
  |          |                         |   DRAIN  |                          |
  |          |                         |          |                          |
  |          |                         +----------+                          |
  |          |                              ^                                |
  |          |                              |                                |
  |          |                              | compr_drain()                  |
  |          |                              |                                |
  |          v                              |                                |
  |    +----------+                    +----------+                          |
  |    |          |    compr_start()   |          |        compr_stop()      |
  |    | PREPARE  |------------------->|  RUNNING |--------------------------+
  |    |          |                    |          |                          |
  |    +----------+                    +----------+                          |
  |          |                            |    ^                             |
  |          |compr_free()                |    |                             |
  |          |              compr_pause() |    | compr_resume()              |
  |          |                            |    |                             |
  |          v                            v    |                             |
  |    +----------+                   +----------+                           |
  |    |          |                   |          |         compr_stop()      |
  +--->|   FREE   |                   |  PAUSE   |---------------------------+
       |          |                   |          |
       +----------+                   +----------+


无缝播放
================
在播放整张专辑时，解码器有能力跳过编码延迟和填充，并直接从一曲内容过渡到另一曲。用户可以感知这种无缝播放，因为我们在从一曲切换到另一曲时没有静音。

此外，由于编码可能会产生低强度噪声。对于所有类型的压缩数据来说，完美的无缝播放很难实现，但对于大多数音乐内容来说效果很好。解码器需要知道编码延迟和编码填充，所以我们需要将这些信息传递给DSP。这些元数据是从ID3/MP4头部提取的，并且默认情况下不会出现在比特流中，因此需要一个新的接口来传递这些信息给DSP。同时，DSP和用户空间需要从一个曲目切换到另一个曲目并开始使用第二个曲目的数据。

主要的添加如下：

set_metadata
  此例程设置编码延迟和编码填充。这可用于由解码器去除静音。这需要在写入轨道中的数据之前设置
set_next_track
  此例程告诉DSP，在此之后发送的元数据和写操作对应于后续的曲目

部分清空
  当达到文件末尾时调用。用户空间可以通知DSP文件已结束，现在DSP可以开始跳过填充延迟。此外，下一个写入的数据将属于下一曲

无缝播放的序列流程如下：
- 打开
- 获取功能/编解码器功能
- 设置参数
- 设置第一曲的元数据
- 填充第一曲的数据
- 触发启动
- 用户空间完成发送所有数据，
- 通过发送set_next_track指示下一曲的数据
- 设置下一曲的元数据
- 然后调用partial_drain来清除DSP中的大部分缓冲区
- 填充下一曲的数据
- DSP切换到第二曲

（注意：partial_drain和写入下一曲的顺序可以颠倒）

无缝播放状态机
==================

对于无缝播放，我们从运行状态移动到部分清空状态然后再返回，同时还设置了元数据并为下一曲发出信号 ::


                                        +----------+
                compr_drain_notify()    |          |
              +------------------------>|  RUNNING |
              |                         |          |
              |                         +----------+
              |                              |
              |                              |
              |                              | compr_next_track()
              |                              |
              |                              V
              |                         +----------+
              |    compr_set_params()   |          |
              |             +-----------|NEXT_TRACK|
              |             |           |          |
              |             |           +--+-------+
              |             |              | |
              |             +--------------+ |
              |                              |
              |                              | compr_partial_drain()
              |                              |
              |                              V
              |                         +----------+
              |                         |          |
              +------------------------ | PARTIAL_ |
                                        |  DRAIN   |
                                        +----------+

不支持的功能
=============
- VoIP/电路交换通话的支持不是此API的目标。动态比特率变化的支持需要DSP与主机堆栈之间的紧密耦合，限制了节能的效果
- 包丢失隐藏不受支持。这需要额外的接口让解码器在传输过程中丢失帧时合成数据。这可能在未来被添加
- 音量控制/路由不由这个API处理。暴露压缩数据接口的设备将被视为常规ALSA设备；音量变化和路由信息将通过常规ALSA kcontrols提供
- 内置音频效果。此类效果应以相同的方式启用，无论输入是PCM还是压缩
- 多通道IEC编码。尚不清楚是否需要这个功能
- 如上所述，不支持编码/解码加速。有可能将解码器的输出路由到捕获流，甚至实现转码能力。这种路由将通过ALSA kcontrols启用
- 音频策略/资源管理。此API没有提供任何查询音频DSP利用率或任何抢占机制的挂钩
- 没有欠载/过载的概念。由于所写入的字节本质上是被压缩的，而且写入/读取的数据并不能直接对应到随时间变化的渲染输出，因此这里不处理欠载/过载问题，并且这可能需要在用户库中解决。

鸣谢
======
- 马克·布朗 (Mark Brown) 和 利亚姆·吉尔伍德 (Liam Girdwood) 对于此API需求的讨论
- 哈莎·普丽雅 (Harsha Priya) 在intel_sst压缩API方面的工作
- 拉凯什·乌格雷贾 (Rakesh Ughreja) 提供了宝贵的反馈
- 辛格·纳拉塞兰 (Sing Nallasellan)、锡坎达尔·马达 (Sikkandar Madar) 和 普拉萨纳·萨玛加 (Prasanna Samaga) 展示并量化了在实际平台上进行音频卸载的好处
