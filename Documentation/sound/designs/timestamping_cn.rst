== ALSA PCM 时间戳 ==
  
ALSA API 可以提供两种不同的系统时间戳：

- `Trigger_tstamp` 是在调用 `.trigger` 回调时所获取的系统时间快照。通常情况下，此快照由 ALSA 核心捕获，但特定硬件可能具备同步能力，或者相反地只能在一定延迟后提供准确估计。在后两种情况下，低级驱动程序负责在最恰当和精确的时刻更新 `trigger_tstamp`。应用程序不应仅依赖于第一个 `trigger_tstamp`，而应在驱动程序延迟提供更精确估计时更新其内部计算。
- `tstamp` 是在最近一次事件或应用程序查询期间更新的当前系统时间戳。
时间差 (`tstamp - trigger_tstamp`) 定义了经过的时间。

ALSA API 提供了两个基本的信息：`avail` 和 `delay`，结合 `trigger` 和当前系统时间戳，使应用程序能够跟踪环形缓冲区的“满度”以及排队样本的数量。
使用这些不同的指针和时间信息取决于应用程序的需求：

- `avail` 报告可以在环形缓冲区中写入多少数据。
- `delay` 报告在所有已排队样本播放完毕后听到新样本所需的时间。

当启用时间戳时，`avail/delay` 信息会与系统时间快照一起报告。应用程序可以选择 `CLOCK_REALTIME`（包括 NTP 校正，甚至可以回溯）、`CLOCK_MONOTONIC`（有 NTP 校正但不会回溯）、`CLOCK_MONOTONIC_RAW`（没有 NTP 校正），并可以通过 `sw_params` 动态更改模式。

ALSA API 还提供了一个 `audio_tstamp`，它反映了通过音频硬件的不同组件测量的时间流逝。对于播放情况，可以用 ASCII 艺术表示如下：
```
--------------------------------------------------------> 时间
    ^               ^              ^                ^           ^
    |               |              |                |           |
   模拟         链路            DMA              应用       全缓冲区
   时间           时间           时间              时间        时间
    |               |              |                |           |
    |< 编码器延迟 >|<-- 硬件延迟 -->|< 排队样本 >|<--- 可用 -->|
    |<----------------- 延迟 ---------------------->|           |
                                   |<---- 环形缓冲区长度 ---->|
```

模拟时间是在播放的最后阶段捕获的，尽可能接近实际转换器。

链路时间是在 SoC/芯片组输出处捕获的，即样本被推送到链路上时。如果硬件支持，链路时间可以直接通过样本计数器或时钟（例如 HDAudio 的 24MHz 或网络解决方案中的 PTP 时钟）进行测量；或者间接估算（例如 USB 中的帧计数器）。
DMA 时间是通过计数器测量的——通常是所有测量中最不可靠的一种，因为 DMA 传输具有突发性。
应用时间对应于应用程序在向环形缓冲区写入之后追踪的时间。
应用程序可以查询硬件能力，并通过选择 `audio_tstamp_config` 字段中的相关设置来定义希望报告的音频时间，从而获得时间戳精度的估计。它还可以要求将从数字到模拟的延迟能够包含在测量中。直接访问链路时间在提供了嵌入式 DSP 的平台上非常有趣；通过专用硬件直接测量链路时间，可能与系统时间同步，消除了跟踪内部 DSP 处理时间和延迟的需要。

如果应用程序请求的音频时间戳在硬件/低级驱动程序中不支持，则类型将被覆盖为 DEFAULT，并且时间戳将根据 `hw_pointer` 值报告 DMA 时间。
为了与先前未提供时间戳选择功能的实现保持向后兼容性，当COMPAT时间戳类型值为零时，默认结果将采用HDAudio的系统时钟作为播放流的时间基准，在所有其他情况下则采用直接内存访问时间（hw_ptr）。
音频时间戳的准确性可以返回到用户空间，以便据此做出适当决策：

- 对于直接内存访问时间（默认），可以从更新之间的步长推断出传输的粒度，进而提供有关应用程序指针可以安全回绕多少的信息。
- 链接时间可用于通过(tstamp-trigger_tstamp)/audio_tstamp比率追踪音频时间和系统时间之间的长期偏差，精度有助于定义所需的平滑/低通滤波程度。链接时间可以在启动时重置或按原样报告（后者对于比较不同流的进度很有用——但可能需要始终运行系统时钟，并在空闲期间不发生溢出）。如果硬件支持的话，绝对链接时间也可以用于定义精确的开始时间（相关补丁正在开发中）。

- 在音频时间戳中包括延迟可能反直觉地不会提高时间戳的精度，例如，如果编解码器包含可变延迟的数字信号处理或一系列硬件组件，则通常无法精确得知该延迟。
准确性以纳秒单位报告（使用一个32位无符号整数），这给出了最大4.29秒的精度，这对于音频应用来说已经足够了。
由于时间戳需求的多样性，即使是单一应用也存在多种需求，因此音频时间戳配置可以动态更改。在`STATUS` ioctl中，参数是只读的，不允许任何应用选择。为了克服这一限制而又不影响遗留应用，引入了一个新的`STATUS_EXT` ioctl，其中参数可以读写。ALSA-lib将会被修改以使用`STATUS_EXT`，从而实际上废弃`STATUS`。
ALSA API仅允许一次报告单个音频时间戳。这是一个有意识的设计决策：从硬件寄存器或通过进程间通信读取时间戳需要时间，读取的时间戳越多，组合测量的结果就越不准确。为了避免任何解释问题，报告一个（系统，音频）时间戳。需要不同时间戳的应用程序将被要求发出多次查询并对结果进行插值。

在某些特定的硬件配置中，系统时间戳由低级音频子系统捕获，并反馈给驱动程序。由于与硬件通信可能存在延迟，存在与可用性和延迟信息对齐的风险。为了避免让应用程序产生混淆，snd_pcm_status结构中添加了一个driver_timestamp字段；这个时间戳显示信息由驱动程序整合并从`STATUS`和`STATUS_EXT` ioctl返回的时刻。在大多数情况下，此driver_timestamp将与常规系统时间戳相同。

以下是使用HDAudio的时间戳示例：

1. 直接内存访问时间戳，没有补偿直接内存访问+模拟延迟
::

  $ ./audio_time  -p --ts_type=1
  播放: 系统时间: 341121338 纳秒, 音频时间 342000000 纳秒, 系统时间差 -878662
  播放: 系统时间: 426236663 纳秒, 音频时间 427187500 纳秒, 系统时间差 -950837
  播放: 系统时间: 597080580 纳秒, 音频时间 598000000 纳秒, 系统时间差 -919420
  播放: 系统时间: 682059782 纳秒, 音频时间 683020833 纳秒, 系统时间差 -961051
  播放: 系统时间: 852896415 纳秒, 音频时间 853854166 纳秒, 系统时间差 -957751
  播放: 系统时间: 937903344 纳秒, 音频时间 938854166 纳秒, 系统时间差 -950822

2. 直接内存访问时间戳，补偿直接内存访问+模拟延迟
::

  $ ./audio_time  -p --ts_type=1 -d
  播放: 系统时间: 341053347 纳秒, 音频时间 341062500 纳秒, 系统时间差 -9153
  播放: 系统时间: 426072447 纳秒, 音频时间 426062500 纳秒, 系统时间差 9947
  播放: 系统时间: 596899518 纳秒, 音频时间 596895833 纳秒, 系统时间差 3685
  播放: 系统时间: 681915317 纳秒, 音频时间 681916666 纳秒, 系统时间差 -1349
  播放: 系统时间: 852741306 纳秒, 音频时间 852750000 纳秒, 系统时间差 -8694

3. 链接时间戳，补偿直接内存访问+模拟延迟
::

  $ ./audio_time  -p --ts_type=2 -d
  播放: 系统时间: 341060004 纳秒, 音频时间 341062791 纳秒, 系统时间差 -2787
  播放: 系统时间: 426242074 纳秒, 音频时间 426244875 纳秒, 系统时间差 -2801
  播放: 系统时间: 597080992 纳秒, 音频时间 597084583 纳秒, 系统时间差 -3591
  播放: 系统时间: 682084512 纳秒, 音频时间 682088291 纳秒, 系统时间差 -3779
  播放: 系统时间: 852936229 纳秒, 音频时间 852940916 纳秒, 系统时间差 -4687
  播放: 系统时间: 938107562 纳秒, 音频时间 938112708 纳秒, 系统时间差 -5146

示例1表明，直接内存访问级别的时间戳比实际播放时间大约提前1毫秒（作为一种辅助时间，这种测量可以帮助定义回绕保护）。示例2中补偿直接内存访问-链路延迟有助于消除硬件缓冲，但信息仍然非常抖动，误差高达一个样本。在示例3中，使用链路系统时钟测量的时间戳显示出单调行为和较低的分散性。
示例3和4是基于USB音频类的。示例3显示音频时间和系统时间之间由于缓冲而产生的高偏移。示例4展示了补偿延迟如何暴露1毫秒的精度（由于驱动程序使用帧计数器）。

示例3：直接内存访问时间戳，没有补偿延迟，约5毫秒的差异
::

  $ ./audio_time -p -Dhw:1 -t1
  播放: 系统时间: 120174019 纳秒, 音频时间 125000000 纳秒, 系统时间差 -4825981
  播放: 系统时间: 245041136 纳秒, 音频时间 250000000 纳秒, 系统时间差 -4958864
  播放: 系统时间: 370106088 纳秒, 音频时间 375000000 纳秒, 系统时间差 -4893912
  播放: 系统时间: 495040065 纳秒, 音频时间 500000000 纳秒, 系统时间差 -4959935
  播放: 系统时间: 620038179 纳秒, 音频时间 625000000 纳秒, 系统时间差 -4961821
  播放: 系统时间: 745087741 纳秒, 音频时间 750000000 纳秒, 系统时间差 -4912259
  播放: 系统时间: 870037336 纳秒, 音频时间 875000000 纳秒, 系统时间差 -4962664

示例4：直接内存访问时间戳，补偿延迟，约1毫秒的延迟
::

  $ ./audio_time -p -Dhw:1 -t1 -d
  播放: 系统时间: 120190520 纳秒, 音频时间 120000000 纳秒, 系统时间差 190520
  播放: 系统时间: 245036740 纳秒, 音频时间 244000000 纳秒, 系统时间差 1036740
  播放: 系统时间: 370034081 纳秒, 音频时间 369000000 纳秒, 系统时间差 1034081
  播放: 系统时间: 495159907 纳秒, 音频时间 494000000 纳秒, 系统时间差 1159907
  播放: 系统时间: 620098824 纳秒, 音频时间 619000000 纳秒, 系统时间差 1098824
  播放: 系统时间: 745031847 纳秒, 音频时间 744000000 纳秒, 系统时间差 1031847
