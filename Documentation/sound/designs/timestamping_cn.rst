=====================
ALSA PCM 时间戳
=====================

ALSA API 可以提供两种不同的系统时间戳：

- `Trigger_tstamp` 是在调用 `.trigger` 回调时获取的系统时间快照。通常情况下，这个快照由 ALSA 核心获取，但特定硬件可能具有同步能力，或者相反地只能在延迟后提供准确估计。在后两种情况下，低级驱动程序负责在最适当和精确的时刻更新 `trigger_tstamp`。应用程序不应仅依赖于第一个 `trigger_tstamp`，而应在驱动程序延迟提供更精确估计时更新其内部计算。
- `tstamp` 是在上一个事件或应用程序查询期间更新的当前系统时间戳。
差值 (`tstamp - trigger_tstamp`) 定义了经过的时间。

ALSA API 提供了两个基本信息：`avail` 和 `delay`，结合 `trigger` 和当前系统时间戳，允许应用程序跟踪环形缓冲区的“满度”以及排队的样本数量。

这些不同指针和时间信息的使用取决于应用程序的需求：

- `avail` 报告可以在环形缓冲区中写入多少数据。
- `delay` 报告在所有排队的样本播放完毕后听到新样本所需的时间。

当启用时间戳时，`avail/delay` 信息会与系统时间快照一起报告。应用程序可以选择 `CLOCK_REALTIME`（包括回溯在内的 NTP 校正）、`CLOCK_MONOTONIC`（NTP 校正但不会回溯）、`CLOCK_MONOTIC_RAW`（无 NTP 校正），并通过 `sw_params` 动态更改模式。

ALSA API 还提供了一个 `audio_tstamp`，反映了音频硬件不同组件所测量的时间流逝。在 ASCII 图表示法下，这可以如下表示（对于播放情况）：
::

  --------------------------------------------------------------> 时间
    ^               ^              ^                ^           ^
    |               |              |                |           |
   模拟          链路            DMA              应用       全缓冲区
   时间          时间            时间              时间        时间
    |               |              |                |           |
    |< 编码延迟 >|<-- 硬件延迟 -->|< 排队样本 >|<--- 可用 ->|
    |<----------------- 延迟 ---------------------->|           |
                                   |<----- 环形缓冲区长度 ----->|

模拟时间是在播放的最后一阶段获取的，尽可能接近实际换能器。

链路时间是在 SoC/芯片组输出端获取的，因为样本被推送到链路上。如果硬件支持，链路时间可以直接通过样本计数器或墙钟测量（例如 HDAudio 的 24 MHz 或网络解决方案中的 PTP 时钟），或者间接估算（例如 USB 中的帧计数器）。
DMA 时间是通过计数器测量的——通常是所有测量中最不可靠的，因为 DMA 传输具有突发性。
应用时间对应于应用程序在写入环形缓冲区后的跟踪时间。

应用程序可以查询硬件功能，并通过选择 `audio_tstamp_config` 字段中的相关设置来定义要报告的音频时间，从而获得时间戳精度的估计。它还可以请求将延迟到模拟时间包含在测量中。直接访问链路时间在提供嵌入式 DSP 的平台上非常有趣；直接通过专用硬件测量链路时间，可能与系统时间同步，消除了跟踪内部 DSP 处理时间和延迟的需要。

如果应用程序请求的音频时间戳不受硬件/低级驱动程序支持，则类型会被重置为 `DEFAULT`，并且时间戳将基于 `hw_pointer` 值报告 DMA 时间。
为了与之前未提供时间戳选择功能的实现保持向后兼容性，当COMPAT时间戳类型值为零时，默认情况下播放流的结果将使用HDAudio的系统时钟，而在其他所有情况下将使用DMA时间（hw_ptr）。音频时间戳的精度可以返回给用户空间，以便做出适当的决策：

- 对于DMA时间（默认），可以通过更新之间的步长推断传输的粒度，并进而提供有关应用程序指针可以安全回绕多少的信息。
- 链接时间可用于通过(tstamp-trigger_tstamp)/audio_tstamp比率跟踪音频时间和系统时间之间的长期漂移。其精度有助于定义所需的平滑/低通滤波程度。链接时间可以在启动时重置或直接报告（后者有助于比较不同流的进度——但可能需要系统时钟始终运行且在空闲期间不回绕）。如果硬件支持，绝对链接时间也可以用于定义精确的开始时间（补丁正在进行中）。

- 包含音频时间戳中的延迟可能会出乎意料地不会增加时间戳的精度，例如，如果编解码器包含可变延迟的DSP处理或一系列硬件组件，则该延迟通常无法精确知道。
精度以纳秒单位报告（使用一个无符号32位字），这提供了最大4.29秒的精度，对于音频应用来说已经足够了。
由于时间戳需求的多样性，即使是单个应用程序，`audio_tstamp_config`也可以动态更改。在`STATUS` ioctl中，参数是只读的，不允许任何应用程序选择。为了避免影响遗留应用程序并解决这一限制，引入了一个新的`STATUS_EXT` ioctl，其中参数可读写。ALSA库将被修改以使用`STATUS_EXT`并实际上废弃`STATUS`。
ALSA API仅允许一次报告一个音频时间戳。这是一个有意识的设计决定，从硬件寄存器或IPC读取音频时间戳需要时间，读取的时间戳越多，组合测量结果越不精确。为了避免任何解释问题，报告一个（系统、音频）时间戳。需要不同时间戳的应用程序将被要求发出多次查询并对结果进行插值。

在某些特定硬件配置中，系统时间戳由低级音频子系统触发，并将信息反馈给驱动程序。由于与硬件通信的潜在延迟，存在与avail和delay信息错位的风险。为了确保应用程序不被混淆，在`snd_pcm_status`结构中添加了一个`driver_timestamp`字段；此时间戳显示信息由驱动程序整理的时间，然后从`STATUS`和`STATUS_EXT` ioctl返回。大多数情况下，此`driver_timestamp`将与常规系统时间戳相同。

以下是HDAudio时间戳的一些示例：

1. DMA时间戳，不补偿DMA+模拟延迟
```
$ ./audio_time -p --ts_type=1
播放：系统时间：341121338纳秒，音频时间：342000000纳秒，系统时间差值：-878662
播放：系统时间：426236663纳秒，音频时间：427187500纳秒，系统时间差值：-950837
播放：系统时间：597080580纳秒，音频时间：598000000纳秒，系统时间差值：-919420
播放：系统时间：682059782纳秒，音频时间：683020833纳秒，系统时间差值：-961051
播放：系统时间：852896415纳秒，音频时间：853854166纳秒，系统时间差值：-957751
播放：系统时间：937903344纳秒，音频时间：938854166纳秒，系统时间差值：-950822
```

2. DMA时间戳，补偿DMA+模拟延迟
```
$ ./audio_time -p --ts_type=1 -d
播放：系统时间：341053347纳秒，音频时间：341062500纳秒，系统时间差值：-9153
播放：系统时间：426072447纳秒，音频时间：426062500纳秒，系统时间差值：9947
播放：系统时间：596899518纳秒，音频时间：596895833纳秒，系统时间差值：3685
播放：系统时间：681915317纳秒，音频时间：681916666纳秒，系统时间差值：-1349
播放：系统时间：852741306纳秒，音频时间：852750000纳秒，系统时间差值：-8694
```

3. 链接时间戳，补偿DMA+模拟延迟
```
$ ./audio_time -p --ts_type=2 -d
播放：系统时间：341060004纳秒，音频时间：341062791纳秒，系统时间差值：-2787
播放：系统时间：426242074纳秒，音频时间：426244875纳秒，系统时间差值：-2801
播放：系统时间：597080992纳秒，音频时间：597084583纳秒，系统时间差值：-3591
播放：系统时间：682084512纳秒，音频时间：682088291纳秒，系统时间差值：-3779
播放：系统时间：852936229纳秒，音频时间：852940916纳秒，系统时间差值：-4687
播放：系统时间：938107562纳秒，音频时间：938112708纳秒，系统时间差值：-5146
```

示例1显示DMA级别的时间戳比实际播放时间提前近1毫秒（作为附带时间，此类测量有助于定义回绕保护）。示例2中补偿DMA-链路延迟有助于消除硬件缓冲区，但信息仍然非常抖动，最多有一个采样的误差。示例3中使用链接时钟测量时间戳，显示出单调行为和较低的分散性。
示例3和4是USB音频类的情况。示例3显示音频时间和系统时间之间由于缓冲而存在高偏移。示例4显示补偿延迟后暴露1毫秒精度（由于驱动程序使用帧计数器）。

示例3：DMA时间戳，不补偿延迟，约5毫秒的差值
```
$ ./audio_time -p -Dhw:1 -t1
播放：系统时间：120174019纳秒，音频时间：125000000纳秒，系统时间差值：-4825981
播放：系统时间：245041136纳秒，音频时间：250000000纳秒，系统时间差值：-4958864
播放：系统时间：370106088纳秒，音频时间：375000000纳秒，系统时间差值：-4893912
播放：系统时间：495040065纳秒，音频时间：500000000纳秒，系统时间差值：-4959935
播放：系统时间：620038179纳秒，音频时间：625000000纳秒，系统时间差值：-4961821
播放：系统时间：745087741纳秒，音频时间：750000000纳秒，系统时间差值：-4912259
播放：系统时间：870037336纳秒，音频时间：875000000纳秒，系统时间差值：-4962664
```

示例4：DMA时间戳，补偿延迟，约1毫秒的延迟
```
$ ./audio_time -p -Dhw:1 -t1 -d
播放：系统时间：120190520纳秒，音频时间：120000000纳秒，系统时间差值：190520
播放：系统时间：245036740纳秒，音频时间：244000000纳秒，系统时间差值：1036740
播放：系统时间：370034081纳秒，音频时间：369000000纳秒，系统时间差值：1034081
播放：系统时间：495159907纳秒，音频时间：494000000纳秒，系统时间差值：1159907
播放：系统时间：620098824纳秒，音频时间：619000000纳秒，系统时间差值：1098824
播放：系统时间：745031847纳秒，音频时间：744000000纳秒，系统时间差值：1031847
```
