===============================
IEEE 802.15.4 开发者指南
===============================

简介
============
IEEE 802.15.4 工作组主要关注于标准制定的最底层两个部分：介质访问控制（MAC）层和物理层（PHY）。对于上层协议，主要有两种选择：

- ZigBee —— 来自ZigBee联盟的专有协议
- 6LoWPAN —— 在低速个人区域网络上运行IPv6网络

Linux-wpan的目标是提供IEEE 802.15.4 和 6LoWPAN协议的完整实现。IEEE 802.15.4 是一种用于组织低速率无线个人区域网络的协议栈，该协议栈主要由以下三个部分组成：

- IEEE 802.15.4 层；我们选择了使用纯Berkeley套接字API以及通用的Linux网络栈来传输IEEE 802.15.4数据消息，并通过netlink的一个特殊协议来进行配置/管理。
- MAC —— 提供对共享信道的访问和可靠的数据传输
- PHY —— 表示设备驱动程序

套接字API
==========

::
    
    int sd = socket(PF_IEEE802154, SOCK_DGRAM, 0);

地址族、套接字地址等定义在头文件 `include/net/af_ieee802154.h` 中，或者在用户空间包中的特殊头文件中（参见 https://linux-wpan.org/wpan-tools.html 或 https://github.com/linux-wpan/wpan-tools 的git仓库）。

6LoWPAN的Linux实现
============================

IEEE 802.15.4 标准规定最大传输单元（MTU）为127字节，在启用了安全功能的情况下，无线链路上的实际MAC负载大约为80字节，链接吞吐量不超过250 kbps。[RFC4944] 定义了将IPv6数据报通过此类受限链接传输的6LoWPAN适配格式，考虑到了无线传感器网络等应用中预期的有限带宽、内存或能源资源。[RFC4944] 定义了一个网格寻址头以支持子IP转发、一个分段头以支持IPv6最小MTU要求[RFC2460]，以及IPv6数据报的无状态头部压缩（LOWPAN_HC1 和 LOWPAN_HC2），这可以将相对较大的IPv6和UDP头部压缩到（在最佳情况下）几个字节。

2011年9月，标准更新[RFC6282]发布。它废弃了HC1和HC2压缩，并定义了IPHC编码格式，这一格式被本Linux实现所采用。

所有与6lowpan相关的代码可以在文件 `net/6lowpan/*` 和 `net/ieee802154/6lowpan/*` 中找到。

要设置6LoWPAN接口，您需要：
1. 添加IEEE802.15.4接口并设置频道和PAN ID；
2. 通过命令添加6lowpan接口，例如：
# ip link add link wpan0 name lowpan0 type lowpan
3. 启用'lowpan0'接口

驱动程序
=======

如同Wi-Fi一样，存在几种实施IEEE 802.15.4的不同类型的设备：
1) 'HardMAC'。MAC层在设备内部实现，设备提供了一个管理（例如MLME）和数据API。
2) 'SoftMAC' 或仅是无线电。这类设备只是无线电收发器，可能具有一些加速功能，如自动CRC计算和比较、自动ACK处理、地址匹配等。

不同类型的设备需要不同的方法来集成到Linux内核中。

HardMAC
-------

请参考头文件 `include/net/ieee802154_netdev.h`。您需要实现Linux的 `net_device`，其中 `.type = ARPHRD_IEEE802154`。数据通过普通的 `sk_buff` 与套接字家族代码交换。在接收 `skb` 时，`skb->cb` 必须包含额外的信息，如 `struct ieee802154_mac_cb` 所描述。在数据包传输过程中，`skb->cb` 用于向设备的 `header_ops->create` 函数提供额外的数据。请注意，这些数据可能会被覆盖（当套接字代码将 `skb` 提交给qdisc时），因此如果您稍后需要从该 `cb` 获取信息，请自行将其存储在 `skb->data` 中。
为了挂钩MLME接口，你必须用指向`struct ieee802154_mlme_ops`实例的指针填充你的`net_device`中的`ml_priv`字段。`assoc_req`、`assoc_resp`、`disassoc_req`、`start_req`和`scan_req`字段是可选的。所有其他字段都是必需的。

软MAC
------

MAC是IEEE 802.15.4 Linux堆栈中的中间层。目前，它提供了驱动程序注册接口和从属接口管理功能。
注意：目前仅支持监视器设备类型——它是用于网络嗅探器（例如WireShark）的IEEE 802.15.4堆栈接口。
这一层将很快得到扩展。
参见头文件`include/net/mac802154.h`以及`drivers/net/ieee802154/`目录下的几个驱动程序。

假驱动程序
------------

此外，还提供了一个带有软MAC（fakelb-IEEE 802.15.4回环驱动程序）接口的模拟真实设备的驱动程序。此选项提供了在不使用实际硬件的情况下测试和调试堆栈的可能性。

设备驱动程序API
==================

`include/net/mac802154.h`定义了以下函数：

.. c:function:: struct ieee802154_dev *ieee802154_alloc_device(size_t priv_size, struct ieee802154_ops *ops)

分配IEEE 802.15.4兼容设备
.. c:function:: void ieee802154_free_device(struct ieee802154_dev *dev)

释放已分配的设备
.. c:function:: int ieee802154_register_device(struct ieee802154_dev *dev)

在系统中注册PHY设备
以下是您提供的文档的中文翻译：

```c
// c:function:: void ieee802154_unregister_device(struct ieee802154_dev *dev)
// 释放已注册的PHY设备
.. c:function:: void ieee802154_unregister_device(struct ieee802154_dev *dev)

// c:function:: void ieee802154_rx_irqsafe(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
// 告知802.15.4模块有一个新的接收帧skb，其中包含来自硬件设备的射频链路质量指示器（LQI）
.. c:function:: void ieee802154_rx_irqsafe(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)

// c:function:: void ieee802154_xmit_complete(struct ieee802154_hw *hw, struct sk_buff *skb, bool ifs_handling)
// 告知802.15.4模块skb中的帧已经被或即将通过硬件设备传输
.. c:function:: void ieee802154_xmit_complete(struct ieee802154_hw *hw, struct sk_buff *skb, bool ifs_handling)

设备驱动程序必须至少实现以下IEEE 802.15.4操作结构中的回调函数：

```c
struct ieee802154_ops {
        ..
        int     (*start)(struct ieee802154_hw *hw); // 开始处理
        void    (*stop)(struct ieee802154_hw *hw); // 结束处理
        ..
        int     (*xmit_async)(struct ieee802154_hw *hw, struct sk_buff *skb); // 异步发送处理
        int     (*ed)(struct ieee802154_hw *hw, u8 *level); // 能量检测处理
        int     (*set_channel)(struct ieee802154_hw *hw, u8 page, u8 channel); // 设置信道处理
        ..
};
```

// c:function:: int start(struct ieee802154_hw *hw)
// 802.15.4模块调用此处理器来初始化硬件设备
.. c:function:: int start(struct ieee802154_hw *hw)

// c:function:: void stop(struct ieee802154_hw *hw)
// 802.15.4模块调用此处理器来清理硬件设备
.. c:function:: void stop(struct ieee802154_hw *hw)

// c:function:: int xmit_async(struct ieee802154_hw *hw, struct sk_buff *skb)
// 802.15.4模块为skb中将要通过硬件设备传输的每个帧调用此处理器
.. c:function:: int xmit_async(struct ieee802154_hw *hw, struct sk_buff *skb)

// c:function:: int ed(struct ieee802154_hw *hw, u8 *level)
// 802.15.4模块调用此处理器从硬件设备进行能量检测
.. c:function:: int ed(struct ieee802154_hw *hw, u8 *level)

// c:function:: int set_channel(struct ieee802154_hw *hw, u8 page, u8 channel)
// 设置硬件设备在特定信道上监听
.. c:function:: int set_channel(struct ieee802154_hw *hw, u8 page, u8 channel)
```
此外，应该填充IEEE 802.15.4设备的操作结构。

这句话的意思是，在进行相关的设置或编程时，需要完整地定义或配置IEEE 802.15.4设备（这是一种无线通信标准，常用于低速无线个人区域网络）的运行结构或参数。这可能包括设备的启动流程、数据传输协议、错误处理机制等具体操作细节。
