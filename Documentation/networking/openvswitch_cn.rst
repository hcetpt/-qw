SPDX 许可证标识符: GPL-2.0

=============================================
Open vSwitch 数据路径开发者文档
=============================================

Open vSwitch 内核模块允许用户空间对选定网络设备上的流级别数据包处理进行灵活控制。它可以用来实现简单的以太网交换机、网络设备绑定、VLAN 处理、网络访问控制、基于流的网络控制等。
该内核模块实现了多个“数据路径”（类似于桥接器），每个数据路径可以有多个“vport”（类似于桥接器中的端口）。每个数据路径还关联有一个“流表”，用户空间会用“流”填充该表，这些流将基于数据包头和元数据的键映射到一组动作。最常见的动作为将数据包转发到另一个 vport；其他动作也已实现。
当一个数据包到达某个 vport 时，内核模块通过提取其流键并在流表中查找来进行处理。如果找到匹配的流，则执行关联的动作。如果没有匹配项，则将数据包排队给用户空间处理（作为处理的一部分，用户空间可能会设置一个流，以便在内核中完全处理后续相同类型的包）。

流键兼容性
----------------------

网络协议随着时间发展。新的协议变得重要，而现有的协议可能失去其地位。为了使 Open vSwitch 内核模块保持相关性，必须能够解析作为流键一部分的新协议。甚至有可能在未来不再支持解析那些已过时的协议。因此，Open vSwitch 的 Netlink 接口被设计成允许精心编写的用户空间应用程序与任何版本的流键一起工作。
为了支持这种前向和后向兼容性，每当内核模块将一个数据包传递给用户空间时，它还会将从该数据包解析出的流键一并传递。然后用户空间从中提取自己的流键概念，并将其与内核提供的版本进行比较：

- 如果用户空间对数据包的流键概念与内核的一致，那么无需特殊操作。
- 如果内核的流键包含比用户空间版本更多的字段（例如，内核解码了 IPv6 头，但用户空间仅止于以太网类型，因为它不理解 IPv6），那么仍然不需要特殊操作。只要使用内核提供的流键，用户空间仍可以按常规方式设置流。
- 如果用户空间的流键包含比内核更多的字段（例如，用户空间解码了 IPv6 头，但内核仅止于以太网类型），则用户空间可以手动转发该数据包，而不必在内核中设置流。这种情况不利于性能，因为内核认为属于该流的所有数据包都必须去用户空间，但转发行为是正确的。（如果用户空间确定额外字段的值不会影响转发行为，那么它仍然可以设置流。）

流键随时间如何演变对于使这一切工作起来至关重要，因此以下部分会详细介绍。

流键格式
---------------

流键通过 Netlink 套接字作为一系列 Netlink 属性传递。一些属性代表数据包元数据，定义为无法从数据包本身提取的关于数据包的信息，例如接收数据包的 vport。然而，大多数属性是从数据包内的头部提取的，例如来自以太网、IP 或 TCP 头部的源地址和目的地址。
<linux/openvswitch.h> 头文件定义了流键属性的确切格式。为便于非正式解释，在这里我们将它们写成逗号分隔的字符串，括号表示参数和嵌套。例如，以下可以表示一个到达 vport 1 的 TCP 数据包对应的流键：

    in_port(1), eth(src=e0:91:f5:21:d0:b2, dst=00:02:e3:0f:80:a4),
    eth_type(0x0800), ipv4(src=172.16.0.20, dst=172.18.0.52, proto=17, tos=0,
    frag=no), tcp(src=49163, dst=80)

通常我们会省略不重要的参数，例如：

    in_port(1), eth(...), eth_type(0x0800), ipv4(...), tcp(...)

通配符流键格式
--------------------------

一个通配符流由通过 Netlink 套接字传递的两组 Netlink 属性描述。一个流键，正如上面所描述的，以及一个可选的对应流掩码。
一个通配符流可以代表一组精确匹配流。掩码中的每个‘1’位指定与流键中相应位的精确匹配。
一个‘0’位表示一个无关位，它将匹配传入数据包中的‘1’或‘0’位。使用通配符流可以提高流设置速率，通过减少用户空间程序需要处理的新流的数量。对于内核和用户空间程序来说，支持掩码Netlink属性是可选的。内核可以忽略掩码属性，安装精确匹配流，或者在内核中减少无关位的数量，使其少于用户空间程序指定的数量。在这种情况下，内核未实现的位的变化将简单地导致更多的流设置。内核模块还可以与既不支持也不提供流掩码属性的用户空间程序一起工作。

由于内核可能会忽略或修改通配符位，因此用户空间程序很难确切知道已安装的匹配规则。有两种可能的方法：一是当数据包未命中内核流表时反应式地安装流（因此完全不尝试确定通配符的变化）；二是利用内核的响应消息来确定已安装的通配符。

在与用户空间交互时，内核应保持键的匹配部分与最初安装时完全一致。这将为所有后续操作提供一个标识符。然而，在报告已安装流的掩码时，掩码应包括内核施加的任何限制。

使用重叠的通配符流的行为是未定义的。确保任何传入的数据包最多只能匹配一个流（无论是带通配符的还是不带通配符的）是用户空间程序的责任。当前实现尽力检测重叠的通配符流，并可能会拒绝某些但不是全部的流。但是，这种行为在未来版本中可能会改变。

唯一流标识符
--------------

除了使用键的原始匹配部分作为流标识符之外，另一种选择是使用唯一流标识符（UFID）。UFID对于内核和用户空间程序都是可选的。

支持UFID的用户空间程序预计会在流设置期间提供UFID，并在后续的所有操作中使用UFID引用该流。如果指定了UFID，内核不需要按原始流键对流进行索引。

演进流键的基本规则
-------------------

为了真正维护应用程序的前向和后向兼容性，需要遵循“流键兼容性”部分列出的规则。

基本规则显而易见：

    ==================================================================
    新的网络协议支持只能补充现有的流键属性。不得更改已定义的流键属性的意义。
这条规则确实有一些不那么明显的后果，因此值得通过一些例子来说明。例如，假设内核模块尚未实现VLAN解析功能。相反，它只是将802.1Q的TPID（0x8100）解释为以太网类型，然后停止解析数据包。任何带有802.1Q头部的数据包的流键将基本上是这样的，忽略元数据：

    eth(...), eth_type(0x8100)

天真地认为，为了添加VLAN支持，合理的方法是在流键中添加一个新的“vlan”属性来包含VLAN标签，然后继续使用现有的字段定义解码VLAN标签之后的封装报头。有了这个更改后，VLAN 10中的TCP数据包将具有如下类似的流键：

    eth(...), vlan(vid=10, pcp=0), eth_type(0x0800), ip(proto=6, ...), tcp(...)

但是这种更改会对未更新以理解新的“vlan”流键属性的用户空间应用程序产生负面影响。根据上述流兼容性规则，应用程序可以忽略它不理解的“vlan”属性，并因此假定该流包含IP数据包。这是一个错误的假设（只有解析并跳过802.1Q头部时该流才包含IP数据包），这可能会导致应用程序的行为在不同内核版本之间发生变化，即使它遵循了兼容性规则。解决方法是使用嵌套属性。这就是为什么802.1Q支持使用嵌套属性的原因。VLAN 10中的TCP数据包实际上是这样表示的：

    eth(...), eth_type(0x8100), vlan(vid=10, pcp=0), encap(eth_type(0x0800), ip(proto=6, ...), tcp(...))

请注意，“eth_type”，“ip”和“tcp”流键属性是如何嵌套在“encap”属性之内的。因此，不理解“vlan”键的应用程序将看不到这些属性，从而不会误解它们。（此外，外部的eth_type仍然是0x8100，而不是改为0x0800。）

处理畸形数据包
-----------------

不要在内核中因协议头错误、校验和错误等而丢弃数据包。这样做会阻止用户空间实现一个简单的转发所有数据包的以太网交换机。相反，在这种情况下，应包含一个内容为空的属性。如果这些空内容在实际中很少出现，那是否可能是有效的协议值并不重要，因为用户空间可以总是将所有这些值的数据包转发到用户空间并单独处理它们。例如，考虑一个包含IP头的数据包，该IP头指示协议6（即TCP），但被截断在IP头之后，因此缺少TCP头。该数据包的流键将包含一个源端口和目的端口均为零的tcp属性，如下所示：

    eth(...), eth_type(0x0800), ip(proto=6, ...), tcp(src=0, dst=0)

作为另一个例子，考虑一个以太网类型为0x8100的数据包，表明应该跟随一个VLAN TCI，但它在以太网类型之后被截断。该数据包的流键将包含一个全零位的vlan属性和一个空的encap属性，如下所示：

    eth(...), eth_type(0x8100), vlan(0), encap()

与源端口和目的端口均为0的TCP数据包不同，全零位的VLAN TCI并不是那么罕见，因此通常在vlan属性中设置CFI位（即内核中的VLAN_TAG_PRESENT），以明确区分这种情况。因此，第二个示例中的流键明确地表明缺少或畸形的VLAN TCI。

其他规则
---------

流键的其他规则要微妙得多：

- 不允许在同一嵌套级别中存在重复的属性。
- 属性的顺序并不重要。
- 当内核向用户空间发送给定的流键时，它总是以相同的方式组成。这允许用户空间哈希并比较整个流键，即使它可能无法完全解释这些流键。
当然，请提供您需要翻译的文本。
