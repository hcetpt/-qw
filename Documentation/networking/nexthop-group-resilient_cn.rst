SPDX 许可证标识符: GPL-2.0

=========================
弹性下一跳组
=========================

弹性组是一种下一跳组，旨在最小化因组成员构成和权重变化而导致的流量路由中断。弹性哈希组的概念最好通过与传统的多路径下一跳组进行对比来解释，后者使用了RFC 2992中描述的哈希阈值算法。

为了选择一个下一跳，哈希阈值算法首先为组中的每个下一跳分配一段哈希范围，然后通过比较SKB哈希值与各个范围来选择下一跳。当从组中移除一个下一跳时，这些范围会被重新计算，导致一部分哈希空间从一个下一跳重新分配给另一个下一跳。RFC 2992 如此说明：

```
             +-------+-------+-------+-------+-------+
             |   1   |   2   |   3   |   4   |   5   |
             +-------+-+-----+---+---+-----+-+-------+
             |    1    |    2    |    4    |    5    |
             +---------+---------+---------+---------+
```

删除下一跳3前后的哈希阈值算法示意图
注意下一跳2放弃了一部分哈希空间给下一跳1，以及4放弃了一部分给5。虽然新旧分布之间通常会有一些重叠，但部分流量流会改变它们对应的下一跳。

如果多路径组用于在多个服务器之间负载均衡，这种哈希空间重新分配会导致一个问题：来自单一流量流的数据包突然到达一个没有预期到这些数据包的服务器。这可能导致TCP连接被重置。
如果多路径组用于在到达同一服务器的不同路径之间进行负载均衡，问题在于不同路径上的延迟和重新排序会导致数据包到达顺序错误，从而导致应用程序性能下降。

为了缓解上述流量重定向问题，弹性下一跳组在哈希空间与其成员下一跳之间插入了一层间接层：哈希表。选择算法使用SKB哈希来选择一个哈希表槽位，然后读取该槽位包含的下一跳，并将流量转发到那里。

这种间接性带来了一个重要的特性。在哈希阈值算法中，与一个下一跳关联的哈希范围必须是连续的。而在哈希表中，哈希表槽位与个别下一跳之间的映射关系可以是任意的。因此，当一个下一跳被删除时，该下一跳所在的槽位可以直接重新分配给其他下一跳：

```
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |1|1|1|1|2|2|2|2|3|3|3|3|4|4|4|4|5|5|5|5|
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	                     v v v v
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |1|1|1|1|2|2|2|2|1|2|4|5|4|4|4|4|5|5|5|5|
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

删除下一跳3前后的弹性哈希算法示意图

当组内的下一跳权重发生变化时，可能可以选择当前未用于转发流量的一组槽位来满足新的下一跳分布需求，同时保持“繁忙”的槽位不变。这样，已建立的流量理想情况下仍然通过相同的路径转发到相同的端点，就像下一跳组变更之前一样。

算法
----

简而言之，算法的工作原理如下。每个下一跳根据其权重和哈希表中的槽位数量应获得一定数量的槽位。按照源代码，我们将这个数量称为下一跳的“期望计数”。在可能发生导致槽位分配变化的事件时，更新各个下一跳的期望计数。
下一跳（next hop）如果其桶（bucket）的数量少于所需数量，则被称为“欠重（underweight）”。如果其桶的数量多于所需数量，则被称为“超重（overweight）”。如果一组中没有超重的下一跳（因此也没有欠重的下一跳），则该组被认为是“平衡（balanced）”的。

每个桶都维护一个最后使用计时器。每当有数据包通过某个桶转发时，这个计时器会被更新为当前的时间戳值。一个弹性组的属性之一是“空闲计时器”，它是指一个桶必须在不被任何流量命中之前的时间长度，以便被视为“空闲”。未处于空闲状态的桶被认为是繁忙的。

在给下一跳分配所需数量之后，会运行一个“维护（upkeep）”算法。对于以下情况：

1. 没有分配下一跳的桶，
2. 其下一跳已被移除的桶，
3. 空闲且其下一跳为超重的桶，

维护过程会将这些桶引用的下一跳更改为一个欠重的下一跳。如果按照这种方式考虑所有桶后，仍然存在欠重的下一跳，则会安排另一个维护运行以在未来某个时间执行。

可能没有足够的“空闲”桶来满足所有下一跳更新后的所需数量。弹性组的另一个属性是“不平衡计时器”。这个计时器可以设置为0，在这种情况下，表将一直处于不平衡状态，直到出现空闲桶，这可能是永远不会发生的。如果设置为非零值，则该值表示表允许保持不平衡状态的时间长度。

考虑到这一点，我们更新上述条件列表，增加一项。因此，对于以下情况的桶：

4. 其下一跳为超重，并且表处于不平衡状态的时间超过了不平衡计时器（如果该计时器非零），

……这些桶也会被迁移。

卸载与驱动反馈
-------------------

当卸载弹性组时，将桶分配给下一跳的算法仍然是在软件（SW）中实现的。驱动程序通过以下三种方式接收关于下一跳组更新的通知：

- 使用类型为`NH_NOTIFIER_INFO_TYPE_RES_TABLE`的完整组通知。这通常在组创建并首次填充桶后使用。
- 使用类型为`NH_NOTIFIER_INFO_TYPE_RES_BUCKET`的单个桶通知，用于已经建立的组内个别迁移的通知。
- 预替换通知，类型为`NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE`。这在组替换前发送，是一种让驱动程序在向硬件提交任何更改之前否决组的方式。

某些单个桶的通知是强制性的，如通知中的“强制”标志所示。这些用于处理例如与桶关联的下一跳被移除的情况，此时桶确实需要被迁移。

非强制性通知可以通过返回错误代码由驱动程序覆盖。这种情况的一个用例是，驱动程序通知硬件某个桶应该被迁移，但硬件发现该桶实际上已经被流量命中。
硬件（HW）报告某个桶处于忙碌状态的第二种方式是通过 `nexthop_res_grp_activity_update()` API。以这种方式标识为忙碌的桶将被视为有流量命中。

卸载的桶应标记为“offload”或“trap”。这是通过 `nexthop_bucket_set_hw_flags()` API 完成的。

Netlink 用户空间API
-------------------

### 弹性组替换
^^^^^^^^^^^^^^^^^^^^^^^^^^^

弹性组使用与配置其他多路径组相同的 `RTM_NEWNEXTHOP` 消息进行配置。以下是对netlink消息中传递属性的更改：

  =================== =========================================================
  ``NHA_GROUP_TYPE``  对于弹性组，应设置为 `NEXTHOP_GRP_TYPE_RES`
  ``NHA_RES_GROUP``   包含特定于弹性组属性的嵌套结构
  =================== =========================================================

``NHA_RES_GROUP`` 的有效负载：

  =================================== =========================================
  ``NHA_RES_GROUP_BUCKETS``           散列表中的桶数量
  ``NHA_RES_GROUP_IDLE_TIMER``        闲置定时器，以clock_t单位计
  ``NHA_RES_GROUP_UNBALANCED_TIMER``  不平衡定时器，以clock_t单位计
  =================================== =========================================

### 下一跳获取
^^^^^^^^^^^^

请求获取弹性下一跳组时使用 `RTM_GETNEXTHOP` 消息，与其它下一跳获取请求完全相同。响应属性与上述替换属性匹配，不同之处在于 ``NHA_RES_GROUP`` 的有效负载将包含以下属性：

  =================================== =========================================
  ``NHA_RES_GROUP_UNBALANCED_TIME``   弹性组失去平衡的时间长度，以clock_t单位计
  =================================== =========================================

### 桶获取
^^^^^^^^^^

不带 `NLM_F_DUMP` 标志的 `RTM_GETNEXTHOPBUCKET` 消息用于请求单个桶。在获取请求中识别的属性包括：

  =================== =========================================================
  ``NHA_ID``          桶所属的下一跳组ID
  ``NHA_RES_BUCKET``  包含特定于桶属性的嵌套结构
  =================== =========================================================
``NHA_RES_BUCKET`` 负载：

  ======================== ====================================================
  ``NHA_RES_BUCKET_INDEX`` 持久化表中的桶索引
  ======================== ====================================================

桶转储
^^^^^^^^^^^^

消息 ``RTM_GETNEXTHOPBUCKET`` 与 ``NLM_F_DUMP`` 标志一起使用，用于请求匹配的桶的转储。在转储请求中识别的属性包括：

  =================== =========================================================
  ``NHA_ID``          如果指定，则将转储限制为仅包含具有此ID的下一跳组
  ``NHA_OIF``         如果指定，则将转储限制为仅包含使用具有此ifindex设备的下一跳的桶
  ``NHA_MASTER``      如果指定，则将转储限制为仅包含使用具有此ifindex设备所在VRF的下一跳的桶
  ``NHA_RES_BUCKET``  包含特定于桶的属性的嵌套结构
  =================== =========================================================

``NHA_RES_BUCKET`` 负载：

  ======================== ====================================================
  ``NHA_RES_BUCKET_NH_ID`` 如果指定，则将转储限制为仅包含具有此ID的下一跳的桶
  ======================== ====================================================

用法
-----

为了说明其用法，考虑以下命令：

```
# ip nexthop add id 1 via 192.0.2.2 dev eth0
# ip nexthop add id 2 via 192.0.2.3 dev eth0
# ip nexthop add id 10 group 1/2 type resilient \
    buckets 8 idle_timer 60 unbalanced_timer 300
```

最后一个命令创建了一个持久化的下一跳组。它将有8个桶（这个数目非常少，这里仅用于演示目的），每个桶在至少60秒内没有流量时将被视为闲置，并且如果该表在300秒内保持不平衡状态，将会强制使其平衡。
更改下一跳权重会导致桶分配的变化：

```
# ip nexthop replace id 10 group 1,3/2 type resilient
```

这可以通过查看单个桶来验证：

```
# ip nexthop bucket show id 10
id 10 index 0 idle_time 5.59 nhid 1
id 10 index 1 idle_time 5.59 nhid 1
id 10 index 2 idle_time 8.74 nhid 2
id 10 index 3 idle_time 8.74 nhid 2
id 10 index 4 idle_time 8.74 nhid 1
id 10 index 5 idle_time 8.74 nhid 1
id 10 index 6 idle_time 8.74 nhid 1
id 10 index 7 idle_time 8.74 nhid 1
```

请注意，有两个桶的空闲时间较短。这些是在执行下一跳替换命令后迁移的桶，以满足新的需求，即下一跳1应该有6个桶而不是4个。

Netdevsim
---------

Netdevsim驱动实现了一个模拟的持久化组卸载，并提供了一个debugfs接口，允许标记单个桶为忙碌状态。例如，以下命令会将下一跳组10中的桶23标记为活跃：

```
# echo 10 23 > /sys/kernel/debug/netdevsim/netdevsim10/fib/nexthop_bucket_activity
```

此外，另一个debugfs接口可用于配置，使下次尝试迁移一个桶时失败：

```
# echo 1 > /sys/kernel/debug/netdevsim/netdevsim10/fib/fail_nexthop_bucket_replace
```

除了作为示例之外，netdevsim暴露的接口对于自动化测试也很有用，并且`tools/testing/selftests/drivers/net/netdevsim/nexthop.sh`利用它们来测试算法。
当然，请提供您需要翻译的文本。
