SPDX 许可证标识符: GPL-2.0

=========================
弹性下一跳组
=========================

弹性组是一种下一跳组类型，旨在最小化因组构成变化和成员下一跳权重变动而引起的流量路由中断。
弹性哈希组的概念最好通过与传统多路径下一跳组的对比来解释，后者使用了RFC 2992中描述的哈希阈值算法。
为了选择一个下一跳，哈希阈值算法首先为组中的每个下一跳分配一段哈希值范围，然后通过比较SKB哈希值与各个范围来选定下一跳。当从组中移除一个下一跳时，这些范围将被重新计算，从而导致一部分哈希空间从一个下一跳重分配给另一个。RFC 2992中这样说明该过程：

             +-------+-------+-------+-------+-------+
             |   1   |   2   |   3   |   4   |   5   |
             +-------+-+-----+---+---+-----+-+-------+
             |    1    |    2    |    4    |    5    |
             +---------+---------+---------+---------+

              哈希阈值算法下删除第三下一跳前后的变化
注意下一跳2放弃了一部分哈希空间，分别给了下一跳1和下一跳5。虽然通常新旧分布之间会有一些重叠，但某些流量流的下一跳发生了改变。
如果多路径组用于在多个服务器间负载均衡，则这种哈希空间重分配会导致一个问题：来自单一流量流的数据包突然到达了一个未曾预料的服务器上。这可能导致TCP连接被重置。
如果多路径组用于在到同一服务器的不同路径间进行负载均衡，则问题在于不同路径上的延迟差异和数据包重排序导致数据包以错误的顺序到达，从而影响应用性能。

为了缓解上述流量重定向问题，弹性下一跳组在哈希空间与其成员下一跳之间插入了另一层间接映射：哈希表。选择算法使用SKB哈希值来选择哈希表中的一个槽（bucket），然后读取该槽所包含的下一跳，并将流量转发到那里。
这一间接映射带来了重要特性。在哈希阈值算法中，与下一跳关联的哈希值范围必须是连续的。而使用哈希表时，哈希表槽与各个下一跳之间的映射可以任意设置。因此，当删除一个下一跳时，原本指向它的槽可以简单地重新分配给其他下一跳：

	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |1|1|1|1|2|2|2|2|3|3|3|3|4|4|4|4|5|5|5|5|
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	                     v v v v
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |1|1|1|1|2|2|2|2|1|2|4|5|4|4|4|4|5|5|5|5|
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	    弹性哈希算法下删除第三下一跳前后的变化
当组内下一跳的权重发生变化时，可能能够选择当前未用于转发流量的一组槽，并用它们满足新的下一跳分布需求，同时保持“繁忙”的槽不变。这样，已建立的流量理想情况下仍然通过相同的路径转发到相同的终点，就像下一跳组变更之前一样。

算法
---------
简而言之，算法的工作原理如下。根据其权重和哈希表中槽的数量，每个下一跳应获得一定数量的槽。按照源代码的说法，我们将这个数量称为下一跳的“需求计数”。在可能引起槽分配变化的事件发生时，需要更新各个下一跳的需求计数。
具有少于所需数量桶的下一跳被称为“不足”。那些具有更多桶的则称为“过量”。如果组中没有过量的（因此也没有不足的）下一跳，则称该组为“平衡”。

每个桶维护一个最后使用计时器。每当通过一个桶转发数据包时，此计时器将更新为当前的时间值。一个有弹性的组的一个属性是“空闲计时器”，即一个桶在被认为是“空闲”之前必须不被流量命中的一段时间。不是空闲状态的桶则是繁忙状态。

在给下一跳分配所需数量后，运行一个“维护”算法。对于以下情况的桶：

1) 没有分配下一跳的，
2) 其下一跳已被移除的，
3) 处于空闲状态且其下一跳为过量的，

维护会将该桶所引用的下一跳更改为不足的下一跳之一。如果以这种方式考虑所有桶之后仍有不足的下一跳，则计划在未来某个时间再进行一次维护运行。
可能没有足够的“空闲”桶来满足所有下一跳更新后的所需数量。有弹性的组的另一个属性是“不平衡计时器”。此计时器可以设置为0，在这种情况下，表将保持不平衡状态直到出现空闲桶，这可能永远不会发生。如果设置为非零值，则该值代表表允许保持不平衡状态的时间段。

考虑到这一点，我们在上面的条件列表中增加了一项。因此，对于桶：

4) 其下一跳为过量的，并且表处于不平衡状态的时间超过了不平衡计时器（如果该计时器非零），

... 这些桶也将被迁移。

卸载与驱动反馈
-------------------

当卸载有弹性的组时，用于在下一跳间分配桶的算法仍然在软件中实现。驱动程序通过以下三种方式接收对下一跳组的更新通知：

- 使用类型为``NH_NOTIFIER_INFO_TYPE_RES_TABLE``的完整组通知。这是在组创建并首次填充桶后立即使用的。
- 使用类型为``NH_NOTIFIER_INFO_TYPE_RES_BUCKET``的单个桶通知，用于已建立组内部单个迁移的通知。
- 替换前的通知，类型为``NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE``。这是在替换组之前发送的，是驱动程序在向硬件提交任何更改前否决组的一种方式。

某些单个桶的通知是强制性的，如通知中的“force”标志所示。这些用于处理例如与桶关联的下一跳已被移除的情况，桶确实需要被迁移的情况。

非强制性通知可以通过返回错误代码由驱动程序覆盖。这种情况的应用案例是：驱动程序通知硬件某桶应该被迁移，但硬件发现该桶实际上已经被流量命中。
第二种方式是硬件（HW）通过 `nexthop_res_grp_activity_update()` API 报告某个桶正忙。以这种方式标识为正忙的桶被视为有流量命中它们。
卸载的桶应被标记为“卸载”或“捕获”。这是通过 `nexthop_bucket_set_hw_flags()` API 完成的。

### Netlink 用户空间API (UAPI)

#### 弹性组替换

弹性组使用 `RTM_NEWNEXTHOP` 消息进行配置，与其它多路径组的配置方式相同。以下是对通过Netlink消息传递的属性所做的更改：

| 属性 | 描述 |
| --- | --- |
| `NHA_GROUP_TYPE` | 对于弹性组，应设置为 `NEXTHOP_GRP_TYPE_RES` |
| `NHA_RES_GROUP` | 包含针对弹性组特定属性的嵌套 |

`NHA_RES_GROUP` 的负载：

| 属性 | 描述 |
| --- | --- |
| `NHA_RES_GROUP_BUCKETS` | 散列表中的桶数量 |
| `NHA_RES_GROUP_IDLE_TIMER` | 空闲定时器，单位为 clock_t |
| `NHA_RES_GROUP_UNBALANCED_TIMER` | 不平衡定时器，单位为 clock_t |

#### 下一跳获取

请求获取弹性下一跳组使用 `RTM_GETNEXTHOP` 消息，与其它下一跳获取请求完全相同。响应属性与上述替换属性相匹配，除了 `NHA_RES_GROUP` 负载将包括以下属性：

| 属性 | 描述 |
| --- | --- |
| `NHA_RES_GROUP_UNBALANCED_TIME` | 弹性组处于不平衡状态的时间长度，单位为 clock_t |

#### 桶获取

使用 `RTM_GETNEXTHOPBUCKET` 消息且不带 `NLM_F_DUMP` 标志来请求单个桶。在获取请求时识别的属性包括：

| 属性 | 描述 |
| --- | --- |
| `NHA_ID` | 所属下一跳组的ID |
| `NHA_RES_BUCKET` | 包含桶特定属性的嵌套 |
```NHA_RES_BUCKET`` 参数载荷：

  ======================== ====================================================
  ``NHA_RES_BUCKET_INDEX`` 在弹性表中的桶索引
  ======================== ====================================================

桶的导出
^^^^^^^^^^^^

消息 ``RTM_GETNEXTHOPBUCKET`` 与 ``NLM_F_DUMP`` 标志一起使用，用于请求匹配的桶的导出。在导出请求中可识别的属性包括：

  =================== =========================================================
  ``NHA_ID``          如果指定，则限制导出仅包含具有此ID的下一跳组
  ``NHA_OIF``         如果指定，则限制导出仅包含使用具有此ifindex设备的下一跳的桶
  ``NHA_MASTER``      如果指定，则限制导出仅包含使用位于具有此ifindex的VRF中的设备的下一跳的桶
  ``NHA_RES_BUCKET``  包含特定于桶的属性的嵌套
  =================== =========================================================

``NHA_RES_BUCKET`` 参数载荷：

  ======================== ====================================================
  ``NHA_RES_BUCKET_NH_ID`` 如果指定，则限制导出仅包含具有此ID的下一跳的桶
  ======================== ====================================================

使用方法
-----

为了说明如何使用这些命令，考虑以下示例命令：

```bash
# ip nexthop add id 1 via 192.0.2.2 dev eth0
# ip nexthop add id 2 via 192.0.2.3 dev eth0
# ip nexthop add id 10 group 1/2 type resilient \
	buckets 8 idle_timer 60 unbalanced_timer 300
```

最后一条命令创建了一个弹性下一跳组。它将有8个桶（这个数字通常会更高，这里仅为演示目的），每个桶在至少60秒内没有数据流量时会被认为是空闲的，并且如果该表持续300秒处于不平衡状态，则会被强制恢复平衡。
更改下一跳权重会导致桶分配的变化：

```bash
# ip nexthop replace id 10 group 1,3/2 type resilient
```

这可以通过查看各个桶来确认：

```bash
# ip nexthop bucket show id 10
id 10 index 0 idle_time 5.59 nhid 1
id 10 index 1 idle_time 5.59 nhid 1
id 10 index 2 idle_time 8.74 nhid 2
id 10 index 3 idle_time 8.74 nhid 2
id 10 index 4 idle_time 8.74 nhid 1
id 10 index 5 idle_time 8.74 nhid 1
id 10 index 6 idle_time 8.74 nhid 1
id 10 index 7 idle_time 8.74 nhid 1
```

请注意那两个空闲时间较短的桶。这些是在下一跳替换命令后迁移的桶，以满足新的需求——即下一跳1应该被分配6个桶而不是4个。

Netdevsim
---------

Netdevsim驱动实现了对弹性组的模拟卸载，并提供了一个debugfs接口，允许标记单个桶为忙碌状态。
例如，下面的命令将标记下一跳组10中的第23个桶为活跃状态：

```bash
# echo 10 23 > /sys/kernel/debug/netdevsim/netdevsim10/fib/nexthop_bucket_activity
```

此外，另一个debugfs接口可用于配置下次尝试迁移桶时失败：

```bash
# echo 1 > /sys/kernel/debug/netdevsim/netdevsim10/fib/fail_nexthop_bucket_replace
```

除了作为示例外，netdevsim暴露的接口在自动化测试中也很有用，`tools/testing/selftests/drivers/net/netdevsim/nexthop.sh`利用这些接口来测试算法。```
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
