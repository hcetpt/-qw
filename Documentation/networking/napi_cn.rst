SPDX 许可证标识符: (GPL-2.0-only 或 BSD-2-Clause)

.. _napi:

====
NAPI
====

NAPI 是 Linux 网络堆栈中使用的事件处理机制。
NAPI 这个名字现在已经不再代表任何特定含义 [#]_。
在基本操作中，设备通过中断通知主机有关新事件的信息。
然后，主机会调度一个 NAPI 实例来处理这些事件。
设备也可以通过 NAPI 检测事件而无需先接收中断（:ref:`忙轮询<poll>`）。
NAPI 处理通常发生在软件中断上下文中，
但也有选项使用 :ref:`独立的内核线程<threaded>` 来进行 NAPI 处理。
总的来说，NAPI 抽象了驱动程序中的事件（数据包接收和发送）处理的上下文和配置。

驱动程序 API
============

NAPI 的两个最重要的元素是 `struct napi_struct` 和相关的 `poll` 方法。
`struct napi_struct` 保存了 NAPI 实例的状态，
而方法则是驱动程序特定的事件处理器。
该方法通常会释放已传输的 Tx 数据包并处理新收到的数据包。

.. _drv_ctrl:

控制 API
--------

`netif_napi_add()` 和 `netif_napi_del()` 用于添加/移除一个 NAPI 实例。
实例被附加到作为参数传递的 `netdevice`（当 `netdevice` 被注销时，实例将自动删除）。
实例是在禁用状态下添加的。
`napi_enable()` 和 `napi_disable()` 用于管理禁用状态。
一个被禁用的 NAPI 无法被调度，并且其轮询方法保证不会被调用。`napi_disable()` 等待 NAPI 实例的所有权被释放。

控制 API 并不是幂等的。控制 API 调用在与数据路径 API 并发使用时是安全的，但不正确的控制 API 调用顺序可能导致崩溃、死锁或竞态条件。例如，连续多次调用 `napi_disable()` 将导致死锁。

数据路径 API
------------

`napi_schedule()` 是调度 NAPI 轮询的基本方法。
驱动程序应在中断处理程序中调用此函数（更多信息参见 :ref:`drv_sched`）。成功调用 `napi_schedule()` 将获取 NAPI 实例的所有权。

稍后，在 NAPI 被调度之后，将调用驱动程序的轮询方法来处理事件/数据包。该方法接受一个“预算”参数——驱动程序可以处理任意数量的发送（Tx）数据包，但应仅处理最多“预算”数量的接收（Rx）数据包。接收处理通常更耗时。

换句话说，对于接收处理，“预算”参数限制了驱动程序在单次轮询中可以处理的数据包数量。当“预算”为 0 时，不能使用任何特定于接收的 API，如页面池或 XDP。

无论“预算”如何，都应该处理 skb 发送（Tx），但如果参数为 0，则驱动程序不能调用任何 XDP（或页面池）API。

.. warning::

   如果内核核心试图仅处理 skb 发送完成而没有接收或 XDP 数据包，“预算”参数可能为 0。

轮询方法返回已完成的工作量。如果驱动程序仍有未完成的工作（例如“预算”已耗尽），轮询方法应返回恰好等于“预算”的值。在这种情况下，NAPI 实例将再次被服务/轮询（无需重新调度）。

如果事件处理已完成（所有未完成的数据包已被处理），轮询方法应在返回前调用 `napi_complete_done()`。`napi_complete_done()` 会释放实例的所有权。
警告：

必须谨慎处理完成所有事件并恰好使用 ``budget`` 的情况。无法向堆栈报告这种（罕见）的情况，因此驱动程序要么不调用 `napi_complete_done()` 并等待再次被调用，要么返回 `budget - 1`。
如果 `budget` 为 0，则不应调用 `napi_complete_done()`。

调用序列
--------

驱动程序不应假设确切的调用顺序。即使驱动程序没有调度实例，也可能调用 poll 方法（除非实例被禁用）。类似地，即使 `napi_schedule()` 成功了，也不能保证会调用 poll 方法（例如，如果实例被禁用了）。
如 :ref:`drv_ctrl` 部分所述，`napi_disable()` 和随后对 poll 方法的调用仅等待实例的所有权被释放，而不是等待 poll 方法退出。这意味着驱动程序应在调用 `napi_complete_done()` 后避免访问任何数据结构。

调度和中断屏蔽
-------------------

驱动程序在调度 NAPI 实例后应保持中断屏蔽，直到 NAPI 轮询完成前，进一步的中断是不必要的。
需要显式屏蔽中断的驱动程序（而非由设备自动屏蔽）应使用 `napi_schedule_prep()` 和 `__napi_schedule()` 调用：

```c
if (napi_schedule_prep(&v->napi)) {
    mydrv_mask_rxtx_irq(v->idx);
    /* 在屏蔽中断后调度以避免竞争 */
    __napi_schedule(&v->n->napi);
}
```

只有在成功调用 `napi_complete_done()` 后才能取消屏蔽中断：

```c
if (budget && napi_complete_done(&v->napi, work_done)) {
    mydrv_unmask_rxtx_irq(v->idx);
    return min(work_done, budget - 1);
}
```

`napi_schedule_irqoff()` 是 `napi_schedule()` 的一个变体，它利用了在 IRQ 上下文调用时提供的保证（无需屏蔽中断）。请注意，PREEMPT_RT 强制所有中断变为线程化的，因此中断可能需要标记为 `IRQF_NO_THREAD` 以避免实时内核配置中的问题。

实例到队列映射
----------------

现代设备每个接口有多个 NAPI 实例（`struct napi_struct`）。对于这些实例如何映射到队列和中断没有严格的要求。NAPI 主要是一个轮询/处理抽象层，没有特定的用户界面语义。尽管如此，大多数网络设备最终都以相似的方式使用 NAPI。
NAPI 实例通常与中断和队列对（一个接收队列和一个发送队列的集合）一对一对应。
在较少见的情况下，一个 NAPI 实例可以用于多个队列，或者在单个核心上，接收队列和发送队列可以由单独的 NAPI 实例服务。然而，无论队列分配如何，通常仍然有一个 NAPI 实例与一个中断的一对一映射。
值得注意的是，ethtool API 使用“通道”术语，其中每个通道可以是 `rx`、`tx` 或 `combined`。不清楚什么构成一个通道；推荐的理解是将一个通道理解为服务于特定类型队列的一个中断/NAPI。例如，1 个 `rx`、1 个 `tx` 和 1 个 `combined` 通道的配置预计会使用 3 个中断，2 个接收队列和 2 个发送队列。
用户 API
========

用户与 NAPI 的交互依赖于 NAPI 实例 ID。这些实例 ID 仅通过 `SO_INCOMING_NAPI_ID` 套接字选项对用户可见。目前无法查询给定设备所使用的 ID。

软件中断合并
----------------

NAPI 默认不执行任何显式的事件合并。在大多数情况下，批处理是由于设备完成的中断合并。有些情况下，软件合并是有帮助的。NAPI 可以配置为在所有数据包处理完毕后启动一个重新轮询定时器，而不是立即解除硬件中断屏蔽。`gro_flush_timeout` 系统文件系统配置项被重用以控制定时器的延迟，而 `napi_defer_hard_irqs` 控制连续空轮询的次数，之后 NAPI 放弃并回到使用硬件中断。

.. _poll:

忙轮询
------------

忙轮询允许用户进程在设备中断触发之前检查传入的数据包。如同任何忙轮询一样，它用 CPU 周期换取更低的延迟（NAPI 忙轮询的实际生产用途尚不明确）。忙轮询可以通过设置选定套接字上的 `SO_BUSY_POLL` 或使用全局的 `net.core.busy_poll` 和 `net.core.busy_read` 系统控制文件来启用。还有一个用于 NAPI 忙轮询的 io_uring API。

中断缓解
---------------

尽管忙轮询主要用于低延迟应用，类似的机制也可用于中断缓解。极高请求每秒的应用（特别是路由/转发应用，尤其是使用 AF_XDP 套接字的应用）可能希望在处理完一个请求或一批数据包之前不被打断。
此类应用程序可以向内核保证，它们将定期执行忙轮询操作，并且驱动程序应始终保持设备中断被屏蔽。此模式通过使用 `SO_PREFER_BUSY_POLL` 套接字选项来启用。为了避免系统行为异常，如果 `gro_flush_timeout` 时间内没有进行任何忙轮询调用，则该保证将被撤销。

忙轮询的 NAPI 预算低于默认值（这符合正常忙轮询低延迟的设计意图）。然而，在中断缓解的情况下并非如此，因此可以通过 `SO_BUSY_POLL_BUDGET` 套接字选项来调整预算。

.. _threaded:

线程化 NAPI
-----------

线程化 NAPI 是一种工作模式，它使用专用的内核线程而不是软件中断上下文来进行 NAPI 处理。
配置是按网络设备进行的，会影响该设备的所有 NAPI 实例。每个 NAPI 实例将启动一个单独的线程（称为 `napi/${ifc-name}-${napi-id}`）。
建议将每个内核线程绑定到单个 CPU 上，即服务中断的同一个 CPU。请注意，IRQ 和 NAPI 实例之间的映射可能并不简单（并且取决于驱动程序）。NAPI 实例 ID 将以与内核线程进程 ID 相反的顺序分配。

线程化 NAPI 通过写入 0 或 1 到网卡设备的 sysfs 目录中的 `threaded` 文件来控制。

.. rubric:: 脚注

.. [#] NAPI 最初在 2.4 版本的 Linux 中被称为 New API。
