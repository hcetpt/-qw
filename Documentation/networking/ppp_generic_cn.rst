SPDX 许可声明标识符: GPL-2.0

========================================
PPP 通用驱动程序和通道接口
========================================

			保罗·麦凯瑞斯
			paulus@samba.org

			2002年2月7日

linux-2.4 中的通用 PPP 驱动程序提供了任何 PPP 实现中都可能用到的功能实现，包括：

* 网络接口单元（如 ppp0 等）
* 与网络代码的接口
* PPP 多链路：将数据报分割到多个链路上，并对接收到的片段进行排序和合并
* 通过 /dev/ppp 字符设备与 pppd 的接口
* 数据包压缩和解压缩
* TCP/IP 首部压缩和解压缩
* 检测用于按需拨号和空闲超时的网络流量
* 简单的数据包过滤

对于 PPP 帧的发送和接收，通用 PPP 驱动程序调用了 PPP“通道”的服务。一个 PPP 通道封装了一种从一台机器到另一台机器传输 PPP 帧的机制。PPP 通道实现可以在内部任意复杂，但它与通用 PPP 代码之间的接口非常简单：它只需要能够发送 PPP 帧、接收 PPP 帧，并且可选地处理 ioctl 请求。目前有针对异步串行端口、同步串行端口以及以太网上的 PPP 的 PPP 通道实现。
这种架构使得通过允许一个以上的通道链接到每个 PPP 网络接口单元来实现 PPP 多链路变得自然且直接。通用层负责在发送时拆分数据报并在接收时重新组合它们。

PPP 通道 API
-------------

请参阅 include/linux/ppp_channel.h 以获取用于通用 PPP 层和 PPP 通道之间通信的类型和函数声明。
每个通道必须通过 ppp_channel.ops 指针向通用 PPP 层提供两个函数：

* start_xmit() 在通用层有帧要发送时被调用。通道可以根据流量控制的原因拒绝该帧。在这种情况下，start_xmit() 应返回 0，并且通道应在稍后能够再次接受帧时调用 ppp_output_wakeup() 函数，然后通用层会尝试重新发送被拒绝的帧。如果帧被接受，start_xmit() 函数应返回 1
* ioctl() 提供了一个接口，用户空间程序可以使用该接口来控制通道的行为方面。当用户空间程序对绑定到该通道的 /dev/ppp 实例执行 ioctl 系统调用时，将调用此过程。（通常只有 pppd 才会这样做。）

通用 PPP 层向通道提供了七个函数：

* ppp_register_channel() 在创建了一个通道时被调用，以通知 PPP 通用层其存在。例如，将串行端口设置为 PPPDISC 行律会导致 ppp_async 通道代码调用此函数
* ppp_unregister_channel() 在销毁一个通道时被调用。例如，当检测到串行端口断开连接时，ppp_async 通道代码会调用此函数
* ppp_output_wakeup() 当通道之前拒绝了对其 start_xmit 函数的调用，并且现在可以接受更多数据包时由通道调用
* ppp_input() 当通道接收到一个完整的 PPP 帧时被调用
* ppp_input_error() 当通道检测到一个帧丢失或被丢弃（例如，由于 FCS 错误）时被调用
* ppp_channel_index() 返回 PPP 通用层为此通道分配的通道索引。通道应提供一种方式（例如 ioctl）将此信息传回用户空间，因为用户空间需要它来将 /dev/ppp 的实例绑定到此通道。
* `ppp_unit_number()` 返回此通道所连接的 PPP 网络接口的单元编号，如果通道未连接则返回 -1。
将一个通道连接到 PPP 通用层是由通道代码发起的，而不是由通用层发起。期望该通道有某种方式让用户级进程独立于 PPP 通用层对其进行控制。例如，在 `ppp_async` 通道中，这是通过串行端口的文件描述符来实现的。

通常，用户级进程会初始化底层通信介质并使其准备好进行 PPP 通信。例如，在异步终端（async tty）的情况下，这可能包括设置终端速度和模式、发送调制解调器命令，然后与远程系统进行某种对话以在远程系统上启动 PPP 服务。我们将这个过程称为“发现”。然后，用户级进程告诉介质成为 PPP 通道，并将其自身注册到 PPP 通用层。

此时，通道必须将分配给它的通道号报告回用户级进程。从这一点开始，PPP 守护进程（pppd）中的 PPP 协商代码可以接管并执行 PPP 协商，通过 `/dev/ppp` 接口访问该通道。

在 PPP 通用层接口处，PPP 帧存储在 `skbuff` 结构中，并以两个字节的 PPP 协议号开头。帧不包含异步 PPP 中可选使用的 0xff “地址”字节或 0x03 “控制”字节。此外，也没有对控制字符进行转义，也没有包含任何帧校验序列（FCS）或帧定界字符。这些都由通道代码负责处理，如果特定介质需要的话。也就是说，提交给 `start_xmit()` 函数的 `skbuff` 仅包含 2 字节的协议号和数据部分，提交给 `ppp_input()` 的 `skbuff` 必须具有相同的格式。

通道必须提供一个 `ppp_channel` 结构实例来表示该通道。通道可以自由使用“private”字段。通道应在调用 `ppp_register_channel()` 之前初始化 “mtu” 和 “hdrlen” 字段，并且在 `ppp_unregister_channel()` 返回之前不应更改它们。“mtu” 字段表示 PPP 帧的数据部分的最大大小，即不包括 2 字节的协议号。

如果通道在传输时需要 `skbuff` 中有一些额外的空间（即，在 PPP 帧开始前的 `skbuff` 数据区域中有空闲空间），它应将 `ppp_channel` 结构中的 “hdrlen” 字段设置为所需的空间大小。通用 PPP 层将尝试提供这么多的空间，但通道仍应检查是否有足够的空间，并在没有足够空间时复制 `skbuff`。

在输入侧，通道理想上应在提交给 `ppp_input()` 的 `skbuff` 中至少提供 2 字节的额外空间。虽然通用 PPP 代码不要求这样做，但如果这样做效率会更高。

缓冲和流量控制
-------------------

通用 PPP 层设计时尽量减少了其在传输方向上的数据缓冲。它为 PPP 单元（网络接口设备）维护了一个传输包队列，以及每个附加通道的一个传输包队列。通常，单元的传输队列最多只包含一个包；例外情况是当 pppd 通过写入 `/dev/ppp` 发送包时，以及当核心网络代码在队列停止的情况下调用通用层的 `start_xmit()` 函数时，即当通用层调用 `netif_stop_queue()` 时，这种情况只会在传输超时时发生。
`start_xmit` 函数总是接受并排队它被要求传输的数据包。

待传输的数据包从 PPP 单元的发送队列中出队，并根据需要进行 TCP/IP 首部压缩和数据包压缩（Deflate 或 BSD-Compress 压缩）。在此之后，数据包将无法再重新排序，因为解压算法依赖于接收到压缩数据包的顺序与生成时的顺序一致。

如果未使用多链路，则此数据包将传递给关联通道的 `start_xmit()` 函数。如果通道拒绝接收该数据包，通用层会将其保存以备后续传输。当通道调用 `ppp_output_wakeup()` 或核心网络代码再次调用通用层的 `start_xmit()` 函数时，通用层将再次调用通道的 `start_xmit()` 函数。通用层不包含超时和重传逻辑；这部分依赖于核心网络代码。

如果使用了多链路，通用层会将数据包分成一个或多个片段，并在每个片段上添加一个多链路头部。它根据数据包的长度以及当前可能接受片段的通道数量来决定使用多少个片段。如果一个通道当前没有排队等待传输的片段，则认为该通道有可能接受片段。即使如此，通道仍可能拒绝接收片段；在这种情况下，该片段会被排队以供通道稍后传输。这种方案的效果是，更多的片段会被分配给高带宽的通道。这也意味着，在轻负载下，通用层倾向于将大数据包分割到所有通道上，从而减少延迟；而在重负载下，数据包更倾向于作为单个片段传输，从而减少分片带来的开销。

### SMP 安全性

PPP 通用层设计为 SMP 安全。在必要时，对内部数据结构的访问使用锁来确保其完整性。作为这一设计的一部分，通用层要求通道遵守某些要求，并反过来向通道提供某些保证。基本上，通道需要在构成通道与通用层之间通信基础的 `ppp_channel` 结构上提供适当的锁定。这是因为通道提供了 `ppp_channel` 结构的存储空间，因此通道需要保证在适当的时间内存在有效的存储空间。

通用层要求通道提供的保证如下：

* `ppp_channel` 对象必须从调用 `ppp_register_channel()` 时存在，直到 `ppp_unregister_channel()` 调用返回后。
* 在调用 `ppp_unregister_channel()` 时，任何线程都不能处于调用 `ppp_input()`、`ppp_input_error()`、`ppp_output_wakeup()`、`ppp_channel_index()` 或 `ppp_unit_number()` 的过程中。
* `ppp_register_channel()` 和 `ppp_unregister_channel()` 必须在进程上下文中调用，而不是在中断或软中断/BH 上下文中调用。
* 其余的通用层函数可以在软中断/BH 级别调用，但不能从硬件中断处理程序中调用。
* 通用层可以在软中断/BH 级别调用通道的 `start_xmit()` 函数，但不会在中断级别调用。因此，`start_xmit()` 函数不能阻塞。
通用层仅在进程上下文中调用通道的ioctl()函数。
通用层向各通道提供以下保证：

- 通用层不会在一个线程已经在该通道的start_xmit()函数中执行时对该通道调用start_xmit()函数。
- 通用层不会在一个线程已经在该通道的ioctl()函数中执行时对该通道调用ioctl()函数。
- 在ppp_unregister_channel()调用返回时，没有任何线程会执行通用层对该通道的start_xmit()或ioctl()函数的调用，并且随后通用层也不会调用这两个函数。

pppd接口
---------

PPP通用层提供了一个名为/dev/ppp的字符设备接口。pppd使用此接口来控制PPP接口单元和通道。尽管只有一个/dev/ppp，每个打开的/dev/ppp实例独立工作，并可以连接到一个PPP单元或一个PPP通道。这是通过使用file->private_data字段指向每个打开的/dev/ppp实例的单独对象来实现的。这样可以获得类似于Solaris的clone open的效果，允许我们控制任意数量的PPP接口和通道，而无需在/dev目录中创建数百个设备名称。

当打开/dev/ppp时，会创建一个新的未连接实例。通过ioctl调用，它可以连接到现有的单元、新创建的单元或现有通道。连接到单元的实例可以使用read()和write()系统调用来发送和接收PPP控制帧，必要时还可以使用poll()。类似地，连接到通道的实例可以用于在该通道上发送和接收PPP帧。

在多链路术语中，单元代表捆绑，而通道则代表各个物理链路。因此，通过写入单元（即，连接到单元的/dev/ppp实例）发送的PPP帧将受到捆绑级别的压缩，并在各个链路上进行分片（如果启用了多链路）。相反，通过写入通道发送的PPP帧将在该通道上直接发送，不包含任何多链路头。

通道最初不连接到任何单元。在这种状态下，它可以用于PPP协商，但不能用于数据包传输。然后可以通过ioctl调用将其连接到PPP单元，使其能够为该单元发送和接收数据包。

/dev/ppp实例可用的ioctl调用取决于它是否未连接、连接到PPP接口或连接到PPP通道。未连接实例可用的ioctl调用包括：

- PPPIOCNEWUNIT创建一个新的PPP接口，并使此/dev/ppp实例成为该接口的“所有者”。参数应指向一个int类型变量，该变量表示若大于等于0，则是期望的单元号；若为-1，则分配最低未使用的单元号。作为接口的所有者意味着如果关闭这个/dev/ppp实例，该接口将会关闭。
* `PPPIOCATTACH` 将此实例附加到一个现有的 PPP 接口。
  参数应该指向包含单元编号的 `int` 变量。
  这并不会使此实例成为 PPP 接口的所有者。

* `PPPIOCATTCHAN` 将此实例附加到一个现有的 PPP 通道。
  参数应该指向包含通道编号的 `int` 变量。

在附属于某个通道的 `/dev/ppp` 实例上可用的 `ioctl` 调用包括：

* `PPPIOCCONNECT` 将此通道连接到一个 PPP 接口。参数应该指向包含接口单元编号的 `int` 变量。如果该通道已经连接到某个接口，则会返回 `EINVAL` 错误；如果请求的接口不存在，则会返回 `ENXIO` 错误。
* `PPPIOCDISCONN` 断开此通道与所连接的 PPP 接口之间的连接。如果该通道未连接到任何接口，则会返回 `EINVAL` 错误。
* `PPPIOCBRIDGECHAN` 将一个通道与另一个通道桥接。参数应该指向包含要桥接的通道编号的 `int` 变量。一旦两个通道被桥接，通过 `ppp_input()` 提供给一个通道的数据帧将传递给桥接实例进行后续传输。这允许数据帧从一个通道切换到另一个通道：例如，将 PPPoE 数据帧传递到 PPPoL2TP 会话中。由于通道桥接会中断正常的 `ppp_input()` 路径，因此一个给定的通道不能同时作为桥接的一部分和单元的一部分。如果该通道已经是桥接或单元的一部分，则此 `ioctl` 调用会返回 `EALREADY` 错误；如果请求的通道不存在，则会返回 `ENXIO` 错误。
* `PPPIOCUNBRIDGECHAN` 执行与 `PPPIOCBRIDGECHAN` 相反的操作，解除桥接一个通道对。如果该通道不是桥接的一部分，则此 ioctl 将返回 `EINVAL` 错误。
* 所有其他 ioctl 命令都会传递给通道的 ioctl 函数。
在连接到接口单元的实例上可用的 ioctl 调用包括：

* `PPPIOCSMRU` 设置接口的最大接收单元（MRU）。参数应指向一个包含新 MRU 值的整数。
* `PPPIOCSFLAGS` 设置控制接口操作的标志。参数应是一个指向包含新标志值的整数的指针。可以设置的标志值中的位如下：

    ===================  =======================================================
    `SC_COMP_TCP`       启用发送方向的 TCP 头压缩
    `SC_NO_TCP_CCID`    禁用 TCP 头压缩时的连接 ID 压缩
    `SC_REJ_COMP_TCP`   禁用接收方向的 TCP 头解压缩
    `SC_CCP_OPEN`       压缩控制协议（CCP）已打开，检查 CCP 数据包
    `SC_CCP_UP`         CCP 已启动，可以（解）压缩数据包
    `SC_LOOP_TRAFFIC`   将 IP 流量发送到 pppd
    `SC_MULTILINK`      在传输的数据包上启用 PPP 多链路分段
    `SC_MP_SHORTSEQ`    在接收到的多链路分片中期望短序列号
    `SC_MP_XSHORTSEQ`   发送带有短序列号的多链路分片
    ===================  =======================================================

这些标志值定义在 `<linux/ppp-ioctl.h>` 中。请注意，如果没有选择 `CONFIG_PPP_MULTILINK` 选项，则忽略 `SC_MULTILINK`、`SC_MP_SHORTSEQ` 和 `SC_MP_XSHORTSEQ` 位的值。

* `PPPIOCGFLAGS` 返回接口单元的状态/控制标志值。参数应指向一个整数，ioctl 将在此处存储标志值。除了上述 `PPPIOCSFLAGS` 的值外，返回值中还可以设置以下位：

    ===================  =======================================================
    `SC_COMP_RUN`       CCP 压缩器正在运行
    `SC_DECOMP_RUN`     CCP 解压缩器正在运行
    `SC_DC_ERROR`       CCP 解压缩器检测到非致命错误
    `SC_DC_FERROR`      CCP 解压缩器检测到致命错误
    ===================  =======================================================

* `PPPIOCSCOMPRESS` 设置数据包压缩或解压缩的参数。参数应指向一个 `ppp_option_data` 结构（定义在 `<linux/ppp-ioctl.h>` 中），其中包含一个指针/长度对，描述包含指定压缩方法及其参数的 CCP 选项的内存块。`ppp_option_data` 结构还包含一个 `transmit` 字段。如果此字段为 0，则 ioctl 将影响接收路径；否则将影响发送路径。
* `PPPIOCGUNIT` 返回由参数指向的整数中的接口单元编号。
* `PPPIOCSDEBUG` 将接口的调试标志设置为参数指向的整数中的值。仅使用最低有效位；如果此位为 1，则通用层将在其操作期间打印一些调试消息。这仅用于调试通用 PPP 层代码；通常对于解决 PPP 连接失败的原因没有帮助。
* `PPPIOCGDEBUG` 返回由参数指向的整数中的接口调试标志。
* `PPPIOCGIDLE` 返回自上次发送和接收数据包以来的时间（以秒为单位）。参数应指向一个 `ppp_idle` 结构（定义在 `<linux/ppp_defs.h>` 中）。如果启用了 `CONFIG_PPP_FILTER` 选项，则重置发送和接收空闲计时器的包集将限制为通过“活动”包过滤器的那些包。
此命令存在两个版本，用于处理用户空间期望时间是以 32 位或 64 位 `time_t` 秒表示的情况。
* `PPPIOCSMAXCID` 设置 TCP 头压缩器和解压缩器的最大连接 ID 参数（从而设置连接槽的数量）。参数所指向的 `int` 的低 16 位指定压缩器的最大连接 ID。如果该 `int` 的高 16 位非零，则它们指定解压缩器的最大连接 ID；否则，解压缩器的最大连接 ID 被设置为 15。
* `PPPIOCSNPMODE` 设置给定网络协议的网络协议模式。参数应指向一个 `npioctl` 结构（定义在 `<linux/ppp-ioctl.h>` 中）。“protocol”字段给出要影响的协议的 PPP 协议号，“mode”字段指定如何处理该协议的数据包：

	=============	==============================================
	NPMODE_PASS	正常操作，传输和接收数据包
	NPMODE_DROP	静默丢弃此协议的数据包
	NPMODE_ERROR	丢弃数据包并在传输时返回错误
	NPMODE_QUEUE	队列化待传输的数据包，丢弃接收到的数据包
	=============	==============================================

目前，NPMODE_ERROR 和 NPMODE_QUEUE 的效果与 NPMODE_DROP 相同。
* `PPPIOCGNPMODE` 返回给定协议的网络协议模式。参数应指向一个 `npioctl` 结构，其中 “protocol” 字段设置为感兴趣的协议的 PPP 协议号。返回时，“mode”字段将被设置为此协议的网络协议模式。
* `PPPIOCSPASS` 和 `PPPIOCSACTIVE` 设置“pass”和“active”包过滤器。这些 `ioctl` 只有在选择了 `CONFIG_PPP_FILTER` 选项时才可用。参数应指向一个包含编译后的 BPF 指令的 `sock_fprog` 结构（定义在 `<linux/filter.h>` 中）。如果数据包未通过“pass”过滤器，则丢弃这些数据包；否则，如果它们未通过“active”过滤器，则通过但不会重置发送或接收空闲计时器。
* `PPPIOCSMRRU` 启用或禁用接收数据包的多链路处理，并设置多链路 MRRU（最大重构接收单元）。参数应指向一个包含新的 MRRU 值的 `int`。如果 MRRU 值为 0，则禁用接收多链路片段的处理。此 `ioctl` 只有在选择了 `CONFIG_PPP_MULTILINK` 选项时才可用。
最后修改日期：2002年2月7日
