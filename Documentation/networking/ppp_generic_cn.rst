### SPDX 许可证标识符：GPL-2.0

========================================
PPP 通用驱动程序和通道接口
========================================

			    保罗·麦凯瑞斯
			    paulus@samba.org

			       2002年2月7日

Linux 2.4中的通用PPP驱动程序提供了一种实现，该实现包含了在任何PPP实现中都可能用到的功能，包括：

* 网络接口单元（如ppp0等）
* 与网络代码的接口
* PPP多链路：将数据报分割到多个链路上，并对收到的分片进行排序和组合
* 通过/dev/ppp字符设备与pppd的接口
* 数据包压缩和解压缩
* TCP/IP头部压缩和解压缩
* 检测拨号按需和空闲超时的网络流量
* 简单的数据包过滤

对于发送和接收PPP帧，通用PPP驱动程序调用PPP“通道”的服务。PPP通道封装了一种机制，用于从一台机器向另一台机器传输PPP帧。PPP通道的内部实现可以任意复杂，但它与通用PPP代码的接口非常简单：它只需要能够发送PPP帧、接收PPP帧，并且可选地处理ioctl请求。目前有针对异步串行端口、同步串行端口以及以太网上的PPP的PPP通道实现。
这种架构使得以自然和直接的方式实现PPP多链路成为可能，允许每个PPP网络接口单元连接一个以上的通道。通用层负责在发送时分割数据报，在接收时重新组合它们。

### PPP 通道 API
---------------

请参阅include/linux/ppp_channel.h以获取通用PPP层与PPP通道之间通信所使用类型和函数的声明。

每个通道都需要通过ppp_channel.ops指针向通用PPP层提供两个函数：

* start_xmit() 在通用层有一个帧要发送时被调用。通道可以选择因流控原因拒绝该帧。在这种情况下，start_xmit()应返回0，并且当通道再次能够接受帧时，稍后应调用ppp_output_wakeup()函数，然后通用层将尝试重传被拒绝的帧。如果帧被接受，start_xmit()函数应该返回1。
* ioctl() 提供了一个用户空间程序可以用来控制通道行为某些方面的接口。当用户空间程序对与该通道绑定的/dev/ppp实例执行ioctl系统调用时，会调用此过程。（通常只有pppd会这样做。）

通用PPP层为通道提供了七个函数：

* ppp_register_channel() 当创建了一个通道时被调用，用于通知PPP通用层它的存在。例如，将串行端口设置为PPPDISC线路规程会导致ppp_async通道代码调用此函数。
* ppp_unregister_channel() 当通道需要被销毁时被调用。例如，当检测到串行端口挂断时，ppp_async通道代码会调用此函数。
* ppp_output_wakeup() 当通道之前拒绝了对其start_xmit函数的调用，并且现在可以接受更多数据包时由通道调用。
* ppp_input() 当通道接收到一个完整的PPP帧时被调用。
* ppp_input_error() 当通道检测到帧丢失或丢弃（例如，由于FCS（帧校验序列）错误）时被调用。
* ppp_channel_index() 返回PPP通用层为此通道分配的通道索引。通道应该提供一种方式（例如，ioctl）来将此信息回传给用户空间，因为用户空间需要它来将/dev/ppp的一个实例与此通道关联起来。
* `ppp_unit_number()` 返回与此通道连接的 ppp 网络接口的单元编号，如果通道未连接则返回 -1。
连接一个通道到 ppp 通用层是由通道代码发起的，而不是由通用层发起。期望该通道为用户级进程提供某种方式来独立于 ppp 通用层控制它。例如，在 `ppp_async` 通道中，这通过串行端口的文件描述符实现。
通常，用户级进程将初始化底层通信媒介并准备其进行 PPP 通信。例如，在异步终端（tty）的情况下，这可能涉及设置 tty 的速度和模式、发出调制解调器命令，然后与远程系统进行某种对话以在远程系统上启动 PPP 服务。我们将此过程称为“发现”。然后，用户级进程告诉媒介成为 PPP 通道，并自行向通用 PPP 层注册。
之后，该通道必须将其分配给自己的通道编号报告回用户级进程。从这一点开始，PPP 守护进程（pppd）中的 PPP 协商代码可以接管并执行 PPP 协商，通过 `/dev/ppp` 接口访问该通道。
在 PPP 通用层接口处，PPP 帧存储在 `skbuff` 结构中，并以两个字节的 PPP 协议号开头。帧不包括异步 PPP 中可选使用的 0xff “地址”字节或 0x03 “控制”字节。也没有任何控制字符的转义，也不包含任何循环冗余校验（FCS）或帧定界字符。这些都是通道代码的责任，如果特定媒介需要的话。也就是说，提交给 `start_xmit()` 函数的 `skbuff` 仅包含 2 字节协议号和数据，提交给 `ppp_input()` 的 `skbuff` 必须是相同的格式。
通道必须提供一个 `ppp_channel` 结构实例来表示该通道。通道可以自由使用 “private” 字段。在调用 `ppp_register_channel()` 之前，通道应初始化 “mtu” 和 “hdrlen” 字段，并且在 `ppp_unregister_channel()` 返回之后不应更改它们。“mtu” 字段代表 PPP 帧数据部分的最大大小，即不包括 2 字节协议号。
如果通道在其传输的 `skbuff` 中需要一些额外空间（即，在 PPP 帧开始前 `skbuff` 数据区中有空闲的空间），它应该将 `ppp_channel` 结构中的 “hdrlen” 字段设置为所需的空间量。通用 PPP 层会尝试提供这么多额外空间，但通道仍然应该检查是否有足够的额外空间，并在没有足够空间时复制 `skbuff`。
在输入方面，通道理想情况下应在提交给 `ppp_input()` 的 `skbuff` 中至少提供 2 字节的额外空间。虽然通用 PPP 代码不要求这样做，但如果这样做将会更高效。

缓冲和流量控制
-----------------
通用 PPP 层设计旨在最小化其在发送方向上缓冲的数据量。它维护每个 PPP 单元（网络接口设备）的发送包队列以及每个附加通道的发送包队列。通常，单元的发送队列最多只包含一个包；例外情况是当 pppd 通过写入 `/dev/ppp` 发送包，以及当核心网络代码在队列停止时调用通用层的 `start_xmit()` 函数，即当通用层调用 `netif_stop_queue()` 时，这仅在发送超时时发生。
`start_xmit` 函数始终接收并排队要发送的数据包。
待发送的数据包从 PPP 单元的发送队列中出队，然后根据需要进行 TCP/IP 首部压缩和数据包压缩（Deflate 或 BSD-Compress 压缩）。经过这一步后，数据包便不能再被重新排序，因为解压算法依赖于接收到压缩数据包的顺序与生成时的顺序相同。
如果未使用多链路，则该数据包将传递给关联通道的 `start_xmit()` 函数。如果通道拒绝接收数据包，通用层会将其保存以备后续发送。当通道调用 `ppp_output_wakeup()` 或核心网络代码再次调用通用层的 `start_xmit()` 函数时，通用层将会再次调用通道的 `start_xmit()` 函数。通用层本身不包含超时和重传逻辑；这部分依赖于核心网络代码。
如果使用了多链路，则通用层将数据包分割成一个或多个片段，并为每个片段添加一个多链路头部。它根据数据包长度以及当前可能接受片段的通道数量来决定使用多少个片段。如果通道当前没有排队等待发送的片段，则认为该通道有可能接受一个片段。即使如此，通道仍可能拒绝一个片段；在这种情况下，该片段会被排队以供稍后由通道发送。这种方案的效果是更多的片段分配给带宽更高的通道。这也意味着在轻负载下，通用层倾向于将大型数据包跨所有通道分片，从而降低延迟；而在重负载下，数据包更倾向于作为单个片段发送，从而减少分片带来的开销。

### SMP 安全性

PPP 通用层设计为 SMP 安全的。必要时使用锁来确保内部数据结构的完整性。为此，通用层要求通道遵守某些规则，并反过来向通道提供一定的保证。基本上，通道需要在其构成通道与通用层通信基础的 `ppp_channel` 结构上提供适当的锁定。这是因为通道提供了 `ppp_channel` 结构的存储空间，因此通道需要保证该存储空间在适当的时候存在且有效。

通用层要求通道提供以下保证：

* `ppp_channel` 对象必须从调用 `ppp_register_channel()` 时存在，直到 `ppp_unregister_channel()` 调用返回之后。
* 在调用通道的 `ppp_unregister_channel()` 时，任何线程都不应处于对 `ppp_input()`、`ppp_input_error()`、`ppp_output_wakeup()`、`ppp_channel_index()` 或 `ppp_unit_number()` 的调用之中。
* `ppp_register_channel()` 和 `ppp_unregister_channel()` 必须在进程上下文中调用，而不是在中断或软中断/BH 上下文中调用。
* 其余的通用层函数可以在软中断/BH 级别调用，但不得在硬件中断处理程序中调用。
* 通用层可以在软中断/BH 级别调用通道的 `start_xmit()` 函数，但不会在中断级别调用。因此，`start_xmit()` 函数不得阻塞。
通用层仅在进程上下文中调用通道的 ioctl() 函数。
通用层向各通道提供以下保证：

* 通用层不会在一个通道的任何线程正在该通道的 start_xmit() 函数中执行时调用该函数。
* 通用层不会在一个通道的任何线程正在该通道的 ioctl() 函数中执行时调用该函数。
* 当 ppp_unregister_channel() 的调用返回时，没有线程会在通用层对该通道的 start_xmit() 或 ioctl() 函数的调用中执行，并且之后通用层将不再调用这两个函数中的任何一个。

pppd 接口
---------

PPP 通用层导出了一个名为 /dev/ppp 的字符设备接口。此接口被 pppd 用来控制 PPP 接口单元和通道。尽管只有一个 /dev/ppp，但每个打开的 /dev/ppp 实例都是独立工作的，并且可以连接到 PPP 单元或 PPP 通道。这是通过使用 file->private_data 字段指向每个打开的 /dev/ppp 实例的单独对象来实现的。这样可以实现类似 Solaris 克隆打开的效果，使我们能够控制任意数量的 PPP 接口和通道，而无需占用 /dev 中的数百个设备名称。
当打开 /dev/ppp 时，会创建一个新的未连接实例。然后可以通过 ioctl 调用将其连接到现有的单元、新创建的单元或现有通道。连接到单元的实例可以使用 read() 和 write() 系统调用（必要时使用 poll()）发送和接收 PPP 控制帧。同样地，连接到通道的实例可以在该通道上发送和接收 PPP 帧。
在多链路术语中，单元代表捆绑，而通道则代表各个物理链接。因此，通过向单元（即，连接到单元的 /dev/ppp 实例）写入 PPP 帧，该帧将受到捆绑级别的压缩处理，并可能被分片到各个链接（如果使用了多链路）。相比之下，向通道写入的 PPP 帧将以原样方式在该通道上发送，不包含任何多链路头部。
通道最初并不连接到任何单元。在这种状态下，它可以用于 PPP 协商，但不能用于数据包传输。
然后，可以通过 ioctl 调用将通道连接到 PPP 单元，使其能够为该单元发送和接收数据包。
在 /dev/ppp 实例上的可用 ioctl 调用取决于它是否处于未连接状态、连接到 PPP 接口还是连接到 PPP 通道。对于未连接的实例，可用的 ioctl 调用包括：

* PPPIOCNEWUNIT 创建一个新的 PPP 接口，并使这个 /dev/ppp 实例成为该接口的“所有者”。参数应指向一个 int 类型的变量，其值若大于等于 0 则为所需的单元号，若为 -1 则分配最低未使用的单元号。作为接口的所有者意味着如果关闭此 /dev/ppp 实例，接口将会关闭。
* `PPPIOCATTACH` 将此实例附加到一个现有的 PPP 接口。参数应当指向包含单元编号的整型变量。
这并不会使该实例成为 PPP 接口的所有者。
* `PPPIOCATTCHAN` 将此实例附加到一个现有的 PPP 通道。参数应当指向包含通道编号的整型变量。
在附属于某个通道的 `/dev/ppp` 实例上可用的 ioctl 调用包括：

* `PPPIOCCONNECT` 将此通道连接到一个 PPP 接口。参数应当指向包含接口单元编号的整型变量。如果该通道已经连接到一个接口，或者请求的接口不存在，则将返回 `EINVAL` 错误；如果请求的接口不存在，则返回 `ENXIO` 错误。
* `PPPIOCDISCONN` 使此通道与所连接的 PPP 接口断开连接。如果该通道未连接到任何接口，则将返回 `EINVAL` 错误。
* `PPPIOCBRIDGECHAN` 将一个通道与另一个通道进行桥接。参数应当指向包含要桥接到的通道编号的整型变量。一旦两个通道被桥接，通过 `ppp_input()` 提供给一个通道的数据包将会传递给桥接实例以进行后续传输。
这样可以实现在不同通道间的数据包交换：例如，将 PPPoE 数据包传入 PPPoL2TP 会话。由于通道桥接会中断正常的 `ppp_input()` 流程，因此一个给定的通道不能同时作为桥的一部分和单元的一部分。
如果该通道已经是桥或单元的一部分，或者请求的通道不存在，则此 ioctl 调用将返回 `EALREADY` 或 `ENXIO` 错误。
* `PPPIOCUNBRIDGECHAN` 执行与 `PPPIOCBRIDGECHAN` 相反的操作，即解除绑定一个通道对。如果该通道不是桥接的一部分，则此 ioctl 将返回 `EINVAL` 错误。
* 所有其他 ioctl 命令都将传递给通道的 ioctl() 函数。
在连接到接口单元的实例上可用的 ioctl 调用包括：

* `PPPIOCSMRU` 设置接口的最大接收单元（MRU）。参数应指向包含新 MRU 值的整数。
* `PPPIOCSFLAGS` 设置控制接口操作的标志。参数应为指向包含新标志值的整数的指针。可以设置的标志值中的位包括：

	================	========================================
	SC_COMP_TCP		启用发送 TCP 头部压缩
	SC_NO_TCP_CCID		禁用 TCP 头部压缩的连接 ID 压缩
	SC_REJ_COMP_TCP		禁用接收 TCP 头部解压
	SC_CCP_OPEN		压缩控制协议（CCP）已打开，因此检查 CCP 数据包
	SC_CCP_UP		CCP 已启动，可以（解）压缩数据包
	SC_LOOP_TRAFFIC		将 IP 流量发送到 pppd
	SC_MULTILINK		启用 PPP 多链路分片传输的数据包
	SC_MP_SHORTSEQ		期望收到的多链路片段具有短序列号
	SC_MP_XSHORTSEQ		发送短多链路序列号
	================	========================================

这些标志的值定义在 `<linux/ppp-ioctl.h>` 中。请注意，如果没有选择 `CONFIG_PPP_MULTILINK` 选项，SC_MULTILINK、SC_MP_SHORTSEQ 和 SC_MP_XSHORTSEQ 的值会被忽略。
* `PPPIOCGFLAGS` 返回接口单元的状态/控制标志值。参数应指向一个整数，ioctl 将在此处存储标志值。除了上面列出的 `PPPIOCSFLAGS` 的值之外，返回值中还可以设置以下位：

	================	=========================================
	SC_COMP_RUN		CCP 压缩器正在运行
	SC_DECOMP_RUN		CCP 解压缩器正在运行
	SC_DC_ERROR		CCP 解压缩器检测到非致命错误
	SC_DC_FERROR		CCP 解压缩器检测到致命错误
	================	=========================================

* `PPPIOCSCOMPRESS` 设置数据包压缩或解压缩的参数。参数应指向一个 `ppp_option_data` 结构体（定义在 `<linux/ppp-ioctl.h>` 中），其中包含一个指针/长度对，描述包含指定压缩方法及其参数的 CCP 选项的内存块。`ppp_option_data` 结构体还包括一个 `transmit` 字段。如果该字段为 0，则 ioctl 影响接收路径；否则影响发送路径。
* `PPPIOCGUNIT` 在由参数指向的整数中返回该接口单元的单元编号。
* `PPPIOCSDEBUG` 将接口的调试标志设置为参数所指向的整数中的值。仅使用最低有效位；如果该位为 1，则通用层将在其操作期间打印一些调试信息。这仅用于调试通用 PPP 层代码；通常对于找出 PPP 连接失败的原因没有帮助。
* `PPPIOCGDEBUG` 在由参数指向的整数中返回接口的调试标志。
* PPPIOCGIDLE 返回自最后的数据包发送和接收以来的时间，单位为秒。参数应指向一个 ppp_idle 结构（在 <linux/ppp_defs.h> 中定义）。如果启用了 CONFIG_PPP_FILTER 选项，则重置发送和接收空闲定时器的包集将限制为通过“活动”包过滤器的那些。
此命令存在两个版本，以处理用户空间期望时间作为 32 位或 64 位 time_t 秒的情况。
* PPPIOCSMAXCID 设置 TCP 头部压缩器和解压缩器的最大连接-ID 参数（从而设置连接槽的数量）。由参数指向的 int 的低 16 位指定了压缩器的最大连接-ID。如果该 int 的高 16 位非零，则它们指定了解压缩器的最大连接-ID，否则解压缩器的最大连接-ID 被设置为 15。
* PPPIOCSNPMODE 设置给定网络协议的网络协议模式。参数应指向一个 npioctl 结构（在 <linux/ppp-ioctl.h> 中定义）。“protocol”字段给出了要影响的协议的 PPP 协议号，“mode”字段指定了如何处理该协议的包：

	=============	==============================================
	NPMODE_PASS	正常操作，发送和接收包
	NPMODE_DROP	静默丢弃此协议的包
	NPMODE_ERROR	丢弃包并在发送时返回错误
	NPMODE_QUEUE	排队等待发送的包，丢弃接收到的包
	=============	==============================================

目前，NPMODE_ERROR 和 NPMODE_QUEUE 与 NPMODE_DROP 具有相同的效果。
* PPPIOCGNPMODE 返回给定协议的网络协议模式。参数应指向一个具有 “protocol” 字段设置为目标协议的 PPP 协议号的 npioctl 结构。返回时，“mode”字段将被设置为此协议的网络协议模式。
* PPPIOCSPASS 和 PPPIOCSACTIVE 设置“pass”和“active”包过滤器。这些 ioctl 只有在选择了 CONFIG_PPP_FILTER 选项时才可用。参数应指向一个 sock_fprog 结构（在 <linux/filter.h> 中定义），其中包含用于过滤器的编译后的 BPF 指令。如果包未通过“pass”过滤器则被丢弃；否则，如果它们未通过“active”过滤器，虽然会被传递但不会重置发送或接收空闲定时器。
* PPPIOCSMRRU 启用或禁用接收包的多链路处理，并设置多链路 MRRU（最大重构接收单元）。参数应指向一个包含新的 MRRU 值的 int。如果 MRRU 值为 0，则禁用接收多链路片段的处理。此 ioctl 只有在选择了 CONFIG_PPP_MULTILINK 选项时才可用。
最后修改：2002 年 2 月 7 日
