### 以太网交换设备驱动模型 (switchdev)

**版权声明** © 2014 Jiri Pirko <jiri@resnulli.us>

**版权声明** © 2014-2015 Scott Feldman <sfeldma@gmail.com>

以太网交换设备驱动模型 (switchdev) 是一个内核中的驱动模型，用于处理从内核卸载转发（数据）平面的交换设备。
图1是一个框图，展示了使用数据中心级别的交换ASIC芯片作为示例设置时switchdev模型的组成部分。其他设置如SR-IOV或软交换机（例如OVS）也是可能的。

```
                                 用户空间工具

       用户空间                           |
      +-------------------------------------------------------------------+
       内核                              | Netlink
                                     |
                    +--------------+-------------------------------+
                    |         网络栈                                   |
                    |           （Linux）                                |
                    |                                                      |
                    +----------------------------------------------+

                             sw1p2     sw1p4     sw1p6
                            sw1p1  +  sw1p3  +  sw1p5  +          eth1
                           +    |    +    |    +    |            +
                           |    |    |    |    |    |            |
                    +--+----+----+----+----+----+---+  +-----+-----+
                    |         交换驱动器           |  |    管理   |
                    |        （本文档）             |  |   驱动  |
                    |                                  |           |
                    +--------------+----------------+  +-----------+
                                      |
       内核                              | 硬件总线（例如PCI）
      +-------------------------------------------------------------------+
       硬件                              |
                    +--------------+----------------+
                    |         交换设备 (sw1)               |
                    |  +----+                         +--------+
                    |  |    v 卸载的数据路径             | 管理端口
                    |  |    |                         |
                    +--|----|----+----+----+----+---+
                       |    |    |    |    |    |
                       +    +    +    +    +    +
                      p1   p2   p3   p4   p5   p6

                             前面板端口


                                    图 1
```

#### 包含文件

```
    #include <linux/netdevice.h>
    #include <net/switchdev.h>
```

#### 配置

在驱动程序的Kconfig中使用 "depends NET_SWITCHDEV" 来确保为驱动程序构建switchdev模型支持。

#### 交换端口

在switchdev驱动初始化时，驱动程序将为每个枚举的物理交换端口分配并注册一个 `struct net_device`（使用 `register_netdev()`），称为端口netdev。端口netdev是物理端口的软件表示，并提供了控制器（即内核）与网络之间控制流量的通道，同时也是桥接、绑定、VLAN、隧道和L3路由器等更高级别构造的锚点。使用标准netdev工具（如iproute2、ethtool等），端口netdev还可以向用户提供交换端口的物理属性访问，例如PHY链路状态和I/O统计信息。

目前，除了端口netdev外，没有更高层次的内核对象来代表整个交换机。所有的switchdev驱动操作都是netdev操作或switchdev操作。

交换管理端口不在switchdev驱动模型的范围内。通常，管理端口不参与卸载数据平面，并且在管理端口设备上加载了不同的驱动程序，如NIC驱动。

##### 交换ID

switchdev驱动必须实现net_device操作 `ndo_get_port_parent_id` 对于每个端口netdev，返回每个端口相同的物理ID。该ID必须在同一系统上的不同交换机之间是唯一的。该ID不需要在不同系统上的交换机之间是唯一的。

交换ID用于定位交换机上的端口，并判断聚合端口是否属于同一交换机。
### 网络设备端口命名
^^^^^^^^^^^^^^^^^^

对于网络设备端口的命名，应使用 udev 规则，并以端口的某个唯一属性作为键，例如端口的 MAC 地址或端口的 PHYS 名称。在驱动程序中硬编码内核网络设备名称的做法是不鼓励的；最好是让内核选择默认的网络设备名称，然后让 udev 根据端口属性设置最终的名称。
使用端口的 PHYS 名称（通过 `ndo_get_phys_port_name` 获取）作为键对于动态命名的端口特别有用，在这种情况下，设备根据外部配置为端口命名。例如，如果一个物理 40G 端口逻辑上被分为 4 个 10G 端口，从而产生 4 个端口网络设备，设备可以使用端口 PHYS 名称给每个端口一个独特的名称。udev 规则如下所示：

```sh
SUBSYSTEM=="net", ACTION=="add", ATTR{phys_switch_id}=="<phys_switch_id>", \
	    ATTR{phys_port_name}!="", NAME="swX$attr{phys_port_name}"
```

建议的命名约定为 "swXpYsZ"，其中 X 是交换机名称或 ID，Y 是端口名称或 ID，Z 是子端口名称或 ID。例如，`sw1p1s0` 表示交换机 1 上端口 1 的子端口 0。

### 端口特性
^^^^^^^^^^^^^

#### `NETIF_F_NETNS_LOCAL`

如果交换机驱动（和设备）仅支持默认网络命名空间（netns）的卸载，则驱动程序应设置此特性标志，以防止端口网络设备移出默认 netns。对于支持 netns 的驱动/设备来说，不应设置此标志，并负责硬件分区以保持 netns 包含性。这意味着硬件不能将从一个命名空间中的端口转发到另一个命名空间中的端口的数据包进行转发。

### 端口拓扑
^^^^^^^^^^^^^

代表物理交换机端口的网络设备可以组织成更高级别的交换结构。默认结构是一个独立的路由器端口，用于卸载第 3 层转发。两个或更多端口可以绑定在一起形成链路聚合组（LAG）。两个或更多端口（或 LAG）可以通过桥接来连接第 2 层网络。VLAN 可以应用于子分第 2 层网络。可以在端口上构建第 2 层跨第 3 层隧道。这些结构使用标准 Linux 工具构建，如桥接驱动、绑定/团队驱动以及基于 netlink 的工具如 iproute2。

通过监控 `NETDEV_CHANGEUPPER` 通知，交换机驱动可以了解特定端口在网络拓扑中的位置。例如，当端口移动到绑定中时，其上级主体会发生变化。如果该绑定被移动到桥接中，绑定的上级主体会发生变化。等等。驱动程序会跟踪这些移动情况来了解端口在整个拓扑中的位置，通过注册网络设备事件并处理 `NETDEV_CHANGEUPPER` 通知。

### 第 2 层转发卸载
---------------------

目标是从内核卸载第 2 层数据转发（交换）路径到交换机设备，方法是将桥接 FDB 条目镜像到设备中。FDB 条目是指 `{端口, MAC, VLAN}` 组合的转发目的地。

为了实现第 2 层桥接卸载，交换机驱动/设备应该支持以下功能：

- 在桥接端口上安装静态 FDB 条目
- 从设备接收学习到的/遗忘的源 MAC/VLAN 通知
- 端口上的 STP 状态变化
- VLAN 洪泛多播/广播和未知单播数据包

#### 静态 FDB 条目
^^^^^^^^^^^^^^^^^^

实现了 `ndo_fdb_add`, `ndo_fdb_del` 和 `ndo_fdb_dump` 操作的驱动能够支持下面的命令，该命令添加了一个静态的桥接 FDB 条目：

```sh
bridge fdb add dev DEV ADDRESS [vlan VID] [self] static
```

（"static" 关键字是非可选的：如果没有指定，默认为 "local"，这意味着它不应该被转发）

"self" 关键字（因为它是隐式的，所以是可选的）的作用是指示内核通过 `DEV` 设备自身的 `ndo_fdb_add` 实现来完成操作。如果 `DEV` 是桥接端口，这将绕过桥接，因此会导致软件数据库与硬件数据库不同步。

为了避免这种情况，可以使用 "master" 关键字：

```sh
bridge fdb add dev DEV ADDRESS [vlan VID] master static
```

上述命令指示内核查找 `DEV` 的主接口，并通过那个接口的 `ndo_fdb_add` 方法来完成操作。这次，桥接生成一个 `SWITCHDEV_FDB_ADD_TO_DEVICE` 通知，端口驱动可以处理该通知并用它来编程硬件表。这样，软件和硬件数据库都将包含这个静态 FDB 条目。
注释：对于新的 `switchdev` 驱动程序，如果它们卸载了 Linux 桥接功能，则强烈不建议实现 `ndo_fdb_add` 和 `ndo_fdb_del` 这两个桥接绕过方法：所有静态 FDB 条目都应使用 "master" 标志添加到桥接端口上。`ndo_fdb_dump` 是一个例外，可以实现它来可视化硬件表，如果设备没有中断来通知操作系统新学习或遗忘的动态 FDB 地址的话。在这种情况下，硬件 FDB 可能会包含软件 FDB 没有的条目，而实现 `ndo_fdb_dump` 是查看这些条目的唯一方式。

注释：默认情况下，桥接器不会对 VLAN 进行过滤，仅桥接未标记的流量。要启用 VLAN 支持，请打开 VLAN 过滤：

```sh
echo 1 >/sys/class/net/<bridge>/bridge/vlan_filtering
```

学习/遗忘源 MAC/VLAN 的通知
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

交换机设备将学习/遗忘入站数据包中的源 MAC 地址/VLAN，并通知交换驱动程序 MAC/VLAN/端口元组。反过来，交换驱动程序将使用 switchdev 通知器调用来通知桥接驱动程序：

```c
err = call_switchdev_notifiers(val, dev, info, extack);
```

其中，当学习时 val 为 `SWITCHDEV_FDB_ADD`，当遗忘时为 `SWITCHDEV_FDB_DEL`，而 info 指向 `struct switchdev_notifier_fdb_info` 结构体。在 `SWITCHDEV_FDB_ADD` 时，桥接驱动程序将在桥接的 FDB 中安装 FDB 条目，并将该条目标记为 `NTF_EXT_LEARNED`。iproute2 桥接命令将这些条目标记为 "offload"：

```sh
$ bridge fdb
52:54:00:12:35:01 dev sw1p1 master br0 permanent
00:02:00:00:02:00 dev sw1p1 master br0 offload
00:02:00:00:02:00 dev sw1p1 self
52:54:00:12:35:02 dev sw1p2 master br0 permanent
00:02:00:00:03:00 dev sw1p2 master br0 offload
00:02:00:00:03:00 dev sw1p2 self
33:33:00:00:00:01 dev eth0 self permanent
01:00:5e:00:00:01 dev eth0 self permanent
33:33:ff:00:00:00 dev eth0 self permanent
01:80:c2:00:00:0e dev eth0 self permanent
33:33:00:00:00:01 dev br0 self permanent
01:00:5e:00:00:01 dev br0 self permanent
33:33:ff:12:35:01 dev br0 self permanent
```

应该使用桥接命令禁用端口上的学习：

```sh
bridge link set dev DEV learning off
```

应该在设备端口上启用学习，以及学习同步（learning_sync）：

```sh
bridge link set dev DEV learning on self
bridge link set dev DEV learning_sync on self
```

学习同步属性启用了学习/遗忘 FDB 条目的同步至桥接的 FDB。有可能但并不理想的做法是，在设备端口和桥接端口上同时启用学习，并禁用学习同步。
FDB 老化
^^^^^^^^^^

桥接器将跳过带有 `NTF_EXT_LEARNED` 标记的 FDB 条目的老化操作，由端口驱动程序/设备负责老化这些条目。如果端口设备支持老化操作，当 FDB 条目到期时，它将通知驱动程序，然后驱动程序再通过 `SWITCHDEV_FDB_DEL` 通知桥接器。如果设备不支持老化操作，驱动程序可以使用垃圾收集定时器来监控 FDB 条目以模拟老化操作。过期的条目将通过 `SWITCHDEV_FDB_DEL` 通知给桥接器。参见 rocker 驱动程序作为运行老化定时器的示例。
为了保持 `NTF_EXT_LEARNED` 条目处于“活动”状态，驱动程序应通过调用 `call_switchdev_notifiers(SWITCHDEV_FDB_ADD, ...)` 来刷新 FDB 条目。此通知将重置 FDB 条目的最后使用时间。驱动程序应限制刷新通知的频率，例如，不超过每秒一次。（最后使用时间可以通过 `bridge -s fdb` 选项查看）
端口上的 STP 状态更改
^^^^^^^^^^^^^^^^^^^^^^^^

内部地或与第三方 STP 协议实现一起（例如 mstpd），桥接驱动程序维护端口的 STP 状态，并使用 switchdev 操作 `switchdev_attr_port_set` 对 `SWITCHDEV_ATTR_PORT_ID_STP_UPDATE` 通知交换驱动程序端口上的 STP 状态更改。
状态之一为 `BR_STATE_*`。交换驱动程序可以使用 STP 状态更新来更新端口的入站数据包过滤列表。例如，如果端口被禁用，则不应有数据包通过；但如果端口变为阻塞状态，则 STP BPDUs 和其他 IEEE 01:80:c2:xx:xx:xx 链路本地多播数据包可以通过。
请注意，STP BPDUs 是未标记的，并且 STP 状态适用于端口上的所有 VLAN，因此应在端口上的未标记和标记 VLAN 上一致应用数据包过滤器。
泛洪 L2 域
^^^^^^^^^^^^^^

对于给定的 L2 VLAN 域，如果允许的话，交换机设备应对域内的所有端口泛洪多播/广播和未知单播数据包，这取决于端口当前的 STP 状态。交换驱动程序了解哪些端口属于哪个 VLAN L2 域，可以为此配置交换机设备进行泛洪。数据包可能会发送到端口网卡以供桥接驱动程序处理。桥接器不应重新泛洪设备已泛洪的相同端口，否则线上会出现重复的数据包。
为了避免重复数据包，交换驱动程序应通过设置 `skb->offload_fwd_mark` 标记数据包已经转发。桥接驱动程序将使用入站桥接端口的标记标记该 skb，并防止其通过具有相同标记的任何桥接端口转发。
### 可能性在于交换设备不处理泛洪并将数据包推送到桥接驱动程序进行泛洪
这并不理想，因为在第二层（L2）域中端口数量会扩展，而设备在泛洪数据包方面比软件更高效。
如果设备支持的话，可以将泛洪控制卸载到设备上，防止某些网络设备在没有FDB条目的情况下泛洪单播流量。

#### IGMP监听
为了支持IGMP监听，端口网络设备应该捕获所有IGMP加入和离开的消息，并将其传递给桥接驱动程序。
桥接多播模块会在每次多播组发生变化时（无论是静态配置还是动态加入或离开）通知端口网络设备。
硬件实现应该只将注册的多播流量转发到已配置的端口。

### 第三层路由卸载
卸载第三层路由需要设备根据内核中的FIB条目进行编程，由设备执行FIB查找和转发。设备根据最长前缀匹配（LPM）原则在FIB条目中找到与路由前缀匹配的条目，并将数据包转发到相应的FIB条目下一跳的出口端口。

为了编程设备，驱动程序必须使用`register_fib_notifier`注册一个FIB通知器处理器。以下事件是可用的：

| 事件                     | 描述                                                         |
|------------------------|------------------------------------------------------------|
| FIB_EVENT_ENTRY_ADD     | 用于向设备添加新的FIB条目或修改设备上的现有条目                                 |
| FIB_EVENT_ENTRY_DEL     | 用于删除FIB条目                                                 |
| FIB_EVENT_RULE_ADD,<br>FIB_EVENT_RULE_DEL | 用于传播FIB规则更改                                            |

`FIB_EVENT_ENTRY_ADD` 和 `FIB_EVENT_ENTRY_DEL` 事件传递如下结构体：

```c
struct fib_entry_notifier_info {
    struct fib_notifier_info info; /* 必须是第一个成员 */
    u32 dst;
    int dst_len;
    struct fib_info *fi;
    u8 tos;
    u8 type;
    u32 tb_id;
    u32 nlflags;
};
```

这些事件用于添加/修改/删除IPv4目标/目标长度前缀到表`tb_id`。`*fi`结构包含关于路由及其下一跳的详细信息。`*dev`是一个路由下一跳列表中提到的端口网络设备之一。

卸载到设备的路由在`ip route`列表中被标记为“offload”：

```
$ ip route show
default via 192.168.0.2 dev eth0
11.0.0.0/30 dev sw1p1  proto kernel  scope link  src 11.0.0.2 offload
11.0.0.4/30 via 11.0.0.1 dev sw1p1  proto zebra  metric 20 offload
11.0.0.8/30 dev sw1p2  proto kernel  scope link  src 11.0.0.10 offload
11.0.0.12/30 via 11.0.0.9 dev sw1p2  proto zebra  metric 20 offload
12.0.0.2  proto zebra  metric 30 offload
    nexthop via 11.0.0.1  dev sw1p1 weight 1
    nexthop via 11.0.0.9  dev sw1p2 weight 1
12.0.0.3 via 11.0.0.1 dev sw1p1  proto zebra  metric 20 offload
12.0.0.4 via 11.0.0.9 dev sw1p2  proto zebra  metric 20 offload
192.168.0.0/24 dev eth0  proto kernel  scope link  src 192.168.0.15
```

如果至少有一个设备卸载了FIB条目，则会设置“offload”标志。
### 下一跳解析
FIB条目中的下一跳列表包含下一跳元组（网关，设备），但为了让交换设备用正确的目标MAC地址转发数据包，需要将下一跳网关解析为邻居的MAC地址。邻居MAC地址的发现通过ARP（或ND）过程实现，可通过ARP表获得。为了解析路由的下一跳网关，驱动程序应触发内核的邻居解析过程。例如，可以参考rocker驱动程序中的`rocker_port_ipv4_resolve()`函数。
驱动程序可以通过网络事件通知器 NETEVENT_NEIGH_UPDATE 来监控 arp_tbl 的更新。随着 arp_tbl 的更新，可以为路由配置已解析的下一跳。驱动程序实现了 ndo_neigh_destroy 方法来跟踪何时从端口设备中删除了 arp_tbl 的邻居条目。

### 设备驱动预期行为

以下是定义的一系列行为准则，启用了 switchdev 的网络设备必须遵循这些准则。

#### 无配置状态

在驱动程序启动时，网络设备必须完全可用，并且底层驱动程序必须配置网络设备，使其能够发送和接收流量到此网络设备，并将其正确地与其他网络设备/端口（例如：对于交换芯片而言）分开。如何实现这一点很大程度上取决于硬件，但一个简单的解决方案是使用每个端口的 VLAN 标识符，除非有更好的机制可用（例如：为每个网络端口提供专有的元数据）。
网络设备必须能够运行完整的 IP 协议栈，包括组播、DHCP、IPv4/6 等。如果需要，它应该配置相应的过滤器用于 VLAN、组播、单播等。底层设备驱动程序必须有效地配置得类似于在这些 switchdev 网络设备上启用 IGMP 监听处理 IP 组播时所做的配置，并且应尽可能早地在硬件级别过滤未请求的组播。
当在网络设备上配置 VLAN 时，所有 VLAN 都必须正常工作，无论其他网络设备的状态如何（例如：其他端口属于执行入站 VID 检查的 VLAN 意识桥接的一部分）。详情请参见下面的内容。
如果设备实现了 VLAN 过滤，将接口设置为混杂模式应该允许接收所有 VLAN 标签（包括不在过滤器中的标签）。

#### 桥接的交换端口

当启用了 switchdev 的网络设备被添加为桥接成员时，它不应该干扰任何非桥接网络设备的功能，并且这些设备应该继续像正常的网络设备一样工作。根据下面的桥接配置选项，具体的行为已被记录下来。

#### 桥接 VLAN 过滤

Linux 桥接允许配置 VLAN 过滤模式（在设备创建时静态配置，在运行时动态配置），这必须被底层的 switchdev 网络设备/硬件遵守：

- 当关闭 VLAN 过滤时：桥接严格不识别 VLAN，并且其数据路径将处理所有的以太网帧，就像它们没有 VLAN 标记一样。
  - 桥接的 VLAN 数据库仍然可以修改，但在 VLAN 过滤关闭的情况下，这些修改不应产生影响。带有未编程到桥接/交换机的 VLAN 表中的 VID 的帧必须被转发，并且可以使用 VLAN 设备进行处理（见下文）。
- 当打开 VLAN 过滤时：桥接对 VLAN 是敏感的，并且带有未编程到桥接/交换机的 VLAN 表中的 VID 的入站帧必须被丢弃（严格的 VID 检查）。
当在桥接端口成员的交换设备网络设备之上配置了VLAN设备（例如：sw0p1.100）时，必须保留软件网络堆栈的行为，或者如果不可能，则应拒绝此类配置。
- 关闭VLAN过滤时，桥接器将处理端口的所有入站流量，除了那些带有VLAN ID、目的地为上层VLAN的标记流量。上层VLAN接口（消耗VLAN标签）甚至可以被添加到第二个桥接器中，该桥接器包括其他交换端口或软件接口。确保属于上层VLAN接口的转发域得到妥善管理的一些方法如下：

    * 如果可以根据每个VLAN管理转发目标，硬件可以被配置为将所有流量映射到内部VLAN ID（对应于无标签数据包），除了那些带有属于上层VLAN接口的VLAN ID的数据包。此内部VLAN ID覆盖所有对VLAN不敏感的桥接器端口。与该VLAN接口对应的VLAN ID覆盖该物理端口以及可能与之桥接的其他端口。
* 将具有上层VLAN接口的桥接端口视为独立端口，并让转发在软件数据路径中处理。
- 开启VLAN过滤时，只要桥接器在任何桥接端口上没有现有的相同VLAN ID的VLAN条目，就可以创建这些VLAN设备。这些VLAN设备不能被加入到桥接器中，因为它们与桥接器的VLAN数据路径处理功能重复/使用案例相同。
同一交换结构中的非桥接网络端口在任何情况下都不应因启用桥接设备上的VLAN过滤而受到干扰。如果VLAN过滤设置对整个芯片是全局性的，则独立端口应在ethtool特性中设置'rx-vlan-filter: on [fixed]'，以指示网络堆栈需要VLAN过滤。
由于VLAN过滤可以在运行时打开和关闭，交换设备驱动程序必须能够动态重新配置底层硬件，以遵循该选项的切换并做出适当行为。如果这不可能，交换设备驱动程序也可以拒绝支持运行时动态切换VLAN过滤选项，并要求销毁现有桥接设备并创建新的桥接设备，具有不同的VLAN过滤值，以确保VLAN意识被传递到硬件。
即使在桥接器中关闭了VLAN过滤，底层交换硬件和驱动程序仍可能自行配置为VLAN感知模式，前提是上述描述的行为得以遵守。
桥接器的VLAN协议在决定数据包是否被视为带标签方面发挥作用：使用802.1ad协议的桥接器必须将VLAN未标记的数据包以及带有802.1Q头部的标记数据包都视为未标记。
802.1p（VID 0）标记的数据包必须由设备以与未标记数据包相同的方式处理，因为桥接设备不允许在其数据库中操纵VID 0。
当桥接器启用了VLAN过滤且入站端口上未配置PVID时，必须丢弃未标记和802.1p标记的数据包。当桥接器启用了VLAN过滤且入站端口上存在PVID时，必须接受未标记和优先级标记的数据包，并根据PVID VLAN的桥接端口成员关系进行转发。当桥接器禁用了VLAN过滤时，是否存在PVID不应影响数据包转发决策。
Linux桥接设备允许配置IGMP侦听（静态配置，在接口创建时，或动态配置，在运行时），底层的switchdev网络设备/硬件必须按照以下方式遵守：

- 当IGMP侦听被关闭时，组播流量必须泛洪到同一桥接器内所有设置为mcast_flood=true的端口。理想情况下，CPU/管理端口不应被泛洪（除非入站接口设置了IFF_ALLMULTI或IFF_PROMISC），并且应继续通过网络堆栈通知来学习组播流量。如果硬件无法实现这一点，则CPU/管理端口也必须被泛洪，并且组播过滤在软件中进行。
- 当IGMP侦听被开启时，组播流量必须选择性地流向适当的网络端口（包括CPU/管理端口）。未知组播的泛洪仅应向连接到组播路由器的端口进行（本地设备也可以作为组播路由器）。
交换机必须遵循RFC 4541并据此泛洪组播流量，因为这是Linux桥接器实现的做法。
由于IGMP侦听可以在运行时打开/关闭，switchdev驱动程序必须能够即时重新配置底层硬件以遵守此选项的切换，并做出适当的行为。
switchdev驱动程序也可以拒绝支持运行时多播侦听控制的动态切换，并要求销毁现有的桥接器设备并创建具有不同多播侦听值的新桥接器设备。
