### SPDX 许可证标识符：GPL-2.0

=============================
内核连接复用器
=============================

内核连接复用器（KCM）是一种机制，它为通用应用协议提供基于消息的TCP接口。使用KCM，应用程序可以高效地通过数据报套接字在TCP上发送和接收应用协议消息。
KCM在内核中实现了一个NxM复用器，如下面的图所示：

    +------------+   +------------+   +------------+   +------------+
    | KCM 套接字 |   | KCM 套接字 |   | KCM 套接字 |   | KCM 套接字 |
    +------------+   +------------+   +------------+   +------------+
	|                 |               |                |
	+-----------+     |               |     +----------+
		    |     |               |     |
		+----------------------------------+
		|           复用器            |
		+----------------------------------+
		    |   |           |           |  |
	+---------+   |           |           |  ------------+
	|             |           |           |              |
    +----------+  +----------+  +----------+  +----------+ +----------+
    |  Psock   |  |  Psock   |  |  Psock   |  |  Psock   | |  Psock   |
    +----------+  +----------+  +----------+  +----------+ +----------+
	|              |           |            |             |
    +----------+  +----------+  +----------+  +----------+ +----------+
    | TCP 套接字 |  | TCP 套接字 |  | TCP 套接字 |  | TCP 套接字 | | TCP 套接字 |
    +----------+  +----------+  +----------+  +----------+ +----------+

#### KCM套接字

KCM套接字提供了用户与复用器之间的接口。所有绑定到复用器的KCM套接字被认为具有等效功能，并且可以在不同的套接字中并行执行I/O操作，无需用户空间中的线程间同步。

#### 复用器

复用器提供消息路由。在发送路径中，写入KCM套接字的消息会原子性地发送到适当的TCP套接字。同样，在接收路径中，每个TCP套接字（Psock）上构建消息，并将完整消息路由到KCM套接字。

#### TCP套接字与Psock

TCP套接字可以绑定到KCM复用器。为每个绑定的TCP套接字分配一个Psock结构，该结构包含接收时构建消息的状态以及其他KCM连接特定信息。

#### 连接模式语义

每个复用器假设所有附加的TCP连接都是到同一目的地，并且在传输时可以使用不同的连接进行负载均衡。正常的send和recv调用（包括sendmmsg和recvmmsg）可用于从KCM套接字发送和接收消息。

#### 套接字类型

KCM支持SOCK_DGRAM和SOCK_SEQPACKET套接字类型。

#### 消息分隔

消息通过TCP流发送，其中包含某种应用协议消息格式，通常包括一个用于界定消息的头部。接收消息的长度可以从应用协议头部推断出来（通常只是一个简单的长度字段）。
必须解析TCP流以确定消息边界。为此使用Berkeley包过滤器（BPF）。当将TCP套接字附加到复用器时，必须指定一个BPF程序。该程序在接收新消息开始时被调用，并给出包含到目前为止接收的字节的skbuff。它解析消息头部并返回消息长度。有了这些信息，KCM将构建指定长度的消息并将其传递给KCM套接字。
TCP套接字管理
---------------------

当一个TCP套接字与KCM多路复用器关联时，数据就绪（POLLIN）和可写空间（POLLOUT）事件由该多路复用器处理。如果在TCP套接字上发生状态变化（如断开连接）或其他错误，则会在TCP套接字上报告一个错误，以便触发POLLERR事件，并使KCM停止使用该套接字。当应用程序收到TCP套接字的错误通知时，应将该套接字从KCM中解除关联，然后处理错误情况（常见的响应是关闭套接字并根据需要创建新连接）。
KCM限制接收消息的最大尺寸为所关联TCP套接字的接收缓冲区大小（可以通过SO_RCVBUF设置缓冲区大小）。如果BPF程序报告的新消息长度超过此限制，则会在TCP套接字上报告相应的错误（EMSGSIZE）。BPF程序还可以强制执行最大消息尺寸，并在超出限制时报告错误。
可以为接收套接字上的消息组装设置超时时间。超时值取自所关联TCP套接字的接收超时时间（这通过SO_RCVTIMEO设置）。如果计时器在组装完成前过期，则会在套接字上报告错误（ETIMEDOUT）。

用户界面
==============

创建多路复用器
---------------------

通过socket调用创建一个新的多路复用器和初始KCM套接字：

  socket(AF_KCM, 类型, 协议)

- 类型是SOCK_DGRAM或SOCK_SEQPACKET
- 协议是KCMPROTO_CONNECTED

克隆KCM套接字
-------------------

在使用上述描述的socket调用创建第一个KCM套接字之后，可以通过克隆KCM套接字来为多路复用器创建额外的套接字。这是通过KCM套接字上的ioctl完成的：

  ```c
  /* 来自linux/kcm.h */
  struct kcm_clone {
	int fd;
  };

  struct kcm_clone info;

  memset(&info, 0, sizeof(info));

  err = ioctl(kcmfd, SIOCKCMCLONE, &info);

  if (!err)
    newkcmfd = info.fd;
  ```

关联传输套接字
------------------------

通过在KCM套接字上调用ioctl来将传输套接字关联到多路复用器。例如：

  ```c
  /* 来自linux/kcm.h */
  struct kcm_attach {
	int fd;
	int bpf_fd;
  };

  struct kcm_attach info;

  memset(&info, 0, sizeof(info));

  info.fd = tcpfd;
  info.bpf_fd = bpf_prog_fd;

  ioctl(kcmfd, SIOCKCMATTACH, &info);
  ```

kcm_attach结构包含：
  
  - fd：要关联的TCP套接字的文件描述符
  - bpf_prog_fd：已下载的编译后的BPF程序的文件描述符

解除关联传输套接字
------------------------

将传输套接字从多路复用器中解除关联非常简单。使用kcm_unattach结构作为参数进行“解除关联”ioctl操作：

  ```c
  /* 来自linux/kcm.h */
  struct kcm_unattach {
	int fd;
  };

  struct kcm_unattach info;

  memset(&info, 0, sizeof(info));

  info.fd = cfd;

  ioctl(fd, SIOCKCMUNATTACH, &info);
  ```

禁用KCM套接字接收
-------------------------------

使用setsockopt来禁用或启用KCM套接字上的接收功能。当接收被禁用时，套接字接收缓冲区中的任何待处理消息都将被移至其他套接字。此特性在应用程序线程知道它将对请求执行大量工作并且暂时无法处理新消息时非常有用。示例使用方法：

  ```c
  int val = 1;

  setsockopt(kcmfd, SOL_KCM, KCM_RECV_DISABLE, &val, sizeof(val))
  ```

用于消息界定的BPF程序
------------------------------------

BPF程序可以使用BPF LLVM后端进行编译。例如，解析Thrift的BPF程序如下：

  ```c
  #include "bpf.h" /* for __sk_buff */
  #include "bpf_helpers.h" /* for load_word intrinsic */

  SEC("socket_kcm")
  int bpf_prog1(struct __sk_buff *skb)
  {
       return load_word(skb, 0) + 4;
  }

  char _license[] SEC("license") = "GPL";
  ```

在应用程序中的使用
===================

KCM加速应用层协议。具体而言，它允许应用程序使用基于消息的接口发送和接收消息。内核提供了必要的保证，确保消息以原子方式发送和接收。这大大减轻了应用程序在TCP流上实现基于消息的协议的负担。KCM还将应用层消息作为内核中调度和导向的单位，从而在多线程应用程序中实现了更简单的网络模型。
配置
--------------

在一个Nx1配置中，KCM逻辑上为同一个TCP连接提供多个套接字句柄。这允许在TCP套接字的I/O操作之间实现并行性（例如，数据的读入和写出并行化）。在应用程序中，可以为每个处理线程打开一个KCM套接字，并将其插入epoll（类似于使用SO_REUSEPORT允许在同一端口上有多个监听套接字）。
在一个MxN配置中，建立到同一目的地的多个连接。这些连接用于简单的负载均衡。
消息批处理
-----------------

KCM的主要目的是在KCM套接字和线程之间实现负载均衡。完全的负载均衡，即引导每个接收的消息到不同的KCM套接字或将每个发送的消息引导到不同的TCP套接字，可能会对性能产生负面影响，因为它不允许建立关联性。基于组或消息批次的平衡可能对性能有益。
在发送过程中，应用程序可以通过以下三种方式在KCM套接字上批量（流水线）发送消息：
1) 使用单个sendmmsg发送多个消息
2) 通过每次调用 `sendmsg` 发送一组消息，其中除了最后一个消息外，所有消息的 `sendmsg` 调用标志中都包含 `MSG_BATCH`。
3) 创建由多个消息组成的“超级消息”，并通过单一的 `sendmsg` 调用来发送这个消息。

在接收端，KCM 模块试图在每个 TCP 就绪回调期间对同一 KCM 套接字上收到的消息进行排队。目标 KCM 套接字在每次接收就绪回调时会发生变化。应用程序无需为此配置任何内容。

错误处理
--------------

应用程序应包含一个线程来监控 TCP 连接上引发的错误。通常，这可以通过将每个与 KCM 多路复用器关联的 TCP 套接字设置为用于 `POLLERR` 事件的 epoll 集合来实现。如果关联的 TCP 套接字上发生错误，KCM 会在该套接字上设置 `EPIPE` 错误，从而唤醒应用程序线程。当应用程序检测到错误（可能是断开连接）时，它应该从 KCM 中卸载该套接字并关闭它。假设一旦 TCP 套接字上出现错误，则数据流不可恢复（即，在接收消息的过程中可能出现错误）。

TCP 连接监控
-------------------------

在 KCM 中，没有方法可以将消息与其用于发送或接收的 TCP 套接字相关联（除非只有一个连接的 TCP 套接字的情况）。然而，应用程序保留了对套接字的打开文件描述符，因此可以从套接字获取统计信息，这些信息可用于检测问题（例如，套接字上的高重传率）。
