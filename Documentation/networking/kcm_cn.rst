SPDX 许可证标识符: GPL-2.0

=============================
内核连接多路复用器
=============================

内核连接多路复用器（KCM）是一种机制，为通用应用程序协议提供基于消息的TCP接口。通过KCM，应用程序可以高效地使用数据报套接字通过TCP发送和接收应用程序协议消息。
KCM在内核中实现了一个NxM多路复用器，如下面图示所示：

    +------------+   +------------+   +------------+   +------------+
    | KCM套接字  |   | KCM套接字  |   | KCM套接字  |   | KCM套接字  |
    +------------+   +------------+   +------------+   +------------+
	|                 |               |                |
	+-----------+     |               |     +----------+
		    |     |               |     |
		+----------------------------------+
		|           多路复用器            |
		+----------------------------------+
		    |   |           |           |  |
	+---------+   |           |           |  ------------+
	|             |           |           |              |
    +----------+  +----------+  +----------+  +----------+ +----------+
    |  Psock   |  |  Psock   |  |  Psock   |  |  Psock   | |  Psock   |
    +----------+  +----------+  +----------+  +----------+ +----------+
	|              |           |            |             |
    +----------+  +----------+  +----------+  +----------+ +----------+
    | TCP套接字 |  | TCP套接字 |  | TCP套接字 |  | TCP套接字 | | TCP套接字 |
    +----------+  +----------+  +----------+  +----------+ +----------+

KCM套接字
==========

KCM套接字提供了用户与多路复用器交互的界面。所有绑定到一个多路复用器的KCM套接字都被认为具有相同的功能，并且可以在不同的套接字上并行执行I/O操作，而无需在用户空间中的线程之间进行同步。
多路复用器
==========

多路复用器负责消息路由。在发送路径中，写入KCM套接字的消息会原子性地发送到适当的TCP套接字。同样，在接收路径中，每个TCP套接字（Psock）上的消息被构建，并将完整消息路由到一个KCM套接字。
TCP套接字与Psock
==================

TCP套接字可以绑定到一个KCM多路复用器。对于每个绑定的TCP套接字都会分配一个Psock结构，该结构包含用于接收时构建消息的状态以及其他KCM连接特定的信息。
连接模式语义
==============

每个多路复用器假定所有附加的TCP连接都是到同一目的地的，并且在传输时可以使用不同的连接进行负载均衡。可以使用常规的send和recv调用（包括sendmmsg和recvmmsg）来发送和接收来自KCM套接字的消息。
套接字类型
==========

KCM支持SOCK_DGRAM和SOCK_SEQPACKET类型的套接字。
消息分隔
----------

消息通过TCP流发送，通常包含某种应用协议消息格式，其中通常包括一个定义消息边界的头部。可以从应用协议头部推断出接收到的消息长度（通常只是一个简单的长度字段）。
必须解析TCP流以确定消息边界。为此使用Berkeley Packet Filter（BPF）。当将TCP套接字绑定到多路复用器时，必须指定一个BPF程序。该程序在接收新消息时被调用，并传入包含到目前为止接收到的字节的skbuff。它解析消息头部并返回消息长度。根据这些信息，KCM将构建指定长度的消息并将其传递给KCM套接字。
TCP套接字管理
---------------------

当一个TCP套接字附加到KCM多路复用器时，数据准备好（POLLIN）和写入空间可用（POLLOUT）事件由多路复用器处理。如果TCP套接字上有状态变化（断开连接）或其他错误，则会在TCP套接字上发布错误，以便触发POLLERR事件，并且KCM停止使用该套接字。当应用程序收到TCP套接字的错误通知时，应将套接字从KCM中分离，并处理错误条件（典型的响应是关闭套接字并根据需要建立新连接）。
KCM将最大接收消息大小限制为附加到TCP套接字上的接收套接字缓冲区的大小（套接字缓冲区大小可以通过SO_RCVBUF设置）。如果BPF程序报告的新消息长度超过此限制，则会在TCP套接字上发布相应的错误（EMSGSIZE）。BPF程序还可能强制执行最大消息大小，并在超出限制时报告错误。
可以在接收套接字上设置超时以组装消息。超时值取自附加的TCP套接字的接收超时（这是通过SO_RCVTIMEO设置的）。如果定时器在组装完成前到期，则会在套接字上发布错误（ETIMEDOUT）。

用户界面
==============

创建多路复用器
----------------------

通过socket调用来创建一个新的多路复用器和初始的KCM套接字：

  socket(AF_KCM, type, protocol)

- type可以是SOCK_DGRAM或SOCK_SEQPACKET
- protocol是KCMPROTO_CONNECTED

克隆KCM套接字
-------------------

在使用上述socket调用创建第一个KCM套接字后，可以通过克隆KCM套接字来为多路复用器创建额外的套接字。这通过KCM套接字上的ioctl实现：

  /* 来自linux/kcm.h */
  struct kcm_clone {
    int fd;
  };

  struct kcm_clone info;

  memset(&info, 0, sizeof(info));

  err = ioctl(kcmfd, SIOCKCMCLONE, &info);

  if (!err)
    newkcmfd = info.fd;

附加传输套接字
------------------------

通过调用多路复用器的KCM套接字上的ioctl来附加传输套接字。例如：

  /* 来自linux/kcm.h */
  struct kcm_attach {
    int fd;
    int bpf_fd;
  };

  struct kcm_attach info;

  memset(&info, 0, sizeof(info));

  info.fd = tcpfd;
  info.bpf_fd = bpf_prog_fd;

  ioctl(kcmfd, SIOCKCMATTACH, &info);

kcm_attach结构包含：

  - fd：要附加的TCP套接字的文件描述符
  - bpf_prog_fd：已下载的编译后的BPF程序的文件描述符

分离传输套接字
------------------------

从多路复用器分离传输套接字非常简单。使用kcm_unattach结构作为参数执行“分离”ioctl：

  /* 来自linux/kcm.h */
  struct kcm_unattach {
    int fd;
  };

  struct kcm_unattach info;

  memset(&info, 0, sizeof(info));

  info.fd = cfd;

  ioctl(fd, SIOCKCMUNATTACH, &info);

禁用KCM套接字接收
-------------------------------

使用setsockopt禁用或启用KCM套接字的接收。当接收被禁用时，套接字接收缓冲区中的任何待处理消息将移至其他套接字。此功能在应用程序线程知道它将在某个请求上进行大量工作并且暂时无法处理新消息时非常有用。示例用法：

  int val = 1;

  setsockopt(kcmfd, SOL_KCM, KCM_RECV_DISABLE, &val, sizeof(val))

BPF程序用于消息分界
------------------------------------

可以使用BPF LLVM后端编译BPF程序。例如，解析Thrift的BPF程序如下：

  #include "bpf.h" /* 用于__sk_buff */
  #include "bpf_helpers.h" /* 用于load_word内联函数 */

  SEC("socket_kcm")
  int bpf_prog1(struct __sk_buff *skb)
  {
       return load_word(skb, 0) + 4;
  }

  char _license[] SEC("license") = "GPL";

在应用程序中的使用
===================

KCM加速了应用层协议。具体来说，它允许应用程序使用基于消息的接口发送和接收消息。内核提供了必要的保证，确保消息原子地发送和接收。这大大减轻了应用程序在将基于消息的协议映射到TCP流时的负担。KCM还将应用层消息作为内核中的工作单元，用于路由和调度，从而在多线程应用程序中实现更简单的网络模型。
配置
--------------

在Nx1配置中，KCM逻辑上为同一TCP连接提供多个套接字句柄。这允许在TCP套接字上的I/O操作之间实现并行性（例如数据的复制输入和复制输出被并行化）。在一个应用程序中，可以为每个处理线程打开一个KCM套接字，并将其插入epoll（类似于使用SO_REUSEPORT允许多个监听套接字在同一端口上）。
在MxN配置中，与同一目的地建立多个连接。这些连接用于简单的负载均衡。
消息批处理
----------------

KCM的主要目的是在KCM套接字之间以及线程间进行负载均衡，在典型使用案例中。完美的负载均衡，即引导每个接收到的消息到不同的KCM套接字或引导每个发送的消息到不同的TCP套接字，可能会降低性能，因为这不允许建立亲和力。基于组或消息批次的负载平衡对性能有益。
在发送过程中，应用程序可以通过三种方式在KCM套接字上批量（流水线）消息：
1) 在单个sendmmsg中发送多个消息
2) 发送一组消息，每条消息都通过一次 `sendmsg` 调用发送，其中除了最后一条消息外，其他所有消息的 `sendmsg` 调用中都包含 `MSG_BATCH` 标志。
3) 创建一个由多条消息组成的“超级消息”，并通过一次 `sendmsg` 调用发送这个“超级消息”。
在接收时，KCM 模块试图在每次 TCP 就绪回调期间将接收到的同一 KCM 套接字上的消息排队。每次在 KCM 套接字上的接收就绪回调时，目标 KCM 套接字会改变。应用程序无需对此进行配置。

错误处理
--------------

应用程序应包括一个线程来监控在 TCP 连接上引发的错误。通常，这可以通过将每个与 KCM 复用器关联的 TCP 套接字放入用于 `POLLERR` 事件的 epoll 集合中来实现。如果关联的 TCP 套接字上发生错误，KCM 会在该套接字上设置 `EPIPE` 从而唤醒应用程序线程。当应用程序看到错误（可能是断开连接）时，应从 KCM 中卸载该套接字并关闭它。假设一旦 TCP 套接字上出现错误，则数据流不可恢复（即可能在接收消息的过程中发生了错误）。

TCP 连接监控
-------------------------

在 KCM 中没有手段将消息与其用于发送或接收的 TCP 套接字相关联（除非只有一个关联的 TCP 套接字）。然而，应用程序保留了对套接字的打开文件描述符，因此可以从套接字获取统计信息，这些信息可用于检测问题（例如高重传率）。
