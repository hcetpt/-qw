### SPDX 许可证标识符: GPL-2.0

#### IP Sysctl

**/proc/sys/net/ipv4/** 变量
=================================

`ip_forward` - 布尔值
- 0 - 禁用（默认）
- 非0 - 启用

在接口间转发数据包。此变量特殊，更改它会将所有配置参数重置为默认状态（对于主机遵循 RFC1122，对于路由器遵循 RFC1812）。

`ip_default_ttl` - 整数
默认TTL字段（生存时间）的值，适用于发送出去的数据包（但不包括转发的数据包）。该值应在1到255之间（含）。
默认值：64（根据 RFC1700 推荐）

`ip_no_pmtu_disc` - 整数
禁用路径MTU发现。如果设置为模式1，并且接收到需要分片的ICMP报文，则到该目的地的PMTU将被设为之前到该目的地的MTU和最小PMTU（见下文）中的较小值。如果你希望避免本地生成的分片，你需要手动将最小PMTU提升至系统中最小的接口MTU。
在模式2中，传入的路径MTU发现消息会被丢弃。传出帧的处理方式与模式1相同，即每个创建的套接字都隐式设置了 `IP_PMTUDISC_DONT`。
模式3是一种强化的PMTU发现模式。内核仅当底层协议能够通过除了简单的套接字查找之外的方式验证分片需求错误时才会接受这些错误。目前支持的协议有TCP、SCTP 和 DCCP，因为它们可以验证序列号或关联信息。此模式不应全局启用，而是仅用于保护特定场景下的名称服务器（如命名空间），在这种情况下TCP路径MTU必须工作，但其他协议的路径MTU信息应被丢弃。如果全局启用此模式，可能会破坏其他协议。
可能的值：0-3

默认值：FALSE

`min_pmtu` - 整数
默认值552 - 最小路径MTU。除非手动更改，否则每个缓存的pmtu都不会低于这个设置。
`ip_forward_use_pmtu` - 布尔值
默认情况下，在转发时我们不会信任协议路径MTU，因为它们很容易被伪造，并可能导致路由器不必要的分片。
只有当您有用户空间软件尝试自行发现路径MTU并依赖内核对此信息的尊重时，才需要启用此选项。通常这不是必需的。
默认值：0（禁用）

可能的值：

- 0 - 禁用
- 1 - 启用

`fwmark_reflect` - 布尔值
控制内核生成的未与套接字关联的IPv4回复数据包的 `fwmark`（例如，TCP RST 或 ICMP 回显回复）。
如果不设置，则这些数据包的 `fwmark` 为零。如果设置，则它们具有其所回复数据包的 `fwmark`。
默认值：0

fib_multipath_use_neigh - 布尔值
在确定多路径路由的下一跳时使用现有邻居条目的状态。如果禁用，则不会使用邻居信息，数据包可能会被导向失败的下一跳。仅对启用了CONFIG_IP_ROUTE_MULTIPATH编译配置的内核有效。
默认值：0（禁用）

可能的值：

- 0 - 禁用
- 1 - 启用

fib_multipath_hash_policy - 整数
控制用于多路径路由的哈希策略。仅对启用了CONFIG_IP_ROUTE_MULTIPATH编译配置的内核有效。
默认值：0（第三层）

可能的值：

- 0 - 第三层
- 1 - 第四层
- 2 - 如果存在则为第三层或内部第三层
- 3 - 自定义多路径哈希。用于多路径哈希计算的字段由fib_multipath_hash_fields sysctl确定

fib_multipath_hash_fields - 无符号整数
当fib_multipath_hash_policy设置为3（自定义多路径哈希）时，用于多路径哈希计算的字段由这个sysctl确定。
此值是一个位掩码，用于启用多路径哈希计算中的各种字段。
可能的字段包括：

====== ============================
0x0001 源IP地址
0x0002 目标IP地址
0x0004 IP协议
0x0008 未使用（流标签）
0x0010 源端口
0x0020 目标端口
0x0040 内部源IP地址
0x0080 内部目标IP地址
0x0100 内部IP协议
0x0200 内部流标签
0x0400 内部源端口
0x0800 内部目标端口
====== ============================

默认值：0x0007（源IP、目标IP和IP协议）

fib_multipath_hash_seed - 无符号整数
用于计算多路径路由哈希的种子值。适用于IPv4和IPv6数据路径。仅对启用了CONFIG_IP_ROUTE_MULTIPATH编译配置的内核有效。
设置为0时，默认使用的种子值为内核内部随机生成的值。
实际的哈希算法没有指定——无法保证给定种子产生的下一跳分布会在不同内核版本间保持稳定。
默认值：0（随机）

fib_sync_mem - 无符号整数
在强制同步rcu之前可以积压的来自FIB条目的脏内存数量。
默认值：512kB 最小值：64kB 最大值：64MB

ip_forward_update_priority - 整数
转发后是否从IPv4报头的"TOS"字段更新SKB优先级。新的SKB优先级根据rt_tos2priority表（参见例如tc-prio手册页）映射自TOS字段的值。
默认值：1（更新优先级）

可能的值：

- 0 - 不更新优先级
- 1 - 优先级更新
route/max_size - 整数
    允许内核中的最大路由数量。当使用大量接口和/或路由时，请增加此值。
    从 Linux 内核 3.6 开始，对于 IPv4 这个设置已废弃，
    因为不再使用路由缓存。
    从 Linux 内核 6.3 开始，对于 IPv6 这个设置已废弃，
    因为垃圾回收管理缓存的路由条目。

neigh/default/gc_thresh1 - 整数
    最小保留条目数量。如果条目少于这个数量，垃圾回收器不会清除条目。
    默认：128

neigh/default/gc_thresh2 - 整数
    当垃圾回收器变得更加积极地清除条目时的阈值。当超过这个数量时，超过 5 秒的旧条目将被清除。
    默认：512

neigh/default/gc_thresh3 - 整数
    允许的最大非永久邻居条目数量。当使用大量接口以及与大量直接连接的对等方通信时，请增加此值。
    默认：1024

neigh/default/unres_qlen_bytes - 整数
    其他网络层为每个未解析地址排队的包所使用的最大字节数量（从 Linux 3.3 版本开始添加）

    设置负数值没有意义，并将返回错误。
    默认：SK_WMEM_MAX，（与 net.core.wmem_default 相同）
确切的值取决于架构和内核选项，但应该足够允许队列化256个中等大小的数据包。

`neigh/default/unres_qlen` - 整数
对于每个未解析地址，其他网络层可以队列的最大数据包数量。
（在Linux 3.3中已废弃）：请改用`unres_qlen_bytes`
在Linux 3.3之前，默认值为3，这可能会导致意外的数据包丢失。当前默认值根据`unres_qlen_bytes`的默认值和真实数据包大小计算得出。
默认值：101

`neigh/default/interval_probe_time_ms` - 整数
具有`NTF_MANAGED`标志的邻居条目的探测间隔，最小值为1。
默认值：5000

`mtu_expires` - 整数
缓存的路径最大传输单元(PMTU)信息保存的时间，以秒为单位。

`min_adv_mss` - 整数
所通告的最大段大小(MSS)依赖于第一跳路由的最大传输单元(MTU)，但不会低于此设置。

`fib_notify_on_flag_change` - 整数
是否在`RTM_F_OFFLOAD`、`RTM_F_TRAP`或`RTM_F_OFFLOAD_FAILED`标志更改时发送`RTM_NEWROUTE`通知。
安装路由到内核后，用户空间会收到确认消息，这意味着该路由已在内核中安装，但不一定在硬件中安装。
已安装在硬件中的路由也可能改变其行为，从而改变其标志。例如，捕获数据包的主机路由可以在安装IPinIP/VXLAN隧道后被“提升”以执行解封装操作。
通知将指示用户空间路由的状态。
默认值：0（不发送通知。）

    可能的值：

    - 0 - 不发送通知
    - 1 - 发送通知
    - 2 - 仅在RTM_F_OFFLOAD_FAILED标志变化时发送通知
IP 分片：

ipfrag_high_thresh - 长整型
    用于重组 IP 分片的最大内存
ipfrag_low_thresh - 长整型
    （自 Linux 4.17 版本起已废弃）
    在内核开始移除不完整的分片队列以释放资源前，用于重组 IP 分片的最大内存
    内核仍然接受新的分片进行重组
ipfrag_time - 整型
    在内存中保存 IP 分片的时间（秒数）
ipfrag_max_dist - 整型
    ipfrag_max_dist 是一个非负整数值，定义了具有相同 IP 源地址的分片之间允许的最大“无序”程度。需要注意的是，数据包的重新排序并不罕见，但如果大量分片从某个源 IP 地址到达而特定分片队列仍不完整，则可能表明该队列中的一个或多个分片已经丢失。当 ipfrag_max_dist 设置为正值时，在分片被添加到重组队列之前会进行额外检查——如果从某个特定 IP 地址到达的分片数量与任何使用该源地址的 IP 分片队列的最近一次添加之间的差距达到 ipfrag_max_dist（或更多），则认为队列中有一个或多个分片丢失。现有的分片队列将被丢弃，并启动一个新的队列。ipfrag_max_dist 的值为零禁用此检查。
使用非常小的值（例如 1 或 2）作为 ipfrag_max_dist 可能会导致在正常的数据包重新排序发生时不必要的丢弃分片队列，这可能导致应用程序性能下降。使用非常大的值（例如 50000）增加了错误地重组源自不同 IP 数据报的 IP 分片的可能性，这可能导致数据损坏。
默认值：64

bc_forwarding - 整数
bc_forwarding 启用 rfc1812#section-5.3.5.2 和 rfc2644 中描述的功能。
它允许路由器转发定向广播。
要启用此功能，'all' 项和输入接口项 应设置为 1
默认值：0

INET 对等存储
==============
inet_peer_threshold - 整数
存储的大致大小。从这个阈值开始，将积极地丢弃条目。
此阈值还决定了条目的存活时间（TTL）以及垃圾回收周期之间的时间间隔。
更多的条目意味着更短的存活时间，更短的垃圾回收间隔
inet_peer_minttl - 整数
条目的最小存活时间。应该足够长以覆盖重组端的分片存活时间。
如果池大小小于 inet_peer_threshold，则保证该最小存活时间
单位：秒
inet_peer_maxttl - 整数
条目的最大存活时间。在没有内存压力的情况下（即当池中的条目数量非常少时），未使用的条目将在这一时间段后过期。
单位：秒
TCP 变量
==========
somaxconn - 整数
socket listen() 队列的最大长度，在用户空间中称为 SOMAXCONN
默认值为 4096。（在 linux-5.4 之前为 128）
另见 tcp_max_syn_backlog，用于对 TCP 套接字进行额外调整
### tcp_abort_on_overflow - BOOLEAN
如果监听服务接收新连接的速度过慢，
则重置这些连接。默认状态为 FALSE。这意味着如果由于突发导致溢出，
连接将恢复。仅在确信监听守护进程无法调整以更快地接受连接时启用此选项。启用此选项可能会损害服务器的客户端。

### tcp_adv_win_scale - INTEGER
自 Linux-6.6 起已废弃
根据 2^tcp_adv_win_scale 计算缓冲开销（如果 tcp_adv_win_scale > 0）或根据 bytes-bytes/2^(-tcp_adv_win_scale) 计算，如果它小于等于 0。
可能的值范围是 [-31, 31]，包括边界值。
默认值：1

### tcp_allowed_congestion_control - STRING
显示/设置非特权进程可用的拥塞控制选择。该列表是 tcp_available_congestion_control 列表的子集。
默认值为 "reno" 并且是默认设置 (tcp_congestion_control)。

### tcp_app_win - INTEGER
为应用缓冲区预留最大值(window/2^tcp_app_win, mss) 的窗口大小。值 0 是特殊的，意味着不保留任何空间。
可能的值范围是 [0, 31]，包括边界值。
默认值：31

### tcp_autocorking - BOOLEAN
启用 TCP 自动合并：
当应用程序进行连续的小写(write())/sendmsg() 系统调用时，
尽量将这些小写操作合并，以减少发送的总包数。这在至少有一个先前的数据包在 Qdisc 队列或设备传输队列中等待时执行。应用程序仍然可以使用 TCP_CORK 来优化它们知道何时解除合并的行为。
默认值：1

### tcp_available_congestion_control - STRING
显示注册的可用拥塞控制选择。
更多的拥塞控制算法可能作为模块提供，但未加载。
以下是提供的英文描述及其翻译成中文的版本：

- `tcp_base_mss` - 整数型
    初始的 `search_low` 值，用于分组层进行路径最大传输单元（MTU）发现（MTU 探测）。如果启用了 MTU 探测，则这是连接使用的初始最大段大小（MSS）。
    
- `tcp_mtu_probe_floor` - 整数型
    如果启用了 MTU 探测，则该值设定了连接中用于 `search_low` 的最小 MSS。
    
    默认值：48

- `tcp_min_snd_mss` - 整数型
    TCP SYN 和 SYNACK 消息通常会宣传一个 ADVMSS 选项，如 RFC 1122 和 RFC 6691 中所描述。如果这个 ADVMSS 选项小于 `tcp_min_snd_mss`，则其将被静默地限制为 `tcp_min_snd_mss` 的值。
    
    默认值：48（每段至少 8 字节的有效载荷）

- `tcp_congestion_control` - 字符串型
    设置新连接所使用的拥塞控制算法。算法 “reno” 总是可用的，但根据内核配置还可能有其他选择。
    
    默认值由内核配置设定。
    
    对于被动连接，监听器的拥塞控制选择会被继承。
    
    [参见 setsockopt(listenfd, SOL_TCP, TCP_CONGESTION, "name" ...) ]

- `tcp_dsack` - 布尔型
    允许 TCP 发送“重复”的 SACK（选择性确认）。

- `tcp_early_retrans` - 整数型
    尾部丢失探测（TLP）将由于尾部丢失导致的重传时间间隔（RTO）转换为快速恢复（参见草案 IETF-TCPM-RACK）。请注意，TLP 需要 RACK 正常工作（参见下面的 `tcp_recovery`）。
    
    可能的值：
    
        - 0 禁用 TLP
        - 3 或 4 启用 TLP
    
    默认值：3

- `tcp_ecn` - 整数型
    控制 TCP 使用显式拥塞通知（ECN）的方式。
    ECN 仅在 TCP 连接的两端均表明支持时使用。此功能有助于通过允许支持 ECN 的路由器在丢弃数据包之前发出拥塞信号来避免因拥塞而导致的数据丢失。
可能的值为：

        =  =====================================================
    0  禁用ECN。既不发起也不接受ECN
    1  当收到的连接请求启用ECN时启用ECN，
           并在发出的连接尝试中也请求ECN
    2  当收到的连接请求启用ECN时启用ECN，
           但不在发出的连接中请求ECN
        =  =====================================================

默认值：2

tcp_ecn_fallback - 布尔值
如果内核检测到ECN连接行为异常，则启用回退到非ECN模式。目前，此选项实现了RFC3168第6.1.1.1节中的回退机制，但我们保留将来在此选项下实现其他检测机制的权利。如果禁用了tcp_ecn或按路由（或拥塞控制）设置的ECN，则此值不会被使用。
默认值：1（启用回退）

tcp_fack - 布尔值
这是一个遗留选项，不再有任何效果。
tcp_fin_timeout - 整数
孤儿连接（不再被任何应用程序引用）处于FIN_WAIT_2状态的时间长度，在本地端终止之前。对于未成为孤儿的连接而言，这是一个完全有效的“仅接收”状态，但若一个孤儿连接处于FIN_WAIT_2状态，则可能永远等待远程端关闭其连接的一端。
参见：tcp_max_orphans

默认值：60秒

tcp_frto - 整数
启用根据RFC5682定义的Forward RTO-Recovery（F-RTO）。F-RTO是一种增强的TCP重传超时恢复算法。它尤其有益于RTT波动的网络（例如，无线网络）。F-RTO仅修改发送方的行为，并不需要接收方的支持。默认情况下启用，非零值表示启用。0表示禁用F-RTO。
tcp_fwmark_accept - 布尔值
如果设置，对于没有socket标记的监听套接字上的传入连接，将把传入的SYN包的fwmark设置为接受套接字的标记。这会导致该连接上所有包（从第一个SYNACK开始）都带有该fwmark发送。监听套接字的标记不变。已经通过setsockopt(SOL_SOCKET, SO_MARK, ...)设置了fwmark的监听套接字不受影响。
默认值：0

tcp_invalid_ratelimit - 整数
限制发送重复确认的最大速率，这些确认是针对现有连接中收到的无效TCP数据包作出的响应。这些数据包被视为无效的原因可能包括：

(a) 序列号超出窗口范围，
(b) 确认号超出窗口范围，或
(c) PAWS（防止序列号回绕保护）检查失败。

这有助于缓解简单的“确认循环”拒绝服务攻击，在这种攻击中，一个有缺陷或恶意的中间设备或中间人可能会重写TCP头部字段，导致每个端点都认为对方发送的是无效的TCP段，从而导致每一方不断发送针对这些无效段的重复确认。
设置为0会禁用对无效段响应时的重复确认限速；否则，该值指定发送此类重复确认之间的最小时间间隔，单位为毫秒。
默认值：500（毫秒）
tcp_keepalive_time - 整数
启用keepalive时，TCP发送keepalive消息的频率。
默认值：2小时
tcp_keepalive_probes - 整数
在判断连接已断开之前，TCP发送keepalive探测的次数。
默认值：9
tcp_keepalive_intvl - 整数
发送探测的频率。与tcp_keepalive_probes相乘即为开始发送探测后判定未响应连接超时的时间。
默认值：75秒，即经过大约11分钟的重试后，连接将被终止
tcp_l3mdev_accept - 布尔值
允许子套接字继承L3主设备索引
启用此选项可让“全局”的监听套接字跨越L3主域（例如，VRF）工作，并使从监听套接字派生的已连接套接字绑定到原始数据包所在的L3域。仅当内核编译时启用了CONFIG_NET_L3_MASTER_DEV配置项时有效。
默认值：0（禁用）

tcp_low_latency - 布尔值
这是一个遗留选项，现在已经不再产生任何影响。
### tcp_max_orphans - 整数
系统持有的、未与任何用户文件句柄关联的TCP套接字的最大数量。如果这个数字被超过，孤立的连接将立即被重置，并打印警告信息。此限制仅用于防止简单的拒绝服务（DoS）攻击，你**必须**不要依赖这个限制或人为降低它，而应该在必要时增加它（可能是在增加了安装内存之后），以满足网络条件需要比默认值更多的要求，并调整网络服务以更积极地保持和消除这些状态。再次提醒：每个孤立的套接字会占用高达约64KB不可交换的内存。

### tcp_max_syn_backlog - 整数
记住的连接请求（SYN_RECV）的最大数量，这些请求尚未从连接客户端收到确认。
这是一个监听器级别的限制。
对于低内存机器，最小值是128，并且它将根据机器的内存大小按比例增加。
如果服务器遭受过载，请尝试增加这个数值。
记得也要检查 `/proc/sys/net/core/somaxconn`。
一个SYN_RECV请求套接字大约消耗304字节的内存。

### tcp_max_tw_buckets - 整数
系统同时持有的TIME_WAIT状态的套接字的最大数量。
如果这个数字被超过，TIME_WAIT状态的套接字将立即被销毁，并打印警告信息。此限制仅用于防止简单的拒绝服务（DoS）攻击，你**必须**不要人为降低这个限制，而应该在必要时增加它（可能是在增加了安装内存之后），以满足网络条件需要比默认值更多的要求。

### tcp_mem - 包含3个整数的向量：min（最小值）、pressure（压力值）、max（最大值）
- **min（最小值）**：低于这个页面数时，TCP不会关心其内存消耗。
- **pressure（压力值）**：当TCP分配的内存量超过这个页面数时，TCP会适度控制其内存消耗并进入内存压力模式；当内存消耗降至“min”之下时退出该模式。
最大值：所有TCP套接字允许排队的页面数量  
默认值根据启动时可用内存计算得出。

tcp_min_rtt_wlen - 整数  
窗口化最小RTT跟踪滤波器的窗口长度  
较短的窗口可以让流更快地检测到新的（更高的）最小RTT，当它被转移到更长路径上时（例如，由于流量工程）。较长的窗口使得滤波器更能抵抗RTT膨胀，如瞬态拥塞。单位是秒。  
可能的值：0 - 86400（1天）

默认值：300

tcp_moderate_rcvbuf - 布尔值  
如果设置，TCP执行接收缓冲区自动调整，尝试自动设置缓冲区大小（不超过tcp_rmem[2]），以匹配路径所需的全带宽下的大小。默认情况下启用。

tcp_mtu_probing - 整数  
控制TCP包层路径MTU发现。可取三个值：

- 0 - 禁用
- 1 - 默认禁用，在检测到ICMP黑洞时启用
- 2 - 总是启用，使用初始MSS为tcp_base_mss

tcp_probe_interval - 无符号整数  
控制何时开始TCP包层路径MTU发现重探测。默认每10分钟进行一次重探测，符合RFC4821规定。

tcp_probe_threshold - 整数  
控制TCP包层路径MTU发现探测停止的时间，基于搜索范围宽度（以字节为单位）。默认值为8字节。

tcp_no_metrics_save - 布尔值  
默认情况下，TCP在连接关闭时将各种连接指标保存在路由缓存中，以便将来建立的连接可以使用这些信息来设置初始条件。通常，这会提高整体性能，但有时会导致性能下降。如果设置，则TCP不会在关闭连接时缓存指标。

tcp_no_ssthresh_metrics_save - 布尔值  
控制TCP是否在路由缓存中保存ssthresh指标。
默认值为 1，这会禁用 ssthresh 指标。
tcp_orphan_retries - 整数
此值会影响本地已关闭的 TCP 连接的超时时间，当重传的 RTO 未得到确认时。
有关更多详情，请参阅 tcp_retries2。
默认值为 8。
如果你的机器是一台负载较高的 WEB 服务器，
你应当考虑降低该值，因为这样的套接字
可能会消耗大量资源。参考 tcp_max_orphans。
tcp_recovery - 整数
此值是一个位图，用于启用各种实验性的丢包恢复功能。
=========   =============================================================
RACK: 0x1   启用 RACK 丢包检测以快速检测丢失的重传和尾部丢包。同时它也包含了并禁用了 RFC6675 中为 SACK 连接定义的恢复机制。
RACK: 0x2   使 RACK 的重排序窗口保持固定（最小 RTT 的四分之一）。
RACK: 0x4   禁用 RACK 的 DUPACK 阈值启发式算法。
=========   =============================================================

默认值：0x1

tcp_reflect_tos - 布尔值
对于监听套接字，重新使用初始 SYN 消息中的 DSCP 值用于传出数据包。这允许 TCP 流的两个方向都使用相同的 DSCP 值，假设在整个连接期间 DSCP 值保持不变。
此选项同时影响 IPv4 和 IPv6。
默认：0（禁用）

tcp_reordering - 整数
TCP 流中数据包初始的重排序级别
TCP 栈可以动态调整此初始值与 tcp_max_reordering 之间的流重排序级别

默认：3

tcp_max_reordering - 整数
TCP 流中数据包的最大重排序级别
300 是一个相对保守的值，但如果你的路径使用了逐包负载均衡（如轮询模式下的绑定），你可能需要增加这个值

默认：300

tcp_retrans_collapse - 布尔值
与某些故障打印机进行 bug-to-bug 兼容性处理
在重传时尝试发送更大的数据包以绕过某些 TCP 栈中的 bug

tcp_retries1 - 整数
该值影响 TCP 判断由于未被确认的重传超时 (RTO) 数据导致出现问题，并将此怀疑报告给网络层所需的时间
请参阅 tcp_retries2 获取更多详细信息
RFC 1122 推荐至少进行 3 次重传，这是默认值

tcp_retries2 - 整数
该值影响当 RTO 重传未被确认时存活的 TCP 连接的超时时间
假设 N 为该值，一个初始 RTO 为 TCP_RTO_MIN 的假想 TCP 连接将在第 (N+1) 次 RTO 之前重传 N 次，然后断开连接
默认值 15 导致的假想超时时间为 924.6 秒，这是实际超时时间的下限
TCP将在第一个超过假设超时时间的RTO（重传超时）处有效超时。

RFC 1122建议超时时间为至少100秒，这对应于一个至少为8的值。

tcp_rfc1337 - 布尔型
如果设置，则TCP堆栈遵循RFC1337的行为。如果没有设置，则我们不遵循RFC，但可以防止TCP TIME_WAIT的攻击。
默认值：0

tcp_rmem - 包含3个整数的向量：最小值、默认值、最大值
最小值：TCP套接字使用的接收缓冲区的最小大小
即使在适度的内存压力下，也保证每个TCP套接字都有此大小的接收缓冲区。
默认值：4K

默认值：TCP套接字使用的接收缓冲区的初始大小
此值会覆盖由其他协议使用的`net.core.rmem_default`。
默认值：131072字节
此值导致初始窗口为65535
最大值：自动选择的TCP套接字接收缓冲区允许的最大大小。此值不会覆盖`net.core.rmem_max`。通过调用setsockopt()并使用SO_RCVBUF参数将禁用该套接字接收缓冲区大小的自动调整，在这种情况下，此值将被忽略。
默认：在 131072 和 6MB 之间，具体取决于 RAM 大小  
tcp_sack - 布尔值  
启用选择性确认（SACK）  
tcp_comp_sack_delay_ns - 长整型  
TCP 尝试通过使用基于 SRTT 的 5% 的定时器来减少发送的 SACK 数量，该定时器受此系统控制调节，单位为纳秒。默认值为 1ms，基于 TSO 自动调整周期  
默认：1,000,000 纳秒（1 毫秒）  

tcp_comp_sack_slack_ns - 长整型  
此系统控制调节用于设置 SACK 压缩所用定时器的余量。这为小 RTT 流提供了额外的时间，并通过允许适时减少定时器中断来降低系统开销  
默认：100,000 纳秒（100 微秒）  

tcp_comp_sack_nr - 整型  
可以压缩的最大 SACK 数量  
使用 0 禁用 SACK 压缩  
默认：44  

tcp_backlog_ack_defer - 布尔值  
如果设置，则处理套接字队列时尝试发送一个 ACK 来确认整个队列。这有助于避免在 TCP 套接字系统调用结束时可能出现的长时间延迟  
默认：true  

tcp_slow_start_after_idle - 布尔值  
如果设置，则提供 RFC2861 行为，在空闲一段时间后使拥塞窗口超时。空闲时间定义为当前 RTO。如果没有设置，则在空闲期后不会使拥塞窗口超时  
默认：1  

tcp_stdurg - 布尔值  
使用主机需求对 TCP 紧急指针字段的解释
大多数主机使用较旧的BSD解释方式，因此如果你开启此选项，
Linux可能无法与它们正确通信。
默认值：FALSE

tcp_synack_retries - 整数
对于被动TCP连接尝试，SYNACK将重传的次数。
不应高于255。默认值为5，对应于在当前1秒初始RTO的情况下，
最后一次重传前等待31秒。因此，被动TCP连接的最终超时时间为63秒。
tcp_syncookies - 整数
仅当内核编译时启用了CONFIG_SYN_COOKIES配置项时有效。
当套接字的SYN待处理队列溢出时发送syncookies。
这是为了防止常见的“SYN洪泛攻击”。
默认值：1

请注意，syncookies是一种回退机制。
它绝不能用于帮助高负载服务器抵御合法连接速率。
如果你的日志中出现SYN洪泛警告，但调查发现这些警告是因为合法连接过载导致，
你应该调整其他参数直到这个警告消失。
参见：tcp_max_syn_backlog, tcp_synack_retries, tcp_abort_on_overflow
syncookies严重违反了TCP协议，不允许使用TCP扩展，
可能会导致某些服务（如SMTP转发）严重降级，这不会被你直接看到，
而是会被你的客户端和转发方注意到。
如果你在日志中看到SYN洪泛警告但实际上并未受到攻击，说明你的服务器配置严重错误。
如果你想测试syncookies对网络连接的影响，可以将此设置设为2以无条件生成syncookies。
tcp_migrate_req - 布尔值
在三路握手期间接收初始SYN数据包时，传入的连接会绑定到特定的监听套接字。
当监听器关闭时，在握手过程中和accept队列中的已建立套接字将被终止。
如果监听器启用了SO_REUSEPORT，则相同端口上的其他监听器应该能够接受此类连接。
此选项允许在close()或shutdown()后将此类子套接字迁移到另一个监听器。
BPF_SK_REUSEPORT_SELECT_OR_MIGRATE 类型的 eBPF 程序通常应当用于定义选择存活监听器的策略。否则，内核仅在启用此选项时随机选择一个存活的监听器。

请注意，在设置不同的监听器之间进行迁移可能会导致应用程序崩溃。假设迁移从监听器 A 发生到 B，且只有 B 启用了 TCP_SAVE_SYN。B 无法从 A 迁移过来的请求中读取 SYN 数据。为了避免这种情况，请在 BPF 程序类型中返回 SK_DROP 来取消迁移，或者禁用此选项。
默认值：0

tcp_fastopen - 整数
启用 TCP 快速打开（RFC7413）以在初始 SYN 包中发送和接收数据
客户端支持通过标志 0x1 启用（默认开启）。客户端必须使用带有 MSG_FASTOPEN 标志的 sendmsg() 或 sendto() 而不是 connect() 来发送 SYN 中的数据。
服务器支持通过标志 0x2 启用（默认关闭）。然后，可以通过另一个标志 (0x400) 对所有监听器启用，或通过 TCP_FASTOPEN 套接字选项为每个监听器单独启用，选项值表示 SYN 数据队列的长度。
这些值（位图）如下：

- 0x1 (客户端)：在客户端启用发送初始 SYN 中的数据
- 0x2 (服务器)：启用服务器支持，即允许在三路握手完成前接受并传递 SYN 包中的数据给应用
- 0x4 (客户端)：无论是否有 cookie 可用及无需 cookie 选项，在初始 SYN 中发送数据
- 0x200 (服务器)：无需任何 cookie 选项即可接受 SYN 中的数据
0x400 (服务器) 默认启用所有监听器以支持快速开启（Fast Open），无需显式设置TCP_FASTOPEN套接字选项。

=====  ======== ======================================================

默认值：0x1

请注意，额外的客户端或服务器功能仅在分别启用了基本支持（0x1 和 0x2）时才有效。
tcp_fastopen_blackhole_timeout_sec - 整数
当发生TFO防火墙黑洞问题时，在活动TCP套接字上禁用快速开启（Fastopen）的初始时间（秒）。
当检测到更多黑洞问题后快速开启被重新启用时，此时间周期将呈指数增长，并在黑洞问题消失时重置为初始值。
设为0以禁用黑洞检测。
默认情况下，其值为0（功能被禁用）。
tcp_fastopen_key - 由逗号分隔的32位十六进制整数组成的列表
该列表包含一个主密钥和一个可选的备份密钥。主密钥用于创建和验证cookie，而可选的备份密钥仅用于验证cookie。备份密钥的目的在于更换密钥时最大化TFO验证。
如果通过sysctl设置tcp_fastopen，并将其设置为0x400（见上文），或者设置了TCP_FASTOPEN setsockopt() optname且之前未通过sysctl配置过密钥，则内核可能会随机选择一个主密钥进行配置。如果通过setsockopt()使用TCP_FASTOPEN_KEY optname配置了密钥，则将使用这些每个套接字的密钥，而不是通过sysctl指定的任何密钥。
密钥表示为4个8位十六进制整数，中间用“-”分隔：xxxxxxxx-xxxxxxxx-xxxxxxxx-xxxxxxxx。可以省略前导零。可以通过逗号分隔来指定主密钥和备份密钥。如果只指定了一个密钥，则它将成为主密钥，并且会移除任何先前配置的备份密钥。
tcp_syn_retries - 整数
对于主动TCP连接尝试，初始SYN报文将被重传的次数。不应高于127。默认值为6，对应于67秒（当tcp_syn_linear_timeouts=4时），直到最后一次重传，基于当前1秒的初始RTO。
对于活跃的TCP连接尝试，最终的超时时间将在131秒后发生。
tcp_timestamps - 整数
    根据RFC1323启用时间戳
- 0: 禁用
- 1: 根据RFC1323启用时间戳，并为每个连接使用随机偏移量，而不仅仅是使用当前时间
- 2: 类似于1，但不使用随机偏移量
默认值: 1

tcp_min_tso_segs - 整数
    每个TSO帧中的最小分段数量
自Linux 3.12以来，TCP会根据流量速率自动调整TSO帧的大小，而不是填充64K字节的数据包
对于特定用途，可以强制TCP构建大型TSO帧。需要注意的是，如果可用窗口太小，TCP堆栈可能会拆分过大的TSO数据包
默认值: 2

tcp_tso_rtt_log - 整数
    基于min_rtt调整TSO数据包大小

    自Linux 5.18开始，可以根据具有较小RTT的流量微调TCP自动调整大小功能
旧版自动调整大小功能将发送速率预算分割开来，以每秒发送1024个TSO数据包
`tso_packet_size = sk->sk_pacing_rate / 1024;`

使用新机制时，我们通过以下方式增加此 TSO 分组大小：

`distance = min_rtt_usec / (2^tcp_tso_rtt_log)`
`tso_packet_size += gso_max_size >> distance;`

这意味着距离非常近的主机之间的流量可以使用更大的 TSO 分组，从而降低它们的 CPU 成本。
如果你想使用旧的自动调整大小机制，请将此 sysctl 设置为 0。
默认值：9 （2^9 = 512 微秒）

`tcp_pacing_ss_ratio` - 整数
`sk->sk_pacing_rate` 由 TCP 栈根据当前速率设置（当前速率 = cwnd * mss / srtt）。
如果 TCP 处于慢启动阶段，则应用 `tcp_pacing_ss_ratio` 来让 TCP 探测更高的速度，假设每过一个往返时间 (RTT)，cwnd 可以翻倍。
默认值：200

`tcp_pacing_ca_ratio` - 整数
`sk->sk_pacing_rate` 由 TCP 栈根据当前速率设置（当前速率 = cwnd * mss / srtt）。
如果 TCP 处于拥塞避免阶段，则应用 `tcp_pacing_ca_ratio` 来保守地探测更高的吞吐量。
默认值：120

`tcp_syn_linear_timeouts` - 整数
对于主动 TCP 连接，在采用指数退避超时之前重传 SYN 的次数，并使用线性退避超时。这不会影响被动 TCP 一侧的 SYNACK。
例如，初始 RTO 为 1 并且 `tcp_syn_linear_timeouts = 4` 时，我们期望的 SYN RTO 将是：1, 1, 1, 1, 1, 2, 4, ... （4 次线性退避超时，以及首次使用 2^0 * 初始 RTO 的指数退避）
默认值：4

`tcp_tso_win_divisor` - 整数
此参数允许控制单个 TSO 帧可以消耗拥塞窗口的百分比。
设置此参数是在突发性和构建更大 TSO 帧之间做出选择。
默认值：3

`tcp_tw_reuse` - 整数
启用在安全的情况下对 TIME-WAIT 状态套接字进行复用以用于新的连接：
- 0 - 禁用
- 1 - 全局启用
- 2 - 仅对回环流量启用

未经技术专家建议/请求不应更改此设置。
默认值：2

tcp_window_scaling - 布尔值
启用根据 RFC1323 定义的窗口缩放功能
tcp_shrink_window - 布尔值
此选项会改变 TCP 接收窗口的计算方式
根据 RFC 7323 第 2.4 节，存在某些情况下可以提供回缩的窗口，并且 TCP 实现必须确保能够处理窗口缩小的情况，如 RFC 1122 中所指定的那样
- 0 - 禁用。窗口永远不会缩小
- 1 - 启用。当需要保持在自动调整（sk_rcvbuf）设置的内存限制内时，窗口将被缩小
这仅在设置了非零的接收窗口缩放因子的情况下发生
默认值：0

tcp_wmem - 包含 3 个整数的向量：最小值、默认值、最大值
最小值：为 TCP 套接字预留的发送缓冲区内存数量
每个 TCP 套接字因为其创建而有权使用它
默认值：4K

默认值：TCP 套接字使用的初始发送缓冲区大小。这个值会覆盖其他协议使用的 net.core.wmem_default 值
通常比 net.core.wmem_default 的值要小
默认值：16K

最大值：为TCP套接字的自动调谐发送缓冲区允许的最大内存数量。此值不会覆盖 `net.core.wmem_max`。通过 `SO_SNDBUF` 调用 `setsockopt()` 禁用该套接字发送缓冲区大小的自动调谐，在这种情况下，此值将被忽略。
默认值：介于64K和4MB之间，取决于RAM大小
`tcp_notsent_lowat` - 无符号整数
TCP套接字可以通过 `TCP_NOTSENT_LOWAT` 套接字选项来控制其写队列中的未发送字节数量。如果未发送字节数量低于每个套接字的值，并且写队列未满，则 `poll()` / `select()` / `epoll()` 将报告 `POLLOUT` 事件。如果达到限制，`sendmsg()` 也不会添加新的缓冲区。
此全局变量控制未使用 `TCP_NOTSENT_LOWAT` 的套接字的未发送数据量。对于这些套接字，全局变量的更改会立即生效。
默认值：`UINT_MAX`（0xFFFFFFFF）

`tcp_workaround_signed_windows` - 布尔值
如果设置，则假设未收到窗口缩放选项意味着远程TCP存在问题，并将窗口视为有符号数量。
如果没有设置，则即使我们未从他们那里收到窗口缩放选项，也假设远程TCP没有问题。
默认值：0

`tcp_thin_linear_timeouts` - 布尔值
启用针对细流的线性超时动态触发。
如果设置，则在因超时而重传时执行检查以确定流是否较细（飞行中的数据包少于4个）。
只要发现流较细，可以在进入指数退避模式之前执行最多6次线性超时。这改善了非激进细流的重传延迟，这些流通常与时间相关。
有关细流的更多信息，请参阅 `Documentation/networking/tcp-thin.rst`

默认值：0

`tcp_limit_output_bytes` - 整数
控制每个TCP套接字的TCP小队列限制。
TCP批量发送器倾向于增加飞行中的数据包数量，直到它收到丢包通知。使用SNDBUF自动调谐时，这可能导致本地机器上有大量数据包被排队（例如：队列管理器、CPU积压或设备），对于典型的pfifo_fast队列管理器而言，这会损害其他流的延迟。`tcp_limit_output_bytes`限制了队列管理器或设备上的字节数量，以减少人工RTT/cwnd并降低缓冲膨胀。
默认值：1048576（16 * 65536）

`tcp_challenge_ack_limit` - 整数
限制每秒发送的挑战ACK的数量，如RFC 5961（提高TCP对盲窗口攻击的鲁棒性）所推荐。需要注意的是，这个按网络命名空间限定的速率可能允许某些旁道攻击，并且可能不应该启用。TCP堆栈无论如何都实现了每个TCP套接字的限制。
默认值：INT_MAX（无限制）

`tcp_ehash_entries` - 整数
显示当前网络命名空间中TCP套接字的哈希桶数量。
负值表示该网络命名空间不拥有自己的哈希桶，并共享初始网络命名空间的一个。
`tcp_child_ehash_entries` - 整数
控制子网络命名空间中TCP套接字的哈希桶数量，必须在clone()或unshare()之前设置。
如果该值不是0，则内核将使用向上取整到2^n的实际哈希桶大小。0是一个特殊值，意味着子网络命名空间将共享初始网络命名空间的哈希桶。
需要注意的是，如果内核无法分配足够的内存，子级将使用全局哈希桶。此外，全局哈希桶分布在可用的NUMA节点上，但子哈希表的分配取决于当前进程的NUMA策略，这可能会导致性能差异。
还需要注意的是，`tcp_max_tw_buckets`和`tcp_max_syn_backlog`的默认值依赖于哈希桶大小。
可能的值：0, 2^n （n: 0 - 24 (16Mi)）

默认值：0

`tcp_plb_enabled` - 布尔值
如果设置并且底层拥塞控制（例如DCTCP）支持并启用了PLB特性，则启用TCP PLB（保护性负载均衡）。PLB在以下论文中进行了描述：https://doi.org/10.1145/3544216.3544226。根据PLB参数，在检测到持续拥塞时，TCP触发对外出IPv6数据包的流标签字段的更改。流标签字段的更改可能会改变使用ECMP/WCMP进行路由的交换机中外出数据包的路径。
PLB（Packet Load Balancing）会改变套接字的txhash，从而导致IPv6流标签字段发生变化，并且目前对IPv4头部不起作用。有可能通过其他网络头部字段（例如TCP或IPv4选项）或者使用外层头部由交换机来确定下一跳的方式应用PLB到IPv4上。无论哪种情况，都需要进一步修改主机和交换机侧。

当启用时，PLB假设拥塞信号（例如ECN）被提供并被拥塞控制模块用来估计一个拥塞度量（例如ce_ratio）。PLB需要拥塞度量来做出重新选路决策。
默认值：FALSE

`tcp_plb_idle_rehash_rounds` - 整数
连续观察到的拥塞轮次（往返时间）数量，在没有飞行中的数据包的情况下可以执行重新哈希操作。
这在PLB论文中被称为M：
https://doi.org/10.1145/3544216.3544226
可能的值：0 - 31

默认值：3

`tcp_plb_rehash_rounds` - 整数
连续观察到的拥塞轮次（往返时间）数量后可以强制执行重新哈希操作。设置此参数时要小心，因为较小的值会增加重传的风险。
这在PLB论文中被称为N：
https://doi.org/10.1145/3544216.3544226
可能的值：0 - 31

默认值：12

`tcp_plb_suspend_rto_sec` - 整数
发生重传超时(RTO)事件时暂停PLB的时间（秒数）。为了避免让PLB重新选路到一个“黑洞”连接性问题，在发生RTO后，TCP连接会随机暂停PLB重新选路一段时间，该时间范围为这个参数的1倍至2倍之间。添加随机性是为了避免多个TCP连接同时重新哈希。此参数应根据修复失败链路所需的时间进行设置。
可能的值：0 - 255

默认值：60

`tcp_plb_cong_thresh` - 整数
在一个轮次（往返时间）内标记为拥塞的数据包比例，用以标记该轮次是否为拥塞状态。这在PLB论文中被称为K：
https://doi.org/10.1145/3544216.3544226
0-1的比例范围映射到0-256的整数范围，以避免浮点运算。例如，128意味着如果一个轮次中至少50%的数据包被标记为拥塞，则该轮次将被视为拥塞状态。
将阈值设置为0意味着PLB每一轮往返时间都会重新选路，不论是否存在拥塞。这不是PLB预期的行为，仅用于实验目的。
### 可能的值：0 - 256

**默认值：128**

`tcp_pingpong_thresh` - 整数
- 对于估计的传入数据请求，需要发送的大致数据响应数量，该数量必须达到某个阈值后，TCP 才会认为连接为“乒乓”（请求-响应）连接，从而可以从中受益使用延迟确认。
- 此阈值默认为 1，但对于某些应用来说，为了获得最佳性能可能需要更高的阈值。
- **可能的值：1 - 255**
- **默认值：1**

`tcp_rto_min_us` - 整数
- TCP 最小重传超时时间（以微秒计）。请注意，rto_min 路由选项对于配置此设置具有最高优先级，其次是 TCP_BPF_RTO_MIN 套接字选项，再次是此 `tcp_rto_min_us` 系统调用。
- 推荐的做法是使用小于或等于 200000 微秒的值。
- **可能的值：1 - INT_MAX**
- **默认值：200000**

### UDP 变量
#### `udp_l3mdev_accept` - 布尔值
- 启用此选项允许一个“全局”绑定的套接字在 L3 主域（例如，VRFs）中工作，接收的数据包无论其起源于哪个 L3 域都可被接收。仅当内核编译时包含 CONFIG_NET_L3_MASTER_DEV 配置时有效。
- **默认值：0（禁用）**

`udp_mem` - 包含 3 个整数的向量：最小值、压力值、最大值
- 允许所有 UDP 套接字用于队列的页面数量。
- **最小值**：所有 UDP 套接字用于队列的页面数量。
- **压力值**：此值引入是为了遵循 tcp_mem 的格式。
- **最大值**：此值引入是为了遵循 tcp_mem 的格式。
- **默认值**：根据可用内存量在启动时计算得出。
### UDP 相关变量

#### udp_rmem_min - INTEGER
- UDP 套接字在适度使用时的接收缓冲区最小尺寸。
- 每个 UDP 套接字能够用于接收数据的尺寸，即使所有 UDP 套接字的总页数超过了 `udp_mem` 压力阈值也是如此。
- 单位：字节
- 默认值：4K

#### udp_wmem_min - INTEGER
- UDP 不具备发送内存会计功能，因此此可调参数没有效果。

#### udp_hash_entries - INTEGER
- 显示当前网络命名空间中 UDP 套接字哈希桶的数量。
- 负数值表示该网络命名空间不拥有自己的哈希桶，并且共享初始网络命名空间中的哈希桶。

#### udp_child_ehash_entries - INTEGER
- 控制子网络命名空间中 UDP 套接字哈希桶的数量，必须在 `clone()` 或 `unshare()` 之前设置。
- 如果值非 0，则内核会使用向上取整到 2 的 n 次幂的实际哈希桶大小。0 是一个特殊值，表示子网络命名空间将共享初始网络命名空间的哈希桶。
- 如果内核无法分配足够的内存，子进程将会使用全局哈希表。此外，全局哈希桶分布在可用的 NUMA 节点上，但子哈希表的分配取决于当前进程的 NUMA 策略，这可能会导致性能差异。
- 可能的值：0、2^n（n：7 (128) - 16 (64K)）
- 默认值：0

### RAW 变量

#### raw_l3mdev_accept - BOOLEAN
- 启用此选项允许“全局”绑定的套接字跨 L3 主域（例如，VRF）工作，可以接收来自任意 L3 域的数据包。仅当内核编译时启用了 CONFIG_NET_L3_MASTER_DEV 配置项时有效。
- 默认值：1（启用）

### CIPSOv4 变量

#### cipso_cache_enable - BOOLEAN
- 如果设置，启用添加至和从 CIPSO 标签映射缓存的查找操作。如果未设置，添加操作被忽略，查找操作总是返回未命中。然而，无论设置如何，当需要时缓存仍然会被无效化，这意味着您可以安全地开启或关闭此选项，而缓存始终是“安全”的。
默认值：1

cipso_cache_bucket_size - 整数
CIPSO 标签缓存由固定大小的哈希表组成，每个哈希桶包含若干个缓存条目。此变量限制了每个哈希桶中的条目数量；值越大，则能缓存的 CIPSO 标签映射越多。当特定哈希桶中的条目数量达到这个限制时，添加新条目会导致该桶中最旧的条目被移除以腾出空间。
默认值：10

cipso_rbm_optfmt - 布尔值
启用 CIPSO 草案规范（请参阅 Documentation/netlabel 了解详细信息）第 3.4.2.6 节中定义的“优化标签 1 格式”。这意味着在设置后，CIPSO 标签将通过填充空类别来使数据包数据对齐至 32 位。
默认值：0

cipso_rbm_structvalid - 布尔值
如果已设置，在调用 ip_options_compile() 时会对 CIPSO 选项进行非常严格的检查。如果未设置，则在 ip_options_compile() 进行期间会放宽这些检查。无论哪种方式都是“安全”的，因为错误会在 CIPSO 处理代码的其他地方被捕获，但将此设置为 0（False）应该会导致较少的工作（即应该更快），但可能会导致与其他需要严格检查的实现产生问题。
默认值：0

IP 变量
==========

ip_local_port_range - 2 个整数
定义了 TCP 和 UDP 选择本地端口时所使用的本地端口范围。第一个数字是起始端口号，第二个数字是结束端口号。
如果可能的话，这些数字最好具有不同的奇偶性（一个为偶数，一个为奇数）。
必须大于或等于 ip_unprivileged_port_start。
默认值分别为 32768 和 60999。
ip_local_reserved_ports - 逗号分隔的范围列表
指定为已知第三方应用程序保留的端口。这些端口不会被自动端口分配使用（例如，在调用 connect() 或 bind() 时使用端口号 0）。显式端口分配行为不变。
输入和输出格式均为逗号分隔的范围列表（例如，“1,2-4,10-10”表示端口 1、2、3、4 和 10）。向文件写入内容将清除所有先前保留的端口，并使用输入中给出的列表更新当前列表。
请注意，`ip_local_port_range` 和 `ip_local_reserved_ports` 的设置是相互独立的，并且内核在确定哪些端口可用于自动端口分配时会同时考虑这两个设置。
您可以预留当前 `ip_local_port_range` 之外的端口，例如：

    $ cat /proc/sys/net/ipv4/ip_local_port_range
    32000 60999
    $ cat /proc/sys/net/ipv4/ip_local_reserved_ports
    8080,9148

尽管这样做有些多余，但如果之后更改端口范围，使其包括这些预留端口，则这种设置是有用的。同时请注意，这些范围重叠可能会影响选择紧接预留端口块之后的临时端口的概率。
默认值：空

`ip_unprivileged_port_start` - 整数
这是一个按命名空间配置的系统控制参数。它定义了网络命名空间中的第一个非特权端口。绑定到特权端口需要具有root权限或`CAP_NET_BIND_SERVICE`能力。
要禁用所有特权端口，可以将其设置为0。它们不应与`ip_local_port_range`重叠。
默认值：1024

`ip_nonlocal_bind` - 布尔值
如果设置，允许进程绑定到非本地IP地址，这有时非常有用，但也可能会导致某些应用程序出现问题。
默认值：0

`ip_autobind_reuse` - 布尔值
默认情况下，bind() 即使新的套接字和所有绑定到该端口的套接字都设置了SO_REUSEADDR也不会自动选择端口。
`ip_autobind_reuse` 允许bind()重用端口，这对于使用bind()+connect()的情况很有用，但也可能会导致某些应用程序出现问题。
更推荐的做法是使用`IP_BIND_ADDRESS_NO_PORT`，并且此选项应仅由专家级用户设置。
默认值：0

`ip_dynaddr` - 整数
如果设置为非零值，则启用动态地址支持。
如果设置为大于1的非零值，当发生动态地址重写时，内核日志中将打印一条消息。
默认值：0

ip_early_demux - 布尔值
优化输入数据包处理，减少到仅一个解复用操作以适用于某些类型的本地套接字。目前我们仅对此进行优化
针对已建立的TCP和已连接的UDP套接字。
这可能会为纯路由工作负载增加额外开销，从而降低整体吞吐量，在这种情况下你应该禁用它。
默认值：1

ping_group_range - 2 个整数
限制ICMP_PROTO数据报套接字的用户组范围
默认设置是“1 0”，这意味着任何人都不能（即使是root用户）创建ping套接字。将其设置为“100 100”将授权给单个组。“0 4294967294”将对所有用户开放，“100
4294967294”将对普通用户开放，但不包括守护进程。
tcp_early_demux - 布尔值
启用已建立TCP套接字的早期解复用功能。
默认值：1

udp_early_demux - 布尔值
启用已连接UDP套接字的早期解复用功能。如果
你的系统可能会经历更多的未连接负载，请禁用此功能。
默认值：1

icmp_echo_ignore_all - 布尔值
如果设置为非零，则内核将忽略所有发送给它的ICMP ECHO
请求。
默认值：0

icmp_echo_enable_probe - 布尔值
如果设置为1，则内核将响应发送给它的RFC 8335 PROBE
请求。
默认值：0

icmp_echo_ignore_broadcasts - 布尔值
如果设置为非零，则内核将忽略所有通过广播/多播发送给它的ICMP ECHO和
TIMESTAMP请求。
默认值：1

icmp_ratelimit - 整数
限制发送与icmp_ratemask（见下文）匹配类型的ICMP数据包到特定目标的最大速率。
禁用任何限制，请设置为0，
否则，设置响应之间的最小间隔（以毫秒为单位）。
注意另一个sysctl参数，`icmp_msgs_per_sec` 限制了发送到所有目标的ICMP数据包的数量。
默认值：1000

`icmp_msgs_per_sec` - 整数
限制从本机每秒发送的最大ICMP数据包数量。
只有类型与`icmp_ratemask`（见下文）匹配的消息才会受到此限制。出于安全原因，每秒消息的确切计数会被随机化。
默认值：1000

`icmp_msgs_burst` - 整数
`icmp_msgs_per_sec` 控制每秒发送的ICMP数据包数量，而 `icmp_msgs_burst` 控制这些数据包的突发大小。
出于安全原因，确切的突发大小会被随机化。
默认值：50

`icmp_ratemask` - 整数
用于限定速率的ICMP类型的掩码。
重要位：IHGFEDCBA9876543210

默认掩码：0000001100000011000 (6168)

位定义（参见 include/linux/icmp.h）：

- = =========================
- 0 Echo Reply
- 3 Destination Unreachable [1]_
- 4 Source Quench [1]_
- 5 Redirect
- 8 Echo Request
- B Time Exceeded [1]_
- C Parameter Problem [1]_
- D Timestamp Request
- E Timestamp Reply
- F Info Request
- G Info Reply
- H Address Mask Request
- I Address Mask Reply
- = =========================

.. [1] 这些默认情况下被限速（参见上面的默认掩码）

`icmp_ignore_bogus_error_responses` - 布尔值
一些路由器违反RFC1122的规定，向广播帧发送错误的响应。这种违规行为通常会通过内核警告记录下来。
如果设置为TRUE，内核将不会给出此类警告，这可以避免日志文件杂乱无章。
默认值：1

`icmp_errors_use_inbound_ifaddr` - 布尔值

如果为零，则ICMP错误消息将以退出接口的主要地址发送。
如果该值非零，则会使用触发 ICMP 错误的数据包所经过接口的主地址来发送消息。
这是许多网络管理员期望从路由器获得的行为。并且它可以让复杂的网络布局调试变得容易得多。
需要注意的是，如果选定接口没有主地址存在，则无论此项设置如何，都会使用第一个拥有主地址的非回环接口的主地址。
默认值：0

igmp_max_memberships - 整数
更改我们可以订阅的多播组最大数量
默认值：20

理论上的最大值受限于必须在一个数据报中发送成员报告（即报告不能跨越多个数据报，否则可能会使交换机混淆并离开你无意退出的组）
支持的组的数量 M 受限于你能放入一个 65535 字节大小的数据报中的组报告条目数量
M = (65536 - IP 头部大小) / (组记录大小)

组记录长度可变，最小为 12 字节
因此 `net.ipv4.igmp_max_memberships` 的值不应高于：

(65536 - 24) / 12 = 5459

值 5459 假设 IP 头部没有选项，因此在实际应用中这个数字可能更低
igmp_max_msf - 整数
允许在多播组源过滤列表中的地址最大数量
默认值：10

igmp_qrv - 整数
控制 IGMP 查询鲁棒性变量（参见 RFC2236 第 8.1 节）
默认值：2（根据RFC2236 8.1规定）

最小值：1（根据RFC6636 4.5规定）

force_igmp_version - 整数
- 0 - （默认）不强制使用特定的IGMP版本，允许回退到IGMPv1/v2。如果所有IGMPv1/v2查询器存在定时器过期，则将恢复到IGMPv3模式。
- 1 - 强制使用IGMP版本1。接收到IGMPv2/v3查询时也会回复IGMPv1报告。
- 2 - 强制使用IGMP版本2。接收到IGMPv1查询消息时会回退到IGMPv1。接收到IGMPv3查询时回复报告。
- 3 - 强制使用IGMP版本3。与默认值0的行为相同。

注意：
这与force_mld_version不同，因为IGMPv3（RFC3376）的安全考虑中没有明确说明可以完全忽略其他版本的消息，如同MLDv2（RFC3810）。因此建议将此值设为默认值0。

`conf/interface/*`
针对每个网络接口更改特殊设置（其中“interface”是您的网络接口名称）

`conf/all/*`
特别地，针对所有接口更改设置

log_martians - 布尔值
记录包含不可能地址的数据包至内核日志
如果`conf/{all,interface}/log_martians`至少有一个被设置为TRUE，则接口的log_martians将启用；否则禁用。

accept_redirects - 布尔值
接受ICMP重定向消息
对于接口，如果满足以下条件之一，accept_redirects将启用：
- 当接口的转发功能启用时，`conf/{all,interface}/accept_redirects`均为TRUE
- 当接口的转发功能禁用时，`conf/{all,interface}/accept_redirects`至少有一个为TRUE
否则，accept_redirects将禁用。

默认值：
- TRUE（主机）
- FALSE（路由器）

forwarding - 布尔值
在此接口上启用IP转发。这控制了是否可以转发在该接口上接收的数据包。

mc_forwarding - 布尔值
执行多播路由。内核需要编译CONFIG_MROUTE，并且需要一个多播路由守护进程。
要为接口启用多播路由，`conf/all/mc_forwarding`也必须设置为TRUE。

medium_id - 整数
用于通过它们所连接的介质区分设备的整数值。当只在一个设备上接收广播数据包时，两个设备可以有不同的ID值。
默认值 0 表示该设备是其介质上唯一的接口，值 -1 表示介质未知。
目前，它被用来改变代理 ARP 的行为：
当两个设备连接到不同的介质时，代理 ARP 功能将对转发的报文启用。

proxy_arp - 布尔值
执行代理 ARP
如果 conf/{all,interface}/proxy_arp 中至少有一个设置为 TRUE，则将为接口启用代理 ARP；否则将禁用代理 ARP。

proxy_arp_pvlan - 布尔值
私有 VLAN 代理 ARP
基本上允许代理 ARP 回复返回到同一接口（即接收 ARP 请求/查询的接口）。
这是为了支持像 RFC 3069 这样的以太网交换机特性，在这些特性中，各端口不允许互相通信，但允许与上游路由器通信。如 RFC 3069 所述，可以通过代理 ARP 实现这些主机通过上游路由器进行通信。无需与代理 ARP 配合使用。
这项技术有不同的名称：

- 在 RFC 3069 中被称为 VLAN 聚合
- Cisco 和 Allied Telesyn 称之为私有 VLAN
- Hewlett-Packard 称之为源端口过滤或端口隔离
- Ericsson 称之为 MAC 强制转发（RFC 草案）
### 参数说明

- **proxy_delay** - 整型数值  
  延迟代理响应  
  当启用了`proxy_arp`或`proxy_ndp`时，延迟对邻居请求的响应。将选择一个[0, `proxy_delay`)之间的随机值；设置为0表示无延迟响应。  
  单位：节拍(jiffies)  
  默认值：80  

- **shared_media** - 布尔型数值  
  发送（路由器）或接受（主机）RFC1620共享介质重定向  
  覆盖`secure_redirects`设置  
  如果`conf/{all,interface}/shared_media`中的至少一个被设置为`TRUE`，则该接口的`shared_media`将被启用；否则，将被禁用。  
  默认值：`TRUE`

- **secure_redirects** - 布尔型数值  
  只接受当前网关列表中列出的网关发送的ICMP重定向消息。即使被禁用，RFC1122重定向规则仍然适用。  
  被`shared_media`覆盖  
  如果`conf/{all,interface}/secure_redirects`中的至少一个被设置为`TRUE`，则该接口的`secure_redirects`将被启用；否则，将被禁用。  
  默认值：`TRUE`

- **send_redirects** - 布尔型数值  
  如果是路由器，则发送重定向消息  
  如果`conf/{all,interface}/send_redirects`中的至少一个被设置为`TRUE`，则该接口的`send_redirects`将被启用；否则，将被禁用。  
  默认值：`TRUE`

- **bootp_relay** - 布尔型数值  
  接受源地址为0.b.c.d且目的地址非本机的包作为本地包处理。假定BOOTP中继守护进程将会捕获并转发此类包。  
  必须将`conf/all/bootp_relay`设置为`TRUE`以在接口上启用BOOTP中继。  
  默认值：`FALSE`  

  注意：此功能尚未实现。
### accept_source_route - BOOLEAN
接收带有SRR选项的数据包  
`conf/all/accept_source_route` 必须同样设置为 `TRUE` 才能在接口上接收带有SRR选项的数据包。

**默认值**

    - TRUE（路由器）
    - FALSE（主机）

### accept_local - BOOLEAN
接收具有本地源地址的数据包。结合合适的路由，可以使用此功能将数据包通过线路从两个本地接口之间转发，并确保它们被正确接收。
**默认值** `FALSE`

### route_localnet - BOOLEAN
在进行路由时，不将回环地址视为火星源或目标地址。这使得可以在本地路由目的中使用 127/8 地址。
**默认值** `FALSE`

### rp_filter - INTEGER
- 0 - 不进行源验证
- 1 - 根据 RFC3704 定义的严格模式：每个传入的数据包都会与 FIB（Forwarding Information Base）进行比对，如果接口不是最佳的反向路径，则数据包检查将失败
  默认情况下，失败的数据包会被丢弃
- 2 - 根据 RFC3704 定义的宽松模式：每个传入的数据包的源地址也会与 FIB 进行比对，如果源地址无法通过任何接口到达，则数据包检查将失败
  根据 RFC3704 的当前推荐做法是启用严格模式以防止来自DDoS攻击的IP欺骗。如果使用不对称路由或其他复杂的路由方案，则建议使用宽松模式
`conf/{all,interface}/rp_filter` 中的最大值用于在 `{interface}` 上执行源验证。
**默认值** 是 0。请注意，某些发行版会在启动脚本中启用它。
### `src_valid_mark` - BOOLEAN
- **0** - 数据包的`fwmark`不包含在反向路径路由查找中。这允许不对称路由配置仅在一个方向上使用`fwmark`，例如，透明代理。
- **1** - 数据包的`fwmark`包含在反向路径路由查找中。这使得当`fwmark`用于双向流量路由时`rp_filter`能够正常工作。
此设置还影响在为ICMP回复执行源地址选择或确定IPOPT_TS_TSANDADDR和IPOPT_RR IP选项中存储的地址时`fwmark`的使用。

`conf/{all,interface}/src_valid_mark`中的最大值被使用。
默认值是**0**。

### `arp_filter` - BOOLEAN
- **1** - 允许您在同一子网上拥有多个网络接口，并根据内核是否会从该接口路由ARP请求的IP地址的数据包来回答每个接口的ARP（因此需要使用基于源的路由才能使这项功能生效）。换句话说，它允许控制哪张网卡（通常是一张）会响应ARP请求。
- **0** - （默认）内核可以响应其他接口上的地址的ARP请求。这可能看起来不正确，但通常是有意义的，因为它增加了成功通信的可能性。
在Linux上，IP地址属于整个主机，而不是特定的接口。只有在更复杂的设置如负载均衡时，这种行为才会导致问题。

如果`conf/{all,interface}/arp_filter`至少有一个设置为TRUE，则接口上的`arp_filter`将启用；否则，将禁用。

### `arp_announce` - INTEGER
定义通过接口发送的ARP请求中本地源IP地址的不同限制级别：

- **0** - （默认）使用任何本地地址，无论配置在哪个接口上。
- **1** - 尝试避免使用不属于目标子网的本地地址。当通过此接口可达的目标主机要求ARP请求中的源IP地址必须是接收接口逻辑网络的一部分时，此模式很有用。当我们生成请求时，我们会检查所有包含目标IP的子网，并保留来自这些子网之一的源地址。如果没有这样的子网，则根据级别2的规则选择源地址。
- **2** - 总是使用针对该目标的最佳本地地址。
在此模式下，我们忽略IP数据包中的源地址，并尝试选择我们更倾向于与目标主机通信的本地地址。这样的本地地址是通过查找所有出站接口子网上的主IP地址来选定的，这些地址包含目标IP地址。如果找不到合适的本地地址，我们会选择出站接口上的第一个本地地址，或者在其他所有接口上选择一个本地地址，希望这样能够收到对我们请求的回复，有时甚至不管我们所声明的源IP地址。

`conf/{all,interface}/arp_announce` 中的最大值被使用。
提高限制级别增加了从解析的目标接收到回答的可能性，而降低级别则宣布了更多有效的发送者信息。

`arp_ignore` - 整数类型
定义响应接收到的ARP请求的不同模式，这些请求用于解析本地目标IP地址：

- 0 - （默认）：对任何配置在任意接口上的本地目标IP地址作出响应
- 1 - 只有当目标IP地址是入站接口上配置的本地地址时才作出响应
- 2 - 只有当目标IP地址是入站接口上配置的本地地址，并且发送者的IP地址也属于该接口上的同一子网时才作出响应
- 3 - 不对配置为主机作用域的本地地址作出响应，仅对全局和链路作用域的地址解析作出响应
- 4-7 - 预留
- 8 - 对所有本地地址都不作出响应

接收到ARP请求时，`conf/{all,interface}/arp_ignore` 中的最大值会被使用。

`arp_notify` - 布尔类型
定义地址和设备更改的通知模式：
==  ==========================================================
  0  （默认）：不执行任何操作
  1  当设备启动或硬件地址发生变化时，生成免费ARP请求
==  ==========================================================

`arp_accept` - 整数类型
定义处理来自不在ARP表中的设备发送的免费ARP（garp）帧的行为：

- 0 - 不在ARP表中创建新条目
- 1 - 在ARP表中创建新条目
- 2 - 只有当源IP地址位于接收garp消息的接口上配置的地址所在的同一子网内时，在ARP表中创建新条目
无论响应还是请求类型的免费ARP都会触发ARP表更新，如果启用了此设置的话。
如果ARP表已经包含了免费ARP帧中的IP地址，则无论是否启用此设置，ARP表都会被更新。

`arp_evict_nocarrier` - 布尔类型
在NOCARRIER事件发生时清除ARP缓存。对于无线设备来说，此选项非常重要，因为当在网络内的不同接入点之间漫游时不应清除ARP缓存。大多数情况下应保持默认设置（1）：
- 1 - （默认）：在NOCARRIER事件发生时清除ARP缓存
- 0 - 不在NOCARRIER事件发生时清除ARP缓存

`mcast_solicit` - 整数类型
未知关联硬件地址的不完整状态下的最大多播探测次数，默认为3。
### 参数翻译及说明

- `ucast_solicit` - 整数类型
  - 当需要重新确认硬件地址时，处于`PROBE`状态下的最大单播探测次数。
  - 默认值为3。

- `app_solicit` - 整数类型
  - 在回退到多播探测（参见`mcast_resolicit`）之前，通过`netlink`发送给用户空间ARP守护进程的最大探测次数。
  - 默认值为0。

- `mcast_resolicit` - 整数类型
  - 经过单播和应用层探测后，在`PROBE`状态下进行的最大多播探测次数。
  - 默认值为0。

- `disable_policy` - 布尔类型
  - 禁用此接口的IPSec策略（SPD）。

- `disable_xfrm` - 布尔类型
  - 无论策略如何，禁用此接口上的IPSec加密。

- `igmpv2_unsolicited_report_interval` - 整数类型
  - 下一次未请求的IGMPv1或IGMPv2报告重传的时间间隔（以毫秒为单位）。
  - 默认值：10000（10秒）。

- `igmpv3_unsolicited_report_interval` - 整数类型
  - 下一次未请求的IGMPv3报告重传的时间间隔（以毫秒为单位）。
  - 默认值：1000（1秒）。

- `ignore_routes_with_linkdown` - 布尔类型
  - 在执行FIB查找时忽略链路已关闭的路由。

- `promote_secondaries` - 布尔类型
  - 当从该接口移除主IP地址时，提升相应的次级IP地址而不是移除所有对应的次级IP地址。

- `drop_unicast_in_l2_multicast` - 布尔类型
  - 丢弃在链路层多播（或广播）帧中收到的所有单播IP数据包。
  - 此行为（针对多播）实际上是RFC 1122中的推荐行为，但默认情况下为了兼容性原因被禁用。
  - 默认值：关（0）。

- `drop_gratuitous_arp` - 布尔类型
  - 丢弃所有无偿ARP帧，例如在网络中有已知良好的ARP代理时，这些帧可能不需要使用（或者在802.11的情况下，必须不使用以防止攻击）。
  - 默认值：关（0）。

- `tag` - 整数类型
  - 允许您写入一个数字，该数字可以按需使用。
默认值为 0  
xfrm4_gc_thresh - 整数  
（自 Linux-4.14 起已废弃）  
开始对 IPv4 目的地缓存条目进行垃圾回收的阈值。当达到该值的两倍时，系统将拒绝新的分配。  
igmp_link_local_mcast_reports - 布尔值  
启用针对链路本地多播组 (224.0.0.X 范围) 的 IGMP 报告。  
默认：TRUE  

作者：  
Alexey Kuznetsov  
kuznet@ms2.inr.ac.ru  

更新者：  

- Andi Kleen  
  ak@muc.de  
- Nicolas Delon  
  delon.nicolas@wanadoo.fr  


/proc/sys/net/ipv6/* 变量  
==============================  

IPv6 没有像 tcp_* 这样的全局变量。tcp_* 设置在 ipv4/ 下也适用于 IPv6 [XXX?]  
bindv6only - 布尔值  
IPV6_V6ONLY 套接字选项的默认值，该选项限制 IPv6 套接字仅用于 IPv6 通信。  
- TRUE: 禁用 IPv4 映射地址功能  
  - FALSE: 启用 IPv4 映射地址功能  

默认：FALSE（如 RFC3493 所规定）

flowlabel_consistency - 布尔值  
保护流标签的一致性和唯一性  
要使用流标签管理器上的 IPV6_FL_F_REFLECT 标志，必须禁用此选项  
- TRUE: 已启用  
  - FALSE: 已禁用  

默认：TRUE

auto_flowlabels - 整数  
根据包的流哈希自动生成流标签。这允许中间设备（如路由器）识别数据包流以实现等成本多路径路由等机制（参见 RFC 6438）  
=  ===========================================================  
 0  完全禁用自动流标签  
 1  默认启用自动流标签，可以使用 IPV6_AUTOFLOWLABEL 套接字选项在每个套接字的基础上禁用它们  
 2  允许自动流标签，可以在每个套接字的基础上使用 IPV6_AUTOFLOWLABEL 套接字选项启用它们  
 3  启用并强制执行自动流标签，不能通过套接字选项禁用它们  
=  ===========================================================  

默认：1

flowlabel_state_ranges - 布尔值  
将流标签号空间分为两个范围。0-0x7FFFF 保留给 IPv6 流管理设施，0x80000-0xFFFFF 保留给无状态流标签（如 RFC6437 中所述）。
- TRUE: 启用  
- FALSE: 禁用  

默认值：true

flowlabel_reflect - 整数  
控制流标签反射。这对于等成本多路径路由中的任播环境中路径最大传输单元（MTU）发现功能至关重要。请参阅RFC 7690以及：  
https://tools.ietf.org/html/draft-wang-6man-flow-label-reflection-01  

这是一个位掩码：  
- 1: 对于已建立的流启用  

      需要注意的是，这会阻止自动更改流标签的行为，就像在“TCP: 在接收到错误重传时更改IPv6流标签”和“TCP: 每次SYN和重传超时时改变txhash”中所做的那样。  
- 2: 对于TCP RESET数据包（无活动监听器）  
      如果设置，则对于关闭端口上的SYN数据包响应发送的RST数据包将反映传入的流标签。  
- 4: 对于ICMPv6回声应答消息  
默认值：0

fib_multipath_hash_policy - 整数  
控制用于多路径路由的哈希策略  
默认值：0（第三层）

可能的值：
- 0 - 第三层（源地址、目标地址加上流标签）
- 1 - 第四层（标准五元组）
- 2 - 如果存在则为第三层或内部第三层
- 3 - 自定义多路径哈希。用于多路径哈希计算的字段由`fib_multipath_hash_fields` sysctl确定

fib_multipath_hash_fields - 无符号整数  
当`fib_multipath_hash_policy`设置为3（自定义多路径哈希）时，用于多路径哈希计算的字段由这个sysctl决定  
此值是一个位掩码，它指定了各种用于多路径哈希计算的字段  
可能的字段包括：

| 值 | 字段 |
|---|---|
| 0x0001 | 源IP地址 |
| 0x0002 | 目标IP地址 |
| 0x0004 | IP协议 |
| 0x0008 | 流标签 |
| 0x0010 | 源端口 |
| 0x0020 | 目标端口 |
| 0x0040 | 内部源IP地址 |
| 0x0080 | 内部目标IP地址 |
| 0x0100 | 内部IP协议 |
| 0x0200 | 内部流标签 |
| 0x0400 | 内部源端口 |
| 0x0800 | 内部目标端口 |

默认值：0x0007（源IP、目标IP和IP协议）

anycast_src_echo_reply - 布尔值  
控制是否使用任播地址作为ICMPv6回声应答的源地址  

- TRUE: 启用  
- FALSE: 禁用  

默认值：FALSE

idgen_delay - 整数  
控制在检测到DAD冲突后重试隐私稳定地址生成之前的延迟秒数  
默认值：1（如RFC7217所指定）

idgen_retries - 整数  
控制在检测到DAD冲突后尝试生成稳定隐私地址的次数  
默认值：3（如RFC7217所指定）

mld_qrv - 整数  
控制MLD查询鲁棒性变量（参见RFC3810 9.1）  
默认值：2（根据RFC3810 9.1指定）  

最小值：1（根据RFC6636 4.5指定）

max_dst_opts_number - 整数  
目标选项扩展头中允许的最大非填充TLV数量。如果该值小于零，则不允许未知选项，并且允许的已知TLV的数量为此数值的绝对值。
默认值：8

max_hbh_opts_number - 整数
在逐跳选项扩展头中允许的最大非填充TLV数量。如果此值小于零，则不允许未知选项，并且允许的已知TLV数量为此数值的绝对值。
默认值：8

max_dst_opts_length - 整数
目标选项扩展头允许的最大长度。
默认值：INT_MAX（无限制）

max_hbh_length - 整数
逐跳选项扩展头允许的最大长度。
默认值：INT_MAX（无限制）

skip_notify_on_dev_down - 布尔值
控制是否为设备被移除或删除时所移除的路由生成RTM_DELROUTE消息。IPv4不生成此类消息；IPv6默认情况下会生成。将此系统控制设置为true可以忽略该消息，从而使IPv4和IPv6在依赖用户空间缓存追踪链路事件并清除路由方面保持一致。
默认值：false（生成消息）

nexthop_compat_mode - 布尔值
新的下一跳API提供了一种独立于前缀管理下一跳的方法。默认启用了与旧路由格式的向后兼容性，这意味着路由转储和通知包含新的下一跳属性，同时也包含完整的、扩展的下一跳定义。此外，更新或删除下一跳配置会产生针对使用该下一跳的每个FIB条目的路由通知。一旦系统理解了新API，可以通过禁用此系统控制来获得新API的全部性能优势，即通过禁用下一跳扩展和多余的通告。
默认值：true（向后兼容模式）

fib_notify_on_flag_change - 整数
是否在RTM_F_OFFLOAD/RTM_F_TRAP/RTM_F_OFFLOAD_FAILED标志发生变化时发送RTM_NEWROUTE通知
安装路由到内核后，用户空间会收到确认信息，这表明路由已在内核中安装，但不一定在硬件中安装。
已经安装在硬件中的路由也可能改变其动作，从而改变其标志。例如，一个正在捕获数据包的主机路由可以在安装IPinIP/VXLAN隧道后被“提升”以执行解封装操作。
这些通知会向用户空间指示路由的状态。
默认值：0（不发送通知）

可能的值：

- 0 - 不发送通知
- 1 - 发送通知
- 2 - 仅在RTM_F_OFFLOAD_FAILED标志更改时发送通知

`ioam6_id` - 整型
定义此节点的IOAM ID。总共使用32位中的24位
最小值：0
最大值：0xFFFFFF

默认值：0xFFFFFF

`ioam6_id_wide` - 长整型
定义此节点的宽IOAM ID。总共使用64位中的56位。可以与`ioam6_id`不同
最小值：0
最大值：0xFFFFFFFFFFFFFF

默认值：0xFFFFFFFFFFFFFF

IPv6 分片：

`ip6frag_high_thresh` - 整型
用于重新组装IPv6分片的最大内存。当为此目的分配了`ip6frag_high_thresh`字节的内存时，分片处理程序将丢弃数据包直到达到`ip6frag_low_thresh`
`ip6frag_low_thresh` - 整型
参见`ip6frag_high_thresh`

`ip6frag_time` - 整型
保存IPv6分片在内存中的时间（秒）

`conf/default/*`：
更改接口特定的默认设置
这些设置将在创建新接口时使用
`conf/all/*`：
更改所有接口特定的设置
[XXX: 除了转发之外的其他特殊功能？]

`conf/all/disable_ipv6` - 布尔值
    更改此值等同于更改 `conf/default/disable_ipv6` 设置，同时也将所有接口级别的 `disable_ipv6` 设置为相同的值。
    读取此值并无特定含义。它并不能说明 IPv6 支持是否被启用或禁用。返回的值在某些接口设置 `disable_ipv6` 为 0 并配置了 IPv6 地址的情况下也可能为 1。

`conf/all/forwarding` - 布尔值
    启用所有接口之间的全局 IPv6 转发。
    IPv4 和 IPv6 在这里的工作方式不同；例如，必须使用 netfilter 来控制哪些接口可以转发数据包，哪些不可以。
    这也会将所有接口的“主机/路由器”设置中的 “forwarding” 设置为指定的值。详细信息请参阅下方。
    这被称为全局转发。

`proxy_ndp` - 布尔值
    执行代理邻居发现协议 (NDP)。

`fwmark_reflect` - 布尔值
    控制内核生成的、与套接字无关的 IPv6 回复数据包（例如 TCP 重置 (RST) 或 ICMPv6 回声回复）的 fwmark。
    如果未设置，则这些数据包的 fwmark 为零。如果已设置，则它们具有与其回复的数据包相同的 fwmark。

默认：0

`conf/interface/*`:
    按每个接口更改特殊设置。
特定设置下的功能行为会根据是否启用了本地转发而有所不同。

`accept_ra` - 整数类型
接收路由器通告；使用它们进行自动配置。
它还决定了是否传输路由器请求。只有当功能设置为接收路由器通告时，才会传输路由器请求。
可能的值为：

        ==  ===========================================================
         0  不接收路由器通告
  1  如果未启用转发，则接收路由器通告
  2  覆盖转发行为。即使转发已启用，也接收路由器通告
 ==  ===========================================================

功能默认设置：

        - 如果未启用本地转发，则启用
- 如果启用了本地转发，则禁用
`accept_ra_defrtr` - 布尔类型
从路由器通告中学习默认路由器
功能默认设置：

        - 如果 `accept_ra` 已启用，则启用
如果 `accept_ra` 被禁用，则禁用。

`ra_defrtr_metric` - 无符号整数
通过路由器通告（Router Advertisement）学习到的默认路由的度量值。此值将被分配给通过IPv6路由器通告学习到的默认路由作为其度量值。仅在 `accept_ra_defrtr` 被启用时生效。
可能的值：
        1 到 0xFFFFFFFF

        默认：IP6_RT_PRIO_USER 即 1024
`accept_ra_from_local` - 布尔值
接受来自本机上找到的源地址的路由器通告（RA），前提是该RA是适当的并且能够被接受。
默认情况下不接受这些RA，因为这可能是非预期的网络环路。
功能默认行为：

       - 如果 `accept_ra_from_local` 在特定接口上被启用，则启用。
       - 如果 `accept_ra_from_local` 在特定接口上被禁用，则禁用。
`accept_ra_min_hop_limit` - 整数
路由器通告中的最小跳数限制信息。
如果路由器通告中的跳数限制信息小于此变量，则忽略该信息。
默认值：1

`accept_ra_min_lft` - 整数
路由器通告中可接受的最小生存时间值。
寿命少于该值的RA（路由器公告）部分应被忽略。寿命为零的情况不受影响。
默认值：0

accept_ra_pinfo - 布尔值
从路由器公告中学习前缀信息
功能默认值：

        - 如果启用了accept_ra，则启用
- 如果未启用accept_ra，则禁用
ra_honor_pio_life - 布尔值
是否使用RFC4862第5.5.3e节来确定与路由器公告中的前缀信息选项匹配的地址的有效寿命
- 如果启用，将始终遵循PIO有效寿命
- 如果禁用，将根据RFC4862第5.5.3e节来确定地址的有效寿命
默认值：0（禁用）

accept_ra_rt_info_min_plen - 整数
路由器公告中路由信息的最小前缀长度
具有小于此变量所指定前缀长度的路由信息将被忽略
功能默认值：

        * 如果启用了accept_ra_rtr_pref，则为0
* -1 如果 `accept_ra_rtr_pref` 被禁用
`accept_ra_rt_info_max_plen` - 整数
    在 RA 中路由信息的最大前缀长度
    当路由信息的前缀大于该变量值时，应当被忽略
    功能默认值：

        * 0 如果 `accept_ra_rtr_pref` 被启用
* -1 如果 `accept_ra_rtr_pref` 被禁用
`accept_ra_rtr_pref` - 布尔值
    接受 RA 中的路由器优先级
    功能默认值：

        - 如果 `accept_ra` 被启用，则启用
- 如果 `accept_ra` 被禁用，则禁用
`accept_ra_mtu` - 布尔值
    应用 RA 选项 5（RFC4861）中指定的 MTU 值。如果
    禁用，RA 中指定的 MTU 将被忽略
    功能默认值：

        - 如果 `accept_ra` 被启用，则启用
翻译为中文：

- 如果 `accept_ra` 被禁用，则禁用。
`accept_redirects` - BOOLEAN
    接受重定向
功能默认值：

    - 如果本地转发被禁用，则启用
    - 如果本地转发被启用，则禁用
`accept_source_route` - 整数
    接受源路由（路由扩展头）
- >= 0：仅接受类型 2 的路由头
- < 0：不接受路由头
默认值：0

`autoconf` - BOOLEAN
    使用路由器广告中的前缀信息自动配置地址
功能默认值：

    - 如果 `accept_ra_pinfo` 被启用，则启用
    - 如果 `accept_ra_pinfo` 被禁用，则禁用
`dad_transmits` - 整数
发送的重复地址检测探测次数
默认值：1

`forwarding` - 整数
配置接口特定的主机/路由器行为
.. 注意::

	   建议在所有接口上设置相同的配置；混合的路由器/主机场景较为少见。
可能的值为：

		- 0 禁用转发
		- 1 启用转发

	**FALSE (0)**:

	默认情况下，假设为主机行为。这意味着：

	1. 在邻居通告中不设置IsRouter标志
2. 如果accept_ra为真（默认），则发送路由器请求
3. 如果accept_ra为真（默认），则接受路由器通告（并进行自动配置）
4. 如果accept_redirects为真（默认），则接受重定向

**TRUE (1)**:

	如果启用了本地转发，则假设为路由器行为。
这意味着与上述情况完全相反：

	1. 在邻居通告中设置了IsRouter标志
2. 除非accept_ra为2，否则不会发送路由器请求
3. 如果`accept_ra`不是2，则忽略路由器通告（Router Advertisements）。
4. 忽略重定向（Redirects）

默认值：如果全局转发被禁用（默认情况），则为0（禁用），否则为1（启用）。

hop_limit - 整数
- 默认的跳数限制
默认值：64

mtu - 整数
- 默认的最大传输单元（Maximum Transmission Unit）

默认值：1280（IPv6要求的最小值）

ip_nonlocal_bind - 布尔值
- 如果设置，允许进程绑定到非本地IPv6地址，这可能会非常有用，但也可能破坏某些应用程序
默认值：0

router_probe_interval - 整数
- 根据RFC4191描述的路由器探测之间的最小时间间隔（以秒为单位）
默认值：60

router_solicitation_delay - 整数
- 接口启动后，在发送路由器请求前等待的时间（以秒为单位）
默认值：1

router_solicitation_interval - 整数
- 发送路由器请求之间等待的时间（以秒为单位）
默认值：4

router_solicitations - 整数
- 在假设没有路由器存在之前要发送的路由器请求次数
默认值：3

use_oif_addrs_only - 布尔值
- 当启用时，通过此接口路由的目的地的候选源地址将仅限于配置在该接口上的地址集（参见RFC 6724第4节）。
默认值：false

use_tempaddr - 整数
	隐私扩展（RFC3041）的偏好设置
* <= 0 ：禁用隐私扩展
	  * == 1 ：启用隐私扩展，但优先使用公共地址而非临时地址
* >  1 ：启用隐私扩展并优先使用临时地址而非公共地址
默认值：

		* 0（对于大多数设备）
		* -1（对于点对点设备和回环设备）

temp_valid_lft - 整数
	临时地址的有效生命周期（以秒为单位）。如果小于所需的最小生命周期（通常为5-7秒），则不会创建临时地址
默认值：172800（2天）

temp_prefered_lft - 整数
	临时地址的首选生命周期（以秒为单位）。如果
	temp_prefered_lft 小于所需的最小生命周期（通常
	为5-7秒），首选生命周期是所需的最小值。如果
	temp_prefered_lft 大于 temp_valid_lft，则首选生命周期为 temp_valid_lft
默认值：86400（1天）

keep_addr_on_down - 整数
	在接口关闭事件时保留所有IPv6地址。如果设置，则静态全局地址即使没有过期时间也不会被清除
*   >0 ：启用
	*    0 ：系统默认值
	*   <0 ：禁用

默认值：0（地址将被移除）

max_desync_factor - 整数
	DESYNC_FACTOR 的最大值，这是一个随机值
	确保客户端不会彼此同步，并在同一时间生成新地址
该值以秒为单位
默认值：600

regen_min_advance - 整数
	在当前地址过时之前至少提前多长时间（以秒为单位）创建新的临时地址。此值会加到可能需要进行重复地址检测的时间上，以确定何时创建新地址。Linux 允许将此值设置为小于默认的2秒，但是小于2的值不符合 RFC 8981 的规定
默认值：2

regen_max_retry - 整数
	尝试生成有效临时地址前的最大重试次数
默认值：5

max_addresses - 整数
每接口的最大自动配置地址数量。设置为零将禁用此限制。不建议将此值设置得过大（或为零），因为这样很容易因允许创建过多的地址而导致内核崩溃。
默认值：16

disable_ipv6 - 布尔值
禁用IPv6操作。如果accept_dad设置为2，并且本地链路地址的重复地址检测(DAD)失败，则此值将动态设置为TRUE。
默认值：FALSE（启用IPv6操作）

当此值从1更改为0（启用IPv6）时，将在指定接口上动态创建一个本地链路地址并启动重复地址检测，如有必要。
当此值从0更改为1（禁用IPv6）时，将在指定接口上动态删除所有地址和路由。从此以后，将无法向选定接口添加地址/路由。

accept_dad - 整数
是否接受DAD（重复地址检测）
== ==============================================================
   0  禁用DAD
   1  启用DAD（默认）
   2  启用DAD，并且如果找到基于MAC的重复本地链路地址，则禁用IPv6操作
== ==============================================================

在给定接口上的DAD操作和模式将根据conf/{all,interface}/accept_dad中的最大值来选择。
force_tllao - 布尔值
即使在响应单播邻居请求时也发送目标链路层地址选项。
默认值：FALSE

引用自RFC 2461第4.4节，目标链路层地址：

“对于多播请求，必须包含该选项以避免无限的邻居请求‘递归’，即当对端节点没有缓存条目以返回邻居通告消息时。对于单播请求的响应，可以省略该选项，因为请求发送方拥有正确的链路层地址；否则它不可能首先发送单播请求。但是，在这种情况下包括链路层地址几乎不会增加开销，并且消除了潜在的竞争条件，即发送方在接收到先前请求的响应之前删除了缓存的链路层地址。”

ndisc_notify - 布尔值
定义通知地址和设备更改的模式
* 0 - （默认）：不做任何事情
* 1 - 当设备被激活或硬件地址发生变化时生成未请求的邻居通告
### ndisc_tclass - 整数
默认用于发送IPv6邻居发现消息（路由器请求、路由器通告、邻居请求、邻居通告、重定向）时使用的IPv6流量类别。
这8位可以被解释为：高6位存储DSCP值，低2位表示ECN（你可能希望保持这两位置零）。
* 0 - （默认）

### ndisc_evict_nocarrier - 布尔值
在NOCARRIER事件发生时清除邻居发现表。对于无线设备而言，此选项很重要，因为在同一网络中漫游时不应清除邻居发现缓存。
大多数情况下，应保留默认设置（1）。
- 1 - （默认）：在NOCARRIER事件时清除邻居发现缓存
- 0 - 在NOCARRIER事件时不清除邻居发现缓存

### mldv1_unsolicited_report_interval - 整数
下次未请求的MLDv1报告重传的时间间隔（以毫秒为单位）。
默认：10000（10秒）

### mldv2_unsolicited_report_interval - 整数
下次未请求的MLDv2报告重传的时间间隔（以毫秒为单位）。
默认：1000（1秒）

### force_mld_version - 整数
* 0 - （默认）不强制特定版本的MLD，允许使用MLDv1回退
* 1 - 强制使用MLD版本1
* 2 - 强制使用MLD版本2

### suppress_frag_ndisc - 整数
控制RFC 6980（IPv6分片与IPv6邻居发现的安全影响）的行为：
* 1 - （默认）丢弃分片的邻居发现数据包
* 0 - 允许分片的邻居发现数据包

### optimistic_dad - 布尔值
是否执行乐观的重复地址检测（RFC 4429）
* 0: 禁用（默认）
* 1: 启用

如果`conf/{all,interface}/optimistic_dad`中的任何一个设置为1，则将启用接口上的乐观重复地址检测；否则禁用。
### `use_optimistic` - 布尔值
如果启用，在源地址选择过程中不会将乐观地址分类为过时。优选地址仍然会在乐观地址之前被选择，前提是符合源地址选择算法中的其他排序规则。
* 0: 禁用（默认）
    * 1: 启用

如果至少有一个配置项 `conf/{all,interface}/use_optimistic` 设置为 1，则此选项将被启用；否则禁用。

### `stable_secret` - IPv6 地址
此 IPv6 地址将作为密钥来生成链路本地地址和自动配置的 IPv6 地址。设置此密钥后生成的所有地址默认将是稳定的隐私地址。可以通过 `addrgenmode ip-link` 来改变这一行为。`conf/default/stable_secret` 用于命名空间内的密钥，特定接口的密钥可以覆盖这个默认值。对 `conf/all/stable_secret` 的写入操作会被拒绝。

推荐在系统安装期间生成此密钥，并在此之后保持不变。

默认情况下，稳定的密钥未设置。

### `addr_gen_mode` - 整数
定义了如何生成链路本地和自动配置的地址。
```
=  ==========================================================================
 0  根据 EUI64 生成地址（默认）
 1  不生成链路本地地址，使用 EUI64 生成从自动配置产生的地址
 2  使用来自 `stable_secret` 的密钥生成稳定的隐私地址（RFC7217）
 3  如果未设置密钥，则使用随机密钥生成稳定的隐私地址
=  ==========================================================================
```

### `drop_unicast_in_l2_multicast` - 布尔值
丢弃在链路层组播（或广播）帧中接收到的所有单播 IPv6 数据包。
默认情况下此功能是关闭的。

### `drop_unsolicited_na` - 布尔值
丢弃所有未请求的邻居通告（Neighbor Advertisement），例如在网络中存在已知良好的 NA 代理时，此类帧不需要使用（或者在 802.11 的情况下，为了防止攻击必须不使用此类帧）。

默认情况下此功能是关闭的。

### `accept_untracked_na` - 整数
定义接受来自未出现在邻居缓存中的设备的邻居通告的行为：
- 0 - （默认）不接受未请求且未跟踪的邻居通告
### 1. 在接收到邻居通告（无论是主动请求还是非主动请求）时，在STALE状态中为路由器添加一个新的邻居缓存条目，如果通告中指定了目标链路层地址选项，并且对于所通告的IPv6地址尚未存在邻居条目。如果没有这个设置，则对于未被跟踪的地址（即在邻居缓存中不存在的地址）接收到的邻居通告会被静默忽略。
此行为符合RFC9131中记录的路由器侧的行为。
此设置的优先级低于drop_unsolicited_na。
这将优化直接连接主机发起的初始离链路通信的返回路径，确保启用此设置的第一跳路由器不必为了执行邻居请求而缓存初始返回数据包。
前提条件是主机配置为在接口启动时发送非主动请求的邻居通告。此设置应与主机上的ndisc_notify设置一起使用以满足该前提条件。

### 2. 扩展选项(1)，仅当源IP地址与接收邻居通告的接口上配置的地址在同一子网内时，才添加一个新的邻居缓存条目。

#### enhanced_dad - 布尔值
在用于重复地址检测（按RFC7527规定）的IPv6邻居请求消息中包含一个nonce选项。只有当接收到的DAD NS消息中的nonce与自己的不同才会被视为重复地址。这避免了由于NS消息回环造成的重复地址误检测。
除非`conf/{all,interface}/enhanced_dad`都设置为FALSE，否则nonce选项将在接口上发送。
默认值：TRUE

### `icmp/*`:
#### ratelimit - 整数
限制发送ICMPv6消息的最大速率。
0表示禁用任何限制，
其他值则表示响应之间最小间隔的毫秒数。
默认值：1000

`ratemask` - 一系列用逗号分隔的范围
对于匹配`ratemask`中范围的ICMPv6消息类型，根据速率限制参数来限制发送该消息。
输入和输出使用的格式为一系列用逗号分隔的范围（例如，“0-127,129”表示ICMPv6消息类型从0到127以及129）。写入文件将清除所有先前的ICMPv6消息类型的范围，并使用输入更新当前列表。
参考：https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml
获取ICMPv6消息类型的数值值，例如回声请求是128，而回声响应是129。
默认值：0-1,3-127（除了“包太大”之外，对ICMPv6错误进行速率限制）

`echo_ignore_all` - 布尔值
如果设置为非零，则内核将忽略通过IPv6协议发送给它的所有ICMP ECHO请求。
默认值：0

`echo_ignore_multicast` - 布尔值
如果设置为非零，则内核将忽略通过多播方式通过IPv6协议发送给它的所有ICMP ECHO请求。
默认值：0

`echo_ignore_anycast` - 布尔值
如果设置为非零，则内核将忽略通过IPv6协议发送给它并指向任播地址的所有ICMP ECHO请求。
默认值：0

`error_anycast_as_unicast` - 布尔值
如果设置为1，则内核将以ICMP错误响应针对任播地址发送给它的IPv6协议请求，实质上将任播视为单播处理。
默认值：0

`xfrm6_gc_thresh` - 整数
（自Linux 4.14版本以来已废弃）
开始对IPv6目标缓存条目进行垃圾回收的阈值。当达到该值两倍时，系统将拒绝新的分配。
IPv6更新者：
Pekka Savola <pekkas@netcore.fi>
YOSHIFUJI Hideaki / USAGI Project <yoshfuji@linux-ipv6.org>

/proc/sys/net/bridge/* 变量:
=================================

`bridge-nf-call-arptables` - 布尔值
- 1 : 将桥接的ARP流量传递给arptables的FORWARD链
- 0 : 禁用此功能
默认值：1

bridge-nf-call-iptables - 布尔值
    - 1：将桥接的IPv4流量传递给iptables的链
    - 0：禁用此功能
默认值：1

bridge-nf-call-ip6tables - 布尔值
    - 1：将桥接的IPv6流量传递给ip6tables的链
    - 0：禁用此功能
默认值：1

bridge-nf-filter-vlan-tagged - 布尔值
    - 1：将桥接的带有VLAN标签的ARP/IP/IPv6流量传递给{arp,ip,ip6}tables
    - 0：禁用此功能
默认值：0

bridge-nf-filter-pppoe-tagged - 布尔值
    - 1：将桥接的带有PPPoE标签的IP/IPv6流量传递给{ip,ip6}tables
    - 0：禁用此功能
默认值：0

bridge-nf-pass-vlan-input-dev - 布尔值
    - 1：如果启用了bridge-nf-filter-vlan-tagged，则尝试在桥接器上找到一个带有VLAN标签的接口，并将netfilter输入设备设置为该VLAN。这允许使用例如“iptables -i br0.1”，并使带有桥接器上的VLAN接口的REDIRECT目标能够正常工作。当没有找到匹配的VLAN接口，或此开关关闭时，输入设备将设置为桥接器接口
    - 0：禁用桥接netfilter VLAN接口查找
默认值：0

``proc/sys/net/sctp/*`` 变量：
==================================

addip_enable - 布尔值
    启用或禁用 RFC5061 中指定的动态地址重新配置（ADD-IP）功能的扩展。此扩展提供了为 SCTP 连接动态添加和移除新地址的能力。
1: 启用扩展
0: 禁用扩展
默认值：0

pf_enable - 整数
    启用或禁用 pf（pf 是潜在失败的缩写）状态。如果 pf_retrans 的值大于 path_max_retrans，也会禁用 pf 状态。也就是说，pf_enable 和 pf_retrans > path_max_retrans 中的一个或两个都可以用来禁用 pf 状态。
由于 pf_retrans 和 path_max_retrans 可以由用户空间应用程序更改，有时用户希望通过设置 pf_retrans > path_max_retrans 来禁用 pf 状态，但偶尔用户的应用程序会改变 pf_retrans 或 path_max_retrans 的值，导致 pf 状态被启用。因此，需要增加这个选项来动态地启用和禁用 pf 状态。详情参见：
    https://datatracker.ietf.org/doc/draft-ietf-tsvwg-sctp-failover
1: 启用 pf
0: 禁用 pf
默认值：1

pf_expose - 整数
    清除或启用/禁用 pf（pf 是潜在失败的缩写）状态的暴露。应用程序可以控制 SCTP_PEER_ADDR_CHANGE 事件中以及通过 SCTP_GET_PEER_ADDR_INFO 套接字选项获取的 PF 路径状态的暴露。当它被清除时，不会发送带有 SCTP_ADDR_PF 状态的 SCTP_PEER_ADDR_CHANGE 事件，并且可以通过 SCTP_GET_PEER_ADDR_INFO 套接字选项获取 SCTP_PF 状态的传输信息；当它被启用时，当传输变为 SCTP_PF 状态时，会发送一个 SCTP_PEER_ADDR_CHANGE 事件，并且可以通过 SCTP_GET_PEER_ADDR_INFO 套接字选项获取 SCTP_PF 状态的传输信息；当它被禁用时，不会发送 SCTP_PEER_ADDR_CHANGE 事件，并且尝试通过 SCTP_GET_PEER_ADDR_INFO 套接字选项获取 SCTP_PF 状态的传输信息时返回 -EACCES。
0: 清除 pf 状态暴露，与旧应用程序兼容
1: 禁用 pf 状态暴露
### 启用pf状态暴露
**默认值：0**

**addip_noauth_enable - 布尔值**
动态地址重新配置（ADD-IP）需要使用认证来保护添加或移除新地址的操作。此要求旨在防止未经授权的主机劫持关联。然而，旧版本实现可能在允许使用ADD-IP扩展的同时没有实施这一要求。出于互操作性的考虑，我们提供了一个变量来控制认证要求的执行。
- **1** 允许在没有认证的情况下使用ADD-IP扩展。这仅应在封闭环境中设置，以便与旧版本实现互操作。
- **0** 强制执行认证要求

**默认值：0**

**auth_enable - 布尔值**
启用或禁用认证块扩展。此扩展提供了发送和接收经过认证的数据包的能力，并且是安全运行动态地址重新配置（ADD-IP）扩展所必需的。
- **1** 启用此扩展
- **0** 禁用此扩展

**默认值：0**

**prsctp_enable - 布尔值**
启用或禁用部分可靠性扩展（RFC3758），该扩展用于通知对等方某个DATA不应再被期望接收。
- **1** 启用扩展
- **0** 禁用

**默认值：1**

**max_burst - 整数**
初始可发送的新数据包数量限制。它控制生成流量的突发性。
**默认值：4**

**association_max_retrans - 整数**
设置一个关联可以尝试重传的最大次数，在判定远程端点不可达之前。如果超过这个值，将终止该关联。
**默认值：10**

**max_init_retransmits - 整数**
在一个关联宣布目标不可达并终止之前，初始化（INIT）和COOKIE-ECHO数据块最大重传次数。
**默认值：未指定** (原文中未给出具体数值)
默认值：8

path_max_retrans - 整数
在给定路径上尝试的最大重传次数。一旦超过此阈值，该路径将被视为不可达，在多宿关联的情况下新流量会使用其他路径。
默认值：5

pf_retrans - 整数
在流量被重定向到备用传输（如果存在）之前，在给定路径上尝试的重传次数。请注意，这与 path_max_retrans 是不同的，因为即使超过了 pf_retrans 阈值，该路径仍然可以使用。仅当栈选择传输路径时它会被降级。此设置主要用于启用快速故障切换机制，而无需将 path_max_retrans 减小到非常低的值。详情参见：http://www.ietf.org/id/draft-nishida-tsvwg-sctp-failover-05.txt。还需注意的是，如果 pf_retrans > path_max_retrans，则禁用此功能。由于 pf_retrans 和 path_max_retrans 都可以通过用户空间应用程序更改，因此使用一个变量 pf_enable 来禁用 pf 状态。
默认值：0

ps_retrans - 整数
Primary.Switchover.Max.Retrans (PSMR)，这是来自 RFC 7829 第 5 节“主路径切换”中的可调参数。当旧主路径上的路径错误计数器超过 PSMR 时，主路径将变更为另一个活动路径，以便“即使旧主目的地址再次变得活跃，SCTP 发送方也可以继续在新的工作路径上进行数据传输”。请注意，此功能通过默认将 'ps_retrans' 每个网络命名空间初始化为 0xffff 来禁用，并且其值在通过 sysctl 更改时不能小于 'pf_retrans'。
默认值：0xffff

rto_initial - 整数
用于计算往返时间的初始往返超时值（以毫秒为单位）。这是重传的初始时间间隔。
默认值：3000

rto_max - 整数
往返超时的最大值（以毫秒为单位）。这是重传之间可能经过的最大时间间隔。
默认值：60000

rto_min - 整数
往返超时的最小值（以毫秒为单位）。这是重传之间可能经过的最小时间间隔。
默认值：1000

hb_interval - 整数
HEARTBEAT 数据块之间的间隔（以毫秒为单位）。这些数据块在空闲路径上以指定的时间间隔发送，以探测两个关联之间的给定路径状态。
默认值：30000

sack_timeout - 整数
实现等待发送 SACK 的时间量（以毫秒为单位）。
默认值：200

valid_cookie_life - 整数
SCTP cookie 的默认生命周期（以毫秒为单位）。此 cookie 在关联建立期间使用。
默认值：60000

cookie_preserve_enable - 布尔值
启用或禁用扩展 SCTP cookie 生命周期的能力，该 cookie 在 SCTP 关联的建立阶段使用。

- 1: 启用 cookie 生命周期扩展
- 0: 禁用

默认值: 1

cookie_hmac_alg - 字符串
选择在由监听的SCTP套接字发送给连接客户端的INIT-ACK数据块中生成Cookie值时所使用的HMAC算法。
有效值为：

    * md5
    * sha1
    * none

能够将md5或sha1设置为选定算法的前提是这些算法在构建时已配置（CONFIG_CRYPTO_MD5和CONFIG_CRYPTO_SHA1）。
默认值：取决于配置。如果可用则为MD5，否则如果可用则为SHA1，否则为none。
rcvbuf_policy - 整数
确定接收缓冲区是归属于套接字还是关联。SCTP支持在一个单一套接字上创建多个关联的能力。当使用此能力时，可能单个阻塞的关联正在缓存大量数据，这可能会通过消耗所有接收缓冲区空间来阻止其他关联交付其数据。为解决这个问题，可以将rcvbuf_policy设置为将接收缓冲区空间分配给每个关联而非套接字，以防止上述阻塞。
- 1: 接收缓冲区空间按关联计算
    - 0: 接收缓冲区空间按套接字计算

默认值: 0

sndbuf_policy - 整数
与rcvbuf_policy类似，这适用于发送缓冲区空间。
- 1: 发送缓冲区按关联跟踪
    - 0: 发送缓冲区按套接字跟踪
默认值: 0

sctp_mem - 包含3个整数的向量：最小值，压力值，最大值
所有SCTP套接字排队允许的页面数量
最小值: 低于此页面数量时，SCTP不会担心其内存需求。当SCTP分配的内存量超过这个数值时，SCTP开始控制内存使用
压力值: 此值引入是为了遵循tcp_mem格式
最大值: 所有SCTP套接字排队允许的页面数量
默认值是在启动时根据可用内存计算得出的。

`sctp_rmem` - 一个包含3个整数的向量：最小值、默认值、最大值
仅使用第一个值（“最小值”），而“默认值”和“最大值”被忽略。
最小值：SCTP套接字接收缓冲区的最小大小
即使在中等程度的内存压力下，也保证每个SCTP套接字（但不是每个连接）至少有这个大小。
默认值：4K

`sctp_wmem` - 一个包含3个整数的向量：最小值、默认值、最大值
仅使用第一个值（“最小值”），而“默认值”和“最大值”被忽略。
最小值：SCTP套接字可以使用的发送缓冲区的最小大小
即使在中等程度的内存压力下，也保证每个SCTP套接字（但不是每个连接）至少有这个大小。
默认值：4K

`addr_scope_policy` - 整数
控制IPv4地址作用域 - 根据草案stewart-tsvwg-sctp-ipv4-00

- 0   - 禁用IPv4地址作用域
- 1   - 启用IPv4地址作用域
- 2   - 遵循草案，但允许使用IPv4私有地址
- 3   - 遵循草案，但允许使用IPv4链路本地地址

默认值：1

`udp_port` - 整数
本地UDP隧道套接字的监听端口。通常使用的是IANA分配的UDP端口号9899（sctp-tunneling）
此UDP套接字用于处理传入的UDP封装的SCTP数据包（参见RFC6951），并且在同一网络命名空间内的所有应用程序共享该UDP套接字。当该值设置为0时，此UDP套接字将关闭。
该值还将用于设置传出UDP封装的SCTP数据包中UDP头部的源端口。关于目标端口，请参考下面的`encap_port`。
默认值：0

`encap_port` - 整数
    默认的远程UDP封装端口
    此值用于默认设置外出的UDP封装SCTP数据包的UDP头部的目标端口。用户也可以通过使用`setsockopt`为每个套接字/关联/传输更改此值。
    更多信息，请参考RFC6951。
    注意，当连接到远程服务器时，客户端应将此值设置为对等服务器上UDP隧道套接字监听的端口，并且客户端上的本地UDP隧道套接字也必须启动。在服务器端，它会从传入数据包的源端口中获取`encap_port`。
    默认值：0

`plpmtud_probe_interval` - 整数
        PLPMTUD探测定时器的时间间隔（以毫秒为单位），该定时器配置为在此周期后过期以接收探测数据包的确认。这也是进行探测搜索时当前路径最大传输单元（PMTU）之间的探测时间间隔。
        当设置为0时，PLPMTUD将被禁用，而其他值必须>= 5000。
        默认值：0

`reconf_enable` - 布尔值
        启用或禁用根据RFC6525中指定的流重新配置功能扩展。此扩展提供了“重置”流的能力，包括“传出/传入序列号重置”、“序列号/传输序列号重置”和“添加传出/传入流”的参数。
- 1: 启用扩展
- 0: 禁用扩展
        默认值：0

`intl_enable` - 布尔值
        启用或禁用根据RFC8260中指定的用户消息交织功能扩展。此扩展允许在不同流上发送的用户消息交织。启用此功能时，如果对等方也支持，则I-DATA块将替换DATA块来承载用户消息。请注意，要使用此功能，需要将此选项设置为1，并且还需要将套接字选项`SCTP_FRAGMENT_INTERLEAVE`设置为2以及`SCTP_INTERLEAVING_SUPPORTED`设置为1。
- 1: 启用扩展功能  
- 0: 禁用扩展功能  
默认值: 0  

ecn_enable - 布尔值  
        控制SCTP使用明确拥塞通知(ECN)  
如同在TCP中一样，仅当SCTP连接的两端均支持ECN时才使用它。此功能有助于通过允许支持ECN的路由器在不得不丢弃数据包之前发出拥塞信号来避免因拥塞而导致的数据包丢失。  
1: 启用ecn  
0: 禁用ecn  
默认值: 1  

l3mdev_accept - 布尔值  
        启用此选项允许“全局”绑定的套接字跨L3主域（例如，VRF）工作，并能接收无论其源自哪个L3域的数据包。仅在内核编译时启用了CONFIG_NET_L3_MASTER_DEV配置项时有效。  
默认值: 1（启用）

``/proc/sys/net/core/*``
========================

        请参阅：Documentation/admin-guide/sysctl/net.rst以获取这些条目的描述  
``/proc/sys/net/unix/*``
========================

max_dgram_qlen - 整数  
        数据报套接字接收队列的最大长度  

默认值: 10
