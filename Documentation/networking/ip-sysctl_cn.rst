SPDX 许可证标识符: GPL-2.0

=========
IP Sysctl
=========

/proc/sys/net/ipv4/* 变量
==============================

ip_forward - 布尔值
	- 0 - 禁用（默认）
	- 不为 0 - 启用

	在接口之间转发数据包
此变量特殊，其更改会将所有配置参数重置为默认状态（对于主机为 RFC1122，对于路由器为 RFC1812）

ip_default_ttl - 整数
	出站（但不转发）IP 数据包的 TTL 字段（生存时间）的默认值。应介于 1 和 255 之间（含）
默认：64（如 RFC1700 所推荐）

ip_no_pmtu_disc - 整数
	禁用路径 MTU 发现。如果在模式 1 中启用，并且接收到需要分片的 ICMP 报文，则该目的地的 PMTU 将设置为旧 MTU 和 min_pmtu（见下文）中的较小值。如果您想避免本地生成的分片，需要手动将 min_pmtu 提高到系统中最小接口 MTU。
在模式 2 中，传入的路径 MTU 发现消息将被丢弃。传出帧的处理方式与模式 1 相同，隐式地为每个创建的套接字设置 IP_PMTUDISC_DONT。
模式 3 是强化的路径 MTU 发现模式。内核仅在接受底层协议可以验证的分片所需错误时才接受这些错误，除了简单的套接字查找。当前接受 pmtu 事件的协议有 TCP、SCTP 和 DCCP，因为它们验证序列号或关联。此模式不应全局启用，仅用于保护例如命名空间中的名称服务器，在这些命名空间中 TCP 路径 MTU 必须仍然工作，但其他协议的路径 MTU 信息应被丢弃。如果全局启用此模式，可能会导致其他协议出现问题。
可能的值：0-3

默认值：FALSE

min_pmtu - 整数
默认值 552 - 最小路径 MTU。除非手动更改，否则每个缓存的 pmtu 永远不会低于此设置
ip_forward_use_pmtu - 布尔值
默认情况下，我们在转发时不信任协议路径 MTU，因为它们很容易被伪造，并可能导致路由器不需要的分片
只有当您有用户空间软件尝试自行发现路径 MTU 并依赖内核对此信息的认可时，才需要启用此选项。通常情况并非如此
默认值：0（禁用）

可能的值：
- 0 - 禁用
- 1 - 启用

fwmark_reflect - 布尔值
控制内核生成的未与套接字关联的 IPv4 回复报文的 fwmark（例如，TCP RST 或 ICMP 回声回复）
如果未设置，这些报文的 fwmark 为零。如果已设置，它们具有它们所回复报文的 fwmark
默认值：0

`fib_multipath_use_neigh` - 布尔值
在确定多路径路由的下一跳时使用现有邻居条目的状态。如果禁用，则不会使用邻居信息，数据包可能会被发送到失败的下一跳。仅适用于编译时启用了`CONFIG_IP_ROUTE_MULTIPATH`的内核。
默认值：0（禁用）

可能的值：
- 0 - 禁用
- 1 - 启用

`fib_multipath_hash_policy` - 整数
控制多路径路由使用的哈希策略。仅适用于编译时启用了`CONFIG_IP_ROUTE_MULTIPATH`的内核。
默认值：0（第三层）

可能的值：
- 0 - 第三层
- 1 - 第四层
- 2 - 如果存在则使用第三层或内部第三层
- 3 - 自定义多路径哈希。用于多路径哈希计算的字段由`fib_multipath_hash_fields` sysctl决定

`fib_multipath_hash_fields` - 无符号整数
当`fib_multipath_hash_policy`设置为3（自定义多路径哈希）时，用于多路径哈希计算的字段由该sysctl决定。
此值是一个位掩码，用于启用多路径哈希计算中的各种字段。
可能的字段如下：

| 位掩码 | 字段名称       |
|--------|----------------|
| 0x0001 | 源IP地址       |
| 0x0002 | 目标IP地址     |
| 0x0004 | IP协议         |
| 0x0008 | 未使用（流标签） |
| 0x0010 | 源端口         |
| 0x0020 | 目标端口       |
| 0x0040 | 内部源IP地址   |
| 0x0080 | 内部目标IP地址 |
| 0x0100 | 内部IP协议     |
| 0x0200 | 内部流标签     |
| 0x0400 | 内部源端口     |
| 0x0800 | 内部目标端口   |

默认值：0x0007（源IP、目标IP和IP协议）

`fib_multipath_hash_seed` - 无符号整数
计算多路径路由哈希时使用的种子值。适用于IPv4和IPv6数据路径。仅适用于编译时启用了`CONFIG_IP_ROUTE_MULTIPATH`的内核。
设置为0时，默认使用内部随机生成的种子值。
实际的哈希算法没有指定——无法保证给定种子值影响的下一跳分布会在不同内核版本中保持稳定。
默认值：0（随机）

`fib_sync_mem` - 无符号整数
在强制执行`synchronize_rcu`之前可以积压的脏内存数量。
默认值：512kB 最小值：64kB 最大值：64MB

`ip_forward_update_priority` - 整数
是否在转发后根据IPv4报头中的“TOS”字段更新SKB优先级。新的SKB优先级根据rt_tos2priority表映射（参见`man tc-prio`）。
默认值：1（更新优先级）

可能的值：
- 0 - 不更新优先级
- 1 - 更新优先级
route/max_size - 整数
    允许在内核中的最大路由数量。当使用大量接口和/或路由时，请增加此值。
    从 Linux 内核 3.6 开始，对于 IPv4，此设置已被弃用，因为不再使用路由缓存。
    从 Linux 内核 6.3 开始，对于 IPv6，此设置已被弃用，因为垃圾回收管理缓存的路由条目。

neigh/default/gc_thresh1 - 整数
    保持的最小条目数量。如果条目数量少于这个数值，垃圾回收器不会清除条目。
    默认值：128

neigh/default/gc_thresh2 - 整数
    当垃圾回收器变得更加积极地清除条目时的阈值。当超过这个数值时，超过 5 秒的条目将被清除。
    默认值：512

neigh/default/gc_thresh3 - 整数
    允许的最大非永久邻居条目数量。当使用大量接口并与大量直接连接的对等体通信时，请增加此值。
    默认值：1024

neigh/default/unres_qlen_bytes - 整数
    其他网络层为每个未解析地址排队的数据包所允许使用的最大字节数量（在 Linux 3.3 中添加）

    设置负值没有意义，并将返回错误。
    默认值：SK_WMEM_MAX（与 net.core.wmem_default 相同）
确切值取决于架构和内核选项，但应足以允许队列中存放256个中等大小的数据包。

`neigh/default/unres_qlen` - 整数
对于每个未解析地址，其他网络层可以排队的最大数据包数量。
（在Linux 3.3中已废弃）：请改用`unres_qlen_bytes`
在Linux 3.3之前，默认值为3，这可能导致意外的数据包丢失。当前默认值根据`unres_qlen_bytes`的默认值和实际数据包大小计算得出。
默认值：101

`neigh/default/interval_probe_time_ms` - 整数
具有NTF_MANAGED标志的邻居条目的探测间隔，最小值为1。
默认值：5000

`mtu_expires` - 整数
缓存的PMTU信息保留的时间（以秒为单位）。

`min_adv_mss` - 整数
所宣传的MSS取决于第一跳路由的MTU，但永远不会低于此设置。

`fib_notify_on_flag_change` - 整数
是否在RTM_F_OFFLOAD/RTM_F_TRAP/RTM_F_OFFLOAD_FAILED标志更改时发送RTM_NEWROUTE通知。
安装路由到内核后，用户空间会收到确认，这意味着路由已经在内核中安装，但不一定在硬件中安装。
已经安装在硬件中的路由也可能改变其操作并因此改变其标志。例如，在安装了IPinIP/VXLAN隧道后，一个捕获数据包的主机路由可以“升级”为执行解封装。
通知将指示用户空间路由的状态。
默认值：0（不发送通知）

可能的值：
- 0 - 不发送通知
- 1 - 发送通知
- 2 - 仅在RTM_F_OFFLOAD_FAILED标志变化时发送通知

IP 分片：

ipfrag_high_thresh - 长整型
用于重组 IP 分片的最大内存。

ipfrag_low_thresh - 长整型
（自 Linux 4.17 起已废弃）
内核开始移除不完整的分片队列以释放资源之前，用于重组 IP 分片的最大内存。内核仍然接受新的分片进行重组。

ipfrag_time - 整型
将 IP 分片保留在内存中的时间（秒）。

ipfrag_max_dist - 整型
ipfrag_max_dist 是一个非负整数值，定义了具有相同 IP 源地址的分片之间允许的最大“无序”程度。请注意，数据包重新排序并不罕见，但如果大量分片从某个源 IP 地址到达，而某个特定分片队列仍未完成，则可能表明该队列的一个或多个分片已丢失。当 ipfrag_max_dist 为正数时，在将分片添加到重组队列之前会进行额外检查 — 如果从某个 IP 地址到达的分片数量达到 ipfrag_max_dist 或更多，并且在此期间未向使用该源地址的任何 IP 分片队列添加分片，则认为队列中的一个或多个分片已丢失。现有的分片队列将被丢弃，并启动一个新的队列。ipfrag_max_dist 值为零则禁用此检查。

使用非常小的值（例如 1 或 2）作为 ipfrag_max_dist 可能会导致在正常的数据包重新排序发生时不必要的丢弃分片队列，这可能会导致应用程序性能下降。使用非常大的值（例如 50000）会增加错误地重组来自不同 IP 数据报的 IP 分片的可能性，从而导致数据损坏。
默认值：64

bc_forwarding - 整数
bc_forwarding 启用 rfc1812#section-5.3.5.2 和 rfc2644 中描述的功能。它允许路由器转发定向广播。
要启用此功能，'all' 条目和输入接口条目应设置为 1
默认值：0

INET 对等存储
==============

inet_peer_threshold - 整数
存储的大致大小。从这个阈值开始，将积极地丢弃条目。该阈值还决定了条目的存活时间（time-to-live）以及垃圾回收间隔的时间。条目越多，存活时间越短，GC 间隔也越短
inet_peer_minttl - 整数
条目的最小存活时间。应该足够长以覆盖重组端的分片存活时间。如果池大小小于 inet_peer_threshold，则保证此最小存活时间
以秒为单位测量
inet_peer_maxttl - 整数
条目的最大存活时间。如果没有内存压力（即池中的条目数量非常少），未使用的条目将在一段时间后过期
以秒为单位测量

TCP 变量
==========

somaxconn - 整数
socket listen() 队列长度的限制，在用户空间中称为 SOMAXCONN
默认值为 4096。（在 Linux 5.4 之前为 128）
另见 tcp_max_syn_backlog，用于对 TCP 套接字进行额外调整
### tcp_abort_on_overflow - BOOLEAN
如果监听服务接受新连接的速度太慢，重置这些连接。默认状态为 FALSE。这意味着如果由于突发导致溢出，连接将恢复。只有在你确信监听守护进程无法调整以更快地接受连接时才启用此选项。启用此选项可能会损害你的服务器客户端。

### tcp_adv_win_scale - INTEGER
自 Linux 6.6 起已过时
计算缓冲区开销为 bytes/2^tcp_adv_win_scale（如果 tcp_adv_win_scale > 0）或 bytes-bytes/2^(-tcp_adv_win_scale)，如果它 <= 0
可能的值为 [-31, 31]，包括两端
默认值：1

### tcp_allowed_congestion_control - STRING
显示/设置非特权进程可用的拥塞控制选择。列表是 tcp_available_congestion_control 中列出的选择的一个子集
默认值为 "reno" 并且默认设置（tcp_congestion_control）

### tcp_app_win - INTEGER
为应用程序缓冲预留最大值 (window/2^tcp_app_win, mss) 的窗口大小。值 0 是特殊的，表示不预留任何空间
可能的值为 [0, 31]，包括两端
默认值：31

### tcp_autocorking - BOOLEAN
启用 TCP 自动 corking：
当应用程序进行连续的小写入（write()/sendmsg()）系统调用时，尽量合并这些小写入，以减少发送的数据包总数。这是在至少有一个先前的数据包在 Qdisc 队列或设备传输队列中等待的情况下完成的。应用程序仍然可以使用 TCP_CORK 来实现最优行为，当它们知道何时何地解除 cork 操作
默认值：1

### tcp_available_congestion_control - STRING
显示已注册的可用拥塞控制选择
更多的拥塞控制算法可能作为模块存在，但未加载
`tcp_base_mss` - 整数  
分组层用于路径MTU发现（MTU探测）时的初始搜索值 `search_low`。如果启用了MTU探测，这是连接使用的初始MSS值。

`tcp_mtu_probe_floor` - 整数  
如果启用了MTU探测，这将限制连接中用于 `search_low` 的最小MSS值。
默认值：48

`tcp_min_snd_mss` - 整数  
TCP SYN 和 SYNACK 消息通常会宣传一个ADVMSS选项，如RFC 1122和RFC 6691所述。
如果这个ADVMSS选项小于 `tcp_min_snd_mss`，则会将其静默地限制为 `tcp_min_snd_mss`。
默认值：48（每个段至少有8字节的有效载荷）

`tcp_congestion_control` - 字符串  
设置新连接使用的拥塞控制算法。算法 “reno” 始终可用，但根据内核配置可能还有其他选择。
默认值在内核配置中设置。
对于被动连接，监听者的拥塞控制选择会被继承。
[参见 setsockopt(listenfd, SOL_TCP, TCP_CONGESTION, "name" ...) ]

`tcp_dsack` - 布尔值  
允许TCP发送“重复”的SACK。

`tcp_early_retrans` - 整数  
尾部丢失探测（TLP）将由于尾部丢失导致的RTO转换为快速恢复（草案-ietf-tcpm-rack）。注意，TLP需要RACK正常工作（参见下面的tcp_recovery）。

可能的值：
- 0 禁用TLP
- 3 或 4 启用TLP

默认值：3

`tcp_ecn` - 整数  
控制TCP使用显式拥塞通知（ECN）。
只有当TCP连接的两端都表明支持ECN时才会使用ECN。此功能有助于避免因拥塞而导致的数据包丢失，通过允许支持的路由器在丢弃数据包之前发出拥塞信号。
可能的值为：

    =  =====================================================
    0  禁用 ECN。既不发起也不接受 ECN
    1  当收到的连接请求启用 ECN 时，也请求在发出的连接尝试中使用 ECN
    2  当收到的连接请求启用 ECN 时，启用 ECN，但不在发出的连接中请求 ECN
    =  =====================================================

    默认值：2

`tcp_ecn_fallback` - 布尔值
如果内核检测到 ECN 连接行为异常，则回退到非 ECN 模式。目前，此选项实现了 RFC3168 第 6.1.1.1 节中的回退机制，但保留了在未来在此选项下实现其他检测机制的可能性。如果 `tcp_ecn` 或基于路由（或拥塞控制）的 ECN 设置被禁用，则该值将不会被使用。
默认值：1（回退功能启用）

`tcp_fack` - 布尔值
这是一个遗留选项，现在已经没有效果了。

`tcp_fin_timeout` - 整数
一个不再被任何应用程序引用的孤儿连接将在 FIN_WAIT_2 状态下保持的时间长度，之后在本地端终止。对于未被遗弃的连接而言，这是一个完全有效的“仅接收”状态，但对于孤儿连接，在 FIN_WAIT_2 状态下可能会永远等待远程端关闭其连接的一端。
参考：`tcp_max_orphans`

默认值：60 秒

`tcp_frto` - 整数
启用 RFC5682 中定义的前向重传超时恢复（F-RTO）。F-RTO 是一种增强的 TCP 重传超时恢复算法。它在网络传输时间（RTT）波动较大的网络（如无线网络）中特别有益。F-RTO 只需要发送方进行修改，不需要接收方的支持。默认情况下，非零值表示启用 F-RTO，0 表示禁用 F-RTO。
默认值：启用（非零值）

`tcp_fwmark_accept` - 布尔值
如果设置，对于没有套接字标记的监听套接字收到的传入连接，将接受套接字的标记设置为传入的 SYN 包的 fwmark。这将导致该连接上的所有数据包（从第一个 SYNACK 开始）都带有该 fwmark 发送。监听套接字的标记不变。已经通过 `setsockopt(SOL_SOCKET, SO_MARK, ...)` 设置了 fwmark 的监听套接字不受影响。
默认值：0

tcp_invalid_ratelimit - 整数
限制发送重复确认响应的最大速率，这些确认是针对现有连接中收到的无效TCP数据包。这些数据包可能因以下原因而被视为无效：

  (a) 序列号超出窗口范围，
  (b) 确认号超出窗口范围，或
  (c) PAWS（防止序列号回绕保护）检查失败

这有助于缓解简单的“确认循环”DoS攻击，在这种攻击中，有缺陷或恶意的中间盒或中间人可以篡改TCP头部字段，导致每个端点认为对方发送的是无效的TCP段，从而引发双方持续发送针对无效段的重复确认。
使用0会禁用对无效段响应时的重复确认限速；否则，该值指定发送此类重复确认之间的最小时间间隔，单位为毫秒。
默认值：500（毫秒）

tcp_keepalive_time - 整数
启用keepalive功能时，TCP发送keepalive消息的频率。
默认值：2小时

tcp_keepalive_probes - 整数
TCP在判定连接断开前发送的keepalive探测次数。
默认值：9

tcp_keepalive_intvl - 整数
探测消息发送的频率。乘以tcp_keepalive_probes后，即为开始探测后放弃无响应连接的时间。
默认值：75秒，即连接将在大约11分钟的重试后被终止。

tcp_l3mdev_accept - 布尔值
启用子套接字继承L3主设备索引。
启用此选项允许一个“全局”的监听套接字跨L3主域（例如，VRFs）工作，并且从监听套接字派生的已连接套接字将绑定到数据包源起的L3域。仅当内核编译时启用了CONFIG_NET_L3_MASTER_DEV配置项时有效。
默认值：0（禁用）

tcp_low_latency - 布尔值
这是一个遗留选项，不再有任何效果。
tcp_max_orphans - 整数
系统中未与任何用户文件句柄关联的TCP套接字的最大数量。如果此数量被超过，孤立连接将立即被重置，并打印警告信息。这个限制仅为了防止简单的DoS攻击，你_必须_不要依赖这个限制或人为降低它，而应该在必要时增加它（可能在增加安装内存后），以满足网络条件需要超过默认值的要求，并调整网络服务以更积极地处理和消除这种状态。再次提醒：每个孤立套接字会占用高达约64KB的不可交换内存。

tcp_max_syn_backlog - 整数
记住的连接请求（SYN_RECV）的最大数量，这些请求尚未从连接客户端收到确认。
这是一个针对每个监听器的限制。
对于低内存机器，最小值是128，并且会根据机器的内存比例增加。
如果服务器遭受过载，请尝试增加这个数字。
记得也要检查 /proc/sys/net/core/somaxconn。
一个SYN_RECV请求套接字大约消耗304字节的内存。

tcp_max_tw_buckets - 整数
系统同时持有的TIME_WAIT状态套接字的最大数量。
如果此数量被超过，TIME_WAIT套接字将立即被销毁，并打印警告信息。这个限制仅为了防止简单的DoS攻击，你_必须_不要人为降低这个限制，而应该在必要时增加它（可能在增加安装内存后），以满足网络条件需要超过默认值的要求。

tcp_mem - 包含3个整数的向量：min, pressure, max
min: 在此页面数量以下，TCP不会关心其内存消耗。
pressure: 当TCP分配的内存超过此页面数量时，TCP会适度控制其内存消耗并进入内存压力模式，当内存消耗降至“min”以下时退出该模式。
最大值：所有TCP套接字允许排队的页面数  
默认值在启动时根据可用内存计算得出。

`tcp_min_rtt_wlen` - 整型  
跟踪最小RTT的窗口过滤器的窗口长度。  
较短的窗口可以让流更快地检测到新的（更高的）最小RTT，当它被移动到较长路径时（例如，由于流量工程）。较长的窗口使过滤器更能抵抗瞬时拥塞引起的RTT膨胀。单位为秒。  
可能的值：0 - 86400（1天）  

默认值：300

`tcp_moderate_rcvbuf` - 布尔型  
如果设置，则TCP执行接收缓冲区自动调优，尝试自动调整缓冲区大小（不超过`tcp_rmem[2]`），以匹配路径所需的全吞吐量。默认情况下启用。

`tcp_mtu_probing` - 整型  
控制TCP分组层路径MTU发现。取三个值：  
- 0 - 禁用  
- 1 - 默认禁用，在检测到ICMP黑洞时启用  
- 2 - 始终启用，使用初始MSS `tcp_base_mss`

`tcp_probe_interval` - 无符号整型  
控制何时开始TCP分组层路径MTU发现重新探测。默认每10分钟重新探测一次，如RFC4821所述。

`tcp_probe_threshold` - 整型  
控制TCP分组层路径MTU发现探测停止的时间，依据搜索范围的宽度（以字节为单位）。默认值为8字节。

`tcp_no_metrics_save` - 布尔型  
默认情况下，TCP在连接关闭时将各种连接指标保存在路由缓存中，以便未来建立的连接可以使用这些指标来设置初始条件。通常这会提高整体性能，但有时可能会导致性能下降。如果设置，则TCP不会在关闭连接时缓存指标。

`tcp_no_ssthresh_metrics_save` - 布尔型  
控制TCP是否在路由缓存中保存慢启动阈值（ssthresh）指标。
默认值为 1，这会禁用 ssthresh 指标。
tcp_orphan_retries - 整数
此值影响本地关闭的 TCP 连接的超时时间，当重传的 RTO 未得到确认时。
更多详情请参阅 tcp_retries2。
默认值为 8。
如果你的机器是一台负载较高的 Web 服务器，
你应该考虑降低这个值，因为这种套接字可能会消耗大量资源。参见 tcp_max_orphans。
tcp_recovery - 整数
此值是一个位图，用于启用各种实验性的丢包恢复功能。

=========   =============================================================
RACK: 0x1   启用 RACK 丢包检测，以便快速检测丢失的重传和尾部丢弃。同时包含并禁用 RFC6675 对于 SACK 连接的恢复功能
RACK: 0x2   使 RACK 的重排序窗口固定（min_rtt/4）
RACK: 0x4   禁用 RACK 的 DUPACK 阈值启发式算法
=========   =============================================================

默认值：0x1

tcp_reflect_tos - 布尔值
对于监听套接字，重用初始 SYN 消息中的 DSCP 值用于出站数据包。这使得 TCP 流的两个方向都可以使用相同的 DSCP 值，假设在整个连接期间 DSCP 值保持不变。
此选项适用于 IPv4 和 IPv6。
默认值：0（禁用）

`tcp_reordering` - 整数
TCP 流中初始的数据包重排序级别
TCP 栈可以根据需要动态调整此初始值和 `tcp_max_reordering` 之间的数据包重排序级别

默认值：3

`tcp_max_reordering` - 整数
TCP 流中最大的数据包重排序级别
300 是一个相对保守的值，但如果你的路径使用了每个数据包的负载均衡（如轮询模式的绑定），你可以增加这个值

默认值：300

`tcp_retrans_collapse` - 布尔值
与某些有缺陷的打印机进行错误兼容
在重传时尝试发送更大的数据包以绕过某些 TCP 栈中的错误

`tcp_retries1` - 整数
此值影响 TCP 在未收到确认的重传超时（RTO）重传后判断出现问题并报告给网络层的时间
更多详细信息请参见 `tcp_retries2`
RFC 1122 推荐至少 3 次重传，这是默认值

`tcp_retries2` - 整数
此值影响当 RTO 重传未被确认时，活动的 TCP 连接的超时时间
给定一个值 N，一个遵循指数退避且初始 RTO 为 `TCP_RTO_MIN` 的假设 TCP 连接会在第 N+1 次 RTO 时杀死连接之前重传 N 次
默认值 15 产生了一个假设的超时时间为 924.6 秒，并且这是实际超时时间的下限
TCP将在第一个超过假设超时时间的重传超时（RTO）处有效超时。

RFC 1122建议超时时间为至少100秒，这对应于至少8的值。

tcp_rfc1337 - 布尔值
如果设置，则TCP堆栈遵循RFC 1337的行为。如果没有设置，则我们不遵循RFC，但可以防止TCP TIME_WAIT攻击。
默认值：0

tcp_rmem - 包含3个整数的向量：min, default, max
min: TCP套接字使用的接收缓冲区最小大小
即使在中等内存压力下也保证每个TCP套接字有此大小的缓冲区。
默认值：4K

default: TCP套接字使用的初始接收缓冲区大小
此值覆盖其他协议使用的net.core.rmem_default。
默认值：131072字节
此值导致初始窗口大小为65535。

max: 允许自动选择的TCP套接字接收缓冲区的最大大小。此值不会覆盖net.core.rmem_max。调用setsockopt()并使用SO_RCVBUF会禁用该套接字接收缓冲区大小的自动调整，在这种情况下，此值将被忽略。
默认值：介于 131072 和 6MB 之间，具体取决于 RAM 大小
tcp_sack - 布尔值
    启用选择性确认（SACK）
tcp_comp_sack_delay_ns - 长整型
    TCP 尝试通过使用基于 SRTT 的 5% 的定时器来减少发送的 SACK 数量，该定时器的最大值由此 sysctl 控制，单位为纳秒。
    默认值为 1ms，基于 TSO 自动调整大小周期。
    默认值：1,000,000 纳秒（1 毫秒）

tcp_comp_sack_slack_ns - 长整型
    此 sysctl 控制用于启动 SACK 压缩定时器时使用的松弛时间。这为小 RTT 流提供了额外的时间，并通过允许机会性地减少定时器中断来降低系统开销。
    默认值：100,000 纳秒（100 微秒）

tcp_comp_sack_nr - 整型
    可以压缩的最大 SACK 数量。
    使用 0 禁用 SACK 压缩。
    默认值：44

tcp_backlog_ack_defer - 布尔值
    如果设置，处理套接字队列的用户线程尝试为整个队列发送一个 ACK。这有助于避免在 TCP 套接字系统调用结束时可能出现的长延迟。
    默认值：true

tcp_slow_start_after_idle - 布尔值
    如果设置，则提供 RFC2861 行为，并在空闲一段时间后使拥塞窗口超时。空闲期定义为当前的 RTO。如果未设置，则在空闲期后不会使拥塞窗口超时。
    默认值：1

tcp_stdurg - 布尔值
    使用主机需求解释 TCP 紧急指针字段
大多数主机使用较旧的BSD解释，因此如果您开启此功能，
Linux 可能无法正确与它们通信。
默认值：FALSE

tcp_synack_retries - 整数
被动TCP连接尝试时，SYNACK将重传的次数。不应高于255。默认值为5，对应于最后一次重传前31秒的时间间隔（基于当前1秒的初始RTO）。因此，被动TCP连接的最终超时时间将在63秒后发生。

tcp_syncookies - 整数
仅当内核编译时包含CONFIG_SYN_COOKIES配置时有效。
当套接字的SYN待处理队列溢出时发送syncookies。这是为了防止常见的“SYN洪泛攻击”。
默认值：1

请注意，syncookies是一种回退机制。
它绝不能用来帮助高负载服务器抵御合法连接速率。如果您在日志中看到SYN洪泛警告，但调查发现这些警告是由于合法连接过载造成的，您应该调整其他参数直至这些警告消失。
参见：tcp_max_syn_backlog、tcp_synack_retries、tcp_abort_on_overflow
syncookies严重违反了TCP协议，不允许使用TCP扩展，并可能导致某些服务（例如SMTP中继）的严重降级，这可能不会被您看到，而是由您的客户端和中继在联系您时注意到。当您在日志中看到并非真正遭受洪泛攻击的SYN洪泛警告时，说明您的服务器配置有严重问题。
如果您想测试syncookies对网络连接的影响，可以将此参数设置为2以无条件生成syncookies。

tcp_migrate_req - 布尔值
在三路握手过程中，初始SYN数据包接收时，传入的连接会绑定到一个特定的监听套接字。
当监听器关闭时，在握手过程中的飞行请求套接字和accept队列中的已建立套接字会被终止。
如果监听器启用了SO_REUSEPORT，则相同端口上的其他监听器应该能够接受此类连接。此选项使得在close()或shutdown()之后，可以将此类子套接字迁移到另一个监听器成为可能。
BPF_SK_REUSEPORT_SELECT_OR_MIGRATE 类型的 eBPF 程序通常用于定义选择存活监听器的策略。
否则，如果启用了此选项，内核只会随机选择一个存活的监听器。
请注意，在具有不同设置的监听器之间迁移可能会导致应用程序崩溃。假设从监听器 A 迁移到 B，并且只有 B 启用了 TCP_SAVE_SYN。B 无法读取从 A 迁移过来的请求中的 SYN 数据。为了避免这种情况，可以通过在该类型的 eBPF 程序中返回 SK_DROP 来取消迁移，或者禁用此选项。
默认值：0

tcp_fastopen - 整数
启用 TCP 快速打开（RFC7413），以便在初始 SYN 包中发送和接收数据。
客户端支持通过标志 0x1 启用（默认开启）。客户端必须使用带有 MSG_FASTOPEN 标志的 sendmsg() 或 sendto() 而不是 connect() 来发送 SYN 中的数据。
服务器支持通过标志 0x2 启用（默认关闭）。然后可以通过另一个标志（0x400）为所有监听器启用，或者通过 TCP_FASTOPEN 套接字选项为单个监听器启用，选项值为 SYN 数据队列长度。
值（位图）如下：

=====  ======== ======================================================
  0x1  (客户端) 在客户端的初始 SYN 包中启用发送数据
0x2  (服务器) 启用服务器支持，即允许在三路握手完成前接收并传递 SYN 包中的数据到应用程序
0x4  (客户端) 不管是否有 cookie 可用或没有 cookie 选项，在初始 SYN 包中发送数据
0x200  (服务器) 接受无 cookie 选项的数据包中的 SYN 数据
=====  ======== ======================================================
0x400 （服务器）默认启用所有监听器以支持快速打开（Fast Open），无需显式设置TCP_FASTOPEN套接字选项

=====  ======== ======================================================

默认值：0x1

请注意，只有在分别启用了基本支持（0x1 和 0x2）的情况下，额外的客户端或服务器功能才有效。

`tcp_fastopen_blackhole_timeout_sec` - 整数
当发生TFO防火墙黑洞问题时，在活动TCP套接字上禁用快速打开（Fastopen）的初始时间（秒）
如果在重新启用快速打开后检测到更多黑洞问题，则此时间段将呈指数增长，并在黑洞问题消失时重置为初始值。
设置为0可禁用黑洞检测。
默认情况下，此值设为0（功能禁用）。

`tcp_fastopen_key` - 由逗号分隔的32位十六进制整数列表
该列表包含一个主密钥和一个可选的备用密钥。主密钥用于创建和验证Cookie，而可选的备用密钥仅用于验证Cookie。备用密钥的目的在于密钥轮换时最大化TFO验证。
如果设置了`tcp_fastopen` sysctl参数为0x400（见上文），或者设置了`TCP_FASTOPEN` setsockopt()选项名且未通过sysctl配置密钥，则内核可能会随机选择一个主密钥进行配置。如果通过使用`TCP_FASTOPEN_KEY` setsockopt()选项名配置了密钥，则这些每个套接字的密钥将优先于通过sysctl指定的任何密钥。
密钥格式为四个8位十六进制整数，中间用“-”分隔，形式为：xxxxxxxx-xxxxxxxx-xxxxxxxx-xxxxxxxx。前导零可以省略。主密钥和备用密钥之间可以用逗号分隔。如果只指定一个密钥，则该密钥成为主密钥，并移除任何之前配置的备用密钥。

`tcp_syn_retries` - 整数
主动TCP连接尝试中初始SYN数据包将重传的次数。不应高于127。默认值为6，这对应于67秒（当`tcp_syn_linear_timeouts`设为4时），直到最后一次重传，当前初始RTO为1秒。
使用此设置，活动的TCP连接尝试的最终超时将在131秒后发生。
tcp_timestamps - 整数
    按照RFC1323定义启用时间戳
- 0: 禁用
- 1: 按照RFC1323定义启用时间戳，并为每个连接使用随机偏移而不是仅使用当前时间
- 2: 类似于1，但不使用随机偏移
默认值: 1

tcp_min_tso_segs - 整数
    每个TSO帧的最小段数
自Linux 3.12以来，TCP会根据流量速率自动调整TSO帧大小，而不是填充64KB的数据包
对于特定用途，可以强制TCP构建大的TSO帧。注意，如果可用窗口太小，TCP堆栈可能会拆分过大的TSO数据包
默认值: 2

tcp_tso_rtt_log - 整数
    基于min_rtt调整TSO数据包大小

    自Linux 5.18起，TCP自动调整可以根据具有较小RTT的流量进行微调
旧的自动调整方法是将调度预算分配为每秒发送1024个TSO数据包
```tso_packet_size = sk->sk_pacing_rate / 1024;

使用新机制时，我们通过以下方式增加 TSO 尺寸：

distance = min_rtt_usec / (2^tcp_tso_rtt_log)
tso_packet_size += gso_max_size >> distance;

这意味着距离非常近的主机之间的流量可以使用更大的 TSO 数据包，从而降低它们的 CPU 成本。
如果要使用旧的自动调整大小功能，请将此 sysctl 设置为 0。
默认值：9（2^9 = 512 微秒）

tcp_pacing_ss_ratio - 整数
sk->sk_pacing_rate 是 TCP 栈根据当前速率应用的一个比率来设置的。（current_rate = cwnd * mss / srtt）
如果 TCP 处于慢启动阶段，则应用 tcp_pacing_ss_ratio 来让 TCP 探测更高的速度，假设 cwnd 每隔一个 RTT 可以翻倍。
默认值：200

tcp_pacing_ca_ratio - 整数
sk->sk_pacing_rate 是 TCP 栈根据当前速率应用的一个比率来设置的。（current_rate = cwnd * mss / srtt）
如果 TCP 处于拥塞避免阶段，则应用 tcp_pacing_ca_ratio 来保守地探测更高的吞吐量。
默认值：120

tcp_syn_linear_timeouts - 整数
主动 TCP 连接在采用线性退避超时重传 SYN 的次数，在默认转为指数退避超时之前。这不会影响被动 TCP 端的 SYNACK。
初始 RTO 为 1 且 tcp_syn_linear_timeouts = 4 时，我们期望的 SYN RTO 为：1, 1, 1, 1, 1, 2, 4, ... （4 次线性退避超时，第一次指数退避为 2^0 * 初始 RTO）。
默认值：4

tcp_tso_win_divisor - 整数
这允许控制单个 TSO 帧可以消耗拥塞窗口的百分比。
设置此参数是在突发性和构建更大 TSO 帧之间的选择。
默认值：3

tcp_tw_reuse - 整数
启用在安全的情况下对 TIME-WAIT 套接字进行复用以用于新连接。
- 0 - 禁用
- 1 - 全局启用
- 2 - 仅对回环流量启用

未经技术专家建议/请求不应更改此设置。
```
默认值：2

tcp_window_scaling - 布尔值
启用 RFC1323 中定义的窗口缩放功能

tcp_shrink_window - 布尔值
这会改变 TCP 接收窗口的计算方式
RFC 7323 第 2.4 节指出，在某些情况下可以提供缩小的窗口，并且 TCP 实现必须确保它们能够处理 RFC 1122 中指定的缩小窗口
- 0 - 禁用。窗口永远不会缩小
- 1 - 启用。当需要保持在自动调整（sk_rcvbuf）设置的内存限制内时，窗口会缩小
这仅在非零接收窗口缩放因子生效的情况下发生
默认值：0

tcp_wmem - 包含 3 个整数的向量：最小值、默认值、最大值
最小值：为 TCP 套接字预留的发送缓冲区内存数量
每个 TCP 套接字由于其创建事实而有权使用它
默认值：4KB

默认值：TCP 套接字使用的初始发送缓冲区大小。此值覆盖其他协议使用的 net.core.wmem_default
通常比 net.core.wmem_default 更小
默认值：16K

max: 允许为TCP套接字的自动调谐发送缓冲区设置的最大内存量。此值不会覆盖 net.core.wmem_max。如果使用 setsockopt() 和 SO_SNDBUF 调用，则会禁用该套接字发送缓冲区大小的自动调谐，在这种情况下，此值将被忽略。
默认值：根据RAM大小，在64K到4MB之间变化
tcp_notsent_lowat - 无符号整数
TCP 套接字可以通过 TCP_NOTSENT_LOWAT 套接字选项来控制其写入队列中的未发送字节数量。当未发送字节数量低于每个套接字的阈值，并且写入队列未满时，poll()/select()/epoll() 将报告 POLLOUT 事件。sendmsg() 在达到限制时也不会添加新的缓冲区。
这个全局变量控制了未使用 TCP_NOTSENT_LOWAT 的套接字的未发送数据量。对于这些套接字，全局变量的更改会立即生效。
默认值：UINT_MAX (0xFFFFFFFF)

tcp_workaround_signed_windows - 布尔值
如果设置，则假定未收到窗口缩放选项表示远程TCP有问题，并将其视为有符号的数量。
如果不设置，则假定即使我们没有收到窗口缩放选项，远程TCP也没有问题。
默认值：0

tcp_thin_linear_timeouts - 布尔值
启用对细流（thin streams）动态触发线性超时的功能。
如果设置，在因超时而重传时会进行检查以确定流是否为细流（在传输中的数据包少于4个）。
只要检测到流是细流，最多可以执行6次线性超时，之后才进入指数退避模式。这提高了非激进细流的重传延迟，这类情况通常与时间相关。
有关细流的更多信息，请参见 Documentation/networking/tcp-thin.rst。

默认值：0

tcp_limit_output_bytes - 整数
控制每个TCP套接字的小队列限制。
TCP批量发送器倾向于增加飞行中的数据包数量，直到收到丢包通知。在使用SNDBUF自动调整时，这可能导致大量数据包在本地机器上排队（例如：队列管理器、CPU积压或设备），从而影响其他流的延迟，对于典型的pfifo_fast队列管理器尤为如此。`tcp_limit_output_bytes`限制了队列管理器或设备上的字节数量，以减少人为的RTT/cwnd并减少缓冲区膨胀。
默认值：1048576（16 * 65536）

`tcp_challenge_ack_limit` - 整数
限制每秒发送的Challenge ACK的数量，如RFC 5961（《提高TCP对盲目窗口攻击的鲁棒性》）中所建议。请注意，这个按网络命名空间的速率限制可能会允许一些旁道攻击，并且可能不应该启用。TCP堆栈无论如何已经实现了每个TCP套接字的限制。
默认值：INT_MAX（无限制）

`tcp_ehash_entries` - 整数
显示当前网络命名空间中TCP套接字的哈希桶数量。
负值表示该网络命名空间不拥有自己的哈希桶，而是共享初始网络命名空间的哈希桶。
`tcp_child_ehash_entries` - 整数
控制子网络命名空间中TCP套接字的哈希桶数量，必须在clone()或unshare()之前设置。如果该值不为0，则内核将使用一个向上取整到2^n的实际哈希桶大小。0是一个特殊值，表示子网络命名空间将共享初始网络命名空间的哈希桶。
请注意，如果内核未能分配足够的内存，子命名空间将使用全局哈希桶。此外，全局哈希桶分布在可用的NUMA节点上，但子哈希表的分配取决于当前进程的NUMA策略，这可能导致性能差异。
另外需要注意的是，`tcp_max_tw_buckets`和`tcp_max_syn_backlog`的默认值依赖于哈希桶大小。
可能的值：0, 2^n（n: 0 - 24 (16Mi)）
默认值：0

`tcp_plb_enabled` - 布尔值
如果设置并且底层拥塞控制（例如DCTCP）支持并启用了PLB特性，则启用TCP PLB（保护负载均衡）。PLB在以下论文中有描述：https://doi.org/10.1145/3544216.3544226。根据PLB参数，在检测到持续拥塞时，TCP会触发IPv6出站数据包的流标签字段发生变化。流标签字段的变化可能会改变使用ECMP/WCMP进行路由的交换机中出站数据包的路径。
PLB（路径负载平衡）会更改套接字的txhash，从而导致IPv6流标签字段发生变化，并且目前对IPv4报头没有影响。可以通过其他网络报头字段（例如TCP或IPv4选项）或使用外层报头由交换机确定下一跳的封装来将PLB应用于IPv4。无论哪种情况，都需要进一步修改主机和交换机端。

当设置时，PLB假定拥塞信号（例如ECN）是可用的，并被拥塞控制模块用来估计一个拥塞度量（例如ce_ratio）。PLB需要拥塞度量来进行重新选择路径的决策。

默认值：FALSE

`tcp_plb_idle_rehash_rounds` - 整数
连续出现拥塞轮次（RTT）的数量，在没有飞行中的数据包的情况下可以执行重新哈希。
这在PLB论文中称为M：
https://doi.org/10.1145/3544216.3544226
可能的值：0 - 31

默认值：3

`tcp_plb_rehash_rounds` - 整数
连续出现拥塞轮次（RTT）的数量，在此之后可以强制执行重新哈希。设置此参数时需谨慎，因为较小的值会增加重传的风险。
这在PLB论文中称为N：
https://doi.org/10.1145/3544216.3544226
可能的值：0 - 31

默认值：12

`tcp_plb_suspend_rto_sec` - 整数
在发生RTO事件时暂停PLB的时间（以秒为单位）。为了避免PLB重新选择到连接“黑洞”，在发生RTO后，TCP连接会随机暂停PLB重新选择路径一段时间，该时间范围为这个参数的1倍到2倍之间。添加随机性是为了避免多个TCP连接同时重新哈希。此值应根据修复失败链路所需的时间来设置。
可能的值：0 - 255

默认值：60

`tcp_plb_cong_thresh` - 整数
在一个轮次（RTT）内标记为拥塞的数据包比例，用于标记该轮次是否为拥塞。这在PLB论文中称为K：
https://doi.org/10.1145/3544216.3544226
0-1的比例范围映射到0-256的整数范围内，以避免浮点运算。例如，128表示如果一个轮次中有至少50%的数据包被标记为拥塞，则该轮次将被标记为拥塞。
将阈值设置为0意味着PLB会在每个RTT都重新选择路径，无论是否有拥塞。这不是PLB预期的行为，仅用于实验目的。
可能的值：0 - 256

默认值：128

tcp_pingpong_thresh - 整数
估计的数据响应数量与估计的传入数据请求数量之间的比率，必须达到这一比率，TCP 才会认为该连接为“乒乓”（请求-响应）连接，并且延迟确认可以提供益处。
此阈值默认为 1，但某些应用程序可能需要更高的阈值以实现最佳性能。
可能的值：1 - 255

默认值：1

tcp_rto_min_us - 整数
最小的 TCP 重传超时时间（以微秒为单位）。注意，rto_min 路由选项具有最高优先级来配置此设置，其次是 TCP_BPF_RTO_MIN 套接字选项，再次是这个 tcp_rto_min_us 系统控制变量。
建议的做法是使用一个小于或等于 200000 微秒的值。
可能的值：1 - INT_MAX

默认值：200000

UDP 变量
==========

udp_l3mdev_accept - 布尔值
启用此选项允许全局绑定的套接字在 L3 主域（例如，VRF）之间工作，并能够接收无论其起源于哪个 L3 域的数据包。仅当内核编译时启用了 CONFIG_NET_L3_MASTER_DEV 配置项时有效。
默认值：0（禁用）

udp_mem - 包含 3 个整数的向量：最小值、压力值、最大值
所有 UDP 套接字排队使用的页面数
最小值：所有 UDP 套接字排队允许的页面数
压力值：此值是为了遵循 tcp_mem 的格式而引入的
最大值：此值是为了遵循 tcp_mem 的格式而引入的
默认值是在启动时根据可用内存计算得出的。
### UDP 变量

`udp_rmem_min` - 整数  
在适度条件下，UDP 套接字使用的接收缓冲区的最小大小。  
每个 UDP 套接字能够使用该大小来接收数据，即使 UDP 套接字的总页数超过了 `udp_mem` 的压力。单位是字节。  
默认值：4K

`udp_wmem_min` - 整数  
UDP 没有发送内存计数功能，此可调参数没有效果。

`udp_hash_entries` - 整数  
显示当前网络命名空间中 UDP 套接字哈希桶的数量。  
负数表示该网络命名空间不拥有自己的哈希桶，并共享初始网络命名空间的哈希桶。

`udp_child_ehash_entries` - 整数  
控制子网络命名空间中 UDP 套接字哈希桶的数量，必须在 `clone()` 或 `unshare()` 之前设置。  
如果该值不是 0，则内核将使用向上取整到 2^n 的实际哈希桶大小。0 是一个特殊值，表示子网络命名空间将共享初始网络命名空间的哈希桶。  
请注意，如果内核无法分配足够的内存，子命名空间将使用全局哈希桶。此外，全局哈希桶分布在可用的 NUMA 节点上，但子哈希表的分配取决于当前进程的 NUMA 策略，这可能导致性能差异。  
可能的值：0, 2^n（n: 7 (128) - 16 (64K)）  
默认值：0

### RAW 变量

`raw_l3mdev_accept` - 布尔值  
启用此选项允许“全局”绑定套接字在 L3 主域（例如，VRFs）之间工作，接收的包无论其起源于哪个 L3 域都能被接收。仅当内核编译时包含 `CONFIG_NET_L3_MASTER_DEV` 配置时有效。  
默认值：1（启用）

### CIPSOv4 变量

`cipso_cache_enable` - 布尔值  
如果设置，则启用对 CIPSO 标签映射缓存的添加和查找。如果未设置，则添加被忽略且查找总是返回未命中。然而，无论设置如何，当需要时缓存仍然会被无效化，因此您可以安全地切换此选项，缓存始终是“安全”的。
默认值：1

`cipso_cache_bucket_size` - 整数
CIPSO 标签缓存由一个固定大小的哈希表组成，每个哈希桶包含多个缓存条目。此变量限制了每个哈希桶中的条目数量；值越大，可以缓存的 CIPSO 标签映射就越多。当给定哈希桶中的条目数量达到此限制时，添加新条目会导致该桶中最旧的条目被移除以腾出空间。
默认值：10

`cipso_rbm_optfmt` - 布尔值
启用 CIPSO 草案规范（详见 `Documentation/netlabel` 中的详细信息）第 3.4.2.6 节中定义的“优化标签 1 格式”。
这意味着在设置后，CIPSO 标签将通过填充空类别来使数据包数据对齐到 32 位。
默认值：0

`cipso_rbm_structvalid` - 布尔值
如果设置，在调用 `ip_options_compile()` 时对 CIPSO 选项进行非常严格的检查。如果没有设置，则在 `ip_options_compile()` 过程中放松这些检查。无论如何都是“安全”的，因为错误会在 CIPSO 处理代码的其他地方被捕获，但将此设置为 0（假）应该会减少工作量（即应该更快），但可能会导致与其他需要严格检查的实现出现问题。
默认值：0

IP 变量
========

`ip_local_port_range` - 2 个整数
定义了 TCP 和 UDP 选择本地端口时使用的本地端口范围。第一个数字是起始端口号，第二个数字是结束端口号。
如果可能的话，最好这些数字具有不同的奇偶性（一个偶数和一个奇数）。
必须大于或等于 `ip_unprivileged_port_start`。
默认值分别是 32768 和 60999。

`ip_local_reserved_ports` - 逗号分隔的范围列表
指定为已知第三方应用程序保留的端口。这些端口不会被自动端口分配使用（例如，在调用 `connect()` 或 `bind()` 时使用端口号 0）。显式端口分配行为保持不变。
输入和输出使用的格式是一个逗号分隔的范围列表（例如，“1,2-4,10-10”表示端口 1、2、3、4 和 10）。写入文件将清除所有以前保留的端口，并用输入中给出的当前列表更新。

希望这些翻译对你有帮助！如果有任何问题，请随时告诉我。
请注意，`ip_local_port_range` 和 `ip_local_reserved_ports` 的设置是独立的，并且内核在确定哪些端口可用于自动端口分配时会同时考虑这两个设置。
例如，您可以保留当前 `ip_local_port_range` 之外的端口：

```
$ cat /proc/sys/net/ipv4/ip_local_port_range
32000 60999
$ cat /proc/sys/net/ipv4/ip_local_reserved_ports
8080,9148
```

尽管这样做有些多余，但如果后来更改了端口范围，使得包含这些预留端口，则这种设置是有用的。此外，请注意，这些范围的重叠可能会影响选择紧接预留端口块之后的临时端口的概率。
默认值：空

`ip_unprivileged_port_start` - 整数
这是一个每个命名空间的 sysctl 设置。它定义了网络命名空间中的第一个非特权端口。特权端口需要 root 权限或 CAP_NET_BIND_SERVICE 权限才能绑定。
要禁用所有特权端口，请将其设置为 0。它们不得与 `ip_local_port_range` 重叠。
默认值：1024

`ip_nonlocal_bind` - 布尔值
如果设置，则允许进程绑定到非本地 IP 地址，这可能会非常有用，但也可能导致某些应用程序出错。
默认值：0

`ip_autobind_reuse` - 布尔值
默认情况下，bind() 不会自动选择端口，即使新套接字和所有绑定到该端口的套接字都设置了 SO_REUSEADDR。
`ip_autobind_reuse` 允许 bind() 重用端口，这对于使用 bind()+connect() 的情况非常有用，但也可能导致某些应用程序出错。推荐的解决方案是使用 IP_BIND_ADDRESS_NO_PORT，此选项应仅由专家设置。
默认值：0

`ip_dynaddr` - 整数
如果设置为非零值，则启用动态地址支持。
如果设置为大于 1 的非零值，在发生动态地址重写时，内核将打印一条日志消息。
默认值：未指定（具体数值取决于系统配置）
默认值：0

`ip_early_demux` - 布尔值
优化某些本地套接字的输入数据包处理，将其减少到一个解复用器。目前我们只对已建立的TCP和已连接的UDP套接字这样做。
对于纯路由工作负载，这可能会增加额外的成本，从而降低整体吞吐量，在这种情况下你应该禁用它。
默认值：1

`ping_group_range` - 两个整数
限制ICMP协议数据报套接字的用户组范围
默认值为“1 0”，这意味着任何人都不能（即使是root）创建ping套接字。设置为“100 100”将授予单个组权限。“0 4294967294”将对所有人启用，“100 4294967294”将对用户启用，但不包括守护进程。
`tcp_early_demux` - 布尔值
为已建立的TCP套接字启用早期解复用
默认值：1

`udp_early_demux` - 布尔值
为已连接的UDP套接字启用早期解复用。如果你的系统可能会遇到更多的未连接负载，请禁用此选项。
默认值：1

`icmp_echo_ignore_all` - 布尔值
如果设置为非零，则内核将忽略发送给它的所有ICMP ECHO请求。
默认值：0

`icmp_echo_enable_probe` - 布尔值
如果设置为1，则内核将响应发送给它的RFC 8335 PROBE请求。
默认值：0

`icmp_echo_ignore_broadcasts` - 布尔值
如果设置为非零，则内核将忽略通过广播/多播发送给它的所有ICMP ECHO和TIMESTAMP请求。
默认值：1

`icmp_ratelimit` - 整数
限制发送与`icmp_ratemask`（见下文）匹配类型的ICMP数据包的最大速率到特定目标。
0 表示禁用任何限制，
否则表示响应之间的最小时间间隔（毫秒）

注意，另一个 sysctl 参数 `icmp_msgs_per_sec` 限制了发送到所有目标的 ICMP 数据包数量
默认值：1000

`icmp_msgs_per_sec` - 整数
限制从本机每秒发送的最大 ICMP 数据包数量
只有类型与 `icmp_ratemask`（见下文）匹配的消息才会受到此限制。出于安全原因，每秒消息的确切数量会被随机化
默认值：1000

`icmp_msgs_burst` - 整数
`icmp_msgs_per_sec` 控制每秒发送的 ICMP 数据包数量，而 `icmp_msgs_burst` 控制这些数据包的突发大小
出于安全原因，确切的突发大小会被随机化
默认值：50

`icmp_ratemask` - 整数
由受速率限制的 ICMP 类型组成的掩码
重要位：IHGFEDCBA9876543210

默认掩码：0000001100000011000 (6168)

位定义（参见 include/linux/icmp.h）：

```
= =========================
0 Echo Reply
3 Destination Unreachable [1]_
4 Source Quench [1]_
5 Redirect
8 Echo Request
B Time Exceeded [1]_
C Parameter Problem [1]_
D Timestamp Request
E Timestamp Reply
F Info Request
G Info Reply
H Address Mask Request
I Address Mask Reply
= =========================

.. [1] 这些默认是受速率限制的（参见上面的默认掩码）
```

`icmp_ignore_bogus_error_responses` - 布尔值
一些路由器违反了 RFC1122，通过向广播帧发送错误的响应。这种违规行为通常会通过内核警告记录下来
如果设置为 TRUE，则内核不会发出此类警告，从而避免日志文件杂乱
默认值：1

`icmp_errors_use_inbound_ifaddr` - 布尔值

如果为零，则使用退出接口的主要地址发送 ICMP 错误消息
如果非零，则消息将使用接收到导致ICMP错误的数据包的接口的主要地址发送。
这是许多网络管理员期望路由器具备的行为。而且，它可以大大简化复杂网络布局的调试工作。
请注意，如果选定接口没有主要地址，则无论此设置如何，都将使用第一个具有主要地址的非回环接口的主要地址。
默认值：0

`igmp_max_memberships` - 整数
更改我们可以订阅的最大多播组数量。
默认值：20

理论上的最大值受到单个数据报中发送成员报告的限制（即报告不能跨越多个数据报，否则可能会使交换机混淆，并且会离开你不打算离开的组）。
支持的组数 `M` 受到你能在单个 65535 字节的数据报中容纳的组报告条目数量的限制。
`M = (65536 - IP头部大小) / 组记录大小`

组记录是可变长度的，最小为 12 字节。
因此，`net.ipv4.igmp_max_memberships` 不应设置得高于：

`(65536 - 24) / 12 = 5459`

该值 5459 假设没有 IP 头部选项，因此在实际应用中这个数字可能更低。
`igmp_max_msf` - 整数
多播组的源过滤列表中允许的最大地址数量。
默认值：10

`igmp_qrv` - 整数
控制 IGMP 查询鲁棒性变量（参见 RFC2236 第 8.1 节）
默认值：2（根据RFC2236 8.1规定）

最小值：1（根据RFC6636 4.5规定）

force_igmp_version - 整数
- 0 - （默认）不强制使用特定的IGMP版本，允许回退到IGMPv1/v2。如果所有IGMPv1/v2查询器存在定时器过期，则会重新回到IGMPv3模式。
- 1 - 强制使用IGMP版本1。收到IGMPv2/v3查询时也会回复IGMPv1报告。
- 2 - 强制使用IGMP版本2。收到IGMPv1查询消息时会回退到IGMPv1。收到IGMPv3查询时会回复报告。
- 3 - 强制使用IGMP版本3。与默认值0的行为相同。

注意：
这与force_mld_version不同，因为IGMPv3（RFC3376）的安全性考虑部分没有明确说明可以完全忽略其他版本的消息，就像MLDv2（RFC3810）那样。因此，建议将此值设置为默认值0。

``conf/interface/*``
在每个接口上更改特殊设置（其中“interface”是您的网络接口名称）

``conf/all/*``
这是特殊的，更改所有接口的设置

log_martians - 布尔值
记录包含不可能地址的数据包到内核日志中
如果`conf/{all,interface}/log_martians`中的任何一个被设置为TRUE，则该接口上的log_martians将启用；否则将禁用。

accept_redirects - 布尔值
接受ICMP重定向消息
如果满足以下条件之一，则该接口上的accept_redirects将启用：

- `conf/{all,interface}/accept_redirects`都为TRUE，并且该接口启用了转发功能。
- `conf/{all,interface}/accept_redirects`中的至少一个为TRUE，并且该接口未启用转发功能。

否则，该接口上的accept_redirects将禁用。

默认值：
- TRUE（主机）
- FALSE（路由器）

forwarding - 布尔值
在此接口上启用IP转发。这控制了是否可以通过此接口转发接收到的数据包。

mc_forwarding - 布尔值
进行组播路由。内核需要编译CONFIG_MROUTE，并且需要一个组播路由守护进程。
要使接口上的组播路由生效，`conf/all/mc_forwarding`也必须设置为TRUE。

medium_id - 整数
用于通过它们所连接的介质区分设备的整数值。当仅在一个设备上接收到广播数据包时，两个设备可以有不同的ID值。
默认值 0 表示该设备是其介质上的唯一接口，值为 -1 表示介质未知。
目前，它用于更改 proxy_arp 的行为：
当在连接到不同介质的两个设备之间转发数据包时，会启用 proxy_arp 功能。

proxy_arp - 布尔值
执行代理 ARP
如果 conf/{all,interface}/proxy_arp 中至少有一个设置为 TRUE，则会为该接口启用 proxy_arp；否则将禁用它。

proxy_arp_pvlan - 布尔值
私有 VLAN 代理 ARP
基本上允许代理 ARP 回复返回到同一个接口（从该接口接收到 ARP 请求/查询）。
这是为了支持以太网交换机功能，如 RFC 3069，其中各个端口不允许相互通信，但允许与上游路由器通信。根据 RFC 3069 的描述，可以通过代理 ARP 实现这些主机通过上游路由器进行通信。不需要与 proxy_arp 一起使用。

这项技术有不同的名称：

- 在 RFC 3069 中称为 VLAN 聚合
- Cisco 和 Allied Telesyn 称之为私有 VLAN
- Hewlett-Packard 称之为源端口过滤或端口隔离
- Ericsson 称之为 MAC 强制转发（RFC 草案）
### proxy_delay - 整数
延迟代理响应
当启用 proxy_arp 或 proxy_ndp 时，延迟对邻居请求的响应。将在 [0, proxy_delay) 范围内选择一个随机值，设置为零表示无延迟响应。
值以 jiffies（节拍）为单位，默认值为 80。

### shared_media - 布尔值
发送（路由器）或接受（主机）RFC1620 共享媒体重定向
覆盖 secure_redirects
如果 conf/{all,interface}/shared_media 中至少有一个设置为 TRUE，则该接口的 shared_media 将被启用；否则将被禁用。

默认值：TRUE

### secure_redirects - 布尔值
仅接受当前网关列表中列出的网关的 ICMP 重定向消息。即使禁用，RFC1122 重定向规则仍然适用。
被 shared_media 覆盖
如果 conf/{all,interface}/secure_redirects 中至少有一个设置为 TRUE，则该接口的 secure_redirects 将被启用；否则将被禁用。

默认值：TRUE

### send_redirects - 布尔值
发送重定向消息，如果为路由器
如果 conf/{all,interface}/send_redirects 中至少有一个设置为 TRUE，则该接口的 send_redirects 将被启用；否则将被禁用。

默认值：TRUE

### bootp_relay - 布尔值
接受源地址为 0.b.c.d 且目的地址不是本机的数据包作为本地数据包处理。假设 BOOTP 中继守护进程会捕获并转发此类数据包。
要使接口启用 BOOTP 中继，conf/all/bootp_relay 必须也设置为 TRUE。

默认值：FALSE

尚未实现
### accept_source_route - BOOLEAN
接受带有SRR选项的数据包。
`conf/all/accept_source_route` 必须设置为 `TRUE` 才能接受带有 SRR 选项的数据包。

- 默认值：
  - 路由器：`TRUE`
  - 主机：`FALSE`

### accept_local - BOOLEAN
接受本地源地址的数据包。结合合适的路由，可以用来通过网络将数据包从一个本地接口传输到另一个本地接口，并正确接受这些数据包。

- 默认值：`FALSE`

### route_localnet - BOOLEAN
在路由时，不将回环地址视为火星源地址或目标地址。这使得可以在本地路由中使用 127/8 地址段。

- 默认值：`FALSE`

### rp_filter - INTEGER
- 0 - 不进行源验证
- 1 - 根据 RFC3704 定义的严格模式（Strict Reverse Path）
  每个传入的数据包都会与 FIB 进行测试，如果接口不是最佳的反向路径，则数据包检查将失败。
  默认情况下，失败的数据包会被丢弃。
- 2 - 根据 RFC3704 定义的宽松模式（Loose Reverse Path）
  每个传入的数据包的源地址也会与 FIB 进行测试，如果源地址无法通过任何接口到达，则数据包检查将失败。
  
当前推荐的做法是启用严格模式（RFC3704），以防止 DDoS 攻击中的 IP 欺骗。如果使用非对称路由或其他复杂的路由，则建议使用宽松模式。
`conf/{all,interface}/rp_filter` 的最大值会在对 `{interface}` 进行源验证时使用。

- 默认值：0。注意某些发行版在启动脚本中启用了此功能。
### src_valid_mark - BOOLEAN
- **0** - 数据包的fwmark不包含在反向路径路由查找中。这允许不对称路由配置仅在一个方向上使用fwmark，例如透明代理。
- **1** - 数据包的fwmark包含在反向路径路由查找中。这使得当fwmark用于双向路由时，rp_filter可以正常工作。

此设置还影响在生成ICMP回复或确定IPOPT_TS_TSANDADDR和IPOPT_RR IP选项中存储的地址时使用fwmark的方式。

`conf/{all,interface}/src_valid_mark` 的最大值将被使用，默认值为0。

### arp_filter - BOOLEAN
- **1** - 允许在同一子网上有多个网络接口，并且根据内核是否会将ARP请求的IP从该接口路由出去来决定是否应答每个接口的ARP请求（因此需要使用基于源地址的路由才能使此功能生效）。换句话说，它允许控制哪些网卡（通常只有一个）会响应ARP请求。
- **0**（默认） - 内核可以使用其他接口上的地址来响应ARP请求。虽然这看起来不太对，但通常是合理的，因为它增加了成功通信的机会。

在Linux上，IP地址归属于整个主机，而不是特定的接口。只有在更复杂的设置（如负载均衡）中，这种行为才会导致问题。

如果 `conf/{all,interface}/arp_filter` 中至少有一个设置为TRUE，则该接口的 `arp_filter` 将被启用；否则将被禁用。

### arp_announce - INTEGER
定义在接口上发送ARP请求时宣布本地源IP地址的不同限制级别：

- **0** - （默认）使用任何本地地址，无论其配置在哪个接口上。
- **1** - 尝试避免使用不属于目标子网的本地地址。当通过此接口可达的目标主机要求ARP请求中的源IP地址必须是接收接口逻辑网络的一部分时，此模式很有用。在生成请求时，我们会检查所有包含目标IP的子网，并保留来自这些子网的源地址。如果没有这样的子网，则根据级别2的规则选择源地址。
- **2** - 始终使用针对此目标的最佳本地地址。
在此模式下，我们忽略IP数据包中的源地址，并尝试选择一个本地地址来与目标主机通信。这样的本地地址是通过查找所有出站接口子网中包含目标IP地址的主要IP地址来选定的。如果找不到合适的本地地址，则选择出站接口上的第一个本地地址或所有其他接口上的第一个本地地址，希望我们能够收到请求的回复，有时甚至不管我们宣布的源IP地址。

`conf/{all,interface}/arp_announce` 中的最大值被使用  
增加限制级别可以提高从解析目标接收答复的机会，而降低级别则会公布更多有效的发送者信息。

`arp_ignore` - 整数类型  
定义响应接收到的ARP请求时的不同模式，这些请求用于解析本地目标IP地址：

- 0 - （默认）：对任何接口上配置的本地目标IP地址进行回复
- 1 - 只有当目标IP地址是入站接口上配置的本地地址时才回复
- 2 - 只有当目标IP地址是入站接口上配置的本地地址且发送者的IP地址在同一子网上时才回复
- 3 - 不回复以主机范围配置的本地地址，只回复全局和链路范围的地址解析
- 4-7 - 预留
- 8 - 不回复所有本地地址

当在 `{interface}` 上接收到ARP请求时，使用 `conf/{all,interface}/arp_ignore` 中的最大值。

`arp_notify` - 布尔类型  
定义通知地址和设备变化的模式：
- 0 - （默认）：不执行任何操作
- 1 - 当设备启动或硬件地址发生变化时生成免费ARP请求

`arp_accept` - 整数类型  
定义接受来自未出现在ARP表中的设备的免费ARP（garp）帧的行为：
- 0 - 不在ARP表中创建新条目
- 1 - 在ARP表中创建新条目
- 2 - 仅当源IP地址与接收garp消息的接口上配置的地址在同一子网内时，在ARP表中创建新条目

无论回复还是请求类型的免费ARP都会触发ARP表更新，如果此设置启用的话。如果ARP表已经包含免费ARP帧的IP地址，则无论此设置是否启用，ARP表都会被更新。

`arp_evict_nocarrier` - 布尔类型  
在NOCARRIER事件发生时清除ARP缓存。此选项对于无线设备非常重要，因为在同一网络的不同接入点之间漫游时不应清除ARP缓存。大多数情况下应保持默认设置（1）：
- 1 - （默认）：在NOCARRIER事件发生时清除ARP缓存
- 0 - 在NOCARRIER事件发生时不清除ARP缓存

`mcast_solicit` - 整数类型  
当关联的硬件地址未知时，处于INCOMPLETE状态下的最大多播探测次数，默认为3。
ucast_solicit - 整数
当重新确认硬件地址时，处于PROBE状态下的最大单播探测次数。默认值为3。

app_solicit - 整数
在回退到多播探测（参见mcast_resolicit）之前，通过netlink发送到用户空间ARP守护进程的最大探测次数。默认值为0。

mcast_resolicit - 整数
在单播和应用探测之后，处于PROBE状态下的最大多播探测次数。默认值为0。

disable_policy - 布尔值
禁用此接口的IPSEC策略（SPD）。

disable_xfrm - 布尔值
无论策略如何，在此接口上禁用IPSEC加密。

igmpv2_unsolicited_report_interval - 整数
下一次未请求的IGMPv1或IGMPv2报告重传的时间间隔（毫秒）。默认值：10000（10秒）。

igmpv3_unsolicited_report_interval - 整数
下一次未请求的IGMPv3报告重传的时间间隔（毫秒）。默认值：1000（1秒）。

ignore_routes_with_linkdown - 布尔值
在执行FIB查找时忽略链路已关闭的路由。

promote_secondaries - 布尔值
当从该接口移除主IP地址时，提升相应的次级IP地址而不是移除所有相应的次级IP地址。

drop_unicast_in_l2_multicast - 布尔值
丢弃在链路层多播（或广播）帧中接收到的所有单播IP数据包。
这种行为（对于多播）实际上是RFC 1122中的“应遵循”建议，但由于兼容性原因，默认情况下是禁用的。默认值：关闭（0）。

drop_gratuitous_arp - 布尔值
丢弃所有无偿ARP帧，例如在网络中有已知的良好ARP代理时，这些帧不需要使用（或者在802.11的情况下，必须禁用以防止攻击）。默认值：关闭（0）。

tag - 整数
允许您写入一个数字，可以根据需要使用。
默认值为 0
xfrm4_gc_thresh - 整数
（自 Linux-4.14 起已废弃）
启动 IPv4 目的地缓存垃圾回收的阈值。当达到两倍该值时，系统将拒绝新的分配。
igmp_link_local_mcast_reports - 布尔值
启用对 224.0.0.X 范围内的链路本地多播组的 IGMP 报告
默认：TRUE

Alexey Kuznetsov
kuznet@ms2.inr.ac.ru

更新者：

- Andi Kleen
  ak@muc.de
- Nicolas Delon
  delon.nicolas@wanadoo.fr

/proc/sys/net/ipv6/* 变量
==============================

IPv6 没有全局变量如 tcp_*。ipv4/ 下的 tcp_* 设置也适用于 IPv6 [XXX?]
bindv6only - 布尔值
IPV6_V6ONLY 套接字选项的默认值，该选项限制 IPv6 套接字仅用于 IPv6 通信
- TRUE：禁用 IPv4 映射地址功能
- FALSE：启用 IPv4 映射地址功能

默认：FALSE（如 RFC3493 中所规定）

flowlabel_consistency - 布尔值
保护流标签的一致性和唯一性
您必须禁用它才能在流标签管理器中使用 IPV6_FL_F_REFLECT 标志
- TRUE：启用
- FALSE：禁用

默认：TRUE

auto_flowlabels - 整数
根据数据包的流哈希自动生成流标签。这允许中间设备（如路由器）识别数据包流以实现等价成本多路径路由（见 RFC 6438）
=  ===========================================================
0  完全禁用自动流标签
1  默认启用自动流标签，可以通过 IPV6_AUTOFLOWLABEL 套接字选项在每个套接字基础上禁用
2  允许自动流标签，可以通过 IPV6_AUTOFLOWLABEL 套接字选项在每个套接字基础上启用
3  启用并强制自动流标签，不能通过套接字选项禁用
=  ===========================================================

默认：1

flowlabel_state_ranges - 布尔值
将流标签号空间分为两个范围。0-0x7FFFF 保留给 IPv6 流管理设施，0x80000-0xFFFFF 保留给无状态流标签（见 RFC6437）
- TRUE: 启用  
- FALSE: 禁用  

默认值：true

flowlabel_reflect - 整数  
控制流标签反射。这是为了让等价成本多路径路由（ECMP）在任播环境中的路径最大传输单元（Path MTU）发现功能正常工作所需的设置。详见 RFC 7690 和：
https://tools.ietf.org/html/draft-wang-6man-flow-label-reflection-01

这是一个位掩码  
- 1：为已建立的流启用  
    注意，这会阻止自动更改流标签，例如“tcp: 在接收到意外重传时更改IPv6流标签”和“tcp: 在每次SYN和RTO重传时更改txhash”
- 2：为TCP重置（RESET）数据包启用（没有活动监听器）
    如果设置了此选项，则对关闭端口上的SYN数据包的响应中发送的RST数据包将反射传入的流标签  
- 4：为ICMPv6回声回复消息启用  
默认值：0

fib_multipath_hash_policy - 整数  
控制多路径路由使用的哈希策略  
默认值：0（第三层）

可能的值：  
- 0 - 第三层（源地址和目的地址加流标签）
- 1 - 第四层（标准五元组）
- 2 - 第三层或存在时的内部第三层
- 3 - 自定义多路径哈希。用于多路径哈希计算的字段由 fib_multipath_hash_fields 控制变量确定

fib_multipath_hash_fields - 无符号整数  
当 fib_multipath_hash_policy 设置为3（自定义多路径哈希）时，用于多路径哈希计算的字段由此控制变量确定  
此值是一个位掩码，用于启用多路径哈希计算的各种字段  
可能的字段包括：

====== ============================
0x0001 源IP地址
0x0002 目的IP地址
0x0004 IP协议
0x0008 流标签
0x0010 源端口
0x0020 目的端口
0x0040 内部源IP地址
0x0080 内部目的IP地址
0x0100 内部IP协议
0x0200 内部流标签
0x0400 内部源端口
0x0800 内部目的端口
====== ============================

默认值：0x0007（源IP、目的IP和IP协议）

anycast_src_echo_reply - 布尔值  
控制是否使用任播地址作为ICMPv6回声回复的源地址  
- TRUE: 启用  
- FALSE: 禁用  

默认值：FALSE

idgen_delay - 整数  
控制在检测到DAD冲突后重试隐私稳定地址生成之前的延迟秒数  
默认值：1（如RFC7217所述）

idgen_retries - 整数  
控制在检测到DAD冲突后生成稳定隐私地址的重试次数  
默认值：3（如RFC7217所述）

mld_qrv - 整数  
控制MLD查询鲁棒性变量（见RFC3810 9.1节）  
默认值：2（根据RFC3810 9.1节规定）

最小值：1（根据RFC6636 4.5节规定）

max_dst_opts_number - 整数  
目标选项扩展头中允许的最大非填充TLV数量。如果该值小于零，则不允许未知选项，并且允许的已知TLV数量为此数值的绝对值
默认值：8

`max_hbh_opts_number` - 整数
允许在逐跳选项扩展头中包含的最大非填充TLV数量。如果该值小于零，则不允许未知选项，并且允许的已知TLV数量为该数值的绝对值。
默认值：8

`max_dst_opts_length` - 整数
允许的目的地选项扩展头的最大长度。
默认值：`INT_MAX`（无限制）

`max_hbh_length` - 整数
允许的逐跳选项扩展头的最大长度。
默认值：`INT_MAX`（无限制）

`skip_notify_on_dev_down` - 布尔值
控制是否为设备关闭或删除时移除的路由生成RTM_DELROUTE消息。IPv4不生成此消息；IPv6默认生成此消息。将此sysctl设置为true会跳过该消息，从而使IPv4和IPv6在依赖用户空间缓存跟踪链路事件并删除路由方面保持一致。
默认值：false（生成消息）

`nexthop_compat_mode` - 布尔值
新的下一跳API提供了一种独立于前缀管理下一跳的方法。默认启用与旧路由格式的向后兼容性，这意味着路由转储和通知包含新的下一跳属性，同时也包含完整的、展开的下一跳定义。此外，对下一跳配置的更新或删除会为使用该下一跳的每个FIB条目生成路由通知。一旦系统理解了新API，可以禁用此sysctl以获得新API带来的全部性能优势，即通过禁用下一跳展开和冗余通知来实现。
默认值：true（向后兼容模式）

`fib_notify_on_flag_change` - 整数
是否在RTM_F_OFFLOAD/RTM_F_TRAP/RTM_F_OFFLOAD_FAILED标志发生变化时发出RTM_NEWROUTE通知。
安装路由到内核后，用户空间会收到确认信息，这表示路由已经在内核中安装，但不一定在硬件中安装。
已经安装在硬件中的路由也可能改变其行为，因此改变其标志。例如，一个正在捕获数据包的主机路由可以在安装IPinIP/VXLAN隧道后被“提升”为执行解封装操作。
这些通知会告知用户空间路由的状态。
默认值：0（不发送通知）

可能的值：
- 0 - 不发送通知
- 1 - 发送通知
- 2 - 仅在 RTM_F_OFFLOAD_FAILED 标志更改时发送通知

`ioam6_id` - 整数
定义该节点的 IOAM ID。只使用 32 位中的 24 位。
最小值：0
最大值：0xFFFFFF
默认值：0xFFFFFF

`ioam6_id_wide` - 长整数
定义该节点的宽 IOAM ID。只使用 64 位中的 56 位。可以与 `ioam6_id` 不同。
最小值：0
最大值：0xFFFFFFFFFFFFFF
默认值：0xFFFFFFFFFFFFFF

IPv6 分片：

`ip6frag_high_thresh` - 整数
用于重新组装 IPv6 分片的最大内存。当分配 `ip6frag_high_thresh` 字节的内存用于此目的时，分片处理程序将丢弃数据包直到达到 `ip6frag_low_thresh`
`ip6frag_low_thresh` - 整数
参见 `ip6frag_high_thresh`

`ip6frag_time` - 整数
保存 IPv6 分片在内存中的时间（秒）

`conf/default/*`：
更改接口特定的默认设置
这些设置将在创建新接口时使用

`conf/all/*`：
更改所有接口特定的设置
[XXX：除了转发之外的其他特殊功能？]

conf/all/disable_ipv6 - 布尔值
更改此值等同于更改 ``conf/default/disable_ipv6`` 设置，并且还将所有接口级别的 ``disable_ipv6`` 设置为相同的值。
读取此值没有特别的意义。它并不能说明 IPv6 支持是启用还是禁用。返回的值在某些接口设置了 ``disable_ipv6`` 为 0 并且配置了 IPv6 地址的情况下也可能为 1。

conf/all/forwarding - 布尔值
启用所有接口之间的全局 IPv6 转发。
IPv4 和 IPv6 在这里工作方式不同；例如，必须使用 netfilter 来控制哪些接口可以转发数据包，哪些不可以。
这也会将所有接口的 Host/Router 设置 'forwarding' 设置为指定的值。详情见下文。
这被称为全局转发。

proxy_ndp - 布尔值
进行代理 NDP（邻居发现协议）。

fwmark_reflect - 布尔值
控制内核生成的、未与套接字关联的 IPv6 回复数据包的 fwmark（例如，TCP RST 或 ICMPv6 回声回复）。
如果未设置，则这些数据包的 fwmark 为零。如果设置，则它们具有其回复的数据包的 fwmark。
默认值：0。

``conf/interface/*``：
更改每个接口的特殊设置。
某些设置的功能行为取决于是否启用了本地转发。

accept_ra - 整数
接受路由器通告；使用它们进行自动配置。
同时决定是否传输路由器请求。如果且仅当功能设置为接受路由器通告时，才会传输路由器请求。
可能的值为：

        ==  ===========================================================
         0  不接受路由器通告
  1  如果未启用转发，则接受路由器通告
  2  覆盖转发行为。即使启用了转发，也接受路由器通告
 ==  ===========================================================

功能默认值：

    - 如果未启用本地转发，则启用
  - 如果启用了本地转发，则禁用
accept_ra_defrtr - 布尔值
在路由器通告中学习默认路由器。
功能默认值：

    - 如果 accept_ra 已启用，则启用
### 翻译成中文：

- 如果 `accept_ra` 被禁用，则该选项也会被禁用。

`ra_defrtr_metric` - 无符号整数
通过路由器通告（Router Advertisement）学习到的默认路由的度量值。此值将作为通过 IPv6 路由器通告学习到的默认路由的度量值。仅当 `accept_ra_defrtr` 启用时生效。
可能的值：
    1 到 0xFFFFFFFF

    默认值：IP6_RT_PRIO_USER，即 1024

`accept_ra_from_local` - 布尔值
如果路由器通告（RA）的源地址在本地机器上找到，并且该 RA 否则正确且可以接受，则接受该 RA。
默认情况下不接受这些 RA，因为这可能是无意中的网络环路。
功能默认值：
    - 如果特定接口上的 `accept_ra_from_local` 启用，则启用。
    - 如果特定接口上的 `accept_ra_from_local` 禁用，则禁用。

`accept_ra_min_hop_limit` - 整数
路由器通告中的最小跳数限制信息。
如果路由器通告中的跳数限制信息小于该变量，则忽略该信息。
默认值：1

`accept_ra_min_lft` - 整数
路由器通告中可接受的最小生存时间值。
RA部分的寿命少于该值时应被忽略。零寿命不受影响。
默认值：0

accept_ra_pinfo - 布尔值
在路由器通告中学习前缀信息
功能默认值：

- 如果启用了accept_ra，则启用
- 如果禁用了accept_ra，则禁用
ra_honor_pio_life - 布尔值
是否使用RFC4862第5.5.3e节来确定与路由器通告中的前缀信息选项匹配的地址的有效寿命
- 如果启用，将始终遵循PIO有效寿命
- 如果禁用，使用RFC4862第5.5.3e节来确定地址的有效寿命
默认值：0（禁用）

accept_ra_rt_info_min_plen - 整数
RA中路由信息的最小前缀长度
前缀小于此变量的路由信息将被忽略
功能默认值：

- 如果启用了accept_ra_rtr_pref，则为0
* -1 如果 accept_ra_rtr_pref 被禁用
accept_ra_rt_info_max_plen - 整数
路由公告（RA）中的路由信息的最大前缀长度
具有大于此变量值的前缀长度的路由信息将被忽略
功能默认值：

    * 0 如果 accept_ra_rtr_pref 被启用
* -1 如果 accept_ra_rtr_pref 被禁用
accept_ra_rtr_pref - 布尔值
接受路由公告（RA）中的路由器优先级
功能默认值：

    - 如果 accept_ra 被启用，则启用
- 如果 accept_ra 被禁用，则禁用
accept_ra_mtu - 布尔值
应用路由公告（RA）选项 5 中指定的 MTU 值（RFC4861）。如果
禁用，则忽略路由公告中指定的 MTU 值
功能默认值：

    - 如果 accept_ra 被启用，则启用
```plaintext
接受重定向 - 布尔值
    接受重定向
功能默认值：
    - 如果未启用本地转发，则启用
    - 如果启用了本地转发，则禁用

接受源路由 - 整数
    接受源路由（路由扩展头部）
    - >= 0：仅接受类型为2的路由头部
    - < 0：不接受路由头部
默认值：0

自动配置 - 布尔值
    使用路由器广告中的前缀信息自动配置地址
功能默认值：
    - 如果启用了accept_ra_pinfo，则启用
    - 如果未启用了accept_ra_pinfo，则禁用
```
dad_transmits - 整数
发送的重复地址检测探测次数
默认值：1

forwarding - 整数
配置接口特定的主机/路由器行为
.. 注意::

	   建议在所有接口上设置相同的配置；混合路由器/主机的情况较为罕见。
可能的值为：

		- 0 禁用转发
		- 1 启用转发

	**FALSE (0)**：

	默认情况下，假设为主机行为。这意味着：

	1. 在邻居通告中不设置IsRouter标志
	2. 如果accept_ra为TRUE（默认），则发送路由器请求
	3. 如果accept_ra为TRUE（默认），则接受路由器通告（并进行自动配置）
	4. 如果accept_redirects为TRUE（默认），则接受重定向

**TRUE (1)**：

	如果启用了本地转发，则假定为路由器行为。这意味着与上述情况正好相反：

	1. 在邻居通告中设置IsRouter标志
	2. 除非accept_ra为2，否则不发送路由器请求
3. 除非 `accept_ra` 设置为 2，否则忽略路由器通告（Router Advertisements）。
4. 忽略重定向（Redirects）

默认值：如果全局转发被禁用（默认），则为 0（禁用），否则为 1（启用）
`hop_limit` - 整数
默认跳数限制
默认值：64

`mtu` - 整数
默认最大传输单元（Maximum Transfer Unit）

默认值：1280（IPv6 所需的最小值）

`ip_nonlocal_bind` - 布尔值
如果设置，则允许进程绑定到非本地的 IPv6 地址，这可能非常有用，但也可能会导致某些应用程序出问题
默认值：0

`router_probe_interval` - 整数
根据 RFC4191 描述的路由器探测之间的最小时间间隔（秒）
默认值：60

`router_solicitation_delay` - 整数
接口启动后，在发送路由器请求之前等待的秒数
默认值：1

`router_solicitation_interval` - 整数
在发送路由器请求之间等待的秒数
默认值：4

`router_solicitations` - 整数
发送路由器请求的数量，直到假定没有路由器存在
默认值：3

`use_oif_addrs_only` - 布尔值
启用时，通过此接口路由的目的地址的候选源地址将限制为此接口上配置的地址集（参见 RFC 6724 第 4 节）
默认值：false

use_tempaddr - 整数
隐私扩展（RFC3041）的偏好设置
* <= 0 ：禁用隐私扩展
    * == 1 ：启用隐私扩展，但优先使用公共地址而非临时地址
* > 1 ：启用隐私扩展，并优先使用临时地址而非公共地址
默认值：
    * 0（对于大多数设备）
    * -1（对于点对点设备和回环设备）

temp_valid_lft - 整数
临时地址的有效寿命（以秒为单位）。如果小于最小要求寿命（通常为5-7秒），则不会创建临时地址
默认值：172800（2天）

temp_prefered_lft - 整数
临时地址的首选寿命（以秒为单位）。如果temp_prefered_lft小于最小要求寿命（通常为5-7秒），首选寿命为最小要求寿命。如果temp_prefered_lft大于temp_valid_lft，则首选寿命为temp_valid_lft
默认值：86400（1天）

keep_addr_on_down - 整数
在接口关闭事件时保留所有IPv6地址。如果设置静态全局地址且没有过期时间，则不会清除这些地址
* >0 ：启用
* 0 ：系统默认值
* <0 ：禁用
默认值：0（地址被移除）

max_desync_factor - 整数
DESYNC_FACTOR的最大值，这是一个随机值，确保客户端不会同步并在同一时间生成新地址
该值以秒为单位
默认值：600

regen_min_advance - 整数
在当前临时地址失效前至少提前多少秒创建新的临时地址。此值加上可能需要的重复地址检测时间，以确定何时创建新地址。Linux允许将此值设置为小于默认的2秒，但小于2的值不符合RFC 8981的要求
默认值：2

regen_max_retry - 整数
在放弃尝试生成有效临时地址之前的最大重试次数
默认值：5

max_addresses - 整数
每个接口的最大自动配置地址数量。设置为零将禁用此限制。不建议将此值设置得过大（或设为零），因为这样很容易通过创建过多地址导致内核崩溃。
默认值：16

disable_ipv6 - 布尔值
禁用IPv6操作。如果accept_dad设置为2，并且链路本地地址的DAD（重复地址检测）失败，此值将动态设置为TRUE。
默认值：FALSE（启用IPv6操作）

当此值从1改为0（启用IPv6）时，它将在给定接口上动态创建一个链路本地地址并启动必要的重复地址检测。当此值从0改为1（禁用IPv6）时，它将动态删除给定接口上的所有地址和路由。从此以后，将无法向选定接口添加地址/路由。
accept_dad - 整数
是否接受DAD（重复地址检测）
== ==============================================================
  0 禁用DAD
  1 启用DAD（默认）
  2 启用DAD，并在发现基于MAC地址的重复链路本地地址时禁用IPv6操作
== ==============================================================

给定接口上的DAD操作和模式将根据conf/{all,interface}/accept_dad的最大值来选择。
force_tllao - 布尔值
即使在响应单播邻居请求时也发送目标链路层地址选项。
默认值：FALSE

引用自RFC 2461第4.4节，目标链路层地址：

“必须在多播请求中包含此选项，以避免当对等节点没有缓存条目返回邻居通告消息时发生无限的邻居请求‘递归’。在响应单播请求时，可以省略此选项，因为请求发送者已经有了正确的链路层地址；否则它将无法发送单播请求。然而，在这种情况下包含链路层地址增加了很少的开销，并消除了潜在的竞态条件，即发送者在收到对先前请求的响应之前删除了缓存的链路层地址。”

ndisc_notify - 布尔值
定义地址和设备更改的通知模式
* 0 - （默认）：不做任何事情
* 1 - 当设备启动或硬件地址更改时生成未请求的邻居通告
### ndisc_tclass - 整数
发送IPv6邻居发现（路由器请求、路由器通告、邻居请求、邻居通告、重定向）消息时，默认使用的IPv6流量类别。
这8位可以解释为：高6位表示DSCP值，低2位表示ECN（你可能希望保持清零）。
* 0 - （默认）

### ndisc_evict_nocarrier - 布尔值
在NOCARRIER事件发生时清除邻居发现表。此选项对于无线设备非常重要，因为在同一网络内漫游时不应清除邻居发现缓存。
在大多数情况下，应保持默认值（1）。
- 1 - （默认）：在NOCARRIER事件发生时清除邻居发现缓存
- 0 - 在NOCARRIER事件发生时不清除邻居发现缓存

### mldv1_unsolicited_report_interval - 整数
下一次未请求的MLDv1报告重新传输的时间间隔（以毫秒为单位）。
默认值：10000（10秒）

### mldv2_unsolicited_report_interval - 整数
下一次未请求的MLDv2报告重新传输的时间间隔（以毫秒为单位）。
默认值：1000（1秒）

### force_mld_version - 整数
* 0 - （默认）不强制使用特定版本的MLD，允许回退到MLDv1
* 1 - 强制使用MLD版本1
* 2 - 强制使用MLD版本2

### suppress_frag_ndisc - 整数
控制RFC 6980（IPv6分片与IPv6邻居发现的安全影响）的行为：
* 1 - （默认）丢弃分片的邻居发现数据包
* 0 - 允许分片的邻居发现数据包

### optimistic_dad - 布尔值
是否执行乐观的重复地址检测（RFC 4429）。
* 0：禁用（默认）
* 1：启用

如果`conf/{all,interface}/optimistic_dad`中至少有一个设置为1，则启用接口上的乐观重复地址检测；否则禁用。
### use_optimistic - 布尔值
如果启用，在源地址选择过程中不会将乐观地址分类为已弃用。优选地址仍然会在其他排名条件下优先于乐观地址被选择。
* 0：禁用（默认）
* 1：启用

如果 `conf/{all,interface}/use_optimistic` 中至少有一个设置为 1，则此选项将启用，否则禁用。

### stable_secret - IPv6 地址
此 IPv6 地址将作为生成链路本地地址和自动配置地址的秘密密钥。设置此秘密后生成的所有地址默认将是稳定的隐私地址。这可以通过 `addrgenmode ip-link` 进行更改。`conf/default/stable_secret` 用于命名空间的秘密，特定接口的设置可以覆盖它。拒绝写入 `conf/all/stable_secret` 的操作。

建议在系统安装时生成此秘密，并在此之后保持稳定。

默认情况下，稳定的秘密未设置。

### addr_gen_mode - 整数
定义如何生成链路本地和自动配置地址。
```
=  =================================================================
 0  根据 EUI64 生成地址（默认）
 1  不生成链路本地地址，使用 EUI64 生成自动配置地址
 2  使用 `stable_secret` 中的秘密生成稳定的隐私地址（RFC7217）
 3  如果未设置，则使用随机秘密生成稳定的隐私地址
=  =================================================================
```

### drop_unicast_in_l2_multicast - 布尔值
丢弃在链路层组播（或广播）帧中接收到的任何单播 IPv6 数据包。

默认情况下，此功能是关闭的。

### drop_unsolicited_na - 布尔值
丢弃所有未请求的邻居通告（Neighbor Advertisement），例如在网络中有已知的良好邻居代理时，不需要这些帧（或者在 802.11 网络中，必须丢弃这些帧以防止攻击）。

默认情况下，此功能是关闭的。

### accept_untracked_na - 整数
定义接受来自邻居缓存中不存在的设备的邻居通告的行为：
- 0 - （默认）不接受未请求且未跟踪的邻居通告
- 1 - 在接收到邻居通告（无论是主动请求的还是非主动请求的）并指定了目标链路层地址选项时，如果尚未为所通告的IPv6地址创建邻居条目，则在STALE状态中添加一个新的邻居缓存条目。如果没有这个设置，对于未被跟踪的地址（邻居缓存中不存在的地址），收到的邻居通告将被默默地忽略。
这是根据RFC9131中记录的路由器端行为。
此设置的优先级低于drop_unsolicited_na。
这将优化由直接连接的主机发起的初始离链路通信的返回路径，通过确保启用此设置的第一跳路由器不需要缓冲初始返回数据包来进行邻居请求。
前提条件是主机配置为在接口启动时发送非主动请求的邻居通告。此设置应与主机上的ndisc_notify设置一起使用以满足此前提条件。
- 2 - 扩展选项(1)，仅当源IP地址与接收邻居通告的接口上配置的地址在同一子网内时，才添加一个新的邻居缓存条目。

enhanced_dad - BOOLEAN
根据RFC7527，在用于重复地址检测的IPv6邻居请求消息中包含一个nonce选项。接收到的DAD NS只有在nonce不同的情况下才会指示重复地址。这避免了由于NS消息回环导致的重复地址误检测。
除非conf/{all,interface}/enhanced_dad均设置为FALSE，否则将在接口上发送nonce选项。
默认值：TRUE

``icmp/*``:
===========

ratelimit - INTEGER
限制发送ICMPv6消息的最大速率
设置为0表示不进行任何限制，
其他情况下，响应之间的最小间隔以毫秒为单位。
默认值：1000

`ratemask` - 逗号分隔的范围列表
对于匹配 `ratemask` 中范围的 ICMPv6 消息类型，根据 `ratelimit` 参数限制消息的发送。
输入和输出使用的格式是一个逗号分隔的范围列表（例如，“0-127,129” 表示 ICMPv6 消息类型 0 到 127 和 129）。写入文件会清除所有先前的 ICMPv6 消息类型范围，并用输入更新当前列表。
参考：https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml 获取 ICMPv6 消息类型的数值，例如回声请求为 128，回声回复为 129。
默认值：0-1,3-127（限制 ICMPv6 错误消息，但不包括包太大）

`echo_ignore_all` - 布尔值
如果设置为非零，则内核将忽略通过 IPv6 协议发送的所有 ICMP 回声请求。
默认值：0

`echo_ignore_multicast` - 布尔值
如果设置为非零，则内核将忽略通过多播方式发送的所有 ICMP 回声请求。
默认值：0

`echo_ignore_anycast` - 布尔值
如果设置为非零，则内核将忽略发送到任播地址的所有 ICMP 回声请求。
默认值：0

`error_anycast_as_unicast` - 布尔值
如果设置为 1，则内核将以 ICMP 错误响应发送到任播地址的请求，实际上将任播视为单播。
默认值：0

`xfrm6_gc_thresh` - 整数
（自 Linux 4.14 起已废弃）
开始对 IPv6 目的地缓存条目进行垃圾回收的阈值。在该值的两倍时，系统将拒绝新的分配。
IPv6 更新：
Pekka Savola <pekkas@netcore.fi>
YOSHIFUJI Hideaki / USAGI Project <yoshfuji@linux-ipv6.org>

/proc/sys/net/bridge/* 变量：
=================================

`bridge-nf-call-arptables` - 布尔值
- 1 ：将桥接的 ARP 流量传递给 arptables 的 FORWARD 链
- 0 ：禁用此功能
默认值：0
默认值：1

bridge-nf-call-iptables - 布尔值
- 1：将桥接的IPv4流量传递给iptables的链
- 0：禁用此功能
默认值：1

bridge-nf-call-ip6tables - 布尔值
- 1：将桥接的IPv6流量传递给ip6tables的链
- 0：禁用此功能
默认值：1

bridge-nf-filter-vlan-tagged - 布尔值
- 1：将桥接的带有VLAN标签的ARP/IP/IPv6流量传递给{arp,ip,ip6}tables
- 0：禁用此功能
默认值：0

bridge-nf-filter-pppoe-tagged - 布尔值
- 1：将桥接的带有PPPoE标签的IP/IPv6流量传递给{ip,ip6}tables
- 0：禁用此功能
默认值：0

bridge-nf-pass-vlan-input-dev - 布尔值
- 1：如果启用了bridge-nf-filter-vlan-tagged，则尝试在桥接上找到一个VLAN接口，并将netfilter输入设备设置为该VLAN。这允许使用例如“iptables -i br0.1”，并使带有桥接上的VLAN接口的REDIRECT目标生效。当未找到匹配的VLAN接口或此开关关闭时，输入设备将设置为桥接接口
- 0：禁用桥接netfilter VLAN接口查找
默认值：0

``proc/sys/net/sctp/*`` 变量：
==================================

addip_enable - 布尔值
启用或禁用 RFC5061 中指定的动态地址重新配置（ADD-IP）功能扩展。此扩展提供了动态添加和移除 SCTP 连接的新地址的能力。
1：启用扩展
0：禁用扩展
默认值：0

pf_enable - 整数值
启用或禁用 pf（pf 是 potentially failed 的缩写）状态。如果 pf_retrans > path_max_retrans，则也会禁用 pf 状态。也就是说，pf_enable 和 pf_retrans > path_max_retrans 中的一个可以禁用 pf 状态。由于 pf_retrans 和 path_max_retrans 可以由用户空间应用程序更改，有时用户希望通过 pf_retrans > path_max_retrans 的值来禁用 pf 状态，但偶尔用户应用程序会更改 pf_retrans 或 path_max_retrans 的值，从而使 pf 状态被启用。因此，需要添加这个选项来动态地启用和禁用 pf 状态。详情请参见：
https://datatracker.ietf.org/doc/draft-ietf-tsvwg-sctp-failover
1：启用 pf
0：禁用 pf
默认值：1

pf_expose - 整数值
取消设置或启用/禁用 pf（pf 是 potentially failed 的缩写）状态暴露。应用程序可以控制 SCTP_PEER_ADDR_CHANGE 事件和 SCTP_GET_PEER_ADDR_INFO 套接字选项中的 PF 路径状态的暴露。当取消设置时，不会发送带有 SCTP_ADDR_PF 状态的 SCTP_PEER_ADDR_CHANGE 事件，并且可以通过 SCTP_GET_PEER_ADDR_INFO 套接字选项获取 SCTP_PF 状态的传输信息；当启用时，将为变为 SCTP_PF 状态的传输发送一个 SCTP_PEER_ADDR_CHANGE 事件，并且可以通过 SCTP_GET_PEER_ADDR_INFO 套接字选项获取 SCTP_PF 状态的传输信息；当禁用时，不会发送 SCTP_PEER_ADDR_CHANGE 事件，并且在尝试通过 SCTP_GET_PEER_ADDR_INFO 套接字选项获取 SCTP_PF 状态的传输信息时返回 -EACCES。
0：取消设置 pf 状态暴露，与旧应用程序兼容
1：禁用 pf 状态暴露
2: 启用 pf 状态暴露  
默认值：0

addip_noauth_enable - 布尔值  
动态地址重新配置（ADD-IP）需要使用身份验证来保护添加或移除新地址的操作。此要求是为了防止未经授权的主机劫持关联。然而，旧实现可能在允许 ADD-IP 扩展时没有实现这一要求。出于互操作性的原因，我们提供此变量来控制身份验证要求的执行。

== ===================================================================================
1 允许在不进行身份验证的情况下使用 ADD-IP 扩展。这仅应在封闭环境中为与旧实现的互操作性而设置。
0 强制执行身份验证要求
== ===================================================================================

默认值：0

auth_enable - 布尔值  
启用或禁用身份验证扩展。此扩展提供了发送和接收经过身份验证的数据块的能力，并且是动态地址重新配置（ADD-IP）扩展安全运行所必需的。
- 1: 启用此扩展
- 0: 禁用此扩展
默认值：0

prsctp_enable - 布尔值  
启用或禁用部分可靠性扩展（RFC3758），该扩展用于通知对等方某个数据不再需要被期望。
- 1: 启用扩展
- 0: 禁用
默认值：1

max_burst - 整数  
初始可发送的新数据包数量的限制。它控制生成的流量的突发程度。
默认值：4

association_max_retrans - 整数  
设置一个关联尝试重传的最大次数，在决定远端不可达之前。如果超过此值，则终止关联。
默认值：10

max_init_retransmits - 整数  
在宣告目的地不可达并终止关联之前，一个关联将尝试重传 INIT 和 COOKIE-ECHO 数据块的最大次数。
默认值：未指定（原文中未给出具体数值）
默认值：8

path_max_retrans - 整数
在给定路径上尝试的最大重传次数。一旦超过此阈值，该路径将被视为不可达，并且新流量会在多宿关联中使用其他路径。
默认值：5

pf_retrans - 整数
在流量被重定向到备用传输（如果存在）之前，在给定路径上尝试的重传次数。注意这与path_max_retrans不同，因为即使一个路径超过了pf_retrans阈值，它仍然可以被使用。只有在传输路径由堆栈选择时才会对其降优先级。此设置主要用于启用快速故障切换机制，而无需将path_max_retrans降低到非常小的值。详情请参阅：http://www.ietf.org/id/draft-nishida-tsvwg-sctp-failover-05.txt。请注意，pf_retrans > path_max_retrans的值会禁用此功能。由于pf_retrans和path_max_retrans都可以由用户空间应用程序更改，因此使用了一个变量pf_enable来禁用pf状态。
默认值：0

ps_retrans - 整数
Primary.Switchover.Max.Retrans (PSMR)，这是一个来自rfc7829第5节“主路径切换”的可调参数。当旧主路径上的路径错误计数超过PSMR时，主路径将更改为另一个活动路径，以便“即使旧主目的地址重新变得活跃，SCTP发送方也可以继续在新的工作路径上进行数据传输”。注意此功能通过将'ps_retrans'默认初始化为每个netns的0xffff来禁用，并且其值在通过sysctl更改时不能小于'pf_retrans'。
默认值：0xffff

rto_initial - 整数
用于计算往返时间的初始往返超时值（以毫秒为单位）。这是重传的初始时间间隔。
默认值：3000

rto_max - 整数
往返超时的最大值（以毫秒为单位）。这是两次重传之间可以经过的最大时间间隔。
默认值：60000

rto_min - 整数
往返超时的最小值（以毫秒为单位）。这是两次重传之间可以经过的最短时间间隔。
默认值：1000

hb_interval - 整数
HEARTBEAT块之间的间隔（以毫秒为单位）。这些块在空闲路径上以指定的间隔发送，以探测两个关联之间的给定路径状态。
默认值：30000

sack_timeout - 整数
实现等待发送SACK的时间量（以毫秒为单位）。
默认值：200

valid_cookie_life - 整数
SCTP cookie的默认生命周期（以毫秒为单位）。cookie在关联建立期间使用。
默认值：60000

cookie_preserve_enable - 布尔值
启用或禁用扩展SCTP cookie生命周期的能力，该cookie在SCTP关联的建立阶段使用。

- 1: 启用cookie生命周期扩展
- 0: 禁用

默认值：1

cookie_hmac_alg - 字符串
选择在 INIT-ACK 数据块中由监听的 SCTP 套接字发送给连接客户端的 cookie 值时所使用的 HMAC 算法
有效值为：

- md5
- sha1
- none

能够将 md5 或 sha1 设置为选定算法的前提是在构建时配置了这些算法（CONFIG_CRYPTO_MD5 和 CONFIG_CRYPTO_SHA1）
默认值：取决于配置。如果可用则使用 MD5，否则如果可用则使用 SHA1，否则使用 none
rcvbuf_policy - 整数
确定接收缓冲区是否归属于套接字或关联。SCTP 支持在单个套接字上创建多个关联的能力。当使用此功能时，可能存在某个阻塞的关联正在缓存大量数据，从而通过消耗所有接收缓冲区空间阻止其他关联传递数据的情况。为了绕过这个问题，可以将 rcvbuf_policy 设置为将接收缓冲区空间分配给每个关联而不是整个套接字。这可以防止上述情况的发生。
- 1: 接收缓冲区空间按关联分配
- 0: 接收缓冲区空间按套接字分配

默认值：0

sndbuf_policy - 整数
类似于上面的 rcvbuf_policy，这适用于发送缓冲区空间
- 1: 发送缓冲区按关联跟踪
- 0: 发送缓冲区按套接字跟踪

默认值：0

sctp_mem - 包含 3 个整数的向量：最小值、压力值、最大值
所有 SCTP 套接字允许排队的页面数量
最小值：低于这个页面数量时，SCTP 不关心其内存需求。当 SCTP 分配的内存数量超过这个数值时，SCTP 开始调节内存使用
压力值：这个值是为了遵循 tcp_mem 的格式而引入的
最大值：所有 SCTP 套接字允许排队的页面数量
默认值是在启动时根据可用内存计算得出的。

`sctp_rmem` - 一个包含3个整数的向量：最小值、默认值、最大值  
仅使用第一个值（“最小值”），忽略“默认值”和“最大值”。  
最小值：SCTP套接字接收缓冲区的最小大小。  
即使在中等程度的内存压力下，每个SCTP套接字（但不是每个关联）都能保证这个最小值。  
默认值：4K

`sctp_wmem` - 一个包含3个整数的向量：最小值、默认值、最大值  
仅使用第一个值（“最小值”），忽略“默认值”和“最大值”。  
最小值：SCTP套接字可以使用的发送缓冲区的最小大小。  
即使在中等程度的内存压力下，每个SCTP套接字（但不是每个关联）都能保证这个最小值。  
默认值：4K

`addr_scope_policy` - 整数  
控制IPv4地址范围 —— 参照草案 draft-stewart-tsvwg-sctp-ipv4-00

- 0   - 禁用IPv4地址范围控制
- 1   - 启用IPv4地址范围控制
- 2   - 遵循草案但允许IPv4私有地址
- 3   - 遵循草案但允许IPv4链路本地地址

默认值：1

`udp_port` - 整数  
本地UDP隧道套接字的监听端口。通常使用IANA分配的UDP端口号9899（sctp-tunneling）。  
此UDP套接字用于处理RFC6951中定义的传入的UDP封装的SCTP数据包，并且在同一网络命名空间内的所有应用程序共享此UDP套接字。当设置为0时，此UDP套接字将被关闭。  
该值还将用于设置传出的UDP封装的SCTP数据包的UDP头部的源端口。关于目的端口，请参阅下面的`encap_port`。
默认值：0

encap_port - 整数
	默认的远程UDP封装端口
此值用于默认设置传出的UDP封装SCTP数据包的UDP头部的目标端口。用户也可以通过setsockopt为每个sock/asoc/transport更改该值。
如需更多信息，请参阅RFC6951。
注意，当连接到远程服务器时，客户端应将此值设置为对等服务器上UDP隧道sock监听的端口，并且客户端本地的UDP隧道sock也必须启动。在服务器端，它会从传入的数据包源端口获取encap_port。
默认值：0

plpmtud_probe_interval - 整数
	PLPMTUD探测计时器的时间间隔（以毫秒为单位），配置为在此时间段后到期以接收对探测数据包的确认。这也是当进行探测搜索时当前路径最大传输单元(pmtu)之间的探测时间间隔。
当设置为0时，PLPMTUD将被禁用，其他值必须>= 5000。
默认值：0

reconf_enable - 布尔值
	启用或禁用根据RFC6525中指定的流重组功能扩展。此扩展提供了“重置”流的能力，包括“传出/传入SSN重置”，“SSN/TSN重置”和“添加传出/传入流”的参数。
- 1: 启用扩展
- 0: 禁用扩展
默认值：0

intl_enable - 布尔值
	启用或禁用根据RFC8260中指定的用户消息交错功能扩展。此扩展允许在不同流上发送的用户消息交错。启用此功能时，如果对等方也支持，则I-DATA块将取代DATA块来传输用户消息。注意，要使用此功能，需要将此选项设置为1，并且还需要将套接字选项SCTP_FRAGMENT_INTERLEAVE设置为2，SCTP_INTERLEAVING_SUPPORTED设置为1。
```markdown
1: 启用扩展
0: 禁用扩展
默认值：0

ecn_enable - BOOLEAN
        控制 SCTP 使用显式拥塞通知 (ECN)
与 TCP 类似，只有当 SCTP 连接的两端都支持 ECN 时才会使用该功能。此功能有助于通过允许支持 ECN 的路由器在丢弃数据包之前发出拥塞信号来避免因拥塞导致的数据包丢失。
1: 启用 ECN
0: 禁用 ECN
默认值：1

l3mdev_accept - BOOLEAN
        启用此选项允许“全局”绑定的套接字在 L3 主域（例如，VRF）之间工作，并且能够接收不论其起始 L3 域的报文。仅在内核编译时包含 CONFIG_NET_L3_MASTER_DEV 配置项时有效。
默认值：1（启用）

``/proc/sys/net/core/*``
========================
        请参阅：Documentation/admin-guide/sysctl/net.rst 获取这些条目的描述

``/proc/sys/net/unix/*``
========================

max_dgram_qlen - 整数
        数据报套接字接收队列的最大长度

        默认值：10
```
