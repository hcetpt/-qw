SPDX 许可声明标识符: GPL-2.0

================================
UDP-Lite 协议（RFC 3828）
================================

UDP-Lite 是一个标准跟踪的 IETF 传输协议，其特点是具有可变长度的校验和。这在无线网络中传输多媒体（如视频、VoIP）时具有优势，因为部分损坏的数据包仍然可以被送入编解码器，而不会因为校验和失败而被丢弃。

此文件简要描述了现有的内核支持和套接字API。对于更详细的信息，您可以参考：

- UDP-Lite 主页：
  http://web.archive.org/web/%2E/http://www.erg.abdn.ac.uk/users/gerrit/udp-lite/

  您还可以从这里下载一些示例应用程序源代码。
- UDP-Lite 的HOWTO文档：
  http://web.archive.org/web/%2E/http://www.erg.abdn.ac.uk/users/gerrit/udp-lite/files/UDP-Lite-HOWTO.txt
- Wireshark 的 UDP-Lite 维基（包含捕获文件）：
  https://wiki.wireshark.org/Lightweight_User_Datagram_Protocol
- 协议规范，RFC 3828：http://www.ietf.org/rfc/rfc3828.txt

1. 应用程序
===============

多个应用程序已成功移植到 UDP-Lite。例如，Ethereal（现称为Wireshark）默认支持 UDP-Lite v4/v6。将应用程序移植到 UDP-Lite 很简单：只需更改套接字级别和 IPPROTO；发送方还需设置校验和覆盖长度（默认为头部长度=8）。具体细节见下文。

2. 编程 API
==================

UDP-Lite 提供了一个无连接、不可靠的数据报服务，因此使用与 UDP 相同的套接字类型。实际上，从 UDP 迁移到 UDP-Lite 非常容易：只需在 socket(2) 调用中添加 `IPPROTO_UDPLITE` 作为最后一个参数，使语句看起来像这样：

    ```c
    s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);
    ```

或者，

    ```c
    s = socket(PF_INET6, SOCK_DGRAM, IPPROTO_UDPLITE);
    ```

仅通过上述更改，您就能够运行 UDP-Lite 服务或连接到 UDP-Lite 服务器。内核会假设您不打算使用部分校验和覆盖，并因此模拟 UDP 模式（完全覆盖）。

为了利用部分校验和覆盖功能，需要设置一个套接字选项，该选项接收一个指定覆盖长度的整数：

- 发送方校验和覆盖：UDPLITE_SEND_CSCOV

  例如：

    ```c
    int val = 20;
    setsockopt(s, SOL_UDPLITE, UDPLITE_SEND_CSCOV, &val, sizeof(int));
    ```

  此设置将校验和覆盖长度设置为 20 字节（12 字节数据 + 8 字节头部）。每个数据包只有前 20 字节（加上伪头部）会被校验。这对具有 12 字节基本头部的 RTP 应用非常有用。

- 接收方校验和覆盖：UDPLITE_RECV_CSCOV

  此选项是接收方对应的选项。它是真正可选的，即不需要启用部分校验和覆盖的流量。它的功能相当于一个流量过滤器：当启用时，它指示内核丢弃所有覆盖长度小于该值的数据包。例如，如果希望保护 RTP 和 UDP 头部，接收方可以强制只接受最小覆盖长度为 20 的数据包：

    ```c
    int min = 20;
    setsockopt(s, SOL_UDPLITE, UDPLITE_RECV_CSCOV, &min, sizeof(int));
    ```

对 getsockopt(2) 的调用类似。由于 UDP-Lite 是一个扩展而不是独立的协议，所有 UDP 中已知的套接字选项都可以以与之前相同的方式使用，例如 UDP_CORK 或 UDP_ENCAP。

关于 UDP-Lite 校验和覆盖选项的详细讨论请参阅第四节。
3. 头文件
===============

  套接字API需要通过/usr/include中的头文件支持：

    * /usr/include/netinet/in.h
      用于定义IPPROTO_UDPLITE

    * /usr/include/netinet/udplite.h
      用于UDP-Lite的头部字段和协议常量

  为了测试目的，以下可以作为一个“迷你”头文件使用：

    ```plaintext
    #define IPPROTO_UDPLITE       136
    #define SOL_UDPLITE           136
    #define UDPLITE_SEND_CSCOV     10
    #define UDPLITE_RECV_CSCOV     11
    ```

  各种发行版的现成头文件在UDP-Lite的tarball中。

4. 内核对各种套接字选项的行为
=================================

  为了启用调试信息，日志级别需要设置为8，因为大多数消息使用的都是KERN_DEBUG级别（7）。

1) 发送方套接字选项

  如果发送方指定了0作为覆盖长度，模块将假设完全覆盖，并传输一个覆盖长度为0及其相应校验和的数据包。如果发送方指定了小于8且不等于0的覆盖长度，内核会默认使用8作为值。最后，如果指定的覆盖长度超过数据包长度，则使用数据包长度作为覆盖长度。

2) 接收方套接字选项

  接收方指定其愿意接受的最小覆盖长度值。这里的一个0值表示接收方希望整个数据包都被覆盖。在这种情况下，所有部分覆盖的数据包都将被丢弃，并记录错误。
非法值（<0 和 <8）是不可能指定的；在这些情况下，默认值为8。
所有到达时覆盖值小于指定阈值的数据包都会被丢弃，这些事件也会被记录。

3) 禁用校验和计算

  在发送方和接收方上，始终会执行校验和计算，并且不能使用SO_NO_CHECK禁用。因此：

  ```c
  setsockopt(sockfd, SOL_SOCKET, SO_NO_CHECK,  ... );
  ```

  总是会被忽略，而：

  ```c
  getsockopt(sockfd, SOL_SOCKET, SO_NO_CHECK, &value, ...);
  ```

  的返回值是没有意义的（正如TCP）。带有零校验和字段的数据包是非法的（参见RFC 3828，第3.1节），并将被静默丢弃。

4) 分片

  校验和计算同时考虑了缓冲区大小和MTU。UDP-Lite数据包的大小由发送缓冲区的大小决定。发送缓冲区的最小大小为2048（在include/net/sock.h中定义为SOCK_MIN_SNDBUF），默认值可以通过net.core.wmem_default配置或通过设置SO_SNDBUF套接字选项来更改。发送缓冲区的最大上限由net.core.wmem_max确定。
对于大于发送缓冲区大小的有效载荷大小，UDP-Lite会将有效载荷拆分成多个单独的数据包，在每种情况下都填满发送缓冲区的大小。
精确值还取决于接口的MTU。反过来，接口MTU可能会触发IP分片。在这种情况下，生成的UDP-Lite数据包将被拆分成几个IP数据包，其中只有第一个包含L4头部。
发送缓冲区大小对校验和覆盖长度有影响。考虑以下示例：

    数据负载：1536字节          发送缓冲区：1024字节
    最大传输单元（MTU）：1500字节          覆盖长度：856字节

UDP-Lite 将这 1536 字节分成两个独立的数据包进行传输：

    数据包 1：1024字节数据负载 + 8字节头部 + 20字节IP头部 = 1052字节
    数据包 2：512字节数据负载 + 8字节头部 + 20字节IP头部 = 540字节

覆盖数据包覆盖了第一个数据包中的 UDP-Lite 头部和 848 字节的数据负载，第二个数据包则被完全覆盖。需要注意的是，对于第二个数据包，覆盖长度超过了数据包的长度。在这种情况下，内核会自动调整覆盖长度以匹配数据包的实际长度。

作为当一个 UDP-Lite 数据包被分割成多个小片段时会发生什么情况的一个例子，考虑以下示例：

    数据负载：1024字节              发送缓冲区大小：1024字节
    最大传输单元（MTU）：300字节          覆盖长度：575字节

    +-+-----------+--------------+--------------+--------------+
    |8|    272    |      280     |     280      |     280      |
    +-+-----------+--------------+--------------+--------------+
        280            560            840           1032
                 ^
    *****校验和覆盖*************

UDP-Lite 模块生成了一个 1032 字节的数据包（1024字节数据负载 + 8字节头部）。根据接口的最大传输单元（MTU），这些数据包将被分割成四个 IP 数据包（280字节 IP 数据负载 + 20字节 IP 头部）。内核模块在将这些片段传递给 IP 模块之前，会计算前两个数据包的全部内容以及最后一个数据包的前 15 字节的校验和。

要查看类似情况下 IPv6 分片的情况，请考虑链路最大传输单元（MTU）为 1280 字节，写缓冲区为 3356 字节。如果校验和覆盖长度小于 1232 字节（MTU 减去 IPv6/分片头部长度），则只需要考虑第一个分片。当使用更大的校验和覆盖长度时，每个符合条件的分片都需要进行校验。假设我们有一个 3062 字节的校验和覆盖长度。3356 字节的缓冲区将被分割成如下分片：

    分片 1：1280字节，携带 1232 字节的 UDP-Lite 数据
    分片 2：1280字节，携带 1232 字节的 UDP-Lite 数据
    分片 3：948字节，携带 900 字节的 UDP-Lite 数据

前两个分片需要完全校验，而最后一个分片只有 598 字节（= 3062 - 2 * 1232）需要校验。

虽然正确处理这种情况很重要，但这种情况（令人烦恼地）很少见：UDP-Lite 是为了优化无线（或通常嘈杂的）链路上的多媒体性能而设计的，因此较小的覆盖长度可能是预期的。

5. UDP-Lite 运行时统计信息及其含义
===================================

异常和错误条件会被记录到 syslog 中，日志级别为 KERN_DEBUG。关于 UDP-Lite 的实时统计信息可以在 `/proc/net/snmp` 中找到，并且（对于较新版本的 netstat）可以通过以下命令查看：

    netstat -svu

这会显示 UDP-Lite 统计变量，其含义如下：

============     =====================================================
  InDatagrams      交付给用户的总数据报数量
  NoPorts          接收到的未知端口的数据包数量
  这些情况是单独计数的（不计入 InErrors）
  InErrors         错误的 UDP-Lite 数据包的数量。错误包括：

                    * 内部套接字队列接收错误
                    * 数据包太短（少于 8 字节或声明的覆盖长度超过接收到的长度）
                    * xfrm4_policy_check() 返回错误
                    * 应用程序指定的最小覆盖长度大于传入数据包的覆盖长度
                    * 校验和覆盖违反
                    * 校验和错误
  OutDatagrams     发送的总数据报数量
这些统计数据来源于UDP MIB（RFC 2013）

6. IPtables
===========

  支持UDP-Lite的数据包匹配以及对LOG目标的支持。如果你将以下行复制并粘贴到 `/etc/protocols` 中：

    ```plaintext
    udplite 136     UDP-Lite        # UDP-Lite [RFC 3828]
    ```

  那么：

    ```plaintext
    iptables -A INPUT -p udplite -j LOG
    ```

  将会产生日志输出到syslog。丢弃和拒绝数据包也有效。

7. 维护者地址
=====================

  UDP-Lite补丁是在以下地址开发的：

		    阿伯丁大学
		    电子研究组
		    工程系
		    弗雷泽·诺布尔大楼
		    阿伯丁 AB24 3UE；英国

  当前的维护者是Gerrit Renker，<gerrit@erg.abdn.ac.uk>。最初的代码由William Stanislaus开发，<william@erg.abdn.ac.uk>。
