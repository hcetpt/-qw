SPDX 许可声明标识符：GPL-2.0

================================
UDP-Lite 协议（RFC 3828）
================================


  UDP-Lite 是 IETF 的标准路径传输协议，其特征是具有可变长度的校验和。这对于通过无线网络传输多媒体（如视频、VoIP）具有优势，因为部分损坏的数据包仍然可以被送入编解码器而不是由于校验和检查失败而被丢弃。本文件简要描述了现有内核的支持和套接字API。对于深入信息，您可以参考：

   - UDP-Lite 主页：
     http://web.archive.org/web/%2E/http://www.erg.abdn.ac.uk/users/gerrit/udp-lite/

     您还可以从此处下载一些示例应用程序源代码。
- UDP-Lite 的指南文档位于
     http://web.archive.org/web/%2E/http://www.erg.abdn.ac.uk/users/gerrit/udp-lite/files/UDP-Lite-HOWTO.txt

   - Wireshark 的 UDP-Lite 维基（附带捕获文件）：
     https://wiki.wireshark.org/Lightweight_User_Datagram_Protocol

   - 协议规范，RFC 3828，http://www.ietf.org/rfc/rfc3828.txt


1. 应用程序
===============

  已经有几个应用程序成功地移植到了 UDP-Lite。Ethereal（现称为 Wireshark）默认支持 UDP-Lite v4/v6。
将应用程序移植到 UDP-Lite 直截了当：只需更改套接字级别和 IPPROTO；发送者还需设置校验和覆盖长度（默认值=头部长度=8）。详细信息请参见下一节。
2. 编程API
==================

  UDP-Lite 提供了一个无连接、不可靠的数据报服务，因此它使用与 UDP 相同的套接字类型。事实上，从 UDP 到 UDP-Lite 的移植非常简单：只需在 socket(2) 调用中添加 `IPPROTO_UDPLITE` 作为最后一个参数，使语句看起来像这样：

      s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);

  或者，

  ::

      s = socket(PF_INET6, SOCK_DGRAM, IPPROTO_UDPLITE);

  仅做以上更改后，您就可以运行 UDP-Lite 服务或连接到 UDP-Lite 服务器。内核会假设您不打算使用部分校验和覆盖，并因此模拟 UDP 模式（全覆盖）。
为了利用部分校验和覆盖功能，需要设置一个套接字选项，该选项接受一个整数来指定覆盖长度：

    * 发送方校验和覆盖：UDPLITE_SEND_CSCOV

      例如：

	int val = 20;
	setsockopt(s, SOL_UDPLITE, UDPLITE_SEND_CSCOV, &val, sizeof(int));

      将校验和覆盖长度设置为 20 字节（12 字节数据 + 8 字节头部）。每个数据包只有前 20 字节（加上伪头部）会被校验。这对于 RTP 应用程序很有用，这些应用通常有一个 12 字节的基础头部。
* 接收方校验和覆盖：UDPLITE_RECV_CSCOV

      此选项是接收端的对应项。它是真正可选的，即不需要启用部分校验和覆盖的流量。它的功能相当于一个流量过滤器：当启用时，它指示内核丢弃所有覆盖少于这个值的数据包。例如，如果希望保护 RTP 和 UDP 头部，则接收方可以强制只接受最小覆盖为 20 的数据包：

	int min = 20;
	setsockopt(s, SOL_UDPLITE, UDPLITE_RECV_CSCOV, &min, sizeof(int));

  对 getsockopt(2) 的调用是类似的。作为一个扩展而非独立协议，所有之前在 UDP 中已知的套接字选项都可以以完全相同的方式使用，例如 UDP_CORK 或 UDP_ENCAP。
关于 UDP-Lite 校验和覆盖选项的详细讨论，请参阅第四节。
3. 头文件
===============

  socket API 需要通过位于 /usr/include 中的头文件来支持：

    * /usr/include/netinet/in.h
      用于定义 IPPROTO_UDPLITE

    * /usr/include/netinet/udplite.h
      用于 UDP-Lite 的头部字段和协议常量

  对于测试目的，以下可以作为一个“迷你”头文件使用：

    ```plaintext
    #define IPPROTO_UDPLITE       136
    #define SOL_UDPLITE           136
    #define UDPLITE_SEND_CSCOV     10
    #define UDPLITE_RECV_CSCOV     11
    ```

  各种发行版的现成头文件可以在 UDP-Lite 的压缩包中找到。

4. 内核对于各种套接字选项的行为
==============================================================

  要启用调试消息，需要将日志级别设置为 8，因为大多数消息使用的是 KERN_DEBUG 级别（7）。

1) 发送方套接字选项

  如果发送方指定的覆盖长度值为 0，则模块假定为完全覆盖，并发送一个覆盖长度为 0 及相应校验和的数据包。如果发送方指定的覆盖长度小于 8 且不为 0，则内核默认采用 8。最后，如果指定的覆盖长度超过了数据包长度，则使用数据包长度作为覆盖长度。

2) 接收方套接字选项

  接收方指定其愿意接受的最小覆盖长度值。这里的一个值为 0 表示接收方总是希望整个数据包被覆盖。在这种情况下，所有部分覆盖的数据包都会被丢弃并记录错误信息。
非法值（<0 和 <8）是不可能被指定的；在这些情况下，默认假设值为 8。
所有到达时覆盖值小于指定阈值的数据包都会被丢弃，这些事件也会被记录。

3) 禁用校验和计算

  在发送方和接收方上，都将始终执行校验和计算，不能使用 SO_NO_CHECK 来禁用。因此：

  ```c
  setsockopt(sockfd, SOL_SOCKET, SO_NO_CHECK,  ... );
  ```

  始终会被忽略，而以下值：

  ```c
  getsockopt(sockfd, SOL_SOCKET, SO_NO_CHECK, &value, ...);
  ```

  没有意义（就像在 TCP 中一样）。带有零校验和字段的数据包是非法的（参见 RFC 3828 第 3.1 节），将会被静默丢弃。

4) 分片

  校验和计算会考虑到缓冲区大小和 MTU。UDP-Lite 数据包的大小由发送缓冲区的大小决定。发送缓冲区的最小大小为 2048（在 include/net/sock.h 中定义为 SOCK_MIN_SNDBUF），默认值可以通过 net.core.wmem_default 或设置套接字选项 SO_SNDBUF (参见 socket(7)) 进行配置。发送缓冲区的最大上限由 net.core.wmem_max 确定。
当负载大小大于发送缓冲区大小时，UDP-Lite 将把负载分割成多个独立的数据包，每次都填满发送缓冲区的大小。
具体的值还取决于接口 MTU。反过来，接口 MTU 可能触发 IP 分片。在这种情况下，生成的 UDP-Lite 数据包会被拆分成几个 IP 数据包，其中只有第一个数据包包含第 4 层头部。
发送缓冲区大小对校验和覆盖长度有影响。考虑以下示例：

    有效载荷：1536 字节          发送缓冲区：     1024 字节
    最大传输单元（MTU）：     1500 字节          覆盖长度：  856 字节

  UDP-Lite 将以两个独立的数据包发送这 1536 字节：

    数据包 1：1024 字节的有效载荷 + 8 字节的头部 + 20 字节的 IP 头部 = 1052 字节
    数据包 2： 512 字节的有效载荷 + 8 字节的头部 + 20 字节的 IP 头部 =  540 字节

  覆盖数据包覆盖了第一个数据包中的 UDP-Lite 头部和 848 字节的有效载荷，第二个数据包被完全覆盖。请注意，对于第二个数据包，覆盖长度超过了数据包长度。在这种情况下，内核总是会将覆盖长度重新调整为数据包长度。
作为当一个 UDP-Lite 数据包被分割成几个小片段时会发生什么情况的一个例子，请考虑以下示例：

    有效载荷：1024 字节            发送缓冲区大小：1024 字节
    最大传输单元（MTU）：      300 字节            覆盖长度：   575 字节

    +-+-----------+--------------+--------------+--------------+
    |8|    272    |      280     |     280      |     280      |
    +-+-----------+--------------+--------------+--------------+
		280            560            840           1032
					^
    *****校验和覆盖*************

  UDP-Lite 模块生成一个 1032 字节的数据包（1024 字节加上 8 字节的头部）。根据接口的最大传输单元（MTU），这些数据被分割成 4 个 IP 数据包（280 字节的 IP 有效载荷加上 20 字节的 IP 头部）。内核模块在将这些片段释放到 IP 模块之前，会对整个前两个数据包的内容以及最后一个数据包的前 15 字节进行求和。
要了解 IPv6 分片中类似的情况，请考虑一个链路最大传输单元（MTU）为 1280 字节和写缓冲区为 3356 字节的情况。如果校验和覆盖长度小于 1232 字节（最大传输单元减去 IPv6/分片头部长度），则只需要考虑第一个分片。使用较大的校验和覆盖长度时，每个符合条件的分片都需要进行校验和计算。假设我们有一个 3062 的校验和覆盖长度。3356 字节的缓冲区将被分割成以下分片：

    分片 1：1280 字节，携带  1232 字节的 UDP-Lite 数据
    分片 2：1280 字节，携带  1232 字节的 UDP-Lite 数据
    分片 3： 948 字节，携带   900 字节的 UDP-Lite 数据

  前两个分片需要完全进行校验和计算，最后一个分片只有 598 字节（= 3062 - 2*1232）需要进行校验和计算。
虽然处理这类情况非常重要，但它们（令人恼火地）很少出现：UDP-Lite 是为优化无线（或一般噪声环境下的）多媒体性能而设计的，因此较小的覆盖长度可能是预期的。
5. UDP-Lite 运行时统计信息及其含义
=====================================

  异常和错误条件会以 KERN_DEBUG 级别记录到系统日志中。关于 UDP-Lite 的实时统计信息可以在 /proc/net/snmp 中获取，并且（对于较新版本的 netstat）可以通过以下命令查看：

			    netstat -svu

  这显示了 UDP-Lite 统计变量，其含义如下：
============     =====================================================
   收到的数据报      交付给用户的总数据报数
未知端口          接收到的未知端口的数据包数量
这些情况是单独计数的（不计入 InErrors）
错误数据报        错误的 UDP-Lite 数据包的数量。错误包括：

		      * 内部套接字队列接收错误
		      * 数据包太短（少于 8 字节或声明的覆盖长度超过接收长度）
		      * xfrm4_policy_check() 返回错误
		      * 应用程序指定的最小覆盖长度大于传入数据包的覆盖长度
		      * 校验和覆盖被违反
		      * 校验和错误

   发送的数据报     总发送的数据报数
这些统计信息来源于 UDP MIB（RFC 2013）。

6. IPtables
===========

对于 UDP-Lite，有数据包匹配支持以及对 LOG 目标的支持。如果你将下面这行复制并粘贴到 `/etc/protocols` 文件中：

    udplite 136     UDP-Lite        # UDP-Lite [RFC 3828]

那么：

	      iptables -A INPUT -p udplite -j LOG

将会生成记录输出到系统日志中。丢弃和拒绝数据包也是可行的。

7. 维护者地址
=============

UDP-Lite 补丁是在以下地点开发的：

		    英国阿伯丁大学
		    电子研究小组
		    工程系
		    弗雷泽·诺布尔大楼
		    阿伯丁 AB24 3UE；英国

当前的维护者是 Gerrit Renker，<gerrit@erg.abdn.ac.uk>。最初的代码是由 William Stanislaus 开发的，<william@erg.abdn.ac.uk>。
