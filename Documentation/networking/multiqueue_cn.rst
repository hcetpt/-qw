### SPDX 许可证标识符: GPL-2.0

===========================================
多队列网络设备支持的使用说明
===========================================

**第 1 节：实现多队列支持的基本驱动程序要求**
=======================================================================

**简介：内核对多队列设备的支持**

内核对多队列设备的支持始终存在。
基本驱动程序需要使用新的 `alloc_etherdev_mq()` 或 `alloc_netdev_mq()` 函数来为设备分配子队列。底层内核API将负责子队列内存的分配和释放，以及确定队列在内存中的位置的netdev配置。
基本驱动程序还需要像管理全局 `netdev->queue_lock` 那样管理队列。因此，在设备仍在运行时，基本驱动程序应使用 `netif_{start|stop|wake}_subqueue()` 函数来管理每个队列。当设备上线或完全关闭（例如 `unregister_netdev()` 等）时，仍然使用 `netdev->queue_lock`。

**第 2 节：多队列设备的队列调度器（qdisc）支持**
===============================================

目前有两种队列调度器针对多队列设备进行了优化。第一个是默认的 `pfifo_fast` 队列调度器。该队列调度器支持每个硬件队列一个队列调度器。
新增了一个循环轮询队列调度器 `sch_multiq`，也支持多个硬件队列。队列调度器负责根据 `skb->queue_mapping` 的值对 skb 进行分类，并将其定向到相应的带宽和队列。在基本驱动程序中使用此字段来确定将 skb 发送到哪个队列。
`sch_multiq` 是为希望避免头端阻塞的硬件而添加的。它将循环遍历各个带宽，并在从队列中提取数据包之前验证与带宽关联的硬件队列是否未停止。
加载队列调度器时，带宽数量基于硬件上的队列数量。一旦建立了关联，任何设置了 `skb->queue_mapping` 的 skb 都会被排队到与硬件队列关联的带宽中。

**第 3 节：使用 MULTIQ 对多队列设备进行简要说明**
==========================================================

用户空间命令 `tc`（iproute2 包的一部分）用于配置队列调度器。为了将 MULTIQ 队列调度器添加到您的网络设备（假设设备名为 eth0），请运行以下命令：

    # tc qdisc add dev eth0 root handle 1: multiq

队列调度器将分配与设备报告的队列数量相等的带宽数量，并使队列调度器上线。假设 eth0 有 4 个发送队列，则带宽映射将如下所示：

    带宽 0 => 队列 0
    带宽 1 => 队列 1
    带宽 2 => 队列 2
    带宽 3 => 队列 3

流量将开始根据简单的 `simple_tx_hash` 函数或根据定义的 `netdev->select_queue()` 流经每个队列。
队列过滤器的行为保持不变。但是，添加了一个新的队列操作 `skbedit`。假设您想将所有发往特定主机（例如 192.168.0.3）的流量通过特定队列发送，您可以使用此操作并设置过滤器，例如：

    tc filter add dev eth0 parent 1: protocol ip prio 1 u32 \
            match ip dst 192.168.0.3 \
            action skbedit queue_mapping 3

**作者:** Alexander Duyck <alexander.h.duyck@intel.com>
**原始作者:** Peter P. Waskiewicz Jr. <peter.p.waskiewicz.jr@intel.com>
