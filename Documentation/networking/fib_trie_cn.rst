SPDX 许可证标识符: GPL-2.0

============================
LC-trie 实现说明
============================

节点类型
----------
leaf
    一个带有数据的终端节点。它包含相关键的一个副本，以及按前缀长度排序的路由表项 'hlist'
详见 struct leaf 和 struct leaf_info
trie 节点或 tnode
    一个内部节点，包含指向子节点（leaf 或 tnode）的指针数组，通过键的一部分进行索引。详见级压缩（Level Compression）

一些概念解释
------------------------
Bits (tnode)
    在键段中用于索引子节点数组的位数——“子索引”。详见级压缩（Level Compression）
Pos (tnode)
    用于索引子节点数组的键段在键中的位置。详见路径压缩（Path Compression）
路径压缩 / 跳过的位
    每个给定的 tnode 都通过其父节点的 “pos” 和 “bits” 指定的键段链接到父节点的子数组。
    在某些情况下，这个 tnode 的 “pos” 并不紧邻父节点的 (pos+bits)，而是跳过了键中的一些位，
    因为这些位表示了一条没有分支的单一路径。这些 “跳过的位” 构成了路径压缩。
    注意搜索算法在搜索时会直接跳过这些位，因此需要保存叶子中的键来验证它们是否确实与我们正在搜索的键匹配。
级压缩 / 子数组
    trie 在一定条件下保持层级平衡，将满子节点（见 "full_children"）的子节点向上移动一级，
    这样就不会是一个纯二叉树，每个内部节点（"tnode"）可能包含一个任意大小的子节点链接数组。
相反，如果 tnode 的子数组大部分为空（见 empty_children），则可以将其“减半”，
    将一些子节点向下移动一级，以避免子数组不断增加。
empty_children
    给定 tnode 的子数组中 NULL 位置的数量
### `full_children`
给定 `tnode` 的子节点中未进行路径压缩的子节点数量（换句话说，它们不是 `NULL` 或叶子节点，并且它们的 `pos` 等于该 `tnode` 的 `pos` + `bits`）。
（这里的“full”更多地是指“完整”，而不是“非空”，这可能会有些令人困惑。）

### 评论
我们尽量使代码结构尽可能接近 `fib_hash`，以便验证和帮助审查。

- `fib_find_node()`
  - 理解这段代码的良好起点。这个函数实现了简单的 Trie 查找。

- `fib_insert_node()`
  - 在 Trie 中插入一个新的叶节点。这比 `fib_find_node()` 复杂一些。插入新节点意味着我们可能需要对 Trie 的一部分运行层级压缩算法。

- `trie_leaf_remove()`
  - 查找一个键，删除它并运行层级压缩算法。

- `trie_rebalance()`
  - 在 Trie 发生任何更改后，这是动态 Trie 的关键函数。它会从给定的 `tnode` 向上遍历到根节点，在每一步执行 `resize()` 以实现层级压缩。

- `resize()`
  - 分析一个 `tnode` 并通过反复膨胀或缩小其子数组大小来优化，直到满足最优层级压缩的标准。这部分遵循原始论文，并且可能有一些实验空间。

- `inflate()`
  - 将 `tnode` 内部的子数组大小加倍。由 `resize()` 使用。

- `halve()`
  - 将 `tnode` 内部的子数组大小减半，是 `inflate()` 的逆操作。由 `resize()` 使用。

- `fn_trie_insert()`, `fn_trie_delete()`, `fn_trie_select_default()`
  - 路由操作函数。应该与 `fib_hash` 中相应的函数非常接近。
### `fn_trie_flush()`
该函数遍历整个前缀树（使用`nextleaf()`），并查找需要移除的空叶子节点。

### `fn_trie_dump()`
按照前缀长度顺序输出路由表。与对应的`fib_hash`函数相比，这个操作速度较慢，因为我们必须为每个前缀长度遍历整个前缀树。相比之下，`fib_hash`是按前缀长度组织的，每个前缀长度对应一个“区域”/哈希表。

### 锁定
---

`fib_lock`用于实现读写锁，其用法与`fib_hash`中的相同。然而，这些函数在其他可能的锁定场景中有所分离。理论上，可以通过RCU运行`trie_rebalance`来避免在`fn_trie_lookup()`函数中使用`read_lock`。

### 主要查找机制
---------------------
`fn_trie_lookup()`是主要的查找函数。
查找过程最简单的形式类似于`fib_find_node()`。我们逐段键值下降前缀树，直到找到一个叶子节点。`check_leaf()`在叶子节点的排序前缀链表中执行`fib_semantic_match`。

如果找到匹配项，查找完成。
如果没有找到匹配项，进入前缀匹配模式。前缀长度最初与键长度相同，然后逐步减少，并回溯前缀树以找到最长匹配前缀。目标始终是到达一个叶子节点并从`fib_semantic_match`机制中获得一个正向结果。

在每个`tnode`内部，寻找最长匹配前缀的过程包括搜索子数组，逐个将子索引的最低有效位清零，直到找到匹配项或子索引完全由零组成。

此时我们回溯（`t->stats.backtrack++`）上层前缀树，继续截断部分键值以找到最长匹配前缀。
在这一点上，我们将反复下降子trie以寻找匹配项，并且有一些优化措施可以为我们提供“捷径”，以避免进入死胡同。在代码中查找标记为“HL_OPTIMIZE”的部分。
为了消除对路由选择过程正确性的任何疑虑，新增加了一个netlink操作。查找NETLINK_FIB_LOOKUP，它允许用户空间访问fib_lookup()函数。
