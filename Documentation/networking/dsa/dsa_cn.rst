### 架构

本文件描述了**分布式交换架构（DSA）**子系统的设原则、限制、与其他子系统之间的交互方式，以及如何为该子系统开发驱动程序，同时也为有兴趣加入开发工作的开发者提供了一个待办事项列表。

#### 设计原则

分布式交换架构子系统最初主要设计用于支持Marvell以太网交换机（MV88E6xxx，即Link Street产品线）在Linux环境下的使用，但之后也扩展支持其他厂商的产品。此设计最初的哲学是能够使未经修改的Linux工具如bridge、iproute2、ifconfig等透明地工作，无论是配置/查询交换机端口网络设备还是常规网络设备。

一个以太网交换机通常包含多个前面板端口和一个或多个CPU或管理端口。目前DSA子系统依赖于存在一个连接到可以从交换机接收以太网帧的以太网控制器的管理端口。这是各种小型家庭和办公室产品中常见的设置：路由器、网关，甚至是机架顶部的交换机。这个主机以太网控制器在DSA术语和代码中将被称作“导管”（conduit）和“cpu”。

DSA中的"D"代表分布式，因为该子系统设计时考虑到了通过上行链路和下行链路在彼此之上配置和管理级联的交换机的能力。这些特定的端口在DSA术语和代码中被称为“dsa”端口。多个相互连接的交换机集合被称为“交换树”。

对于每个前面板端口，DSA创建专门的网络设备作为Linux网络堆栈使用的控制和数据流终点。这些专门的网络接口在DSA术语和代码中被称为“用户”网络接口。

使用DSA的理想情况是当以太网交换机支持“交换标签”，这是一种硬件特性，使得交换机可以为从特定端口接收到的每个以太网帧插入一个特定的标签，帮助管理接口确定：

- 此帧来自哪个端口
- 此帧被转发的原因是什么
- 如何发送由CPU生成的流量到特定端口

该子系统确实支持不具有插入/剥离标签能力的交换机，但是这种情况下功能可能会稍有受限（流量分离依赖于基于端口的VLAN ID）。

需要注意的是，目前DSA子系统不会为“cpu”和“dsa”端口创建网络接口，原因是：

- “cpu”端口是管理控制器面向以太网交换机的一侧，因此会形成特性重复，因为你将得到两个同一导管的接口：导管网络设备（conduit netdev）和“cpu”网络设备。

- “dsa”端口只是两个或多个交换机之间的导管，因此不能真正用作合适的网络接口，只有下游或最上游的接口在这个模型下才有意义。

**注**：过去15年来，DSA子系统一直使用术语“主控”（而不是“导管”）和“从属”（而不是“用户”）。这些术语已从DSA代码库中移除，并逐步从uAPI中淘汰。

#### 交换标签协议

DSA支持许多特定于供应商的标签协议、一种软件定义的标签协议以及无标签模式（`DSA_TAG_PROTO_NONE`）。

标签协议的具体格式因供应商而异，但总体而言，它们都包含一些信息来：

- 确定以太网帧来自或应发送到哪个端口
- 提供此帧被转发到管理接口的原因

所有标签协议都在`net/dsa/tag_*.c`文件中实现，并实现了`struct dsa_device_ops`结构的方法，具体细节如下。
标记协议通常属于以下三种类别之一：

1. 交换机特定的帧头位于以太网头部之前，从 DSA 通道的帧解析器的角度来看，这将 MAC 目的地址（DA）、MAC 源地址（SA）、EtherType 和整个第二层（L2）负载向右移动。
2. 交换机特定的帧头位于 EtherType 之前，保持 MAC 目的地址（DA）和 MAC 源地址（SA）不变，但从 DSA 通道的角度看，真正的 EtherType 和 L2 负载被向右移动。
3. 交换机特定的帧头位于数据包尾部，所有帧头保持不变，并且不改变 DSA 通道的帧解析器所看到的数据包视图。

标记协议可能为所有数据包打上相同长度的交换标签，或者标签长度可能会有所不同（例如带有精确时间协议（PTP）时间戳的数据包可能需要更长的交换标签，或者在发送时使用一种标签长度，在接收时使用另一种）。无论如何，标记协议驱动程序必须填充 `struct dsa_device_ops::needed_headroom` 和/或 `struct dsa_device_ops::needed_tailroom`，以最长的交换帧头/尾部长度（以八位字节为单位）。DSA 框架会自动调整通道接口的最大传输单元（MTU），以适应这些额外大小，以便 DSA 用户端口能够支持标准的 MTU（L2 负载长度）1500 八位字节。`needed_headroom` 和 `needed_tailroom` 属性还用于尽力请求网络栈分配具有足够额外空间的数据包，从而在发送数据包时添加交换标签不会因为内存不足而重新分配。

尽管应用程序不期望解析 DSA 特定的帧头，但标记协议在电线上的格式代表了一个由内核向用户空间暴露的应用二进制接口，适用于诸如 `libpcap` 的解码器。标记协议驱动程序必须用一个唯一描述硬件交换机与数据路径驱动程序之间所需交互特性的值填充 `struct dsa_device_ops` 中的 `proto` 成员：帧头中每个位字段的偏移量以及处理帧所需的任何状态化处理（如 PTP 时间戳可能需要的）。

从网络栈的角度来看，同一 DSA 交换树中的所有交换机都使用相同的标记协议。对于通过多个交换机的织物传输的数据包，交换机特定的帧头由该数据包接收到的第一个织物中的交换机插入。此头部通常包含有关其类型的信息（是否是必须捕获到 CPU 的控制帧，还是转发的数据帧）。

控制帧应仅由软件数据路径解封装，而数据帧也可能自主地转发到同一织物中其他交换机的其他用户端口，在这种情况下，最外层交换端口必须解封装数据包。

值得注意的是，在某些情况下，叶交换机（未直接连接到 CPU）使用的标记格式可能与网络栈所见的不同。这一点在 Marvell 交换机树中可以观察到，其中 CPU 端口可以配置为使用 DSA 或 Ethertype DSA（EDSA）格式，但 DSA 链接被配置为使用较短的（不含 EtherType）DSA 帧头，以减少自主数据包转发的开销。

即使 DSA 交换树被配置为 EDSA 标记协议，操作系统仍然可以看到来自叶交换机的 EDSA 标记数据包，这些交换机使用较短的 DSA 头进行标记。这是因为直接连接到 CPU 的 Marvell 交换机被配置为执行 DSA 和 EDSA 之间的标记转换（即简单地添加或删除 `ETH_P_EDSA` EtherType 和一些填充八位字节的操作）。

即使它们的标记协议彼此不兼容，也有可能构建 DSA 交换机级联设置。在这种情况下，此织物中没有 DSA 链接，每个交换机构成了一个独立的 DSA 交换树。DSA 链接被视为一个 DSA 通道（上游 DSA 交换机的面向外部端口）和一个 CPU 端口（下游 DSA 交换机的面向内部端口）的组合。
附件中的DSA交换机树的标签协议可以通过`dsa/tagging` sysfs属性查看，该属性位于DSA通道中：

    cat /sys/class/net/eth0/dsa/tagging

如果硬件和驱动程序支持，在运行时可以更改DSA交换机树的标签协议。这通过向上述相同的sysfs设备属性（DSA通道及其所有连接的交换端口在此期间必须处于关闭状态）写入新的标签协议名称来实现。
希望所有标签协议都能通过`dsa_loop`模拟驱动进行测试，该驱动可以连接到任何网络接口。目标是任何网络接口都应该能够以相同的方式传输相同的报文，并且标签器应该能够以相同的方式解码接收到的相同报文，无论用于交换控制路径的驱动程序或用于DSA通道的驱动程序如何。
报文的发送会经过标签器的`xmit`函数。传递的`struct sk_buff *skb`中的`skb->data`指向`skb_mac_header(skb)`，即目标MAC地址，而传递的`struct net_device *dev`表示虚拟的DSA用户网络接口，该接口的硬件对应部分需要将报文导向（例如`swp0`）。
此方法的任务是以一种使交换机能理解报文对应的出口端口的方式准备skb（并且不会将其递送到其他端口）。通常这是通过添加一个帧头来完成的。如果`needed_headroom`和`needed_tailroom`属性正确填写，则无需检查skb头部空间或尾部空间是否不足，因为DSA在调用此方法之前确保有足够的空间。
报文的接收会经过标签器的`rcv`函数。传递的`struct sk_buff *skb`中的`skb->data`指向`skb_mac_header(skb) + ETH_ALEN`字节处，即指向以太类型之后的第一个字节（如果这个帧没有被标记的话）。此方法的作用是消耗帧头，调整`skb->data`使其真正指向以太类型之后的第一个字节，并改变`skb->dev`，使其指向与物理前向交换端口对应的虚拟DSA用户网络接口，该物理端口是报文接收的地方。
由于第1类和第2类标签协议会破坏DSA通道上的软件（大多数情况下还有硬件）报文分片功能，如DSA通道上的RPS（接收报文转向）等功能可能会失效。DSA框架通过挂钩到流分片器并根据DSA通道看到的带有标签的帧中IP头的位置移动偏移量来处理这种情况。
这种行为是基于标签协议的`overhead`值自动进行的。如果并非所有报文大小都相等，标签器可以实现`struct dsa_device_ops`中的`flow_dissect`方法，并通过指定每个接收报文的确切偏移量来覆盖默认行为。尾部标签器不会对流分片器造成问题。
对于第1类和第2类标签器，当DSA通道驱动程序在vlan_features中声明NETIF_F_HW_CSUM并检查csum_start和csum_offset时，校验和卸载应该能正常工作。在这种情况下，DSA会根据标签的大小移动校验和起始位置和偏移量。如果DSA通道驱动程序仍在vlan_features中使用过时的NETIF_F_IP_CSUM或NETIF_F_IPV6_CSUM，那么卸载可能仅在卸载硬件已经期望特定标签的情况下才有效（可能是由于厂商匹配）。DSA用户端口继承这些标志，由驱动程序负责在IP头不在硬件期望的位置时正确地回退到软件计算校验和。如果这种检查无效，报文可能会在网络中传输而没有正确的校验和（校验和字段将包含伪IP头之和）。对于第3类情况，如果卸载硬件不期望正在使用的交换机标签，则必须在插入任何标签之前计算校验和（即在标签器内部）。否则，DSA通道将在（软件或硬件）校验和计算中包括尾部标签。然后，当标签在传输过程中被交换机剥离时，它将留下不正确的IP校验和。
由于各种原因（最常见的原因是第1类标签器与未意识到DSA存在的通道关联，混淆了通道感知的MAC目的地址），标签协议可能要求DSA通道以混杂模式运行，以接收所有帧，无论MAC目的地址的值如何。这可以通过设置`struct dsa_device_ops`中的`promisc_on_conduit`属性来实现。
请注意，这假设了一个不了解DSA的管道驱动程序，这是常态。
管道网络设备
-------------

管道网络设备是常规的、未修改过的Linux网络设备驱动程序，用于CPU/管理以太网接口。这种驱动程序偶尔需要知道DSA是否已启用（例如：为了启用/禁用特定的卸载功能），但DSA子系统已被证明可以与行业标准驱动程序一起工作，如`e1000e`、`mv643xx_eth`等，而无需对这些驱动程序进行修改。这样的网络设备也常被称为管道网络设备，因为它们充当主机处理器和硬件以太网交换机之间的管道。
网络堆栈钩子
--------------

当使用DSA时，如果使用管道netdev，则在网络堆栈中放置一个小钩子，以便让DSA子系统处理以太网交换机特定的标记协议。DSA通过向网络堆栈注册一个特定的（并且是虚拟的）以太网类型（稍后成为`skb->protocol`）来实现这一点，这也被称为`ptype`或`packet_type`。典型的以太网帧接收序列如下：

管道网络设备（例如：e1000e）：

1. 接收中断触发：

        - 调用接收函数
        - 进行基本的数据包处理：获取长度、状态等
- 通过调用`eth_type_trans`准备数据包以便由以太网层处理

2. `net/ethernet/eth.c`中的代码示例：

          eth_type_trans(skb, dev)
                  if (dev->dsa_ptr != NULL)
                          -> skb->protocol = ETH_P_XDSA

3. `drivers/net/ethernet/*`中的代码示例：

          netif_receive_skb(skb)
                  -> 遍历注册的packet_type
                          -> 调用处理ETH_P_XDSA的handler，调用dsa_switch_rcv()

4. `net/dsa/dsa.c`中的代码示例：

          -> dsa_switch_rcv()
                  -> 调用在'net/dsa/tag_*.c'中的特定交换机标签协议处理器

5. `net/dsa/tag_*.c`中的代码示例：

        - 检查并剥离交换机标签协议以确定源端口
        - 查找每个端口的网络设备
        - 使用DSA用户网络设备调用`eth_type_trans()`
        - 调用`netif_receive_skb()`

在此之后，DSA用户网络设备将接收到常规的以太网帧，这些帧可以被网络堆栈处理。
用户网络设备
------------

由DSA创建的用户网络设备构建在其管道网络设备之上，每个这些网络接口都将负责作为交换机前面板端口的控制和数据流终端。这些接口经过专门设计，以便：

- 在发送到/从特定交换机端口传输流量时插入/移除交换机标签协议（如果存在）
- 向交换机查询ethtool操作：统计信息、链路状态、网络唤醒、寄存器转储等
- 管理外部/内部PHY：链路、自动协商等
这些用户网络设备具有自定义的`net_device_ops`和`ethtool_ops`函数指针，允许DSA在网络堆栈/ethtool与交换机驱动程序实现之间引入一层抽象。

当从这些用户网络设备发送帧时，DSA会查找当前与这些网络设备注册的交换机标记协议，并调用一个特定的发送例程，该例程负责在以太网帧中添加相关的交换机标签。

然后使用管道网络设备的`ndo_start_xmit()`函数将这些帧排队以供发送。由于它们包含适当的交换机标签，以太网交换机将能够处理来自管理接口的这些传入帧，并将其交付给物理交换机端口。
当使用多个CPU端口时，可以在DSA用户设备与物理DSA通道之间堆叠一个LAG（绑定/团队）设备。LAG设备因此也成为DSA通道，但LAG从属设备仍然保持为DSA通道（只是没有分配用户端口；这对于在LAG DSA通道消失时进行恢复是必要的）。因此，LAG DSA通道的数据路径被非对称地使用。接收数据时，`ETH_P_XDSA`处理器（调用`dsa_switch_rcv`）会在物理DSA通道（LAG从属设备）上早期被调用。因此，LAG DSA通道的接收数据路径实际上未被使用。另一方面，发送数据是线性进行的：`dsa_user_xmit`调用`dsa_enqueue_skb`，后者又调用`dev_queue_xmit`指向LAG DSA通道，该LAG DSA通道再调用`dev_queue_xmit`到一个或另一个物理DSA通道，在这两种情况下，数据包都是通过硬件路径离开系统，到达交换机。

图形表示如下：

简单总结，从网络设备的角度看，DSA大致如下所示：

                不了解DSA的应用程序
              打开并绑定套接字
                       |  ^
                       |  |
           +-----------v--|--------------------+
           |+------+ +------+ +------+ +------+|
           || swp0 | | swp1 | | swp2 | | swp3 ||
           |+------+-+------+-+------+-+------+|
           |          DSA交换机驱动程序        |
           +-----------------------------------+
                         |        ^
            由交换机驱动程序添加标签 |        | 由交换机驱动程序消费标签
                         v        |
           +-----------------------------------+
           | 未修改的主机接口驱动程序          | 软件
   --------+-----------------------------------+------------
           |       主机接口（eth0）       | 硬件
           +-----------------------------------+
                         |        ^
         由交换机硬件消费标签 |        | 由交换机硬件添加标签
                         v        |
           +-----------------------------------+
           |               交换机              |
           |+------+ +------+ +------+ +------+|
           || swp0 | | swp1 | | swp2 | | swp3 ||
           ++------+-+------+-+------+-+------++

用户MDIO总线
------------

为了能够读取和写入构建在其中的交换机PHY，DSA创建了一个用户MDIO总线，允许特定的交换机驱动程序将MDIO读写操作重定向和拦截到特定的PHY地址。对于大多数MDIO连接的交换机来说，这些功能会利用直接或间接的PHY寻址模式来返回来自交换机内置PHY的标准MII寄存器，使得PHY库和/或能够返回链路状态、链路伙伴页面、自动协商结果等信息。

对于既有外部又有内部MDIO总线的以太网交换机，用户MII总线可以用来复用/解复用向内部或外部MDIO设备的MDIO读写操作，这些交换机可能连接的设备包括内部PHY、外部PHY甚至是外部交换机。

数据结构
---------------

DSA的数据结构定义在`include/net/dsa.h`以及`net/dsa/dsa_priv.h`中：

- `dsa_chip_data`: 给定交换机设备的平台数据配置，这个结构描述了交换机设备的父设备、其地址以及其端口的各种属性：名称/标签，并最终提供路由表指示（当级联交换机时）

- `dsa_platform_data`: 平台设备配置数据，它可以引用一系列`dsa_chip_data`结构，如果多个交换机级联的话，这个交换机树所连接的通道网络设备需要被引用

- `dsa_switch_tree`: 分配给通道网络设备的结构（在`dsa_ptr`下），这个结构引用了一个`dsa_platform_data`结构以及交换机树支持的标记协议，并指明应调用哪些接收/发送函数挂钩，还提供了关于直接连接的交换机的信息：CPU端口。最后，一系列的`dsa_switch`被引用以处理树中的单个交换机

- `dsa_switch`: 描述树中的交换机设备的结构，它引用了一个`dsa_switch_tree`作为回指针，用户网络设备、通道网络设备，并引用了支持它的`dsa_switch_ops`

- `dsa_switch_ops`: 引用函数指针的结构，下面将详细描述

设计局限性
==================

缺少CPU/DSA网络设备
-------------------------------

目前DSA没有为CPU或DSA端口创建用户网络设备，如前所述。这可能会导致以下问题：

- 无法使用ethtool获取交换机CPU端口的统计计数器，这可能会使调试使用xMII接口连接的MDIO交换机变得更加困难

- 无法根据连接到它的以太网控制器的能力来配置CPU端口的链接参数：http://patchwork.ozlabs.org/patch/509806/

- 在使用级联设置时，无法配置特定的VLAN ID/主干VLAN之间的交换机

使用DSA设置时常见的陷阱
--------------------------------

一旦配置了使用DSA的通道网络设备（dev->dsa_ptr变为非NULL），并且后面的交换机期望有标记协议，则此网络接口只能专用于作为通道接口。直接通过此接口发送数据包（例如：使用此接口打开一个套接字）将不会经过交换机标记协议的发送函数，因此另一端的以太网交换机期望收到带有标签的数据包，通常会丢弃该帧。

与其他子系统的交互
==================

DSA当前利用了以下子系统：

- MDIO/PHY库：`drivers/net/phy/phy.c`，`mdio_bus.c`
- Switchdev: `net/switchdev/*`
- 设备树用于各种of_*函数
- Devlink: `net/core/devlink.c`

MDIO/PHY库
----------------

由DSA暴露的用户网络设备可能与PHY设备（`struct phy_device`，定义于`include/linux/phy.h`）相连接也可能不连接，但DSA子系统处理所有可能的组合：

- 内置PHY设备，构建在以太网交换机硬件中
- 外部PHY设备，通过内部或外部MDIO总线连接
- 内置PHY设备，通过内部MDIO总线连接
- 特殊的、非自动协商或非MDIO管理的PHY设备：SFPs、MoCA；也即固定PHY

PHY配置由`dsa_user_phy_setup()`函数完成，逻辑基本如下：

- 如果使用设备树，使用标准的"phy-handle"属性查找PHY设备，如果找到，则使用`of_phy_connect()`创建并注册该PHY设备

- 如果使用设备树且PHY设备是“固定的”，也就是说，符合`Documentation/devicetree/bindings/net/fixed-link.txt`中定义的非MDIO管理PHY的定义，则使用特殊的固定MDIO总线驱动程序透明地注册并连接该PHY

- 最后，如果PHY构建在交换机中，这是独立交换机包中非常常见的情况，则使用DSA创建的用户MII总线探测该PHY

SWITCHDEV
---------

DSA直接利用SWITCHDEV与桥接层交互，特别是在配置每个端口上的用户网络设备上的VLAN时与其VLAN过滤部分交互。目前，DSA支持的唯一SWITCHDEV对象是FDB和VLAN对象。
Devlink
-------

DSA为结构中的每个物理交换机注册一个devlink设备。
对于每个 devlink 设备，每个物理端口（即用户端口、CPU 端口、DSA 链路或未使用的端口）都会作为一个 devlink 端口暴露出来。
DSA 驱动程序可以利用以下 devlink 特性：

- 区域：一种调试特性，允许用户空间以低级的二进制格式转储驱动程序定义的硬件信息区域。支持全局区域以及每端口区域。即使对于某些已经以某种方式暴露给标准 iproute2 用户空间程序（如 ip-link、bridge）的数据（例如地址表和 VLAN 表），也可以导出 devlink 区域。例如，在这些表包含额外的硬件特定细节时，这可能非常有用，或者在非用户端口上检查这些表也很有用，因为这些端口没有注册网络接口，因此对 iproute2 是不可见的
- 参数：一种特性，使用户能够配置与设备相关的某些低级可调参数。驱动程序可以实现适用的通用 devlink 参数，或者添加新的设备特有 devlink 参数
- 资源：一种监控特性，使用户能够查看设备中某些硬件表的使用程度，例如 FDB、VLAN 等
- 共享缓冲区：一种 QoS 特性，用于调整和划分每个端口和每个流量类别的内存和帧预留，在入站和出站方向上，以便低优先级的大批量流量不会妨碍高优先级关键流量的处理
更多详细信息，请参阅 ``Documentation/networking/devlink/``
设备树
------

DSA 特性具有标准化绑定，该绑定在 ``Documentation/devicetree/bindings/net/dsa/dsa.txt`` 中进行了文档说明。还使用了诸如 ``of_get_phy_mode()`` 和 ``of_phy_connect()`` 这样的 PHY/MDIO 库帮助函数来查询每个端口的 PHY 特定细节：接口连接、MDIO 总线位置等
驱动开发
========

DSA 交换机驱动程序需要实现一个 ``dsa_switch_ops`` 结构体，其中将包含下面描述的各种成员
探测、注册和设备生命周期
------------------------------

DSA 交换机是总线（无论是平台、SPI、I2C、MDIO 或其他）上的常规 ``device`` 结构。DSA 框架不参与与设备核心进行探测的过程
从驱动程序的角度来看，交换机注册通常意味着在其探测函数中向 ``dsa_register_switch()`` 传递有效的 ``struct dsa_switch`` 指针。提供的结构中的以下成员必须有效：

- ``ds->dev``：将用于解析交换机的 OF 节点或平台数据
- `ds->num_ports`：将用于为该交换机创建端口列表，并验证OF节点中提供的端口索引。
- `ds->ops`：指向包含DSA方法实现的`dsa_switch_ops`结构的指针。
- `ds->priv`：指向一个驱动程序私有数据结构的回指针，可以在所有后续的DSA方法回调中获取。

此外，在`dsa_switch`结构中的以下标志可以可选地配置以从DSA核心获得驱动程序特定的行为。当设置这些标志时的行为已在`include/net/dsa.h`中通过注释进行了文档说明：
- `ds->vlan_filtering_is_global`
- `ds->needs_standalone_vlan_filtering`
- `ds->configure_vlan_while_not_filtering`
- `ds->untag_bridge_pvid`
- `ds->assisted_learning_on_cpu_port`
- `ds->mtu_enforcement_ingress`
- `ds->fdb_isolation`

内部地，DSA维护了一个全局的交换机树（一组交换机）数组，并在注册时将一个`dsa_switch`结构附加到一棵树上。
交换机所连接的树ID由交换机OF节点的`dsa,member`属性的第一个u32数字确定（如果缺失则为0）。
交换机在树内的ID由同一OF属性的第二个u32数字确定（如果缺失则为0）。使用相同的树ID和交换机ID注册多个交换机是非法的，将会导致错误。使用平台数据时，允许注册单一交换机和单一交换机树。
对于有多台交换机的树，探测过程是非对称的。
前N-1个调用`dsa_register_switch()`的交换机会只将其端口添加到树的端口列表(`dst->ports`)中，每个端口都有指向其关联交换机的回指针(`dp->ds`)。然后，这些交换机会较早地退出它们的`dsa_register_switch()`调用，因为`dsa_tree_setup_routing_table()`已经确定树尚未完成（不是所有的DSA链接引用的端口都存在于树的端口列表中）。当最后一个交换机调用`dsa_register_switch()`时，树变为完整状态，这触发了对该树内所有交换机初始化的实际继续（包括调用`ds->ops->setup()`），所有这些都是作为最后一个交换机探测函数的调用上下文的一部分进行的。
与注册相反的过程发生在调用`dsa_unregister_switch()`时，它会从树的端口列表中移除交换机的端口。当第一个交换机卸载时，整个树就被拆解。
### 强制要求

DSA 交换机驱动程序必须实现其相应总线的 `shutdown()` 回调，并从中调用 `dsa_switch_shutdown()`（这是 `dsa_unregister_switch()` 执行的完整清理过程的一个最小版本）。
原因是 DSA 会保留对通道网络设备的引用，如果通道设备的驱动程序决定在关闭时解除绑定，DSA 的引用将阻止该操作完成。

`dsa_switch_shutdown()` 或 `dsa_unregister_switch()` 必须被调用，但不能同时调用两者。设备驱动模型允许即使 `shutdown()` 已经被调用，也可以调用总线的 `remove()` 方法。因此，驱动程序需要通过在任一方法执行后将其 `drvdata` 设置为 NULL，并在采取任何行动前检查 `drvdata` 是否为 NULL 来实现在 `remove()` 和 `shutdown()` 之间的互斥。

调用 `dsa_switch_shutdown()` 或 `dsa_unregister_switch()` 后，不再可以通过提供的 `dsa_switch_ops` 进行进一步的回调，并且驱动程序可以释放与 `dsa_switch` 关联的数据结构。

### 交换机配置

- `get_tag_protocol`：此函数用于指示支持哪种类型的标记协议，应是 `dsa_tag_protocol` 枚举的有效值。
返回的信息不必是静态的；驱动程序会传递 CPU 端口号以及可能堆叠的上游交换机的标记协议，以防硬件在支持的标记格式方面存在限制。
- `change_tag_protocol`：当默认的标记协议与通道或其他问题存在兼容性问题时，驱动程序可以在运行时通过设备树属性或通过 sysfs 更改它。在这种情况下，进一步调用 `get_tag_protocol` 应报告当前使用的协议。
- `setup`：交换机的设置函数，此函数负责使用所有必需的内容设置 `dsa_switch_ops` 的私有结构：寄存器映射、中断、互斥量、锁等。此函数还应正确配置交换机以将所有网络接口相互隔离，即它们应该由交换机硬件本身隔离，通常通过为每个端口创建基于端口的 VLAN ID 并仅允许 CPU 端口和特定端口处于转发向量中来实现。平台未使用的端口应被禁用。在此函数之后，交换机应完全配置并准备好处理任何类型的请求。建议在此设置函数期间对交换机进行软件重置，以避免依赖之前可能已配置的任何先前软件代理（如引导加载程序/固件）。负责撤销此处所做的任何适用分配或操作的方法是 `teardown`。
- `port_setup` 和 `port_teardown`：用于初始化和销毁每个端口数据结构的方法。对于某些操作（例如注册和注销 devlink 端口区域）必须从这些方法中完成，否则它们是可选的。只有在端口已经设置后才会被拆除。端口有可能在探测过程中设置，然后立即被拆除，例如在其 PHY 无法找到的情况下。在这种情况下，DSA 交换机的探测将继续进行，但不包括该特定端口。
- `port_change_conduit`：用于更改用户端口与 CPU 端口之间关联（用于流量终止目的）的方法。默认情况下，来自树的所有用户端口都分配给第一个适合它们的可用 CPU 端口（大多数情况下这意味着树的所有用户端口都分配给同一个 CPU 端口，除了如提交 2c0b03258b8b 中所述的 H 拓扑）。`port` 参数表示用户端口的索引，而 `conduit` 参数表示新的 DSA 通道 `net_device`。与新通道关联的 CPU 端口可以通过查看 `struct dsa_port *cpu_dp = conduit->dsa_ptr` 获取。此外，通道也可以是一个 LAG 设备，其中所有从属设备都是物理 DSA 通道。LAG DSA 也有一个有效的 `conduit->dsa_ptr` 指针，但这不是唯一的，而是第一个物理 DSA 通道（LAG 从属）`dsa_ptr` 的副本。在 LAG DSA 通道的情况下，将为与物理 DSA 通道相关的物理 CPU 端口单独发出进一步的 `port_lag_join` 调用，要求它们创建与 LAG 接口关联的硬件 LAG。
PHY设备和链路管理
-------------------------------

- ``get_phy_flags``: 某些交换机连接到各种类型的以太网PHY，如果PHY库中的PHY驱动需要了解它无法自行获取的信息（例如：来自交换机内存映射寄存器的信息），此函数应返回一个32位的“标志”位掩码，该掩码是交换机驱动与`drivers/net/phy/*`中的以太网PHY驱动之间的私有信息。
- ``phy_read``: 当尝试读取交换机端口MDIO寄存器时DSA用户MDIO总线调用的函数。如果不可用，则对每次读取返回0xffff。对于内置交换机以太网PHY，此函数应允许读取链路状态、自动协商结果、链路伙伴页面等。
- ``phy_write``: 当尝试写入交换机端口MDIO寄存器时DSA用户MDIO总线调用的函数。如果不可用则返回负错误代码。
- ``adjust_link``: 当用户网络设备连接到PHY设备时由PHY库调用的函数。此函数负责根据`phy_device`提供的信息适当地配置交换机端口链路参数：速度、双工模式、基于暂停的功能等。
- ``fixed_link_update``: 由PHY库调用的函数，特别地是由固定PHY驱动请求交换机驱动提供无法通过自动协商或通过MDIO读取PHY寄存器获得的链路参数。这对于某些特定硬件类型特别有用，如QSGMII、MoCA或其他非MDIO管理的PHY，其中带外链路信息是可以获取的。

ethtool操作
------------------

- ``get_strings``: 用于查询驱动程序字符串的ethtool函数，通常会返回统计字符串、私有标志字符串等。
- ``get_ethtool_stats``: 用于查询每个端口的统计信息并返回其值的ethtool函数。DSA覆盖用户网络设备的一般统计信息：从网络设备获取的RX/TX计数器，并结合每个端口特定于交换机驱动的统计信息。
- ``get_sset_count``: 用于查询统计项目数量的ethtool函数。
- ``get_wol``: 用于获取每个端口的Wake-on-LAN设置的ethtool函数，对于某些实现，此函数也可能查询信道网络设备的Wake-on-LAN设置，如果此接口需要参与Wake-on-LAN。
- ``set_wol``: 用于配置每个端口的Wake-on-LAN设置的ethtool函数，直接对应于`set_wol`函数，具有类似的限制。
- ``set_eee``: 用于配置交换机端口EEE（绿色以太网）设置的ethtool函数，可选地调用PHY库以在PHY级别启用EEE，如果相关的话。此函数应在交换机端口MAC控制器和数据处理逻辑中启用EEE。
- ``get_eee``: 用于查询交换机端口EEE设置的ethtool函数，此函数应返回交换机端口MAC控制器和数据处理逻辑的EEE状态以及查询PHY当前配置的EEE设置。
- ``get_eeprom_len``: 用于返回给定交换机的EEPROM长度/大小（以字节为单位）的ethtool函数。
- ``get_eeprom``: 用于返回给定交换机的EEPROM内容的ethtool函数。
- ``set_eeprom``: 用于将指定数据写入给定交换机EEPROM的ethtool函数。
- ``get_regs_len``: 用于返回给定交换机的寄存器长度的ethtool函数。
- ``get_regs``: 用于返回以太网交换机内部寄存器内容的ethtool函数。此函数可能需要ethtool中的用户空间代码来美观地打印寄存器值和寄存器。

电源管理
----------------

- ``suspend``: 当系统进入待机状态时由DSA平台设备调用的函数，应停止所有以太网交换机活动，但保持参与Wake-on-LAN的端口处于活动状态，以及支持的其他唤醒逻辑。
- ``resume``: 当系统恢复时由DSA平台设备调用的函数，应恢复所有以太网交换机活动，并重新配置交换机使其处于完全活动状态。
- ``port_enable``: 当端口被管理性启动时由DSA用户网络设备的ndo_open函数调用的函数，此函数应完全启用给定的交换机端口。DSA负责标记端口为`BR_STATE_BLOCKING`如果端口是桥接成员，或者`BR_STATE_FORWARDING`如果不是，并将这些更改传播到硬件。
- ``port_disable``: 当端口被管理性关闭时由DSA用户网络设备的ndo_close函数调用的函数，此函数应完全禁用给定的交换机端口。DSA负责标记端口为`BR_STATE_DISABLED`并将更改传播到硬件，如果此端口在作为桥接成员时被禁用。

地址数据库
-----------------

交换硬件预计会有一个FDB条目的表，但并非所有条目同时都是活跃的。地址数据库是FDB条目的子集（分区），根据端口的状态是活跃的（可以通过接收地址学习匹配或FDB查找）。地址数据库在此文档中偶尔被称为“FID”（过滤标识符），尽管底层实现可以选择任何可用的方式与硬件交互。
例如，所有属于VLAN无感知桥接（目前是VLAN无感知的）的端口都应在其源地址的学习过程中使用与该桥接关联的数据库（而不是与其他VLAN无感知桥接关联的）。在转发和FDB查找过程中，一个在VLAN无感知桥接端口上收到的包应该能够找到一个具有与包相同的MAC目标地址的VLAN无感知FDB条目，该条目存在于同一桥接的另一个端口上。同时，FDB查找过程必须能够找不到一个具有与包相同的MAC目标地址的FDB条目，如果该条目指向的是另一个VLAN无感知桥接的成员端口（因此与不同的地址数据库相关联）。
类似地，每个卸载的VLAN感知桥接的每个VLAN都应该有一个相关的地址数据库，该数据库由所有属于该VLAN的端口共享，但不被属于同一VID的不同桥接的端口共享。
在此背景下，不了解VLAN的数据库意味着所有数据包都应与其匹配，无论VLAN ID如何（仅进行MAC地址查找），而了解VLAN的数据库意味着数据包应根据从分类后的802.1Q报头（或如果未标记则为pvid）得出的VLAN ID进行匹配。在桥接层，不了解VLAN的FDB条目的特殊VID值为0，而了解VLAN的FDB条目具有非零VID值。需要注意的是，不了解VLAN的桥接器可能包含了解VLAN（非零VID）的FDB条目，而了解VLAN的桥接器也可能包含不了解VLAN的FDB条目。与硬件一样，软件桥接器保持独立的地址数据库，并通过switchdev异步地将属于这些数据库的FDB条目卸载到硬件，相对于数据库变为活动状态或非活动状态的时间。

当用户端口以独立模式运行时，其驱动程序应将其配置为使用一个称为端口私有数据库的独立数据库。这与上述数据库不同，应尽可能不影响作为独立端口的操作（数据包进入，数据包输出到CPU端口）。例如，在数据包进入时，它不应试图学习进入流量的MAC源地址，因为学习是桥接层的服务，而这是一个独立端口，因此会占用无用的空间。没有地址学习的情况下，端口私有数据库在简单的实现中应该是空的，在这种情况下，所有收到的数据包都应该简单地泛洪到CPU端口。

DSA（级联）和CPU端口也被称为“共享”端口，因为它们服务于多个地址数据库，并且数据包应该关联的数据库通常嵌入在DSA标签中。这意味着CPU端口可以同时传输来自独立端口的数据包（这些数据包被硬件分类到一个地址数据库中）和来自桥接端口的数据包（这些数据包被分类到不同的地址数据库中）。

满足特定标准的交换机驱动程序能够通过将CPU端口从交换机的泛洪域中移除并仅向硬件编程指向CPU端口的FDB条目来优化简单的配置，对于这些端口，已知软件对这些MAC地址感兴趣。不匹配已知FDB条目的数据包不会被传递给CPU，这将节省创建skb只是为了丢弃它所需的CPU周期。

DSA能够执行以下类型的地址的主机地址过滤：

- 端口的主要单播MAC地址（`dev->dev_addr`）。这些与相应用户端口的端口私有数据库相关联，驱动程序通过`port_fdb_add`通知安装这些地址到CPU端口。
- 端口的辅助单播和多播MAC地址（通过`dev_uc_add()`和`dev_mc_add()`添加的地址）。这些也与相应用户端口的端口私有数据库相关联。
- 桥接器的本地/永久FDB条目（`BR_FDB_LOCAL`）。这些是桥接端口的MAC地址，对于这些地址，数据包必须在本地终止而不是转发。它们与该桥接器的地址数据库相关联。
- 向位于与某些DSA交换机端口相同的桥接器中的外设（非DSA）接口安装的静态桥接FDB条目。这些也与该桥接器的地址数据库相关联。
在某些DSA交换机端口所在的同一桥接器中，如果驱动程序将`ds->assisted_learning_on_cpu_port`设置为真，则动态学习到的外来接口上的FDB条目仅在此情况下存在。这些条目与该桥接器的地址数据库相关联。

对于下面详细描述的各种操作，DSA提供了一个`dsa_db`结构，它可以是以下类型之一：

- `DSA_DB_PORT`：要安装或删除的FDB（或多播数据库MDB）条目属于用户端口`db->dp`的端口私有数据库。
- `DSA_DB_BRIDGE`：条目属于桥接器`db->bridge`的一个地址数据库。驱动程序应负责区分VLAN无关的数据库和此桥接器的每个VID数据库。
- `DSA_DB_LAG`：条目属于LAG `db->lag`的地址数据库。
注意：`DSA_DB_LAG`目前未使用，并可能在未来被移除。

处理`port_fdb_add`、`port_mdb_add`等函数中的`dsa_db`参数的驱动程序应该声明`ds->fdb_isolation`为真。

DSA为每个卸载的桥接器和每个卸载的LAG关联一个基于1的ID（`struct dsa_bridge :: num`、`struct dsa_lag :: id`），用于在共享端口上对地址进行引用计数。驱动程序可以利用DSA的编号方案（ID可以通过`db->bridge.num`和`db->lag.id`读取），也可以实现自己的方案。

只有声明支持FDB隔离的驱动程序才会被通知到属于`DSA_DB_PORT`数据库的CPU端口上的FDB条目。

出于兼容性和向后兼容性的原因，即使驱动程序不支持FDB隔离，也会向其通知`DSA_DB_BRIDGE`地址。但是，在这种情况下`db->bridge.num`和`db->lag.id`始终设置为0（表示缺乏隔离，以便进行引用计数）。

请注意，对于交换机驱动程序来说，并不是强制要求为每个独立用户端口实现物理上分离的地址数据库。因为端口私有数据库中的FDB条目总是指向CPU端口，因此不存在错误转发决策的风险。在这种情况下，所有独立端口可以共享同一个数据库，但对于主机过滤地址（即如果某个端口的MAC地址仍被其他端口使用则不删除相应的FDB条目）的引用计数则成为驱动程序的责任，因为DSA并不知道端口数据库实际上是共享的。这可以通过调用`dsa_fdb_present_in_other_db()`和`dsa_mdb_present_in_other_db()`来实现。
不利的一面是，每个用户端口的 RX 过滤列表实际上是共享的，这意味着用户端口 A 可能会接受一个本不应接收的带有 MAC 目标地址（DA）的数据包，仅仅因为该 MAC 地址存在于用户端口 B 的 RX 过滤列表中。然而，这些数据包仍然会在软件中被丢弃。

**桥接层**

卸载桥接转发平面是可选的，并通过以下方法处理。这些方法可能不存在、返回 `-EOPNOTSUPP`，或者 `ds->max_num_bridges` 可能是非零值但已被超出，在这种情况下，尽管可以将桥接端口加入，但数据包转发将在软件中进行，且软件桥接下的端口必须保持与独立操作时相同的配置方式，即禁用所有桥接服务功能（如地址学习等），并将所有收到的数据包仅发送到 CPU 端口。

具体来说，一旦端口在调用 `port_bridge_join` 方法后返回成功，它就开始卸载桥接的转发平面；在调用 `port_bridge_leave` 方法之后，它停止这样做。卸载桥接意味着根据软件桥接端口的状态自主学习 FDB 条目，并且自主转发（或泛洪）收到的数据包而无需 CPU 干预。

即使当卸载桥接端口时这也是可选的。标记协议驱动程序预期对那些已经在入口交换端口的转发域内自主转发的数据包调用 `dsa_default_offload_fwd_mark(skb)`。DSA 通过 `dsa_port_devlink_setup()` 认为所有属于同一树 ID 的交换端口都属于同一个桥接转发域（能够互相自主转发）。

卸载桥接的 TX 转发过程与简单地卸载其转发平面是不同的概念，指的是某些驱动和标记协议组合能够将来自桥接设备传输函数的单个 skb 发送到潜在的多个出口端口的能力（从而避免在软件中的克隆）。

请求此行为的数据包被称为数据平面数据包，并且在标记协议驱动程序的 `xmit` 函数中将 `skb->offload_fwd_mark` 设置为 `true`。数据平面数据包要经过 FDB 查找、CPU 端口上的硬件学习，并且不会覆盖端口的 STP 状态。

此外，数据平面数据包的复制（多播、泛洪）在硬件中处理，而桥接驱动程序将为每个可能需要复制或不需要复制的数据包传输单个 skb。

当启用 TX 转发卸载时，标记协议驱动程序负责将数据包注入到硬件的数据平面中，以进入端口所属的正确桥接域（FID）。端口可能是对 VLAN 不敏感的，在这种情况下，FID 必须等于驱动程序为其与该桥接关联的 VLAN 不敏感地址数据库使用的 FID。

或者，桥接可能是对 VLAN 敏感的，在这种情况下，保证数据包也被用桥接处理此数据包所在的 VLAN ID 标记。硬件的责任是在出口未标记端口上取消标记 VID，或在出口已标记端口上保留标签。

- `port_bridge_join`: 当给定的交换端口被添加到桥接时调用的桥接层函数，此函数应在交换层面执行必要的操作以允许加入的端口被添加到相关逻辑域中，以便与其他桥接成员进行入站/出站通信。
通过将 `tx_fwd_offload` 参数设置为 true，此桥接器的 TX 转发过程也被卸载。

- `port_bridge_leave`: 当某个交换机端口从桥接器移除时调用的桥接层函数。该函数应在交换机级别执行必要的操作以阻止离开的端口接收来自剩余桥接成员的入站/出站流量。
- `port_stp_state_set`: 当计算出某个交换机端口的生成树协议 (STP) 状态并需要将其传播到交换机硬件以转发/阻止/学习流量时调用的桥接层函数。
- `port_bridge_flags`: 当端口需要配置其设置（例如未知流量泛洪或源地址学习）时调用的桥接层函数。交换机驱动程序负责为独立端口进行初始设置，包括禁用地址学习和对所有类型的流量进行出站泛洪。然后，当端口加入或离开桥接器时，DSA 核心会通知任何关于桥接端口标志的变化。目前，DSA 不管理 CPU 端口的桥接端口标志。假设如果硬件支持的话，应静态启用 CPU 端口上的地址学习，并且也应启用向 CPU 端口的泛洪，因为 DSA 核心中缺乏明确的地址过滤机制。
- `port_fast_age`: 当有必要清除端口上动态学习的 FDB 条目时调用的桥接层函数。这在从一个应该进行学习的 STP 状态转换到不应该进行学习的 STP 状态、或者离开桥接器、或者通过 `port_bridge_flags` 关闭地址学习时发生。

### 桥接 VLAN 过滤

- `port_vlan_filtering`: 当桥接器被配置为开启或关闭 VLAN 过滤时调用的桥接层函数。如果没有特定的操作需要在硬件级别完成，则不需要实现此回调。
当开启 VLAN 过滤时，硬件必须被编程为拒绝具有不在允许的 VLAN ID 映射/规则之外的 802.1Q 帧。如果没有 PVID 编程到交换机端口中，则也应拒绝未标记的帧。当关闭 VLAN 过滤时，交换机必须接受任何 802.1Q 帧，无论它们的 VLAN ID 如何，并且允许未标记的帧。
- `port_vlan_add`: 当给定的交换机端口配置了 VLAN（标记或未标记）时调用的桥接层函数。只有当外部桥接端口也是该 VLAN 的成员（并且需要在软件中进行转发），或者该 VLAN 被安装到桥接设备本身的 VLAN 组中以进行终止（如 `bridge vlan add dev br0 vid 100 self`）时，CPU 端口才成为 VLAN 的成员。共享端口上的 VLAN 是引用计数的，并在没有用户使用时被删除。驱动程序不需要手动在 CPU 端口上安装 VLAN。
- `port_vlan_del`: 当从给定的交换机端口中移除 VLAN 时调用的桥接层函数。

- `port_fdb_add`: 当桥接器想要安装一个转发数据库条目时调用的桥接层函数。交换机硬件应被编程为在与该 VLAN ID 相关联的转发数据库中指定指定的地址和 VLAN ID。
- `port_fdb_del`: 当桥接器想要移除一个转发数据库条目时调用的桥接层函数。交换机硬件应被编程为从指定的 VLAN ID 中删除指定的 MAC 地址，如果它被映射到了这个端口的转发数据库中。

- `port_fdb_dump`: 由物理 DSA 端口接口上的 `ndo_fdb_dump` 调用的桥接绕行函数。由于 DSA 不尝试使其硬件 FDB 条目与其软件桥接保持同步，因此实现了此方法来查看用户端口在硬件数据库中可见的条目。
此函数报告的条目在`bridge fdb show`命令的输出中带有`self`标志。
- `port_mdb_add`: 当网桥希望安装一个多播数据库条目时调用的网桥层函数。交换机硬件应根据指定的VLAN ID，在与该VLAN ID相关的转发数据库中编程指定的地址。
- `port_mdb_del`: 当网桥希望删除一个多播数据库条目时调用的网桥层函数，交换机硬件应被编程为从指定的VLAN ID中删除指定的MAC地址（如果它已被映射到这个端口转发数据库）。

链路聚合
---------

链路聚合通过bonding和team驱动程序在Linux网络堆栈中实现，这些驱动程序被建模为虚拟、可堆叠的网络接口。
DSA能够将链路聚合组(LAG)卸载到支持该功能的硬件上，并且支持物理端口与LAG之间以及LAG之间的网桥连接。一个包含多个物理端口的bonding/team接口构成一个逻辑端口，尽管DSA目前没有明确的逻辑端口概念。因此，LAG加入/离开网桥的情况被视为其所有成员物理端口加入/离开网桥。作为网桥端口卸载到LAG上的Switchdev端口属性（VLAN过滤、STP状态等）和对象（VLAN、MDB条目）同样处理：DSA在LAG的所有成员上卸载相同的Switchdev对象/端口属性。LAG上的静态网桥FDB条目目前尚不支持，因为DSA驱动API中没有逻辑端口ID的概念。
- `port_lag_join`: 当某个交换端口被添加到LAG时调用的函数。驱动程序可以返回`-EOPNOTSUPP`，在这种情况下，DSA将回退到软件实现，其中来自此端口的所有流量都被发送到CPU。
- `port_lag_leave`: 当某个交换端口离开LAG并恢复为独立端口操作时调用的函数。
- `port_lag_change`: 当LAG任何成员的链路状态发生变化且哈希函数需要重新平衡以仅使用处于活动状态的物理LAG成员端口子集时调用的函数。
可以从`dsa_switch_ops::setup`方法中选择性地填充`ds->num_lag_ids`，以便于具有与每个卸载LAG相关联ID的驱动程序。然后DSA交换驱动可以通过`dsa_lag_id`函数检索与bonding/team接口关联的LAG ID。

IEC 62439-2 (MRP)
------------------

媒体冗余协议是一种优化快速故障恢复时间用于环形网络的拓扑管理协议，该协议的部分组件由网桥驱动程序实现。MRP使用管理PDUs（测试、拓扑、LinkDown/Up、选项）发送至多播目标MAC地址范围01:15:4e:00:00:0x，并使用EtherType 0x88e3。
根据节点在环中的角色（MRM：媒体冗余管理器，MRC：媒体冗余客户端，MRA：媒体冗余自动管理器），某些 MRP PDU（Protocol Data Unit，协议数据单元）可能需要本地终止，而其他一些则需要转发。
MRM 还可以从将创建和传输某些 MRP PDU 的任务卸载到硬件中获益（测试）。
通常，可以在任何网络接口上创建 MRP 实例，
但在像 DSA 这样具有卸载数据路径的设备的情况下，即使硬件不支持 MRP，也需要能够从网络中提取 MRP PDU，之后驱动程序才能进行软件实现。目前 DSA 没有支持 MRP 的驱动程序，因此它只监听最少的 switchdev 对象以确保软件辅助功能正常工作。具体操作如下：
- ``port_mrp_add`` 和 ``port_mrp_del``：当创建或删除具有特定环 ID、优先级、主端口和次端口的 MRP 实例时通知驱动程序
- ``port_mrp_add_ring_role`` 和 ``port_mrp_del_ring_role``：当 MRP 实例的角色在 MRM 或 MRC 之间发生变化时调用的函数。这会影响哪些 MRP PDU 应被转交给软件处理，哪些应该自主转发
IEC 62439-3 (HSR/PRP)
----------------------

并行冗余协议 (PRP) 是一种通过在网络中复制并序列编号数据包并通过两个独立的第二层网络传输（这些网络对数据包中携带的 PRP 尾部标签不知情），并在接收端消除重复数据包来工作的网络冗余协议。高可用无缝冗余 (HSR) 协议在概念上类似，但所有承载冗余流量的节点都知道它是 HSR 标签的（因为 HSR 使用 0x892f 的 EtherType 头部），并且物理上连接成环形拓扑。HSR 和 PRP 都使用监控帧来监测网络健康状况和发现其他节点。
在 Linux 中，HSR 和 PRP 都是在 hsr 驱动中实现的，该驱动创建了一个带有两个成员端口的虚拟堆叠式网络接口。
该驱动仅实现了 DANH（双重连接节点实现 HSR）和 DANP（双重连接节点实现 PRP）的基本角色；RedBox 和 QuadBox 角色没有实现（因此，将 hsr 网络接口与物理交换机端口桥接不会产生预期的结果）。
能够卸载 DANP 或 DANH 的某些功能的驱动程序应按照 ``Documentation/networking/netdev-features.rst`` 文档中所指示的声明相应的网络设备特性。此外，还必须实现以下方法：

- ``port_hsr_join``：当给定的交换机端口加入 DANP/DANH 时调用的函数。驱动程序可以返回 ``-EOPNOTSUPP``，在这种情况下，DSA 将回退到一个软件实现，其中来自此端口的所有流量都发送到 CPU
- ``port_hsr_leave``：当给定的交换机端口离开 DANP/DANH 并返回到作为独立端口的正常运行状态时调用的函数
### 让 SWITCHDEV 和 DSA 趋同到一个统一的代码库

SWITCHDEV 正确地处理了通过具备卸载能力的硬件对网络堆栈进行抽象，但并未强制实施严格的交换机设备驱动模型。而 DSA 则强制执行了一个相对严格的设备驱动模型，并处理了大多数与交换机相关的特性。在某个时点上，我们应该考虑将这两个子系统合并，从而兼得两者之长。
