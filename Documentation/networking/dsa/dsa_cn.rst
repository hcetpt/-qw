架构
============

本文档描述了**分布式交换架构（DSA）**子系统的设计原则、限制、与其他子系统的交互，以及如何为该子系统开发驱动程序，并列出有兴趣参与开发的开发者待办事项。

设计原则
=================

分布式交换架构子系统最初设计用于支持使用Linux的Marvell以太网交换机（MV88E6xxx，即Link Street产品线），但后来也扩展支持其他厂商。这一设计的初衷是能够透明地使用未经修改的Linux工具（如bridge、iproute2、ifconfig），无论它们配置或查询的是交换机端口网络设备还是普通网络设备。

一个以太网交换机通常包含多个前面板端口和一个或多个CPU或管理端口。目前DSA子系统依赖于存在一个连接到能够接收来自交换机的以太网帧的以太网控制器的管理端口。这种常见的设置适用于小型家庭和办公产品中的各种类型的以太网交换机：路由器、网关甚至机架顶部交换机。在DSA术语和代码中，这个主机以太网控制器将被称为“conduit”和“cpu”。

DSA中的D代表分布式，因为该子系统被设计为能够在各个交换机之间通过上行和下行以太网链路进行级联配置和管理。这些特定端口在DSA术语和代码中称为“dsa”端口。多个相互连接的交换机集合称为“交换树”。

对于每个前面板端口，DSA会创建专门的网络设备，用作Linux网络堆栈使用的控制和数据流端点。这些专门的网络接口在DSA术语和代码中称为“user”网络接口。

使用DSA的理想情况是当一个以太网交换机支持“交换标签”，这是一种硬件特性，使得交换机为从特定端口接收或发送的每个以太网帧插入一个特定标签，帮助管理接口确定：

- 这个帧来自哪个端口
- 为什么这个帧会被转发
- 如何将CPU生成的流量发送到特定端口

尽管子系统确实支持无法插入/剥离标签的交换机，但在这种情况下，功能可能会略有受限（流量分离依赖于基于端口的VLAN ID）。

需要注意的是，目前DSA没有为“cpu”和“dsa”端口创建网络接口，原因如下：

- “cpu”端口是管理控制器面向以太网交换机的一侧，因此会带来功能重复的问题，因为你会得到两个相同管道的接口：conduit netdev和“cpu” netdev。
- “dsa”端口只是两个或多个交换机之间的通道，因此不能真正作为合适的网络接口使用，只有下游或最上游的接口在这个模型中有意义。

注意：过去15年来，DSA子系统一直使用“master”（而不是“conduit”）和“slave”（而不是“user”）这两个术语。这些术语已被从DSA代码库中移除，并逐步从uAPI中淘汰。

以太网交换机标签协议
------------------------

DSA支持许多厂商特定的标签协议、一种软件定义的标签协议以及无标签模式（`DSA_TAG_PROTO_NONE`）。标签协议的具体格式是厂商特定的，但通常它们都包含一些信息：

- 标识以太网帧来自或应发送到哪个端口
- 提供帧被转发到管理接口的原因

所有标签协议都在`net/dsa/tag_*.c`文件中实现，并实现了`struct dsa_device_ops`结构的方法，具体细节如下。
标记协议通常分为以下三类：

1. 交换机特定的帧头位于以太网头部之前，从 DSA 通道解析器的角度来看，向右移动了 MAC DA、MAC SA、EtherType 和整个第 2 层有效负载。
2. 交换机特定的帧头位于 EtherType 之前，保持 MAC DA 和 MAC SA 不变，但从 DSA 通道解析器的角度看，将实际的 EtherType 和第 2 层有效负载向右移动。
3. 交换机特定的帧头位于数据包尾部，保持所有帧头不变，并且不改变 DSA 通道解析器看到的数据包视图。

标记协议可能会用相同长度的交换标签标记所有数据包，或者标签长度可能有所不同（例如，带有 PTP 时间戳的数据包可能需要扩展的交换标签，或者在发送时使用一种标签长度，在接收时使用另一种）。无论如何，标记协议驱动程序必须填充 `struct dsa_device_ops::needed_headroom` 和/或 `struct dsa_device_ops::needed_tailroom` 中最长交换帧头/尾的字节长度。DSA 框架会自动调整通道接口的 MTU 以容纳这个额外大小，从而使 DSA 用户端口支持标准的 1500 字节 MTU（第 2 层有效负载长度）。`needed_headroom` 和 `needed_tailroom` 属性还用于请求网络栈尽力分配具有足够额外空间的数据包，以便在传输数据包时添加交换标签不会因内存不足而重新分配。

尽管应用程序不应解析 DSA 特定的帧头，但标记协议在线上的格式代表内核向用户空间暴露的应用二进制接口，如 `libpcap` 解码器。标记协议驱动程序必须填充 `struct dsa_device_ops` 的 `proto` 成员，该成员包含唯一描述硬件交换机与数据路径驱动程序之间所需交互特性的值：帧头中每个位字段的偏移量以及处理帧所需的任何状态处理（如 PTP 时间戳所要求的）。

从网络栈的角度来看，同一 DSA 交换树中的所有交换机都使用相同的标记协议。如果数据包通过多于一个交换机的结构，插入交换机特定帧头的是数据包接收到的第一个交换机。此头部通常包含有关其类型的信息（是必须捕获到 CPU 的控制帧还是需要转发的数据帧）。

控制帧应仅由软件数据路径解封装，而数据帧也可能自主地转发到同一结构中的其他交换机的其他用户端口，在这种情况下，最外层的交换端口必须解封装数据包。

需要注意的是，在某些情况下，叶交换机（未直接连接到 CPU）使用的标记格式可能与网络栈看到的不同。这可以在 Marvell 交换树中看到，其中 CPU 端口可以配置为使用 DSA 或 Ethertype DSA (EDSA) 格式，但 DSA 链接被配置为使用较短的（不含 Ethertype 的）DSA 帧头，以减少自主数据包转发开销。

即使如此，如果 DSA 交换树配置为 EDSA 标记协议，操作系统也会看到带有较短 DSA 头的叶交换机标记的数据包。这是因为在直接连接到 CPU 的 Marvell 交换机上配置了 DSA 到 EDSA 的标签转换（即添加或删除 `ETH_P_EDSA` EtherType 和一些填充字节的操作）。

即使它们的标记协议不兼容，也可以构建级联的 DSA 交换机设置。在这种情况下，此结构中没有 DSA 链接，并且每个交换机构成一个独立的 DSA 交换树。DSA 链接被视为一对 DSA 通道（上游 DSA 交换机的外向端口）和 CPU 端口（下游 DSA 交换机的内向端口）。
附件中的DSA交换树的标签协议可以通过`dsa/tagging` sysfs属性查看：

    cat /sys/class/net/eth0/dsa/tagging

如果硬件和驱动程序支持，可以在运行时更改DSA交换树的标签协议。这通过将新的标签协议名称写入上述相同的sysfs设备属性来实现（在此过程中，DSA通道及其所有连接的交换端口必须处于关闭状态）。
希望所有标签协议都能通过`dsa_loop`模拟驱动进行测试，该驱动可以连接到任何网络接口。目标是任何网络接口都应能够以相同的方式传输相同的报文，并且无论使用哪个驱动程序来控制交换路径或DSA通道，标签器都应该以相同的方式解码接收到的相同报文。
报文的发送会经过标签器的`xmit`函数。传递的`struct sk_buff *skb`中的`skb->data`指向`skb_mac_header(skb)`，即目的MAC地址，而传递的`struct net_device *dev`表示虚拟的DSA用户网络接口，该接口的硬件对应部分需要将报文引导至（例如`swp0`）。
此方法的任务是以交换机能够理解的方式准备skb，使交换机知道报文的目的端口（并且不会向其他端口传送）。通常这是通过添加一个帧头来实现的。如果`needed_headroom`和`needed_tailroom`属性正确填写，则无需检查skb头部或尾部的空间是否足够，因为DSA在调用此方法之前会确保有足够的空间。
报文的接收会经过标签器的`rcv`函数。传递的`struct sk_buff *skb`中的`skb->data`指向`skb_mac_header(skb) + ETH_ALEN`字节，即EtherType之后的第一个字节所在的位置（如果该帧没有被标记的话）。此方法的作用是消费帧头，调整`skb->data`使其真正指向EtherType之后的第一个字节，并将`skb->dev`更改为指向接收到报文的实际前端物理交换端口对应的虚拟DSA用户网络接口。
由于第1类和第2类标签协议破坏了DSA通道上的软件（通常是硬件）报文解析功能，因此DSA通道上的RPS（接收报文转向）等功能可能会失效。DSA框架通过挂钩流解析器并调整DSA通道看到的标记帧中IP头的位置偏移来处理这种情况。
这种行为是根据标签协议的`overhead`值自动进行的。如果并非所有报文大小都相同，标签器可以实现`struct dsa_device_ops`中的`flow_dissect`方法，并通过指定每个接收报文的正确偏移量来覆盖这种默认行为。尾部标签器不会对流解析器造成问题。
当DSA通道驱动在vlan_features中声明NETIF_F_HW_CSUM并查看csum_start和csum_offset时，第1类和第2类标签器应该支持校验和卸载功能。对于这些情况，DSA会根据标签大小调整校验和开始位置和偏移量。如果DSA通道驱动仍在vlan_features中使用过时的NETIF_F_IP_CSUM或NETIF_F_IPV6_CSUM，卸载功能可能仅在卸载硬件已经期望特定标签的情况下工作（可能是由于匹配的供应商）。DSA用户端口继承这些标志，由驱动程序负责在IP头不在硬件期望的位置时正确地回退到软件校验和。如果该检查无效，报文可能会在网络中传输而没有正确的校验和（校验和字段将包含伪IP头和）。
由于各种原因（最常见的原因是第1类标签器与不支持DSA的通道相关联，破坏了通道感知的MAC DA），标签协议可能要求DSA通道以混杂模式运行，以接收所有帧而不考虑MAC DA的值。这可以通过设置`struct dsa_device_ops`中的`promisc_on_conduit`属性来实现。
请注意，这假设了一个不支持DSA的管道驱动程序，这是常态。
管道网络设备
-------------

管道网络设备是普通的、未经修改的Linux网络设备驱动程序，用于CPU/管理以太网接口。这样的驱动程序偶尔需要知道是否启用了DSA（例如：启用或禁用特定的卸载功能），但事实证明，DSA子系统可以与标准行业驱动程序（如`e1000e`、`mv643xx_eth`等）一起工作，而无需对这些驱动程序进行任何修改。这种网络设备也常被称为管道网络设备，因为它们充当主机处理器和硬件以太网交换机之间的管道。
网络堆栈挂钩
-------------

当使用管道网络设备与DSA时，需要在网络堆栈中放置一个小的挂钩，以便让DSA子系统处理以太网交换机特定的标记协议。DSA通过向网络堆栈注册一个特定的（且虚拟的）以太网类型（稍后成为`skb->protocol`）来实现这一点，这也被称为`ptype`或`packet_type`。典型的以太网帧接收序列如下：

管道网络设备（例如e1000e）：

1. 接收中断触发：

        - 调用接收函数
        - 进行基本的数据包处理：获取长度、状态等
- 准备数据包以便由以太网层处理，调用`eth_type_trans`

2. `net/ethernet/eth.c`中的代码：

          eth_type_trans(skb, dev)
                  if (dev->dsa_ptr != NULL)
                          -> skb->protocol = ETH_P_XDSA

3. `drivers/net/ethernet/*`中的代码：

          netif_receive_skb(skb)
                  -> 遍历已注册的packet_type
                          -> 调用处理ETH_P_XDSA的handler，调用dsa_switch_rcv()

4. `net/dsa/dsa.c`中的代码：

          -> dsa_switch_rcv()
                  -> 调用特定于交换机标签协议的处理程序`net/dsa/tag_*.c`

5. `net/dsa/tag_*.c`中的代码：

        - 检查并剥离交换机标签协议以确定源端口
        - 查找每个端口的网络设备
        - 使用DSA用户网络设备调用`eth_type_trans()`
        - 调用`netif_receive_skb()`

在此之后，DSA用户网络设备将接收到普通的以太网帧，这些帧可以被网络堆栈处理。
用户网络设备
------------

由DSA创建的用户网络设备是基于其管道网络设备构建的，每个这些网络接口都负责作为交换机前面板端口的控制和数据流终点。这些接口经过专门设计以实现以下功能：

- 在发送到/从特定交换机端口的数据包中插入/移除交换机标签协议（如果存在）
- 查询交换机以执行ethtool操作：统计信息、链路状态、网络唤醒、寄存器转储等
- 管理外部/内部PHY：链路、自动协商等
这些用户网络设备具有自定义的`net_device_ops`和`ethtool_ops`函数指针，允许DSA在网络堆栈/ethtool与交换机驱动程序实现之间引入一层抽象。

当从这些用户网络设备传输帧时，DSA会查找当前注册给这些网络设备的交换机标记协议，并调用特定的传输例程，该例程负责在以太网帧中添加相关的交换机标签。然后使用管道网络设备的`ndo_start_xmit()`函数排队传输这些帧。由于它们包含适当的交换机标签，以太网交换机能够处理来自管理接口的这些传入帧，并将其传递到物理交换机端口。
当使用多个CPU端口时，可以在DSA用户设备和物理DSA通道之间堆叠一个LAG（绑定/团队）设备。因此，LAG设备也是一个DSA通道，但LAG从设备仍然是DSA通道（只是没有分配用户端口；这是为了在LAG DSA通道消失时进行恢复所需）。因此，LAG DSA通道的数据路径是不对称使用的。在接收（RX）时，`ETH_P_XDSA`处理器（调用`dsa_switch_rcv`）会在早期被调用（在物理DSA通道上；LAG从设备上）。因此，LAG DSA通道的接收数据路径未被使用。另一方面，发送（TX）是线性的：`dsa_user_xmit`调用`dsa_enqueue_skb`，后者又调用`dev_queue_xmit`向LAG DSA通道发送，该函数再向一个或另一个物理DSA通道调用`dev_queue_xmit`，在这两种情况下，数据包都会通过硬件路径离开系统并传送到交换机。

图形表示如下：

总结来说，从网络设备的角度来看，DSA大致如下所示：

```
                不了解DSA的应用程序
              打开并绑定套接字
                       |  ^
                       |  |
           +-----------v--|--------------------+
           |+------+ +------+ +------+ +------+|
           || swp0 | | swp1 | | swp2 | | swp3 ||
           |+------+-+------+-+------+-+------+|
           |          DSA交换机驱动程序        |
           +-----------------------------------+
                         |        ^
            由交换机驱动程序添加标签 |        | 由交换机驱动程序消费标签
                         v        |
           +-----------------------------------+
           | 未修改的主机接口驱动程序  | 软件
   --------+-----------------------------------+------------
           |       主机接口（eth0）       | 硬件
           +-----------------------------------+
                         |        ^
         由交换机硬件消费标签 |        | 由交换机硬件添加标签
                         v        |
           +-----------------------------------+
           |               交换机              |
           |+------+ +------+ +------+ +------+|
           || swp0 | | swp1 | | swp2 | | swp3 ||
           ++------+-+------+-+------+-+------++
```

用户MDIO总线
------------

为了能够读取和写入内置交换机PHY，DSA创建了一个用户MDIO总线，允许特定的交换机驱动程序拦截和重定向针对特定PHY地址的MDIO读写操作。在大多数MDIO连接的交换机中，这些功能将利用直接或间接PHY寻址模式来返回交换机内置PHY的标准MII寄存器，从而允许PHY库和/或返回链路状态、链路伙伴页面、自动协商结果等信息。

对于具有内部和外部MDIO总线的以太网交换机，用户MII总线可以用于复用/解复用指向该交换机可能连接到的内部或外部MDIO设备的MDIO读写操作：内部PHY、外部PHY甚至外部交换机。

数据结构
---------------

DSA数据结构定义在`include/net/dsa.h`以及`net/dsa/dsa_priv.h`中：

- `dsa_chip_data`：给定交换机设备的平台数据配置，此结构描述了交换机设备的父设备、其地址以及其端口的各种属性：名称/标签，最后是一个路由表指示（当级联交换机时）

- `dsa_platform_data`：平台设备配置数据，如果多个交换机级联，则可以引用一组`dsa_chip_data`结构，此交换机树所连接的通道网络设备也需要被引用

- `dsa_switch_tree`：分配给通道网络设备下的`dsa_ptr`的结构，此结构引用了一个`dsa_platform_data`结构以及交换机树支持的标记协议，以及应调用的接收/发送函数钩子，还提供了关于直接连接的交换机的信息：CPU端口。最后，引用了一组`dsa_switch`以解决树中的单个交换机

- `dsa_switch`：描述树中的交换机设备的结构，引用了一个`dsa_switch_tree`作为反指针，用户网络设备，通道网络设备，以及对底层`dsa_switch_ops`的引用

- `dsa_switch_ops`：引用函数指针的结构，请参见下面的完整描述

设计限制
==================

缺少CPU/DSA网络设备
-------------------------------

目前DSA不会为CPU或DSA端口创建用户网络设备，如前所述。这可能会导致以下问题：

- 无法使用ethtool获取交换机CPU端口统计计数器，这会使调试使用xMII接口连接的MDIO交换机变得更加困难

- 无法根据连接到它的以太网控制器的能力来配置CPU端口的链路参数：http://patchwork.ozlabs.org/patch/509806/

- 在使用级联设置时，无法配置交换机之间的特定VLAN ID/干道VLAN

使用DSA设置时常见的陷阱
--------------------------------

一旦配置了一个通道网络设备以使用DSA（`dev->dsa_ptr`变为非空），并且其后面的交换机期望一种标记协议，那么这个网络接口只能专用于作为通道接口。直接通过此接口发送数据包（例如：使用此接口打开套接字）将不会通过交换机标记协议传输函数，因此另一端的以太网交换机会因为没有标签而通常会丢弃这个帧。

与其他子系统的交互
==================

DSA目前利用了以下子系统：

- MDIO/PHY库：`drivers/net/phy/phy.c`，`mdio_bus.c`
- Switchdev：`net/switchdev/*`
- 设备树用于各种of_*函数
- Devlink：`net/core/devlink.c`

MDIO/PHY库
----------------

DSA暴露的用户网络设备可能与PHY设备（在`include/linux/phy.h`中定义的`struct phy_device`）交互也可能不交互，但DSA子系统处理所有可能的组合：

- 内置PHY设备，集成到以太网交换机硬件中
- 外部PHY设备，通过内部或外部MDIO总线连接
- 内部PHY设备，通过内部MDIO总线连接
- 特殊的、非自动协商或非MDIO管理的PHY设备：SFP，MoCA；即固定PHY

PHY配置由`dsa_user_phy_setup()`函数完成，逻辑基本上如下：

- 如果使用设备树，使用标准的“phy-handle”属性查找PHY设备，如果找到，则使用`of_phy_connect()`创建并注册该PHY设备

- 如果使用设备树且PHY设备为“固定”，即符合`Documentation/devicetree/bindings/net/fixed-link.txt`中定义的非MDIO管理PHY，则使用特殊的固定MDIO总线驱动程序透明地注册并连接PHY

- 最后，如果PHY内置在交换机中，这在独立交换机包中非常常见，使用DSA创建的用户MII总线探测PHY

SWITCHDEV
---------

DSA直接在与桥接层交互时利用SWITCHDEV，并且特别在其配置VLAN时使用VLAN过滤部分。截至今天，DSA支持的唯一SWITCHDEV对象是FDB和VLAN对象

Devlink
-------

DSA为结构中的每个物理交换机注册一个devlink设备。
对于每个devlink设备，每个物理端口（即用户端口、CPU端口、DSA链路或未使用的端口）都会作为一个devlink端口暴露出来。
DSA驱动程序可以使用以下devlink特性：

- 区域：调试功能，允许用户空间以低级别的二进制格式转储驱动程序定义的硬件信息区域。支持全局区域和每个端口的区域。即使某些数据已经通过标准iproute2用户空间程序（如ip-link、bridge）部分地暴露出来，也可以导出devlink区域，例如地址表和VLAN表。如果这些表包含一些无法通过iproute2抽象看到的硬件特定细节，或者需要检查未注册网络接口的非用户端口上的这些表，这可能是有用的。
- 参数：一种功能，使用户能够配置与设备相关的某些低级可调参数。驱动程序可以实现适用的通用devlink参数，也可以添加新的设备特定devlink参数。
- 资源：一种监控功能，使用户能够查看设备中某些硬件表（如FDB、VLAN等）的利用率程度。
- 共享缓冲区：一种QoS功能，用于调整和划分每个端口和每个流量类别的内存和帧预留，在入站和出站方向上，使得低优先级的大批量流量不会妨碍高优先级关键流量的处理。

更多详细信息，请参阅``Documentation/networking/devlink/``

设备树
------

DSA具有一个标准化绑定，该绑定在``Documentation/devicetree/bindings/net/dsa/dsa.txt``中有文档说明。还使用了PHY/MDIO库辅助函数（如``of_get_phy_mode()``、``of_phy_connect()``）来查询每个端口的PHY特定细节：接口连接、MDIO总线位置等。

驱动程序开发
============

DSA交换机驱动程序需要实现一个``dsa_switch_ops``结构体，其中将包含下面描述的各种成员。
探测、注册和设备生命周期
------------------------------

DSA交换机是总线上的常规``device``结构（无论是平台总线、SPI、I2C、MDIO或其他）。DSA框架不参与它们与设备核心的探测过程。
从驱动程序的角度来看，交换机注册通常意味着在其探测函数中向``dsa_register_switch()``传递一个有效的``struct dsa_switch``指针。提供的结构中必须有效的是：

- ``ds->dev``：将用于解析交换机的OF节点或平台数据。
- ``ds->num_ports``：用于为该交换机创建端口列表，并验证 OF 节点中提供的端口索引。
- ``ds->ops``：指向包含 DSA 方法实现的 `dsa_switch_ops` 结构体的指针。
- ``ds->priv``：指向一个驱动程序私有数据结构的反向指针，可以在所有后续的 DSA 方法回调中获取。

此外，可以在 `dsa_switch` 结构体中可选地配置以下标志，以从 DSA 核心中获得特定于驱动程序的行为。当这些标志被设置时，其行为在 `include/net/dsa.h` 中通过注释进行了说明：
- ``ds->vlan_filtering_is_global``
- ``ds->needs_standalone_vlan_filtering``
- ``ds->configure_vlan_while_not_filtering``
- ``ds->untag_bridge_pvid``
- ``ds->assisted_learning_on_cpu_port``
- ``ds->mtu_enforcement_ingress``
- ``ds->fdb_isolation``

内部地，DSA 在内核中维护了一个全局的交换机树（一组交换机）数组，并在注册时将一个 `dsa_switch` 结构体附加到一棵树上。
交换机所附着的树 ID 由交换机的 OF 节点中的 `dsa,member` 属性的第一个 u32 数字决定（如果缺失则为 0）。
交换机在树中的 ID 由同一个 OF 属性的第二个 u32 数字决定（如果缺失则为 0）。使用相同的交换机 ID 和树 ID 注册多个交换机是非法的，会导致错误。使用平台数据时，允许注册单个交换机和单个交换机树。
对于包含多个交换机的树，探测过程是非对称的。
前 N-1 个调用 `dsa_register_switch()` 的交换机会将其端口添加到树的端口列表 (`dst->ports`) 中，每个端口都有一个指向其关联交换机 (`dp->ds`) 的反向指针。然后，这些交换机会提前退出 `dsa_register_switch()` 调用，因为 `dsa_tree_setup_routing_table()` 确定树尚未完成（DSA 链接引用的所有端口未出现在树的端口列表中）。当最后一个交换机调用 `dsa_register_switch()` 时，树变为完整状态，这会触发该树内所有交换机初始化的实际继续（包括调用 `ds->ops->setup()`），所有这些都是作为最后一个交换机探测函数的调用上下文的一部分进行的。
在调用 `dsa_unregister_switch()` 时，与注册相反的过程会发生，该函数会从树的端口列表中移除交换机的端口。当第一个交换机注销时，整个树会被拆除。
### DSA 交换机驱动程序

DSA 交换机驱动程序必须实现其相应总线的 `shutdown()` 回调，并在其中调用 `dsa_switch_shutdown()`（这是一个最小版本的由 `dsa_unregister_switch()` 执行的完整清理操作）。

原因是 DSA 会保留一个到通道网络设备的引用，如果通道设备的驱动程序决定在关机时解除绑定，DSA 的引用将会阻止该操作完成。

`dsa_switch_shutdown()` 或 `dsa_unregister_switch()` 必须被调用，但不能同时调用两者。设备驱动模型允许即使已经调用了 `shutdown()` 方法，仍然可以调用总线的 `remove()` 方法。因此，驱动程序需要实现 `remove()` 和 `shutdown()` 之间的互斥方法，即在任何这些方法执行后将其 `drvdata` 设置为 `NULL`，并在继续采取任何行动之前检查 `drvdata` 是否为 `NULL`。

在调用 `dsa_switch_shutdown()` 或 `dsa_unregister_switch()` 后，通过提供的 `dsa_switch_ops` 进行的进一步回调将不再发生，驱动程序可以释放与 `dsa_switch` 相关联的数据结构。

### 交换机配置

- `get_tag_protocol`：用于指示支持哪种标签协议，应是 `dsa_tag_protocol` 枚举中的有效值。
返回的信息不必是静态的；驱动程序将传递 CPU 端口编号以及可能堆叠的上游交换机的标签协议，以应对硬件对支持的标签格式的限制。
- `change_tag_protocol`：当默认的标签协议与通道或其他问题不兼容时，驱动程序可以在运行时支持更改它，无论是通过设备树属性还是通过 sysfs。在这种情况下，进一步调用 `get_tag_protocol` 应报告当前使用的协议。
- `setup`：交换机的设置函数，此函数负责使用所有必需的内容设置 `dsa_switch_ops` 私有结构：寄存器映射、中断、互斥锁等。此函数还应正确配置交换机，使所有网络接口相互隔离，通常是通过为每个端口创建基于端口的 VLAN ID 并仅允许 CPU 端口和特定端口位于转发向量中。平台未使用的端口应被禁用。在此函数之后，交换机应完全配置并准备好处理任何类型的请求。建议在此设置函数中发出软件复位命令，以避免依赖于先前软件代理（如启动加载程序/固件）可能已配置的内容。负责撤销此处所做的任何适用分配或操作的方法是 `teardown`。
- `port_setup` 和 `port_teardown`：用于初始化和销毁每端口数据结构的方法。某些操作（如注册和注销 devlink 端口区域）必须从这些方法中完成，否则它们是可选的。只有在端口已预先设置的情况下才会被拆除。端口可能在探测期间设置，随后立即被拆除，例如在其 PHY 无法找到的情况下。在这种情况下，DSA 交换机的探测将继续进行，只是没有那个特定端口。
- `port_change_conduit`：用于更改用户端口与 CPU 端口之间关联（用于流量终止目的）的方法。默认情况下，来自树的所有用户端口都分配给第一个可用的 CPU 端口（大多数情况下这意味着树的所有用户端口都分配给同一个 CPU 端口，除了如提交 2c0b03258b8b 中描述的 H 拓扑）。`port` 参数表示用户端口的索引，`conduit` 参数表示新的 DSA 通道 `net_device`。可以通过查看 `struct dsa_port *cpu_dp = conduit->dsa_ptr` 来获取与新通道相关联的 CPU 端口。此外，通道也可以是一个 LAG 设备，其中所有从属设备都是物理的 DSA 通道。LAG DSA 也具有有效的 `conduit->dsa_ptr` 指针，但这不是唯一的，而是第一个物理 DSA 通道（LAG 从属设备）的 `dsa_ptr` 的副本。在 LAG DSA 通道的情况下，将单独发出进一步调用 `port_lag_join`，要求与物理 DSA 通道相关的物理 CPU 端口创建与 LAG 接口相关的硬件 LAG。
PHY设备和链路管理
-------------------------------

- ``get_phy_flags``：某些交换机连接了各种类型的以太网PHY，如果PHY库中的PHY驱动需要获取其无法自行获取的信息（例如：来自交换机内存映射寄存器），此函数应返回一个32位的“标志”掩码，该掩码在交换机驱动与`drivers/net/phy/*`中的以太网PHY驱动之间是私有的。
- ``phy_read``：当尝试读取交换机端口MDIO寄存器时，由DSA用户MDIO总线调用的函数。如果不可用，则对每次读取返回0xffff。对于内置交换机以太网PHY，此函数应允许读取链路状态、自动协商结果、链路伙伴页面等。
- ``phy_write``：当尝试写入交换机端口MDIO寄存器时，由DSA用户MDIO总线调用的函数。如果不可用则返回负错误代码。
- ``adjust_link``：当用户网络设备连接到PHY设备时，由PHY库调用的函数。此函数负责根据``phy_device``提供的信息适当地配置交换机端口链路参数：速度、双工模式、基于暂停的状态等。
- ``fixed_link_update``：由PHY库调用，特别是固定PHY驱动请求交换机驱动提供无法通过自动协商或通过MDIO读取PHY寄存器获得的链路参数。这对于诸如QSGMII、MoCA或其他非MDIO管理的PHY类型特别有用，因为这些硬件可以从其他途径获取链路信息。

ethtool操作
------------------

- ``get_strings``：用于查询驱动字符串的ethtool函数，通常会返回统计字符串、私有标志字符串等。
- ``get_ethtool_stats``：用于查询每个端口统计信息并返回其值的ethtool函数。DSA覆盖用户网络设备的一般统计信息：来自网络设备的RX/TX计数器，并提供每个端口特定的交换机驱动统计信息。
- ``get_sset_count``：用于查询统计项目数量的ethtool函数。
- ``get_wol``：用于获取每个端口Wake-on-LAN设置的ethtool函数，某些实现可能还会查询中继网络设备的Wake-on-LAN设置，如果这个接口需要参与Wake-on-LAN。
- ``set_wol``：用于配置每个端口Wake-on-LAN设置的ethtool函数，直接对应于set_wol，具有类似的限制。
- ``set_eee``：用于配置交换机端口EEE（绿色以太网）设置的ethtool函数，可选地调用PHY库来在PHY级别启用EEE（如果相关）。此函数应在交换机端口MAC控制器和数据处理逻辑中启用EEE。
- ``get_eee``：用于查询交换机端口EEE设置的ethtool函数，应返回交换机端口MAC控制器和数据处理逻辑的EEE状态以及查询PHY当前配置的EEE设置。
- ``get_eeprom_len``：返回给定交换机EEPROM长度/大小（字节）的ethtool函数。
- ``get_eeprom``：返回给定交换机EEPROM内容的ethtool函数。
- ``set_eeprom``：将指定数据写入给定交换机EEPROM的ethtool函数。
- ``get_regs_len``：返回给定交换机寄存器长度的ethtool函数。
- ``get_regs``：返回以太网交换机内部寄存器内容的ethtool函数。此函数可能需要用户空间中的ethtool代码来漂亮地打印寄存器值和寄存器。

电源管理
----------------

- ``suspend``：当系统进入休眠时，由DSA平台设备调用的函数，应使所有以太网交换活动静默，但保持参与Wake-on-LAN的端口处于活跃状态，同时支持额外的唤醒逻辑。
- ``resume``：当系统恢复时，由DSA平台设备调用的函数，应恢复所有以太网交换活动并重新配置交换机使其处于完全活跃状态。
- ``port_enable``：当端口被管理性启动时，由DSA用户网络设备ndo_open函数调用的函数，此函数应完全启用给定的交换机端口。DSA负责标记端口为``BR_STATE_BLOCKING``（如果端口是桥接成员），或者``BR_STATE_FORWARDING``（如果不是），并将这些更改传播到硬件。
- ``port_disable``：当端口被管理性关闭时，由DSA用户网络设备ndo_close函数调用的函数，此函数应完全禁用给定的交换机端口。DSA负责标记端口为``BR_STATE_DISABLED``，并将更改传播到硬件（如果端口在作为桥接成员时被禁用）。

地址数据库
-----------------

交换硬件预期有一个FDB条目的表，然而并非所有条目在同一时间都是活跃的。地址数据库是FDB条目的子集（分区），根据端口的状态（可以在接收地址学习或转发FDB查找时匹配）而活跃。地址数据库在此文档中偶尔被称为“FID”（过滤标识符），尽管底层实现可以根据硬件选择任何可用的方式。例如，所有属于VLAN无感知桥接（目前是VLAN无感知）的端口都预期在与该桥接相关的数据库中学习源地址（而不是与其他VLAN无感知桥接相关联）。在转发和FDB查找期间，从VLAN无感知桥接端口接收到的包应能够找到一个具有相同MAC DA的VLAN无感知FDB条目，该条目位于同一桥接的另一个端口上。同时，在FDB查找过程中，如果该条目指向属于不同VLAN无感知桥接的端口，则必须找不到具有相同MAC DA的FDB条目。类似地，每个卸载的VLAN感知桥接的每个VLAN都应该有一个关联的地址数据库，该数据库由该VLAN的所有成员端口共享，但不与属于同一VID的不同桥接的端口共享。
在此背景下，一个不支持VLAN的数据库意味着所有数据包都应与其匹配，而不管VLAN ID（仅基于MAC地址查找），而支持VLAN的数据库则意味着数据包应该根据分类后的802.1Q报头中的VLAN ID（或未标记时的pvid）进行匹配。在桥接层，不支持VLAN的FDB条目的VID值为特殊值0，而支持VLAN的FDB条目则具有非零的VID值。请注意，不支持VLAN的桥接器可能包含支持VLAN（非零VID）的FDB条目，而支持VLAN的桥接器也可能包含不支持VLAN的FDB条目。与硬件一样，软件桥接器维护独立的地址数据库，并通过switchdev异步地将属于这些数据库的FDB条目卸载到硬件，相对于数据库变为活动或非活动状态的时间。

当用户端口以独立模式运行时，其驱动程序应将其配置为使用一个称为端口专用数据库的独立数据库。这不同于上述数据库，并且应尽可能不妨碍作为独立端口的操作（数据包入，数据包出到CPU端口）。例如，在入站时，不应尝试学习入站流量的MAC源地址，因为学习是桥接层的服务，而这是一个独立端口，因此会占用无用的空间。没有地址学习的情况下，端口专用数据库在简单的实现中应该是空的，在这种情况下，所有收到的数据包都应该简单地泛洪到CPU端口。

由于服务多个地址数据库，级联（DSA）和CPU端口也被称为“共享”端口，并且数据包应关联的数据库通常嵌入在DSA标签中。这意味着CPU端口可以同时传输来自独立端口的数据包（这些数据包被硬件分类到一个地址数据库中），以及来自桥接端口的数据包（这些数据包被分类到另一个不同的地址数据库中）。

满足某些标准的交换机驱动程序能够通过将CPU端口从交换机的泛洪域中移除，并仅将硬件编程为指向已知软件感兴趣的MAC地址的FDB条目来优化简单的配置。不匹配已知FDB条目的数据包不会传送到CPU，这将节省创建skb只是为了丢弃它所需的CPU周期。

DSA能够执行以下类型的主机地址过滤：

- 端口的主要单播MAC地址（`dev->dev_addr`）。这些与相应用户端口的端口专用数据库相关联，并通过`port_fdb_add`通知驱动程序安装到CPU端口。
- 端口的次级单播和多播MAC地址（通过`dev_uc_add()`和`dev_mc_add()`添加的地址）。这些也与相应用户端口的端口专用数据库相关联。
- 本地/永久桥接FDB条目（`BR_FDB_LOCAL`）。这些是桥接端口的MAC地址，对于这些地址，数据包必须本地终止而不是转发。它们与该桥接器的地址数据库相关联。
- 安装到同一桥接器中某些DSA交换机端口所存在的外国（非DSA）接口的静态桥接FDB条目。这些也与该桥接器的地址数据库相关联。
动态学习到的FDB条目位于与某些DSA交换机端口在同一桥接器中的外部接口上，但前提是驱动程序将`ds->assisted_learning_on_cpu_port`设置为true。这些条目与该桥接器的地址数据库相关联。

对于下面详细说明的各种操作，DSA提供了一个`dsa_db`结构，该结构可以是以下类型之一：

- `DSA_DB_PORT`：要安装或删除的FDB（或MDB）条目属于用户端口`db->dp`的端口私有数据库。
- `DSA_DB_BRIDGE`：条目属于桥接器`db->bridge`的某个地址数据库。驱动程序需要负责VLAN无关数据库和此桥接器的每个VID数据库之间的分离。
- `DSA_DB_LAG`：条目属于LAG `db->lag`的地址数据库。注意：`DSA_DB_LAG`目前未使用，并且将来可能会被移除。

在`port_fdb_add`、`port_mdb_add`等函数中处理`dsa_db`参数的驱动程序应该声明`ds->fdb_isolation`为true。

为了在共享端口上进行地址引用计数，DSA为每个卸载的桥接器和每个卸载的LAG关联一个基于一的ID（`struct dsa_bridge::num`、`struct dsa_lag::id`）。驱动程序可以选择使用DSA的编号方案（ID可以通过`db->bridge.num`和`db->lag.id`读取），或者实现自己的方案。

只有声明支持FDB隔离的驱动程序才会收到属于`DSA_DB_PORT`数据库的CPU端口上的FDB条目的通知。

出于兼容性和向后兼容性的原因，即使驱动程序不支持FDB隔离，`DSA_DB_BRIDGE`地址也会通知给驱动程序。然而，在这种情况下，`db->bridge.num`和`db->lag.id`始终设置为0（表示没有隔离，用于引用计数的目的）。

请注意，交换机驱动程序并非必须为每个独立用户端口实现物理上分开的地址数据库。由于端口私有数据库中的FDB条目总是指向CPU端口，因此不会导致错误的转发决策。在这种情况下，所有独立端口可以共享同一个数据库，但是主机过滤地址的引用计数（如果端口的MAC地址仍在其他端口中使用，则不删除该端口的FDB条目）则成为驱动程序的责任，因为DSA并不知道端口数据库实际上是共享的。这可以通过调用`dsa_fdb_present_in_other_db()`和`dsa_mdb_present_in_other_db()`来实现。
不利之处在于，每个用户端口的接收过滤列表实际上是共享的，这意味着用户端口A可能会接受一个本不应接受的MAC目标地址的数据包，仅仅因为该MAC地址在用户端口B的接收过滤列表中。然而，这些数据包仍将在软件中被丢弃。

桥接层
------

卸载桥接转发平面是可选的，并由以下方法处理。它们可能不存在、返回-EOPNOTSUPP，或者`ds->max_num_bridges`可能为非零但已超出，这种情况下，加入桥接端口仍然是可能的，但是包转发将发生在软件中，并且在软件桥下的端口必须保持与独立操作时相同的配置，即禁用所有桥接服务功能（如地址学习等），并将所有收到的数据包仅发送到CPU端口。

具体来说，一旦端口在调用`port_bridge_join`方法时返回成功，它就开始卸载桥接的转发平面，并在`port_bridge_leave`被调用后停止这样做。卸载桥接意味着根据软件桥接端口的状态自主地学习FDB条目，并自主地转发（或泛洪）收到的数据包而不需CPU干预。

即使是在卸载桥接端口的情况下，这也仍然是可选的。标签协议驱动程序预计会为已经在入站交换端口的转发域中自主转发的数据包调用`dsa_default_offload_fwd_mark(skb)`。通过`dsa_port_devlink_setup()`，DSA认为所有属于同一树ID的交换端口都属于同一个桥接转发域（能够自主地相互转发）。

卸载桥接的TX转发过程与简单地卸载其转发平面是不同的概念，指的是某些驱动程序和标签协议组合能够将来自桥接设备的传输函数的一个skb传送到潜在的多个出端口（从而避免在软件中的克隆）。

请求这种行为的数据包称为数据平面数据包，并且在标签协议驱动程序的`xmit`函数中将`skb->offload_fwd_mark`设置为true。数据平面数据包受FDB查找、CPU端口上的硬件学习的影响，并且不会覆盖端口的STP状态。

此外，数据平面数据包的复制（多播、泛洪）由硬件处理，而桥接驱动程序将为每个可能需要复制的数据包传输一个skb。

当启用TX转发卸载时，标签协议驱动程序负责将数据包注入硬件的数据平面，进入端口所属的正确桥接域（FID）。端口可能是不感知VLAN的，在这种情况下，FID必须等于驱动程序为其不感知VLAN的地址数据库使用的FID，该数据库与该桥接相关联。

或者，桥接可能是感知VLAN的，在这种情况下，保证数据包也带有该桥接处理此数据包时所用的VLAN ID。硬件的责任是在出端口未标记VID时去除VID标签，或者在出端口已标记VID时保留该标签。

- `port_bridge_join`：当给定的交换端口被添加到桥接时调用的桥接层函数，此函数应在交换机级别执行必要的操作，以允许加入的端口加入相关的逻辑域，以便与其他桥接成员进行入站/出站流量。
通过将 `tx_fwd_offload` 参数设置为 `true`，此桥接器的 TX 转发过程也会被卸载。

- `port_bridge_leave`：当某个交换端口从桥接器中移除时调用的桥接层函数。此函数应在交换机级别执行必要的操作，以阻止离开的端口接收来自其他桥接成员的入站和出站流量。
- `port_stp_state_set`：当给定的交换端口 STP 状态由桥接层计算并需要传播到交换硬件以转发/阻塞/学习流量时调用的桥接层函数。
- `port_bridge_flags`：当端口必须配置其设置（例如未知流量泛洪或源地址学习）时调用的桥接层函数。交换驱动程序负责初始设置独立端口，禁用地址学习并泛洪所有类型的流量，然后当端口加入或离开桥接器时，DSA 核心会通知任何对桥接端口标志的更改。目前 DSA 不管理 CPU 端口的桥接端口标志。假设如果硬件支持的话，CPU 端口应静态启用地址学习，并且由于 DSA 核心中缺乏明确的地址过滤机制，因此向 CPU 端口的泛洪也应启用。
- `port_fast_age`：当需要清除端口上动态学习的 FDB 条目时调用的桥接层函数。这在从一个应该进行学习的 STP 状态转换为不应进行学习的 STP 状态时、或者当离开桥接器时、或者通过 `port_bridge_flags` 关闭地址学习时调用。
桥接 VLAN 过滤
------------------

- `port_vlan_filtering`：当桥接器配置开启或关闭 VLAN 过滤时调用的桥接层函数。如果没有特定的操作需要在硬件级别完成，则无需实现此回调。
当开启 VLAN 过滤时，硬件必须编程以拒绝具有不在允许的 VLAN ID 地图/规则之外的 802.1Q 帧。如果交换端口中没有编程 PVID，则还应拒绝未标记的帧。当关闭时，交换机必须接受任何 802.1Q 帧，无论其 VLAN ID 如何，并且允许未标记的帧。
- `port_vlan_add`：当为给定的交换端口配置 VLAN（标记或未标记）时调用的桥接层函数。只有当外桥端口也是该 VLAN 的成员（并且需要在软件中进行转发），或者 VLAN 安装到桥接设备本身的 VLAN 组中用于终止目的（如 `bridge vlan add dev br0 vid 100 self`）时，CPU 端口才成为 VLAN 的成员。共享端口上的 VLAN 是引用计数的，并在没有用户使用时删除。驱动程序不需要手动在 CPU 端口上安装 VLAN。
- `port_vlan_del`：当从给定的交换端口中删除 VLAN 时调用的桥接层函数。
- `port_fdb_add`：当桥接器想要安装一个转发数据库条目时调用的桥接层函数，交换硬件应根据指定的地址和 VLAN ID 在与该 VLAN ID 相关的转发数据库中进行编程。
- `port_fdb_del`：当桥接器想要删除一个转发数据库条目时调用的桥接层函数，交换硬件应编程以从指定的 VLAN ID 中删除指定的 MAC 地址，如果它映射到了该端口的转发数据库中。
- `port_fdb_dump`：由 `ndo_fdb_dump` 在物理 DSA 端口接口上调用的桥接旁路函数。由于 DSA 并不试图保持其硬件 FDB 条目与软件桥接同步，此方法作为查看硬件数据库中用户端口可见条目的手段而实现。
此函数报告的条目在`bridge fdb show`命令的输出中带有`self`标志。
- `port_mdb_add`：当网桥希望安装一个多播数据库条目时调用的网桥层函数。交换硬件应根据指定的VLAN ID将指定地址编程到与此VLAN ID关联的转发数据库中。
- `port_mdb_del`：当网桥希望删除一个多播数据库条目时调用的网桥层函数，交换硬件应被编程为从指定的VLAN ID中删除指定的MAC地址（如果该地址映射到了该端口的转发数据库）。

链路聚合
---------

链路聚合通过bonding和team驱动在Linux网络堆栈中实现，这些驱动被建模为虚拟、可堆叠的网络接口。DSA能够将链路聚合组（LAG）卸载到支持该特性的硬件上，并支持物理端口与LAG之间以及LAG之间的桥接。一个包含多个物理端口的bonding/team接口构成一个逻辑端口，尽管DSA目前没有明确的逻辑端口概念。因此，当LAG加入或离开网桥时，视为所有属于该LAG的单个物理端口加入或离开网桥。作为网桥端口卸载到LAG上的Switchdev端口属性（VLAN过滤、STP状态等）和对象（VLAN、MDB条目）也类似处理：DSA在LAG的所有成员上卸载相同的Switchdev对象/端口属性。目前还不支持在LAG上的静态网桥FDB条目，因为DSA驱动API中没有逻辑端口ID的概念。
- `port_lag_join`：当某个交换端口加入LAG时调用的函数。驱动程序可以返回`-EOPNOTSUPP`，在这种情况下，DSA会回退到软件实现，其中来自该端口的所有流量都被发送到CPU。
- `port_lag_leave`：当某个交换端口离开LAG并恢复为独立端口操作时调用的函数。
- `port_lag_change`：当LAG中的任何成员的链路状态发生变化且需要重新平衡哈希函数以仅使用处于活动状态的LAG成员端口子集时调用的函数。
受益于每个卸载LAG具有ID的驱动程序可以从`dsa_switch_ops::setup`方法中选择填充`ds->num_lag_ids`。然后DSA交换机驱动程序可以使用`dsa_lag_id`函数检索与bonding/team接口关联的LAG ID。

IEC 62439-2（MRP）
-----------------

媒体冗余协议是一种针对环形网络快速故障恢复时间优化的拓扑管理协议，部分功能由网桥驱动实现。MRP使用管理PDUs（测试、拓扑、链路Down/Up、选项）发送到多播目的MAC地址范围01:15:4e:00:00:0x，并使用EtherType为0x88e3。
根据节点在环中的角色（MRM：媒体冗余管理器，MRC：媒体冗余客户端，MRA：媒体冗余自动管理器），某些MRP PDU可能需要本地终止，而其他则需要转发。
MRM还可以从硬件卸载创建和传输某些MRP PDU（测试）中获益。
通常，可以在任何网络接口上创建MRP实例，但在具有卸载数据路径（如DSA）的设备的情况下，即使硬件不支持MRP，也需要能够从结构中提取MRP PDU，然后驱动程序才能继续进行软件实现。目前DSA没有支持MRP的驱动程序，因此它只监听最少的switchdev对象，以确保软件辅助功能正常工作。以下是详细的操作：

- `port_mrp_add` 和 `port_mrp_del`：当创建或删除具有特定环ID、优先级、主端口和次端口的MRP实例时通知驱动程序
- `port_mrp_add_ring_role` 和 `port_mrp_del_ring_role`：当MRP实例在MRM或MRC之间改变角色时调用的函数。这会影响哪些MRP PDU应被捕获到软件中，哪些应自主转发

IEC 62439-3 (HSR/PRP)
---------------------

并行冗余协议（PRP）通过在两个独立的L2网络中复制和序列编号数据包，并在接收端消除重复数据包来实现网络冗余。这两个独立的L2网络对PRP尾标签是无感知的。高可用无缝冗余（HSR）协议概念类似，但所有携带冗余流量的节点都知道这是HSR标记的数据包（因为HSR使用以太类型0x892f的头部），并且物理上连接成环形拓扑。HSR和PRP都使用监督帧来监控网络健康状况和发现其他节点。

在Linux中，HSR和PRP都是通过hsr驱动实现的，该驱动创建一个虚拟的、可堆叠的网络接口，包含两个成员端口。驱动程序仅实现了基本的角色DANH（实现HSR的双重连接节点）和DANP（实现PRP的双重连接节点）；RedBox和QuadBox角色未实现（因此，将hsr网络接口与物理交换机端口桥接不会产生预期结果）。

能够卸载DANP或DANH某些功能的驱动程序应根据文档“Documentation/networking/netdev-features.rst”声明相应的netdev特性。此外，还必须实现以下方法：

- `port_hsr_join`：当给定的交换机端口加入DANP/DANH时调用的函数。驱动程序可以返回`-EOPNOTSUPP`，在这种情况下，DSA将回退到一种软件实现方式，其中来自此端口的所有流量都会发送到CPU
- `port_hsr_leave`：当给定的交换机端口离开DANP/DANH并恢复为独立端口时调用的函数
TODO
====

使 SWITCHDEV 和 DSA 融合到统一的代码库
-------------------------------------------------------------

SWITCHDEV 正确地处理了通过具有卸载能力的硬件抽象网络堆栈的问题，但并没有强制实施严格的交换设备驱动模型。而 DSA 则强制实施了一个相对严格的设备驱动模型，并处理了大多数与交换机相关的问题。在某个时候，我们应该考虑将这两个子系统合并，以获得两者的最佳特性。
