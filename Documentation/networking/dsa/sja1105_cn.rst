NXP SJA1105 交换机驱动程序
=========================

概述
========

NXP SJA1105 是一系列由10个SPI管理的汽车级交换机：

- SJA1105E: 第一代，无TTEthernet支持
- SJA1105T: 第一代，支持TTEthernet
- SJA1105P: 第二代，无TTEthernet支持，无SGMII接口
- SJA1105Q: 第二代，支持TTEthernet，无SGMII接口
- SJA1105R: 第二代，无TTEthernet支持，有SGMII接口
- SJA1105S: 第二代，支持TTEthernet，有SGMII接口
- SJA1110A: 第三代，支持TTEthernet、SGMII接口，集成100base-T1和100base-TX物理层
- SJA1110B: 第三代，支持TTEthernet、SGMII接口、100base-T1、100base-TX
- SJA1110C: 第三代，支持TTEthernet、SGMII接口、100base-T1、100base-TX
- SJA1110D: 第三代，支持TTEthernet、SGMII接口、100base-T1

作为汽车零部件，它们的配置界面设计为设置后即忘记的方式，运行时动态交互最少。这些交换机需要软件组合一个静态配置，并通过CRC和表头进行打包，然后通过SPI发送出去。
静态配置由多个配置表组成。每个表包含一定数量的条目。某些配置表可以在运行时（部分）重新配置，而有些则不能。有些表是必需的，有些则不是：

============================= ================== =============================
表                           必需              可重新配置
============================= ================== =============================
调度表                       否                 否
调度入口点                   若启用调度         否
虚拟局域网查找                否                 否
虚拟局域网策略                若启用虚拟局域网查找  否
虚拟局域网转发                若启用虚拟局域网查找  否
第二层查找                    否                 否
第二层策略                    是                 否
虚拟局域网查找                是                 部分（在P/Q/R/S上完全）
第二层转发                    是                 部分（在P/Q/R/S上完全）
MAC配置                      是                 部分（在P/Q/R/S上完全）
调度参数                      若启用调度         否
调度入口点参数                若启用调度         否
虚拟局域网转发参数            若启用虚拟局域网转发  否
第二层查找参数                否                 部分（在P/Q/R/S上完全）
第二层转发参数                是                 否
时钟同步参数                  否                 否
AVB参数                       否                 否
通用参数                      是                 部分
重标签                        否                 是
xMII参数                      是                 否
SGMII                         否                 是
============================= ================== =============================

此外，配置是只写操作（除了极少数例外情况，软件无法从交换机读取配置）。
驱动程序在探测时创建一个静态配置，并始终将其保留在内存中，作为硬件状态的影子。当需要更改硬件设置时，静态配置也会被更新。
如果可以将更改后的设置通过动态重新配置接口传输到交换机，则会这样做；否则将重置并重新编程交换机，使用更新后的静态配置。
交换机特性
==================

该驱动程序支持在硬件中配置第二层转发规则以实现端口桥接。可以通过两种方法限制端口之间的转发、广播和泛洪域：要么在第二层转发级别（隔离一个桥接器的端口与另一个的端口），要么在虚拟局域网端口成员资格级别（在同一桥接器内隔离端口）。硬件做出的最终转发决策是这两组规则的逻辑与运算结果。
硬件内部使用基于端口的虚拟局域网（pvid）标记所有流量，或者解码802.1Q标签中的虚拟局域网信息。高级虚拟局域网分类是不可能的。一旦分配了虚拟局域网标签，帧就会根据端口的成员资格规则进行检查，在进入时若不符合任何虚拟局域网则会被丢弃。
此行为在交换机端口加入具有`vlan_filtering 1`的桥接器时可用。
通常，硬件对于虚拟局域网意识不可配置，但是通过改变交换机搜索802.1Q标签所用的TPID，可以保持`vlan_filtering 0`的桥接器语义（接受所有流量，无论是否标记），因此也支持这种模式。
支持将交换机端口分割到多个桥接器中（例如2+2），但所有桥接器都应具有相同的虚拟局域网意识水平（要么都是`vlan_filtering` 0，要么都是1）。
支持通过STP进行拓扑和环路检测。
卸载
=====

时间感知调度
------------------

交换机支持IEEE 802.1Q-2018（原为802.1Qbv）中对计划流量增强特性的变体。这意味着它可以用于确保优先级流量在网络调度中的门打开事件时具有确定性的延迟，这些流量是与带宽内的其他数据一同发送的。
这种能力可以通过tc-taprio卸载（'标志 2'）进行管理。与taprio软件实现相比的区别在于后者只能塑造源自CPU的流量，而不能处理自主转发的数据流。
该设备有8个流量等级，并根据VLAN PCP位将传入帧映射到其中一个等级（如果没有VLAN，则使用基于端口的默认值）。
如前文所述，依据`vlan_filtering`的值，交换机识别的VLAN EtherType可以是典型的0x8100或驱动程序内部用于标记的自定义值。
因此，在独立模式或桥接模式下，当`vlan_filtering=0`时，由于交换机无法识别0x8100的EtherType，所以它会忽略VLAN PCP位。在这些模式下，仅能通过DSA网络设备将流量注入特定的TX队列，因为它们会在出站时填充标签头中的PCP字段。
使用`vlan_filtering=1`时情况则相反：卸载的数据流可以根据VLAN PCP被引导到TX队列，但DSA网络设备则不再能做到这一点。
为了在启用VLAN感知的情况下将帧注入硬件TX队列，需要在DSA通道端口上创建一个VLAN子接口，并向交换机发送带有正常（0x8100）VLAN标签的帧，同时正确设置VLAN PCP位。
管理流量（具有DMAC 01-80-C2-xx-xx-xx或01-19-1B-xx-xx-xx）是一个显著的例外：交换机会始终以固定优先级处理此类流量，并忽略任何存在的VLAN PCP位。目前管理流量的流量等级值为7（最高优先级），并且在驱动程序中不可配置。
以下是为出口端口`swp5`配置500微秒周期性调度的一个示例。管理流量（7）的流量等级门开启100微秒，而所有其他流量等级的门开启400微秒：

```bash
#!/bin/bash

set -e -u -o pipefail

NSEC_PER_SEC="1000000000"

gatemask() {
        local tc_list="$1"
        local mask=0

        for tc in ${tc_list}; do
                mask=$((${mask} | (1 << ${tc})))
        done

        printf "%02x" ${mask}
}

if ! systemctl is-active --quiet ptp4l; then
        echo "Please start the ptp4l service"
        exit
fi

now=$(phc_ctl /dev/ptp1 get | gawk '/clock time is/ { print $5; }')
# 将基准时间与下一秒的开始对齐
sec=$(echo "${now}" | gawk -F. '{ print $1; }')
base_time="$(((${sec} + 1) * ${NSEC_PER_SEC}))"

tc qdisc add dev swp5 parent root handle 100 taprio \
        num_tc 8 \
        map 0 1 2 3 5 6 7 \
        queues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7 \
        base-time ${base_time} \
        sched-entry S $(gatemask 7) 100000 \
        sched-entry S $(gatemask "0 1 2 3 4 5 6") 400000 \
        flags 2
```

可以在多个出口端口应用tc-taprio卸载。与此相关的硬件限制在于不允许两个端口同时触发门事件。驱动程序会检查这些日程安排的一致性以避免违反此限制，并在适当情况下报错。避免此类情况需要进行日程分析，这超出了本文档的范围。
路由操作（重定向、捕获、丢弃）
--------------------------------------

交换机能够卸载基于流的包重定向至用户指定的目的端口集。内部实现上，这是通过使用虚拟链路（TTEthernet概念）来完成的。
驱动程序支持两种类型的虚拟链路键：

- 带VLAN感知的虚拟链路：这些匹配目标MAC地址、VLAN ID和VLAN PCP
- 不带VLAN感知的虚拟链路：这些仅匹配目标MAC地址
桥接器的VLAN感知状态（vlan_filtering）在已安装虚拟链路规则的情况下无法更改。
在同一规则中组合多个操作是被支持的。当仅请求路由操作时，驱动程序会创建一个“非关键”虚拟链路。如果操作列表中还包含 tc-gate（详情见下文），则该虚拟链路变为“时间关键型”（从预留的内存分区提取帧缓冲等）。
支持的三种路由操作为“捕获”、“丢弃”和“重定向”。
示例 1：将接收自 swp2 端口且目标地址为 42:be:24:9b:76:20 的帧发送到 CPU 和 swp3 端口。这种类型的关键字（仅目标地址）在端口的 VLAN 意识状态关闭时适用：

  tc qdisc add dev swp2 clsact
  tc filter add dev swp2 ingress flower skip_sw dst_mac 42:be:24:9b:76:20 \
          action mirred egress redirect dev swp3 \
          action trap

示例 2：丢弃接收自 swp2 端口且目标地址为 42:be:24:9b:76:20、VLAN ID 为 100 并且 VLAN 优先级为 0 的帧：

  tc filter add dev swp2 ingress protocol 802.1Q flower skip_sw \
          dst_mac 42:be:24:9b:76:20 vlan_id 100 vlan_prio 0 action drop

基于时间的入口策略
-------------------

交换机的TTEthernet硬件能力可以被约束以类似 IEEE 802.1Q-2018（原 802.1Qci）中规定的每流过滤与策略（PSFP）条款的方式运作。这意味着它可以用于对最多 1024 个流（由目标 MAC 地址、VLAN ID 和 VLAN PCP 组成的元组标识）执行严格的时间基础准入控制。在预期接收窗口之外接收到的数据包会被丢弃。
此功能可以通过 tc-gate 动作的卸载来管理。由于路由动作是 TTEthernet 中虚拟链路固有的（它执行时间关键型流量的显式路由，并不将其留给 FDB、泛洪等处理），因此在要求 sja1105 卸载 tc-gate 动作时，tc-gate 动作不能单独出现。必须至少跟随一个重定向或捕获动作。
示例：创建一个与 tc-gate 调度同步的 tc-taprio 调度（时钟需通过 1588 应用堆栈进行同步，这超出了本文档的范围）。发送者发送的任何数据包都不会被丢弃。需要注意的是，接收窗口比传输窗口大（在这个例子中更是如此）以补偿链路的数据包传播延迟（可通过 1588 应用堆栈确定）。
接收方（sja1105）：

  tc qdisc add dev swp2 clsact
  now=$(phc_ctl /dev/ptp1 get | awk '/clock time is/ {print $5}') && \
          sec=$(echo $now | awk -F. '{print $1}') && \
          base_time="$(((sec + 2) * 1000000000))" && \
          echo "base time ${base_time}"
  tc filter add dev swp2 ingress flower skip_sw \
          dst_mac 42:be:24:9b:76:20 \
          action gate base-time ${base_time} \
          sched-entry OPEN  60000 -1 -1 \
          sched-entry CLOSE 40000 -1 -1 \
          action trap

发送方：

  now=$(phc_ctl /dev/ptp0 get | awk '/clock time is/ {print $5}') && \
          sec=$(echo $now | awk -F. '{print $1}') && \
          base_time="$(((sec + 2) * 1000000000))" && \
          echo "base time ${base_time}"
  tc qdisc add dev eno0 parent root taprio \
          num_tc 8 \
          map 0 1 2 3 4 5 6 7 \
          queues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7 \
          base-time ${base_time} \
          sched-entry S 01  50000 \
          sched-entry S 00  50000 \
          flags 2

用于调度入口门控操作的引擎与用于 tc-taprio 卸载的相同。因此，关于两个门控动作（无论是 tc-gate 还是 tc-taprio 门控）不能在同一时间（同一 200 纳秒时段内）触发的限制仍然适用。
为了便于使用，可以跨多个入口端口共享时间触发的虚拟链路，通过流块实现。在这种情况下，同时触发的限制不适用，因为系统中只有一个调度表，即共享虚拟链路的调度表：

  tc qdisc add dev swp2 ingress_block 1 clsact
  tc qdisc add dev swp3 ingress_block 1 clsact
  tc filter add block 1 flower skip_sw dst_mac 42:be:24:9b:76:20 \
          action gate index 2 \
          base-time 0 \
          sched-entry OPEN 50000000 -1 -1 \
          sched-entry CLOSE 50000000 -1 -1 \
          action trap

每个流的硬件统计信息也可获取（"pkts" 计数被丢弃的数据包数量，这是因时间违规、缺少目的端口和 MTU 强制检查导致的数据包丢弃数量之和）。字节级别的计数器不可用。

限制
====

SJA1105 交换机系列始终执行 VLAN 处理。在配置为不感知 VLAN 时，帧携带不同的内部 VLAN 标签，具体取决于端口是独立的还是位于不感知 VLAN 的桥接器之下。
虚拟链路关键字始终固定为 {MAC 目标地址, VLAN ID, VLAN PCP}，但当端口位于 VLAN 意识桥接器之下时，驱动程序会请求 VLAN ID 和 VLAN PCP。否则，它会根据端口是否独立或位于不感知 VLAN 的桥接器之下自动填充 VLAN ID 和 PCP，并且仅接受“不感知 VLAN”的 tc-flower 关键字（MAC 目标地址）。
使用虚拟链接卸载的现有 tc-flower 键在以下任一情况发生后将不再起作用：

- 端口原来是独立的，后来加入了桥接器（无论是 VLAN 意识还是非 VLAN 意识）
- 端口是桥接器的一部分，而该桥接器的 VLAN 意识状态发生了变化
- 端口原来是桥接器的一部分，后来变成了独立端口
- 端口原来是独立的，但另一个端口加入了一个 VLAN 意识桥接器，这改变了桥接器的整体 VLAN 意识状态

驱动程序无法否决所有这些操作，并且也无法更新或删除现有的 tc-flower 过滤器。因此为了确保正确运行，tc-flower 过滤器应在完成端口转发配置之后安装，并且在对设备树绑定和板设计进行任何更改之前由用户空间移除。

### 设备树绑定和板设计

本节参考 `Documentation/devicetree/bindings/net/dsa/nxp,sja1105.yaml`，旨在展示一些潜在的交换机问题。

#### RMII PHY 角色与带外信号传输

根据 RMII 规范，50 MHz 时钟信号要么由介质访问控制器 (MAC) 驱动，要么由外部振荡器驱动（而不是由 PHY 驱动）。
但是规范相对宽松，各种设备以多种方式偏离了它。
某些 PHY 违反了规范，在一个输出引脚上提供了自行产生的 50 MHz 时钟，试图提供帮助。
另一方面，SJA1105 只能通过二进制方式进行配置——当处于 RMII MAC 角色时，它也会尝试驱动时钟信号。为了避免这种情况，必须将其置于 RMII PHY 角色。
但这样做会带来一些意外后果。
根据 RMII 规范，PHY 可以通过 RXD[1:0] 发送额外的带外信号。
实际上，这些是在每帧前导码之前的几个额外代码字（/J/ 和 /K/）。MAC 并没有定义 RMII 规范中的这种带外信号传输机制。
因此，当 SJA1105 端口置于 PHY 角色以避免两个驱动程序同时驱动时钟信号时，不可避免地会创建一个 RMII PHY 到 PHY 的连接。SJA1105 完全模拟 PHY 接口，并在帧前导码之前生成 /J/ 和 /K/ 符号，而真正的 PHY 不被期望理解这些额外符号。因此，PHY 将从 SJA1105（作为 PHY）接收到的额外符号直接编码到 100Base-Tx 线路上。
在另一侧的线路末端，一些链路伙伴可能会丢弃这些额外的符号，而其他的一些则可能因为这些符号而导致整个以太网帧被丢弃。这在某些链路伙伴看来就像是数据包丢失，但在其他的链路伙伴那里则不会出现这种情况。
结论是，在RMII模式下，如果SJA1105连接到了一个PHY，则必须让SJA1105来驱动参考时钟。
RGMII固定链路与内部延迟
-------------------------------

如绑定文档中所述，第二代设备包含可调节的延迟线作为MAC的一部分，可以用来建立正确的RGMII定时预算。
当通电后，这些延迟线可以在73.8到101.7度之间产生Rx和Tx时钟之间的相位差。
问题在于，这些延迟线需要锁定在一个稳定的频率信号上。这意味着在旧频率与新频率之间的时钟至少要有2微秒的静默期。否则会失去锁定，延迟线需要重置（断电再重新供电）。
在RGMII中，时钟频率随链路速度变化（1000Mbps时为125MHz，100Mbps时为25MHz，10Mbps时为2.5MHz），并且链路速度可能会在自动协商过程中发生变化。
在交换机端口通过RGMII固定链路连接到一个链路伙伴的情况下，如果该链路伙伴的链路状态生命周期不在Linux控制之外（例如另一个SoC），那么延迟线将保持未锁定（且不活跃），直到有人工干预（在交换机端口上执行ifdown/ifup）。
结论是，在RGMII模式下，只有当链路伙伴从不改变链路速度，或者即使改变也必须与交换机端口协调一致时（实际上，固定链路的两端都由同一Linux系统控制），交换机的内部延迟才是可靠的。
至于为什么固定链路接口会改变链路速度：存在一些以太网控制器，在复位后默认运行在100Mbps模式下，并且其驱动程序不可避免地需要更改速度和时钟频率，以便在需要时能够工作在千兆模式下。
MDIO总线与PHY管理
------------------------

SJA1105没有MDIO总线，也不执行带内自动协商。
因此，交换机设备不会发出任何链路状态通知。
需要将连接到该交换机的物理层设备（PHY）连接到系统中Linux可用的其他任何MDIO总线上（例如，连接到DSA通道的MDIO总线上）。链路状态管理通过驱动程序手动保持MAC链路速度与PHY协商设置同步来实现（通过SPI命令）。
相比之下，SJA1110支持一个MDIO从设备访问点，其内部的100base-T1 PHY可通过主机访问。然而，这个功能并未被驱动程序使用，而是通过SPI命令访问内部的100base-T1和100base-TX PHY，在Linux中被建模为虚拟MDIO总线。
连接到SJA1110端口0的微控制器也具有一个以主模式运行的MDIO控制器，但是驱动程序也不支持这一点，因为当Linux驱动程序运行时，会禁用该微控制器。
连接到交换机端口的独立PHY应将其MDIO接口连接到主机系统的MDIO控制器上，而不是连接到交换机上，类似于SJA1105的情况。

端口兼容性矩阵
------------------

SJA1105的端口兼容性矩阵如下：

===== ============== ============== ==============
端口   SJA1105E/T     SJA1105P/Q     SJA1105R/S
===== ============== ============== ==============
0      xMII           xMII           xMII
1      xMII           xMII           xMII
2      xMII           xMII           xMII
3      xMII           xMII           xMII
4      xMII           xMII           SGMII
===== ============== ============== ==============

SJA1110的端口兼容性矩阵如下：

===== ============== ============== ============== ==============
端口   SJA1110A       SJA1110B       SJA1110C       SJA1110D
===== ============== ============== ============== ==============
0      RevMII (uC)    RevMII (uC)    RevMII (uC)    RevMII (uC)
1      100base-TX     100base-TX     100base-TX
       或 SGMII                                    SGMII
2      xMII           xMII           xMII           xMII
       或 SGMII                                    或 SGMII
3      xMII           xMII           xMII
       或 SGMII       或 SGMII                       SGMII
       或 2500base-X  或 2500base-X                  或 2500base-X
4      SGMII          SGMII          SGMII          SGMII
       或 2500base-X  或 2500base-X  或 2500base-X  或 2500base-X
5      100base-T1     100base-T1     100base-T1     100base-T1
6      100base-T1     100base-T1     100base-T1     100base-T1
7      100base-T1     100base-T1     100base-T1     100base-T1
8      100base-T1     100base-T1     不适用         不适用
9      100base-T1     100base-T1     不适用         不适用
10     100base-T1     不适用         不适用         不适用
===== ============== ============== ============== ==============
