SPDX 许可声明标识符：GPL-2.0

===================================
Linux 以太网绑定驱动程序使用说明
===================================

最后更新：2011年4月27日

初始发布者：Thomas Davis <tadavis at lbl.gov>

修正与高可用性扩展：2000/10/03-15：

  - Willy Tarreau <willy at meta-x.org>
  - Constantine Gavrilov <const-g at xpert.com>
  - Chad N. Tindel <ctindel at ieee dot org>
  - Janice Girouard <girouard at us dot ibm dot com>
  - Jay Vosburgh <fubar at us dot ibm dot com>

2005年2月由Jay Vosburgh重新组织和更新
添加Sysfs信息：2006/04/24

  - Mitch Williams <mitch.a.williams at intel.com>

简介
============

Linux绑定驱动程序提供了一种将多个网络接口聚合为单一逻辑“绑定”接口的方法。
绑定接口的行为取决于模式；通常，模式提供了热备用或负载平衡服务。
此外，还可以执行链路完整性监控。
绑定驱动最初来自Donald Becker的beowulf补丁包，用于内核2.0。自那以后它已经发生了很大的变化，原来的来自extreme-linux和beowulf站点的工具无法与这个版本的驱动兼容。
对于新版本的驱动、更新的用户空间工具以及寻求帮助的对象，请参考本文档末尾的链接。
.. 目录

   1. 绑定驱动安装

   2. 绑定驱动选项

   3. 配置绑定设备
   3.1	使用Sysconfig支持配置
   3.1.1		使用DHCP与Sysconfig
   3.1.2		使用Sysconfig配置多个绑定
   3.2	使用Initscripts支持配置
   3.2.1		使用DHCP与Initscripts
   3.2.2		使用Initscripts配置多个绑定
   3.3	手动使用Ifenslave配置绑定
   3.3.1		手动配置多个绑定
   3.4	通过Sysfs手动配置绑定
   3.5	使用Interfaces支持配置
   3.6	针对特殊情况覆盖配置
   3.7 使用更安全的方式配置LACP以支持802.3ad模式

   4. 查询绑定配置
   4.1	绑定配置
   4.2	网络配置

   5. 交换机配置

   6. 802.1q VLAN支持

   7. 链路监控
   7.1	ARP监控操作
   7.2	配置多个ARP目标
   7.3	MII监控操作

   8. 潜在的问题来源
   8.1	路由冒险
   8.2	以太网设备重命名
   8.3	Miimon极其缓慢或者无法检测到失败的链路

   9. SNMP代理

   10. 混杂模式

   11. 为高可用性配置绑定
   11.1	单交换机拓扑中的高可用性
   11.2	多交换机拓扑中的高可用性
   11.2.1		多交换机拓扑下的HA绑定模式选择
   11.2.2		多交换机拓扑下的HA链路监控

   12. 为最大吞吐量配置绑定
   12.1	单交换机拓扑下的最大吞吐量
   12.1.1		单交换机拓扑下的MT绑定模式选择
   12.1.2		单交换机拓扑下的MT链路监控
   12.2	多交换机拓扑下的最大吞吐量
   12.2.1		多交换机拓扑下的MT绑定模式选择
   12.2.2		多交换机拓扑下的MT链路监控

   13. 交换机行为问题
   13.1	链路建立和故障切换延迟
   13.2	重复的传入数据包

   14. 硬件特定考虑
   14.1	IBM BladeCenter

   15. 常见问题解答

   16. 资源与链接


1. 绑定驱动安装
==============================

大多数流行的发行版内核已经包含了作为模块的绑定驱动程序。如果您的发行版没有包含，或者您需要从源代码编译绑定（例如，配置并安装来自kernel.org的主要内核），您需要执行以下步骤：

1.1 配置并构建带有绑定的内核
-----------------------------------------------

当前版本的绑定驱动程序可以在最新内核源码（可以从http://kernel.org获取）的drivers/net/bonding子目录中找到。大多数自行构建的用户会希望使用来自kernel.org的最新内核。
使用"make menuconfig"（或"make xconfig"或"make config"）配置内核，然后在网络设备支持部分选择“绑定驱动程序支持”。建议您将驱动程序配置为模块，因为这是目前唯一向驱动程序传递参数或配置多个绑定设备的方法。
构建并安装新的内核和模块
1.2 绑定控制实用工具
---------------------------

建议通过iproute2（netlink）或sysfs来配置绑定，旧的ifenslave控制工具已过时
2. 绑定驱动选项
=========================

绑定驱动程序的选项作为参数在加载时传递给绑定模块，或者通过sysfs指定
模块选项可以作为命令行参数提供给 `insmod` 或 `modprobe` 命令，但通常指定在 ``/etc/modprobe.d/*.conf`` 配置文件中，或特定于发行版的配置文件中（其中一些在下一部分中有详细说明）。关于 sysfs 的绑定支持详情，请参阅下面的 "通过 Sysfs 手动配置绑定" 部分。
可用的绑定驱动程序参数如下。如果未指定参数，则使用默认值。在初次配置绑定时，建议在另一个窗口运行 "tail -f /var/log/messages" 来监视绑定驱动程序错误信息。
至关重要的是，必须指定 `miimon` 或 `arp_interval` 和 `arp_ip_target` 参数，否则在网络链路故障期间可能会发生严重的网络性能下降。极少有设备不支持 `miimon`，因此几乎没有任何理由不使用它。
对于具有文本值的选项，将接受文本名称或为了向后兼容性，接受选项值。例如，“mode=802.3ad”和“mode=4”设置相同的模式。
参数如下：

active_slave

	为支持它的模式（活动备份、平衡 ALB 和平衡 TLB）指定新的活动从属接口。可能的值是任何当前从属接口的名称，或者空字符串。如果给出了名称，该从属接口及其链接必须处于活动状态才能被选为新的活动从属接口。如果指定了空字符串，则清除当前活动从属接口，并自动选择一个新的活动从属接口。
请注意，此选项仅通过 sysfs 接口可用。不存在同名的模块参数。
此选项的正常值是当前活动从属接口的名称，或者如果没有活动从属接口或当前模式不使用活动从属接口，则为空字符串。
ad_actor_sys_prio

	在 AD 系统中，这指定了系统优先级。允许的范围是 1 到 65535。如果不指定值，默认采用 65535。
此参数仅在 802.3ad 模式下有效，并且可通过 SysFs 接口获得。
在 AD (802.3ad) 系统中，此参数指定了参与协议数据包交换（LACP 数据单元）的参与者（actor）的 MAC 地址。该值不能是多播地址。如果指定全零 MAC 地址，则绑定内部会使用绑定自身的 MAC 地址。虽然优选设置本地管理位（local-admin bit）对此 MAC 地址进行标记，但驱动程序并不强制执行这一点。如果没有给出此值，则系统默认使用主接口的 MAC 地址作为参与者的系统地址。
此参数仅在 802.3ad 模式下生效，并且可以通过 SysFs 接口访问。

`ad_select`

此选项指定了 802.3ad 聚合选择逻辑。可能的值及其效果如下：

- `stable` 或 `0`

  活动聚合器由最大的聚合带宽来选择。活动聚合器的重新选择仅当所有活动聚合器的从属接口都处于故障状态或活动聚合器没有任何从属接口时发生。这是默认值。

- `bandwidth` 或 `1`

  活动聚合器由最大的聚合带宽来选择。重新选择会在以下情况下发生：

    - 绑定中添加或移除一个从属接口
    - 任何从属接口的链路状态发生变化
    - 任何从属接口的 802.3ad 关联状态发生变化
    - 绑定的管理状态变为激活状态

- `count` 或 `2`

  活动聚合器由最多数量的端口（从属接口）来选择。重新选择的条件与 `bandwidth` 设置相同。

带宽和数量选择策略允许在活动聚合器部分失效的情况下实现 802.3ad 聚合的故障转移。这确保了始终保持最高可用性（无论是带宽还是端口数量）的聚合器处于活跃状态。
此选项是在绑定版本 3.4.0 中添加的。

`ad_user_port_key`

在 AD (802.3ad) 系统中，端口密钥（port-key）由三部分组成，如下面表格所示：

| 位数 | 用途 |
|------|------|
| 00   | 双工 |
| 01-05| 速度 |
| 06-15| 用户定义 |

此参数定义了端口密钥的高 10 位。这些值可以是从 0 到 1023 的任意值。如果没有给出此值，则系统默认为 0。
此参数仅在 802.3ad 模式下生效，并且可以通过 SysFs 接口访问。
`all_slaves_active`

指定是否应丢弃（0）或传递（1）在非活动端口上收到的重复帧。
通常，绑定会丢弃在非活动端口上收到的重复帧，这对大多数用户来说是理想的。但有时允许传递重复帧也是有用的。
默认值为0（丢弃在非活动端口上收到的重复帧）。

`arp_interval`

指定ARP链路监控频率（以毫秒为单位）。
ARP监控通过定期检查从属设备来工作，确定它们最近是否发送或接收了流量（具体标准取决于绑定模式和从属设备的状态）。通过针对`arp_ip_target`选项中指定的地址发出的ARP探测生成常规流量。
这种行为可以通过下面的`arp_validate`选项进行修改。
如果在与以太通道兼容的模式（模式0和2）中使用ARP监控，则应该将交换机配置为一种可以均匀分布所有链接上的数据包的模式。如果交换机被配置为以XOR方式分发数据包，那么来自ARP目标的所有回复都将在同一链接上接收，这可能会导致其他团队成员失败。不应将ARP监控与`miimon`一起使用。0值禁用ARP监控。默认值为0。

`arp_ip_target`

当`arp_interval`大于0时，指定要作为ARP监控对等方使用的IP地址。这些是用于确定到目标链接健康状况的ARP请求的目标。
请以`ddd.ddd.ddd.ddd`格式指定这些值。多个IP地址之间必须用逗号隔开。为了使ARP监控功能正常运行，至少必须给出一个IP地址。可以指定的最大目标数量为16个。默认值是没有IP地址。

`ns_ip6_target`

当`arp_interval`大于0时，指定要作为IPv6监控对等方使用的IPv6地址。这些是用于确定到目标链接健康状况的NS请求的目标。
指定这些值采用 ffff:ffff::ffff:ffff 的格式。多个 IPv6 地址之间需要用逗号分隔。为了使 NS/NA 监控功能正常工作，必须至少给出一个 IPv6 地址。可以指定的最大目标数量为 16 个。默认值是没有 IPv6 地址。
arp_validate

指定是否在支持 ARP 监控的任何模式中验证 ARP 探测和响应，或者对于链路监控目的是否过滤（忽略）非 ARP 流量。
可能的值包括：

    none 或 0

        不执行任何验证或过滤
    active 或 1

        仅对活动从属设备执行验证
    backup 或 2

        仅对备份从属设备执行验证
    all 或 3

        对所有从属设备执行验证
    filter 或 4

        对所有从属设备应用过滤。不执行任何验证
    filter_active 或 5

        对所有从属设备应用过滤，仅对活动从属设备执行验证
    filter_backup 或 6

        对所有从属设备应用过滤，仅对备份从属设备执行验证
验证：

启用验证会导致 ARP 监控检查传入的 ARP 请求和响应，并且只有在接收到适当的 ARP 流量时才认为从属设备处于活动状态。
对于活跃从设备，验证检查会确认ARP回复是由`arp_ip_target`生成的。由于备用从设备通常接收不到这些回复，因此对备用从设备执行的验证是基于通过活跃从设备发送出去的广播ARP请求。有可能某些交换机或网络配置会导致备用从设备接收不到ARP请求的情况；在这种情况下，必须禁用备用从设备的验证。

对备用从设备上的ARP请求进行验证主要是帮助绑定（bonding）机制判断在活跃从设备发生故障时哪些从设备更可能工作，但这并不能真正保证如果被选为下一个活跃从设备的话，该备用从设备就能正常工作。

验证在存在多个绑定主机同时向一个或多个通过共享交换机的目标发送ARP的情况下是有用的。如果交换机和目标之间的链路失败（但交换机本身并未失败），由多个绑定实例产生的探测流量会让标准ARP监视器误以为链路仍然可用。使用验证可以解决这个问题，因为ARP监视器只考虑与自身绑定实例相关的ARP请求和回复。

过滤：

启用过滤后，ARP监视器仅使用传入的ARP包来确定链路是否可用。非ARP包会被正常传递，但在确定从设备是否可用时不会被计入。
过滤操作是通过仅考虑收到的ARP包（无论源地址或目的地址）来确定从设备是否接收到用于链路可用性检测的流量。
过滤在网络配置中很有用，在这种配置中大量的第三方广播流量可能会让标准ARP监视器误以为链路仍然可用。使用过滤可以解决这个问题，因为只有ARP流量才会被考虑用于链路可用性的检测。
此选项是在绑定版本3.1.0中添加的。
`arp_all_targets`

指定为了使ARP监视器认为从设备处于可用状态，需要有多少个`arp_ip_targets`可达。
此选项仅影响启用了`arp_validation`的主动-备份模式下的从设备。
可能的值包括：

- `any` 或 `0`

    仅当任何一个`arp_ip_target`可达时，才认为从设备可用。

- `all` 或 `1`

    仅当所有`arp_ip_target`都可达时，才认为从设备可用。

`arp_missed_max`

指定在接口被ARP监视器标记为不可用之前，连续失败的`arp_interval`监控检查次数。
为了提供有序的故障转移语义，允许备用接口进行额外的一次监控检查（即，在被标记为失效之前必须失败 arp_missed_max + 1 次）。
默认值是 2，允许的范围是 1 - 255。
coupled_control

    指定在 802.3ad 模式下 LACP 状态机的 MUX 是否应该有独立的收集和分发状态。
这是通过实现 IEEE 802.1AX-2008 5.4.15 中规定的独立控制状态机，以及现有的耦合控制状态机来完成的。
默认值是 1。此设置不会将收集和分发状态分开，保持了耦合控制下的绑定状态。
downdelay

    指定在检测到链路故障后禁用从属设备前等待的时间（以毫秒为单位）。此选项仅对 miimon 链路监控有效。downdelay 的值应为 miimon 值的倍数；如果不是，它将向下舍入到最近的倍数值。默认值是 0。
fail_over_mac

    指定在主动-备用模式下是否应将所有从属设备设置为相同的 MAC 地址（传统行为），或者启用时，根据选定策略对绑定的 MAC 地址进行特殊处理。
可能的值包括：

    none 或 0

        此设置禁用 fail_over_mac，并导致绑定将主动-备用绑定的所有从属设备设置为同一 MAC 地址。这是默认设置。
active 或 1

        “active” fail_over_mac 策略表明绑定的 MAC 地址应始终与当前活动从属设备的 MAC 地址相同。不更改从属设备的 MAC 地址；相反，在故障转移期间更改绑定的 MAC 地址。
此策略适用于永远不能更改其 MAC 地址的设备，或拒绝带有自身源 MAC 的传入广播的设备（这会干扰 ARP 监控）。
此策略的缺点是网络上的每个设备都必须通过免费ARP进行更新，而传统的做法只需要更新交换机或一组交换机（这种更新通常针对所有流量而非仅限ARP流量，如果交换机通过监视传入流量来更新其表格的话）。如果免费ARP丢失，则可能会中断通信。

当此策略与mii监视器结合使用时，那些在实际能够发送和接收数据之前就声明链路已建立的设备特别容易丢失免费ARP，此时可能需要一个合适的updelay设置。

跟随后（Follow）：
“跟随”失败切换MAC地址策略导致绑定的MAC地址被正常选择（通常是添加到绑定的第一个从属接口的MAC地址）。
然而，在备份角色中的第二个及后续从属接口不会被设置为该MAC地址；从属接口在故障转移时刻被编程为绑定的MAC地址（而先前活跃的从属接口则接收新活跃从属接口的MAC地址）。
此策略对于多端口设备非常有用，这些设备在多个端口被配置为相同的MAC地址时可能会变得混乱或遭受性能损失。
默认策略是无，除非第一个从属接口无法更改其MAC地址，在这种情况下，默认选择活动策略。
只有当绑定中没有从属接口存在时，此选项才可通过sysfs进行修改。
此选项是在绑定版本3.2.0中添加的。“跟随”策略是在绑定版本3.3.0中添加的。

LACP主动模式：
此选项指定是否定期发送LACPDU帧。
关闭或0：
LACPDU帧的行为类似于“只在被询问时才回答”。
LACPDU 帧沿着已配置的链路定期发送。有关详细信息，请参阅 `lacp_rate`。
默认设置为开启。
`lacp_rate`

此选项指定了在 802.3ad 模式下请求我们的链路伙伴传输 LACPDU 数据包的速率。可能的值包括：

慢速或 0
请求伙伴每 30 秒传输一次 LACPDUs。

快速或 1
请求伙伴每 1 秒传输一次 LACPDUs。

默认值为慢速。
`max_bonds`

指定了为这个绑定驱动实例创建的绑定设备数量。例如，如果 `max_bonds` 的值为 3，并且绑定驱动尚未加载，则会创建 bond0、bond1 和 bond2。默认值为 1。指定值为 0 将加载绑定功能，但不会创建任何设备。
`miimon`

指定了 MII 链路监控频率（以毫秒为单位）。这决定了检查每个从属链路状态以检测链路故障的频率。值为零将禁用 MII 链路监控。100 是一个不错的起点值。下面的 `use_carrier` 选项会影响链路状态的确定方式。有关更多信息，请参阅高可用性部分。如果未设置 `arp_interval`，默认值为 100。
`min_links`

指定了必须处于活动状态的最小链路数，才能声明链路有效。这类似于思科 EtherChannel 的 `min-links` 特性。这允许设置成员端口中必须处于激活状态（链路上状态）的最小数量，在将绑定设备标记为激活之前。这对于确保在切换前有最低数量的低带宽链路处于活动状态的情况非常有用。此选项仅影响 802.3ad 模式。
默认值为 0。这将导致在存在活动聚合器时声明链路有效（对于 802.3ad 模式），而不论该聚合器中有多少可用链路。请注意，由于没有至少一条可用链路，聚合器不可能处于活动状态，因此将此选项设置为 0 或 1 具有完全相同的效果。
`mode`

指定了其中一种绑定策略。默认为 `balance-rr`（轮询）。可能的值包括：

`balance-rr` 或 0

轮询策略：按顺序从第一个可用的从属链路到最后一个发送数据包。此模式提供了负载均衡和容错能力。
### 主动备份或 1

- **主动备份策略：** 只有一个从设备处于活动状态。只有当活动的从设备出现故障时，另一个不同的从设备才会变为活动状态。该绑定的MAC地址仅在一个端口（网络适配器）上对外可见，以避免使交换机产生混淆。

在2.6.2版本或更高版本的绑定中，当在主动备份模式下发生故障切换时，绑定会在新激活的从设备上发出一个或多个免费ARP包。
- 对于绑定主接口和配置在其上的每个VLAN接口，都会发出一个免费ARP包，前提是该接口至少配置了一个IP地址。为VLAN接口发出的免费ARP包会被标记上相应的VLAN ID。

此模式提供了容错能力。下面记录的“主要”选项会影响此模式的行为。

### 平衡异或或 2

- **异或策略：** 根据选定的传输哈希策略进行传输。默认策略是一个简单的[(源MAC地址与目标MAC地址及包类型ID进行异或运算)取模以得到从设备数量]。可以通过下面描述的`xmit_hash_policy`选项选择其他传输策略。

此模式提供了负载均衡和容错能力。

### 广播或 3

- **广播策略：** 在所有从设备接口上发送所有数据。此模式提供了容错能力。

### 802.3ad 或 4

- **IEEE 802.3ad 动态链路聚合。** 创建共享相同速度和双工设置的聚合组。根据802.3ad规范利用活跃聚合器中的所有从设备。

对于传出流量的从设备选择是根据传输哈希策略进行的，可以通过下面描述的`xmit_hash_policy`选项从默认的简单异或策略更改。请注意，并非所有的传输策略都符合802.3ad标准，特别是在关于第43.2.4节中的包顺序混乱要求方面。不同的对等实现对于不符合标准的容忍度各不相同。

### 前提条件：

1. 在基础驱动程序中支持使用ethtool获取每个从设备的速度和双工设置。
2. 支持IEEE 802.3ad 动态链路聚合的交换机  
大多数交换机都需要某种类型的配置来启用802.3ad模式。

- `balance-tlb` 或者 `5`

  适应性传输负载均衡：这种通道绑定方式不需要特殊的交换机支持。  
  在 `tlb_dynamic_lb=1` 模式下，根据每个从设备（slave）当前的负载（相对于速度计算得出）来分配传出流量。  
  在 `tlb_dynamic_lb=0` 模式下，禁用基于当前负载的负载均衡，并仅使用哈希分布来分配负载。  
  接收的流量由当前的从设备处理；如果接收的从设备出现故障，则另一个从设备接管该故障从设备的MAC地址。

前提条件：

  - 基础驱动中支持使用ethtool获取每个从设备的速度。

- `balance-alb` 或者 `6`

  适应性负载均衡：包括 `balance-tlb` 的功能加上针对IPv4流量的接收负载均衡（RLB），并且不需要特殊交换机支持。接收负载均衡通过ARP协商实现。  
  绑定驱动会拦截本地系统发出的ARP响应，并将源硬件地址替换为绑定中的一个从设备的唯一硬件地址，从而使得不同的对等体使用不同的硬件地址来访问服务器。
接收由服务器创建的连接所带来的流量也是均衡的。当本地系统发送ARP请求时，绑定驱动程序会复制并保存来自ARP数据包中的对等方IP信息。当ARP回复从对等方到达时，其硬件地址被检索，并且绑定驱动程序向这个对等方发起ARP回复，将其分配给绑定中的某个从设备。使用ARP协商进行负载均衡的一个问题在于每次广播ARP请求时都会使用绑定的硬件地址。因此，对等方学习到的是绑定的硬件地址，接收流量的均衡会退化为当前的从设备。这通过向所有对等方发送更新（ARP回复），其中包含了它们各自分配的硬件地址来处理，从而使流量重新分布。当新的从设备加入绑定或者一个非活动的从设备被重新激活时，接收流量也会重新分布。接收负载按顺序（轮询方式）在绑定中速度最高的从设备组之间分配。

当链路重新连接或新从设备加入绑定时，通过向每个客户端发起具有选定MAC地址的ARP回复，接收流量会在绑定中的所有活动从设备之间重新分配。updelay参数（下文详细说明）必须设置为等于或大于交换机转发延迟的值，以确保发送给对等方的ARP回复不会被交换机阻止。

先决条件：

1. 基础驱动程序支持使用ethtool获取每个从设备的速度。
2. 基础驱动程序支持在设备打开时设置硬件地址。这是必需的，以便始终有一个从设备（curr_active_slave）使用绑定的硬件地址，同时绑定中的每个从设备都有唯一的硬件地址。如果curr_active_slave出现故障，则将其硬件地址与选择的新curr_active_slave进行交换。

num_grat_arp, num_unsol_na

指定在故障转移事件后要发出的对等方通知（免费ARP和未请求的IPv6邻居通告）的数量。一旦新从设备上的链路建立（可能立即），就会在绑定设备和每个VLAN子设备上发送对等方通知。如果数量大于1，则按照peer_notif_delay指定的速率重复此操作。
有效范围是0-255；默认值为1。这些选项仅影响主备模式。这些选项分别在绑定版本3.3.0和3.4.0中添加。
从Linux 3.0和绑定版本3.7.1开始，这些通知由ipv4和ipv6代码生成，重复次数不能独立设置。

packets_per_slave

指定在转向下一个从设备之前通过一个从设备传输的数据包数量。设置为0时则随机选择一个从设备。
有效范围是0-65535；默认值为1。此选项仅在balance-rr模式下生效。

peer_notif_delay

指定在故障转移事件后发出每个对等方通知（免费ARP和未请求的IPv6邻居通告）之间的延迟（以毫秒为单位）。
这段英文的中文翻译如下：

此延迟应当是MII链路监控间隔（`miimon`）的倍数。
有效范围是0-300000。默认值为0，这意味着与MII链路监控间隔的值相匹配。
`prio`
从设备优先级。数值越大表示优先级越高。
主从设备具有最高优先级。此选项同样遵循`primary_reselect`规则。
此选项只能通过netlink配置，并且仅在活动备份（1）、负载平衡tlb（5）和负载平衡alb（6）模式下有效。
有效值范围是一个有符号的32位整数。
默认值为0。
`primary`

一个字符串（如eth0、eth2等），用于指定哪个从设备为主设备。当该设备可用时，它将始终作为活动从设备。只有当主设备离线时才会使用其他备选设备。当某个从设备比其他设备更受青睐时（例如，当某个从设备具有更高的吞吐量时）这很有用。
`primary`选项仅在活动备份（1）、负载平衡tlb（5）和负载平衡alb（6）模式下有效。
`primary_reselect`

指定了主从设备重新选择策略。这影响了在活动从设备出现故障或主从设备恢复时如何选择主从设备成为活动从设备。此选项设计用于防止主从设备与其他从设备之间频繁切换。可能的值包括：

- `always` 或 0（默认）

主从设备只要恢复连接就会成为活动从设备。
更好的或1

主从设备在恢复时变为活动从设备，如果其速度和双工模式优于当前活动从设备的速度和双工模式。

失败或2

仅当当前活动从设备发生故障且主从设备已启动时，主从设备才变为活动从设备。

在以下两种情况下忽略`primary_reselect`设置：

- 如果没有从设备处于活动状态，则首先恢复的从设备将被设为活动从设备。
- 当最初被设为从设备时，主从设备总是会被设为活动从设备。
通过sysfs更改`primary_reselect`策略会立即根据新策略选择最佳的活动从设备。这可能会或可能不会导致活动从设备的改变，具体取决于实际情况。
此选项是在绑定版本3.6.0中添加的。
tlb_dynamic_lb

指定是否在tlb或alb模式下启用流的动态重排。该值对其他任何模式均无影响。
tlb模式的默认行为是基于该间隔内的负载在从设备间重新分配活跃流。这样做可以提供良好的负载均衡特性，但也可能导致数据包顺序混乱。如果顺序问题是一个关注点，可以通过这个变量来禁用流的重排，并依赖哈希分布提供的纯负载均衡。
可以使用`xmit-hash-policy`来为设置选择合适的哈希算法。
可以通过sysfs条目来针对每个绑定设备更改设置，初始值来源于模块参数。只有在绑定设备处于关闭状态时才允许更改sysfs条目。
默认值为 "1"，这会启用流量洗牌功能；而值 "0" 则禁用该功能。此选项是在绑定驱动程序 3.7.1 版本中添加的。

`updelay`

指定在检测到链路恢复后重新启用从属接口前等待的时间（以毫秒为单位）。此选项仅对 `miimon` 链路监控器有效。`updelay` 的值应是 `miimon` 值的倍数；如果不是，则会被向下取整到最接近的倍数值。默认值为 0。

`use_carrier`

指定 `miimon` 是否应该使用 MII 或 ETHTOOL 输入输出控制命令（ioctl）而非 `netif_carrier_ok()` 来确定链路状态。MII 或 ETHTOOL 的 ioctl 方法效率较低，并且在内核中使用了已废弃的调用序列。`netif_carrier_ok()` 依赖于设备驱动程序通过 `netif_carrier_on/off` 来维护其状态；目前，大多数但并非所有设备驱动程序都支持这一特性。
如果绑定模块错误地认为链路处于开启状态时实际上不应该如此，可能是因为网络设备驱动程序不支持 `netif_carrier_on/off`。对于 `netif_carrier` 的默认状态是“链路开启”，因此如果驱动程序不支持 `netif_carrier`，则会看起来链路始终处于开启状态。在这种情况下，将 `use_carrier` 设置为 0 可使绑定模块回退到使用 MII/ETHTOOL ioctl 方法来确定链路状态。
值 1 启用 `netif_carrier_ok()` 的使用，值 0 将使用已废弃的 MII/ETHTOOL ioctl 方法。默认值为 1。

`xmit_hash_policy`

选择在 balance-xor、802.3ad 和 tlb 模式下用于从属接口选择的发送哈希策略。可能的值包括：

`layer2`

使用硬件 MAC 地址和数据包类型 ID 字段的异或运算生成哈希值。公式如下：

哈希 = 源 MAC[5] 异或 目标 MAC[5] 异或 数据包类型 ID  
从属编号 = 哈希值模从属总数

此算法会将发往特定网络对等方的所有流量置于同一从属接口上。
此算法符合 802.3ad 标准。

`layer2+3`

此策略结合了第 2 层和第 3 层协议信息来生成哈希值。
使用硬件 MAC 地址和 IP 地址的异或运算生成哈希值。公式如下：

哈希 = 源 MAC[5] 异或 目标 MAC[5] 异或 数据包类型 ID  
哈希 = 哈希 异或 源 IP 异或 目标 IP  
哈希 = 哈希 异或 (哈希右移 16 位)  
哈希 = 哈希 异或 (哈希右移 8 位)  
然后将哈希值减至从属总数的模数

如果协议是 IPv6，则首先使用 `ipv6_addr_hash` 对源地址和目标地址进行哈希处理。
此算法会将发往特定网络对等方的所有流量置于同一从属接口上。对于非 IP 流量，公式与第 2 层发送哈希策略相同。
此策略旨在提供比仅使用第二层更为均衡的流量分布，特别是在需要通过第三层网关设备才能到达大多数目的地的环境中。

此算法符合802.3ad标准
第三层+第四层

此策略在可用的情况下利用更高层协议信息来生成哈希值。这使得到特定网络对等方的流量可以跨越多个链路，尽管单个连接不会跨越多个链路。
对于未分片的TCP和UDP数据包，哈希计算公式为：

    哈希值 = 源端口, 目的端口（如头部所示）
    哈希值 = 哈希值 XOR 源IP XOR 目的IP
    哈希值 = 哈希值 XOR (哈希值右移16位)
    哈希值 = 哈希值 XOR (哈希值右移8位)
    哈希值 = 哈希值右移1位
    然后将哈希值对从属链路数量取模
如果协议是IPv6，则首先使用ipv6_addr_hash函数对源地址和目的地址进行哈希处理。
对于分片的TCP或UDP数据包以及所有其他IPv4和IPv6协议流量，会省略源端口和目的端口信息。对于非IP流量，其公式与第二层传输哈希策略相同。
此算法不符合完整的802.3ad标准。一个同时包含分片和未分片数据包的单一TCP或UDP对话可能会看到数据包被分配到两个接口上。这可能导致数据包乱序交付。大多数流量类型不会遇到这种情况，因为TCP很少分片流量，并且大多数UDP流量不涉及长时间的对话。其他实现的802.3ad可能能容忍或者不能容忍这种不符合标准的情况。
封装第二层+第三层

此策略使用的公式与第二层+第三层相同，但它依赖于skb_flow_dissect来获取头部字段，这可能导致使用内部头部（如果使用了封装协议的话）。例如，这将提高隧道用户的性能，因为数据包将根据封装的流进行分配。
封装第三层+第四层

此策略使用的公式与第三层+第四层相同，但它依赖于skb_flow_dissect来获取头部字段，这可能导致使用内部头部（如果使用了封装协议的话）。例如，这将提高隧道用户的性能，因为数据包将根据封装的流进行分配。
VLAN+源MAC

此策略使用非常基础的VLAN ID和源MAC哈希来按VLAN均衡负载，并在一条链路失败时进行故障转移。预期的应用场景是在一个由多个虚拟机共享的绑定中，这些虚拟机都配置了自己的VLAN，从而可以在没有LACP功能的交换硬件的情况下实现类似LACP的功能。
哈希计算的公式很简单：

    hash = (VLAN ID) XOR (源MAC厂商部分) XOR (源MAC设备部分)

默认值是layer2。这个选项是在bonding版本2.6.3中添加的。在更早版本的bonding中，这个参数不存在，并且layer2策略是唯一的策略。layer2+3值是在bonding版本3.2.2中添加的。
resend_igmp

指定了在发生故障转移后要发出的IGMP成员报告的数量。故障转移后会立即发出一个成员报告，随后的报文则会在每个200毫秒的时间间隔内发送。
有效范围是0 - 255；默认值为1。设置为0将阻止在故障转移事件响应时发出IGMP成员报告。
此选项对于balance-rr（0）、active-backup（1）、balance-tlb（5）和balance-alb（6）这些bonding模式非常有用，在这些模式下，故障转移可能会使IGMP流量从一个子接口切换到另一个。因此，需要重新发出IGMP报告以使交换机转发经过新选择的子接口的入站IGMP流量。
此选项是在bonding版本3.7.0中添加的。
lp_interval

指定了bonding驱动向每个子接口的对等交换机发送学习报文之间的秒数间隔。
有效范围是1 - 0x7fffffff；默认值为1。此选项仅在balance-tlb和balance-alb模式中有作用。
3. 配置Bonding设备
======================

您可以使用发行版的网络初始化脚本、iproute2或sysfs接口手动配置bonding。发行版通常使用以下三种包之一来处理网络初始化脚本：initscripts、sysconfig或interfaces。
这些包的较新版本支持bonding，而旧版本则不支持。
我们将首先描述使用具有完整或部分bonding支持的initscripts、sysconfig和interfaces版本来配置bonding的选项，然后提供在没有网络初始化脚本支持的情况下启用bonding的信息（即，initscripts或sysconfig的旧版本）。
如果你不确定你的发行版使用的是 `sysconfig`、`initscripts` 还是 `interfaces`，或者不知道它是否足够新，不用担心。确定这一点相当直接。

首先，在 `/etc/network` 目录中查找一个名为 `interfaces` 的文件。
如果此文件存在于你的系统中，则你的系统使用 `interfaces`。请参阅
[支持 interfaces 的配置](#)。

否则，运行以下命令：

	$ rpm -qf /sbin/ifup

它会返回以 “`initscripts`” 或 “`sysconfig`” 开头的一行文本，后面跟着一些数字。这是提供网络初始化脚本的软件包。
接下来，要确定你的安装是否支持绑定（bonding），运行以下命令：

    $ grep ifenslave /sbin/ifup

如果这返回任何匹配项，则表明你的 `initscripts` 或 `sysconfig` 支持绑定（bonding）。

### 3.1 支持 sysconfig 的配置
------------------------

本节适用于使用支持绑定版本的 `sysconfig` 的发行版，例如 SuSE Linux Enterprise Server 9。
SuSE SLES 9 的网络配置系统确实支持绑定，但是到目前为止，YaST 系统配置前端尚未提供用于处理绑定设备的任何方式。
不过可以手动管理绑定设备，具体步骤如下：
首先，如果它们尚未被配置，配置从属设备。在 SLES 9 上，最简单的方法是运行 yast2 sysconfig 配置工具。目标是为每个从属设备创建一个 `ifcfg-id` 文件。最简单的方法是将设备配置为使用 DHCP（这只是为了创建 `ifcfg-id` 文件；下面会提到关于 DHCP 的一些问题）。每个设备的配置文件名称格式如下：

    ifcfg-id-xx:xx:xx:xx:xx:xx

其中 "xx" 部分会用设备的永久 MAC 地址中的数字替换。
一旦创建了 ifcfg-id-xx:xx:xx:xx:xx:xx 文件集，就需要编辑从设备（MAC 地址对应于从设备的地址）的配置文件。在编辑之前，文件将包含多行内容，看起来大致如下：

	BOOTPROTO='dhcp'
	STARTMODE='on'
	USERCTL='no'
	UNIQUE='XNzu.WeZGOGF+4wE'
	_nm_name='bus-pci-0001:61:01.0'

将 BOOTPROTO 和 STARTMODE 行更改为以下内容：

	BOOTPROTO='none'
	STARTMODE='off'

不要更改 UNIQUE 或 _nm_name 行。删除其他任何行（如 USERCTL 等）。
一旦修改了 ifcfg-id-xx:xx:xx:xx:xx:xx 文件，接下来就要创建绑定设备本身的配置文件。此文件名为 ifcfg-bondX，其中 X 是要创建的绑定设备编号，从 0 开始。第一个这样的文件是 ifcfg-bond0，第二个是 ifcfg-bond1，依此类推。sysconfig 网络配置系统能够正确启动多个绑定实例。

ifcfg-bondX 文件的内容如下：

	BOOTPROTO="static"
	BROADCAST="10.0.2.255"
	IPADDR="10.0.2.10"
	NETMASK="255.255.0.0"
	NETWORK="10.0.2.0"
	REMOTE_IPADDR=""
	STARTMODE="onboot"
	BONDING_MASTER="yes"
	BONDING_MODULE_OPTS="mode=active-backup miimon=100"
	BONDING_SLAVE0="eth0"
	BONDING_SLAVE1="bus-pci-0000:06:08.1"

将示例中的 BROADCAST、IPADDR、NETMASK 和 NETWORK 值替换为您网络中相应的值。

STARTMODE 指定了何时将设备上线，可能的值为：

	======== ======================================================
	onboot	 设备在启动时开始工作。如果您不确定，这可能是您想要的选择
manual	 只有手动调用 ifup 时设备才开始工作。如果出于某种原因您不希望绑定设备在启动时自动开始工作，可以将其配置为此模式
hotplug  设备由热插拔事件启动。这对于绑定设备不是一个有效的选择
off 或 ignore 设备配置被忽略
	======== ======================================================

BONDING_MASTER='yes' 这一行表明该设备是一个绑定主设备。唯一有用的值是 "yes"。

BONDING_MODULE_OPTS 的内容提供给此设备的绑定模块实例。在这里指定绑定模式、链路监控等选项。不要包括 max_bonds 绑定参数；如果您有多个绑定设备，这会混淆配置系统。
最后，为每个从设备提供一个 `BONDING_SLAVEn="从设备"`。其中的 "n" 是递增的值，对于每个从设备都不同。"从设备" 可以是接口名称（例如，“eth0”），也可以是网络设备的设备标识符。接口名称更容易找到，但 ethN 的名称在启动时可能会改变，例如，如果序列中的早期设备出现故障。设备标识符（如上面示例中的 bus-pci-0000:06:08.1）指定了物理网络设备，并且不会改变，除非设备的总线位置发生变化（例如，它从一个 PCI 插槽移动到另一个）。上面的例子为了演示目的使用了每种类型的一个；大多数配置会选择一种用于所有从设备。

当所有配置文件都被修改或创建后，必须重新启动网络服务才能使配置更改生效。这可以通过以下命令完成：

	# /etc/init.d/network restart

请注意，网络控制脚本（/sbin/ifdown）会在网络关闭处理过程中卸载绑定模块，因此如果模块参数已更改，则不需要手动移除模块。

此外，在撰写本文时，YaST/YaST2 不会管理绑定设备（它们不会在其网络设备列表中显示绑定接口）。需要手动编辑配置文件来更改绑定配置。

有关一般选项和 ifcfg 文件格式的详细信息，可以在示例 ifcfg 模板文件中找到：

	/etc/sysconfig/network/ifcfg.template

请注意，模板没有记录上述各种 ``BONDING_*`` 设置，但它描述了许多其他选项。

### 3.1.1 使用 Sysconfig 配置 DHCP

在 Sysconfig 下，将设备配置为 BOOTPROTO='dhcp' 将使其通过 DHCP 查询其 IP 地址信息。在撰写本文时，这对绑定设备不起作用；脚本尝试在添加任何从设备之前获取设备地址。没有活动的从设备，DHCP 请求就不会发送到网络。

### 3.1.2 使用 Sysconfig 配置多个绑定

Sysconfig 网络初始化系统能够处理多个绑定设备。只需要为每个绑定实例有一个适当配置的 ifcfg-bondX 文件（如上所述）。不要向任何绑定实例指定 "max_bonds" 参数，因为这会使 Sysconfig 混淆。如果你需要具有相同参数的多个绑定设备，请创建多个 ifcfg-bondX 文件。

由于 Sysconfig 脚本在 ifcfg-bondX 文件中提供了绑定模块选项，因此无需将这些选项添加到系统的 ``/etc/modules.d/*.conf`` 配置文件中。

### 3.2 使用支持 Initscripts 的配置

本节适用于使用最新版本的 initscripts 并支持绑定的发行版，例如 Red Hat Enterprise Linux 3 或更高版本、Fedora 等。在这些系统上，网络初始化脚本了解绑定，并可以配置为控制绑定设备。请注意，旧版本的 initscripts 包对绑定的支持较低；适用的地方会进行说明。

这些发行版不会自动加载网络适配器驱动程序，除非 ethX 设备被配置了 IP 地址。

由于这一限制，用户必须手动为所有将成为 bondX 链路成员的物理适配器配置网络脚本文件。网络脚本文件位于目录：

/etc/sysconfig/network-scripts

文件名必须以 "ifcfg-eth" 开头，并以适配器的物理编号结尾。例如，eth0 的脚本名为 /etc/sysconfig/network-scripts/ifcfg-eth0。
将以下文本放入文件中：

	DEVICE=eth0
	USERCTL=no
	ONBOOT=yes
	MASTER=bond0
	SLAVE=yes
	BOOTPROTO=none

`DEVICE=`行对于每个ethX设备都不同，并且必须与文件名对应，例如，ifcfg-eth1必须有`DEVICE=eth1`。`MASTER=`的设置也将取决于您为绑定选择的最终绑定接口名称。如同其他网络设备一样，这些通常从0开始，并为每个设备递增一个数字，即第一个绑定实例是bond0，第二个是bond1，依此类推。
接下来，创建一个绑定网络脚本。此脚本的文件名为`/etc/sysconfig/network-scripts/ifcfg-bondX`，其中X是绑定的编号。对于bond0，文件名为"ifcfg-bond0"，对于bond1，文件名为"ifcfg-bond1"，依此类推。在该文件中，放置以下文本：

	DEVICE=bond0
	IPADDR=192.168.1.1
	NETMASK=255.255.255.0
	NETWORK=192.168.1.0
	BROADCAST=192.168.1.255
	ONBOOT=yes
	BOOTPROTO=none
	USERCTL=no

确保更改特定于网络配置的行（IPADDR、NETMASK、NETWORK和BROADCAST），以匹配您的网络配置。
对于initscripts的较新版本，例如Fedora 7（或更高版本）和Red Hat Enterprise Linux 5（或更高版本）中包含的版本，可以并且实际上更优选地在ifcfg-bond0文件中指定绑定选项，例如如下格式的行：

  BONDING_OPTS="mode=active-backup arp_interval=60 arp_ip_target=192.168.1.254"

将使用指定的选项配置绑定。在`BONDING_OPTS`中指定的选项与绑定模块参数相同，除了在使用版本低于8.57（Fedora 8）和8.45.19（Red Hat Enterprise Linux 5.2）的initscripts版本时arp_ip_target字段。当使用较旧版本时，每个目标应作为单独的选项包含，并且前面应加上'+'来表示它应该被添加到查询的目标列表中，例如：

    arp_ip_target=+192.168.1.1 arp_ip_target=+192.168.1.2

是用于指定多个目标的正确语法。当通过`BONDING_OPTS`指定选项时，不需要编辑`/etc/modprobe.d/*.conf`。
对于不支持`BONDING_OPTS`的甚至更旧版本的initscripts，需要根据您的发行版编辑`/etc/modprobe.d/*.conf`，以便在启动bond0接口时加载绑定模块并选择其选项。在`/etc/modprobe.d/*.conf`中的以下行将加载绑定模块，并选择其选项：

	alias bond0 bonding
	options bond0 mode=balance-alb miimon=100

用适用于您配置的适当选项集替换示例参数。
最后，以root身份运行`/etc/rc.d/init.d/network restart`。这将重新启动网络子系统，现在您的绑定链接应该已经启动并运行。
3.2.1 使用initscripts与DHCP
---------------------------------

initscripts的较新版本（据报道Fedora Core 3和Red Hat Enterprise Linux 4或更高版本提供的版本有效）支持通过DHCP为绑定设备分配IP信息。
要为DHCP配置绑定，请按照上述方式配置，只是将“BOOTPROTO=none”替换为“BOOTPROTO=dhcp”，并添加一行“TYPE=Bonding”。请注意，TYPE值区分大小写。
3.2.2 使用initscripts配置多个绑定
-------------------------------------------------

Fedora 7和Red Hat Enterprise Linux 5中包含的initscripts包通过简单地在ifcfg-bondX中指定适当的`BONDING_OPTS=`来支持多个绑定接口，其中X是绑定的编号。此支持要求内核具有sysfs支持，并且绑定驱动程序版本为3.0.0或更高版本。其他配置可能不支持此方法来指定多个绑定接口；对于这些情况，请参阅下面的“手动配置多个绑定”部分。
3.3 使用iproute2手动配置绑定
-----------------------------------------------

本节适用于那些网络初始化脚本（sysconfig或initscripts包）没有具体了解绑定特性的发行版。一个这样的发行版是SuSE Linux Enterprise Server 8。
这些系统的通用方法是将绑定模块参数放入 `/etc/modprobe.d/` 目录下的配置文件中（根据已安装的发行版适当设置），然后在系统的全局初始化脚本中添加 `modprobe` 和/或 `ip link` 命令。全局初始化脚本的名称有所不同；对于 sysconfig，它是 `/etc/init.d/boot.local`，而对于 initscripts，则是 `/etc/rc.d/rc.local`。例如，如果您希望创建两个 e100 设备（假定为 eth0 和 eth1）的简单绑定，并使其在重启后仍然生效，则编辑相应的文件（`/etc/init.d/boot.local` 或 `/etc/rc.d/rc.local`），并添加以下内容：

```bash
modprobe bonding mode=balance-alb miimon=100
modprobe e100
ifconfig bond0 192.168.1.1 netmask 255.255.255.0 up
ip link set eth0 master bond0
ip link set eth1 master bond0
```

将示例中的绑定模块参数和 bond0 网络配置（如 IP 地址、子网掩码等）替换为您配置中适当的值。
不幸的是，这种方法无法为绑定设备上的 `ifup` 和 `ifdown` 脚本提供支持。为了重新加载绑定配置，需要运行初始化脚本，例如：

```bash
# /etc/init.d/boot.local
```

或者

```bash
# /etc/rc.d/rc.local
```

在这种情况下，可能希望创建一个单独的脚本来仅初始化绑定配置，然后从 `boot.local` 中调用这个单独的脚本。这允许启用绑定而无需重新运行整个全局初始化脚本。
要关闭绑定设备，首先需要将绑定设备本身标记为关闭状态，然后卸载相应的设备驱动程序模块。对于上面的例子，您可以执行以下操作：

```bash
# ifconfig bond0 down
# rmmod bonding
# rmmod e100
```

同样，出于方便考虑，可能希望创建一个包含这些命令的脚本。

### 3.3.1 手动配置多个绑定

#### -------------------------

本节包含有关为那些网络初始化脚本不支持配置多个绑定的系统手动配置具有不同选项的多个绑定设备的信息。
如果您需要多个绑定设备，但所有设备都使用相同的选项，您可能希望使用文档中提到的 "max_bonds" 模块参数。

为了创建具有不同选项的多个绑定设备，最好使用 sysfs 导出的绑定参数，如下文所述。
对于没有 sysfs 支持的绑定版本，提供具有不同选项的多个绑定实例的唯一方法是多次加载绑定驱动程序。请注意，当前版本的 sysconfig 网络初始化脚本自动处理这种情况；如果您的发行版使用这些脚本，则无需采取特殊行动。如果您不确定自己的网络初始化脚本，请参阅上面的“配置绑定设备”部分。
为了加载模块的多个实例，必须为每个实例指定不同的名称（模块加载系统要求每个加载的模块，即使同一模块的多个实例，也必须具有唯一的名称）。这可以通过在 `/etc/modprobe.d/*.conf` 中提供多组绑定选项来实现，例如：

```bash
alias bond0 bonding
options bond0 -o bond0 mode=balance-rr miimon=100

alias bond1 bonding
options bond1 -o bond1 mode=balance-alb miimon=50
```

这将加载绑定模块两次。第一个实例名为 "bond0"，以 round-robin 平衡模式创建 bond0 设备，miimon 设置为 100。第二个实例名为 "bond1"，以负载平衡 ALB 模式创建 bond1 设备，miimon 设置为 50。
在某些情况下（通常是在较旧的发行版中），上述方法不起作用，第二个绑定实例从未看到其选项。在这种情况下，可以将第二条选项行替换为以下内容：

```bash
install bond1 /sbin/modprobe --ignore-install bonding -o bond1 mode=balance-alb miimon=50
```

这可以重复任意次数，每次后续实例用新的且唯一的名称替换 bond1。
已经观察到，一些由红帽提供的内核无法在加载时重命名模块（即"-o bond1"这部分）。尝试将此选项传递给modprobe会产生“操作不允许”的错误。此问题已在某些Fedora Core内核上被报告，并且在RHEL 4中也已出现。对于表现出该问题的内核，将不可能配置具有不同参数的多个绑定，因为这些内核较旧，而且也不支持sysfs。

3.4 通过Sysfs手动配置绑定
------------------------------------------

从版本3.0.0开始，可以使用sysfs接口来配置通道绑定。此接口允许在不卸载模块的情况下动态地配置系统中的所有绑定，并且还允许在运行时添加和删除绑定。尽管ifenslave不再是必需的，但它仍然得到支持。

使用sysfs接口使您可以在不重新加载模块的情况下使用具有不同配置的多个绑定。此外，即使绑定功能被编译入内核，它也允许您使用多个配置不同的绑定。

要以这种方式配置绑定，您必须挂载了sysfs文件系统。本文档中的示例假定您正在使用sysfs的标准挂载点，例如/sys。如果您的sysfs文件系统挂载在其他位置，则需要相应地调整示例路径。

创建和销毁绑定
----------------------
要添加一个新的绑定foo：

	# echo +foo > /sys/class/net/bonding_masters

要移除现有的绑定bar：

	# echo -bar > /sys/class/net/bonding_masters

要显示所有现有绑定：

	# cat /sys/class/net/bonding_masters

.. note:: 

   由于sysfs文件的大小限制为4KB，如果您有数百个以上的绑定，这个列表可能会被截断。在正常运行条件下，这种情况不太可能发生。

添加和移除从属接口
-----------------------
可以通过文件/sys/class/net/<bond>/bonding/slaves将接口绑定到绑定中。此文件的语义与bonding_masters文件相同。

要将接口eth0绑定到绑定bond0：

	# ifconfig bond0 up
	# echo +eth0 > /sys/class/net/bond0/bonding/slaves

要解除eth0作为bond0的从属接口：

	# echo -eth0 > /sys/class/net/bond0/bonding/slaves

当接口被绑定到一个绑定时，会在sysfs文件系统中在这两者之间创建符号链接。在这种情况下，您会得到/sys/class/net/bond0/slave_eth0指向/sys/class/net/eth0，以及/sys/class/net/eth0/master指向/sys/class/net/bond0。

这意味着您可以快速判断一个接口是否已被绑定，方法是查看master符号链接。因此：
# echo -eth0 > /sys/class/net/eth0/master/bonding/slaves
将解除eth0与任何绑定的关系，无论绑定接口的名称是什么。
更改网卡绑定的配置
-------------------------------
可以通过操作位于`/sys/class/net/<绑定名称>/bonding`下的文件来单独配置每个绑定。

这些文件的名称直接对应于本文件其他地方描述的命令行参数，除了`arp_ip_target`外，它们接受相同的值。要查看当前设置，只需使用`cat`命令读取相应的文件。
下面给出一些示例；对于每个参数的具体使用指导，请参阅本文档的相应部分。
为了将`bond0`配置为`balance-alb`模式：

	# ifconfig bond0 down
	# echo 6 > /sys/class/net/bond0/bonding/mode
	- 或者 -
	# echo balance-alb > /sys/class/net/bond0/bonding/mode

.. 注意::

   在更改模式之前，绑定接口必须处于关闭状态。
为了在`bond0`上启用MII监控，并设置间隔时间为1秒：

	# echo 1000 > /sys/class/net/bond0/bonding/miimon

.. 注意::

   如果启用了ARP监控，在启用MII监控时，ARP监控会被禁用，反之亦然。
为了添加ARP目标：

	# echo +192.168.0.100 > /sys/class/net/bond0/bonding/arp_ip_target
	# echo +192.168.0.101 > /sys/class/net/bond0/bonding/arp_ip_target

.. 注意::

   最多可以指定16个目标地址。
为了移除一个ARP目标：

	# echo -192.168.0.100 > /sys/class/net/bond0/bonding/arp_ip_target

为了配置学习包发送的间隔时间：

	# echo 12 > /sys/class/net/bond0/bonding/lp_interval

.. 注意::

   `lp_interval`是绑定驱动向每个从属交换机的对等端口发送学习包之间的秒数。默认间隔是1秒。
示例配置
---------------------
我们从第3.3节中展示的相同示例开始，使用sysfs执行，并且不使用ifenslave。
为了创建两个e100设备（假设为eth0和eth1）的简单绑定，并使其在重启后依然存在，编辑适当的文件（例如`/etc/init.d/boot.local`或`/etc/rc.d/rc.local`），并添加以下内容：

	modprobe bonding
	modprobe e100
	echo balance-alb > /sys/class/net/bond0/bonding/mode
	ifconfig bond0 192.168.1.1 netmask 255.255.255.0 up
	echo 100 > /sys/class/net/bond0/bonding/miimon
	echo +eth0 > /sys/class/net/bond0/bonding/slaves
	echo +eth1 > /sys/class/net/bond0/bonding/slaves

为了添加第二个绑定，包含两个e1000接口，并采用`active-backup`模式，使用ARP监控，可以在你的启动脚本中添加以下行：

	modprobe e1000
	echo +bond1 > /sys/class/net/bonding_masters
	echo active-backup > /sys/class/net/bond1/bonding/mode
	ifconfig bond1 192.168.2.1 netmask 255.255.255.0 up
	echo +192.168.2.100 > /sys/class/net/bond1/bonding/arp_ip_target
	echo 2000 > /sys/class/net/bond1/bonding/arp_interval
	echo +eth2 > /sys/class/net/bond1/bonding/slaves
	echo +eth3 > /sys/class/net/bond1/bonding/slaves

3.5 支持接口的配置
-----------------------------------------

本节适用于使用`/etc/network/interfaces`文件来描述网络接口配置的发行版，尤其是Debian及其衍生版本。
Debian上的ifup和ifdown命令默认不支持绑定。应该安装ifenslave-2.6包以提供绑定支持。安装后，此包将为`/etc/network/interfaces`文件提供`bond-*`选项。
需要注意的是，ifenslave-2.6包会加载绑定模块，并在适当的时候使用ifenslave命令。
示例配置
----------------------

在 `/etc/network/interfaces` 中，以下段落将配置 bond0，在主动备份（active-backup）模式下，并将 eth0 和 eth1 作为从属接口：

```plaintext
auto bond0
iface bond0 inet dhcp
    bond-slaves eth0 eth1
    bond-mode active-backup
    bond-miimon 100
    bond-primary eth0 eth1
```

如果上述配置不起作用，那么你的系统可能使用了 upstart 来启动系统。这在最近的 Ubuntu 版本中尤为常见。在 `/etc/network/interfaces` 中的以下段落将在这些系统上产生相同的效果：

```plaintext
auto bond0
iface bond0 inet dhcp
    bond-slaves none
    bond-mode active-backup
    bond-miimon 100

auto eth0
iface eth0 inet manual
    bond-master bond0
    bond-primary eth0 eth1

auto eth1
iface eth1 inet manual
    bond-master bond0
    bond-primary eth0 eth1
```

对于 `/etc/network/interfaces` 中支持的所有 `bond-*` 选项和一些针对你特定发行版的更高级示例，请参阅 `/usr/share/doc/ifenslave-2.6` 中的文件。

3.6 在特殊情况下覆盖配置
----------------------------------------------

在使用绑定驱动程序时，通常由绑定驱动程序选择传输帧的物理端口，这对用户或系统管理员来说通常是不相关的。输出端口仅仅是根据所选绑定模式的策略来选择的。然而，有时需要将某些类型的流量导向某些物理接口以实现稍微复杂一点的策略。例如，要通过一个绑定接口访问 Web 服务器，其中 eth0 连接到私有网络，而 eth1 通过公共网络连接，可能希望偏向于首先通过 eth0 发送此类流量，仅将 eth1 作为备选，而所有其他流量可以安全地通过任一接口发送。这样的配置可以通过 Linux 内置的流量控制工具来实现。

默认情况下，绑定驱动程序具有多队列感知功能，并且当驱动程序初始化时创建了 16 个队列（详情见 `Documentation/networking/multiqueue.rst`）。如果需要更多或更少的队列，可以使用模块参数 `tx_queues` 来更改这个值。没有可用的 sysfs 参数，因为分配是在模块初始化时完成的。

文件 `/proc/net/bonding/bondX` 的输出已经改变，现在为每个从属接口打印出队列 ID：

```plaintext
Bonding Mode: fault-tolerance (active-backup)
Primary Slave: None
Currently Active Slave: eth0
MII Status: up
MII Polling Interval (ms): 0
Up Delay (ms): 0
Down Delay (ms): 0

Slave Interface: eth0
MII Status: up
Link Failure Count: 0
Permanent HW addr: 00:1a:a0:12:8f:cb
Slave queue ID: 0

Slave Interface: eth1
MII Status: up
Link Failure Count: 0
Permanent HW addr: 00:1a:a0:12:8f:cc
Slave queue ID: 2
```

可以从属接口设置队列 ID，命令如下：

```plaintext
# echo "eth1:2" > /sys/class/net/bond0/bonding/queue_id
```

任何需要设置队列 ID 的接口都应该像上面那样进行多次调用，直到为所有接口设置了正确的优先级。在允许通过 initscripts 配置的发行版上，可以在 `BONDING_OPTS` 中添加多个 `queue_id` 参数来设置所有所需的从属队列。

这些队列 ID 可以与 `tc` 工具结合使用来配置多队列 qdisc 和过滤器，以便对某些流量进行偏置，使其通过某些从属设备发送。例如，假设我们想要在上述配置中强制所有发往 192.168.1.100 的流量使用 bond 中的 eth1 作为输出设备。以下命令可以实现这一点：

```plaintext
# tc qdisc add dev bond0 handle 1 root multiq

# tc filter add dev bond0 protocol ip parent 1: prio 1 u32 match ip \
    dst 192.168.1.100 action skbedit queue_mapping 2
```

这些命令告诉内核将一个多队列队列纪律附加到 bond0 接口，并过滤被排队到该接口的流量，使得目标 IP 地址为 192.168.1.100 的数据包的输出队列映射值被重写为 2。

此值随后传递给驱动程序，导致正常的输出路径选择策略被覆盖，而是选择 qid 2，其映射到 eth1。

需要注意的是，qid 值从 1 开始。qid 0 被保留用于向驱动程序指示应采用正常的输出策略选择。仅仅将从属接口的 qid 设置为 0 的一个好处是，现在绑定驱动程序中的多队列感知能力。这种意识允许在从属设备以及绑定设备上放置 tc 过滤器，绑定驱动程序将简单地作为传递，用于选择从属设备上的输出队列而不是输出端口的选择。

此功能首次出现在绑定驱动程序版本 3.7.0 中，对输出从属设备的选择的支持仅限于轮询和主动备份模式。

3.7 以更安全的方式配置 LACP 用于 802.3ad 模式
----------------------------------------------------------

在使用 802.3ad 绑定模式时，Actor（主机）和 Partner（交换机）之间会交换 LACPDUs。这些 LACPDUs 无法被嗅探，因为它们的目标地址是链路本地 MAC 地址（交换机/桥接器不应转发）。然而，大多数值很容易预测，或者只是机器的 MAC 地址（这对于同一 L2 中的所有其他主机而言是微不足道的已知信息）。这意味着同一 L2 域中的其他机器可以伪造来自其他主机的 LACPDU 包并发送给交换机，可能会引起混乱，比如从交换机的角度来看加入另一台机器的聚合组，从而接收该主机的部分传入流量和/或伪造来自该机器的流量（甚至有可能成功终止部分流量）。尽管这不是一个很可能会发生的情况，但可以通过简单地配置几个绑定参数来避免这种可能性：

(a) `ad_actor_system`：你可以设置一个随机的 MAC 地址，用于这些 LACPDU 交换。该值不能为 NULL 或 Multicast。最好设置本地管理位。以下 shell 代码生成如上所述的随机 MAC 地址：

```plaintext
# sys_mac_addr=$(printf '%02x:%02x:%02x:%02x:%02x:%02x' \
                       $(( (RANDOM & 0xFE) | 0x02 )) \
                       $(( RANDOM & 0xFF )) \
                       $(( RANDOM & 0xFF )) \
                       $(( RANDOM & 0xFF )) \
                       $(( RANDOM & 0xFF )) \
                       $(( RANDOM & 0xFF )))
# echo $sys_mac_addr > /sys/class/net/bond0/bonding/ad_actor_system
```

(b) `ad_actor_sys_prio`：随机化系统优先级。默认值是 65535，但是系统可以取 1 到 65535 之间的值。以下 shell 代码生成随机优先级并设置它：

```plaintext
# sys_prio=$(( 1 + RANDOM + RANDOM ))
# echo $sys_prio > /sys/class/net/bond0/bonding/ad_actor_sys_prio
```

(c) `ad_user_port_key`：使用用户部分的端口密钥。默认情况下保持这部分为空。这些是端口密钥的高 10 位，取值范围为 0 到 1023。以下 shell 代码生成这 10 位并设置它：

```plaintext
# usr_port_key=$(( RANDOM & 0x3FF ))
# echo $usr_port_key > /sys/class/net/bond0/bonding/ad_user_port_key
```

4 查询绑定配置
==================

4.1 绑定配置
-------------------------

每个绑定设备在 `/proc/net/bonding` 目录中都有一个只读文件。文件内容包括关于绑定配置、选项和每个从属接口状态的信息。
例如，当使用参数 `mode=0` 和 `miimon=1000` 加载驱动程序后，`/proc/net/bonding/bond0` 的内容通常如下：

	以太网通道绑定驱动程序：2.6.1（2004年10月29日）
	绑定模式：负载均衡（轮询）
	当前活动从属设备：eth0
	MII 状态：正常
	MII 检查间隔（毫秒）：1000
	启动延迟（毫秒）：0
	关闭延迟（毫秒）：0

	从属接口：eth1
	MII 状态：正常
	链路故障计数：1

	从属接口：eth0
	MII 状态：正常
	链路故障计数：1

具体的格式和内容会根据绑定配置、状态以及绑定驱动程序的版本而变化。
4.2 网络配置
--------------

可以使用 `ifconfig` 命令来检查网络配置。绑定设备将设置 `MASTER` 标志；绑定从属设备将设置 `SLAVE` 标志。`ifconfig` 输出不包含哪些从属设备与哪个主设备关联的信息。在下面的例子中，`bond0` 接口是主设备 (`MASTER`)，而 `eth0` 和 `eth1` 是从属设备 (`SLAVE`)。请注意，除了需要每个从属设备具有唯一MAC地址的 TLB 和 ALB 模式之外，所有从属设备的 `bond0` 的MAC地址（HWaddr）都相同：

  # /sbin/ifconfig
  bond0     链接封装：以太网  HWaddr 00:C0:F0:1F:37:B4
	    inet 地址:XXX.XXX.XXX.YYY  广播:XXX.XXX.XXX.255  掩码:255.255.252.0
	    UP BROADCAST 运行 MASTER 多播  MTU:1500  度量:1
	    接收数据包:7224794 错误:0 丢弃:0 超时:0 帧:0
	    发送数据包:3286647 错误:1 丢弃:0 超时:1 载波:0
	    碰撞:0 发送队列长度:0

  eth0      链接封装：以太网  HWaddr 00:C0:F0:1F:37:B4
	    UP BROADCAST 运行 SLAVE 多播  MTU:1500  度量:1
	    接收数据包:3573025 错误:0 丢弃:0 超时:0 帧:0
	    发送数据包:1643167 错误:1 丢弃:0 超时:1 载波:0
	    碰撞:0 发送队列长度:100
	    中断:10 基础地址:0x1080

  eth1      链接封装：以太网  HWaddr 00:C0:F0:1F:37:B4
	    UP BROADCAST 运行 SLAVE 多播  MTU:1500  度量:1
	    接收数据包:3651769 错误:0 丢弃:0 超时:0 帧:0
	    发送数据包:1643480 错误:0 丢弃:0 超时:0 载波:0
	    碰撞:0 发送队列长度:100
	    中断:9 基础地址:0x1400

5. 交换机配置
==============

本节中的“交换机”是指绑定设备直接连接到的系统（即，线缆另一端插入的地方）。这可能是一个实际的专用交换机设备，也可能是一个普通的系统（例如，运行 Linux 的另一台计算机）。

主动备份（active-backup）、平衡 TLB（balance-tlb）和平衡 ALB（balance-alb）模式不需要任何特定的交换机配置。
802.3ad 模式要求交换机上相应的端口被配置为 802.3ad 聚合。具体配置方法因交换机而异，但例如，Cisco 3550 系列交换机需要首先将相应的端口组合在一个以太通道实例中，然后将该以太通道设置为模式“lacp”以启用 802.3ad（而不是标准以太通道）。
平衡 RR（balance-rr）、平衡 XOR（balance-xor）和广播（broadcast）模式通常需要交换机上的相应端口被分组在一起。这种分组的名称在不同的交换机之间有所不同，它可能被称为“以太通道”（如上面的 Cisco 示例所示）、“中继组”或其他类似的变体。对于这些模式，每个交换机也将有自己的配置选项用于设置交换机向绑定发送数据的策略。常见的选择包括 MAC 地址或 IP 地址的 XOR。两个对等点的数据发送策略不必匹配。对于这三种模式，绑定模式实际上选择了以太通道组的数据发送策略；这三种模式都可以与其他以太通道组互操作。
6. 802.1q VLAN 支持
=====================

可以在绑定接口上配置 VLAN 设备使用 8021q 驱动程序。但是，默认情况下只有来自 8021q 驱动程序并通过绑定的数据包会被标记。自我生成的数据包，例如，绑定的学习数据包或 ALB 模式或 ARP 监控机制生成的 ARP 数据包，由绑定本身内部标记。因此，绑定必须“学习”在其上方配置的 VLAN ID，并使用这些 ID 来标记自我生成的数据包。
出于简单性和支持使用可以进行 VLAN 硬件加速卸载的适配器的原因，绑定接口声明自己完全支持硬件卸载能力，它可以接收添加和删除 VLAN ID 的通知来收集必要的信息，并将这些动作传播给从属设备。在混合类型的适配器的情况下，应该通过不支持卸载的适配器发送的硬件加速标记数据包会被绑定驱动程序“取消加速”，以便 VLAN 标记位于常规位置。
VLAN 接口必须仅在绑定至少一个从属设备之后添加到绑定接口之上。绑定接口在添加第一个从属设备之前具有硬件地址 00:00:00:00:00:00。
如果在第一次绑定前创建了 VLAN 接口，它将采用全零的硬件地址。一旦第一个从属设备被附加到绑定上，绑定设备本身将采用从属设备的硬件地址，该地址随后可用于 VLAN 设备。
同样需要注意的是，如果从仍然拥有一个或多个VLAN接口的链路聚合组中释放所有从设备，可能会出现类似的问题。当添加新的从设备时，链路聚合接口将从第一个从设备获取其硬件地址，这可能与VLAN接口的硬件地址不匹配（VLAN接口的地址最终是从早期的一个从设备复制过来的）。
确保在移除所有从设备后VLAN设备能使用正确硬件地址有两种方法：

1. 移除所有VLAN接口然后重新创建它们

2. 设置链路聚合接口的硬件地址以匹配VLAN接口的硬件地址
请注意，更改VLAN接口的硬件地址会将底层设备（即链路聚合接口）设置为混杂模式，这可能不是您想要的结果。
7. 链路监控
=============

当前，链路聚合驱动支持两种方案来监控从设备的链路状态：ARP监控和MII监控。
目前由于链路聚合驱动自身的实现限制，无法同时启用ARP和MII监控。
7.1 ARP监控操作
---------------------

ARP监控正如其名所述：它向网络上指定的一个或多个对等系统发送ARP查询，并将收到的响应作为链路正常工作的指示。这样可以一定程度上保证流量确实流向了本地网络上的一个或多个对等系统。
7.2 配置多个ARP目标
------------------------------

虽然仅使用一个目标进行ARP监控是可行的，但在高可用性环境中，监控多个目标会更加有用。在只有一个目标的情况下，该目标本身可能出现故障或问题导致无法响应ARP请求。增加额外的目标（或者几个目标）可以提高ARP监控的可靠性。
多个ARP目标需要通过逗号分隔如下所示：

```
# 示例：具有三个目标的ARP监控选项
alias bond0 bonding
options bond0 arp_interval=60 arp_ip_target=192.168.0.1,192.168.0.3,192.168.0.9
```

对于只有一个目标的情况，选项将如下所示：

```
# 示例：具有一个目标的ARP监控选项
alias bond0 bonding
options bond0 arp_interval=60 arp_ip_target=192.168.0.100
```

7.3 MII监控操作
-----------------------

MII监控仅监控本地网络接口的载波状态。它可以通过以下三种方式之一来完成：依赖设备驱动程序维护其载波状态、查询设备的MII寄存器，或者向设备发出ethtool查询。
如果use_carrier模块参数设置为1（默认值），那么MII监控将依赖于驱动程序提供载波状态信息（通过netif_carrier子系统）。如前所述，在use_carrier参数说明中，如果MII监控未能检测到设备载波丢失（例如，物理断开电缆），可能是驱动程序不支持netif_carrier。
如果use_carrier设置为0，则MII监控首先会通过ioctl查询设备的MII寄存器并检查链路状态。如果该请求失败（不只是返回载波已断开），则MII监控将尝试通过ethtool ETHTOOL_GLINK请求来获取相同的信息。如果两种方法都失败（即，驱动程序要么不支持要么在处理MII寄存器和ethtool请求时出现错误），则MII监控将假设链路处于连通状态。
8. 潜在的麻烦来源
===============================

8.1 路由中的冒险
-------------------------

当配置了绑定（bonding）时，非常重要的一点是确保从属设备（slave devices）没有覆盖主设备（master）路由的路由（或者通常来说，不要有任何路由）。例如，假设绑定设备bond0有两个从属设备eth0和eth1，并且路由表如下所示：

```
内核IP路由表
目的地       网关         子网掩码           标志   MSS 窗口 irtt 接口
10.0.0.0      0.0.0.0       255.255.0.0     U        40 0          0 eth0
10.0.0.0      0.0.0.0       255.255.0.0     U        40 0          0 eth1
10.0.0.0      0.0.0.0       255.255.0.0     U        40 0          0 bond0
127.0.0.0     0.0.0.0       255.0.0.0       U        40 0          0 lo
```

这种路由配置可能会继续更新驱动程序中的接收/发送时间（这是ARP监视器所需要的），但可能绕过绑定驱动程序（因为发往网络10上的其他主机的数据包会优先使用eth0或eth1而不是bond0）。ARP监视器（以及ARP本身）可能会因这种配置而产生混乱，因为ARP请求（由ARP监视器生成）将通过一个接口（bond0）发送出去，但相应的回复会从另一个接口（eth0）到达。这个回复对ARP看起来像是一个未请求的ARP回复（因为ARP是以接口为基础匹配回复的），因此会被丢弃。MII监视器不会受到路由表状态的影响。
解决这个问题的方法就是确保从属设备没有自己的路由，如果由于某种原因必须有，则这些路由不应覆盖其主设备的路由。这通常应该是这样的情形，但不寻常的配置或误操作的手动或自动静态路由添加可能会导致问题。

8.2 以太网设备重命名
----------------------------

对于那些网络配置脚本不直接将物理设备与网络接口名称关联起来（即同一个物理设备总是拥有相同的"ethX"名称）的系统，可能需要在`/etc/modprobe.d/`下的配置文件中加入一些特殊的逻辑。
例如，给定一个包含以下内容的`modules.conf`文件：

```
alias bond0 bonding
options bond0 mode=some-mode miimon=50
alias eth0 tg3
alias eth1 tg3
alias eth2 e1000
alias eth3 e1000
```

如果eth0和eth1都不是bond0的从属设备，那么当bond0接口启动时，这些设备可能会被重新排序。这是因为绑定模块首先加载，然后是其从属设备的驱动程序。由于没有其他驱动程序被加载，当e1000驱动程序加载时，它将为它的设备获得eth0和eth1，但是绑定配置试图将eth2和eth3作为从属设备（这些设备稍后可能分配给了tg3设备）。
添加以下内容：

```
add above bonding e1000 tg3
```

会使modprobe在加载绑定模块时按照e1000然后tg3的顺序加载这些模块。此命令在`modules.conf`手册页中有完整文档。
对于使用modprobe的系统，也会出现类似的问题。
在这种情况下，可以在`/etc/modprobe.d/`下的配置文件中添加以下内容：

```
softdep bonding pre: tg3 e1000
```

这将在加载绑定模块之前先加载tg3和e1000模块。关于此内容的完整文档可以在`modprobe.d`和`modprobe`手册页中找到。

8.3 MII监控器检测链路故障异常缓慢或无法检测
---------------------------------------------------------

默认情况下，绑定启用了use_carrier选项，该选项指示绑定信任驱动程序来维护链路状态。
如在上面的选项部分中所讨论的，一些驱动程序不支持`netif_carrier_on`/_`off`链路状态跟踪系统。当启用`use_carrier`时，绑定（bonding）将始终把这些链接视为正常工作，无论它们的实际状态如何。
此外，其他一些驱动程序虽然支持`netif_carrier`，但并不会实时维护它，例如，只会在某个固定间隔轮询链路状态。在这种情况下，`miimon`会检测到故障，但需要经过一段较长的时间。如果发现`miimon`检测链路故障非常慢，请尝试指定`use_carrier=0`，看看是否能改善故障检测时间。如果这样做确实改善了故障切换时间，那么可能是驱动程序在固定间隔检查载波状态，但没有缓存MII寄存器值（因此直接查询寄存器的方法`use_carrier=0`起作用）。如果`use_carrier=0`并不能改善故障切换，则驱动程序可能缓存了寄存器值，或者问题出在其他地方。
另外，请记住`miimon`仅检查设备的载波状态。它没有办法确定交换机上其他端口或之外的设备的状态，也无法判断交换机是否拒绝传输数据同时仍然保持载波状态。

9. SNMP代理
=============

如果运行SNMP代理，则应在任何参与绑定的网络驱动程序之前加载绑定驱动程序。这一要求是由于接口索引（`ipAdEntIfIndex`）与具有给定IP地址的第一个找到的接口相关联。也就是说，每个IP地址只有一个`ipAdEntIfIndex`。例如，如果`eth0`和`eth1`是`bond0`的从设备，并且`eth0`的驱动程序在绑定驱动程序之前被加载，则IP地址的接口将与`eth0`接口相关联。以下配置示例中，IP地址`192.168.1.1`有一个接口索引为2，该索引指向`ifDescr`表中的`eth0`：
```
     interfaces.ifTable.ifEntry.ifDescr.1 = lo
     interfaces.ifTable.ifEntry.ifDescr.2 = eth0
     interfaces.ifTable.ifEntry.ifDescr.3 = eth1
     interfaces.ifTable.ifEntry.ifDescr.4 = eth2
     interfaces.ifTable.ifEntry.ifDescr.5 = eth3
     interfaces.ifTable.ifEntry.ifDescr.6 = bond0
     ip.ipAddrTable.ipAddrEntry.ipAdEntIfIndex.10.10.10.10 = 5
     ip.ipAddrTable.ipAddrEntry.ipAdEntIfIndex.192.168.1.1 = 2
     ip.ipAddrTable.ipAddrEntry.ipAdEntIfIndex.10.74.20.94 = 4
     ip.ipAddrTable.ipAddrEntry.ipAdEntIfIndex.127.0.0.1 = 1
```

通过在任何参与绑定的网络驱动程序之前加载绑定驱动程序可以避免此问题。以下是一个首先加载绑定驱动程序的例子，IP地址`192.168.1.1`正确地与`ifDescr.2`相关联：
```
     interfaces.ifTable.ifEntry.ifDescr.1 = lo
     interfaces.ifTable.ifEntry.ifDescr.2 = bond0
     interfaces.ifTable.ifEntry.ifDescr.3 = eth0
     interfaces.ifTable.ifEntry.ifDescr.4 = eth1
     interfaces.ifTable.ifEntry.ifDescr.5 = eth2
     interfaces.ifTable.ifEntry.ifDescr.6 = eth3
     ip.ipAddrTable.ipAddrEntry.ipAdEntIfIndex.10.10.10.10 = 6
     ip.ipAddrTable.ipAddrEntry.ipAdEntIfIndex.192.168.1.1 = 2
     ip.ipAddrTable.ipAddrEntry.ipAdEntIfIndex.10.74.20.94 = 5
     ip.ipAddrTable.ipAddrEntry.ipAdEntIfIndex.127.0.0.1 = 1
```

虽然某些发行版可能不会在`ifDescr`中报告接口名称，但IP地址与IfIndex之间的关联仍然存在，SNMP功能如Interface_Scan_Next将报告这种关联。

10. 混杂模式
==============

在运行网络监控工具（例如tcpdump）时，通常会启用混杂模式以查看所有流量（而不仅仅是发往本地主机的流量）。
绑定驱动程序处理对绑定主设备（例如`bond0`）的混杂模式更改，并将设置传播到从设备。
对于`balance-rr`、`balance-xor`、`broadcast`和`802.3ad`模式，混杂模式设置将被传播到所有从设备。
对于主动备份（active-backup）、负载平衡TLB（balance-tlb）和自适应负载平衡ALB（balance-alb）模式，混杂模式设置仅传播到活动的从属接口。
对于balance-tlb模式，活动的从属接口是当前接收传入流量的从属接口。
对于balance-alb模式，活动的从属接口被用作“主接口”。这个从属接口用于特定于模式的控制流量，向未分配或负载不平衡的对等方发送数据。
对于主动备份、负载平衡TLB和自适应负载平衡ALB模式，当活动的从属接口发生变化时（例如，由于链路故障），混杂模式设置将传播到新的活动从属接口。

11. 高可用性配置
==================

高可用性是指通过在主机与外界之间配置冗余或备份设备、链路或交换机来实现最大网络可用性的配置。其目标是在任何情况下保证网络连接的最大可用性（即网络始终正常工作），尽管其他配置可能提供更高的吞吐量。

11.1 单个交换机拓扑中的高可用性
-----------------------------------

如果两台主机（或一台主机与单个交换机）通过多个物理链路直接相连，则为了最大化带宽而优化不会影响可用性。在这种情况下，只有一个交换机（或对等体），因此如果它发生故障，没有其他可切换的接入方式。此外，绑定的负载均衡模式支持成员链路监控，因此如果个别链路出现故障，负载将在剩余设备间重新分配。
有关如何使用一个对等设备配置绑定以获得最大吞吐量的信息，请参阅第12节，“配置绑定以获得最大吞吐量”。

11.2 多个交换机拓扑中的高可用性
------------------------------------

在存在多个交换机的情况下，绑定配置及网络结构会发生显著变化。在多交换机拓扑中，网络可用性和可用带宽之间存在着权衡。

下面是一个为最大化网络可用性配置的示例网络：

```
         |                                     |
         |port3                           port3|
       +-----+----+                          +-----+----+
       |          |port2       ISL      port2|          |
       | switch A +--------------------------+ switch B |
       |          |                          |          |
       +-----+----+                          +-----++---+
         |port1                           port1|
         |             +-------+               |
         +-------------+ host1 +---------------+
                 eth0 +-------+ eth1
```

在此配置中，两个交换机之间有一条链路（ISL，即交换机间的链路），并且每个交换机都有多个端口连接到外部世界（每个交换机上的“port3”）。从技术上讲，并没有任何限制阻止扩展到第三个交换机。

11.2.1 多交换机拓扑中的HA绑定模式选择
----------------------------------------

在上述类型的拓扑结构中，当以可用性为目标进行优化时，只有主动备份和广播模式是有用的绑定模式；其他模式要求所有链路必须终止在同一对等体上才能合理运行。
### 主动-备份模式：
这通常是首选的模式，特别是在交换机之间有ISL（内部交换链路）且能良好协同工作的情况下。如果网络配置中有一个特定的交换机作为备份交换机（例如，容量较低、成本较高等），那么可以使用主选项来确保在可用时始终使用首选链接。

### 广播模式：
这种模式实际上是一种特殊用途的模式，只适用于非常具体的需求。例如，如果两个交换机没有连接（没有ISL），并且它们后面的网络是完全独立的。在这种情况下，如果需要某些特定的一向流量能够到达这两个独立网络，则广播模式可能是合适的。

### 11.2.2 高可用性链接监控选择：多交换机拓扑
-------------------------------------------------

链接监控的选择最终取决于您的交换机。如果交换机能够在遇到其他故障时可靠地关闭端口，那么无论是MII还是ARP监控都应该是可行的。例如，在上面的例子中，如果“port3”链接在远端出现故障，MII监控器无法直接检测到这一点。而ARP监控器可以在port3的远端设置一个目标，从而在不需要交换机支持的情况下检测到这个故障。
通常而言，在多交换机拓扑中，ARP监控器可以在检测端到端连接性故障方面提供更高的可靠性（这些故障可能是由任何单个组件因任何原因无法传输数据引起的）。此外，ARP监控器应该被配置为具有多个目标（至少每个网络中的交换机都有一个）。这样可以确保无论哪个交换机处于活动状态，ARP监控器都有一个合适的目标进行查询。

值得注意的是，最近许多交换机支持一种通常称为“链路故障转移”的功能。这是一种交换机的功能，当另一个交换机端口的状态变为不可用（或可用）时，特定交换机端口的链接状态会被设置为不可用（或可用）。其目的是将逻辑上“外部”端口的链接故障传播到逻辑上“内部”的端口，这些端口可以通过miimon进行监控。链路故障转移的可用性和配置因交换机而异，但在使用适当的交换机时，这可以成为ARP监控的一个可行替代方案。

### 12. 配置绑定以实现最大吞吐量
==================================

#### 12.1 在单一交换机拓扑中最大化吞吐量
-------------------------------------------

在单一交换机配置中，最佳的方法来最大化吞吐量取决于应用和网络环境。不同的负载均衡模式在不同的环境下各有优势和劣势，具体如下：

对于本讨论，我们将拓扑结构分为两类。根据大多数流量的目的地，我们将其分为“网关”配置或“本地”配置。

在网关配置中，“交换机”主要作为路由器使用，大多数流量通过此路由器传递到其他网络。一个例子如下所示：

```
+----------+                     +----------+
|          |eth0            port1|          | to other networks
| Host A   +---------------------+ router   +------------------->
|          +---------------------+          | Hosts B and C are out
|          |eth1            port2|          | here somewhere
+----------+                     +----------+
```

路由器可能是一个专用的路由器设备，或者另一个充当网关的主机。对于我们的讨论，重要的是大多数来自Host A的流量会通过路由器传递到另一个网络，然后到达其最终目的地。

在网关网络配置中，尽管Host A可能会与许多其他系统通信，但其所有流量都将通过本地网络上的一个其他对等节点（即路由器）发送和接收。
请注意，两个系统通过多个物理链路直接连接的情况，在配置绑定时，与网关配置的情况相同。在这种情况下，所有流量的目的地实际上是“网关”本身，而不是网关之外的其他网络。

在本地配置中，“交换机”主要作为交换机工作，并且大部分流量通过此交换机到达同一网络上的其他站点。一个例子如下：

    +----------+            +----------+       +--------+
    |          |eth0   port1|          +-------+ Host B |
    |  Host A  +------------+  switch  |port3  +--------+
    |          +------------+          |                  +--------+
    |          |eth1   port2|          +------------------+ Host C |
    +----------+            +----------+port4             +--------+

再次强调，该交换机可以是专用的交换设备，也可以是充当网关的另一台主机。对于我们的讨论而言，重要的一点是来自Host A的大多数流量都目的地是同一本地网络上的其他主机（例如上图中的Host B和Host C）。

总之，在网关配置中，到绑定设备的进出流量都将流向网络上的同一MAC级别对等体（即网关本身，也就是路由器），无论其最终目的地是什么。而在本地配置中，流量直接流向最终目的地，因此每个目的地（如Host B、Host C）都会被它们各自的MAC地址直接寻址。

这种网关配置与本地网络配置之间的区别很重要，因为许多负载均衡模式使用本地网络源和目的的MAC地址来做出负载均衡决策。每种模式的行为将在下面详细描述。

12.1.1 单交换机拓扑下的MT绑定模式选择

这种配置是最容易设置和理解的，尽管您需要决定哪种绑定模式最适合您的需求。每种模式的权衡如下：

balance-rr：
	此模式是唯一允许单个TCP/IP连接在多个接口之间条带化流量的模式。因此，这是唯一允许单个TCP/IP流利用超过一个接口带宽的模式。然而，这会带来一个代价：条带化通常会导致对等系统接收到乱序的数据包，从而触发TCP/IP的拥塞控制系统，经常表现为重新传输数据段。
	可以通过调整net.ipv4.tcp_reordering的sysctl参数来改变TCP/IP的拥塞限制。默认值通常是3。但请记住，当检测到重排序时，TCP堆栈能够自动增加这个值。
	请注意，将被乱序交付的数据包比例是高度可变的，并且不太可能为零。重排序的程度取决于多种因素，包括网络接口、交换机以及配置的拓扑结构。一般来说，高速网络卡会产生更多的重排序（由于诸如数据包聚合等因素），而“多对多”的拓扑结构将比“多慢对一快”的配置产生更高的重排序率。
	许多交换机不支持任何条带化流量的模式（而是根据IP或MAC级别的地址选择端口）；对于这些设备，特定连接的流量通过交换机流向balance-rr绑定时，不会利用大于一个接口的带宽。
	如果您正在使用除TCP/IP以外的协议，例如UDP，并且您的应用程序可以容忍乱序交付，则此模式可以允许随着绑定接口的增加，单流数据报性能几乎线性增长。
	此模式要求交换机具有适当配置的“etherchannel”或“trunking”端口。

active-backup：
	在此网络拓扑中，active-backup模式的优势不大，因为备用设备处于非活动状态，它们都连接到了与主设备相同的对等体。在这种情况下，带有链路监控的负载均衡模式将提供相同水平的网络可用性，但具有更高的可用带宽。不过，active-backup模式的优点是不需要配置交换机，因此如果可用硬件不支持任何负载均衡模式，它可能具有价值。
### Balance-XOR 模式：
此模式将限制流量，确保发往特定对等方的数据包始终通过同一接口发送。由于目标是由涉及的MAC地址决定的，这种模式最适合于“本地”网络配置（如上所述），其中所有目的地都在同一本地网络上。如果所有流量都通过单一路由器传递（即“网关化”网络配置，如上所述），则此模式可能不是最优选择。
与平衡轮询（balance-rr）类似，交换机端口需要配置为“etherchannel”或“trunking”。

### 广播（Broadcast）模式：
如同主动备份（active-backup）模式，在此类网络拓扑中，该模式的优势不大。

### 802.3ad 模式：
对于这种类型的网络拓扑，此模式可以是一个很好的选择。802.3ad模式是IEEE标准，因此实现802.3ad的所有对等方应该能够很好地互操作。802.3ad协议包括自动配置聚合链路，因此只需要最小程度的手动配置交换机（通常仅需指定某些设备可用于802.3ad）。802.3ad标准还要求帧必须按顺序传送（在一定范围内），因此一般来说单个连接不会看到数据包乱序。802.3ad模式也有一些缺点：标准要求聚合链路中的所有设备以相同的速度和双工模式运行。此外，与除平衡轮询（balance-rr）之外的所有其他绑定负载均衡模式一样，没有一个单独的连接能利用超过单一接口带宽。
另外，Linux绑定的802.3ad实现通过对等方进行流量分配（使用MAC地址和数据包类型ID的XOR运算），所以在“网关化”配置下，所有传出流量通常会使用同一设备。传入流量也可能最终集中在单一设备上，但这取决于对等方802.3ad实现的负载均衡策略。在“本地”配置下，流量将在绑定中的设备之间分布。
最后，802.3ad模式要求使用MII监视器，因此在这种模式下无法使用ARP监视器。

### Balance-TLB 模式：
平衡TLB模式根据对等方平衡传出流量。
由于负载均衡基于MAC地址，在“网关化”配置下（如上所述），此模式会将所有流量发送到单一设备。然而，在“本地”网络配置中，此模式以一种略显智能的方式（不同于balance-xor或802.3ad模式中的简单XOR运算）在设备间平衡多个本地网络对等方，这样数学上不幸运的MAC地址（即XOR结果相同的地址）就不会全部集中在一个接口上。
与802.3ad不同，接口可以有不同的速度，并且不需要特殊的交换机配置。不利方面，在此模式下所有传入流量都会通过单一接口到达，此模式需要从属接口的网络设备驱动程序支持某些ethtool功能，并且ARP监视器不可用。

### Balance-ALB 模式：
此模式具有平衡TLB模式的所有功能，并且更多。
它具有平衡TLB模式的所有特性（和限制），并且还会平衡来自本地网络对等方的传入流量（如上文“绑定模块选项”部分所述）。
### 唯一的额外缺点是此模式要求网络设备驱动程序在设备打开时支持更改硬件地址。

#### 12.1.2 单交换机拓扑中的MT链路监控
在这种情况下，选择哪种链路监控方式可能很大程度上取决于您选择使用的模式。更高级的负载均衡模式不支持ARP监控的使用，因此只能使用MII监控（这不如ARP监控那样能提供端到端的高度保障）。

#### 12.2 多个交换机拓扑中的最大吞吐量
多个交换机可以用于优化吞吐量，当它们作为孤立网络的一部分并行配置在两个或多个系统之间时，例如：

```
         +-----------+
         |  Host A   |
         +-+---+---+-+
           |   |   |
    +--------+   |   +---------+
    |            |             |
    +------+---+  +-----+----+  +-----+----+
    | Switch A |  | Switch B |  | Switch C |
    +------+---+  +-----+----+  +-----+----+
    |            |             |
    +--------+   |   +---------+
           |   |   |
         +-+---+---+-+
         |  Host B   |
         +-----------+
```

在此配置中，各交换机彼此隔离。采用这种拓扑结构的一个原因是为具有许多主机的孤立网络（例如，为高性能而配置的集群），使用多个较小的交换机通常比使用一个较大的交换机更具成本效益，例如，在一个有24台主机的网络中，三个24端口的交换机可能远比一个72端口的交换机便宜得多。
如果需要访问该网络之外的内容，则可以在一台主机上配备一个连接到外部网络的额外网络设备；这台主机同时也充当网关。

#### 12.2.1 多个交换机拓扑中的MT绑定模式选择
实际上，在此类配置中常用的绑定模式通常是平衡轮询（balance-rr）。历史上，在这种网络配置中，关于乱序包传输的一般注意事项通过使用不进行任何包聚合（通过使用NAPI，或者因为设备本身直到接收到一定数量的包后才生成中断）的网络适配器得以缓解。以这种方式使用时，平衡轮询模式允许两台主机之间的单个连接有效利用超过一个接口的带宽。

#### 12.2.2 多个交换机拓扑中的MT链路监控
同样，在实际应用中，此配置最常使用的是MII监控，因为性能优先于可用性。ARP监控也可以在此拓扑中工作，但随着涉及系统的数量增加所需探针的数量增多，其相对于MII监控的优势被削弱了（请记住，网络中的每个主机都配置了绑定）。

### 13. 交换机行为问题

#### 13.1 链路建立和故障转移延迟
一些交换机在报告链路上线和下线的时间方面表现出不良行为。
首先，当一条链路建立时，某些交换机可能会指示链路已上线（载波可用），但在一段时间内不通过该接口传递流量。这种延迟通常是由于某种自动协商或路由协议造成的，也可能发生在交换机初始化期间（例如，在交换机故障恢复之后）。如果您发现这是一个问题，可以通过设置适当的updelay值来延迟使用相关接口。
其次，一些交换机在链路状态改变时可能会“抖动”链路状态一次或多次。这种情况最常发生在交换机初始化过程中。再次，适当的updelay值可能有所帮助。
请注意，当一个绑定接口没有任何活动链路时，驱动程序会立即重用第一个上线的链路，即使指定了updelay参数（此时updelay将被忽略）。如果有等待updelay超时到期的从属接口，那么最先进入该状态的接口将被立即重用。这减少了网络的停机时间，如果updelay的值被高估，这样做可以减少停机时间，并且这种情况仅在没有连接性的情况下发生，因此忽略updelay不会带来额外的代价。
除了对切换时间的担忧之外，如果你的交换机进入备份模式需要较长时间，可能不希望在链路断开后立即激活备份接口。可以通过`downdelay`这个bonding模块选项来延迟故障转移。
### 13.2 重复的接收数据包

**注：**从版本3.0.2开始，bonding驱动程序中已经加入了抑制重复数据包的逻辑，这应该可以大大消除这个问题。以下描述仅作为参考保留。

当bonding设备首次使用或闲置一段时间后重新启动时，观察到短暂的一连串重复流量是很常见的。最简单的观察方法是向网络中的其他主机发送“ping”命令，并注意到ping输出标记了重复的数据包（通常每个从属接口有一个）。

例如，在一个有五个从属接口都连接到同一个交换机的主备模式bonding配置中，输出可能如下所示：

```
# ping -n 10.0.4.2
PING 10.0.4.2 (10.0.4.2) from 10.0.3.10 : 56(84) bytes of data
64 bytes from 10.0.4.2: icmp_seq=1 ttl=64 time=13.7 ms
64 bytes from 10.0.4.2: icmp_seq=1 ttl=64 time=13.8 ms (DUP!)
64 bytes from 10.0.4.2: icmp_seq=1 ttl=64 time=13.8 ms (DUP!)
64 bytes from 10.0.4.2: icmp_seq=1 ttl=64 time=13.8 ms (DUP!)
64 bytes from 10.0.4.2: icmp_seq=1 ttl=64 time=13.8 ms (DUP!)
64 bytes from 10.0.4.2: icmp_seq=2 ttl=64 time=0.216 ms
64 bytes from 10.0.4.2: icmp_seq=3 ttl=64 time=0.267 ms
64 bytes from 10.0.4.2: icmp_seq=4 ttl=64 time=0.222 ms
```

这不是因为bonding驱动程序有错误，而是交换机更新其MAC转发表的一种副作用。最初，交换机不会将数据包中的MAC地址与特定的端口关联起来，因此它可能会将流量发送到所有端口直到其MAC转发表被更新。由于bonding接口可能占用单个交换机上的多个端口，当交换机（暂时地）将流量泛洪到所有端口时，bonding设备会接收到同一数据包的多个副本（每个从属接口一个）。

重复数据包的行为取决于具体的交换机型号，有些交换机会出现这种情况，而有些则不会。对于表现出这种行为的交换机，可以通过清除MAC转发表来触发这种现象（在大多数Cisco交换机上，特权命令`clear mac address-table dynamic`可以实现这一点）。
### 14. 硬件特性的考虑

本节包含针对特定硬件平台配置bonding的额外信息，或者与特定交换机或其他设备接口的信息。
#### 14.1 IBM BladeCenter

这适用于JS20和类似系统。
在JS20刀片服务器上，绑定驱动程序仅支持balance-rr、active-backup、balance-tlb和balance-alb模式。这主要是由于BladeCenter内部的网络拓扑结构，具体细节如下。

JS20网络适配器信息
--------------------

所有JS20服务器都集成了两个Broadcom千兆以太网端口（在主板上）。在BladeCenter机箱中，所有JS20刀片服务器的eth0端口硬连接到I/O模块#1；类似地，所有eth1端口都连接到I/O模块#2。
可以安装一个附加的Broadcom扩展卡为JS20提供另外两个千兆以太网端口。这些端口（eth2和eth3）分别连接到I/O模块#3和#4。
每个I/O模块可能包含一个交换机或一个直通模块（允许端口直接连接到外部交换机）。某些绑定模式需要特定的BladeCenter内部网络拓扑结构才能运行；具体细节如下。
更多关于BladeCenter特性的网络信息可以在两本IBM红皮书中找到（www.ibm.com/redbooks）：

- “IBM eServer BladeCenter 网络选项”
- “IBM eServer BladeCenter 第2层至第7层网络交换”

BladeCenter网络配置
--------------------

由于BladeCenter可以以非常多种方式配置，以下讨论将局限于描述基本配置。
通常情况下，在I/O模块#1和#2中使用以太网交换模块(ESM)。在这种配置下，JS20的eth0和eth1端口将连接到不同的内部交换机（在相应的I/O模块中）。
直通模块(OPM或CPM，即光学或铜线直通模块)将I/O模块直接连接到外部交换机。通过在I/O模块#1和#2中使用直通模块(PM)，JS20的eth0和eth1接口可以被导向外部并与一个公共的外部交换机相连。
根据ESM和PM的不同组合，网络对于绑定来说可能表现为单个交换机拓扑（全为PMs）或多交换机拓扑（一个或多个ESM，零个或多个PMs）。同样，也可以将ESM连接在一起，形成与“多交换机拓扑中的高可用性”示例类似的配置。

特定模式的要求
-----------------

balance-rr模式要求使用直通模块(PM)作为绑定设备的一部分，并且所有这些设备都连接到一个共同的外部交换机。
该交换机必须在其相应的端口上配置为“etherchannel”或“trunking”，这是balance-rr模式下的常见配置。
平衡-alb 和 平衡-tlb 模式可以与交换模块或直通模块一起使用（或者两者的混合）。这些模式的唯一特定要求是所有网络接口必须能够到达通过绑定设备发送流量的所有目的地（即，网络必须在 BladeCenter 外部的某个点上汇聚）。
对于活动-备份模式没有额外的要求。

链路监控问题
----------------------

当安装了以太网交换模块时，只有 ARP 监控能可靠地检测到到外部交换机的链路丢失。这并不罕见，但检查 BladeCenter 机柜可能会让人误以为“外部”网络端口就是系统的以太网端口，而实际上在这类“外部”端口和 JS20 系统本身的设备之间还有一个交换机。MII 监控只能检测到 ESM 和 JS20 系统之间的链路故障。
当安装了直通模块时，MII 监控确实可以检测到“外部”端口的故障，该端口直接连接到 JS20 系统。

其他关注点
--------------

串行网络链接（SoL）仅通过主以太网（eth0）建立，因此 eth0 的任何链路丢失都会导致您失去 SoL 连接。它不会像其他网络流量那样进行故障转移，因为 SoL 系统超出了绑定驱动程序的控制范围。
可能希望禁用交换机上的生成树协议（无论是内部以太网交换模块还是外部交换机），以避免使用绑定时出现故障转移延迟问题。

15. 常见问题解答
==================

1. 它是否支持 SMP？
-------------------
是的。旧的 2.0.xx 通道绑定补丁不支持 SMP。
新的驱动程序从一开始就设计为支持 SMP。
2. 哪种类型的网卡可以与它一起工作？
-----------------------------------------
任何类型的以太网卡（甚至可以混合使用不同的卡，例如 Intel EtherExpress PRO/100 和 3com 3c905b）。对于大多数模式，设备不必具有相同的速度。
从版本 3.2.1 开始，绑定还支持在活动-备份模式下使用 InfiniBand 设备作为从属设备。
3. 我可以拥有多少个绑定设备？
------------------------------------------------

没有数量限制。
4. 一个绑定设备可以有多少个从设备？
---------------------------------------------------

这仅受限于 Linux 支持的网络接口数量和您可以在系统中安装的网卡数量。
5. 当从设备链接断开时会发生什么？
----------------------------------------------------

如果启用了链路监控，则故障设备将被禁用。主动备份模式会切换到备份链接，而其他模式会忽略已失败的链接。链路将继续被监控，一旦恢复，它将以适当的方式重新加入绑定（取决于模式）。有关详细信息，请参阅高可用性部分以及各模式的文档。
链路监控可以通过 miimon 或 arp_interval 参数启用（在上面的模块参数部分中有描述）。通常情况下，miimon 监控由底层网络设备感知到的载波状态，而 ARP 监控（arp_interval）则监控与本地网络上另一台主机的连通性。
如果没有配置链路监控，绑定驱动程序将无法检测到链路故障，并且会假定所有链路始终可用。这可能会导致数据包丢失，并因此导致性能下降。具体性能损失取决于绑定模式和网络配置。
6. 绑定可以用于高可用性吗？
------------------------------------------------

可以。请参阅高可用性部分了解详情。
7. 它适用于哪些交换机/系统？
------------------------------------------------

这个问题的完整答案取决于所需的模式。
在基本负载平衡模式（balance-rr 和 balance-xor）中，它适用于支持 EtherChannel（也称为 trunking）的任何系统。目前大多数可管理的交换机都支持这种功能，许多不可管理的交换机也支持。
高级负载平衡模式（balance-tlb 和 balance-alb）对交换机没有特殊要求，但需要支持特定功能的设备驱动程序（在上面的模块参数部分有描述）。
在 802.3ad 模式下，它适用于支持 IEEE 802.3ad 动态链路聚合的系统。目前大多数可管理的交换机和许多不可管理的交换机都支持 802.3ad。
主动备份模式应与任何第二层交换机兼容。

8. 哪里获取绑定设备的MAC地址？
----------------------------------

当使用具有固定MAC地址的从属设备，或者启用了`fail_over_mac`选项时，绑定设备的MAC地址是活动从属设备的MAC地址。
对于其他配置，如果没有明确配置（通过`ifconfig`或`ip link`），绑定设备的MAC地址取自其第一个从属设备。然后此MAC地址被传递给所有后续的从属设备，并保持不变（即使第一个从属设备被移除），直到绑定设备被关闭或重新配置。
如果你想更改MAC地址，你可以用`ifconfig`或`ip link`设置它：

	# ifconfig bond0 hw ether 00:11:22:33:44:55

	# ip link set bond0 address 66:77:88:99:aa:bb

也可以通过关闭/启动设备并更改其从属设备（或它们的顺序）来更改MAC地址：

	# ifconfig bond0 down ; modprobe -r bonding
	# ifconfig bond0 .... up
	# ifenslave bond0 eth..

这种方法会自动从添加的下一个从属设备中获取地址。
要恢复从属设备的MAC地址，你需要将它们从绑定中分离（`ifenslave -d bond0 eth0`）。绑定驱动程序随后会恢复这些从属设备在被绑定之前所具有的MAC地址。

16. 资源和链接
===============

最新的绑定驱动程序可以在最新版本的Linux内核中找到，该内核位于http://kernel.org

本文档的最新版本可以在最新内核源代码中找到（命名为Documentation/networking/bonding.rst）。
关于绑定驱动程序开发的讨论在主要的Linux网络邮件列表上进行，该列表托管于vger.kernel.org。列表地址为：

netdev@vger.kernel.org

订阅或退订的管理界面可以在这里找到：

http://vger.kernel.org/vger-lists.html#netdev
