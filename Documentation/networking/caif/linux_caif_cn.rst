SPDX 许可证标识符: GPL-2.0
.. include:: <isonum.txt>

==========
Linux CAIF
==========

版权所有 |copy| ST-Ericsson AB 2010

:作者: Sjur Brendeland/ sjur.brandeland@stericsson.com
:许可条款: GNU通用公共许可证（GPL）第2版


简介
============

CAIF 是一种由ST-Ericsson手机调制解调器使用的多路复用协议，用于调制解调器与主机之间的通信。主机进程可以打开虚拟AT通道、启动GPRS数据连接、视频通道和实用通道。实用通道是调制解调器与主机之间的一般用途管道。ST-Ericsson调制解调器支持调制解调器与主机间的多种传输方式。目前，UART和回环接口对Linux架构可用。
架构
============

CAIF的实现分为：

* CAIF套接字层和GPRS IP接口
* CAIF核心协议实现
* CAIF链路层，作为NET设备实现
::

  RTNL
   !
   !	      +------+	 +------+
   !	     +------+!	+------+!
   !	     !	IP  !!	!Socket!!
   +-------> !接口 !+	! API  !+	<- CAIF客户端APIs
   !	     +------+	+------!
   !		!	    !
   !		+-----------+
   !		      !
   !		   +------+		<- CAIF核心协议
   !		   ! CAIF !
   !		   ! 核心 !
   !		   +------+
   !	   +----------!---------+
   !	   !	      !		!
   !	+------+   +-----+   +------+
   +--> ! HSI  !   ! TTY !   ! USB  !	<- 链路层（网卡设备）
	+------+   +-----+   +------+



实现
==============

CAIF核心协议层
------------------------

CAIF核心层实现了ST-Ericsson定义的CAIF协议。
它按照层次化的方法实现CAIF协议栈，其中规范中的每一层都在单独的C文件中实现。
该架构受到设计模式“协议层”和“协议包”的启发。
CAIF结构
^^^^^^^^^^^^^^

核心CAIF实现包括：

      - 简单实现的CAIF
- 层次化的架构（类似于流），CAIF规范中的每一层都在单独的C文件中实现
客户端必须调用配置函数以添加物理层  
客户端必须实现CAIF层来处理/生成  
带有接收和发送功能的CAIF负载  
客户端必须调用配置函数以添加并连接  
客户端层  
- 在接收/发送CAIF数据包（cfpkt）时，所有权会传递给被调用的函数  
（除了帧层的接收函数除外）

分层架构  
===============  

CAIF协议可以分为两部分：支持功能和协议实现。支持功能包括：

      - CFPKT CAIF数据包。实现了CAIF协议数据包。CAIF数据包提供了创建、销毁、添加内容以及向协议数据包添加/提取头部和尾部的功能
CAIF协议实现包含：

      - CFCNFG CAIF配置层。配置CAIF协议栈，并提供客户端接口以便在CAIF堆栈之上添加链路层和驱动接口
- CFCTRL CAIF控制层。编码和解码控制消息，如枚举和通道设置。同时也匹配请求与响应消息
- CFSERVL 通用CAIF服务层功能；处理流控制和远程关闭请求
- CFVEI CAIF VEI层。处理CAIF上的AT通道（位于VEI，即虚拟外部接口）。这一层对VEI帧进行编码/解码
- CFDGML CAIF数据报层。处理CAIF数据报层（IP流量），对数据报帧进行编码/解码
- CFMUX CAIF复用层。处理多个物理承载和多个通道之间的复用，如VEI、数据报等
MUX 跟踪现有的 CAIF 通道和物理实例，并根据 Channel-Id 和 Physical-ID 选择合适的实例。
- CFFRML CAIF 帧层。处理帧结构，即帧长度和帧校验和。
- CFSERL CAIF 串行层。处理将帧拼接/拆分为具有正确长度的 CAIF 帧。

```
		    +---------+
		    | 配置    |
		    | CFCNFG  |
		    +---------+
			 !
    +---------+	    +---------+	    +---------+
    | AT     |	    | 控制    |	    | 数据报  |
    | CFVEIL |	    | CFCTRL  |	    | CFDGML  |
    +---------+	    +---------+	    +---------+
	   \_____________!______________/
			 !
		    +---------+
		    | MUX     |
		    |         |
		    +---------+
		    _____!_____
		   /	       \
	    +---------+	    +---------+
	    | CFFRML  |	    | CFFRML  |
	    | 帧层    |	    | 帧层    |
	    +---------+	    +---------+
		 !		!
	    +---------+	    +---------+
	    |         |	    | 串行    |
	    |         |	    | CFSERL  |
	    +---------+	    +---------+
```

在这种分层方法中，适用以下“规则”：
- 所有层都嵌入了相同的结构“struct cflayer”
      - 层不依赖于其他层的私有数据
- 层通过设置指针来堆叠：

		  layer->up , layer->dn

      - 为了向上发送数据，每层应执行如下操作：

		 layer->up->receive(layer->up, packet);

      - 为了向下发送数据，每层应执行如下操作：

		 layer->dn->transmit(layer->dn, packet);

CAIF 套接字与 IP 接口
======================
IP 接口和 CAIF 套接字 API 实现基于 CAIF 核心协议之上。IP 接口和 CAIF 套接字有一个 'struct cflayer' 的实例，就像 CAIF 核心协议栈一样。网卡设备和套接字实现了由 'struct cflayer' 定义的 'receive()' 函数，就像 CAIF 协议栈中的其余部分一样。这样，数据包的传输和接收与其他层一样处理：通过调用 'dn->transmit()' 函数来传输数据。

链路层配置
-----------------
链路层作为 Linux 网络设备（struct net_device）实现。有效载荷处理和注册使用标准 Linux 机制。CAIF 协议依赖于无损链路层而不实现重传。这意味着不允许丢弃数据包。
因此，实现了一种流控制机制，其中物理接口可以启动对所有CAIF通道的流停止操作。
