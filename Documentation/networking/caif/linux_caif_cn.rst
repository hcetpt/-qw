.. SPDX-License-Identifier: GPL-2.0
.. include:: <isonum.txt>

==========
Linux CAIF
==========

版权所有 |copy| ST-Ericsson AB 2010

:作者: Sjur Brendeland / sjur.brandeland@stericsson.com
:许可条款: GNU通用公共许可证（GPL）第2版

简介
============

CAIF 是一个由 ST-Ericsson 手机调制解调器使用的多路复用协议，用于调制解调器和主机之间的通信。主机进程可以打开虚拟AT通道、启动GPRS数据连接、视频通道和工具通道。工具通道是调制解调器与主机之间的一般用途管道。ST-Ericsson 调制解调器支持多种调制解调器与主机之间的传输方式。目前，对于Linux架构，可用的传输方式有UART和环回（Loopback）。

架构
============

CAIF 的实现分为以下几个部分：

* CAIF 套接字层和GPRS IP接口
* CAIF 核心协议实现
* CAIF 链路层，作为NET设备实现

::

  RTNL
   !
   !	      +------+	 +------+
   !	     +------+!	+------+!
   !	     !	IP  !!	!Socket!!
   +-------> !interf!+	! API  !+	<- CAIF 客户端API
   !	     +------+	+------!
   !		!	    !
   !		+-----------+
   !		      !
   !		   +------+		<- CAIF 核心协议
   !		   ! CAIF !
   !		   ! Core !
   !		   +------+
   !	   +----------!---------+
   !	   !	      !		!
   !	+------+   +-----+   +------+
   +--> ! HSI  !   ! TTY !   ! USB  !	<- 链路层（Net设备）
	+------+   +-----+   +------+


实现
==============

CAIF 核心协议层
------------------------

CAIF 核心层实现了由 ST-Ericsson 定义的 CAIF 协议。它采用分层的方法来实现 CAIF 协议栈，其中规范中的每一层都作为一个单独的层来实现。其架构受到设计模式“协议层”和“协议包”的启发。

CAIF 结构
^^^^^^^^^^^^^^

核心 CAIF 实现包含：

      - 简单的 CAIF 实现
- 分层架构（类似 Streams），CAIF 规范中的每一层都在一个单独的 C 文件中实现
客户端必须调用配置函数来添加 PHY 层  
客户端必须实现 CAIF 层以消费/生成带有接收和发送功能的 CAIF 负载  
客户端必须调用配置函数来添加并连接客户端层  
在接收/发送 CAIF 数据包（cfpkt）时，所有权将传递给被调用的函数（除帧处理层的接收函数外）

分层架构
====================

CAIF 协议可以分为两部分：支持功能和协议实现。支持功能包括：

- CFPKT CAIF 数据包。实现 CAIF 协议数据包。CAIF 数据包具有创建、销毁和添加内容的功能，并且可以向协议数据包中添加/提取头部和尾部。

CAIF 协议实现包含：

- CFCNFG CAIF 配置层。配置 CAIF 协议栈，并提供一个客户端接口以在 CAIF 栈上添加链路层和驱动接口。
- CFCTRL CAIF 控制层。编码和解码控制消息，如枚举和信道设置。同时匹配请求和响应消息。
- CFSERVL 通用 CAIF 服务层功能；处理流控制和远程关闭请求。
- CFVEI CAIF VEI 层。处理 VEI（虚拟外部接口）上的 CAIF AT 信道。该层编码/解码 VEI 帧。
- CFDGML CAIF 数据报层。处理 CAIF 数据报层（IP 流量），编码/解码数据报帧。
- CFMUX CAIF 复用层。处理多个物理承载和多个信道（如 VEI、数据报等）之间的复用。
MUX 跟踪现有的 CAIF 通道和物理实例，并根据 Channel-Id 和 Physical-ID 选择合适的实例。
- CFFRML CAIF 帧层。处理帧，即帧长度和帧校验和。
- CFSERL CAIF 串行层。处理帧的拼接/拆分以形成正确长度的 CAIF 帧。

```
           +---------+
           | Config  |
           | CFCNFG  |
           +---------+
                !
    +---------+    +---------+    +---------+
    | AT     |    | Control |    | Datagram|
    | CFVEIL |    | CFCTRL  |    | CFDGML  |
    +---------+    +---------+    +---------+
       \_________________________/
                !
           +---------+
           | MUX     |
           |         |
           +---------+
           _____!_____
          /          \
    +---------+    +---------+
    | CFFRML  |    | CFFRML  |
    | Framing |    | Framing |
    +---------+    +---------+
        !        !
    +---------+    +---------+
    |         |    | Serial  |
    |         |    | CFSERL  |
    +---------+    +---------+
```

在这种分层方法中，以下“规则”适用：
- 所有层都嵌入了相同的结构 "struct cflayer"
  - 一个层不依赖于任何其他层的私有数据
- 层通过设置指针进行堆叠：

        layer->up , layer->dn

  - 为了向上发送数据，每个层应执行如下操作：

        layer->up->receive(layer->up, packet);

  - 为了向下发送数据，每个层应执行如下操作：

        layer->dn->transmit(layer->dn, packet);

CAIF 套接字和 IP 接口
======================

IP 接口和 CAIF 套接字 API 是在 CAIF 核心协议的基础上实现的。IP 接口和 CAIF 套接字有一个 'struct cflayer' 的实例，就像 CAIF 核心协议栈一样。
网卡设备和套接字实现了 'struct cflayer' 定义的 'receive()' 函数，就像 CAIF 栈中的其他部分一样。这样，数据包的传输和接收与其他层一样处理：调用 'dn->transmit()' 函数来传输数据。

链路层配置
---------------------
链路层作为 Linux 网络设备（struct net_device）实现。有效载荷处理和注册使用标准的 Linux 机制。
CAIF 协议依赖于无丢包的链路层，但不实现重传。这意味着不允许丢弃数据包。
因此，实现了一种流量控制机制，其中物理接口可以发起对所有CAIF通道的流量停止。
