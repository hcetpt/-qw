SPDX 许可声明标识符: GPL-2.0

===
RDS
===

概述
========

本说明文档旨在提供一些关于 RDS 的背景信息，解释其工作原理和原因，并希望能帮助您理解代码。此外，请参阅以下电子邮件以了解 RDS 的起源：
http://oss.oracle.com/pipermail/rds-devel/2007-November/000228.html

RDS 架构
================

RDS 通过在集群中的任意两个节点之间建立一个可靠的连接来提供可靠有序的数据报传输。这使得应用程序可以通过单个套接字与集群中的任何其他进程通信——因此，在包含 N 个进程的集群中，您只需要 N 个套接字，而使用基于连接的套接字传输（如 TCP）则需要 N*N 个。

RDS 并不是针对 InfiniBand 特定设计的；它被设计为支持不同的传输方式。当前实现支持通过 TCP 和 IB 使用 RDS。

从应用程序的角度来看，RDS 的高层次语义包括：

 * 地址

    RDS 使用 IPv4 地址和 16 位端口号来标识连接的终点。所有涉及内核和用户空间之间传递地址的套接字操作通常使用 `struct sockaddr_in` 结构体。
    使用 IPv4 地址并不意味着底层传输必须是基于 IP 的。实际上，RDS 在 IB 上使用的是一个可靠的 IB 连接；IPv4 地址仅用于定位远程节点的 GID（通过 ARP 查询给定的 IP）。
    端口空间完全独立于 UDP、TCP 或任何其他协议。

 * 套接字接口

    RDS 套接字基本上按照 BSD 套接字的方式工作。下一节将详细讲解这些细节。无论如何，所有的 I/O 操作都是通过标准的 BSD 套接字 API 完成的。
    一些额外的功能，如零拷贝支持，通过控制消息实现，而其他扩展则使用 `getsockopt` 和 `setsockopt` 调用。
    在发送或接收数据之前，必须绑定套接字。
    这是因为绑定还选择了传输方式并将其附加到套接字上。一旦绑定，传输方式的分配就不会改变。RDS 可以容忍 IP 地址的变化（例如在主-主高可用场景中），但前提是地址不会移动到不同的传输方式上。
* `sysctls`

RDS 支持在 `/proc/sys/net/rds` 中的多个 `sysctls`。

Socket 接口
===========

  `AF_RDS`, `PF_RDS`, `SOL_RDS`
`AF_RDS` 和 `PF_RDS` 是与 `socket(2)` 一起使用的域类型，用于创建 RDS 套接字。`SOL_RDS` 是与 `setsockopt(2)` 和 `getsockopt(2)` 一起使用的套接字级别，用于 RDS 特定的套接字选项。
```c
fd = socket(PF_RDS, SOCK_SEQPACKET, 0);
```
这将创建一个新的未绑定的 RDS 套接字。
`setsockopt(SOL_SOCKET)`：发送和接收缓冲区大小
RDS 遵守发送和接收缓冲区大小的套接字选项。
不允许你向一个套接字排队超过 `SO_SNDSIZE` 字节的数据。当调用 `sendmsg` 时消息被排队，并且当远程系统确认其到达时消息离开队列。
`SO_RCVSIZE` 选项控制最大接收队列长度。
这是一个软限制而不是硬限制 —— 即使队列长度超过了限制，RDS 也会继续接受并排队传入的消息。但是，它也会将端口标记为“拥塞”，并向源节点发送一个拥塞更新。源节点应该限制任何向这个拥塞端口发送数据的过程。
```c
bind(fd, &sockaddr_in, ...)
```
这将套接字绑定到本地 IP 地址、端口以及传输协议（如果尚未通过 `SO_RDS_TRANSPORT` 套接字选项选择的话）。

  `sendmsg(fd, ...)`
向指定的接收者发送一条消息。如果底层的可靠连接尚未建立，内核将透明地建立该连接。
尝试发送一条超出 `SO_SNDSIZE` 的消息将返回 `-EMSGSIZE`。
尝试发送一条消息，如果这条消息会导致排队中的总字节数超过 `SO_SNDSIZE` 的阈值，则会返回 `EAGAIN`。
尝试向一个被标记为“拥塞”的目的地发送消息将返回 `ENOBUFS`。
```c
recvmsg(fd, ...)
```
接收排队到此套接字的消息。调整套接字的接收队列计数，并且如果队列长度低于 `SO_SNDSIZE`，则将端口标记为不拥塞，并向所有对等节点发送一个拥塞更新。
应用程序可以请求RDS内核模块通过控制消息接收通知（例如，当拥塞更新到达或RDMA操作完成时会有通知）。这些通知是通过`struct msghdr`中的`msg.msg_control`缓冲区接收的。消息的格式在手册页中有描述。

`poll(fd)`
RDS支持poll接口，允许应用程序实现异步I/O。

处理`POLLIN`非常直接。当有传入的消息排队到套接字或有挂起的通知时，我们发出`POLLIN`信号。

处理`POLLOUT`稍微复杂一些。由于你基本上可以发送到任何目的地，只要发送队列有足够的空间（即已排队的字节数小于发送缓冲区大小），RDS就会一直发出`POLLOUT`信号。

然而，内核会拒绝接受发送到标记为拥塞的目的地的消息——在这种情况下，如果你依赖poll来指导你的操作，将会无限循环。

这不是一个简单的问题，但应用程序可以通过使用拥塞通知和检查`sendmsg`返回的`ENOBUFS`错误来应对这个问题。

`setsockopt(SOL_RDS, RDS_CANCEL_SENT_TO, &sockaddr_in)`
这允许应用程序丢弃在此特定套接字上排队到某个特定目的地的所有消息。

如果应用程序检测到超时，它可以取消未完成的消息。例如，如果尝试发送消息，但远程主机无法到达，RDS将一直尝试下去。

应用程序可能会决定这样做不值得，并取消该操作。在这种情况下，它将使用`RDS_CANCEL_SENT_TO`来删除任何挂起的消息。

```
setsockopt(fd, SOL_RDS, SO_RDS_TRANSPORT, (int *)&transport ..),
getsockopt(fd, SOL_RDS, SO_RDS_TRANSPORT, (int *)&transport ..)
```
设置或读取一个整数，定义用于套接字上的RDS数据包所使用的底层封装传输方式。设置此选项时，整数参数可以是`RDS_TRANS_TCP`或`RDS_TRANS_IB`。检索值时，未绑定的套接字将返回`RDS_TRANS_NONE`。
此套接字选项只能在通过 `bind(2)` 系统调用绑定套接字之前准确设置一次。尝试在一个已经显式（通过 `SO_RDS_TRANSPORT`）或隐式（通过 `bind(2)`）指定了传输方式的套接字上设置 `SO_RDS_TRANSPORT` 将返回 `EOPNOTSUPP` 错误。

将 `SO_RDS_TRANSPORT` 设置为 `RDS_TRANS_NONE` 始终会返回 `EINVAL` 错误。

### RDS 的 RDMA 支持

详情请参阅 `rds-rdma(7)` 手册页（可在 rds-tools 中找到）。

### 拥塞通知

详情请参阅 `rds(7)` 手册页。

### RDS 协议

#### 消息头

消息头是一个 `struct rds_header`（参见 rds.h）：

字段：

- `h_sequence`：每个数据包的序列号。
- `h_ack`：捎带的对最近收到的数据包的确认。
- `h_len`：数据长度，不包括头部。
- `h_sport`：源端口。
- `h_dport`：目的端口。
- `h_flags`：可能的标志位：
  - `CONG_BITMAP`：这是一个拥塞更新位图。
  - `ACK_REQUIRED`：接收方必须确认此数据包。
  - `RETRANSMITTED`：此数据包已先前发送过。
- `h_credit`：指示连接另一端有更多的信用额度可用（即有更多发送空间）。
- `h_padding[4]`：未使用，供将来使用。
- `h_csum`：头部校验和。
- `h_exthdr`：可选数据可通过这里传递。目前用于传递 RDMA 相关信息。

#### ACK 和重传处理

可能会认为，在使用可靠的 InfiniBand 连接时，无需确认已收到的消息。问题是 InfiniBand 硬件在 DMA 消息到内存之前就生成了确认消息。这导致如果在发送确认消息和消息 DMA 到内存并被处理之间禁用了 HCA，则有可能丢失消息。这仅在另一个 HCA 可用于故障切换时成为潜在问题。

立即发送确认消息可以让发送方快速从其发送队列中释放已发送的消息，但可能会导致大量确认流量。RDS 将确认消息附带在发送的数据包中。仅允许一个单独的确认数据包在飞行中，并且只有当发送方的发送缓冲区开始填满时才请求确认。所有重传数据包也会被确认。

#### 流量控制

RDS 的 InfiniBand 传输层使用基于信用的机制来验证对端的接收缓冲区是否有空间接收更多的数据。这消除了连接上的硬件重试需求。

#### 拥塞

接收套接字接收队列中等待的消息会根据套接字的 `SO_RCVBUF` 选项值进行统计。只有消息的有效载荷字节会被统计。如果排队的字节数等于或超过 `rcvbuf`，则该套接字处于拥塞状态。所有试图向此套接字地址发送的数据应返回阻塞或 `-EWOULDBLOCK`。

应用程序应该调整得当，使这种情况极少发生。遇到这种“反压”的应用程序被视为存在缺陷。

这是通过让每个节点维护位图实现的，这些位图表示哪些绑定地址上的端口处于拥塞状态。随着位图的变化，它将通过终止于位图发生变化的本地地址的所有连接发送。

位图在建立连接时分配。这避免了在处理中断路径中的分配，该路径会在套接字上排队消息。密集的位图使得传输层可以合理高效地在任何位图变化时发送整个位图。这比更细粒度的端口拥塞通信更容易实现。发送方只需执行非常廉价的位检测即可判断即将发送的端口是否处于拥塞状态。
RDS 传输层
===================

如上所述，RDS 并不局限于 InfiniBand（IB）。其代码分为通用的 RDS 层和传输层。通用层负责处理套接字 API、拥塞控制、回环、统计信息、用户内存固定以及连接状态机。传输层则处理具体的传输细节。例如，IB 传输层负责处理所有的队列对、工作请求、CM 事件处理器以及其他 InfiniBand 的细节。

RDS 内核结构
=====================

`struct rds_message`
    也称为“rds_outgoing”，通用 RDS 层复制要发送的数据并根据套接字 API 设置所需的头部字段。然后该数据被排队等待由特定连接的传输层发送。

`struct rds_incoming`
    一个泛指的结构体，用于处理从传输层传递到通用代码的传入数据，并由通用代码在唤醒套接字时进行排队。然后将其传递回传输层以处理实际的用户复制操作。

`struct rds_socket`
    每个套接字的信息。

`struct rds_connection`
    每个连接的信息。

`struct rds_transport`
    指向特定传输功能的指针。

`struct rds_statistics`
    非传输相关的统计信息。

`struct rds_cong_map`
    包含原始拥塞位图，包含 rbnode、waitq 等。

连接管理
=====================

连接可能处于 UP（已连接）、DOWN（未连接）、CONNECTING（正在连接）、DISCONNECTING（正在断开）和 ERROR（错误）状态。
当 RDS 套接字首次尝试向节点发送数据时，会分配并建立一个连接。此连接将永久保持——如果出现传输错误，连接会被丢弃并重新建立。
在有数据包排队时丢弃连接会导致排队或部分发送的数据报在连接重新建立后被重传。
发送路径
=============

  rds_sendmsg()
    - 从传入数据构建struct rds_message
    - 解析CMSG（例如RDMA操作）
    - 如果尚未分配和连接，则分配并连接传输连接
    - 将rds_message放置在发送队列上
    - 唤醒发送工作线程

  rds_send_worker()
    - 调用rds_send_xmit()直到队列为空

  rds_send_xmit()
    - 如果有待处理的拥塞图，则进行传输
    - 可能设置ACK_REQUIRED
    - 调用传输层发送非RDMA或RDMA消息（RDMA操作永不重传）

  rds_ib_xmit()
    - 从发送环分配工作请求
    - 添加任何新的发送信用到对等端（h_credits）
    - 映射rds_message的sg列表
    - 捆绑确认
    - 填充工作请求
    - 向连接的队列对发布发送请求

接收路径
=============

  rds_ib_recv_cq_comp_handler()
    - 查看写完成情况
    - 从设备中取消映射接收缓冲区
    - 如果没有错误，调用rds_ib_process_recv()
    - 重新填充接收环

  rds_ib_process_recv()
    - 验证报头校验和
    - 如果是新数据报的开始，将报头复制到rds_ib_incoming结构体
    - 添加到ibinc的fraglist
    - 如果已完成的数据报：
      - 如果是拥塞更新则更新拥塞图
      - 否则调用rds_recv_incoming()
      - 记录是否需要确认

  rds_recv_incoming()
    - 丢弃重复包
    - 响应ping
    - 找到与此数据报关联的sock
    - 添加到sock队列
    - 唤醒sock
    - 进行一些拥塞计算

  rds_recvmsg
    - 将数据复制到用户iovec
    - 处理CMSG
    - 返回给应用程序

多路径RDS（mprds）
=====================
  mprds是多路径RDS，主要用于RDS-over-TCP（尽管这一概念可以扩展到其他传输方式）。传统的RDS-over-TCP实现方法是在两个端点之间通过单个TCP套接字解复用多个PF_RDS套接字（其中端点==[IP地址，端口]）。这导致了将多个RDS流汇聚到一个TCP流中，因此它存在以下局限性：
  (a) 上限受限于单一流量带宽，
  (b) 对所有RDS套接字造成头部阻塞问题。

对于固定的小包大小（MTU），可以通过每个rds/tcp连接使用多个TCP/IP流来提高吞吐量，即多路径RDS（mprds）。每个这样的TCP/IP流构成rds/tcp连接的一个路径。RDS套接字将根据某些哈希（例如本地地址和RDS端口号）绑定到一个路径，并且该RDS套接字的包将通过TCP在该路径上分段/重组。

多路径RDS通过将struct rds_connection拆分为公共部分（对所有路径通用）和每个路径的struct rds_conn_path来实现。所有I/O工作队列和重连线程都由rds_conn_path驱动。

支持多路径的传输（如TCP）可以为每个rds_conn_path设置一个TCP套接字，这由传输通过传输私有指针cp_transport_data管理。

传输通过在注册时设置t_mp_capable标志来声明其支持多路径。当传输支持多路径时，rds_sendmsg()会将传出流量哈希到多个路径上。哈希值基于PF_RDS套接字绑定的本地地址和端口计算得出。

此外，即使传输支持MP，我们也可能与不支持mprds或支持不同路径数的节点通信。因此，对等节点需要就连接所使用的路径数量达成一致。

这是通过在第一个数据包之前发送控制包交换来完成的。控制包交换必须在rds_sendmsg()完成哈希输出时完成，如果传输支持多路径的话。

控制包是一个RDS ping包（即发送到rds目标端口0的包），该ping包具有一个类型为RDS_EXTHDR_NPATHS、长度为2字节的RDS扩展头选项，其值为发送方支持的路径数。探针ping包将从某个预留端口RDS_FLAG_PROBE_PORT（在<linux/rds.h>中定义）发出。

收到从RDS_FLAG_PROBE_PORT发出的ping包的接收方能够立即计算出min(发送方路径数, 接收方路径数)。响应探针ping的pong应该包含接收方的npaths，如果接收方支持mprds的话。

如果接收方不支持mprds，则忽略ping中的exthdr。在这种情况下，pong将没有任何exthdr，因此发送探针ping的一方可以默认使用单路径mprds。
