### SPDX 许可证标识符: GPL-2.0

####

#### RDS

####

##### 概览

本说明文档旨在提供关于 RDS 的工作原理及其设计初衷的一些背景信息，希望能帮助您更好地理解代码。此外，请参阅以下邮件了解 RDS 的起源：
http://oss.oracle.com/pipermail/rds-devel/2007-November/000228.html

#### RDS 架构

RDS 通过在集群中的任意两个节点之间建立一个可靠的连接来提供可靠有序的数据报传输服务。这使得应用程序能够使用单一的套接字与集群内的任何其他进程进行通信 —— 因此，在包含 N 个进程的集群中，你只需要 N 个套接字，相比之下，如果使用如 TCP 这样的面向连接的套接字传输方式，则需要 N*N 个套接字。
RDS 并非专为 InfiniBand 设计；它被设计为支持不同的传输层协议。当前的实现既支持基于 TCP 的 RDS，也支持基于 InfiniBand 的 RDS。
从应用程序的角度来看，RDS 提供的高级语义包括：

* **寻址**

    RDS 使用 IPv4 地址和 16 位端口号来标识连接的终点。所有涉及内核和用户空间间地址传递的套接字操作通常使用 `struct sockaddr_in` 结构体。
    使用 IPv4 地址并不意味着底层传输必须基于 IP。实际上，RDS 在 InfiniBand 上的工作方式是使用可靠的 InfiniBand 连接；IPv4 地址仅用于定位远程节点的全局标识符（GID），通过 ARP 协议查询给定的 IP 地址。
    端口空间完全独立于 UDP、TCP 或任何其他协议。

* **套接字接口**

    RDS 套接字的工作方式与您期望的 BSD 套接字大致相同。下一节将详细说明。无论如何，所有的输入输出都是通过标准的 BSD 套接字 API 完成的。
    零拷贝等一些扩展功能通过控制消息实现，而其他扩展则使用 `getsockopt` 和 `setsockopt` 调用。
    发送或接收数据前，套接字必须绑定到地址。
    这是因为绑定时也会选择传输层并将其附加到套接字上。一旦绑定，传输层的分配就不会改变。RDS 能够容忍 IP 地址的变化（例如，在主动-主动高可用性场景中），但前提是这些地址不能移动到不同的传输层。
*RDS 支持多个 sysctls，位于 /proc/sys/net/rds 中。

### 套接字接口
####

  * **AF_RDS**, **PF_RDS**, **SOL_RDS**
    * **AF_RDS** 和 **PF_RDS** 是用于与 `socket(2)` 结合创建 RDS 套接字的域类型。
    * **SOL_RDS** 是用于与 `setsockopt(2)` 和 `getsockopt(2)` 结合设置 RDS 特定套接字选项的套接字级别。
    
```c
fd = socket(AF_RDS, SOCK_SEQPACKET, 0);
```
    * 这将创建一个新的未绑定的 RDS 套接字。
* `setsockopt(SOL_SOCKET)`: 发送和接收缓冲区大小
    * RDS 考虑发送和接收缓冲区大小的套接字选项。
    * 不允许向一个套接字排队超过 `SO_SNDSIZE` 字节的数据。当调用 `sendmsg` 时消息被排队，并且在远程系统确认消息到达后离开队列。
* `SO_RCVSIZE` 选项控制最大接收队列长度。
    * 这是一个软限制而非硬性限制 —— 即使接收队列长度超过了限制，RDS 仍将继续接受并排队传入的消息。但是，它也会标记该端口为“拥塞”状态，并向源节点发送拥塞更新。源节点应该对向这个拥塞端口发送数据的任何进程进行限速。
* `bind(fd, &sockaddr_in, ...)`
    * 将套接字绑定到本地 IP 地址、端口以及传输方式（如果尚未通过 `SO_RDS_TRANSPORT` 套接字选项选择的话）。
* `sendmsg(fd, ...)`
    * 向指定接收方发送一条消息。内核会透明地建立底层可靠连接（如果还未建立的话）。
    * 尝试发送超出 `SO_SNDSIZE` 的消息将返回 `-EMSGSIZE` 错误。
    * 尝试发送会使已排队字节数总和超过 `SO_SNDSIZE` 阈值的消息将返回 `EAGAIN`。
    * 尝试向被标记为“拥塞”的目的地发送消息将返回 `ENOBUFS`。
* `recvmsg(fd, ...)`
    * 接收被排队到此套接字的消息。调整该套接字的 `recv` 队列统计信息，如果队列长度降至 `SO_SNDSIZE` 以下，则端口被标记为非拥塞状态，并向所有对等节点发送拥塞更新。
应用程序可以请求RDS内核模块通过控制消息接收通知（例如，拥塞更新到达时或RDMA操作完成时会有通知）。这些通知是通过`struct msghdr`中的`msg.msg_control`缓冲区接收的。消息的格式在手册页中有所描述。

`poll(fd)`
RDS支持poll接口以允许应用程序实现异步I/O。
对于`POLLIN`的处理非常直接。当有传入的消息排队到套接字或者有挂起的通知时，我们就会发出`POLLIN`信号。
`POLLOUT`稍微复杂一些。由于你基本上可以向任何目的地发送信息，只要发送队列有足够的空间（即排队的数据量小于sendbuf大小），RDS就会一直发出`POLLOUT`信号。
然而，内核会拒绝接受发往被标记为拥塞的目的地的消息——在这种情况下，如果你依赖poll来决定下一步行动的话，将会陷入无限循环。
这不是一个简单的问题，但应用程序可以通过使用拥塞通知以及检查`sendmsg`返回的`ENOBUFS`错误来处理这种情况。

`setsockopt(SOL_RDS, RDS_CANCEL_SENT_TO, &sockaddr_in)`
这使得应用程序能够丢弃在此特定套接字上排队到某个特定目的地的所有消息。
如果应用程序检测到超时，则可以取消未决消息。例如，如果它尝试发送一条消息，而远程主机无法到达，RDS将永远尝试下去。
应用程序可能会认为这样做不值得，并取消该操作。在这种情况下，它将使用`RDS_CANCEL_SENT_TO`来清除所有待处理的消息。

`setsockopt(fd, SOL_RDS, SO_RDS_TRANSPORT, (int *)&transport ..), getsockopt(fd, SOL_RDS, SO_RDS_TRANSPORT, (int *)&transport ..)`
设置或读取一个整数，定义用于套接字上的RDS数据包的基础封装传输方式。设置此选项时，整数参数可以是`RDS_TRANS_TCP`或`RDS_TRANS_IB`。检索值时，在未绑定的套接字上将返回`RDS_TRANS_NONE`。
此套接字选项仅能在通过 `bind(2)` 系统调用绑定之前，在套接字上确切地设置一次。尝试在已经显式（通过 `SO_RDS_TRANSPORT`）或隐式（通过 `bind(2)`）附加了传输方式的套接字上设置 `SO_RDS_TRANSPORT` 将返回一个 `EOPNOTSUPP` 错误。
将 `SO_RDS_TRANSPORT` 设置为 `RDS_TRANS_NONE` 的尝试总是返回 `EINVAL`。

RDS 的 RDMA
=============

请参阅 `rds-rdma(7)` 手册页（在 rds-tools 中可用）。

拥塞通知
==============

请参阅 `rds(7)` 手册页。

RDS 协议
=============

消息头

消息头是一个 `struct rds_header` （见 rds.h）：

字段：

- `h_sequence`: 每个数据包的序列号
- `h_ack`: 对收到的最后一个数据包的捆绑确认
- `h_len`: 数据长度，不包括头部
- `h_sport`: 源端口
- `h_dport`: 目标端口
- `h_flags`: 可以是：

| 标志       | 解释                                       |
|------------|--------------------------------------------|
| CONG_BITMAP| 这是一个拥塞更新位图                       |
| ACK_REQUIRED| 接收方必须确认此数据包                     |
| RETRANSMITTED| 数据包已被先前发送过                       |

- `h_credit`: 向连接的另一端表明有更多的信用额度可用（即有更多可发送的空间）
- `h_padding[4]`: 未使用，供将来使用
- `h_csum`: 头部校验和
- `h_exthdr`: 可选数据可以在这里传递。目前用于传递与 RDMA 相关的信息

确认与重传处理

人们可能认为有了可靠的 IB 连接就不需要对已接收的消息进行确认了。问题是 IB 硬件会在将消息 DMA 到内存之前生成确认消息。这在 HCA 因任何原因在发送确认和消息 DMA 并被处理之间被禁用的情况下可能导致潜在的消息丢失。这只有在另一个 HCA 可用于故障转移时才成为一个潜在问题。
立即发送确认可以让发送者快速地从其发送队列中释放已发送的消息，但可能会导致确认消息的过度使用。RDS 将确认捆绑在发送的数据包上。只允许一个确认包处于飞行状态，并且只有当发送者的缓冲区开始填满时才会请求确认。所有重传的数据包也都会被确认。

流量控制

RDS 的 IB 传输使用基于信用的机制来验证对方接收缓冲区是否有空间接收更多的数据。这消除了连接上的硬件重试的需求。

拥塞

接收套接字接收队列中等待的消息会根据套接字的 `SO_RCVBUF` 选项值进行计数。只有消息的有效载荷字节会被计入。如果排队的字节数等于或超过 `rcvbuf`，则该套接字被认为处于拥塞状态。所有试图向此套接字地址发送的消息都应该阻塞或返回 `-EWOULDBLOCK`。
期望应用程序合理调整，使得这种情况极少发生。遇到这种“反压”的应用程序被认为是存在缺陷。
这是通过每个节点维护位图实现的，这些位图指示哪些绑定地址上的端口处于拥塞状态。随着位图的变化，它将通过终止于位图更改的本地地址的所有连接发送。
位图是在建立连接时分配的。这避免了在处理排队到套接字上的消息的中断路径中进行分配。密集的位图让传输层能够有效地在任何位图变化时发送整个位图。这比更精细粒度的每端口拥塞通信更容易实现。发送方只需进行非常简单的位检测即可判断即将发送到的端口是否处于拥塞状态。
RDS 传输层
===================

如上所述，RDS 不是特定于 IB 的。它的代码分为一个通用的 RDS 层和一个传输层。
通用层处理套接字 API、拥塞处理、环回、统计信息、用户内存固定以及连接状态机。
传输层处理传输的具体细节。例如，IB 传输处理所有队列对、工作请求、CM 事件处理器和其他 InfiniBand 细节。

RDS 内核结构
=====================

`struct rds_message`
也可能是“rds_outgoing”，通用 RDS 层复制要发送的数据并根据套接字 API 设置所需的头部字段。然后为每个连接排队，并由该连接的传输层发送。
`struct rds_incoming`
一个通用结构体，指代可以从传输层传递给通用代码的传入数据，并被通用代码排队直至套接字被唤醒。之后再交还给传输层代码来处理实际的用户复制操作。
`struct rds_socket`
每个套接字的信息。
`struct rds_connection`
每个连接的信息。
`struct rds_transport`
指向传输特定函数的指针。
`struct rds_statistics`
非传输特定的统计信息。
`struct rds_cong_map`
封装原始拥塞位图，包含 rbnode、等待队列等。

连接管理
=====================

连接可能处于 UP（激活）、DOWN（关闭）、CONNECTING（正在建立连接）、DISCONNECTING（正在断开连接）和 ERROR（错误）状态。
当 RDS 套接字首次尝试向节点发送数据时，会分配并建立一个连接。此连接将永久维持——如果出现传输错误，连接会被丢弃并重新建立。
在有数据包排队的情况下丢弃连接会导致已排队或部分发送的数据报在连接重新建立后被重传。
发送路径
=============

rds_sendmsg()
    - 从传入的数据构建 `struct rds_message`
    - 解析 CMSG（例如 RDMA 操作）
    - 如果尚未分配和连接，则分配并连接传输连接
    - 将 `rds_message` 放到发送队列上
    - 唤醒发送工作线程

rds_send_worker()
    - 调用 rds_send_xmit() 直到队列为空

rds_send_xmit()
    - 如果有待处理的拥塞图，则进行传输
    - 可能设置 ACK_REQUIRED
    - 调用传输层发送非 RDMA 或 RDMA 消息
      （RDMA 操作从不重传）

rds_ib_xmit()
    - 从发送环分配工作请求
    - 添加任何新可用的发送信用给对等端（h_credits）
    - 映射 `rds_message` 的 sg 列表
    - 捎带确认
    - 填充工作请求
    - 向连接的队列对发送

接收路径
=============

rds_ib_recv_cq_comp_handler()
    - 查看写完成情况
    - 从设备取消映射接收缓冲区
    - 若无错误，则调用 rds_ib_process_recv()
    - 重新填充接收环

rds_ib_process_recv()
    - 验证报头校验和
    - 如果是新数据报的开始，将报头复制到 rds_ib_incoming 结构体中
    - 添加到 ibinc 的 fraglist 中
    - 如果是已完成的数据报：
        - 如果数据报是拥塞更新，则更新拥塞图
        - 否则调用 rds_recv_incoming()
        - 记录是否需要确认

rds_recv_incoming()
    - 丢弃重复的数据包
    - 响应 ping 请求
    - 找到与此数据报关联的套接字
    - 添加到套接字队列
    - 唤醒套接字
    - 进行一些拥塞计算

rds_recvmsg
    - 将数据复制到用户 iovec 中
    - 处理 CMSG
    - 返回给应用程序

多路径 RDS (mprds)
=====================
  Mprds 是多路径 RDS，主要用于 RDS-over-TCP
  （尽管这一概念可以扩展到其他传输方式）。传统的 RDS-over-TCP 实现是通过在两个端点之间（其中端点 == [IP 地址, 端口]）的单个 TCP 套接字上复用多个 PF_RDS 套接字来实现。这存在局限性，因为最终会将多个 RDS 流汇聚到一个 TCP 流中，因此：
  (a) 上限受限于单一流带宽，
  (b) 对所有 RDS 套接字产生头部阻塞问题
对于固定小包大小（MTU），可以通过为每个 rds/tcp 连接提供多个 TCP/IP 流来提高吞吐量，即采用多路径 RDS（mprds）。每个这样的 TCP/IP 流构成 rds/tcp 连接的一个路径。RDS 套接字将根据某种哈希（例如本地地址和 RDS 端口号）附加到某个路径，并且该路径上的 RDS 数据报将使用 TCP 来分段/重组。
多路径 RDS 通过将 `struct rds_connection` 分解为所有路径共有的部分以及每个路径特有的 `struct rds_conn_path` 来实现。所有 I/O 工作队列和重新连接线程都由 `rds_conn_path` 驱动。
如 TCP 这样的多路径传输可以为每个 `rds_conn_path` 设置一个 TCP 套接字，并且这些是由传输层通过 `cp_transport_data` 指针管理的。
传输层通过在向 RDS 核心模块注册时设置 `t_mp_capable` 位来宣布自己支持多路径能力。当传输层支持多路径时，rds_sendmsg() 将根据本地地址和 PF_RDS 套接字绑定的端口来散列传出流量。
此外，即使传输层支持多路径，我们可能正在与不支持 mprds 或支持不同数量路径的节点通信。因此，对等节点需要就连接使用的路径数达成一致。
这是通过在第一个数据包之前发送控制包交换来完成的。当传输层支持多路径时，控制包交换必须在 rds_sendmsg() 完成传出哈希之前完成。
控制包是一个 RDS ping 包（即，发送到 RDS 目的地端口 0 的包），该 ping 包具有类型为 RDS_EXTHDR_NPATHS、长度为 2 字节的 RDS 扩展报头选项，其值为发送方支持的路径数。该“探测”ping 包将从一个预留端口 RDS_FLAG_PROBE_PORT（在 <linux/rds.h> 中定义）发送。
接收到从 RDS_FLAG_PROBE_PORT 发送的 ping 的接收方可以立即计算出 min(发送方路径数, 接收方路径数)。响应探测 ping 的 pong 应包含接收方的路径数，如果接收方支持 mprds。
如果接收方不支持 mprds，ping 中的扩展报头将被忽略。在这种情况下，pong 不会有任何扩展报头，因此发送探测 ping 的一方可以默认使用单路径 mprds。
