SPDX 许可证标识符: GPL-2.0

===================
ICE Devlink 支持
===================

本文档描述了由 `ice` 设备驱动程序实现的 Devlink 功能。
参数
======

.. list-table:: 实现的一般参数
   :widths: 5 5 90

   * - 名称
     - 模式
     - 备注
   * - ``enable_roce``
     - 运行时
     - 与 ``enable_iwarp`` 互斥
   * - ``enable_iwarp``
     - 运行时
     - 与 ``enable_roce`` 互斥
   * - ``tx_scheduling_layers``
     - 永久
     - ICE 硬件使用层次调度来处理发送数据包，并且调度树有固定的层数。每一层都是一个决策点。根节点代表端口，而所有叶子节点则代表队列。通过这种方式配置发送调度器，使得诸如 DCB 或 Devlink-rate（如下所述）等功能可以配置分配给特定队列或队列组的带宽，从而实现精细控制，因为可以在树中的任何一层配置调度参数。
默认的九层树拓扑被认为对大多数工作负载来说是最好的，因为它提供了性能与可配置性的最佳比率。然而，在某些特定情况下，这种九层拓扑可能并不适用。例如，向不是8的倍数的队列发送流量。由于九层拓扑的最大基数限制为8，第九个队列与其他队列有不同的父节点，并被分配更多的带宽信用。当系统向9个队列发送流量时，这会造成问题：

       | tx_queue_0_packets: 24163396
       | tx_queue_1_packets: 24164623
       | tx_queue_2_packets: 24163188
       | tx_queue_3_packets: 24163701
       | tx_queue_4_packets: 24163683
       | tx_queue_5_packets: 24164668
       | tx_queue_6_packets: 23327200
       | tx_queue_7_packets: 24163853
       | tx_queue_8_packets: 91101417 < 从第9个队列发送过多流量

       为了解决这一需求，您可以切换到五层拓扑，这样将最大拓扑基数改为512。通过此增强功能，所有队列都可以在树中分配给相同的父节点，因此其性能特性是相同的。此解决方案的明显缺点是树的配置深度较低。
使用 ``tx_scheduling_layer`` 参数和 Devlink 命令更改发送调度器拓扑。要使用五层拓扑，请使用值5。例如：
       $ devlink dev param set pci/0000:16:00.0 name tx_scheduling_layers
       value 5 cmode permanent
       使用值9将其重置为默认值
必须进行 PCI 插槽电源循环才能使选定的拓扑生效
验证值是否已设置：
       $ devlink dev param show pci/0000:16:00.0 name tx_scheduling_layers

.. list-table:: 实现的驱动特定参数
    :widths: 5 5 90

    * - 名称
      - 模式
      - 描述
    * - ``local_forwarding``
      - 运行时
      - 通过调整调度器带宽来控制回环行为
它影响所有类型的功能：物理、虚拟和子功能
支持的值为：

        ``enabled`` - 允许端口上的回环流量

        ``disabled`` - 不允许在此端口上进行回环流量

        ``prioritized`` - 在此端口上优先处理回环流量

        ``local_forwarding`` 参数的默认值为 ``enabled``
``prioritized`` 提供了调整回环流量速率的能力，以增加一个端口的容量，代价是另一个端口的容量。用户需要在一个端口上禁用本地转发，以便在 ``prioritized`` 端口上获得更高的容量
信息版本
=============

``ice`` 驱动程序报告了以下版本：

.. list-table:: devlink info versions implemented
    :widths: 5 5 5 90

    * - 名称
      - 类型
      - 示例
      - 描述
    * - ``board.id``
      - 固定
      - K65390-000
      - 板卡的产品板组件（PBA）标识符
    * - ``cgu.id``
      - 固定
      - 36
      - 时钟生成单元（CGU）硬件修订标识符
    * - ``fw.mgmt``
      - 运行中
      - 2.1.7
      - 设备上嵌入式管理处理器运行的管理固件的三位版本号。它控制 PHY、链路、访问设备资源等。Intel 文档中将其称为 EMP 固件
    * - ``fw.mgmt.api``
      - 运行中
      - 1.5.1
      - 通过 AdminQ 导出的管理固件 API 的三位版本号（主版本.次版本.修订版）。驱动程序用于识别支持哪些命令。历史版本的内核仅显示两位版本号（主版本.次版本）
    * - ``fw.mgmt.build``
      - 运行中
      - 0x305d955f
      - 管理固件源代码的唯一标识符
    * - ``fw.undi``
      - 运行中
      - 1.2581.0
      - 包含 UEFI 驱动程序的 Option ROM 的版本。版本号采用 ``主版本.次版本.修订版`` 格式。主版本在发生重大变更或次版本溢出时递增；次版本在非破坏性变更时递增，并在主版本递增时重置为 1；修订版本通常为 0，但在对旧基础 Option ROM 提供修复补丁时会递增
    * - ``fw.psid.api``
      - 运行中
      - 0.80
      - 定义闪存内容格式的版本
    * - ``fw.bundle_id``
      - 运行中
      - 0x80002ec0
      - 加载到设备上的固件映像文件的唯一标识符。也称为 NVM 的 EETRACK 标识符
    * - ``fw.app.name``
      - 运行中
      - ICE OS Default Package
      - 在设备中活动的 DDP 包的名称。DDP 包由驱动程序在初始化期间加载。每个 DDP 包变体都有一个唯一的名称
    * - ``fw.app``
      - 运行中
      - 1.3.1.0
      - 在设备中活动的 DDP 包的版本。注意，要唯一标识该包，需要同时提供名称（由 ``fw.app.name`` 报告）和版本号
* - ``fw.app.bundle_id``
      - 运行中
      - 0xc0000001
      - 加载在设备中的DDP包的唯一标识符。也称为DDP跟踪ID。可以用于唯一标识特定的DDP包。
* - ``fw.netlist``
      - 运行中
      - 1.1.2000-6.7.0
      - 网表模块的版本。此模块定义了设备的以太网功能和默认设置，并且由管理固件用于管理和链接设备连接。
* - ``fw.netlist.build``
      - 运行中
      - 0xee16ced7
      - 网表模块内容哈希值的前4个字节。
* - ``fw.cgu``
      - 运行中
      - 8032.16973825.6021
      - 时钟生成单元（CGU）的版本。格式：<CGU类型>.<配置版本>.<固件版本>

闪存更新
========

``ice`` 驱动实现了使用 ``devlink-flash`` 接口进行闪存更新的支持。它支持使用包含 ``fw.mgmt``、``fw.undi`` 和 ``fw.netlist`` 组件的组合闪存镜像来更新设备闪存。

.. list-table:: 支持的覆盖模式列表
   :widths: 5 95

   * - 位
     - 行为
   * - ``DEVLINK_FLASH_OVERWRITE_SETTINGS``
     - 不保留正在更新的闪存组件中存储的设置。这包括覆盖确定设备初始化时物理功能数量的端口配置。
   * - ``DEVLINK_FLASH_OVERWRITE_SETTINGS`` 和 ``DEVLINK_FLASH_OVERWRITE_IDENTIFIERS``
     - 不保留设置或标识符。用提供的镜像内容覆盖闪存中的所有内容，不执行任何保留。这包括覆盖设备识别字段，如MAC地址、VPD区域和设备序列号。预计这种组合将与为特定设备定制的镜像一起使用。

``ice`` 硬件不支持仅覆盖标识符同时保留设置，因此单独使用 ``DEVLINK_FLASH_OVERWRITE_IDENTIFIERS`` 将被拒绝。如果没有提供覆盖掩码，则在更新时会指示固件保留所有设置和识别字段。

重载
======

``ice`` 驱动支持在闪存更新后激活新固件，使用带有 ``DEVLINK_RELOAD_ACTION_FW_ACTIVATE`` 操作的 ``DEVLINK_CMD_RELOAD`` 命令。

.. code:: shell

    $ devlink dev reload pci/0000:01:00.0 reload action fw_activate

通过发出特定于设备的嵌入式管理处理器重置请求，新固件被激活，该请求要求设备重置并重新加载EMP固件镜像。
驱动程序当前不支持通过 `DEVLINK_RELOAD_ACTION_DRIVER_REINIT` 重新加载驱动程序。

端口拆分
========

`ice` 驱动程序仅支持对端口 0 进行拆分，因为固件为整个设备预定义了一组可用的端口拆分选项。需要系统重启才能应用端口拆分。以下命令将选择带有 4 个端口的端口拆分选项：

```shell
$ devlink port split pci/0000:16:00.0/0 count 4
```

每次执行 `split` 和 `unsplit` 命令后，所有可用的端口选项都会打印到动态调试中。第一个选项是默认选项。
```shell
ice 0000:16:00.0: 可用的端口拆分选项和最大端口速度 (Gbps)：
ice 0000:16:00.0: 状态  拆分数  四分之一 0          四分之一 1
ice 0000:16:00.0:         数量  L0  L1  L2  L3  L4  L5  L6  L7
ice 0000:16:00.0: 激活  2     100   -   -   - 100   -   -   -
ice 0000:16:00.0:         2      50   -  50   -   -   -   -   -
ice 0000:16:00.0: 待定  4      25  25  25  25   -   -   -   -
ice 0000:16:00.0:         4      25  25   -   -  25  25   -   -
ice 0000:16:00.0:         8      10  10  10  10  10  10  10  10
ice 0000:16:00.0:         1     100   -   -   -   -   -   -   -
```

可能存在多个具有相同端口拆分数的固件端口选项。当再次发出相同的端口拆分数请求时，将选择下一个具有相同端口拆分数的固件端口选项。
`devlink port unsplit` 将选择拆分数为 1 的选项。如果没有可用的拆分数为 1 的固件选项，则会收到错误。

区域
====

`ice` 驱动程序实现了以下区域以访问内部设备数据：

.. list-table:: 实现的区域
    :widths: 15 85

    * - 名称
      - 描述
    * - ``nvm-flash``
      - 整个闪存芯片的内容，有时称为设备的非易失性内存
    * - ``shadow-ram``
      - 从闪存开始加载的 Shadow RAM 的内容。尽管内容主要来自闪存，但该区域还包含设备启动过程中生成且未存储在闪存中的数据
    * - ``device-caps``
      - 设备固件功能缓冲区的内容。用于确定设备的当前状态和配置
``nvm-flash`` 和 ``shadow-ram`` 区域无需快照即可访问。``device-caps`` 区域需要快照，因为其内容是由固件发送的，并且无法拆分为单独的读取操作。用户可以通过 ``DEVLINK_CMD_REGION_NEW`` 命令请求立即捕获三个区域的快照。

```shell
$ devlink region show
pci/0000:01:00.0/nvm-flash: size 10485760 snapshot [] max 1
pci/0000:01:00.0/device-caps: size 4096 snapshot [] max 10

$ devlink region new pci/0000:01:00.0/nvm-flash snapshot 1
$ devlink region dump pci/0000:01:00.0/nvm-flash snapshot 1

$ devlink region dump pci/0000:01:00.0/nvm-flash snapshot 1
0000000000000000 0014 95dc 0014 9514 0035 1670 0034 db30
0000000000000010 0000 0000 ffff ff04 0029 8c00 0028 8cc8
0000000000000020 0016 0bb8 0016 1720 0000 0000 c00f 3ffc
0000000000000030 bada cce5 bada cce5 bada cce5 bada cce5

$ devlink region read pci/0000:01:00.0/nvm-flash snapshot 1 address 0 length 16
0000000000000000 0014 95dc 0014 9514 0035 1670 0034 db30

$ devlink region delete pci/0000:01:00.0/nvm-flash snapshot 1

$ devlink region new pci/0000:01:00.0/device-caps snapshot 1
$ devlink region dump pci/0000:01:00.0/device-caps snapshot 1
0000000000000000 01 00 01 00 00 00 00 00 01 00 00 00 00 00 00 00
0000000000000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000000000000020 02 00 02 01 32 03 00 00 0a 00 00 00 25 00 00 00
0000000000000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000000000000040 04 00 01 00 01 00 00 00 00 00 00 00 00 00 00 00
0000000000000050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000000000000060 05 00 01 00 03 00 00 00 00 00 00 00 00 00 00 00
0000000000000070 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000000000000080 06 00 01 00 01 00 00 00 00 00 00 00 00 00 00 00
0000000000000090 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00000000000000a0 08 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00
00000000000000b0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00000000000000c0 12 00 01 00 01 00 00 00 01 00 01 00 00 00 00 00
00000000000000d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00000000000000e0 13 00 01 00 00 01 00 00 00 00 00 00 00 00 00 00
00000000000000f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000000000000100 14 00 01 00 01 00 00 00 00 00 00 00 00 00 00 00
0000000000000110 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000000000000120 15 00 01 00 01 00 00 00 00 00 00 00 00 00 00 00
0000000000000130 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000000000000140 16 00 01 00 01 00 00 00 00 00 00 00 00 00 00 00
0000000000000150 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000000000000160 17 00 01 00 06 00 00 00 00 00 00 00 00 00 00 00
0000000000000170 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000000000000180 18 00 01 00 01 00 00 00 01 00 00 00 08 00 00 00
0000000000000190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00000000000001a0 22 00 01 00 01 00 00 00 00 00 00 00 00 00 00 00
00000000000001b0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00000000000001c0 40 00 01 00 00 08 00 00 08 00 00 00 00 00 00 00
00000000000001d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00000000000001e0 41 00 01 00 00 08 00 00 00 00 00 00 00 00 00 00
00000000000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000000000000200 42 00 01 00 00 08 00 00 00 00 00 00 00 00 00 00
0000000000000210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

$ devlink region delete pci/0000:01:00.0/device-caps snapshot 1
```

### Devlink Rate

``ice`` 驱动实现了 devlink-rate API。它允许将分层 QoS 卸载到硬件中。该功能使用户能够以树状结构对虚拟函数进行分组，并为树中的每个节点分配支持的参数：tx_share、tx_max、tx_priority 和 tx_weight。这样用户可以有效地控制每个 VF 组所分配的带宽。这最终由硬件强制执行。

假设此功能与在固件中执行的 DCB 和 ADQ 或任何会触发 QoS 变化的驱动特性（例如创建新的流量类别）互斥。如果用户开始使用 devlink-rate API 对节点进行任何更改，驱动程序将阻止 DCB 或 ADQ 的配置。要配置这些特性，必须重新加载驱动程序。

相应地，如果 ADQ 或 DCB 被配置，驱动程序将不会导出层次结构，或者如果在导出层次结构后但在进行任何更改之前启用了这些特性，则会删除未被修改的层次结构。

此功能还依赖于系统中启用的 switchdev 功能。

这是必需的，因为 devlink-rate 需要 devlink-port 对象的存在，而这些对象仅在 switchdev 模式下创建。

如果驱动程序设置为 switchdev 模式，则会在创建 VF 时导出内部层次结构。树的根始终由节点_0 表示。此节点不能被用户删除。叶子节点和具有子节点的节点也不能被删除。

#### 支持的属性表
| 名称 | 描述 |
|------|------|
| tx_max | 树节点可消耗的最大带宽。速率限制是一个绝对数值，表示在一秒钟内节点可能消耗的最大字节数。速率限制保证了链路不会使远程端点的接收方过载，并且在用户和网络提供商之间强制执行 SLA。|
| tx_share | 当树节点未被阻塞时分配给它的最小带宽。|
它指定了一个绝对带宽（BW）。虽然 `tx_max` 定义了节点可以消耗的最大带宽，但 `tx_share` 标记了分配给节点的承诺带宽（Committed BW）。

* - ``tx_priority``
      - 允许在同级节点之间使用严格的优先级仲裁。这种仲裁方案尝试在节点保持在其带宽限制内的情况下，根据它们的优先级进行调度。
范围为0-7。优先级为7的节点具有最高优先级，并且会被首先选择，而优先级为0的节点具有最低优先级。相同优先级的节点将被平等对待。
* - ``tx_weight``
      - 允许在同级节点之间使用加权公平队列（Weighted Fair Queuing）仲裁方案。这种仲裁方案可以与严格的优先级同时使用。范围为1-200。对于仲裁而言，只有相对值是重要的。

`tx_priority` 和 `tx_weight` 可以同时使用。在这种情况下，相同优先级的节点在同级组中形成一个WFQ子组，其中的仲裁基于分配的权重。

```shell
# 启用 switchdev 模式
$ devlink dev eswitch set pci/0000:4b:00.0 mode switchdev

# 此时驱动程序应导出内部层次结构
$ echo 2 > /sys/class/net/ens785np0/device/sriov_numvfs

$ devlink port function rate show
pci/0000:4b:00.0/node_25: 类型 节点 父节点 node_24
pci/0000:4b:00.0/node_24: 类型 节点 父节点 node_0
pci/0000:4b:00.0/node_32: 类型 节点 父节点 node_31
pci/0000:4b:00.0/node_31: 类型 节点 父节点 node_30
pci/0000:4b:00.0/node_30: 类型 节点 父节点 node_16
pci/0000:4b:00.0/node_19: 类型 节点 父节点 node_18
pci/0000:4b:00.0/node_18: 类型 节点 父节点 node_17
pci/0000:4b:00.0/node_17: 类型 节点 父节点 node_16
pci/0000:4b:00.0/node_14: 类型 节点 父节点 node_5
pci/0000:4b:00.0/node_5: 类型 节点 父节点 node_3
pci/0000:4b:00.0/node_13: 类型 节点 父节点 node_4
pci/0000:4b:00.0/node_12: 类型 节点 父节点 node_4
pci/0000:4b:00.0/node_11: 类型 节点 父节点 node_4
pci/0000:4b:00.0/node_10: 类型 节点 父节点 node_4
pci/0000:4b:00.0/node_9: 类型 节点 父节点 node_4
pci/0000:4b:00.0/node_8: 类型 节点 父节点 node_4
pci/0000:4b:00.0/node_7: 类型 节点 父节点 node_4
pci/0000:4b:00.0/node_6: 类型 节点 父节点 node_4
pci/0000:4b:00.0/node_4: 类型 节点 父节点 node_3
pci/0000:4b:00.0/node_3: 类型 节点 父节点 node_16
pci/0000:4b:00.0/node_16: 类型 节点 父节点 node_15
pci/0000:4b:00.0/node_15: 类型 节点 父节点 node_0
pci/0000:4b:00.0/node_2: 类型 节点 父节点 node_1
pci/0000:4b:00.0/node_1: 类型 节点 父节点 node_0
pci/0000:4b:00.0/node_0: 类型 节点
pci/0000:4b:00.0/1: 类型 叶子 父节点 node_25
pci/0000:4b:00.0/2: 类型 叶子 父节点 node_25

# 创建一个自定义节点
$ devlink port function rate add pci/0000:4b:00.0/node_custom 父节点 node_0

# 第二个自定义节点
$ devlink port function rate add pci/0000:4b:00.0/node_custom_1 父节点 node_custom

# 将第二个VF重新分配到新创建的分支
$ devlink port function rate set pci/0000:4b:00.0/2 父节点 node_custom_1

# 为VF分配 tx_weight
$ devlink port function rate set pci/0000:4b:00.0/2 tx_weight 5

# 为VF分配 tx_share
$ devlink port function rate set pci/0000:4b:00.0/2 tx_share 500Mbps
```
