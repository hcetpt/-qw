SPDX 许可证标识符: GPL-2.0

=============
Devlink DPIPE
=============

背景
======

在执行硬件卸载过程中，许多硬件细节无法呈现。这些细节对于调试非常有用，而 `devlink-dpipe` 提供了一种标准化的方式来提供对卸载过程的可见性。例如，Linux 内核使用的路由最长前缀匹配（LPM）算法可能与硬件实现不同。管道调试 API（DPIPE）旨在以通用的方式为用户提供对 ASIC 管道的可见性。硬件卸载过程应当以用户无法区分硬件和软件实现的方式进行。在这个过程中，忽略了硬件的具体细节。实际上，这些细节具有重要的意义，并且应该以某种标准方式暴露出来。

当希望将整个网络堆栈的控制路径卸载到交换芯片 ASIC 时，这个问题变得更加复杂。由于硬件和软件模型之间的差异，某些过程无法正确表示。一个例子是内核的 LPM 算法，在很多情况下与硬件实现有很大不同。配置 API 是相同的，但不能依赖转发信息库（FIB）来与硬件中的层级路径压缩树（LPC-trie）保持一致。在许多情况下，仅基于内核的转储来分析系统故障可能不够充分。通过结合底层硬件的相关信息，可以更容易地进行调试；此外，这些信息在调试性能问题时也很有用。

概述
======

`devlink-dpipe` 接口填补了这一空白。硬件的管道被建模为匹配/操作表的图。每个表代表一个特定的硬件模块。这种模型并非新颖，最初由 P4 语言引入。传统上，它被用作硬件配置的替代模型，但 `devlink-dpipe` 接口将其作为标准化的补充工具用于可见性目的。系统的视图应根据标准配置工具所做的更改相应变化。

例如，使用三态内容寻址存储器（TCAM）实现访问控制列表（ACL）非常常见。TCAM 存储器可以分为多个 TCAM 区域。复杂的 TC 过滤器可以包含多个具有不同优先级和不同查找键的规则。另一方面，硬件 TCAM 区域具有预定义的查找键。使用 TCAM 引擎卸载 TC 过滤器规则可能会导致多个 TCAM 区域通过链式连接（这可能影响数据路径延迟）。针对新的 TC 过滤器，应创建新的表来描述这些区域。

模型
=====

`DPIPE` 模型引入了几个对象：

  * 头部
  * 表格
  * 条目

`头部` 描述包格式并为包内的字段提供名称。`表格` 描述硬件模块。`条目` 描述特定表格的实际内容。
硬件管道不是特定于端口的，而是描述整个ASIC。因此，它与“devlink”基础设施的顶层相关联。
驱动程序可以在运行时注册和注销表，以支持动态行为。这种动态行为对于描述像TCAM区域这样的硬件块是必需的，这些区域可以动态分配和释放。
“devlink-dpipe”通常不用于配置。唯一的例外是对特定表进行硬件计数。
以下命令用于从用户空间获取“dpipe”对象：

  * “table_get”：接收一个表的描述
  * “headers_get”：接收设备支持的报头
  * “entries_get”：接收表中的当前条目
  * “counters_set”：启用或禁用表上的计数器

表
---

对于每个表，驱动程序应实现以下操作：

  * “matches_dump”：转储支持的匹配项
  * “actions_dump”：转储支持的操作
  * “entries_dump”：转储表的实际内容
``counters_set_update``：同步硬件，启用或禁用计数器
头部/字段
-----------

类似于P4中的头部和字段用于描述表的行为。协议标准头部与特定ASIC元数据之间存在细微差别。协议头部应在``devlink``核心API中声明。另一方面，ASIC元数据是驱动程序特有的，应在驱动程序中定义。此外，每个驱动程序特定的devlink文档文件应记录其实现的驱动程序特定的``dpipe``头部。通过枚举来标识这些头部和字段。为了提供进一步的可见性，一些ASIC元数据字段可以映射到内核对象。例如，内部路由器接口索引可以直接映射到网络设备ifindex。不同虚拟路由和转发（VRF）表使用的FIB表索引可以映射到内部路由表索引。

匹配
-----

匹配保持原始且接近硬件操作。不支持如LPM这样的匹配类型，因为这是我们希望详细描述的过程。匹配类型的示例：

  * ``field_exact``：对特定字段进行精确匹配
* ``field_exact_mask``：在掩码后对特定字段进行精确匹配
* ``field_range``：在特定范围内进行匹配
需要指定头部和字段的ID以识别特定字段。此外，还应指定头部索引以区分包中同一类型的多个头部（隧道）

动作
------

与匹配类似，动作也保持原始且接近硬件操作。例如：

  * ``field_modify``：修改字段值
* ``field_inc``：递增字段值
* ``push_header``：添加一个头部
``pop_header``：移除一个报头
条目
------

特定表中的条目可以根据需求导出。每个条目通过索引进行标识，并且其属性由一组匹配/操作值和特定计数器来描述。通过导出表的内容，可以解决表之间的交互关系。

抽象示例
===================

以下是一个关于Mellanox Spectrum ASIC的L3部分的抽象模型示例。这些模块按照它们在管道中出现的顺序进行描述。下面示例中的表大小并非实际硬件大小，仅用于演示目的。

LPM
---

LPM算法可以实现为一系列哈希表的列表。每个哈希表包含具有相同前缀长度的路由。列表的根是/32，在未命中情况下，硬件将继续搜索下一个哈希表。搜索的深度将影响数据路径延迟。
在命中情况下，条目包含有关下一阶段管道的信息，该信息用于解析MAC地址。下一阶段可以是直接连接路由的本地主机表，或者是下一跳的邻接表。
`meta.lpm_prefix`字段用于连接两个LPM表。
.. code::

    表格 lpm_prefix_16 {
      大小: 4096,
      启用计数器: 是,
      匹配: { meta.vr_id: 精确匹配,
               ipv4.dst_addr: 精确掩码匹配,
               ipv6.dst_addr: 精确掩码匹配,
               meta.lpm_prefix: 精确匹配 },
      操作: { meta.adj_index: 设置,
              meta.adj_group_size: 设置,
              meta.rif_port: 设置,
              meta.lpm_prefix: 设置 },
    }

本地主机
----------

对于本地路由的情况，LPM查找已经解决了出口路由器接口（RIF），但确切的MAC地址未知。本地主机表是一个哈希表，它将输出接口ID与目标IP地址组合作为键。结果是MAC地址。
.. code::

    表格 local_host {
      大小: 4096,
      启用计数器: 是,
      匹配: { meta.rif_port: 精确匹配,
               ipv4.dst_addr: 精确匹配},
      操作: { ethernet.daddr: 设置 }
    }

邻接表
---------

对于远程路由的情况，此表执行ECMP。LPM查找结果提供ECMP组的大小和索引，这作为进入此表的全局偏移量。
同时生成一个包的哈希值。基于ECMP组大小和包的哈希值，生成一个局部偏移量。多个LPM条目可以指向相同的邻接组。
.. code::

    表格 adjacency {
      大小: 4096,
      启用计数器: 是,
      匹配: { meta.adj_index: 精确匹配,
               meta.adj_group_size: 精确匹配,
               meta.packet_hash_index: 精确匹配 },
      操作: { ethernet.daddr: 设置,
              meta.erif: 设置 }
    }

ERIF
----

如果出口RIF和目标MAC已在前一阶段表格中解析，则此表会执行多个操作，如TTL递减和MTU检查。
然后根据数据包的类型（广播、单播、多播）做出转发或丢弃的决定，并更新端口 L3 的统计信息。

.. code::

    表 erif {
      大小: 800,
      启用计数器: true,
      匹配: { 元数据.接口端口: 精确匹配,
               元数据.是否为L3单播: 精确匹配,
               元数据.是否为L3广播: 精确匹配,
               元数据.是否为L3多播: 精确匹配 },
      操作: { 元数据.L3丢弃: 设置,
               元数据.L3转发: 设置 }
    }
