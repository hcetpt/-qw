物理层抽象层 (PHY Abstraction Layer)
====================================

目的
====

大多数网络设备包含一组寄存器，这些寄存器为介质访问控制层（MAC 层）提供接口，MAC 层通过物理层（PHY）与物理连接进行通信。PHY 负责与网络另一端的对等实体协商链路参数（通常是一根以太网线），并提供寄存器接口让驱动程序能够确定所选设置，并配置允许使用的设置。尽管这些设备与网络设备本身是分开的，并且它们的寄存器遵循一个标准布局，但通常的做法是将 PHY 管理代码集成到网络驱动程序中。这导致了大量的重复代码。此外，在具有多个（有时非常不同）以太网控制器并通过同一管理总线连接的嵌入式系统上，很难确保该总线的安全使用。

由于 PHY 是设备，而用于访问它们的管理总线实际上也是总线，因此物理层抽象层（PHY Abstraction Layer，PAL）将它们作为这样的设备处理。这样做有以下目标：

1. 提高代码复用率。
2. 增加整体代码可维护性。
3. 加快新网络驱动程序和新系统的开发时间。

基本上，这一层旨在为 PHY 设备提供接口，使网络驱动程序编写者尽可能少写代码，同时仍然提供完整的功能集。

MDIO 总线
=========

大多数网络设备通过管理总线连接到 PHY。不同的设备使用不同的总线（尽管有些共享相同的接口）。为了利用 PAL，每个总线接口都需要注册为一个独立的设备。

1. 必须实现读写函数。它们的原型如下所示：
   
   ```c
   int write(struct mii_bus *bus, int mii_id, int regnum, u16 value);
   int read(struct mii_bus *bus, int mii_id, int regnum);
   ```

   `mii_id` 是总线上 PHY 的地址，`regnum` 是寄存器编号。可以保证这些函数不会在中断时间内被调用，因此它们可以安全地阻塞，等待中断信号来指示操作已完成。

2. 重置函数是可选的。此函数用于将总线恢复到初始化状态。
3. 需要一个探测函数。此函数应设置总线驱动程序需要的任何内容、设置 `mii_bus` 结构，并使用 `mdiobus_register` 注册到 PAL。同样地，有一个移除函数来撤销上述操作（使用 `mdiobus_unregister`）。
4. 和任何驱动程序一样，必须配置 `device_driver` 结构，并使用 init 和 exit 函数来注册驱动程序。
### 总线作为设备的声明与注册

总线也必须在某处被声明为一个设备，并进行注册。作为司机实现MDIO总线驱动的一个例子，可以参见`drivers/net/ethernet/freescale/fsl_pq_mdio.c`以及相关的DTS文件之一（例如用户："git grep fsl,.*-mdio arch/powerpc/boot/dts/")

### (RG)MII/电气接口考虑

#### 减少型千兆介质独立接口 (RGMII)

减少型千兆介质独立接口 (RGMII) 是一个使用同步125MHz时钟信号和多条数据线的12针电气信号接口。由于设计决定，必须在时钟线（RXC或TXC）和数据线之间添加1.5ns到2ns的延迟，以便让PHY（时钟接收器）有足够的设置和保持时间来正确采样数据线。PHY库提供了不同类型的PHY_INTERFACE_MODE_RGMII*值，以使PHY驱动程序和可选的MAC驱动程序能够实现所需的延迟。phy_interface_t的值必须从PHY设备本身的视角来理解，导致以下情况：

- **PHY_INTERFACE_MODE_RGMII**：PHY不负责自行插入任何内部延迟，它假定以太网MAC（如果具备能力）或PCB走线插入正确的1.5-2ns延迟。
- **PHY_INTERFACE_MODE_RGMII_TXID**：PHY应该对由PHY设备处理的发送数据线（TXD[3:0]）插入内部延迟。
- **PHY_INTERFACE_MODE_RGMII_RXID**：PHY应该对由PHY设备处理的接收数据线（RXD[3:0]）插入内部延迟。
- **PHY_INTERFACE_MODE_RGMII_ID**：PHY应该对从/到PHY设备的发送和接收数据线都插入内部延迟。

尽可能地使用PHY侧的RGMII延迟，原因如下：

- PHY设备可能提供亚纳秒级别的精度来指定接收器/发射器侧的延迟（例如：0.5、1.0、1.5ns），这种精度可能需要用来补偿PCB走线长度的差异。
- PHY设备通常适用于广泛的应用场景（工业、医疗、汽车等），并且它们在整个温度/压力/电压范围内提供恒定且可靠的延迟。
- PHYLIB中的PHY设备驱动程序本质上是可重用的，能够正确配置指定的延迟使得具有相似延迟要求的设计能正确运行。

对于PHY无法提供此延迟但以太网MAC驱动程序可以做到的情况，正确的phy_interface_t值应该是PHY_INTERFACE_MODE_RGMII，并且应该正确配置以太网MAC驱动程序以从PHY设备的角度提供所需的发送和/或接收侧延迟。相反，如果以太网MAC驱动程序查看phy_interface_t值，对于除PHY_INTERFACE_MODE_RGMII以外的任何模式，它应该确保禁用MAC级延迟。

在既非以太网MAC也不是PHY能够提供RGMII标准所定义的所需延迟的情况下，可能存在几种选项：

- 某些SoC可能提供了一个能够配置一组给定引脚的强度、延迟和电压的引脚垫/多路复用器/控制器；这可能是一个合适的选项来插入预期的2ns RGMII延迟。
- 修改PCB设计以包含固定延迟（例如：使用专门设计的蛇形走线），这可能根本不需要软件配置。

#### RGMII延迟不匹配的常见问题

当以太网MAC和PHY之间的RGMII延迟不匹配时，最有可能的结果是时钟和数据线信号在PHY或MAC获取这些信号的快照以将其转换为逻辑1或0状态并重建传输/接收的数据时变得不稳定。典型的症状包括：

- 传输/接收部分工作，观察到频繁或偶尔的丢包。
- 以太网MAC可能会报告一些或所有进入的报文带有FCS/CRC错误，或者完全丢弃它们。
- 切换到较低的速度，如10/100Mbit/s，会使问题消失（因为在这种情况下有足够的设置/保持时间）。

### 连接到PHY

在启动过程中某个时刻，网络驱动程序需要建立PHY设备与网络设备之间的连接。此时，PHY的总线和驱动程序都需要已经加载，以便准备好连接。此时有几种方式来连接到PHY：

1. PAL处理一切，并仅在网络链接状态变化时调用网络驱动程序，以便它可以作出反应。
2. PAL处理除了中断之外的一切（通常是因为控制器拥有中断寄存器）。
3. PAL处理一切，但每秒检查一次与驱动程序的通信，允许网络驱动程序在PAL之前对任何变化作出首次反应。
4. PAL仅仅作为一个函数库，网络设备手动调用函数来更新状态并配置PHY。

### 让PHY抽象层处理一切

如果你选择第1种方案（希望每个驱动程序都能做到，但仍然对不能做到的驱动程序有用），连接到PHY很简单：

首先，你需要一个函数来响应链接状态的变化。这个函数遵循以下协议：

```c
static void adjust_link(struct net_device *dev);
```

接下来，你需要知道连接到此设备的PHY的设备名称。名称看起来像是"0:00"，其中第一个数字是总线ID，第二个是该总线上的PHY地址。通常，总线负责使其ID唯一。
