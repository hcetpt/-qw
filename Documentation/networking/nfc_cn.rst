===================
Linux NFC 子系统
===================

近场通信（NFC）子系统旨在标准化NFC设备驱动程序的开发，并创建统一的用户空间接口。本文档涵盖了架构概述、设备驱动程序接口描述和用户空间接口描述。

架构概述
=====================

NFC子系统负责：
- 管理NFC适配器；
- 搜索目标；
- 低级数据交换；

该子系统分为几个部分。“核心”部分负责提供设备驱动程序接口，同时也负责提供控制操作和低级数据交换的接口。
控制操作通过通用netlink对用户空间开放。低级数据交换接口由新的套接字家族PF_NFC提供。NFC_SOCKPROTO_RAW用于与NFC目标进行原始通信。

.. code-block:: none

        +--------------------------------------+
        |              用户空间                |
        +--------------------------------------+
            ^                       ^
            | 低级数据交换          | 控制操作
            |                      | 
            |                      |
            |                      v
            |                  +-----------+
            | AF_NFC           |  netlink  |
            | 套接字           +-----------+
            | 原始                  ^
            |                      |
            v                      v
        +---------+            +-----------+
        | rawsock | <--------> |   核心    |
        +---------+            +-----------+
                                    ^
                                    |
                                    v
                               +-----------+
                               |  驱动程序  |
                               +-----------+

设备驱动程序接口
=======================

当注册到NFC子系统时，设备驱动程序必须向核心报告支持的NFC协议集以及回调函数集。必须实现的操作回调包括：

* start_poll - 设置设备以搜索目标
* stop_poll - 停止正在进行的搜索操作
* activate_target - 选择并初始化已找到的目标之一
* deactivate_target - 取消选择并去初始化选定的目标
* data_exchange - 发送数据并接收响应（双向通信操作）

用户空间接口
===================

用户空间接口分为控制操作和低级数据交换操作。

**控制操作：**

通用netlink用于实现与控制操作的接口。这些操作由命令和事件组成，如下所示：

* NFC_CMD_GET_DEVICE - 获取特定设备的信息或转储设备列表
* NFC_CMD_START_POLL - 设置特定设备以搜索目标
* NFC_CMD_STOP_POLL - 停止特定设备上的搜索操作
* NFC_CMD_GET_TARGET - 转储特定设备找到的目标列表

* NFC_EVENT_DEVICE_ADDED - 报告添加了NFC设备
* NFC_EVENT_DEVICE_REMOVED - 报告移除了NFC设备
* NFC_EVENT_TARGETS_FOUND - 当找到一个或多个目标时报告START_POLL的结果

用户必须调用START_POLL来搜索NFC目标，并通过NFC_ATTR_PROTOCOLS属性传递所需的NFC协议。设备将保持在搜索状态直到找到任何目标。然而，用户可以通过调用STOP_POLL命令停止搜索操作。在这种情况下，将检查请求STOP_POLL的用户是否与启动搜索的用户相同。
如果搜索操作找到一个或多个目标，则会发送TARGETS_FOUND事件（包含设备ID）。用户必须调用GET_TARGET来获取该设备找到的所有目标列表。每个回复消息都包含有关目标的相关信息，例如支持的NFC协议。
通过单个netlink套接字请求的所有搜索操作将在其关闭时停止。
低级数据交换：

用户空间必须使用 PF_NFC 套接字来与目标进行任何数据通信。所有 NFC 套接字都使用 AF_NFC：

        struct sockaddr_nfc {
               sa_family_t sa_family;
               __u32 dev_idx;
               __u32 target_idx;
               __u32 nfc_protocol;
        };

为了与一个目标建立连接，用户必须创建一个 NFC_SOCKPROTO_RAW 套接字，并正确填充 sockaddr_nfc 结构体后调用 'connect' 系统调用。所有信息来自 NFC_EVENT_TARGETS_FOUND 的 netlink 事件。由于一个目标可能支持多种 NFC 协议，用户需要指定想要使用的协议。

内部地，'connect' 将导致对驱动程序的 activate_target 调用。当套接字关闭时，目标将被停用。

通过套接字交换的数据格式取决于 NFC 协议。例如，在与 MIFARE 标签通信时，交换的数据是 MIFARE 命令及其响应。

收到的第一个数据包是对发送的第一个数据包的响应，依此类推。为了允许有效的“空”响应，每个接收到的数据都有一个 1 字节的 NULL 头部。
