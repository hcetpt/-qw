SPDX 许可证标识符: (GPL-2.0 或 MIT)

===================
J1939 文档
===================

概述 / 什么是 J1939
========================

SAE J1939 在 CAN 网络上定义了一个更高层的协议。它实现了一个更复杂的寻址方案，并将最大数据包大小扩展到超过 8 字节。存在一些衍生规范，这些规范在应用层与原始 J1939 有所不同，如 MilCAN A、NMEA2000，特别是 ISO-11783（ISOBUS）。最后一个规范规定了所谓的 ETP（扩展传输协议），该协议已包含在此实现中。这导致最大数据包大小为 ((2^24) - 1) * 7 字节 == 111 MiB。

使用的规范
-------------------

* SAE J1939-21：数据链路层
* SAE J1939-81：网络管理
* ISO 11783-6：虚拟终端（扩展传输协议）

.. _j1939-motivation:

动机
==========

鉴于存在类似 SocketCAN 的东西，并且其 API 类似于 BSD 套接字，我们找到了一些理由来证明在内核中实现 J1939 使用的寻址和传输方法是合理的：
* **寻址：** 当一个 ECU 上的过程通过 J1939 进行通信时，它不一定需要知道其源地址。然而，每个 ECU 至少应该有一个过程知道源地址。其他过程应该能够重用该地址。这样，不同过程为同一个 ECU 协作时不会重复地址参数。这种工作方式与 UNIX 概念密切相关，即程序只做一件事并且做得很好。
* **动态寻址：** J1939 中的地址声明是时间敏感的。此外，在地址协商期间应正确处理数据传输。将此功能放在内核中消除了每个通过 J1939 通信的用户空间进程对此功能的需求。这样可以确保 J1939 总线具有正确的寻址一致性。
* **传输：** TP 和 ETP 都重用一些 PGN 来传输大包。因此，不同的过程可能使用相同的 TP 和 ETP PGN 而不必实际知道这一点。不同的过程之间的各个 TP 和 ETP 会话必须进行序列化（同步）。内核很好地解决了这个问题，并消除了每个通过 J1939 通信的用户空间进程对序列化（同步）的需求。

J1939 定义了一些其他特性（中继、网关、快速数据包传输等）。对于这些特性的内核代码不会有助于协议的稳定性，因此这些部分留给用户空间处理。

J1939 套接字在 CAN 网络设备上运行（参见 SocketCAN）。任何在 CAN 原始套接字上运行的 J1939 用户空间库仍然可以正常工作。
由于此类库不与内核中的实现通信，因此必须注意这两者不会相互干扰。实际上，这意味着它们不能共享ECU地址。一个ECU（或虚拟ECU）地址要么由库独占使用，要么由内核系统独占使用。

J1939 概念
==========

PGN
---

J1939协议使用29位的CAN标识符，并具有以下结构：

  ============  ==============  ====================
  29位CAN标识符
  --------------------------------------------------
  CAN标识符内的比特位置
  --------------------------------------------------
  28 ... 26     25 ... 8        7 ... 0
  ============  ==============  ====================
  优先级         PGN             SA（源地址）
  ============  ==============  ====================

PGN（参数组编号）是一个用于标识数据包的数字。PGN的组成如下：

  ============  ==============  =================  =================
  PGN
  ------------------------------------------------------------------
  CAN标识符内的比特位置
  ------------------------------------------------------------------
  25            24              23 ... 16          15 ... 8
  ============  ==============  =================  =================
  R（保留）     DP（数据页）    PF（PDU格式）      PS（PDU特定）
  ============  ==============  =================  =================

在J1939-21中，区分了PDU1格式（PF < 240）和PDU2格式（PF >= 240）。此外，在使用PDU2格式时，PS字段包含一个所谓的组扩展，这是PGN的一部分。当使用PDU2格式时，组扩展设置在PS字段中。
==============  ========================
  PDU1格式（特定）（点对点）
  ----------------------------------------
  CAN标识符内的比特位置
  ----------------------------------------
  23 ... 16       15 ... 8
  ==============  ========================
  00h ... EFh     DA（目标地址）
  ==============  ========================

  ==============  ========================
  PDU2格式（全局）（广播）
  ----------------------------------------
  CAN标识符内的比特位置
  ----------------------------------------
  23 ... 16       15 ... 8
  ==============  ========================
  F0h ... FFh     GE（组扩展）
  ==============  ========================

另一方面，当使用PDU1格式时，PS字段包含一个所谓的目标地址，这并不是PGN的一部分。当从用户空间向内核（反之亦然）通信PGN且使用PDU2格式时，PGN的PS字段应设为零。目标地址应设置在其他地方。
关于PGN映射到29位CAN标识符，目标地址应通过内核从标识符的相应位获取/设置。

寻址
----------

可以使用静态和动态寻址方法。
对于静态地址，内核不会进行额外检查，并认为提供的地址是正确的。这一责任在于OEM或系统集成商。
对于动态寻址，即所谓的地址声明，内核提供了额外的支持。在J1939中，任何ECU都以其64位NAME为人所知。在成功声明地址时，内核会跟踪被声明的NAME和源地址。这是过滤方案的基础。默认情况下，目的地不是本地的报文将被拒绝。
允许混合模式报文（从静态地址到动态地址或反之亦然）。BSD套接字定义了单独的API调用来获取/设置本地和远程地址，适用于J1939套接字。

过滤
---------

J1939定义了每个套接字的白名单过滤器，用户可以设置这些过滤器以接收J1939流量的一个子集。过滤可以基于：

* SA
* SOURCE_NAME
* PGN

当单个套接字中有多个过滤器，并且有一个报文符合这些过滤器中的几个时，该报文仅针对该套接字接收一次。

如何使用J1939
===============

API调用
---------

在CAN网络上，您首先需要打开一个套接字以进行通信。
要使用 J1939，需要包含 `<linux/can/j1939.h>`。这样也会自动包含 `<linux/can.h>`。要创建一个套接字，请使用以下代码：

```c
s = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);
```

J1939 使用 `SOCK_DGRAM` 类型的套接字。在 J1939 规范中，连接是在传输协议会话的上下文中提到的。这些连接仍然会将数据包发送到另一端（使用多个 CAN 数据包）。`SOCK_STREAM` 不被支持。

成功创建套接字后，通常会使用 `bind(2)` 和/或 `connect(2)` 系统调用来将套接字绑定到 CAN 接口。绑定和/或连接套接字后，可以像往常一样使用 `read(2)`、`write(2)`、`send(2)`、`sendto(2)`、`sendmsg(2)` 及其对应的 `recv*()` 操作来读写数据。下面还描述了一些 J1939 特定的套接字选项。

为了发送数据，必须先成功地执行 `bind(2)`。`bind(2)` 为套接字分配本地地址。

与 CAN 不同的是，有效载荷数据只是实际发送的数据，不包括其头部信息。头部信息是从传递给 `bind(2)`、`connect(2)`、`sendto(2)` 和 `recvfrom(2)` 的 sockaddr 结构中获取的。`write(2)` 的大小为 4 字节时，结果将是包含 4 字节数据的包。

sockaddr 结构体有针对 J1939 的扩展，具体如下：

```c
struct sockaddr_can {
   sa_family_t can_family;
   int         can_ifindex;
   union {
      struct {
         __u64 name;  /* pgn:
                       * 8 bit: PS in PDU2 case, else 0
                       * 8 bit: PF
                       * 1 bit: DP
                       * 1 bit: reserved
                       */
         __u32 pgn;
         __u8  addr;
      } j1939;
   } can_addr;
}
```

`can_family` 和 `can_ifindex` 与其他 SocketCAN 套接字相同。
`can_addr.j1939.pgn` 指定了 PGN（最大值为 0x3ffff）。各个位的具体定义如上所述。
`can_addr.j1939.name` 包含 64 位的 J1939 NAME。
`can_addr.j1939.addr` 包含地址。

`bind(2)` 系统调用分配本地地址，即发送数据包时的源地址。如果在 `bind(2)` 期间设置了 PGN，则将其用作接收过滤器，即只接收匹配 PGN 的数据包。如果设置了 ADDR 或 NAME，则也用作接收过滤器，匹配传入数据包的目标 NAME 或 ADDR。NAME 过滤器只有在相应的 CAN 总线上完成了适当的 Address Claiming 并由内核注册/缓存后才会起作用。
另一方面，`connect(2)` 分配远程地址，即目标地址。从 `connect(2)` 中获取的 PGN 在发送数据包时作为默认 PGN 使用。如果设置了 ADDR 或 NAME，则将其用作默认的目标 ADDR 或 NAME。进一步地，在 `connect(2)` 中设置的 ADDR 或 NAME 用作接收过滤器。它会匹配传入数据包的源 NAME 或 ADDR。

`write(2)` 和 `send(2)` 都会发送带有 `bind(2)` 中的本地地址和 `connect(2)` 中的远程地址的数据包。使用 `sendto(2)` 来覆盖目标地址。

如果设置了 `can_addr.j1939.name`（不等于 0），则内核会查找该 NAME 并使用对应的 ADDR。如果没有设置 `can_addr.j1939.name`（等于 0），则使用 `can_addr.j1939.addr`。

在创建套接字时，默认会设置一些合理的选项。有些选项可以通过 `setsockopt(2)` 和 `getsockopt(2)` 进行修改。

与 RX 路径相关的选项：

- `SO_J1939_FILTER` — 配置过滤器数组
- `SO_J1939_PROMISC` — 禁用由 `bind(2)` 和 `connect(2)` 设置的过滤器

默认情况下，无法发送或接收广播数据包。要启用发送或接收广播数据包，请使用套接字选项 `SO_BROADCAST`：

```c
int value = 1;
setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &value, sizeof(value));
```

以下图示说明了 RX 路径：

```
                    +--------------------+
                    |  incoming packet   |
                    +--------------------+
                              |
                              V
                    +--------------------+
                    | SO_J1939_PROMISC?  |
                    +--------------------+
                             |  |
                         no  |  | yes
                             |  |
                   .---------'  `---------
|                      |
     +---------------------------+        |
     | bind() + connect() +      |        |
     | SOCK_BROADCAST filter     |        |
     +---------------------------+        |
                   |                      |
                   |<---------------------'
                   V
     +---------------------------+
     |      SO_J1939_FILTER      |
     +---------------------------+
                   |
                   V
     +---------------------------+
     |        socket recv()      |
     +---------------------------+
```

与 TX 路径相关的选项：
`SO_J1939_SEND_PRIO` — 更改套接字的默认发送优先级

在 `send()` 及相关系统调用中的消息标志
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`send(2)`、`sendto(2)` 和 `sendmsg(2)` 接受一个 'flags' 参数。目前支持的标志有：

- `MSG_DONTWAIT`，即非阻塞操作

`recvmsg(2)`
^^^^^^^^^^

在大多数情况下，如果您想提取比 `recvfrom(2)` 提供的更多信息，如数据包优先级和时间戳，则需要使用 `recvmsg(2)`。目的地地址、名称和数据包优先级（如果适用）会在 `recvmsg(2)` 调用中附加到 msghdr 上。可以使用 `cmsg(3)` 宏提取这些信息，其中 `cmsg_level == SOL_J1939 && cmsg_type == SCM_J1939_DEST_ADDR`、`SCM_J1939_DEST_NAME` 或 `SCM_J1939_PRIO`。返回的数据是一个 `uint8_t` 类型的 `priority` 和 `dst_addr`，以及 `uint64_t` 类型的 `dst_name`。

```c
uint8_t priority, dst_addr;
uint64_t dst_name;

for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
    switch (cmsg->cmsg_level) {
    case SOL_CAN_J1939:
        if (cmsg->cmsg_type == SCM_J1939_DEST_ADDR)
            dst_addr = *CMSG_DATA(cmsg);
        else if (cmsg->cmsg_type == SCM_J1939_DEST_NAME)
            memcpy(&dst_name, CMSG_DATA(cmsg), cmsg->cmsg_len - CMSG_LEN(0));
        else if (cmsg->cmsg_type == SCM_J1939_PRIO)
            priority = *CMSG_DATA(cmsg);
        break;
    }
}
```

动态寻址
------------------

需要区分使用已声明的地址和进行地址声明。要使用已经声明的地址，需要填写 `j1939.name` 成员并将其提供给 `bind(2)`。如果名称之前已经声明了一个地址，则所有后续发送的消息将使用该地址，并且忽略 `j1939.addr` 成员。

一个例外是 PGN 0x0ee00。这是“地址声明/无法声明地址”消息，内核会为该 PGN 使用 `j1939.addr` 成员（如果必要的话）。

要声明一个地址，可以使用以下代码示例：

```c
struct sockaddr_can baddr = {
    .can_family = AF_CAN,
    .can_addr.j1939 = {
        .name = name,
        .addr = J1939_IDLE_ADDR,
        .pgn = J1939_NO_PGN, /* 为了禁用 bind() 的 PGN 接收过滤器 */
    },
    .can_ifindex = if_nametoindex("can0"),
};

bind(sock, (struct sockaddr *)&baddr, sizeof(baddr));

/* 为了进行地址声明，必须允许广播 */
int value = 1;
setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &value, sizeof(value));

/* 配置用于地址声明所需的高级接收过滤器 */
const struct j1939_filter filt[] = {
    {
        .pgn = J1939_PGN_ADDRESS_CLAIMED,
        .pgn_mask = J1939_PGN_PDU1_MAX,
    }, {
        .pgn = J1939_PGN_REQUEST,
        .pgn_mask = J1939_PGN_PDU1_MAX,
    }, {
        .pgn = J1939_PGN_ADDRESS_COMMANDED,
        .pgn_mask = J1939_PGN_MAX,
    },
};

setsockopt(sock, SOL_CAN_J1939, SO_J1939_FILTER, &filt, sizeof(filt));

uint64_t dat = htole64(name);
const struct sockaddr_can saddr = {
    .can_family = AF_CAN,
    .can_addr.j1939 = {
        .pgn = J1939_PGN_ADDRESS_CLAIMED,
        .addr = J1939_NO_ADDR,
    },
};

/* 之后使用 sendto(2) 发送数据，数据设置为 NAME（小端序）。如果提供的 NAME 与提供给 bind(2) 的 j1939.name 不匹配，则返回 EPROTO 错误 */
```
```c
sendto(sock, dat, sizeof(dat), 0, (const struct sockaddr *)&saddr, sizeof(saddr));
```

如果在传输后250毫秒内没有其他人对地址声明提出异议，内核将标记该`NAME-SA`分配为有效。有效的分配将与其他有效的`NAME-SA`分配一起保存。从那时起，任何绑定到该`NAME`的套接字都可以发送数据包。
如果另一个ECU声明了该地址，内核会标记该`NAME-SA`已过期。
绑定到该`NAME`的任何套接字都不能发送数据包（除了地址声明）。要声明另一个地址，必须有一些绑定到`NAME`的套接字再次调用`bind(2)`，但只修改`j1939.addr`为新的SA，并且然后发送一个有效的地址声明数据包。这将重新启动内核（和总线上其他参与者）针对该`NAME`的状态机。

`can-utils`还包括了`j1939acd`工具，因此可以将其作为代码示例或默认的地址声明守护进程。

发送示例
--------

### 静态寻址
^^^^^^^^^^^^^^^^

此示例将从SA 0x20向DA 0x30发送PGN (0x12300)。
绑定：

```c
struct sockaddr_can baddr = {
    .can_family = AF_CAN,
    .can_addr.j1939 = {
        .name = J1939_NO_NAME,
        .addr = 0x20,
        .pgn = J1939_NO_PGN,
    },
    .can_ifindex = if_nametoindex("can0"),
};

bind(sock, (struct sockaddr *)&baddr, sizeof(baddr));
```

现在，套接字`sock`已经绑定到SA 0x20。由于没有调用`connect(2)`，此时我们只能使用`sendto(2)`或`sendmsg(2)`。
发送：

```c
const struct sockaddr_can saddr = {
    .can_family = AF_CAN,
    .can_addr.j1939 = {
        .name = J1939_NO_NAME,
        .addr = 0x30,
        .pgn = 0x12300,
    },
};

sendto(sock, dat, sizeof(dat), 0, (const struct sockaddr *)&saddr, sizeof(saddr));
```
