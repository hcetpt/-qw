SPDX 许可证标识符: (GPL-2.0 或 MIT)

===================
J1939 文档
===================

概述 / 什么是 J1939
========================

SAE J1939 在 CAN 网络上定义了一个更高层的协议。它实现了一个更为复杂的寻址方案，并将最大数据包大小扩展到了超过8字节。存在几个派生规范，这些规范在应用级别上与原始 J1939 有所不同，如 MilCAN A、NMEA2000，尤其是 ISO-11783（ISOBUS）。后者规定了所谓的 ETP（扩展传输协议），该协议已被包含在此实现中。这导致最大数据包大小为 ((2 ^ 24) - 1) * 7 字节 == 111 MiB

使用的规范
-------------------

* SAE J1939-21：数据链路层
* SAE J1939-81：网络管理
* ISO 11783-6：虚拟终端（扩展传输协议）

.. _j1939-motivation:

动机
==========

鉴于存在类似 SocketCAN 的东西，其API类似于BSD套接字，我们找到了一些理由来证明内核实现 J1939 中使用的寻址和传输方法是合理的：
* **寻址：** 当一个ECU上的进程通过 J1939 进行通信时，它不一定需要知道其源地址。但是，每个ECU至少应该有一个进程知道源地址。其他进程应能够复用该地址。这样，对于同一ECU的不同协作进程来说，地址参数就不会被重复。这种工作方式与UNIX的概念密切相关，在这个概念中程序只做一件事情并且做得很好。
* **动态寻址：** J1939 中的地址声明是时间敏感的。此外，在地址协商过程中，数据传输应当得到妥善处理。将此功能放在内核中消除了对于通过 J1939 通信的每个用户空间进程都需要实现这一功能的要求。这将产生一个具有适当寻址的统一 J1939 总线。
* **传输：** TP 和 ETP 都重用了某些PGNs以在其上传输大数据包。因此，不同的进程可以使用相同的TP和ETP PGNS而不实际知道这一点。各个TP和ETP会话必须在不同进程中进行序列化（同步）。内核适当地解决了这个问题，并消除了对于通过 J1939 通信的每个用户空间进程都需要实现序列化（同步）的要求。

J1939 定义了一些其他特性（如转发、网关、快速数据包传输等）。内核代码对于这些特性可能不会有助于协议的稳定性，因此这些部分被留给用户空间处理。
J1939 套接字在 CAN 网络设备上运行（参见 SocketCAN）。任何在 CAN 原始套接字上运行的 J1939 用户空间库仍然可以正常工作。
由于此类库不会与内核中的实现进行通信，因此必须注意这两者之间不能产生干扰。实际上，这意味着它们不能共享ECU地址。一个ECU（或虚拟ECU）地址只能被库独占使用，或者被内核系统独占使用。
J1939概念
==========

PGN
---

J1939协议使用了具有以下结构的29位CAN标识符：

  ============  ==============  ====================
  29位 CAN-ID
  --------------------------------------------------
  CAN-ID内的比特位置
  --------------------------------------------------
  28 ... 26     25 ... 8        7 ... 0
  ============  ==============  ====================
  优先级        PGN             SA（源地址）
  ============  ==============  ====================

PGN（参数组编号）是一个用来识别数据包的数字。PGN由以下部分组成：

  ============  ==============  =================  =================
  PGN
  ------------------------------------------------------------------
  CAN-ID内的比特位置
  ------------------------------------------------------------------
  25            24              23 ... 16          15 ... 8
  ============  ==============  =================  =================
  R（保留）     DP（数据页）   PF（PDU格式）     PS（PDU特定）
  ============  ==============  =================  =================

在J1939-21中，根据PF（PDU格式）是否小于240来区分PDU1格式和PDU2格式。此外，在使用PDU2格式时，PS字段包含所谓的“组扩展”，它是PGN的一部分。当使用PDU2格式时，组扩展设置在PS字段中。

  ===============  ========================
  PDU1格式（特定）（点对点）
  ----------------------------------------
  CAN-ID内的比特位置
  ----------------------------------------
  23 ... 16       15 ... 8
  ==============  ========================
  00h ... EFh     DA（目标地址）
  ==============  ========================

  ==============  ========================
  PDU2格式（广播）
  ----------------------------------------
  CAN-ID内的比特位置
  ----------------------------------------
  23 ... 16       15 ... 8
  ==============  ========================
  F0h ... FFh     GE（组扩展）
  ==============  ========================

另一方面，当使用PDU1格式时，PS字段包含所谓的“目标地址”，它不是PGN的一部分。当从用户空间向内核（反之亦然）传递PGN，并且使用PDU2格式时，PGN的PS字段应设置为零。目标地址应在其他地方设置。
关于PGN映射到29位CAN标识符，目标地址应当通过内核从标识符的相应比特位获取/设置。
地址分配
----------

可以使用静态和动态两种地址分配方法。
对于静态地址，内核不会进行额外的检查，并认为提供的地址是正确的。这个责任在于OEM或系统集成商。
对于动态地址分配，即所谓的地址声明(Address Claiming)，内核提供了额外的支持。在J1939中，任何ECU都以其64位NAME而闻名。在成功声明地址时，内核会记录下被声明的NAME和源地址。这是过滤策略的基础。默认情况下，目标地址不是本地的报文将被拒绝。
允许混合模式报文（从静态地址到动态地址或相反）。BSD套接字定义了用于获取/设置本地和远程地址的单独API调用，这些也适用于J1939套接字。
过滤
------

J1939定义了每个套接字的白名单过滤器，用户可以设置以接收J1939流量的子集。过滤可以基于以下内容：

* SA
* SOURCE_NAME
* PGN

当单个套接字上有多个过滤器，并且有一个报文匹配其中几个过滤器时，该套接字仅接收一次该报文。
如何使用J1939
===============

API调用
--------

在CAN上，您首先需要打开一个套接字以便通过CAN网络进行通信。
要使用J1939，需要包含`<linux/can/j1939.h>`。从这里开始，也会自动包含`<linux/can.h>`。要创建一个套接字，可以使用以下C语言代码：

```c
s = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);
```

J1939确实使用`SOCK_DGRAM`类型的套接字。在J1939规范中，连接是在传输协议会话的上下文中提及的。这些连接仍然将数据包发送到另一端（可能需要多个CAN数据包）。`SOCK_STREAM`类型不被支持。

成功创建套接字后，通常需要使用`bind(2)`和/或`connect(2)`系统调用来将套接字绑定到CAN接口。绑定和/或连接套接字后，可以从/向套接字进行`read(2)`和`write(2)`操作，或者像平常一样使用`send(2)`、`sendto(2)`、`sendmsg(2)`以及`recv*()`等对应的操作。还有一些J1939特定的套接字选项如下所述。

为了发送数据，必须先成功地执行`bind(2)`。`bind(2)`为套接字分配了一个本地地址。

与CAN不同的是，有效负载数据只是实际发送的数据，不包括其头部信息。头部信息是从`bind(2)`、`connect(2)`、`sendto(2)`和`recvfrom(2)`提供的sockaddr结构中获取的。一个大小为4的`write(2)`操作将生成一个包含4个字节的数据包。

对于J1939，sockaddr结构有一些扩展，具体如下：

```c
struct sockaddr_can {
   sa_family_t can_family;
   int         can_ifindex;
   union {
      struct {
         __u64 name;
                /* pgn:
                 * 8位: PS在PDU2情况下为1，其他情况下为0
                 * 8位: PF
                 * 1位: DP
                 * 1位: 保留
                 */
         __u32 pgn;
         __u8  addr;
      } j1939;
   } can_addr;
}
```

`can_family`和`can_ifindex`对其他SocketCAN套接字也有相同的作用。
`can_addr.j1939.pgn`指定了PGN（最大值为0x3ffff）。各个位的具体含义如上所示。
`can_addr.j1939.name`包含了64位的J1939 NAME。
`can_addr.j1939.addr`包含了地址。

`bind(2)`系统调用分配了本地地址，即发送数据包时的源地址。如果在`bind(2)`时设置了PGN，则将其作为接收过滤器使用。也就是说，只有匹配的PGN的数据包才能被接收。如果设置了ADDR或NAME，则也被用作接收过滤器，它将匹配传入数据包的目的NAME或ADDR。NAME过滤器仅在相应的Address Claiming已在此NAME下在CAN总线上完成，并由内核注册/缓存的情况下才起作用。
另一方面，`connect(2)` 会分配远程地址，即目标地址。从 `connect(2)` 获取的 PGN 在发送数据包时用作默认 PGN。如果设置了 ADDR 或 NAME，则将其用作默认的目标 ADDR 或 NAME。此外，在 `connect(2)` 期间设置的 ADDR 或 NAME 用作接收过滤器。它会匹配传入数据包的源 NAME 或 ADDR。
`write(2)` 和 `send(2)` 都会发送一个具有由 `bind(2)` 指定的本地地址和由 `connect(2)` 指定的远程地址的数据包。使用 `sendto(2)` 来覆盖目标地址。
如果设置了 `can_addr.j1939.name`（不等于 0），则内核会查找 NAME，并使用对应的 ADDR。如果没有设置 `can_addr.j1939.name`（等于 0），则使用 `can_addr.j1939.addr`。
创建套接字时，默认设置了一些合理的选项。有些选项可以通过 `setsockopt(2)` 和 `getsockopt(2)` 进行修改。
与接收路径相关的选项：

- `SO_J1939_FILTER` — 配置过滤器数组
- `SO_J1939_PROMISC` — 禁用由 `bind(2)` 和 `connect(2)` 设置的过滤器

默认情况下，不能发送或接收广播数据包。要启用发送或接收广播数据包，请使用套接字选项 `SO_BROADCAST`：

.. code-block:: C

     int value = 1;
     setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &value, sizeof(value));

以下图示说明了接收路径：

.. code::

                    +--------------------+
                    |  incoming packet   |
                    +--------------------+
                              |
                              V
                    +--------------------+
                    | SO_J1939_PROMISC?  |
                    +--------------------+
                             |  |
                         no  |  | yes
                             |  |
                   .---------'  `---------
|                      |
     +---------------------------+        |
     | bind() + connect() +      |        |
     | SOCK_BROADCAST filter     |        |
     +---------------------------+        |
                   |                      |
                   |<---------------------'
                   V
     +---------------------------+
     |      SO_J1939_FILTER      |
     +---------------------------+
                   |
                   V
     +---------------------------+
     |        socket recv()      |
     +---------------------------+

与传输路径相关的选项：
`SO_J1939_SEND_PRIO` — 更改套接字的默认发送优先级

发送期间的 Message Flags 及相关系统调用
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`send(2)`、`sendto(2)` 和 `sendmsg(2)` 接受一个 'flags' 参数。当前支持的标志位包括：

* `MSG_DONTWAIT`，即非阻塞操作
`recvmsg(2)`
^^^^^^^^^^

在大多数情况下，如果需要提取比 `recvfrom(2)` 提供的更多信息（例如数据包优先级和时间戳），则需要使用 `recvmsg(2)`。目标地址、名称以及数据包优先级（如果适用）会在 `recvmsg(2)` 调用中附加到 msghdr。可以使用 `cmsg(3)` 宏来提取这些信息，其中 `cmsg_level == SOL_J1939` 并且 `cmsg_type == SCM_J1939_DEST_ADDR`、`SCM_J1939_DEST_NAME` 或 `SCM_J1939_PRIO`。返回的数据是一个 `uint8_t` 类型的 `priority` 和 `dst_addr`，以及 `uint64_t` 类型的 `dst_name`。

.. code-block:: C

	uint8_t priority, dst_addr;
	uint64_t dst_name;

	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
		switch (cmsg->cmsg_level) {
		case SOL_CAN_J1939:
			if (cmsg->cmsg_type == SCM_J1939_DEST_ADDR)
				dst_addr = *CMSG_DATA(cmsg);
			else if (cmsg->cmsg_type == SCM_J1939_DEST_NAME)
				memcpy(&dst_name, CMSG_DATA(cmsg), cmsg->cmsg_len - CMSG_LEN(0));
			else if (cmsg->cmsg_type == SCM_J1939_PRIO)
				priority = *CMSG_DATA(cmsg);
			break;
		}
	}

动态寻址
------------------

使用已声明的地址与进行地址声明之间有所区别。要使用已经声明的地址，需要填写 `j1939.name` 成员并将其提供给 `bind(2)`。如果该名称先前已经声明了一个地址，则之后发送的所有消息都会使用那个地址，而 `j1939.addr` 成员将被忽略。
一个例外是 PGN 0x0ee00。这是“地址声明/无法声明地址”消息，内核会在必要时使用 `j1939.addr` 成员为该 PGN。
要声明一个地址，可以使用下面的代码示例：

.. code-block:: C

	struct sockaddr_can baddr = {
		.can_family = AF_CAN,
		.can_addr.j1939 = {
			.name = name,
			.addr = J1939_IDLE_ADDR,
			.pgn = J1939_NO_PGN,	/* 用于禁用 PGN 的 bind() 接收过滤器 */
		},
		.can_ifindex = if_nametoindex("can0"),
	};

	bind(sock, (struct sockaddr *)&baddr, sizeof(baddr));

	/* 对于地址声明必须允许广播 */
	int value = 1;
	setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &value, sizeof(value));

	/* 配置用于地址声明所需的 PGN 的高级接收过滤器 */
	const struct j1939_filter filt[] = {
		{
			.pgn = J1939_PGN_ADDRESS_CLAIMED,
			.pgn_mask = J1939_PGN_PDU1_MAX,
		}, {
			.pgn = J1939_PGN_REQUEST,
			.pgn_mask = J1939_PGN_PDU1_MAX,
		}, {
			.pgn = J1939_PGN_ADDRESS_COMMANDED,
			.pgn_mask = J1939_PGN_MAX,
		},
	};

	setsockopt(sock, SOL_CAN_J1939, SO_J1939_FILTER, &filt, sizeof(filt));

	uint64_t dat = htole64(name);
	const struct sockaddr_can saddr = {
		.can_family = AF_CAN,
		.can_addr.j1939 = {
			.pgn = J1939_PGN_ADDRESS_CLAIMED,
			.addr = J1939_NO_ADDR,
		},
	};

	/* 之后使用 sendto(2) 发送数据，其中数据设置为目标 NAME （小端格式）。如果提供的 NAME 与提供给 bind(2) 的 j1939.name 不匹配，将返回 EPROTO 错误 */
```c
// 发送数据到指定的套接字
sendto(sock, dat, sizeof(dat), 0, (const struct sockaddr *)&saddr, sizeof(saddr));
```

如果在发送后250毫秒内没有其他实体对地址声明提出争议，内核会将NAME-SA分配标记为有效。有效的分配将会和其他有效的NAME-SA分配一起被保存。从那时起，任何绑定到该NAME的套接字都可以发送数据包。
如果有另一个ECU（电子控制单元）声称拥有该地址，则内核会将NAME-SA标记为过期。
任何绑定到该NAME的套接字都不能发送数据包（除了地址声明）。要声明另一个地址，需要有一个绑定到该NAME的套接字再次调用`bind(2)`，但是`j1939.addr`需要修改为新的SA，并且需要发送一个有效的地址声明数据包。这将重启内核（以及其他总线参与者）中的状态机针对这个NAME的操作。
`can-utils`也包含了`j1939acd`工具，因此它可以作为代码示例使用，或者作为默认的地址声明守护进程。

### 发送示例

#### 静态寻址

这个例子将从SA 0x20向DA 0x30发送一个PGN（0x12300）。
绑定：

```c
struct sockaddr_can baddr = {
    .can_family = AF_CAN,
    .can_addr.j1939 = {
        .name = J1939_NO_NAME,
        .addr = 0x20,
        .pgn = J1939_NO_PGN,
    },
    .can_ifindex = if_nametoindex("can0"),
};

bind(sock, (struct sockaddr *)&baddr, sizeof(baddr));
```

现在，套接字'sock'已绑定到SA 0x20。由于没有调用`connect(2)`，此时我们只能使用`sendto(2)`或`sendmsg(2)`。
发送：

```c
const struct sockaddr_can saddr = {
    .can_family = AF_CAN,
    .can_addr.j1939 = {
        .name = J1939_NO_NAME,
        .addr = 0x30,
        .pgn = 0x12300,
    },
};

sendto(sock, dat, sizeof(dat), 0, (const struct sockaddr *)&saddr, sizeof(saddr));
```
