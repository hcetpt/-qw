许可协议标识符：(GPL-2.0 或 BSD-3-Clause)

====================
ISO 15765-2 (ISO-TP)
====================

概述
========

ISO 15765-2，也被称为ISO-TP，是专门为在CAN（控制器局域网络）上进行诊断通信定义的传输协议。它在汽车行业广泛使用，例如作为UDSonCAN（ISO 14229-3）或与排放相关的诊断服务（ISO 15031-5）的传输协议。ISO-TP既可在传统的CAN网络（CAN CC，即经典CAN）上使用，也可在具有灵活数据率的CAN FD网络上使用。它还设计为与使用SAE J1939作为数据链路层的CAN网络兼容（但这不是必须的）。

使用的规范
-------------------

* ISO 15765-2:2024 : 道路车辆 - 通过控制器局域网络的诊断通信（DoCAN）。第2部分：传输协议和网络层服务

寻址
----------

以最简单的形式，ISO-TP基于两种寻址模式，用于连接到同一网络的节点：

* 物理寻址由两个特定于节点的地址实现，并用于点对点通信。
* 功能寻址由一个特定于节点的地址实现，并用于一点对多点通信。

可以使用三种不同的寻址格式：

* “正常”：每个地址仅由CAN ID表示。
* “扩展”：每个地址由CAN ID加上CAN有效载荷的第一个字节表示；两个地址之间的CAN ID和有效载荷内的字节都应不同。
* “混合”：每个地址由CAN ID加上CAN有效载荷的第一个字节表示；两个地址之间的CAN ID不同，但额外的字节相同。

传输协议及其相关帧类型
---------------------------------------------

当使用ISO-TP协议传输数据时，有效载荷可能适合在一个单独的CAN消息中，也可能不适合，这也要考虑到协议产生的开销以及可选的扩展寻址。在第一种情况下，数据一次性使用所谓的单帧（SF）进行传输。在第二种情况下，ISO-TP定义了一种多帧协议，在这种协议中，发送方通过初始帧（FF）提供要传输的PDU长度，并请求一个流量控制（FC）帧，该帧提供了宏数据块的最大支持大小（`blocksize`）以及组成该块的单个CAN消息之间的最小时间（`stmin`）。一旦收到这些信息，发送方开始发送包含数据有效载荷片段的帧（称为连续帧CF），并在每个`blocksize`大小的块后停止，等待接收方的确认，接收方随后应发送另一个流量控制帧，告知发送方其接收更多数据的能力。

如何使用ISO-TP
=================

与其他CAN协议一样，ISO-TP堆栈的支持构建在Linux网络子系统中，用于CAN总线，即Linux-CAN或SocketCAN，并遵循相同的套接字API。
### ISO-TP套接字的创建与基本使用
--------------------------------------------

要使用ISO-TP堆栈，需要包含`<linux/can/isotp.h>`。然后可以使用`PF_CAN`协议族、`SOCK_DGRAM`类型（因为底层协议本质上是基于数据报的）以及`CAN_ISOTP`协议来创建一个套接字：

```c
s = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP);
```

成功创建套接字后，应调用`bind(2)`将套接字绑定到所需的CAN接口；要做到这一点：

* 必须在传递给调用的`sockaddr`结构中指定发送(CAN ID)
* 还应指定接收(CAN ID)，除非通过套接字选项设置了广播标志（如下所述）

一旦绑定到接口，就可以使用通常的`read(2)`和`write(2)`系统调用来读取和写入套接字，也可以使用`send(2)`、`sendmsg(2)`、`recv(2)`和`recvmsg(2)`。
与`CAN_RAW`套接字API不同，仅通过这些调用发送和接收ISO-TP数据字段（实际的有效载荷）。地址信息和协议信息由ISO-TP堆栈根据创建套接字时提供的配置自动填充。同样地，当需要时（即，当数据有效载荷的大小超过底层CAN总线的最大传输单元(MTU)时），堆栈会使用传输机制。

用于SocketCAN的`sockaddr`结构为ISO-TP使用做了扩展，如下面所定义：

```c
struct sockaddr_can {
    sa_family_t can_family;
    int         can_ifindex;
    union {
        struct { canid_t rx_id, tx_id; } tp;
        ..
    } can_addr;
};
```

* `can_family` 和 `can_ifindex` 与其它SocketCAN套接字中的作用相同
* `can_addr.tp.rx_id` 指定了接收(CAN ID)，并将用作接收过滤器
* `can_addr.tp.tx_id` 指定了发送(CAN ID)

### ISO-TP套接字选项

创建ISO-TP套接字时，会设置合理的默认值。一些选项可以通过`setsockopt(2)`修改，并且/或通过`getsockopt(2)`读回。

#### 通用选项

通用套接字选项可以通过`CAN_ISOTP_OPTS`选项名传递：

```c
struct can_isotp_options opts;
ret = setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts));
```

其中`can_isotp_options`结构具有以下内容：

```c
struct can_isotp_options {
    u32 flags;
    u32 frame_txtime;
    u8  ext_address;
    u8  txpad_content;
    u8  rxpad_content;
    u8  rx_ext_address;
};
```

* `flags`: 应用于ISO-TP堆栈默认行为的修饰符。可用的标志包括：

  * `CAN_ISOTP_LISTEN_MODE`: 监听模式（不发送FC帧）；通常作为测试功能使用
* `CAN_ISOTP_EXTEND_ADDR`: 使用`ext_address`中指定的字节作为额外的地址组件。如果单独使用，这启用“混合”地址格式；如果与`CAN_ISOTP_RX_EXT_ADDR`一起使用，则启用“扩展”地址格式
* ``CAN_ISOTP_TX_PADDING``: 启用发送帧的填充功能，使用 ``txpad_content`` 作为填充字节的值。
* ``CAN_ISOTP_RX_PADDING``: 启用接收帧的填充功能，使用 ``rxpad_content`` 作为填充字节的值。
* ``CAN_ISOTP_CHK_PAD_LEN``: 检查接收帧的正确填充长度。
* ``CAN_ISOTP_CHK_PAD_DATA``: 检查接收帧的填充字节是否与 ``rxpad_content`` 相匹配；如果未指定 ``CAN_ISOTP_RX_PADDING``，则忽略此标志。
* ``CAN_ISOTP_HALF_DUPLEX``: 强制将 ISO-TP 套接字设置为半双工模式（即传输机制在同一时间只能是接收或发送，不能同时进行）。
* ``CAN_ISOTP_FORCE_TXSTMIN``: 忽略从接收的 FC 中的 stmin；通常作为测试特性使用。
* ``CAN_ISOTP_FORCE_RXSTMIN``: 忽略依赖于接收 stmin 的 CFs；通常作为测试特性使用。
* ``CAN_ISOTP_RX_EXT_ADDR``: 在接收路径中使用 ``rx_ext_address`` 而不是 ``ext_address`` 作为扩展寻址字节。若与 ``CAN_ISOTP_EXTEND_ADDR`` 结合使用，则该标志实际上启用了“扩展”寻址格式。
* ``CAN_ISOTP_WAIT_TX_DONE``: 在从 ``write(2)`` 和 ``send(2)`` 调用返回前等待帧发送完成（即，阻塞写操作）。
* ``CAN_ISOTP_SF_BROADCAST``: 使用 1 对 N 功能寻址（不能与 ``CAN_ISOTP_CF_BROADCAST`` 同时指定）。
* ``CAN_ISOTP_CF_BROADCAST``: 使用无流控的1对N传输模式（不能与``CAN_ISOTP_SF_BROADCAST``同时指定）
注意：这并不符合ISO 15765-2标准的覆盖范围
* ``CAN_ISOTP_DYN_FC_PARMS``: 启用流控参数的动态更新
* ``frame_txtime``: 帧传输时间（在ISO标准中定义为N_As/N_Ar）；如果设为``0``，则使用默认值（或最后设置的值）
为了将传输时间设为``0``，应当使用``CAN_ISOTP_FRAME_TXTIME_ZERO``宏（等于0xFFFFFFFF）
* ``ext_address``: 扩展地址字节，在指定了``CAN_ISOTP_EXTEND_ADDR``标志时使用
* ``txpad_content``: 用于发送帧填充的字节
* ``rxpad_content``: 用于接收帧填充的字节
* ``rx_ext_address``: 接收路径上的扩展地址字节，在指定了``CAN_ISOTP_RX_EXT_ADDR``标志时使用

流控选项
~~~~~~~~~

流控(FC)选项可通过使用``CAN_ISOTP_RECV_FC``的optname来传递，以提供接收ISO-TP PDU的通信参数。
以下是给定代码段的中文翻译：

使用`code-block:: C`定义的`can_isotp_fc_options`结构体如下：

```c
struct can_isotp_fc_options fc_opts;
ret = setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_RECV_FC, &fc_opts, sizeof(fc_opts));
```

其中`can_isotp_fc_options`结构体内容为：

```c
struct can_isotp_options {
    u8 bs;       // 在流控制帧中提供的块大小
    u8 stmin;    // 在流控制帧中提供的最小间隔时间，可以有以下值（其他值保留）：
                 // 0x00 - 0x7F : 0 - 127 毫秒
                 // 0xF1 - 0xF9 : 100 微秒 - 900 微秒
    u8 wftmax;   // 在流控制帧中提供的最大等待帧数
};
```

链路层选项
~~~~~~~~~~

链路层(LL)选项可以通过`CAN_ISOTP_LL_OPTS`选项名称传递：

```c
struct can_isotp_ll_options ll_opts;
ret = setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &ll_opts, sizeof(ll_opts));
```

其中`can_isotp_ll_options`结构体内容为：

```c
struct can_isotp_ll_options {
    u8 mtu;      // 生成和接受的CAN帧类型，可以等于`CAN_MTU`对于传统CAN帧或`CANFD_MTU`对于CAN FD帧
    u8 tx_dl;    // 发送帧的最大有效载荷长度，可以是以下值之一：8, 12, 16, 20, 24, 32, 48, 64。大于8的值仅适用于CAN FD流量（即：`mtu = CANFD_MTU`）
    u8 tx_flags; // 在创建帧时设置到`struct canfd_frame.flags`中的标志，仅适用于CAN FD流量（即：`mtu = CANFD_MTU`）
};
```

发送stmin
~~~~~~~~

可以使用`CAN_ISOTP_TX_STMIN`选项名称强制执行发送最小间隔时间（stmin），并提供一个以微秒为单位的32位无符号整数stmin值；这将覆盖接收者在流控制帧中发送的值：

```c
uint32_t stmin;
ret = setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_TX_STMIN, &stmin, sizeof(stmin));
```

接收stmin
~~~~~~~~

可以使用`CAN_ISOTP_RX_STMIN`选项名称强制执行接收最小间隔时间（stmin），并提供一个以微秒为单位的32位无符号整数stmin值；接收到的时间戳差异小于该值的连续帧(CF)将被忽略：

```c
uint32_t stmin;
ret = setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_RX_STMIN, &stmin, sizeof(stmin));
```

多帧传输支持
-------------

Linux内核中包含的ISO-TP堆栈支持标准定义的多帧传输机制，但存在以下限制：

* PDU的最大尺寸由模块参数定义，在构建时有一个硬性限制。
* 当正在进行传输时，后续的`write(2)`调用将会阻塞，而`send(2)`调用将根据是否存在`MSG_DONTWAIT`标志，要么阻塞要么失败。
* 不支持发送“等待帧”：PDU是否可以完全接收是在接收到首帧时决定的。

错误报告
--------

以下错误会报告给用户空间：

接收路径错误
~~~~~~~~~~

错误代码| 描述
---|---
-ETIMEDOUT| 数据接收超时
-EILSEQ| 多帧接收期间序列号不匹配
-EBADMSG| 接收数据填充错误

发送路径错误
~~~~~~~~~~

错误代码| 描述
---|---
-ECOMM| 流控制接收超时
-EMSGSIZE| 流控制接收溢出
-EBADMSG| 流控制接收布局/填充错误

示例
====

基本节点示例
------------

以下示例实现了一个使用“正常”物理寻址的节点，其RX ID等于0x18DAF142，TX ID等于0x18DA42F1。所有选项都保持默认。
```c
// 以下是一个使用C语言的代码段，用于设置和绑定一个CAN ISOTP套接字。

int s;                          // 套接字描述符
struct sockaddr_can addr;       // CAN地址结构
int ret;                        // 返回值

// 创建一个CAN ISOTP套接字
s = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP);
if (s < 0) {
    exit(1);                    // 如果创建失败，则退出程序
}

// 设置CAN地址
addr.can_family = AF_CAN;       // CAN地址族
addr.can_ifindex = if_nametoindex("can0"); // 根据接口名称获取索引，这里为"can0"
addr.tp.tx_id = 0x18DA42F1 | CAN_EFF_FLAG; // 设置发送ID，使用扩展帧标识符
addr.tp.rx_id = 0x18DAF142 | CAN_EFF_FLAG; // 设置接收ID，同样使用扩展帧标识符

// 将套接字绑定到CAN地址上
ret = bind(s, (struct sockaddr *)&addr, sizeof(addr));
if (ret < 0) {
    exit(1);                    // 如果绑定失败，则退出程序
}

// 现在可以使用read(s, ...)接收数据，并使用write(s, ...)发送数据了
```

更多示例
--------

更完整（也更复杂）的示例可以在`isotp*`用户空间工具中找到，这些工具作为`can-utils`实用程序的一部分分发，可从以下链接获取：
https://github.com/linux-can/can-utils

这段代码展示了如何在C语言中使用Linux的CAN ISOTP协议栈来创建、配置并绑定一个CAN ISOTP套接字。通过使用`socket`函数创建套接字，`bind`函数将其与特定的CAN接口和ID绑定，从而实现CAN网络上的数据收发功能。
