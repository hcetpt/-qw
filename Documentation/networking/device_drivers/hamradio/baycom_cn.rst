SPDX 许可证标识符: GPL-2.0

===============================
Baycom 调制解调器的 Linux 驱动程序
===============================

Thomas M. Sailer, HB9JNX/AE4WA, <sailer@ife.ee.ethz.ch>

由于 Baycom 调制解调器的驱动程序没有共享任何代码，因此这些驱动程序已经被拆分成独立的驱动程序，并且驱动程序和设备名称也已更改。
本文档描述了简单的 Baycom 风格业余无线电调制解调器的 Linux 内核驱动程序。
以下驱动程序可用：
====================================

baycom_ser_fdx：
  此驱动程序支持 SER12 调制解调器，支持全双工或半双工操作。
  其波特率可以通过模块参数 `baud` 进行更改，因此它几乎支持所有串口上的位敲击（bit bang）调制解调器。其设备名为 bcsf0 至 bcsf3。
  这是推荐用于 SER12 类型调制解调器的驱动程序，但如果您的 UART 克隆有问题，无法正常工作时，您可以尝试使用 baycom_ser_hdx。

baycom_ser_hdx：
  这是另一个用于 SER12 类型调制解调器的驱动程序。
  它仅支持半双工操作，并且仅支持 1200 波特率。其设备名为 bcsh0 至 bcsh3。如果 baycom_ser_fdx 在您的 UART 上无法工作，请使用此驱动程序。

baycom_par：
  此驱动程序支持 par96 和 picpar 调制解调器。
  其设备名为 bcp0 至 bcp3。

baycom_epp：
  此驱动程序支持 EPP 调制解调器。
其设备被称为 bce0 至 bce3。
此驱动程序仍在开发中。
以下调制解调器受支持：

======= ========================================================================
ser12   这是一个非常简单的 1200 波特率 AFSK 调制解调器。该调制解调器仅包含一个调制/解调芯片，通常是 TI TCM3105。计算机负责再生接收比特时钟以及处理 HDLC 协议。该调制解调器连接到串行端口，因此得名。由于串行端口不用于异步串行通信，所以不能使用内核的串行端口驱动程序，此驱动程序只支持标准串行硬件（8250、16450、16550）。

par96   这是一个符合 G3RUH 标准的 9600 波特率 FSK 调制解调器。该调制解调器完成所有滤波并再生接收时钟。数据通过移位寄存器与 PC 进行传输。移位寄存器填满 16 位后会发出中断信号。然后 PC 以突发方式清空移位寄存器。此调制解调器连接到并行端口，因此得名。该调制解调器将 HDLC 协议和扰码多项式的实现留给 PC。

picpar  这是 Henning Rech（DF9IC）重新设计的 par96 调制解调器。该调制解调器与 par96 协议兼容，但仅使用三个低功耗集成电路，因此可以从并行端口供电，不需要额外的电源。此外，它还集成了载波检测电路。

EPP     这是一款高速调制解调器适配器，连接到增强型并行端口。其目标用户是在高速集线器（76.8 kbit/s）上工作的用户。
eppfpga 这是对 EPP 适配器的重新设计
======= ======================================================================================

以上所有调制解调器仅支持半双工通信。然而，驱动程序支持 KISS（见下文）全双工命令。一旦有数据包需要发送时，它就会开始发送，并不关心载波检测信号（DCD），即即使信道上有其他设备在通信，它也会开始发送。这个命令是某些 DAMA 信道接入协议实现所必需的。
驱动程序接口
============================

与之前的驱动程序不同，这些驱动程序不再是字符设备，而是真正的内核网络接口。因此，安装非常简单。安装后，会出现四个名为 bc{sf,sh,p,e}[0-3] 的接口。可以使用 ax25 工具中的 sethdlc 命令来设置驱动程序状态等。
用户空间 AX.25 栈的用户可以使用 net2kiss 工具（也包含在 ax25 工具包中）将网络接口的数据包转换为伪终端上的 KISS 流。还有一个我提供的补丁，允许直接连接内核网络接口到 WAMPES。
配置驱动程序
======================

每次将驱动程序插入内核时，它必须知道应该访问哪些端口上的调制解调器。这可以通过 setbaycom 工具完成。如果您只使用一个调制解调器，您也可以通过 insmod 命令行或通过 ``/etc/modprobe.d/*.conf`` 中的选项行来配置驱动程序。
示例如下：

```plaintext
modprobe baycom_ser_fdx mode="ser12*" iobase=0x3f8 irq=4
sethdlc -i bcsf0 -p mode "ser12*" io 0x3f8 irq 4
```

这两行代码将第一个端口配置为通过第一个串口（在 DOS 下为 COM1）驱动 ser12 调制解调器。mode 参数中的星号(*) 指示驱动程序使用软件 DCD 算法（见下文）：

```plaintext
insmod baycom_par mode="picpar" iobase=0x378
sethdlc -i bcp0 -p mode "picpar" io 0x378
```

这两行代码将第一个端口配置为通过第一个并口（在 DOS 下为 LPT1）驱动 picpar 调制解调器。（注意：picpar 表示硬件 DCD，而 par96 表示软件 DCD）
可以通过 sethdlc -a 或 kissparms 设置信道接入参数。请注意，这两个工具对这些值的解释略有不同。
硬件DCD与软件DCD
================================

为了避免空中碰撞，驱动程序必须知道信道何时忙碌。这是DCD电路/软件的任务。驱动程序可以使用软件DCD算法（options=1），或者使用硬件提供的DCD信号（options=0）。

ser12   如果使用软件DCD，则无线电的静噪应始终保持开启。强烈建议使用软件DCD算法，因为它比大多数硬件静噪电路更快。缺点是会略微增加系统负载。
par96   这种类型的调制解调器的软件DCD算法较差。由于调制解调器提供的信息不足，无法在软件中实现合理的DCD算法。因此，如果您的无线电连接到PAR96调制解调器的DCD输入端，则建议使用硬件DCD电路。
picpar  picpar调制解调器内置了硬件DCD，强烈推荐使用。

与其他Linux内核组件的兼容性
===============================================

串行驱动程序和Baycom串行驱动程序争夺相同的硬件资源。当然，一次只能有一个驱动程序访问给定的接口。串行驱动程序在启动时会获取所有能找到的接口。因此，Baycom驱动程序随后将无法访问这些串行端口。您可能需要通过命令`setserial /dev/ttyS# uart none`释放由串行驱动程序拥有的端口，其中#是接口编号。除非在`insmod`命令行上指定了某个端口，否则Baycom驱动程序在启动时不预留任何端口。另一种解决方法是将所有驱动程序编译为模块，并让kmod根据应用程序加载正确的驱动程序。现在并行端口驱动程序（baycom_par、baycom_epp）使用parport子系统来仲裁不同客户端驱动程序之间的端口。

vy 73s de

Tom Sailer, sailer@ife.ee.ethz.ch

hb9jnx @ hb9w.ampr.org
