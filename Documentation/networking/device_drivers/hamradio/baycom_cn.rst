### SPDX 许可证标识符：GPL-2.0

===============================
Baycom 调制解调器的 Linux 驱动程序
===============================

Thomas M. Sailer, HB9JNX/AE4WA, <sailer@ife.ee.ethz.ch>

针对 Baycom 调制解调器的驱动程序已经拆分成单独的驱动，因为它们之间并未共享代码，并且驱动和设备名称也已更改。
本文件描述了简单的 Baycom 风格业余无线电调制解调器的 Linux 内核驱动程序。
以下驱动程序可用：
====================================

**baycom_ser_fdx**
  该驱动支持 SER12 调制解调器，无论是全双工还是半双工。
  其波特率可以通过 `baud` 模块参数进行更改，因此它几乎支持所有串口上的位敲击（bit-bang）调制解调器。其设备名称为 bcsf0 至 bcsf3。
  这是推荐用于 SER12 类型调制解调器的驱动程序，但如果您的 UART 克隆存在无法正常工作的状态位问题，您可以尝试使用 baycom_ser_hdx。
**baycom_ser_hdx**
  这是适用于 SER12 类型调制解调器的替代驱动程序。
  它仅支持半双工，并且只支持 1200 波特率。其设备名称为 bcsh0 至 bcsh3。只有当 baycom_ser_fdx 在您的 UART 上无法工作时才应使用此驱动程序。
**baycom_par**
  该驱动支持 par96 和 picpar 调制解调器。
  其设备名称为 bcp0 至 bcp3。
**baycom_epp**
  该驱动支持 EPP 调制解调器。
其设备被称为 bce0 至 bce3。
此驱动程序仍在开发中。
以下调制解调器得到支持：

====== ========================================================================
ser12   这是一个非常简单的 1200 波特 AFSK 调制解调器。该调制解调器仅由一个调制/解调芯片组成，通常是 TI TCM3105。计算机负责再生接收比特时钟以及处理 HDLC 协议。由于它连接到串行端口，因此得名。由于串行端口不用于异步串行通信，因此无法使用内核的串行端口驱动程序，并且此驱动程序仅支持标准串行硬件（8250、16450、16550）。

par96   这是一个符合 G3RUH 标准的 9600 波特 FSK 调制解调器。该调制解调器完成所有的滤波并再生接收时钟。数据通过移位寄存器从 PC 发送至调制解调器和从调制解调器接收至 PC。移位寄存器填充 16 位后发出中断信号。随后 PC 以突发方式清空移位寄存器。此调制解调器连接到并行端口，因此得名。该调制解调器将 HDLC 协议和扰码多项式的实现留给 PC 完成。

picpar  这是 Henning Rech（DF9IC）重新设计的 par96 调制解调器。该调制解调器与 par96 协议兼容，但只使用三个低功耗集成电路，因此可以从并行端口供电，无需额外电源。此外，它还包含载波检测电路。

EPP     这是一款高速调制解调器适配器，可连接至增强型并行端口。
其目标用户是在高速集线器上工作的用户（76.8 kbit/s）。
这是对 EPP 适配器的重新设计。

以上所有的调制解调器只支持半双工通信。然而，驱动程序支持 KISS（见下文）全双工命令。一旦有数据包要发送时就开始发送，并不关心载波检测（DCD），即即使通道上还有其他人在通信时也会开始发送。这一命令被某些 DAMA 信道接入协议的实现所要求。
驱动程序的接口
============================

与之前的驱动程序不同，这些驱动程序不再是字符设备，而是真正的内核网络接口。因此安装变得简单。安装后，会有四个名为 bc{sf,sh,p,e}[0-3] 的接口可用。可以使用 ax25 工具中的 sethdlc 命令来设置驱动状态等。用户空间 AX.25 栈的用户可以使用 net2kiss 工具（同样包含在 ax25 工具包中）将网络接口的数据包转换为伪终端上的 KISS 流。还有一个来自我的补丁可供 WAMPES 使用，允许直接连接内核网络接口。
配置驱动程序
======================

每当一个驱动程序插入内核时，它必须知道应该访问哪些端口上的调制解调器。这可以通过 setbaycom 工具完成。如果你只使用一个调制解调器，也可以从 insmod 命令行（或通过 ``/etc/modprobe.d/*.conf`` 中的选项行）配置驱动程序。示例如下：

```shell
modprobe baycom_ser_fdx mode="ser12*" iobase=0x3f8 irq=4
sethdlc -i bcsf0 -p mode "ser12*" io 0x3f8 irq 4
```

这两行配置了第一个端口以在第一个串行端口（DOS 下的 COM1）驱动一个 ser12 调制解调器。模式参数中的 * 指令驱动程序使用软件 DCD 算法（见下文）：

```shell
insmod baycom_par mode="picpar" iobase=0x378
sethdlc -i bcp0 -p mode "picpar" io 0x378
```

这两行配置了第一个端口以在第一个并行端口（DOS 下的 LPT1）驱动一个 picpar 调制解调器。（注：picpar 暗示硬件 DCD，par96 暗示软件 DCD）
信道接入参数可以通过 sethdlc -a 或 kissparms 设置。需要注意的是，这两个工具对值的解释略有不同。
硬件DCD与软件DCD
=================================

为了避免空中碰撞，驱动程序必须知道信道何时处于忙碌状态。这是DCD电路/软件的任务。驱动程序可以使用软件DCD算法（options=1）或从硬件获取一个DCD信号（options=0）。
====== =================================================================
ser12   如果使用软件DCD，则无线电的静噪应始终打开。强烈建议使用软件DCD算法，因为它比大多数硬件静噪电路快得多。缺点是会稍微增加系统负载。
par96   这种类型的调制解调器所用的软件DCD算法相当差。由于调制解调器提供的信息不足，在软件中实现合理的DCD算法比较困难。因此，如果你的无线电连接到PAR96调制解调器的DCD输入端，推荐使用硬件DCD电路。
picpar  picpar调制解调器内置有硬件DCD，非常推荐使用。
====== =================================================================

与其他Linux内核组件的兼容性
===============================================

串行驱动程序和Baycom串行驱动程序竞争相同的硬件资源。当然，一次只能有一个驱动程序访问给定接口。串行驱动程序在启动时会尽可能抓取所有找到的接口。因此，随后Baycom驱动程序将无法访问串行端口。你可能需要通过命令`setserial /dev/ttyS# uart none`来释放串行驱动程序占用的端口，其中`#`是接口编号。除非在`insmod`命令行上指定了端口，否则Baycom驱动程序在启动时不保留任何端口。另一种解决方法是将所有驱动程序编译为模块，并让kmod根据应用程序加载正确的驱动程序。现在，平行端口驱动程序（baycom_par，baycom_epp）使用parport子系统在不同的客户端驱动程序之间仲裁端口。
vy 73s de

Tom Sailer, sailer@ife.ee.ethz.ch

hb9jnx @ hb9w.ampr.org
