### SPDX 许可证标识符: GPL-2.0

============================================================
### Linux 内核针对 Elastic 网络适配器（ENA）家族的驱动程序
============================================================

#### 概览
========

ENA 是一种网络接口，旨在充分利用现代 CPU 特性和系统架构。ENA 设备提供了一个轻量级的管理接口，具有最小数量的内存映射寄存器和通过管理队列（Admin Queue）扩展的命令集。该驱动支持一系列 ENA 设备，与链路速度无关（即同一驱动适用于 10GbE、25GbE、40GbE 等），并且具有一套协商并可扩展的功能集。

一些 ENA 设备支持 SR-IOV。此驱动同时用于 SR-IOV 的物理功能（PF）和虚拟功能（VF）设备。ENA 设备通过提供多个发送/接收队列对（最大数量由设备通过管理队列告知）、每个发送/接收队列对专用的 MSI-X 中断向量、自适应中断调节以及针对 CPU 缓存行优化的数据放置，实现高速和低开销的网络流量处理。

ENA 驱动支持行业标准的 TCP/IP 卸载特性，如校验和卸载。对于多核扩展支持接收端扩展（RSS）。ENA 驱动及其对应的设备实现了健康监控机制，例如看门狗，使得设备和驱动可以在应用程序透明的情况下恢复，以及调试日志。

部分 ENA 设备支持称为低延迟队列（LLQ）的工作模式，可以节省更多微秒级的时间。

#### ENA 源代码目录结构
===================================

| 目录/文件 | 描述 |
| --- | --- |
| ena_com.[ch] | 管理通信层。该层负责处理所有设备与驱动之间的管理（admin）通信。 |
| ena_eth_com.[ch] | 发送/接收数据路径。 |
以下是提供的文本的中文翻译：

`ena_admin_defs.h`    ENA 管理接口定义  
`ena_eth_io_defs.h`   ENA 数据路径接口定义  
`ena_common_defs.h`   适用于 `ena_com` 层的通用定义  
`ena_regs_defs.h`     ENA PCI 映射内存（MMIO）寄存器定义  
`ena_netdev.[ch]`     主要的 Linux 内核驱动程序  
`ena_ethtool.c`       ethtool 回调函数  
`ena_xdp.[ch]`        XDP 文件  
`ena_pci_id_tbl.h`    支持的设备 ID  

==================   ======================================================

管理接口：
==================

ENA 管理接口通过以下方式提供：

- PCIe 配置空间
- 设备寄存器
- 管理队列（AQ）和管理完成队列（ACQ）
- 异步事件通知队列（AENQ）

ENA 设备 MMIO 寄存器仅在驱动程序初始化期间访问，并且在后续正常设备操作过程中不再使用。
AQ 用于提交管理命令，而结果/响应则通过 ACQ 异步报告。
ENA 引入了一组较小的管理命令，为供应商特定扩展留有余地。大多数管理操作都封装在一个通用的获取/设置特性命令中。
以下管理队列命令得到支持：

- 创建 I/O 提交队列
- 创建 I/O 完成队列
- 销毁 I/O 提交队列
- 销毁 I/O 完成队列
- 获取特性
- 设置特性
- 配置异步事件通知队列（AENQ）
- 获取统计信息

参见 `ena_admin_defs.h` 以获取支持的“获取/设置”特性的列表。
异步事件通知队列（AENQ）是一个单向队列，用于 ENA 设备向驱动程序发送无法通过 ACQ 报告的事件。AENQ 事件被细分为不同的组。每个组可能包含多个症状，如下所示：

事件包括：

====================    ===============
组                     症状
====================    ===============
链路状态变更           **X**
致命错误               **X**
通知                    暂停流量
通知                    恢复流量
心跳检测                **X**
====================    ===============

ACQ 和 AENQ 共享相同的 MSI-X 中断向量。
心跳检测是一种特殊机制，允许监控设备的健康状况。
每秒钟由设备发送一次心跳检测事件。
驱动程序维护一个看门狗（WD）处理器，记录当前状态和统计信息。如果心跳检测事件未如预期那样发送，则 WD 会重置设备和驱动程序。

数据路径接口
=============

I/O 操作基于发送（Tx）和接收（Rx）提交队列（Tx SQ 和 Rx SQ）。每个 SQ 都有一个与之关联的完成队列（CQ）。
SQs 和 CQs 实现为连续物理内存中的描述符环。
ENA 驱动程序支持两种队列操作模式用于 Tx SQs：

- **常规模式：**
  在此模式下，Tx SQs 存在于主机的内存中。ENA 设备从主机内存中获取 ENA 发送描述符和数据包数据。
- **低延迟队列（LLQ）模式或“推送模式”：**
  在这种模式下，驱动程序将发送描述符和数据包的前 96 字节直接推送到 ENA 设备的内存空间。剩余的数据包有效载荷由设备获取。对于这种操作模式，驱动程序使用一个专用的 PCI 设备内存 BAR，该 BAR 以写合并能力进行映射。
**需要注意的是** 并非所有 ENA 设备都支持 LLQ，并且此功能在初始化时与设备协商确定。如果 ENA 设备不支持 LLQ 模式，则驱动程序回退到常规模式。
Rx SQs仅支持常规模式。
驱动程序为Tx和Rx都支持多队列。这具有多种好处：

- 减少了在给定以太网接口上的CPU/线程/进程争用
- 在完成时减少了缓存未命中率，特别是持有sk_buff结构的数据缓存行
- 处理接收到的报文时提高了进程级别的并行性
- 通过将报文处理导向到运行消费该报文的应用程序线程所在的CPU上，提高了数据缓存的命中率
- 硬件中断重定向
中断模式
==========

驱动程序为每个队列对（对于Tx和Rx方向）分配一个MSI-X向量。驱动程序还为管理（ACQ和AENQ）分配了一个专用的MSI-X向量。
管理中断注册是在Linux内核探测适配器时执行的，并且在移除适配器时取消注册。I/O队列中断注册是在适配器的Linux接口打开时执行的，并且在关闭接口时取消注册。
管理中断的名称如下：

   ena-mgmnt@pci:<PCI域:总线:插槽.功能>

对于每个队列对，有一个中断名称如下：

   <接口名称>-Tx-Rx-<队列索引>

ENA设备运行在自动屏蔽和自动清除中断模式下。也就是说，一旦MSI-X被传送到主机，其Cause位会被自动清除并且中断被屏蔽。在NAPI处理完成后，驱动程序会解除中断屏蔽。
中断调节
============

ENA驱动程序和设备可以运行在传统或自适应中断调节模式下。
**在传统模式下**，驱动程序根据静态中断延迟值指示设备推迟中断的发送。可以通过 `ethtool(8)` 配置中断延迟值。以下 `ethtool` 参数被驱动程序支持：`tx-usecs`、`rx-usecs`。

**在自适应中断调节模式下**，中断延迟值由驱动程序动态更新，并且根据流量特性在每个 NAPI 周期进行调整。
可以通过 `ethtool(8)` 的 :code:`adaptive_rx on|off` 参数来开启或关闭自适应合并功能。
关于自适应中断调节（DIM）的更多信息可以在 Documentation/networking/net_dim.rst 中找到。

.. _`RX copybreak`:

RX copybreak
============

RX copybreak 默认初始化为 ENA_DEFAULT_RX_COPYBREAK，并可通过 SIOCETHTOOL ioctl 的 ETHTOOL_STUNABLE 命令进行配置。
此选项控制了接收 RX 描述符将被重用的最大数据包长度。当接收到的数据包小于 RX copybreak 字节时，它会被复制到一个新的内存缓冲区中，并将 RX 描述符返回给硬件。
统计信息
==========

用户可以使用 `ethtool` 获取 ENA 设备和驱动程序的统计信息。驱动程序可以从设备收集常规或扩展统计信息（包括按队列统计信息）。
此外，在设备重置时，驱动程序会将统计信息记录到 syslog 中。
MTU
===

驱动程序支持任意大的 MTU，最大值与设备协商确定。驱动程序通过 SetFeature 命令（ENA_ADMIN_MTU 属性）配置 MTU。用户可以通过 `ip(8)` 和类似的遗留工具更改 MTU。
无状态卸载
==================

ENA 驱动程序支持：

- IPv4 头校验和卸载
- TCP/UDP 过 IPv4/IPv6 校验和卸载

RSS
===

- ENA 设备支持 RSS，允许灵活地对 Rx 流量进行引导。
- 支持 Toeplitz 和 CRC32 散列函数。
不同的L2/L3/L4字段组合可以被配置为哈希函数的输入。
- 驱动程序使用AQ SetFeature命令（ENA_ADMIN_RSS_HASH_FUNCTION、ENA_ADMIN_RSS_HASH_INPUT和ENA_ADMIN_RSS_INDIRECTION_TABLE_CONFIG属性）来配置RSS设置。
- 如果设置了NETIF_F_RXHASH标志，则将哈希函数计算出的32位结果设置在Rx CQ描述符中，并将其存入接收到的SKB中。
- 用户可以通过`ethtool(8)`提供哈希密钥、哈希函数并配置间接表。

数据路径
========

发送(Tx)
--
:code:`ena_start_xmit()`由堆栈调用。该函数执行以下操作：

- 映射数据缓冲区(``skb->data`` 和 frags)
- 在推模式下填充``ena_buf``用于推缓冲区（如果驱动程序和设备处于推模式）
- 为剩余的frags准备ENA缓冲区
- 从空的``req_id``环形缓冲中分配一个新的请求ID。请求ID是Tx信息中数据包的索引，用于处理乱序的发送完成情况
- 将数据包添加到Tx环中的适当位置
- 调用:code:`ena_com_prepare_tx()`，这是ENA通信层的一部分，它将``ena_bufs``转换为ENA描述符（并根据需要添加元ENA描述符）
* 此功能还会将 ENA 描述符及推送缓冲区复制到设备内存空间（如果处于推送模式）
- 向 ENA 设备写入一个门铃信号
- 当 ENA 设备完成数据包发送时，会触发一个完成中断
- 中断处理程序调度 NAPI
- 调用 :code:`ena_clean_tx_irq()` 函数。此函数处理由 ENA 生成的完成描述符，每个完成的数据包对应一个完成描述符
* 从完成描述符中获取 `req_id`。通过 `req_id` 获取数据包的 `tx_info`。解除数据缓冲区的映射，并将 `req_id` 返回到空的 `req_id` 环形队列
* 当完成描述符处理完毕或达到预算限制时，该功能停止
接收 (Rx)

- 当从 ENA 设备接收到一个数据包时
- 中断处理程序调度 NAPI
- 调用 :code:`ena_clean_rx_irq()` 函数。此函数调用 ENA 通信层函数 :code:`ena_com_rx_pkt()`，该函数返回用于新数据包的描述符数量，如果没有找到新数据包则返回零
`:code:`ena_rx_skb()`检查数据包长度：

  * 如果数据包较小（长度 < rx_copybreak），驱动程序为新数据包分配一个SKB，并将数据包的有效载荷复制到SKB的数据缓冲区中。
- 这样原始数据缓冲区不会传递给协议栈，而是被重用于未来的接收数据包。
* 否则，该函数取消Rx缓冲区的映射，将第一个描述符设置为`skb`的线性部分，其他描述符设置为`skb`的碎片。
- 更新新的SKB所需的信息（如协议、校验和硬件验证结果等），然后通过NAPI接口函数`:code:`napi_gro_receive()`将其传递给网络栈。

动态接收缓冲区(DRB)
------------------------

接收环中的每个接收描述符是一个单页内存（根据系统的配置，其长度可以是4KB或16KB）。
为了减少处理大量小数据包时所需的内存分配，当一个页面剩余超过2KB未使用空间时，驱动程序尝试重用该接收描述符的剩余空间。
下面是一个简单示例来说明这一机制：

::

        1. 驱动程序分配页面大小的接收缓冲区并将其传递给硬件
                +----------------------+
                |4KB 接收缓冲区         |
                +----------------------+

        2. 在这个缓冲区上接收到一个300字节的数据包

        3. 驱动程序增加该页面的引用计数，并将其作为大小为4KB - 300字节 = 3796字节的接收缓冲区返回给硬件
               +----+--------------------+
               |****|3796 字节接收缓冲区|
               +----+--------------------+

当加载了XDP程序，或者接收数据包小于rx_copybreak字节时（此时数据包会从接收缓冲区复制到为新分配的skb的线性部分，并且接收缓冲区保持原大小，参见`接收copybreak`_），则不使用这种机制。
