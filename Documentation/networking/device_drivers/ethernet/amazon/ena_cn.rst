SPDX 许可证标识符: GPL-2.0

============================================================
Linux 内核驱动程序：Elastic 网络适配器 (ENA) 家族
============================================================

概述
========

ENA 是一种网络接口，旨在充分利用现代 CPU 特性和系统架构。ENA 设备提供了一个轻量级的管理接口，该接口包含一组最小的内存映射寄存器，并通过管理队列（Admin Queue）提供一个可扩展的命令集。该驱动支持一系列 ENA 设备，与链路速度无关（即同一驱动适用于 10GbE、25GbE、40GbE 等），并且具有协商和可扩展的功能集。

一些 ENA 设备支持 SR-IOV。此驱动程序同时用于 SR-IOV 物理功能 (PF) 和虚拟功能 (VF) 设备。ENA 设备通过提供多个发送/接收队列对（最大数量由设备通过管理队列告知）、每个发送/接收队列对专用的 MSI-X 中断向量、自适应中断调节以及针对 CPU 缓存行优化的数据放置，实现了高速和低开销的网络流量处理。

ENA 驱动支持行业标准的 TCP/IP 卸载特性，如校验和卸载。接收端扩展（RSS）也得到了支持，以实现多核扩展。ENA 驱动及其对应的设备实现了健康监控机制，如看门狗，使得设备和驱动可以在应用程序透明的情况下恢复，并且支持调试日志。

一些 ENA 设备支持一种称为低延迟队列 (LLQ) 的工作模式，这可以节省数微秒的时间。

ENA 源代码目录结构
===================

=================   ======================================================
ena_com.[ch]        管理通信层。这一层负责处理设备与驱动之间的所有管理（admin）通信
ena_eth_com.[ch]    发送/接收数据路径
=================   ======================================================
```
ena_admin_defs.h    ENA 管理接口定义
ena_eth_io_defs.h   ENA 数据路径接口定义
ena_common_defs.h   ena_com 层的通用定义
ena_regs_defs.h     ENA PCI 内存映射（MMIO）寄存器定义
ena_netdev.[ch]     主要的 Linux 内核驱动程序
ena_ethtool.c       ethtool 回调函数
ena_xdp.[ch]        XDP 文件
ena_pci_id_tbl.h    支持的设备 ID
==================  ======================================================

管理接口：
==================

ENA 管理接口通过以下方式提供：

- PCIe 配置空间
- 设备寄存器
- 管理队列（AQ）和管理完成队列（ACQ）
- 异步事件通知队列（AENQ）

ENA 设备 MMIO 寄存器仅在驱动程序初始化期间访问，在进一步的正常设备操作中不使用。
AQ 用于提交管理命令，结果/响应通过 ACQ 异步报告。
ENA 引入了一小套管理命令，并留有供供应商扩展的空间。大多数管理操作被封装在一个通用的 Get/Set 特性命令中。
```
以下管理队列命令受支持：

- 创建 I/O 提交队列
- 创建 I/O 完成队列
- 销毁 I/O 提交队列
- 销毁 I/O 完成队列
- 获取特性
- 设置特性
- 配置异步事件通知队列（AENQ）
- 获取统计信息

有关支持的“获取/设置特性”属性列表，请参阅 `ena_admin_defs.h`

异步事件通知队列（AENQ）是一个单向队列，用于 ENA 设备向驱动程序发送无法通过 ACQ 报告的事件。AENQ 事件被细分为多个组。每个组可能有多种症状，如下所示：

事件包括：

====================    ===============
组                      症状
====================    ===============
链路状态变化             **X**
致命错误                 **X**
通知                     暂停流量
通知                     恢复流量
心跳检测                 **X**
====================    ===============

ACQ 和 AENQ 共享相同的 MSI-X 向量。
心跳检测是一种特殊机制，允许监控设备的健康状况。
每秒由设备传送一次心跳检测事件。
驱动程序维护一个看门狗（WD）处理器，记录当前状态和统计信息。如果心跳检测事件没有如期送达，则 WD 会重置设备和驱动程序。

数据路径接口
=============

I/O 操作基于发送队列（Tx SQ）和接收队列（Rx SQ）。每个 SQ 都有一个与之关联的完成队列（CQ）。
SQ 和 CQ 实现为连续物理内存中的描述符环。
ENA 驱动程序支持两种队列操作模式用于 Tx SQ：

- **常规模式：**
  在此模式下，Tx SQ 存在于主机内存中。ENA 设备从主机内存中获取 ENA 发送描述符和数据包数据。
- **低延迟队列（LLQ）模式或“推送模式”：**
  在此模式下，驱动程序将发送描述符和数据包的前 96 字节直接推送到 ENA 设备内存空间。设备随后获取剩余的数据包负载。对于这种操作模式，驱动程序使用一个专门的 PCI 设备内存 BAR，并以写合并能力进行映射。

**请注意** 并非所有 ENA 设备都支持 LLQ，此功能在初始化时与设备协商。如果 ENA 设备不支持 LLQ 模式，驱动程序将回退到常规模式。
Rx SQs 仅支持常规模式。
驱动程序支持 Tx 和 Rx 的多队列。这有多种好处：

- 减少给定以太网接口上的 CPU/线程/进程争用
- 完成时减少缓存未命中率，特别是持有 sk_buff 结构的数据缓存行
- 在处理接收数据包时增加进程级别的并行性
- 通过将数据包的内核处理引导到运行消费该数据包的应用程序线程所在的 CPU 上，从而提高数据缓存命中率
- 硬件中断重定向

中断模式
===============

驱动程序为每个队列对（包括 Tx 和 Rx 方向）分配一个单独的 MSI-X 向量。驱动程序还为管理（ACQ 和 AENQ）分配一个额外的专用 MSI-X 向量。
管理中断注册在 Linux 内核探测适配器时进行，并在适配器移除时取消注册。I/O 队列中断注册在适配器的 Linux 接口打开时进行，并在接口关闭时取消注册。
管理中断的名称如下：

   ena-mgmnt@pci:<PCI 域:总线:插槽.功能>

对于每个队列对，中断的名称如下：

   <接口名称>-Tx-Rx-<队列索引>

ENA 设备运行在自动屏蔽和自动清除中断模式。即一旦 MSI-X 被传递到主机，其原因位会自动清除并且中断被屏蔽。驱动程序在完成 NAPI 处理后解除中断屏蔽。

中断调节
====================

ENA 驱动程序和设备可以运行在传统的或自适应的中断调节模式中。
**在传统模式下**，驱动程序根据静态中断延迟值指示设备推迟中断的发送。中断延迟值可以通过 `ethtool(8)` 进行配置。该驱动程序支持以下 `ethtool` 参数：`tx-usecs`、`rx-usecs`。

**在自适应中断调节模式下**，中断延迟值由驱动程序动态更新，并根据流量特性在每个 NAPI 周期进行调整。自适应汇聚可以通过 `ethtool(8)` 的 :code:`adaptive_rx on|off` 参数进行开启或关闭。关于自适应中断调节（DIM）的更多信息，请参阅 Documentation/networking/net_dim.rst。

.. _`RX copybreak`:

RX copybreak
============

默认情况下，rx_copybreak 初始化为 ENA_DEFAULT_RX_COPYBREAK，并可通过 SIOCETHTOOL ioctl 的 ETHTOOL_STUNABLE 命令进行配置。此选项控制了接收时将被回收的 RX 描述符的最大数据包长度。当接收到小于 RX copybreak 字节的数据包时，它会被复制到一个新的内存缓冲区中，而 RX 描述符则返回给硬件。
统计信息
==========

用户可以使用 `ethtool` 获取 ENA 设备和驱动程序的统计信息。驱动程序可以从设备收集常规或扩展统计信息（包括每队列统计）。此外，在设备重置时，驱动程序会将统计信息记录到 syslog 中。
MTU
===

驱动程序支持任意大小的 MTU，最大值与设备协商确定。驱动程序使用 SetFeature 命令（ENA_ADMIN_MTU 属性）配置 MTU。用户可以通过 `ip(8)` 和类似的遗留工具更改 MTU。
无状态卸载
==================

ENA 驱动程序支持：

- IPv4 首部校验和卸载
- TCP/UDP 在 IPv4/IPv6 上的校验和卸载

RSS
===

- ENA 设备支持 RSS，允许灵活地对 Rx 流量进行导向。
- 支持 Toeplitz 和 CRC32 哈希函数。
不同的L2/L3/L4字段组合可以配置为哈希函数的输入。
- 驱动程序使用AQ SetFeature命令（ENA_ADMIN_RSS_HASH_FUNCTION、ENA_ADMIN_RSS_HASH_INPUT和ENA_ADMIN_RSS_INDIRECTION_TABLE_CONFIG属性）来配置RSS设置。
- 如果设置了NETIF_F_RXHASH标志，则将哈希函数生成的32位结果设置在接收的SKB中的Rx CQ描述符中。
- 用户可以通过`ethtool(8)`提供哈希密钥、哈希函数并配置间接表。

数据路径
========

发送 (Tx)
--
:code:`ena_start_xmit()` 由堆栈调用。此函数执行以下操作：

- 映射数据缓冲区（``skb->data`` 和 frags）
- 填充用于推送缓冲区的 ``ena_buf`` （如果驱动程序和设备处于推送模式）
- 准备剩余frags的ENA缓冲区
- 从空的 ``req_id`` 环中分配一个新的请求ID。请求ID是Tx信息中数据包的索引，用于处理乱序的Tx完成。
- 将数据包添加到Tx环的适当位置
- 调用 :code:`ena_com_prepare_tx()` ，这是ENA通信层的一部分，它将 ``ena_bufs`` 转换为ENA描述符（并根据需要添加元ENA描述符）
* 此功能还会将 ENA 描述符和推送缓冲区复制到设备内存空间（如果处于推送模式）
- 向 ENA 设备写入一个门铃信号
- 当 ENA 设备完成数据包发送时，会触发一个完成中断
- 中断处理程序调度 NAPI
- 调用 :code:`ena_clean_tx_irq()` 函数。此函数处理由 ENA 生成的完成描述符，每个完成的数据包对应一个完成描述符
* 从完成描述符中检索 ``req_id``。通过 ``req_id`` 获取数据包的 ``tx_info``。数据缓冲区被取消映射，并且 ``req_id`` 被返回到空的 ``req_id`` 环中
* 该函数在完成描述符处理完毕或达到预算限制时停止

接收 (Rx)
--

- 当从 ENA 设备接收到一个数据包时
- 中断处理程序调度 NAPI
- 调用 :code:`ena_clean_rx_irq()` 函数。此函数调用 ENA 通信层函数 :code:`ena_com_rx_pkt()`，该函数返回用于新数据包的描述符数量，如果没有找到新数据包则返回零
`:code:`ena_rx_skb()` 检查数据包长度：

  * 如果数据包较小（len < rx_copybreak），驱动程序会为新数据包分配一个 SKB，并将数据包的有效负载复制到 SKB 数据缓冲区。
- 这样，原始数据缓冲区不会传递给堆栈，而是被重用于未来的接收 (Rx) 数据包。
* 否则，该函数将取消映射接收 (Rx) 缓冲区，将第一个描述符设置为 `skb` 的线性部分，其他描述符设置为 `skb` 的 frags。
- 新的 SKB 会更新必要的信息（协议、校验和硬件验证结果等），然后通过 NAPI 接口函数 `:code:napi_gro_receive()` 传递给网络堆栈。

动态接收缓冲区 (DRB)
------------------------

接收环中的每个 RX 描述符是一个单页内存（长度取决于系统配置，可以是 4KB 或 16KB）。
为了减少处理大量小数据包时所需的内存分配，如果页面中剩余空间超过 2KB，则驱动程序尝试重用 RX 描述符的剩余空间。
这种机制的一个简单示例如下所示：

::

        1. 驱动程序分配一个页面大小的 RX 缓冲区并将其传递给硬件
                +----------------------+
                |4KB RX 缓冲区          |
                +----------------------+

        2. 在此缓冲区上接收到一个 300 字节的数据包

        3. 驱动程序增加该页面的引用计数，并将其作为大小为 4KB - 300 字节 = 3796 字节的 RX 缓冲区返回给硬件
               +----+--------------------+
               |****|3796 字节 RX 缓冲区  |
               +----+--------------------+

当加载了 XDP 程序或接收 (Rx) 数据包小于 rx_copybreak 字节时（此时数据包将从 RX 缓冲区复制到为新 `skb` 分配的线性部分，并且 RX 缓冲区保持原大小，参见 `RX copybreak`_），不使用此机制。
