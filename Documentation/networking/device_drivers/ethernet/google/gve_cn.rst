### SPDX 许可证标识符：GPL-2.0+

======================================
Linux 内核驱动程序：计算引擎虚拟以太网（gve）
======================================

#### 支持的硬件
===================
GVE 驱动程序绑定到单一 PCI 设备 ID，该 ID 用于在某些计算引擎虚拟机中找到的虚拟以太网设备。

+--------------+----------+---------+
| 字段         | 值       | 注释    |
+==============+==========+=========+
| 厂商 ID      | `0x1AE0` | Google  |
+--------------+----------+---------+
| 设备 ID      | `0x0042` |         |
+--------------+----------+---------+
| 子厂商 ID    | `0x1AE0` | Google  |
+--------------+----------+---------+
| 子设备 ID    | `0x0058` |         |
+--------------+----------+---------+
| 修订 ID      | `0x0`    |         |
+--------------+----------+---------+
| 设备类别     | `0x200`  | 以太网  |
+--------------+----------+---------+

#### PCI BARs
=============
GVE PCI 设备暴露了三个 32 位内存 BAR：
- Bar0 - 设备配置和状态寄存器
- Bar1 - MSI-X 向量表
- Bar2 - 中断、接收和发送门铃

#### 设备交互
===================
驱动程序与设备的交互方式如下：
- 寄存器
    - 一块 MMIO 寄存器
    - 更多细节请参见 gve_register.h
- 管理队列
    - 参见下面的描述
- 重置
    - 设备可以在任何时候被重置
- 中断
    - 参见下面支持的中断
- 发送和接收队列
    - 参见下面的描述

#### 描述符格式
------------------
GVE 支持两种描述符格式：GQI 和 DQO。这两种格式具有完全不同的描述符，将在下面进行描述。
#### 寻址模式
------------------
GVE 支持两种寻址模式：QPL 和 RDA
QPL（"队列页列表"）模式通过一组预先注册的页面进行数据通信
对于 RDA（"原始 DMA 寻址"）模式，页面集是动态的
因此，数据包缓冲区可以位于客户机内存的任何位置
#### 寄存器
---------
所有寄存器都是 MMIO 的
寄存器用于初始化和配置设备以及响应管理中断查询设备状态
#### 字节序
----------
- 管理队列消息和寄存器均为大端字节序
GQI描述符和数据路径寄存器采用大端格式。
DQO描述符和数据路径寄存器采用小端格式。
管理队列（AQ）
----------------
管理队列是一个PAGE_SIZE大小的内存块，被视为一系列的AQ命令数组，用于驱动程序向设备发送命令并设置资源。驱动程序和设备各自维护已提交和执行的命令数量。为了发出AQ命令，驱动程序必须执行以下操作（在适当加锁的情况下）：

1) 将新命令复制到管理队列数组中下一个可用的位置。
2) 将其计数器增加新命令的数量。
3) 将计数器写入GVE_ADMIN_QUEUE_DOORBELL寄存器。
4) 检查ADMIN_QUEUE_EVENT_COUNTER寄存器直到它的值等于写入门铃寄存器的值，或者直到超时。

设备会通过ADMIN_QUEUE_EVENT_COUNTER寄存器更新每个已执行的AQ命令的状态字段。
设备重置
-------------
通过将0x0写入AQ PFN寄存器触发设备重置。
这会导致设备释放由驱动程序分配的所有资源，包括管理队列本身。
中断
----------
驱动程序支持以下中断：

管理中断
~~~~~~~~~~
管理中断用于通知驱动程序检查GVE_DEVICE_STATUS寄存器。
处理管理中断的函数仅仅是将服务任务加入工作队列来检查寄存器，并确认中断。
通知块中断
~~~~~~~~~~~~~
通知块中断用于告诉驱动程序轮询与该中断相关的队列。
处理这些中断的函数安排相应的napi运行并轮询队列。
GQI 交通队列
------------
GQI 队列由描述符环和缓冲区组成，并被分配给一个通知块。
描述符环是大小为2的幂的环形缓冲区，由固定大小的描述符构成。它们使用位于Bar2中的 __be32 型门铃来推进头部指针。尾部指针则通过按顺序消费描述符并更新 __be32 计数器来推进。门铃和计数器都会溢出至零。
每个队列的缓冲区必须预先注册为队列页列表，而数据包只能放置在这些页面中。
发送
~~~~~
gve 将用于发送环的缓冲区映射到一个先进先出 (FIFO) 结构中，并在将数据包发送到网络接口控制器 (NIC) 之前将其复制到 FIFO 中。
接收
~~~~~
用于接收环的缓冲区被放入一个与描述符环相同长度的数据环中，头部和尾部指针共同跨越这些环推进。
DQO 交通队列
------------
- 每个发送 (TX) 和接收 (RX) 队列都分配有一个通知块。
- 发送队列（TX 和 RX 缓冲队列），它们向设备发送描述符，使用内存映射 I/O (MMIO) 门铃来通知设备有关新描述符的信息。
- 完成队列（RX 和 TX 完成队列），它们从设备接收描述符，使用一个“生成位”来确定描述符是由设备填充的。驱动程序初始化所有位为“当前生成”。设备将用“下一个生成”的信息填充接收到的描述符，这个“下一个生成”与“当前生成”相反。当环形缓冲区循环时，“当前/下一个生成”会被交换。
- 驱动程序有责任确保接收 (RX) 和发送 (TX) 完成队列不会溢出。这可以通过限制发送给硬件的描述符数量来实现。
- 发送 (TX) 数据包有一个 16 位完成标签 (completion_tag)，接收 (RX) 缓冲区有一个 16 位缓冲区 ID (buffer_id)。这些将在 TX 完成队列和 RX 队列中返回，以让驱动程序知道哪些数据包/缓冲区已完成。
传输
------
在传输前，数据包的缓冲区通过DMA（直接内存访问）映射以便设备能够访问。
数据包成功传输后，这些缓冲区会被取消映射。

接收
------
驱动程序将固定大小的缓冲区发布到硬件的接收（RX）缓冲队列上。在相关的接收队列上接收到的数据包可能会跨越多个描述符。
