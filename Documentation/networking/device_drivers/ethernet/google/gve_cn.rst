SPDX 许可证标识符: GPL-2.0+

==============================================================
Linux 内核驱动程序用于 Compute Engine 虚拟以太网（gve）:
==============================================================

支持的硬件
===================
GVE 驱动程序绑定到一个 PCI 设备 ID，该 ID 用于某些 Compute Engine 虚拟机中找到的虚拟以太网设备。
+--------------+----------+---------+
|字段          | 值       | 注释     |
+==============+==========+=========+
|供应商 ID     | `0x1AE0` | Google  |
+--------------+----------+---------+
|设备 ID       | `0x0042` |         |
+--------------+----------+---------+
|子供应商 ID   | `0x1AE0` | Google  |
+--------------+----------+---------+
|子设备 ID     | `0x0058` |         |
+--------------+----------+---------+
|修订 ID       | `0x0`    |         |
+--------------+----------+---------+
|设备类别      | `0x200`  | 以太网  |
+--------------+----------+---------+

PCI BARs
========
gVNIC PCI 设备暴露了三个 32 位内存 BARs：
- Bar0 - 设备配置和状态寄存器
- Bar1 - MSI-X 向量表
- Bar2 - 中断请求、接收和发送门铃

设备交互
===================
驱动程序与设备的交互方式如下：
 - 寄存器
    - 一块 MMIO 寄存器
    - 更多细节请参见 gve_register.h
 - 管理队列
    - 详见以下描述
 - 重置
    - 在任何时候都可以重置设备
 - 中断
    - 详见以下支持的中断
 - 发送和接收队列
    - 详见以下描述

描述符格式
------------------
GVE 支持两种描述符格式：GQI 和 DQO。这两种格式具有完全不同的描述符，将在下面进行描述。
寻址模式
------------------
GVE 支持两种寻址模式：QPL 和 RDA
QPL（"队列页面列表"）模式通过一组预先注册的页面传输数据
对于 RDA（"原始 DMA 寻址"）模式，页面集是动态的
因此，数据包缓冲区可以位于客户机内存中的任何位置
寄存器
---------
所有寄存器都是 MMIO 的
这些寄存器用于初始化和配置设备以及在响应管理中断时查询设备状态
字节序
----------
- 管理队列消息和寄存器均为大端字节序
GQI 描述符和数据路径寄存器采用大端字节序（Big Endian）
DQO 描述符和数据路径寄存器采用小端字节序（Little Endian）

管理队列（AQ）
-----------------
管理队列是一个大小为 `PAGE_SIZE` 的内存块，作为 AQ 命令数组处理，用于驱动程序向设备发出命令并设置资源。驱动程序和设备会分别记录已提交和执行的命令数量。为了发出 AQ 命令，驱动程序必须按以下步骤操作（并进行适当的锁定）：

1. 将新命令复制到 AQ 数组中下一个可用的位置。
2. 将其计数器增加新命令的数量。
3. 将计数器写入 `GVE_ADMIN_QUEUE_DOORBELL` 寄存器。
4. 轮询 `ADMIN_QUEUE_EVENT_COUNTER` 寄存器，直到其值等于写入门铃寄存器的值，或者直到超时。

设备将通过 `ADMIN_QUEUE_EVENT_COUNTER` 寄存器更新每个已报告执行的 AQ 命令的状态字段。

设备重置
---------
通过将 0x0 写入 AQ PFN 寄存器来触发设备重置。
这会导致设备释放所有由驱动程序分配的资源，包括 AQ 本身。

中断
----------
驱动程序支持以下中断：

管理中断
~~~~~~~~~~
管理中断用于通知驱动程序检查 `GVE_DEVICE_STATUS` 寄存器。
管理中断的处理程序只是将服务任务排队到工作队列中以检查寄存器并确认中断。

通知块中断
~~~~~~~~~~~~
通知块中断用于告知驱动程序轮询与该中断相关的队列。
这些中断的处理程序会调度相应的 NAPI 运行，并轮询队列。
GQI 交通队列
------------------
GQI 队列由一个描述符环和一个缓冲区组成，并被分配给一个通知块。
描述符环是大小为 2 的幂的环形缓冲区，由固定大小的描述符组成。它们使用位于 Bar2 中的 __be32 门铃来推进头部指针。尾部指针则通过按顺序消费描述符并更新一个 __be32 计数器来推进。门铃和计数器都会溢出回零。
每个队列的缓冲区必须提前注册为队列页列表，并且数据包只能放入这些页面中。

发送
~~~~~~~~
gve 将发送环中的缓冲区映射到一个 FIFO，并在将数据包发送到 NIC 之前将其复制到 FIFO 中。

接收
~~~~~~~
接收环中的缓冲区被放置到一个与描述符环相同长度的数据环中，头部和尾部指针一起推进。

DQO 交通队列
------------------
- 每个发送（TX）和接收（RX）队列都分配有一个通知块。
- 发送描述符到设备的 TX 和 RX 缓冲队列使用 MMIO 门铃来通知设备新的描述符。
- 接收来自设备的描述符的 RX 和 TX 完成队列使用一个“代号位”来知道描述符何时由设备填充。驱动程序初始化所有位为“当前代号”。设备会用“下一代号”填充接收到的描述符，而“下一代号”与“当前代号”相反。当环形缓冲区循环时，“当前/下一代号”会被交换。
- 驱动程序需要确保 RX 和 TX 完成队列不会溢出。这可以通过限制发送到硬件的描述符数量来实现。
- 发送（TX）数据包具有 16 位完成标签（completion_tag），接收（RX）缓冲区具有 16 位缓冲区 ID（buffer_id）。这些将在 TX 完成队列和 RX 队列中返回，以便驱动程序知道哪个数据包/缓冲区已完成。
传输
~~~~~~
在传输前，数据包的缓冲区通过DMA映射供设备访问。
数据包成功传输后，这些缓冲区会被取消映射。

接收
~~~~~~
驱动程序将固定大小的缓冲区发布到硬件的接收缓冲区队列上。在关联的接收队列中接收到的数据包可能跨越多个描述符。
