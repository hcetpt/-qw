SPDX 许可声明标识符: GPL-2.0

===========================
蜘蛛网设备驱动程序
===========================

由 Linas Vepstas 编写 <linas@austin.ibm.com>

2007年6月7日版本

摘要
========
本文档概述了 Linux 内核树中蜘蛛网设备驱动程序的部分结构。蜘蛛网是一个千兆以太网设备，集成在常用于索尼 PlayStation 3 和 IBM QS20 Cell 刀片服务器的东芝南桥芯片中。
接收环的结构
=============================
接收 (RX) 环是一个由 RX 描述符组成的循环链表，以及三个用于管理其内容的指针。
环中的元素被称为“描述符”或“descrs”，它们描述接收到的数据。这包括指向包含接收数据的缓冲区的指针、缓冲区大小和各种状态位。
描述符有三种主要状态：“空”、“满”和“未使用”。一个“空”的或“就绪”的描述符准备从硬件接收数据。一个“满”的描述符含有数据，并等待被操作系统清空和处理。“未使用”的描述符既不是空也不是满；它仅仅是不可用。它可能甚至没有数据缓冲区，或者由于其他原因无法使用。
正常运行时，在设备启动时，操作系统（具体来说是蜘蛛网设备驱动程序）分配一组 RX 描述符和 RX 缓冲区。这些都被标记为“空”，准备接收数据。此环被交给硬件，硬件会顺序填充这些缓冲区，并将它们标记为“满”。随后，操作系统会取出这些满的缓冲区进行处理，然后将其重新标记为空。
这种填充和清空过程由三个指针管理：操作系统管理的“头”指针和“尾”指针，以及硬件当前描述符指针（GDACTDPA）。GDACTDPA 指向正在填充的描述符。当这个描述符被填满后，硬件将其标记为满，并使 GDACTDPA 向前移动一位。因此，在有 RX 流量的情况下，所有位于该指针后的描述符都应被标记为“满”，而所有位于其前面的描述符都应为“空”。如果硬件发现当前描述符并非空，则会触发中断并停止处理。
尾指针跟随硬件指针。当硬件领先时，尾指针将指向一个“满”的描述符。操作系统会处理这个描述符，并将其标记为“未使用”，然后移动尾指针。因此，在有 RX 流量的情况下，所有位于尾指针前面的描述符都应为“满”，而所有在其后面的描述符都应为“未使用”。当没有 RX 流量时，尾指针可以追上硬件指针。
此时，操作系统会注意到当前尾指针指向的是“空”的描述符，并停止处理。
头指针（命名有些误导性）位于尾指针之后。
当数据流正常传输时，头指针将指向一个“未使用”的描述符。操作系统将在该描述符上执行各种维护任务，包括分配一个新的数据缓冲区并进行DMA映射以使其对硬件可见。然后，操作系统会将该描述符标记为“空”，准备接收数据。因此，在有数据流接收（RX）的情况下，头指针之前的所有内容都应为“未使用”，而其后的内容都应为“空”。如果没有RX数据流，则头指针可以追上尾指针，在这一点上，操作系统会注意到头描述符是“空”的，并停止处理。

因此，在空闲系统中，GDACTDPA、尾和头指针都将指向同一个描述符，该描述符应该是“空”的。环中的其他所有描述符也应该是“空”的。
`show_rx_chain()`例程将打印出GDACTDPA、尾和头指针的位置。它还会总结环中的内容，从尾指针开始，并列出随后描述符的状态。

一个几乎处于空闲状态的系统的典型输出示例如下：

    网络 eth1: 描述符总数 = 256
    网络 eth1: 链路尾位于描述符 = 20
    网络 eth1: 链路头位于 20
    网络 eth1: 硬件当前描述符 (GDACTDPA) 位于 21
    网络 eth1: 有 1 个描述符，状态 = x40800101
    网络 eth1: 硬件下一个描述符 (GDACNEXTDA) 位于 22
    网络 eth1: 最后的 255 个描述符，状态 = xa0800000

在上述输出中，硬件填充了一个描述符，编号为 20。头指针和尾指针都指向 20，因为这个描述符尚未被清空。
同时，硬件指针指向 21，这是一个空闲的描述符。
“Have nnn 描述符”指的是从尾指针开始的描述符：在此例中，nnn = 1 个描述符，从描述符 20 开始。而“最后 nnn 个描述符”指的是从上次状态变化之后的所有其余描述符。“nnn”是指具有完全相同状态的描述符的数量。

状态 x4... 对应于“满”，而状态 xa... 对应于“空”。实际打印出来的值是 RXCOMST_A。

在设备驱动源代码中，对于这些相同的概念使用了不同的名称，即：

    “空” == SPIDER_NET_DESCR_CARDOWNED == 0xa
    “满” == SPIDER_NET_DESCR_FRAME_END == 0x4
    “未使用” == SPIDER_NET_DESCR_NOT_IN_USE == 0xf

### RX RAM 满的 Bug/特性

只要操作系统能够以快于硬件填充的速度清空 RX 缓冲区，就不会有问题。如果由于某种原因，操作系统未能足够快地清空 RX 环，硬件 GDACTDPA 指针将会追上头指针，检测到非空条件，并停止。然而，RX 数据包可能仍继续在网络中到达。

spidernet 芯片可以在本地 RAM 中保存一定数量的这些数据包。
当本地 RAM 填满时，spider 芯片会发出中断指示这种情况（GHIINT0STS 将显示 ERRINT，并且 GHIINT1STS 中的 GRMFLLINT 位会被设置）。当 RX RAM 满的情况发生时，会触发一个特定的 Bug/特性，需要特别处理。
本节描述了对该状况的特殊处理方式。
当操作系统最终有机会运行时，它会清空接收（RX）环。
具体来说，它将清除硬件停止的那个描述符。然而，一旦硬件认定某个描述符无效后，它不会从该描述符重新开始；而是从下一个描述符重启。这可能会导致死锁状况，因为尾指针会指向这个描述符，在操作系统看来，这个描述符是空的；操作系统会等待这个描述符被填充。然而，硬件已经跳过了这个描述符，并在填充后续的描述符。由于操作系统没有看到这一点，因此存在潜在的死锁：操作系统等待一个描述符被填充，而硬件则等待另一组不同的描述符变为空。

此时调用`show_rx_chain()`函数可以揭示问题的本质。当网络挂起时，通常的打印信息如下所示：

    网络 eth1: Spider RX RAM 已满，可能丢弃传入的数据包！
    网络 eth1: 描述符总数 = 256
    网络 eth1: 链的尾部位于描述符 255
    网络 eth1: 链的头部位于 255
    网络 eth1: 硬件当前描述符 (GDACTDPA) 位于 0
    网络 eth1: 有 1 个描述符的状态为 xa0800000
    网络 eth1: 硬件下一个描述符 (GDACNEXTDA) 位于 1
    网络 eth1: 有 127 个描述符的状态为 x40800101
    网络 eth1: 有 1 个描述符的状态为 x40800001
    网络 eth1: 有 126 个描述符的状态为 x40800101
    网络 eth1: 最后的 1 个描述符状态为 xa0800000

尾指针和头指针都指向描述符 255，该描述符标记为 xa... 表示“空”。因此，从操作系统的角度来看，没有什么可做的。特别是，有一种隐含的假设认为，在“空”描述符前面的所有内容肯定也是空的，如上一节所述。操作系统正在等待描述符 255 变为非空，但在这个情况下，这种情况永远不会发生。

硬件指针位于描述符 0。此描述符标记为 0x4... 或“满”。因为它已经是满的，硬件无法再做任何事情，从而停止了处理。注意描述符 0 到 254 都标记为“满”，而描述符 254 和 255 是空的。（“最后 1 个描述符”是指 254，因为尾指针在 255 处。）因此，系统处于死锁状态，无法向前推进；操作系统认为没有什么可做的，而硬件没有地方放置传入的数据。

这个缺陷/特性通过`spider_net_resync_head_ptr()`例程来解决。当驱动程序接收到 RX 中断，但检查 RX 链似乎表明它是空的时候，很可能硬件已经跳过了一两个（有时在网络负载重的情况下会跳过几十个）描述符。`spider_net_resync_head_ptr()` 子程序将在环中搜索下一个满的描述符，并从那里恢复操作。由于这会在环中留下“空洞”，还存在一个 `spider_net_resync_tail_ptr()` 来跳过这些空洞。

截至本文撰写之时，`spider_net_resync()` 策略似乎工作得非常好，即使在网络负载重的情况下也是如此。

### 发送（TX）环

发送（TX）环使用低水位标记中断方案来确保对于大尺寸数据包，TX 队列得到适当的维护。

对于大于约 1KB 的数据包大小，内核可以比设备更快地填满 TX 环。一旦环满，网卡就会停止。当环中有空间时，需要唤醒网卡，以便更多的 TX 数据包放入环中。硬件可以在每个时钟周期清空环大约四次，所以不适宜等待轮询例程来填充，因为轮询例程每时钟周期只运行一次。低水位标记机制在队列底部约四分之一处标记一个描述符，这样当处理该描述符时会生成一个中断。这个中断唤醒网卡，使其能够再次填充队列。
对于大型数据包，这种机制产生的中断数量相对较少，大约每秒1K个。而对于更小的数据包，这将降至零中断，因为硬件清空队列的速度比内核填充队列的速度快。
