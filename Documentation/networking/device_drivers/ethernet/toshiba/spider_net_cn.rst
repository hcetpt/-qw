SPDX 许可声明标识符：GPL-2.0

===========================
Spidernet 设备驱动程序
===========================

作者：Linas Vepstas <linas@austin.ibm.com>

2007年6月7日版本

摘要
========
本文档概述了 Linux 内核中 Spidernet 设备驱动程序的部分结构。Spidernet 是一种千兆以太网设备，集成在常用的东芝南桥芯片中，该芯片被用于索尼 PlayStation 3 和 IBM QS20 Cell 刀片服务器。

接收环的结构
=============================
接收（RX）环是一个由 RX 描述符构成的循环链表，并且有三个指针用于管理其内容。
环中的元素被称为“描述符”或“descrs”，它们描述接收到的数据。这包括指向包含接收到数据的缓冲区的指针、缓冲区大小以及各种状态位。
一个描述符可以处于三种主要状态：“空”、“满”和“未使用”。一个“空”的或“就绪”的描述符准备好从硬件接收数据。一个“满”的描述符中有数据，正在等待被操作系统清空并处理。“未使用”的描述符既不是空也不是满；它仅仅是不可用。它甚至可能没有数据缓冲区，或者以其他方式无法使用。
在正常操作过程中，在设备启动时，操作系统（具体来说是 Spidernet 设备驱动程序）会分配一组 RX 描述符和 RX 缓冲区。这些都标记为“空”，准备好接收数据。这个环交给硬件，硬件依次填充缓冲区，并将其标记为“满”。操作系统随后处理这些满的缓冲区，并重新标记为空。
这种填充和清空过程由三个指针管理：OS 管理的“头”指针和“尾”指针，以及硬件当前描述符指针（GDACTDPA）。GDACTDPA 指向当前正在填充的描述符。当这个描述符被填满后，硬件将其标记为“满”，并将 GDACTDPA 向前移动一位。因此，在有持续 RX 流量的情况下，所有在其后面的描述符都应该标记为“满”，所有在其前面的描述符都应该标记为“空”。如果硬件发现当前描述符不是空的，它将触发中断并停止处理。
尾指针跟随硬件指针。当硬件领先时，尾指针将指向一个“满”的描述符。操作系统将处理这个描述符，并将其标记为“未使用”，然后推进尾指针。因此，在有持续 RX 流量的情况下，所有在尾指针前面的描述符都应该标记为“满”，所有在其后面的描述符都应该标记为“未使用”。当 RX 流量不流动时，尾指针可以赶上硬件指针。
操作系统将注意到当前尾指针是“空”的，并停止处理。
头指针（命名有些误导性）跟随在尾指针之后。
当数据流正常传输时，头指针将指向一个“未使用”的描述符。操作系统将在该描述符上执行各种维护任务，包括分配一个新的数据缓冲区，并通过DMA映射使其对硬件可见。然后，操作系统会将描述符标记为“空”，准备好接收数据。因此，在有数据流入时，头指针前面的所有描述符都应该是“未使用”的状态，而其后面的描述符则应是“空”的状态。如果没有数据流入，则头指针可能会追上尾指针，此时操作系统会注意到头描述符是“空”的，并停止处理。

因此，在空闲系统中，GDACTDPA、尾指针和头指针都将指向同一个描述符，该描述符应该是“空”的。环中的其他所有描述符也应该是“空”的。

`show_rx_chain()` 函数将打印出 GDACTDPA、尾指针和头指针的位置，并总结环的内容，从尾指针开始，列出随后的描述符的状态。

对于几乎空闲系统的典型输出示例如下：

```
net eth1: Total number of descrs=256
net eth1: Chain tail located at descr=20
net eth1: Chain head is at 20
net eth1: HW curr desc (GDACTDPA) is at 21
net eth1: Have 1 descrs with stat=x40800101
net eth1: HW next desc (GDACNEXTDA) is at 22
net eth1: Last 255 descrs with stat=xa0800000
```

在上述输出中，硬件填充了一个描述符，编号为20。头指针和尾指针都指向20，因为它尚未被清空。同时，硬件指针指向21，这是空闲的。

“Have nnn descrs”指的是从尾指针开始的描述符：在此例中，nnn=1个描述符，从描述符20开始。“Last nnn descrs”指的是从上次状态改变以来的所有其余描述符。“nnn”表示具有相同状态的描述符的数量。

状态 x4... 对应于“满”，状态 xa... 对应于“空”。实际打印的值是 RXCOMST_A。

在设备驱动源代码中，这些相同的概念使用了不同的名称，具体如下：

- “空” == SPIDER_NET_DESCR_CARDOWNED == 0xa
- “满” == SPIDER_NET_DESCR_FRAME_END == 0x4
- “未使用” == SPIDER_NET_DESCR_NOT_IN_USE == 0xf

### RX RAM 满的 Bug/特性

只要操作系统能够以比硬件填充更快的速度清空 RX 缓冲区，就不会有问题。如果由于某种原因，操作系统未能及时清空 RX 环，硬件 GDACTDPA 指针将追上头指针，并注意到非空状态，从而停止。然而，数据包仍可能继续从网络线路上到达。

spidernet 芯片可以在本地 RAM 中保存一定数量的这些数据包。当本地 RAM 满时，spider 芯片会发出中断指示这种情况（GHIINT0STS 将显示 ERRINT，并且 GHIINT1STS 中的 GRMFLLINT 位会被设置）。当 RX RAM 满的情况发生时，会触发一个需要特别处理的 Bug/特性。
此节描述了对该条件的特殊处理方法。
当操作系统最终有机会运行时，它会清空接收（RX）环。
具体来说，它会清除硬件停止处理的描述符。然而，一旦硬件认定某个描述符无效后，它不会从该描述符重新开始；相反，它会从下一个描述符重新开始。这可能会导致死锁状态，因为尾指针会指向这个描述符，在操作系统看来这是空的；操作系统将会等待这个描述符被填充。然而，硬件已经跳过了这个描述符，并在填充后面的描述符。由于操作系统看不到这一点，因此有可能出现死锁：操作系统等待一个描述符被填充，而硬件则在等待另一组描述符变为空。

此时调用`show_rx_chain()`可以揭示问题的本质。网络挂起时的典型打印如下所示：

```
net eth1: Spider RX RAM full, incoming packets might be discarded!
net eth1: Total number of descrs=256
net eth1: Chain tail located at descr=255
net eth1: Chain head is at 255
net eth1: HW curr desc (GDACTDPA) is at 0
net eth1: Have 1 descrs with stat=xa0800000
net eth1: HW next desc (GDACNEXTDA) is at 1
net eth1: Have 127 descrs with stat=x40800101
net eth1: Have 1 descrs with stat=x40800001
net eth1: Have 126 descrs with stat=x40800101
net eth1: Last 1 descrs with stat=xa0800000
```

尾指针和头指针都指向描述符255，标记为`xa...`即“空”。因此，在操作系统看来，没有需要执行的操作。特别地，存在一个隐含假设：在“空”描述符之前的任何内容肯定也是空的，如上一节所述。操作系统正在等待描述符255变为非空，但在这种情况下永远不会发生。

硬件指针位于描述符0。此描述符标记为`0x4..`或“满”。由于已经是满的，硬件无法再做任何事情，从而停止了处理。注意，描述符0到254都被标记为“满”，而描述符254和255是空的。（“最后1个描述符”是描述符254，因为尾指针在255。）因此，系统处于死锁状态，无法前进；操作系统认为没有要做的事情，而硬件也没有地方放置传入的数据。

此bug/特性通过`spider_net_resync_head_ptr()`例程进行规避。当驱动程序接收到RX中断，但检查RX链似乎为空时，则可能是硬件跳过了一两个描述符（在网络负载重的情况下有时会跳过几十个）。`spider_net_resync_head_ptr()`子例程将在环中搜索下一个满的描述符，并从那里恢复操作。由于这会在环中留下“空洞”，因此还有一个`spider_net_resync_tail_ptr()`来跳过这些空洞。

截至本文撰写时，`spider_net_resync()`策略即使在网络负载很重的情况下也表现得非常好。

发送（TX）环
=============
发送（TX）环使用低水位标记中断方案来确保对于大包大小时TX队列得到适当的服务。
对于大于约1KB的包大小，内核可以比设备更快地填满TX环。一旦环满了，网卡就会停止。当环中有空间时，需要唤醒网卡以便将更多的发送包放入环中。硬件可以在每个时间片内清空环约四次，因此不适合等待轮询例程来填充，因为轮询例程每时间片只运行一次。低水位机制在队列底部约四分之一处标记一个描述符，当该描述符被处理时会生成中断。这个中断唤醒网卡，使其能够重新填充队列。
对于大型数据包，这种机制产生的中断数量相对较少，大约为每秒1K次。对于较小的数据包，这将减少到零中断，因为硬件清空队列的速度快于内核填充队列的速度。
