SPDX 许可证标识符: (GPL-2.0-only 或 BSD-2-Clause)

==================
内核 TLS 卸载
==================

内核 TLS 操作
====================

Linux 内核提供了 TLS 连接卸载基础设施。一旦 TCP 连接处于 `ESTABLISHED` 状态，用户空间就可以启用 TLS 上层协议 (ULP) 并安装加密连接状态。关于面向用户的接口的详细信息，请参阅 `Documentation/networking/tls.rst <kernel_tls>` 中的 TLS 文档。

`ktls` 可以在三种模式下运行：

* 软件加密模式 (`TLS_SW`) —— CPU 处理加密操作。在大多数基本情况下，只能使用与 CPU 同步的加密操作，但根据调用上下文，CPU 可能会利用异步加密加速器。使用加速器会在套接字读取时引入额外的延迟，并增加系统的 I/O 负载。
* 基于数据包的网卡卸载模式 (`TLS_HW`) —— 网卡逐个数据包地处理加密，前提是数据包按顺序到达。这种模式与内核堆栈集成得最好，并在本文档的剩余部分中详细描述（`ethtool` 标志 `tls-hw-tx-offload` 和 `tls-hw-rx-offload`）。
* 完整的 TCP 网卡卸载模式 (`TLS_HW_RECORD`) —— 在这种模式下，网卡驱动程序和固件替换内核网络堆栈，使用自己的 TCP 处理方式。此模式不适用于生产环境中使用 Linux 网络堆栈的情况，例如任何防火墙功能或 QoS 和数据包调度（`ethtool` 标志 `tls-hw-record`）。

操作模式是根据设备配置自动选择的，目前尚不支持基于每个连接的卸载启用或禁用。

TX
--

在高层次上，用户写请求会被转换为一个分散列表，TLS ULP 会拦截这些请求，插入记录帧，执行加密（在 `TLS_SW` 模式下），然后将修改后的分散列表交给 TCP 层。从这一点开始，TCP 堆栈继续正常工作。
在 `TLS_HW` 模式下，加密不在 TLS ULP 中进行。
相反，数据包会到达设备驱动程序，驱动程序会根据数据包关联的套接字对这些数据包进行加密卸载标记，并将它们发送到设备进行加密和传输（接收路径）。

在接收端，如果设备成功处理了解密和认证，驱动程序将在相关的 `:c:type:'struct sk_buff <sk_buff>'` 中设置解密位。数据包会到达TCP栈并被正常处理。当数据排队到套接字时，“ktls”会收到通知，并使用“strparser”机制来区分记录。在读取请求时，从套接字中检索记录并传递给解密例程。如果设备解密了记录的所有片段，则跳过解密；否则，软件路径处理解密。
.. kernel-figure:: tls-offload-layers.svg
   :alt: TLS卸载层
   :align: center
   :figwidth: 28em

   内核TLS堆栈的各层

设备配置
=========

在驱动程序初始化期间，设备设置了 `NETIF_F_HW_TLS_RX` 和 `NETIF_F_HW_TLS_TX` 牟能，并在其 `:c:type:'struct net_device <net_device>'` 的 `:c:member:'tlsdev_ops'` 成员中安装了 `:c:type:'struct tlsdev_ops <tlsdev_ops>'` 指针。当在“ktls”套接字上安装了TLS加密连接状态时（注意这需要执行两次，一次用于接收方向，一次用于发送方向，且两者完全独立），内核会检查底层网络设备是否支持卸载，并尝试卸载。如果卸载失败，则使用与从未尝试卸载相同的机制完全在软件中处理连接。卸载请求通过 `:c:type:'struct tlsdev_ops <tlsdev_ops>'` 的 `:c:member:'tls_dev_add'` 回调函数完成：

.. code-block:: c

    int (*tls_dev_add)(struct net_device *netdev, struct sock *sk,
                       enum tls_offload_ctx_dir direction,
                       struct tls_crypto_info *crypto_info,
                       u32 start_offload_tcp_sn);

`direction` 表示加密信息是用于接收还是发送的数据包。驱动程序使用 `sk` 参数来获取连接五元组和套接字家族（IPv4与IPv6）。`crypto_info` 中的加密信息包括密钥、初始化向量（IV）、盐以及TLS记录序列号。`start_offload_tcp_sn` 表示哪个TCP序列号对应于具有 `crypto_info` 中序列号的记录的起始点。驱动程序可以在内核结构的末尾添加其状态（参见 `include/net/tls.h` 中的 `:c:member:'driver_state'` 成员），以避免额外的分配和指针引用。

发送路径（TX）
--------------

安装TX状态后，堆栈保证流的第一个片段将恰好从 `start_offload_tcp_sn` 序列号开始，简化了TCP序列号匹配。TX卸载完全初始化并不意味着所有通过驱动程序且属于卸载套接字的片段都会在预期序列号之后，并且会有内核记录信息。特别是，在内核中安装连接状态之前，可能已经对某些数据进行了加密并将其排队到套接字。
### RX 方向

在 RX 方向上，本地网络堆栈对分段的控制较少，因此初始记录的 TCP 序列号可能位于分段内的任意位置。

### 正常操作

设备至少需要为每个连接、每个方向维护以下状态：

- 加密密钥（密钥、初始化向量、盐）
- 加密处理状态（部分数据块、部分认证标签等）
- 记录元数据（序列号、处理偏移量和长度）
- 预期的 TCP 序列号

无法保证记录长度或记录分段。特别是，分段可能从记录中的任何位置开始，并包含任意数量的记录。假设分段按顺序接收，设备应能够执行加密操作和认证，无论分段如何。为此，设备必须保持少量的跨分段状态，包括但不限于：

- 部分头部（如果一个分段只携带了部分 TLS 头部）
- 部分数据块
- 部分认证标签（所有数据都已看到，但认证标签的一部分需要从后续分段中写入或读取）

对于 TLS 卸载来说，不需要重新组装记录。如果数据包按顺序到达，设备应能够分别处理它们并继续前进。

### TX 方向

内核堆栈执行记录帧封装，预留认证标签的空间，并填充所有其他 TLS 头部和尾部字段。由于重传的可能性以及数据包到达设备后缺乏软件回退机制，设备和驱动程序都需要维护预期的 TCP 序列号。

对于按顺序传递的分段，驱动程序使用连接标识符标记数据包（注意：五元组查找不足以识别需要硬件卸载的数据包，参见 :ref:`5tuple_problems` 部分），并将它们交给设备。设备识别出数据包需要进行 TLS 处理，并确认序列号与预期相符。设备执行记录数据的加密和认证，并用正确的值替换认证标签和 TCP 校验和。

### RX 方向

在数据包通过 DMA 传输到主机之前（但在 NIC 的嵌入式交换和数据包转换功能之后），设备验证第 4 层校验和，并进行五元组查找以找到该数据包可能属于的任何 TLS 连接（技术上四元组查找就足够了——IP 地址和 TCP 端口号，因为协议总是 TCP）。如果匹配到连接，设备确认 TCP 序列号是否是预期的，并继续进行 TLS 处理（记录分界、解密、每个记录的认证）。设备保持记录帧不变，堆栈负责记录解封装。
设备指示在每个数据包上下文中成功处理了TLS卸载（描述符）并传递给主机。

当接收到一个经过TLS卸载的数据包时，驱动程序会在对应的数据报片段（`struct sk_buff <sk_buff>`）中设置`:c:member:`decrypted`标记。网络堆栈确保解密和未解密的段不会被合并（例如，通过GRO或套接字层），并且处理部分解密。

同步重置处理
=============

在网络丢包或数据包重新排序的情况下，设备可能会与TLS流失去同步，并需要与内核的TCP堆栈进行同步重置。
注意，仅对已成功添加到设备表中的连接且处于TLS_HW模式下尝试进行同步重置。例如，如果在内核中安装加密状态时表已满，则此类连接将永远不会被卸载。因此，同步请求不携带任何加密连接状态。

发送（TX）
--

从卸载套接字发送的段也可能出现同步问题，类似于接收端的情况——本地丢包是可能的，但网络重新排序则不会。目前有两种机制来处理顺序错误的段。

加密状态重建
~~~~~~~~~~~~~~

每当发送顺序错误的段时，驱动程序会向设备提供足够的信息以执行加密操作。这意味着很可能需要将当前段之前的记录部分作为数据包上下文的一部分传递给设备，连同其TCP序列号和TLS记录编号。然后，设备可以初始化其加密状态，处理并丢弃前面的数据（以便插入认证标签），并继续处理实际的数据包。
在这种模式下，根据实现情况，驱动程序可以要求使用新的序列号继续加密状态（下一个预期的段是在顺序错误的段之后的那个），或者继续使用之前的流状态——假设顺序错误的段只是一个重传。前者更简单，不需要重传检测，因此建议使用该方法直到证明其效率低下。

下一记录同步
~~~~~~~~~~~~

每当检测到顺序错误的段时，驱动程序请求`ktls`软件回退代码对其进行加密。如果段的序列号低于预期，驱动程序假定为重传并不改变设备状态。如果段在将来，可能意味着本地丢包，驱动程序请求堆栈将设备同步到下一记录状态并回退到软件处理。
同步请求通过以下方式表示：

```c
void tls_offload_tx_resync_request(struct sock *sk, u32 got_seq, u32 exp_seq)
```

在同步完成之前，驱动程序不应访问其预期的TCP序列号（因为它将从另一个上下文中更新）。
以下辅助函数用于测试重同步是否完成：

.. code-block:: c

  bool tls_offload_tx_resync_pending(struct sock *sk)

下次当 ``ktls`` 推送一个记录时，它将首先将其TCP序列号和TLS记录号发送给驱动程序。堆栈还会确保新的记录从一个段边界开始（就像初始添加连接时所做的那样）。

接收（RX）
----------

少量的接收重排序事件可能不需要完全重同步。特别是，当可以恢复记录边界时，设备不应失去同步：

.. kernel-figure::  tls-offload-reorder-good.svg
   :alt: 非头部段的重排序
   :align: center

   非头部段的重排序

绿色段表示成功解密，蓝色段表示按接收到的数据传递，红色条纹标记新记录的开始。在上述情况下，段1被成功接收并解密。段2丢失了，因此段3以错序到达。设备根据段1中的记录长度知道下一条记录开始于段3内部。由于缺少来自段2的数据，无法处理段3中前一条记录的剩余部分，因此段3保持不变地传递。然而，设备可以收集段3中新记录的部分块和认证算法的状态，并且当段4和5到达后继续解密。最后，当段2到达时，它完全超出了设备预期的窗口范围，因此无需特殊处理直接传递。``ktls`` 软件回退处理跨越段1、2和3的记录解密。尽管有两个段未被解密，但设备并未失去同步。

如果丢失的段包含记录头并且在下一个记录头已经通过之后到达，则可能需要内核同步：

.. kernel-figure::  tls-offload-reorder-bad.svg
   :alt: 头部段的重排序
   :align: center

   头部段的重排序

在这个示例中，段2丢失了，并且它包含了一个记录头。只有当设备知道来自段2的前一条记录长度时，才能检测到段4也包含一个TLS头。在这种情况下，设备将会与数据流失去同步。

流扫描重同步
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

当设备失去同步并且数据流达到超过预期TCP序列号的最大记录大小时，设备开始扫描已知的头部模式。例如，对于TLS 1.2和TLS 1.3，在头部的SSL/TLS版本字段中，后续字节值为 ``0x03 0x03``。一旦匹配到该模式，设备将继续尝试在预期位置解析头部（基于猜测位置的长度字段）。
每当预期位置不包含有效的头部时，扫描将重新启动。
当匹配到头部时，设备会向内核发送确认请求，询问猜测的位置是否正确（如果TLS记录确实从那里开始），以及给定头部的记录序列号是多少。
内核确认猜测的位置是正确的，并告诉设备记录的序列号。与此同时，设备一直在解析并计数自刚刚确认的那个记录以来的所有记录，它将所看到的记录数量加到内核提供的记录编号上。
此时，设备已同步，并可以在下一个段边界处恢复解密。
在极端情况下，设备可能会锁定一系列匹配的头部，并且永远收不到内核的回复（内核没有负面确认）。然而，考虑到误匹配流的可能性极低，定期重启扫描并不被认为是必要的。
如果确认请求异步传递给数据包流并且记录可能在确认请求之前被内核处理，则需要特别注意。
堆栈驱动的再同步
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

驱动程序也可以在发现记录不再被解密时请求堆栈执行再同步。
如果连接配置为此模式，则堆栈在接收到两个完全加密的记录后自动安排再同步。
堆栈等待套接字排空，并告知设备下一个预期记录的编号及其TCP序列号。如果记录继续以完全加密的方式接收，堆栈将以指数回退的方式重试同步（最初在接收到2个加密记录后，然后是4个记录，之后是8个，16个……直到每128个记录）。
错误处理
=========

TX
--

数据包可能被堆栈重定向或重新路由到不同于选定的TLS卸载设备的其他设备。堆栈将使用:c:func:`sk_validate_xmit_skb`辅助函数来处理这种情况（TLS卸载代码在此挂钩安装了:c:func:`tls_validate_xmit_skb`）。
卸载维护所有记录的信息，直到数据被完全确认，因此如果skbs到达错误的设备，可以由软件回退处理。
在传输侧，任何设备的TLS卸载处理错误都必须导致丢弃该数据包。例如，如果由于堆栈或设备中的错误导致数据包顺序错乱，并且到达设备后无法加密，则此类数据包必须被丢弃。

接收（RX）
----------

如果设备在接收侧遇到任何TLS卸载问题，它应将数据包原封不动地传递给主机的网络堆栈。
例如，段中任何记录的身份验证失败应导致将未修改的数据包传递给软件回退。这意味着数据包不应被“就地”修改。不建议拆分段来处理部分解密。换句话说，要么数据包中的所有记录都被成功处理并经过身份验证，要么必须将数据包原样传递给主机堆栈（如果设备提供精确错误信息，在驱动程序中恢复原始数据包就足够了）。
Linux网络堆栈没有提供报告每个数据包的解密和身份验证错误的方法，有错误的数据包只需不设置`:c:member:` `decrypted`标记即可。
此外，如果数据包包含错误的校验和，也不应由TLS卸载处理。

性能指标
========

TLS卸载可以通过以下基本指标进行描述：

* 最大连接数
* 连接安装速率
* 连接安装延迟
* 总体加密性能

需要注意的是，每个TCP连接需要双向的TLS会话，性能可以针对每个方向分别报告。

最大连接数
------------

设备可以支持的连接数量可以通过`devlink resource` API暴露出来。

总体加密性能
--------------

卸载性能可能取决于段和记录的大小。
设备的加密子系统过载不应显著影响未卸载的流的性能。
统计信息
==========

驱动程序应报告以下最小一组与TLS相关的统计数据：

 * ``rx_tls_decrypted_packets`` - 成功解密的接收（RX）数据包数量，这些数据包是TLS流的一部分
 * ``rx_tls_decrypted_bytes`` - 成功解密的接收（RX）数据包中的TLS有效载荷字节数
 * ``rx_tls_ctx`` - 添加到设备以进行解密的TLS接收硬件卸载上下文数量
 * ``rx_tls_del`` - 从设备中删除的TLS接收硬件卸载上下文数量（连接已结束）
 * ``rx_tls_resync_req_pkt`` - 接收到的带有重新同步请求的TLS数据包数量
 * ``rx_tls_resync_req_start`` - TLS异步重新同步请求开始的次数
 * ``rx_tls_resync_req_end`` - TLS异步重新同步请求正确结束并提供硬件跟踪的tcp-seq的次数
 * ``rx_tls_resync_req_skip`` - TLS异步重新同步请求过程开始但未正确结束的次数
 * ``rx_tls_resync_res_ok`` - 驱动程序成功处理TLS重新同步响应调用的次数
 * ``rx_tls_resync_res_skip`` - 驱动程序未能成功终止TLS重新同步响应调用的次数
* ``rx_tls_err`` - 接收（RX）的数据包数量，这些数据包属于TLS流，但由于状态机中的意外错误未能解密
* ``tx_tls_encrypted_packets`` - 传递给设备进行TLS负载加密的发送（TX）数据包数量
* ``tx_tls_encrypted_bytes`` - 传递给设备进行加密的发送（TX）数据包中TLS负载的字节数
* ``tx_tls_ctx`` - 添加到设备以进行TLS发送硬件卸载上下文的数量
* ``tx_tls_ooO`` - 属于TLS流但未按预期顺序到达的发送（TX）数据包数量
* ``tx_tls_skip_no_sync_data`` - 属于TLS流且到达顺序错乱，但跳过了硬件卸载例程并进入常规发送流程的发送（TX）数据包数量（因为它们是连接握手的重传）
* ``tx_tls_drop_no_sync_data`` - 属于TLS流但被丢弃的发送（TX）数据包数量，因为它们到达顺序错乱且无法找到关联记录
* ``tx_tls_drop_bypass_req`` - 属于TLS流但被丢弃的发送（TX）数据包数量，因为它们同时包含已被软件加密的数据和期望硬件加密卸载的数据

值得注意的特殊情况、异常和额外要求
=====================================

.. _5tuple_problems:

五元组匹配限制
-------------------

设备只能根据套接字的五元组识别接收到的数据包。当前的 ``ktls`` 实现不会卸载通过软件接口路由的套接字，如用于隧道或虚拟网络的接口。然而，许多由网络栈执行的数据包转换（最显著的是任何BPF逻辑）不需要任何中间软件设备，因此在设备级别上五元组匹配可能会一直失败。在这种情况下，设备仍然应该能够执行发送（TX）卸载（加密），并且应该干净地回退到软件解密（RX）。

顺序错乱
--------------

在网卡（NIC）中引入额外处理不应导致数据包传输或接收顺序错乱，例如纯ACK数据包不应与数据段重新排序。
### 入口重排序

允许设备对连续的TCP数据段进行数据包重排序（即按正确顺序放置数据包），但不允许任何形式的额外缓冲。

### 与标准网络卸载功能的共存

卸载的`ktls`套接字应透明地支持标准TCP堆栈功能。启用设备TLS卸载不应导致任何在链路上观察到的数据包差异。

### 传输层透明性

设备不得为了简化TLS卸载而修改任何数据包头部。
设备不得依赖于超出TLS卸载严格需要之外的任何数据包头部。

### 数据段丢弃

只有在发生灾难性系统错误的情况下才可接受丢弃数据包，并且不应将其作为处理正常操作中出现的问题的错误处理机制。换句话说，依靠TCP重传来处理边缘情况是不可接受的。

### TLS设备特性

驱动程序应忽略对TLS设备特性标志的更改。
这些标志将由核心`ktls`代码相应地处理。
TLS设备特性标志仅控制新TLS连接的卸载，标志清除后旧连接仍保持活动状态。
没有校验和计算卸载的情况下，TLS加密不能卸载到设备。因此，TLS TX设备特性标志要求设置TX校验和卸载。
禁用后者意味着清除前者。禁用TX校验和卸载不应影响旧连接，驱动程序应确保校验和计算不会因此中断。
同样地，设备卸载的TLS解密意味着需要执行RXCSUM。如果用户不希望启用RX校验和卸载，那么TLS接收设备功能也会被禁用。
