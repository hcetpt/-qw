SPDX 许可证标识符: (GPL-2.0-only 或 BSD-2-Clause)

==================
内核 TLS 卸载
==================

内核 TLS 操作
====================

Linux 内核提供了 TLS 连接卸载基础设施。一旦一个 TCP 连接处于 `ESTABLISHED` 状态，用户空间就可以启用 TLS 上层协议 (ULP) 并安装加密连接状态。关于面向用户的接口的详细信息，请参阅 `Documentation/networking/tls.rst <kernel_tls>` 中的 TLS 文档。
`ktls` 可以在三种模式下运行：

* 软件加密模式 (`TLS_SW`) - CPU 处理加密操作
  在大多数基本情况下，只能使用与 CPU 同步的加密操作，但根据调用上下文，CPU 可能会利用异步加密加速器。使用加速器会在套接字读取时引入额外延迟（仅当发出读取系统调用时才开始解密）并给系统增加额外的 I/O 负载。
* 基于包的 NIC 卸载模式 (`TLS_HW`) - NIC 按每个数据包处理加密，前提是数据包按顺序到达
  这种模式与内核堆栈集成最好，并在本文档剩余部分中详细描述 (`ethtool` 标志 `tls-hw-tx-offload` 和 `tls-hw-rx-offload`)
* 完整 TCP NIC 卸载模式 (`TLS_HW_RECORD`) - 在这种模式下，NIC 驱动程序和固件替换内核网络堆栈，拥有自己的 TCP 处理，它不适用于使用 Linux 网络堆栈进行例如任何防火墙功能或 QoS 和数据包调度的生产环境 (`ethtool` 标志 `tls-hw-record`)
操作模式基于设备配置自动选择，目前尚不支持针对每个连接的卸载启用或禁用。

发送 (TX)
--

在高层次上，用户的写请求被转换为分散列表，TLS ULP 拦截这些请求，插入记录帧，执行加密（在 `TLS_SW` 模式下），然后将修改后的分散列表传递给 TCP 层。从这一点开始，TCP 堆栈像往常一样继续工作。
在 `TLS_HW` 模式下，加密不在 TLS ULP 中执行。
### 包处理
相反，包会到达设备驱动程序，驱动程序将根据包所关联的套接字对这些包进行加密卸载标记，并将它们发送到设备进行加密和传输（接收方向，RX）。

### 接收侧处理
在接收侧，如果设备成功处理了解密和认证，驱动程序会在相关的`:c:type:`struct sk_buff <sk_buff>`中设置解密位。这些包到达TCP堆栈并被正常处理。当数据被排队到套接字时，“ktls”会被通知，并使用“strparser”机制来界定记录。在读取请求时，从套接字中检索记录并传递给解密例程。如果设备已经解密了记录的所有片段，则跳过解密步骤；否则，软件路径处理解密。
.. kernel-figure::  tls-offload-layers.svg
   :alt: TLS卸载层
   :align: center
   :figwidth: 28em

   内核TLS堆栈的各层

### 设备配置
#### 配置过程
在驱动初始化期间，设备设置`NETIF_F_HW_TLS_RX`和`NETIF_F_HW_TLS_TX`特性，并在其`:c:member:`tlsdev_ops`成员中安装其`:c:type:`struct tlsdev_ops <tlsdev_ops>`指针，该成员属于`:c:type:`struct net_device <net_device>`。当一个`ktls`套接字上安装了TLS加密连接状态（请注意，这需要做两次，一次针对接收方向，一次针对发送方向，且两者完全独立），内核会检查底层网络设备是否支持卸载，并尝试进行卸载。如果卸载失败，则整个连接将完全在软件中处理，就像从未尝试过卸载一样。
卸载请求是通过`:c:member:`tls_dev_add`回调函数完成的：

```c
int (*tls_dev_add)(struct net_device *netdev, struct sock *sk,
		   enum tls_offload_ctx_dir direction,
		   struct tls_crypto_info *crypto_info,
		   u32 start_offload_tcp_sn);
```

`direction`指示加密信息适用于接收还是发送的包。驱动程序使用`sk`参数来检索连接的五元组和套接字家族（IPv4与IPv6）。`crypto_info`中的加密信息包括密钥、初始化向量（IV）、盐值以及TLS记录序列号。`start_offload_tcp_sn`表示与`crypto_info`中的序列号对应的记录开始于哪个TCP序列号。驱动程序可以在内核结构的末尾添加其状态（参见`include/net/tls.h`中的`:c:member:`driver_state`成员），以避免额外的分配和指针引用。

### 发送方向（TX）
#### 处理流程
安装TX状态后，堆栈保证流的第一个片段将正好从`start_offload_tcp_sn`序列号开始，简化了TCP序列号匹配。
TX卸载完全初始化并不意味着所有通过驱动程序并且属于卸载套接字的片段都将在预期的序列号之后，并且具有内核记录信息。
特别是，在安装连接状态之前，可能已经有加密的数据被排队到了套接字中。
在接收（RX）方向上，本地网络堆栈对分段的控制较小，
因此初始记录的TCP序列号可能位于分段内的任意位置。
正常操作
========

对于每个连接，在每个方向上，设备至少需要维护以下状态：

 * 加密密钥（密钥、初始化向量、盐值）
 * 加密处理状态（部分数据块、部分认证标签等）
 * 记录元数据（序列号、处理偏移和长度）
 * 预期的TCP序列号

没有关于记录长度或记录分段的保证。特别是分段可以在记录中的任何位置开始，并且可以包含任意数量的记录。
假设分段是按顺序接收的，设备应该能够执行加密操作和认证，而不管分段如何。为此，设备必须保持少量的跨分段状态，这至少包括：

 * 部分报头（如果一个分段只携带了TLS报头的一部分）
 * 部分数据块
 * 部分认证标签（所有数据都已处理过，但认证标签的部分需要从后续分段中写入或读取）

对于TLS卸载而言，记录重组并非必要。如果数据包按顺序到达，设备应能分别处理它们并取得进展。
发送（TX）
=========

内核堆栈进行记录帧构建，为认证标签预留空间，并填充所有其他TLS头部和尾部字段。
由于可能出现重传以及一旦数据包到达设备后就没有软件回退的可能性，设备和驱动程序都需要维护预期的TCP序列号。
对于按顺序传递的分段，驱动程序使用连接标识符标记数据包（需要注意的是，五元组查找不足以识别需要硬件卸载的数据包；请参阅 :ref:`5tuple_problems` 部分）并将它们交给设备。设备识别出数据包需要进行TLS处理，并确认序列号符合其预期。
设备执行记录数据的加密和认证。
它用正确的值替换认证标签和TCP校验和。
接收（RX）
==========

在数据包被直接内存访问（DMA）到主机之前（但在网卡的嵌入式交换和数据包转换功能之后），设备验证第四层（Layer 4）校验和，并进行五元组查找以找到数据包可能所属的任何TLS连接（技术上四元组查找就足够了——IP地址和TCP端口号，因为协议总是TCP）。如果匹配到连接，设备确认TCP序列号是否与预期一致，并继续进行TLS处理（记录界定、解密、每条记录的认证）。设备保持记录帧不变，堆栈负责记录解封装。
设备指示在每包上下文中成功处理了TLS卸载（描述符）传递给主机
接收到一个经过TLS卸载的报文后，驱动程序会在与该段对应的 `struct sk_buff <sk_buff>` 的`:c:member:`decrypted` 标记中设置
网络堆栈确保已解密和未解密的段不会被合并（例如通过GRO或套接字层），并负责部分解密
同步恢复处理
================

在网络丢包或报文重新排序的情况下，设备可能会与TLS流失去同步，并需要与内核的TCP堆栈进行同步恢复
需要注意的是，仅对那些已成功添加到设备表中的连接尝试同步恢复，且这些连接处于TLS_HW模式。例如，
如果在内核中安装加密状态时设备表已满，则这样的连接将永远不会被卸载。因此，同步恢复请求
不携带任何加密连接状态
TX
--

从卸载套接字发送的段可能会出现类似接收端的情况，导致不同步——本地丢包是可能的，但网络重排序则不是。目前
有两种机制来处理顺序错误的段
重建加密状态
~~~~~~~~~~~~~~~~~~~~~~~

每当发送顺序错误的段时，驱动程序向设备提供足够的信息以执行加密操作
这意味着很可能需要将当前段之前的记录的一部分作为包上下文的一部分传递给设备，连同其TCP序列号和TLS记录编号。这样设备
就可以初始化其加密状态，处理并丢弃前面的数据（以便插入认证标签），然后继续处理实际的报文
在这种模式下，根据实现情况，驱动程序可以要求使用新的序列号继续加密状态（下一个预期段是在顺序错误段之后的一个），或者继续
使用之前的流状态——假设顺序错误的段只是一个重传。前者更简单，并不需要重传检测，因此在证明其效率低下之前，这是推荐的方法
下一个记录同步
~~~~~~~~~~~~~~~~

每当检测到顺序错误的段时，驱动程序请求 `ktls` 软件回退代码对其进行加密。如果段的序列号低于预期，则驱动程序假定为重传
并不改变设备状态。如果段位于未来时间点，可能意味着本地丢包，此时驱动程序会请求堆栈将设备同步到下一个记录状态，并回退到软件
同步恢复请求用以下方式表示：

.. code-block:: c

  void tls_offload_tx_resync_request(struct sock *sk, u32 got_seq, u32 exp_seq)

在同步恢复完成前，驱动程序不应访问其预期的TCP序列号（因为它将从不同的上下文中更新）
应使用以下辅助函数来检测重同步是否完成：

.. code-block:: c

  bool tls_offload_tx_resync_pending(struct sock *sk)

下一次`ktls`推送记录时，它将首先将其TCP序列号和TLS记录号发送给驱动程序。堆栈还会确保新记录从一个段边界开始（就像初始添加连接时所做的那样）。
RX
--

少量的接收重组事件可能不需要完全的重同步。特别是，在可以恢复记录边界的情况下，设备不应失去同步：

.. kernel-figure::  tls-offload-reorder-good.svg
   :alt:	非头部段的重组
   :align:	center

   非头部段的重组

绿色段表示成功解密，蓝色段表示按线上传输的情况传递，红色条纹标记新记录的开始
在上述情况下，段1被成功接收并解密。
段2丢失了，因此3以错序到达。设备根据段1中的记录长度知道新的记录开始于3内部。
段3未经处理直接传递，因为缺少来自段2的数据，无法处理段3中剩余的前一条记录。
然而，设备可以收集认证算法的状态以及段3中新记录的部分块，并且当4和5到达后继续解密。最后，当2到达时，它完全超出了设备预期的窗口，因此不作特殊处理直接传递。“ktls”软件回退处理跨越段1、2和3的记录的解密。尽管两个段没有被解密，但设备并未失去同步。
如果丢失的段包含记录头并且在下一个记录头已经通过之后到达，则可能需要内核同步：

.. kernel-figure::  tls-offload-reorder-bad.svg
   :alt:	含TLS头部的段的重组
   :align:	center

   含TLS头部的段的重组

在这个例子中，段2丢失了，而它包含了一个记录头。只有当设备知道来自段2的前一条记录的长度时，才能检测到段4也包含一个TLS头部。在这种情况下，设备将会与数据流失去同步。
流扫描重同步
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

当设备失去同步且数据流达到超过预期TCP序列号的最大尺寸记录的TCP序列号时，设备开始搜索已知的头部模式。例如，对于TLS 1.2和TLS 1.3，后续字节值为``0x03 0x03``出现在SSL/TLS版本字段中。一旦匹配到模式，设备将继续尝试在预期位置解析头部（基于在猜测位置的长度字段）。
每当预期位置不包含有效头部时，扫描将重新启动。
当匹配到头部时，设备向内核发送确认请求，
询问猜测的位置是否正确（如果TLS记录确实从那里开始），以及给定头部的记录序列号是多少。
内核确认猜测的位置是正确的，并告诉设备记录序列号。与此同时，设备一直在解析并计数自刚确认的记录以来的所有记录，它将所看到的记录数量加到内核提供的记录编号上。
此时，设备已经同步，可以在下一个段边界恢复解密。
在极端情况下，设备可能会锁定一系列匹配的头部而从未收到内核的回复（内核没有提供否定确认）。实现可以选择定期重启扫描。然而，考虑到错误匹配的流极为不可能，因此定期重启被认为没有必要。
如果确认请求异步传递到数据包流中且记录可能在确认请求之前被内核处理，则需要特别注意。
堆栈驱动的重新同步
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

驱动程序也可以在发现记录不再被解密时请求堆栈执行重新同步。
如果连接配置为此模式，则堆栈在接收到两个完全加密的记录后自动安排重新同步。
堆栈等待套接字清空，并告知设备下一个预期的记录编号及其TCP序列号。如果记录继续被完全加密接收，则堆栈将以指数退避的方式重试同步（首先在2个加密记录之后，然后在4个记录之后，接着在8个记录之后，在16个记录之后……直到每128个记录）。

错误处理
==========

TX
--

数据包可能会被堆栈重定向或重新路由到不同于选定TLS卸载设备的其他设备。堆栈将使用`:c:func:`sk_validate_xmit_skb`辅助函数来处理这种情况（TLS卸载代码在此钩子处安装了`:c:func:`tls_validate_xmit_skb`）。
卸载功能会维护所有记录的信息，直到数据被完全确认。因此，如果skbs到达错误的设备，可以通过软件回退机制来处理。

在传输侧，任何设备在处理TLS卸载时出现的错误都必须导致丢弃该数据包。例如，如果由于堆栈或设备中的bug导致数据包顺序混乱，并且该数据包到达了设备却无法加密，则此类数据包必须被丢弃。

接收（RX）

若设备在接收侧处理TLS卸载时遇到任何问题，应当将数据包原封不动地传递给主机的网络堆栈。

例如，对于分段中的任何记录认证失败的情况，应该将未修改的数据包传递给软件回退机制。这意味着数据包不应“就地”修改。不建议将分段拆分以处理部分解密。换句话说，要么数据包中的所有记录都被成功处理和验证，要么数据包需要按其原始状态传递给主机的堆栈（如果设备提供了精确的错误信息，则在驱动程序中恢复原始数据包即可）。

Linux网络堆栈没有提供报告每个数据包的解密和认证错误的方法，包含错误的数据包只需不设置`:c:member:``decrypted`标记即可。

如果数据包包含错误的校验和，则也不应由TLS卸载处理。

性能指标
========

TLS卸载可以通过以下基本指标进行描述：

* 最大连接数
* 连接安装速率
* 连接安装延迟
* 总体加密性能

需要注意的是，每个TCP连接都需要双向的TLS会话，可以分别报告每个方向的性能。

最大连接数
-------------

设备可支持的连接数可通过`devlink resource` API公开。

总体加密性能
--------------

卸载性能可能依赖于分段和记录大小。
设备的加密子系统的过载不应该对非卸载流产生显著的性能影响。
统计信息
========

驱动程序应报告以下与TLS相关的最小统计信息集：

 * `rx_tls_decrypted_packets` - 成功解密的接收（RX）数据包的数量，这些数据包是TLS流的一部分
 * `rx_tls_decrypted_bytes` - 成功解密的接收（RX）数据包中的TLS有效载荷字节数
 * `rx_tls_ctx` - 为解密而添加到设备中的TLS接收（RX）硬件卸载上下文的数量
 * `rx_tls_del` - 从设备中删除的TLS接收（RX）硬件卸载上下文的数量（连接已结束）
 * `rx_tls_resync_req_pkt` - 收到的带有重新同步请求的TLS数据包的数量
 * `rx_tls_resync_req_start` - 开始TLS异步重新同步请求的次数
 * `rx_tls_resync_req_end` - TLS异步重新同步请求正确结束并提供硬件跟踪的tcp-seq的次数
 * `rx_tls_resync_req_skip` - TLS异步重新同步请求过程开始但未正确结束的次数
 * `rx_tls_resync_res_ok` - 驱动程序成功处理TLS重新同步响应调用的次数
 * `rx_tls_resync_res_skip` - 驱动程序未能成功终止TLS重新同步响应调用的次数
* ``rx_tls_err`` - 接收（RX）的数据包数量，这些数据包属于TLS流的一部分，但由于状态机中的意外错误而未能解密。
* ``tx_tls_encrypted_packets`` - 传递给设备进行其TLS负载加密的发送（TX）数据包数量。
* ``tx_tls_encrypted_bytes`` - 传递给设备进行加密的发送（TX）数据包中的TLS负载字节数量。
* ``tx_tls_ctx`` - 添加到设备以进行加密的TLS发送（TX）硬件卸载上下文的数量。
* ``tx_tls_ooo`` - 属于TLS流但未按预期顺序到达的发送（TX）数据包数量。
* ``tx_tls_skip_no_sync_data`` - 属于TLS流并错序到达的发送（TX）数据包数量，但由于它们是连接握手的重传，所以跳过了硬件卸载例程，并转入常规发送流程。
* ``tx_tls_drop_no_sync_data`` - 属于TLS流并被丢弃的发送（TX）数据包数量，因为它们错序到达且无法找到关联记录。
* ``tx_tls_drop_bypass_req`` - 属于TLS流并被丢弃的发送（TX）数据包数量，因为它们同时包含已被软件加密的数据和期望硬件加密卸载的数据。

值得注意的特殊情况、异常及额外要求
======================================

.. _5tuple_problems:

五元组匹配限制
------------------

设备只能根据套接字的五元组来识别接收到的数据包。当前的 ``ktls`` 实现不会卸载通过软件接口路由的套接字，例如用于隧道或虚拟网络的接口。然而，网络堆栈执行的许多数据包转换（最显著的是任何BPF逻辑）不需要任何中间软件设备，因此在设备级别上可能始终会错过五元组匹配。在这种情况下，设备仍然应该能够执行发送（TX）卸载（加密），并且应当干净地回退到软件解密（接收）。

错序问题
------------

在网卡（NIC）中引入额外处理不应导致数据包传输或接收时出现错序，例如纯确认（ACK）数据包不应与数据段重新排序。
### 入口重组

允许设备对连续的TCP数据段进行包重组（即，将数据包按正确顺序排列），但不允许任何形式的额外缓冲。

### 与标准网络卸载功能的共存

被卸载到“ktls”套接字的功能应当透明地支持标准TCP堆栈特性。启用设备的TLS卸载不应在链路上产生任何差异。

### 传输层透明性

设备不应为了简化TLS卸载而修改任何数据包头部。
设备不应依赖于TLS卸载严格必需之外的任何数据包头部信息。

### 数据段丢弃

只有在灾难性的系统错误情况下才可接受丢弃数据包，并且绝不能将其作为处理正常运行中出现的问题时的错误处理机制。换句话说，依赖TCP重传来处理边缘情况是不可接受的。

### TLS 设备特性

驱动程序应忽略对TLS设备特性标志的更改。
这些标志将由核心“ktls”代码相应地处理。
TLS设备特性标志仅控制新增TLS连接卸载，清除标志后旧连接将继续保持活跃状态。
如果没有校验和计算卸载，则不能将TLS加密卸载到设备。因此，TLS TX设备特性标志需要设置TX校验和卸载。
禁用后者意味着清除前者。禁用TX校验和卸载不应影响旧连接，并且驱动程序应确保不会破坏它们的校验和计算。
同样地，设备卸载的TLS解密意味着需要执行接收校验和（RXCSUM）。如果用户不想启用接收校验和卸载功能，那么TLS接收（RX）设备特性也会被禁用。
