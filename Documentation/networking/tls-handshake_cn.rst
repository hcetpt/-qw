SPDX 许可证标识符: GPL-2.0

=======================
内核中的 TLS 握手
=======================

概述
========

传输层安全（TLS）是一种运行在 TCP 之上的上层协议（ULP）。TLS 提供端到端的数据完整性和机密性，以及对等认证。内核的 kTLS 实现处理了 TLS 记录子协议，但不处理用于建立 TLS 会话的 TLS 握手子协议。内核消费者可以使用这里描述的 API 请求建立 TLS 会话。
有几种可能的方法可以在内核中提供握手服务。这里描述的 API 设计为隐藏这些实现的细节，以便内核中的 TLS 消费者不需要知道握手是如何完成的。

用户握手代理
====================

截至本文撰写时，Linux 内核中没有 TLS 握手实现。为了提供握手服务，在每个网络命名空间中启动一个握手代理（通常在用户空间），以满足内核消费者可能需要的 TLS 握手需求。握手代理监听来自内核的事件，这些事件表明有一个等待中的握手请求。
一个打开的套接字通过 netlink 操作传递给握手代理，在握手代理的文件描述符表中创建一个套接字描述符。
如果握手成功完成，握手代理将套接字升级为使用 TLS ULP，并使用 SOL_TLS 套接字选项设置会话信息。握手代理通过第二次 netlink 操作将套接字返回给内核。

内核握手 API
====================

内核 TLS 消费者通过调用其中一个 tls_client_hello() 函数在一个打开的套接字上发起客户端侧的 TLS 握手。首先，它填充一个包含请求参数的结构：

.. code-block:: c

  struct tls_handshake_args {
        struct socket   *ta_sock; // 引用一个打开且已连接的套接字
        tls_done_func_t ta_done; // 包含一个回调函数，该函数在握手完成后被调用
        void            *ta_data; // 用户数据指针
        const char      *ta_peername; // 对方主机名
        unsigned int    ta_timeout_ms; // 超时时间（毫秒）
        key_serial_t    ta_keyring; // 密钥环
        key_serial_t    ta_my_cert; // 本地证书
        key_serial_t    ta_my_privkey; // 本地私钥
        unsigned int    ta_num_peerids; // 对方标识数量
        key_serial_t    ta_my_peerids[5]; // 最多五个对方标识
  };

@ta_sock 字段引用一个打开且已连接的套接字。消费者必须持有该套接字的引用，以防止在握手进行期间被销毁。消费者还必须在 sock->file 中实例化一个 struct file。
@ta_done 包含一个回调函数，该函数在握手完成后被调用。关于此函数的进一步解释，请参见下面的“握手完成”部分。
消费者可以在 @ta_peername 字段中提供一个终止于 NUL 的主机名，作为 ClientHello 的一部分发送。如果没有提供对等主机名，则使用与服务器 IP 地址关联的 DNS 主机名代替。
消费者可以填充 @ta_timeout_ms 字段，以强制服务握手代理在一定毫秒后退出。这使得一旦内核和握手代理都关闭了它们的端点，套接字就可以完全关闭。
认证材料，如X.509证书、私钥证书和预共享密钥，通过密钥提供给握手代理，这些密钥由消费者在发起握手请求前实例化。消费者可以提供一个私钥环，并将其链接到握手代理的进程密钥环中的`@ta_keyring`字段中，以防止其他子系统访问这些密钥。

要请求一个X.509认证的TLS会话，消费者需要填写`@ta_my_cert`和`@ta_my_privkey`字段，这两个字段包含X.509证书及其对应的私钥的序列号。然后调用以下函数：

```c
ret = tls_client_hello_x509(args, gfp_flags);
```

当握手请求正在进行时，该函数返回零。返回零保证了回调函数`@ta_done`将在此套接字上调用。如果握手无法启动，该函数将返回一个负的errno值。负的errno值保证了回调函数`@ta_done`不会在此套接字上调用。

要使用预共享密钥发起客户端TLS握手，使用：

```c
ret = tls_client_hello_psk(args, gfp_flags);
```

在这种情况下，消费者需要填写`@ta_my_peerids`数组，其中包含其希望提供的对等方身份的密钥序列号，并且在`@ta_num_peerids`字段中填写已填充的数组条目数。其他字段的填写与上述相同。

要发起匿名客户端TLS握手，使用：

```c
ret = tls_client_hello_anon(args, gfp_flags);
```

在这种类型的握手过程中，握手代理不会向远程端提供任何对等方身份信息。仅执行服务器认证（即客户端验证服务器的身份）。因此，建立的会话仅使用加密功能。

内核中的服务器消费者使用：

```c
ret = tls_server_hello_x509(args, gfp_flags);
```

或

```c
ret = tls_server_hello_psk(args, gfp_flags);
```

参数结构的填写与上述相同。

如果消费者需要取消握手请求，例如由于`^C`或其他紧急事件，消费者可以调用：

```c
bool tls_handshake_cancel(sock);
```

如果与`@sock`关联的握手请求已被取消，则此函数返回真。消费者的握手完成回调不会被调用。如果此函数返回假，则表示消费者的完成回调已经调用过。

握手完成
=========

当握手代理完成处理后，它会通知内核该套接字可以再次被消费者使用。此时，消费者提供的握手完成回调（在`tls_handshake_args`结构的`@ta_done`字段中）会被调用。

此函数的定义如下：

```c
typedef void (*tls_done_func_t)(void *data, int status, key_serial_t peerid);
```

消费者在`tls_handshake_args`结构的`@ta_data`字段中提供一个cookie，该cookie会在回调的`@data`参数中返回。消费者使用这个cookie来匹配回调和等待握手完成的线程。

握手的成功状态通过`@status`参数返回：

+------------+----------------------------------------------+
|  状态      |  含义                                        |
+============+==============================================+
|  0         |  成功建立TLS会话                              |
+------------+----------------------------------------------+
|  -EACCESS  |  远程对等方拒绝握手或认证失败                  |
+------------+----------------------------------------------+
|  -ENOMEM   |  临时资源分配失败                              |
+------------+----------------------------------------------+
|  -EINVAL   |  消费者提供了无效的参数                        |
+------------+----------------------------------------------+
|  -ENOKEY   |  缺少认证材料                                 |
+------------+----------------------------------------------+
|  -EIO      |  发生了意外故障                                |
+------------+----------------------------------------------+

`@peerid`参数包含包含远程对等方身份的密钥的序列号，或者如果会话未认证则为`TLS_NO_PEERID`的值。

最佳实践是，如果握手失败，应立即关闭并销毁套接字。
其他考虑事项
--------------------

在握手过程中，内核消费者必须修改套接字的 `sk_data_ready` 回调函数，以忽略所有传入的数据。一旦握手完成回调函数被调用，可以恢复正常的接收操作。
一旦建立了 TLS 会话，消费者必须提供一个缓冲区，并检查随后每次 `sock_recvmsg()` 调用中包含的控制消息（CMSG）。每个控制消息都会指示接收到的消息数据是 TLS 记录数据还是会话元数据。
关于 kTLS 消费者如何识别已升级为使用 TLS ULP 的套接字上的传入（解密后的）应用数据、警报和握手数据包的详细信息，请参阅 tls.rst。
