SPDX 许可证标识符: GPL-2.0

=========================================
如何使用 mac80211 进行数据包注入
=========================================

mac80211 现在允许从用户空间向任何 Monitor 模式接口注入任意数据包。你注入的数据包需要按照以下格式组成：

 [ 无线电报头 ]
 [ IEEE80211 报头 ]
 [ 载荷 ]

无线电报头的格式在 ./Documentation/networking/radiotap-headers.rst 中讨论过。尽管目前定义了许多无线电报头参数，但大多数只适用于接收的数据包。以下信息会从无线电报头中解析出来用于控制注入：

 * IEEE80211_RADIOTAP_FLAGS

   =========================  ===========================================
   IEEE80211_RADIOTAP_F_FCS   FCS 将被移除并重新计算
   IEEE80211_RADIOTAP_F_WEP   如果有密钥，则帧将被加密
   IEEE80211_RADIOTAP_F_FRAG  如果帧长度超过当前分片阈值，则将其分片
   =========================  ===========================================

 * IEEE80211_RADIOTAP_TX_FLAGS

   =============================  ========================================
   IEEE80211_RADIOTAP_F_TX_NOACK  即使是单播帧，也应在不等待 ACK 的情况下发送
   =============================  ========================================

 * IEEE80211_RADIOTAP_RATE

   传输的旧速率（仅适用于没有自身速率控制的设备）

 * IEEE80211_RADIOTAP_MCS

   传输的 HT 速率（仅适用于没有自身速率控制的设备）
还有一些标志被解析

   ============================  ========================
   IEEE80211_RADIOTAP_MCS_SGI    使用短保护间隔
   IEEE80211_RADIOTAP_MCS_BW_40  在 HT40 模式下发送
   ============================  ========================

 * IEEE80211_RADIOTAP_DATA_RETRIES

   当使用 IEEE80211_RADIOTAP_RATE 或 IEEE80211_RADIOTAP_MCS 时的重试次数

 * IEEE80211_RADIOTAP_VHT

   传输中使用的 VHT MCS 和流数量（仅适用于没有自身速率控制的设备）。还解析了其他字段

   标志字段
	IEEE80211_RADIOTAP_VHT_FLAG_SGI: 使用短保护间隔

   带宽字段
	* 1: 使用 40MHz 信道宽度发送
	* 4: 使用 80MHz 信道宽度发送
	* 11: 使用 160MHz 信道宽度发送

注入代码还可以跳过所有其他当前定义的无线电报头字段，从而便于直接回放捕获的无线电报头。
下面是一个定义了一些参数的有效无线电报头示例：

	0x00, 0x00, // <-- 无线电报头版本
	0x0b, 0x00, // <- 无线电报头长度
	0x04, 0x0c, 0x00, 0x00, // <-- 位图
	0x6c, // <-- 速率
	0x0c, //<-- 发送功率
	0x01 //<-- 天线

随后立即跟上 IEEE80211 报头，例如：

	0x08, 0x01, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x13, 0x22, 0x33, 0x44, 0x55, 0x66,
	0x13, 0x22, 0x33, 0x44, 0x55, 0x66,
	0x10, 0x86

最后是载荷部分。
在组成数据包内容后，可以通过向处于 Monitor 模式的逻辑 mac80211 接口发送该数据包来完成发送。也可以使用 libpcap（这比绑定套接字到正确接口更容易），如下所示：

	ppcap = pcap_open_live(szInterfaceName, 800, 1, 20, szErrbuf);
	..
	r = pcap_inject(ppcap, u8aSendBuffer, nLength);

你还可以在这里找到一个完整的注入应用程序链接：

https://wireless.wiki.kernel.org/en/users/Documentation/packetspammer

Andy Green <andy@warmcat.com>
