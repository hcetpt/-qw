SPDX 许可证标识符: GPL-2.0

========================================================
TCP 认证选项的 Linux 实现（RFC5925）
========================================================

TCP 认证选项 (TCP-AO) 提供了一种针对受信任对等方之间验证数据段的 TCP 扩展。它在 TCP 头中添加了一个新的选项，包含一个消息认证码 (MAC)。MAC 是使用双方共享的秘密密钥和散列函数从 TCP 数据段的内容生成的。TCP-AO 的目标是取代 TCP-MD5，并提供更好的安全性、密钥轮换以及支持多种散列算法。

1. 引言
===============

.. 表格:: 对比 TCP-AO 和 TCP-MD5 的简短和有限比较

 +----------------------+------------------------+-----------------------+
 |                      |       TCP-MD5          |         TCP-AO        |
 +======================+========================+=======================+
 |支持的散列           |MD5                     |必须支持 HMAC-SHA1     |
 |算法                  |(加密上较弱)            |（前缀选择攻击）和     |
 |                      |                        |CMAC-AES-128（仅侧信道 |
 |                      |                        |攻击）。可以支持任何   |
 |                      |                        |散列算法。             |
 +----------------------+------------------------+-----------------------+
 |MAC 的长度（字节）|16                      |通常为 12-16。允许其   |
 |                      |                        |他适合 TCP 头的变体。  |
 +----------------------+------------------------+-----------------------+
 |每个 TCP 连接的密钥数|1                       |多个                   |
 |量                    |                        |                       |
 +----------------------+------------------------+-----------------------+
 |更换活动密钥的可能   |不实用（双方都需要在  |协议支持               |
 |性                    |MSL 期间更改它们）      |                       |
 +----------------------+------------------------+-----------------------+
 |保护 ICMP '硬错误'   |否                      |是：默认情况下忽略已   |
 |                      |                        |建立连接上的它们       |
 +----------------------+------------------------+-----------------------+
 |保护跨流量攻击       |否                      |是：伪头包括 TCP 端口  |
 |                      |                        |                       |
 +----------------------+------------------------+-----------------------+
 |保护重放 TCP 数据段  |否                      |序列号扩展 (SNE) 和初  |
 |                      |                        |始序列号 (ISNs)        |
 +----------------------+------------------------+-----------------------+
 |支持无连接复位       |是                      |否。需要 ISNs+SNE 来正  |
 |                      |                        |确签名 RST。           |
 +----------------------+------------------------+-----------------------+
 |标准                  |RFC 2385                |RFC 5925, RFC 5926     |
 +----------------------+------------------------+-----------------------+


1.1 常见问题解答 (FAQ) 参考 RFC 5925
----------------------------------------------------------------

问：对于同一个四元组 (srcaddr, srcport, dstaddr, dstport)，SendID 或 RecvID 是否可以不唯一？

答：不可以 [3.1]::

   >> 主密钥元组 (MKT) 的 ID 在 TCP 连接标识符重叠时不能重叠。
   
问：活跃连接的主密钥元组 (MKT) 能否被删除？

答：不可以，除非它被复制到传输控制块 (TCB) 中 [3.1]::

   假定影响特定连接的 MKT 在活跃连接期间不能被销毁——或者说，它的参数被复制到与连接相关的本地区域（即实例化），因此变化只会影响新连接。
   
问：如果旧的 MKT 需要被删除，应该怎样做以避免影响活跃连接？（因为可能稍后任何时候仍在使用它）

答：RFC 5925 没有规定，似乎这是一个密钥管理的问题，需要确保在尝试删除之前没有一方正在使用该 MKT。
   
问：旧的 MKT 是否可以永远存在并被另一方使用？

答：可以，决定何时移除旧密钥是密钥管理的任务 [6.1]::

   决定何时开始使用密钥是一个性能问题。决定何时移除 MKT 是一个安全问题。无效的 MKT 应当被移除。TCP-AO 不提供协调其移除的机制，因为我们认为这是密钥管理操作的一部分。
   同样 [6.1]::

   避免重复使用先前使用的 MKT 的唯一方法是在不再认为其有效时将其移除。
Linux TCP-AO 将尽力阻止您删除正在使用的密钥，视为密钥管理失败。但考虑到保留过时的密钥可能会成为安全问题，且对等方可能通过始终设置其为 RNextKeyID 无意间阻止了旧密钥的删除，因此提供了一个强制删除机制，用户空间需要提供一个 KeyID 作为替代，内核将原子地删除旧密钥，即使对等方仍在请求它。强制删除无法保证成功，因为对等方可能还没有新的密钥，TCP 连接可能因此中断。另一种选择是关闭套接字。

问：收到新连接的一个数据包但没有已知的 MKT RecvID 时会发生什么？

答：根据 RFC 5925 的规定，默认情况下，会记录警告日志并接受该数据包，但是用户可以通过配置改变这种行为 [7.5.1.a]::

   如果该数据段是 SYN，则这是新连接的第一个数据段。使用该数据段的套接字对及其 TCP-AO KeyID 查找匹配的 MKT，与 MKT 的 TCP 连接标识符和 MKT 的 RecvID 匹配。
如果找不到匹配的MKT，则从该段中移除TCP-AO
继续对该段进行进一步的TCP处理
注：这假定对于不匹配任何MKT的连接应被静默接受，如第7.3节所述
[7.3]::

   >> TCP-AO实现必须允许配置对带有TCP-AO但不匹配任何MKT的段的行为。
   这种配置的初始默认值应当是静默接受此类连接。
如果不希望如此，可以包含一个MKT来匹配这些连接，或者连接可以指示需要TCP-AO；
或者，可以更改配置以丢弃不匹配任何MKT的带有AO选项的段。
[10.2.b]::

   不匹配任何MKT的连接不需要TCP-AO。此外，带有TCP-AO的传入段不会仅仅因为包含该选项而被丢弃，
   前提是它们不匹配任何MKT。
   注意Linux的TCP-AO实现在这方面有所不同。目前，带有未知密钥签名的TCP-AO段会被丢弃，并记录警告日志。
问：RFC是否在任何方面暗示了集中式的内核密钥管理？
（即所有连接上的密钥必须同时轮换？）

答：没有明确规定。MKT可以在用户空间中管理，与密钥更改相关的内容只有[7.3]中提到：
   
   >> 所有的TCP段都必须与MKT集进行比对，以检查是否匹配TCP连接标识符。
问：当对等方请求的RNextKeyID未知时会发生什么？应该重置连接吗？

答：不应该，无需采取任何行动[7.5.2.e]::

   ii. 如果它们不同，则判断RNextKeyID MKT是否已准备好
### 如果与段的套接字对相对应的MKT及RNextKeyID不可用，则无需采取任何行动（收到的段的RNextKeyID需要与MKT的SendID匹配）

**问：**`current_key`是如何设置的，以及何时发生变化？这是用户触发的变化，还是来自远程对等方的请求？是由用户显式设置的，还是通过匹配规则自动设置的？

**答：**`current_key`由`RNextKeyID`设置 [6.1]：

   `Rnext_key`仅通过手动用户干预或MKT管理协议操作来更改。TCP-AO不对其进行操纵。在处理收到的TCP段时，如第7.5节中所述，`Current_key`由TCP-AO更新。请注意，该算法允许`current_key`更改为新的MKT，然后再返回到之前使用的MKT（称为“回退”）。这可能发生在MKT变更过程中，当段乱序接收时发生，并被认为是TCP-AO的一个特性，因为乱序不会导致丢包 [7.5.2.e.ii]：

   2. 如果存在与段的套接字对和RNextKeyID匹配的MKT：

      a. 将`current_key`设置为RNextKeyID对应的MKT

**问：**如果双方都有多个与连接的套接字对匹配的MKT（具有不同的KeyID），发送方/接收方应该如何选择使用哪个KeyID？

**答：**需要某种机制来选择“期望”的MKT [3.3]：

   可能有多个MKT与单个出站段匹配，例如，在MKT变更时。这些MKT不能有冲突的ID（如前所述），并且必须确定对于每个给定的出站段使用哪个MKT
>> 出站TCP段必须最多匹配一个期望的MKT，由段的套接字对指示。段可以匹配多个MKT，前提是恰好有一个MKT被指定为期望的。当多个MKT匹配时，段中的其他信息可用于确定期望的MKT；此类信息不得包括TCP选项字段中的任何值。

**问：**TCP-MD5连接能否迁移到TCP-AO（反之亦然）？

**答：**不可以 [1]：

   建立后的TCP MD5保护连接无法迁移到TCP-AO，因为TCP MD5不支持对连接的安全算法进行任何更改。

**问：**如果所有MKT都被从连接中移除，它是否可以变成非TCP-AO签名的连接？

**答：**[7.5.2]没有像[7.5.1.i]中SYN包处理那样的选择，允许接受无签名的段（这将是不安全的）。虽然直接禁止转换为非TCP-AO连接并未明确规定，但看起来这就是RFC的意思。此外，对于TCP-AO连接来说，始终需要有一个`current_key` [3.3]：

   TCP-AO要求每一个受保护的TCP段正好匹配一个MKT [3.3]：

   >> 入站包含TCP-AO的TCP段必须正好匹配一个MKT，仅由段的套接字对及其TCP-AO KeyID指示 [4.4]：

   一个或多个MKT。这些是与该连接的套接字对匹配的MKT。
### 问题：非TCP-AO连接能否变为支持TCP-AO的连接？

### 回答：
不能：对于已经建立的非TCP-AO连接来说，不可能切换为使用TCP-AO，因为生成流量密钥需要初始序列号。换句话说，如果要开始使用TCP-AO，则需要重新建立TCP连接。

### 内核中的MKTs数据库与用户空间中的数据库
#### Linux对TCP-AO的支持是通过`setsockopt()`实现的，类似于TCP-MD5。这意味着想要使用TCP-AO的用户空间应用程序需要在TCP套接字上执行`setsockopt()`来添加、删除或轮换MKTs。这种方法将密钥管理的责任和处理特殊情况的决策（例如，如果对端不尊重RNextKeyID怎么办）移至用户空间。此外，更多的代码被移到了用户空间，尤其是负责策略决策的部分。另外，这种方法具有灵活性且扩展性良好（相比内核数据库所需锁定更少）。需要注意的是，主要的目标用户是BGP进程，而非任何随机的应用程序，这意味着与IPsec隧道不同，并不需要透明性，现代的BGP守护进程已经支持用于TCP-MD5的`setsockopt()`。

#### 考虑到的方法的优点和缺点

|                      | `setsockopt()` 方法 | 内核中的数据库 |
|----------------------|---------------------|----------------|
| 可扩展性             | `setsockopt()`命令应该是可扩展的系统调用 | Netlink消息简单且易于扩展 |
| 所需的用户空间更改   | 需要使用TCP-AO的BGP或其他应用程序必须执行`setsockopt()`并进行密钥管理 | 可以像隧道那样透明提供，如`ip tcpao add key`（删除/显示/轮换） |
| MKTs的添加或删除     | 对用户空间来说较难 | 对内核来说较难 |
| 导出能力             | 使用`getsockopt()` | 使用Netlink的`.dump()`回调 |
| 内核资源/内存限制    | 相等                |               |
| 扩展性               | 在`TCP_LISTEN`套接字上的竞争 | 整个数据库的竞争 |
| 监控与警告           | 使用`TCP_DIAG` | 使用相同的Netlink套接字 |
| MKTs匹配             | 半问题：仅监听套接字 | 困难 |

### 用户空间API (uAPI)

#### Linux提供了一系列`setsockopt()`和`getsockopt()`命令，使用户空间能够基于每个套接字管理TCP-AO。为了添加/删除MKTs，必须使用`TCP_AO_ADD_KEY`和`TCP_AO_DEL_KEY`TCP套接字选项。
不允许在一个已建立但不支持TCP-AO的连接上添加密钥，也不允许从TCP-AO连接中删除最后一个密钥。
`setsockopt(TCP_AO_DEL_KEY)`命令可以指定`tcp_ao_del::current_key` + `tcp_ao_del::set_current` 和/或 `tcp_ao_del::rnext` + `tcp_ao_del::set_rnext`，这使得删除操作成为“强制”的：它为用户空间提供了一种方法来删除正在使用的密钥，并原子地设置另一个密钥。这不是正常使用的预期行为，只应在对端忽略RNextKeyID并继续请求/使用旧密钥时使用。这提供了一种方法来强制删除不受信任的密钥，但这可能会中断TCP-AO连接。
通常的密钥轮换可以通过`setsockopt(TCP_AO_INFO)`来完成。此外，它还提供了一个用户空间API来改变每个套接字的TCP-AO设置，例如忽略ICMP，以及清除每个套接字的TCP-AO数据包计数器。
对应的`getsockopt(TCP_AO_INFO)`可用于获取这些每个套接字的TCP-AO设置。
另一个有用的命令是`getsockopt(TCP_AO_GET_KEYS)`。可以使用它来列出TCP套接字上的所有MKTs，或者使用过滤器来获取特定对端和/或sndid/rcvid、VRF L3接口或当前密钥/下一个密钥。
为了修复TCP-AO连接，可以使用`setsockopt(TCP_AO_REPAIR)`，前提是用户之前已经使用`getsockopt(TCP_AO_REPAIR)`检查点/导出了套接字。
这里有一个关于扩展的 `TCP_LISTEN` 套接字的提示，这些套接字可能包含数千个 TCP-AO 密钥：在使用 `getsockopt(TCP_AO_GET_KEYS)` 时使用过滤器，并通过 `setsockopt(TCP_AO_DEL_KEY)` 进行异步删除。
Linux 的 TCP-AO 提供了一系列的分段计数器，这些计数器对于故障排除和调试问题非常有用。每个 MKT 都有一组良好的/不良的计数器来反映通过/未通过验证的数据包数量。
每个 TCP-AO 套接字具有以下计数器：
- 对于良好分段（正确签名的）
- 对于不良分段（未能通过 TCP-AO 验证的）
- 对于未知密钥的分段
- 对于期望有 AO 签名但未找到的分段
- 被忽略的 ICMP 数量

每个套接字上的 TCP-AO 计数器也以网络命名空间为单位进行了复制，并通过 SNMP 暴露出来。这些是 `TCPAOGood`、`TCPAOBad`、`TCPAOKeyNotFound`、`TCPAORequired` 和 `TCPAODroppedIcmps`。
为了监控的目的，有以下 TCP-AO 跟踪事件：
`tcp_hash_bad_header`、`tcp_hash_ao_required`、`tcp_ao_handshake_failure`、`tcp_ao_wrong_maclen`、`tcp_ao_key_not_found`、`tcp_ao_rnext_request`、`tcp_ao_synack_no_key`、`tcp_ao_snd_sne_update`、`tcp_ao_rcv_sne_update`。可以单独启用其中任何一个，并且可以根据网络命名空间、四元组、族、L3 索引和 TCP 头标志进行过滤。如果一个分段有 TCP-AO 头部，则过滤器还可以包括 keyid、rnext 和 maclen。SNE 更新包括 RFC 5925 中规定的滚动数字。
RFC 5925 非常宽容地规定了如何为 MKT 进行 TCP 端口匹配：

   TCP 连接标识符。即本地 IP 地址、远程 IP 地址、TCP 本地端口和 TCP 远程端口的一对 TCP 套接字
值可以部分指定为范围（例如，2-30）、掩码（例如，0xF0）、通配符（例如，“*”）或任何其他合适的指示
目前 Linux 的 TCP-AO 实现没有提供任何 TCP 端口匹配功能。
也许端口范围对于 uAPI 来说是最灵活的，但至今尚未实现。

### `setsockopt()` 与 `accept()` 的竞争

与只有一个密钥的 TCP-MD5 已建立连接不同的是，TCP-AO 连接可能有许多密钥，这意味着监听套接字上接受的连接也可能拥有任意数量的密钥。由于在第一个正确签名的 SYN 上复制所有这些密钥会使请求套接字变得过大，这是不理想的。目前的实现没有将密钥复制到请求套接字，而是从“父级”监听套接字中查找它们。
结果是当用户空间移除 TCP-AO 密钥时，这可能会破坏尚未完全建立的请求套接字上的连接，同时也无法从已经建立但尚未被 `accept()` 接受、挂起在接受队列中的套接字中移除密钥。
其反向情况同样有效：如果用户空间在一个监听套接字上为对等方添加了新密钥，则已建立的接受队列中的套接字将不会拥有这些新密钥。
在此时，两种竞态条件的解决方案：
``setsockopt(TCP_AO_ADD_KEY)`` 与 ``accept()``
以及 ``setsockopt(TCP_AO_DEL_KEY)`` 与 ``accept()`` 被委托给了用户空间
这意味着预期用户空间会检查由 ``accept()`` 返回的套接字上的 MKTs（密钥标签），以验证在监听套接字上发生的任何密钥轮换是否反映在新建立的连接上。
这与内核层面的TCP-MD5所采取的类似“什么都不做”的方法相似，并且可以通过引入新的标志到 ``tcp_ao_add`` 和 ``tcp_ao_del`` 在将来进行改变。
需要注意的是，这种竞态情况是罕见的，因为它需要TCP-AO密钥轮换发生在新TCP连接的三次握手过程中。
5. 与TCP-MD5的交互
===========================

TCP连接不能在TCP-AO和TCP-MD5选项之间迁移。已建立的并且具有AO或MD5密钥的套接字被限制于添加另一种选项的密钥。
对于监听套接字而言，情况不同：BGP服务器可能希望接收使用TCP-AO和（已废弃）TCP-MD5的客户端。因此，这两种类型的密钥都可以被添加到TCP_CLOSED或TCP_LISTEN状态的套接字中。不允许为同一个对等方添加不同类型的密钥。
6. SNE在Linux中的实现
===========================

RFC 5925 [6.2] 描述了如何使用SNE扩展TCP序列号的算法。简而言之：TCP必须跟踪之前的序列号并在当前SEQ号翻转时设置sne_flag。当当前和之前的SEQ号都超过0x7fff（即32Kb）时，该标志会被清除。
在sne_flag设置的时间段内，算法将每个数据包的SEQ与0x7fff比较，如果它高于32Kb，则假设该数据包应该在递增之前通过SNE进行验证。因此，在这个[0；32Kb]窗口期间，可以接受带有(SNE - 1)的数据包。
Linux的实现对此进行了简化：由于网络堆栈已经跟踪了想要确认的第一个SEQ字节（snd_una）和下一个想要的SEQ字节（rcv_nxt）——这些信息足以进行粗略估计，了解发送者和接收者在4GB序列号空间中的位置。
当序列号回绕至零时，相应的SNE会被递增。
对于每个TCP-AO数据段，都会调用`tcp_ao_compute_sne()`。它会将数据段中的SEQ编号与`snd_una`或`rcv_nxt`进行比较，并将结果适配到它们周围的2GB窗口内，同时检测SEQ编号的回绕。这极大地简化了代码，并且只需要在每个TCP-AO套接字上存储SNE编号。
乍一看，2GB的窗口似乎比RFC 5926更为宽容。但这仅仅用于在回绕前后选择正确的SNE。它允许更多的TCP数据段重播，但所有常规的TCP检查（通过`tcp_sequence()`执行）仍然应用于已验证的数据段。
因此，它以略微更宽容的态度接受重播/重传的数据段为代价，换取了算法的简单性以及对大TCP窗口而言看似更好的行为。

7. 相关链接

* [RFC 5925] TCP认证选项
  * [https://www.rfc-editor.org/rfc/pdfrfc/rfc5925.txt.pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc5925.txt.pdf)

* [RFC 5926] TCP认证选项(TCP-AO)的加密算法
  * [https://www.rfc-editor.org/rfc/pdfrfc/rfc5926.txt.pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc5926.txt.pdf)

* 草案 "TCP认证选项(TCP-AO)的SHA-2算法"
  * [https://datatracker.ietf.org/doc/html/draft-nayak-tcp-sha2-03](https://datatracker.ietf.org/doc/html/draft-nayak-tcp-sha2-03)

* [RFC 2385] 通过TCP MD5签名选项保护BGP会话
  * [https://www.rfc-editor.org/rfc/pdfrfc/rfc2385.txt.pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc2385.txt.pdf)

**作者：**Dmitry Safonov <dima@arista.com>
