SPDX许可证标识符: GPL-2.0

========================================================
TCP 认证选项的 Linux 实现（RFC5925）
========================================================

TCP 认证选项（TCP-AO）提供了一种用于验证可信对等体之间段落的 TCP 扩展。它添加了一个带有消息认证码（MAC）的新 TCP 头选项。MAC 是通过使用双方都知道的密码和散列函数从 TCP 段的内容中生成的。TCP-AO 的目的是取代 TCP-MD5，提供更好的安全性、密钥轮换以及支持多种散列算法。

1. 引言
===============

.. table:: TCP-AO 和 TCP-MD5 的简短比较

 +----------------------+------------------------+-----------------------+
 |                      |       TCP-MD5          |         TCP-AO        |
 +======================+========================+=======================+
 | 支持的散列           | MD5                    | 必须支持 HMAC-SHA1     |
 | 算法                 | (加密较弱)             |（前缀攻击）和 CMAC-AES-128 |
 |                      |                        |（仅侧信道攻击）。可支 |
 |                      |                        |持任何散列算法。       |
 +----------------------+------------------------+-----------------------+
 | MAC 长度（字节）     | 16                     | 通常为 12-16 字节。其 |
 |                      |                        |他符合 TCP 头的变体也 |
 |                      |                        |被允许。               |
 +----------------------+------------------------+-----------------------+
 | 每个 TCP 连接的密钥数| 1                      | 多个                  |
 | 量                   |                        |                       |
 +----------------------+------------------------+-----------------------+
 | 更改活动密钥的可能  | 不实用（双方需要在 MSL| 协议支持              |
 | 性                  | 期间更改密钥）         |                       |
 +----------------------+------------------------+-----------------------+
 | 对 ICMP ‘硬错误’的  | 否                     | 是：默认忽略已建立连 |
 | 保护                |                        | 接上的这些错误         |
 +----------------------+------------------------+-----------------------+
 | 对流量交叉攻击的保  | 否                     | 是：伪头包括 TCP 端口 |
 | 护                  |                        |                       |
 +----------------------+------------------------+-----------------------+
 | 对重放 TCP 段的保   | 否                     | 序列号扩展（SNE）和初 |
 | 护                  |                        | 始序列号（ISNs）       |
 +----------------------+------------------------+-----------------------+
 | 支持无连接重置       | 是                     | 否。需要 ISNs+SNE 来正 |
 |                      |                        | 确签名 RST。           |
 +----------------------+------------------------+-----------------------+
 | 标准                 | RFC 2385               | RFC 5925, RFC 5926     |
 +----------------------+------------------------+-----------------------+

1.1 常见问题解答（FAQ）及引用 RFC 5925
------------------------------------------------

Q: 发送 ID 或接收 ID 是否可以对于同一个四元组（srcaddr, srcport, dstaddr, dstport）不唯一？

A: 不可以 [3.1]::

   >> 主密钥元组（MKT）的 ID 在其 TCP 连接标识符重叠的情况下不能重叠

Q: 可以移除一个活动连接的主密钥元组（MKT）吗？

A: 不可以，除非将其复制到传输控制块（TCB）[3.1]::

   假设影响特定连接的 MKT 在活动连接期间不能被销毁——或者说，其参数被复制到连接本地区域（即实例化），因此更改仅影响新连接

Q: 如果旧的 MKT 需要删除，如何操作以确保不会影响活动连接？（因为它随时都可能仍在使用）

A: RFC 5925 未指定，这似乎是一个密钥管理问题，需要确保在尝试移除之前无人使用此 MKT

Q: 旧的 MKT 是否可以永远存在并被其他对等体使用？

A: 它可以，决定何时移除旧密钥是密钥管理的任务 [6.1]::

   决定何时开始使用密钥是一个性能问题。决定何时移除 MKT 是一个安全问题。无效的 MKT 预计会被移除。TCP-AO 没有提供协调移除的机制，我们认为这是密钥管理操作
同样 [6.1]::

   避免重用先前使用的 MKT 的唯一方法是在不再认为允许使用时移除 MKT
Linux TCP-AO 将尽力阻止您移除正在使用的密钥，视为密钥管理失败。但由于保留过时密钥可能会成为安全问题，并且对等体可能会始终将其设置为 RNextKeyID 从而无意中阻止旧密钥的移除——因此提供了强制密钥移除机制，其中用户空间必须提供一个替代密钥 ID 而不是要移除的那个，内核将原子地删除旧密钥，即使对等体仍在请求它。无法保证强制删除的效果，因为对等体可能尚未获取新密钥，TCP 连接可能会中断。
另一种选择是关闭套接字

Q: 当收到没有已知 MKT 接收 ID 的新连接的数据包时会发生什么？

A: RFC 5925 规定，默认情况下会接受该数据包并记录警告日志，但用户可以通过配置来改变这种行为 [7.5.1.a]::

   如果该段落是 SYN，则这是新连接的第一个段落。使用该段落的套接字对和其 TCP-AO KeyID 查找与该段落匹配的 MKT，与 MKT 的 TCP 连接标识符和 MKT 的 RecvID 匹配
i. 如果没有匹配的MKT，从段中移除TCP-AO
继续进行段的进一步TCP处理
注：这假定不匹配任何MKT的连接应该被静默接受，如第7.3节所述

[7.3]::

   >> TCP-AO实现必须允许配置对于带有TCP-AO但不匹配任何MKT的段的行为。此配置的初始默认值应为静默接受此类连接。
如果这不是所希望的情况，可以包含一个MKT来匹配此类连接，或者连接可以指示需要TCP-AO
另外，可以更改配置以丢弃不匹配MKT的AO选项段。

[10.2.b]::

   不匹配任何MKT的连接不需要TCP-AO。此外，接收到的带有TCP-AO的段不会仅仅因为包含该选项而被丢弃，前提是它们不匹配任何MKT。
请注意，Linux的TCP-AO实现在这方面有所不同。目前，TCP-AO段中的未知密钥签名会被记录警告并丢弃。
问：RFC是否在任何方面暗示了集中式的内核密钥管理？
（即所有连接上的密钥必须同时轮换？）

答：未指定。MKT可以在用户空间中管理，与密钥更改相关的唯一部分是[7.3]::

   >> 所有TCP段都必须与MKT集合进行匹配检查，以匹配TCP连接标识符。
问：当对等方请求的RNextKeyID未知时会发生什么？连接应该重置吗？

答：不应该，无需采取任何行动 [7.5.2.e]::

   ii. 如果它们不同，则确定RNextKeyID MKT是否已准备好。
### 翻译

#### 1. 如果与该段的套接字对和 RNextKeyID 对应的 MKT 不可用，则无需采取任何行动（收到的段的 RNextKeyID 需要与 MKT 的 SendID 匹配）

**问：current_key 是如何设置的？它何时会改变？这是用户触发的更改，还是来自远程对端的请求？它是用户显式设置的，还是通过匹配规则设置的？**

答：current_key 由 RNextKeyID 设置 [6.1]：

   Rnext_key 只能通过手动用户干预或 MKT 管理协议操作来更改。TCP-AO 不对其进行操纵。当处理接收到的 TCP 段时，TCP-AO 会更新 current_key，如第 7.5 节中的段处理描述中所述。需要注意的是，算法允许 current_key 更改为新的 MKT，然后恢复到先前使用的 MKT（称为“回退”）。这在 MKT 更换期间可能会发生，尤其是在段乱序接收时，这被认为是 TCP-AO 的一个特性，因为乱序不会导致丢包 [7.5.2.e.ii]：

   2. 如果与该段的套接字对和 RNextKeyID 对应的匹配 MKT 可用：

      a. 将 current_key 设置为 RNextKeyID MKT

**问：如果两个对端都有多个与连接的套接字对匹配的 MKT（具有不同的 KeyID），发送方/接收方应该如何选择使用哪个 KeyID？**

答：需要某种机制来选择“期望”的 MKT [3.3]：

   单个出站段可能与多个 MKT 匹配，例如，在 MKT 更换过程中。这些 MKT 不能有冲突的 ID（如前所述），并且必须确定每个给定出站段使用的 MKT

   >> 出站 TCP 段最多只能匹配一个期望的 MKT，这由段的套接字对指示。段可以匹配多个 MKT，前提是恰好有一个 MKT 被标记为期望的。其他信息可用于在多个 MKT 匹配时确定期望的 MKT；此类信息不得包含任何 TCP 选项字段中的值

**问：TCP-MD5 连接能否迁移到 TCP-AO（反之亦然）？**

答：不可以 [1]：

   由于 TCP MD5 不支持连接建立后对其安全算法进行任何更改，因此无法将 TCP MD5 保护的连接迁移到 TCP-AO

**问：如果所有 MKT 都从连接中移除，它是否可以变成非 TCP-AO 签名连接？**

答：[7.5.2] 没有像 [7.5.1.i] 中处理 SYN 数据包时那样的选择，允许接受没有签名的数据段（这将是不安全的）。虽然直接禁止切换到非 TCP-AO 连接，但 RFC 好像暗示了这一点。此外，TCP-AO 连接始终需要一个 current_key [3.3]：

   TCP-AO 要求每个受保护的 TCP 段仅匹配一个 MKT [3.3]：

   >> 具有 TCP-AO 的入站 TCP 段必须仅匹配一个 MKT，仅由段的套接字对及其 TCP-AO KeyID 指示 [4.4]：

   一个或多个 MKT。这些是与此连接的套接字对匹配的 MKT
### 问：非TCP-AO连接能否变为支持TCP-AO的连接？

答：不能。对于已经建立的非TCP-AO连接，不可能切换为使用TCP-AO，因为流量密钥生成需要初始序列号。换句话说，开始使用TCP-AO需要重新建立TCP连接。

### 内核中的MKTs数据库与用户空间中的数据库
==================================

Linux对TCP-AO的支持是通过`setsockopt()`实现的，类似于TCP-MD5。这意味着想要使用TCP-AO的用户空间应用程序需要在TCP套接字上执行`setsockopt()`来添加、删除或轮换MKTs。这种方法将密钥管理责任以及处理特殊情况（例如对方不遵守RNextKeyID时应如何处理）的决策转移到了用户空间。此外，更多的代码转移到用户空间，特别是负责策略决策的部分。除此之外，这种方法非常灵活且可扩展性好（与内核数据库相比，需要更少的锁）。需要注意的是，主要预期用户是BGP进程，而不是任何随机的应用程序，这意味着与IPsec隧道相比，不需要透明性，并且现代的BGP守护进程已经有用于TCP-MD5支持的`setsockopt()`。

#### 方法的优缺点对比表

|               | `setsockopt()`  | 内核数据库  |
|---------------|-----------------|-------------|
| 可扩展性      | `setsockopt()`命令应可扩展 | Netlink消息简单且可扩展 |
| 所需用户空间更改 | BGP或其他希望使用TCP-AO的应用需要执行`setsockopt()`并管理密钥 | 可以像隧道一样透明，提供类似`ip tcpao add key`（删除/显示/轮换）的命令 |
| 添加/删除MKTs | 对用户空间来说较难 | 对内核来说较难 |
| 导出能力      | 使用`getsockopt()` | 使用Netlink `.dump()`回调 |
| 内核资源/内存限制 | 相等 |
| 可扩展性      | 在`TCP_LISTEN`套接字上的争用 | 在整个数据库上的争用 |
| 监控和警告    | 使用`TCP_DIAG` | 使用相同的Netlink套接字 |
| 匹配MKTs      | 半问题：仅监听套接字 | 较难 |

### 用户API
================

Linux提供了一组`setsockopt()`和`getsockopt()`系统调用，使用户空间能够按每个套接字管理TCP-AO。为了添加/删除MKTs，必须使用`TCP_AO_ADD_KEY`和`TCP_AO_DEL_KEY` TCP套接字选项。
不允许在已建立的非TCP-AO连接上添加密钥，也不允许从TCP-AO连接中删除最后一个密钥。
`setsockopt(TCP_AO_DEL_KEY)`命令可以指定`tcp_ao_del::current_key`、`tcp_ao_del::set_current`和/或`tcp_ao_del::rnext`、`tcp_ao_del::set_rnext`，这使得这种删除成为“强制”的：它为用户空间提供了一种删除正在使用的密钥并原子地设置另一个密钥的方法。这不是用于正常情况下的，而是在对方忽略RNextKeyID并继续请求/使用旧密钥时才应使用。
这提供了一种强制删除不受信任的密钥的方法，但可能会中断TCP-AO连接。
通常情况下，正常的密钥轮换可以通过`setsockopt(TCP_AO_INFO)`来完成。
它还提供了一个用户API来改变每个套接字的TCP-AO设置，如忽略ICMP，以及清除每个套接字的TCP-AO数据包计数器。
相应的`getsockopt(TCP_AO_INFO)`可用于获取这些每个套接字的TCP-AO设置。
另一个有用的命令是`getsockopt(TCP_AO_GET_KEYS)`。可以使用它列出TCP套接字上的所有MKTs或使用过滤器获取特定对端和/或sndid/rcvid、VRF L3接口或当前密钥/下一个密钥。
为了修复TCP-AO连接，提供了`setsockopt(TCP_AO_REPAIR)`，前提是用户之前已经使用`getsockopt(TCP_AO_REPAIR)`检查点/导出了该套接字。
关于带有大量TCP-AO密钥的TCP_LISTEN套接字的一条提示是：在`getsockopt(TCP_AO_GET_KEYS)`中使用过滤器，并使用`setsockopt(TCP_AO_DEL_KEY)`进行异步删除。

Linux 的 TCP-AO 还提供了一组段计数器，这些计数器对于故障排除和调试问题非常有帮助。每个MKT都有好/坏计数器，反映了通过/未通过验证的数据包数量。

每个TCP-AO套接字具有以下计数器：
- 正确签名的段（良好段）
- 未通过TCP-AO验证的段（坏段）
- 包含未知密钥的段
- 预期有AO签名但未找到的段
- 被忽略的ICMP数据包数量

每个套接字的TCP-AO计数器也与每个网络命名空间（netns）的计数器重复，并通过SNMP暴露出来。这些计数器分别是`TCPAOGood`、`TCPAOBad`、`TCPAOKeyNotFound`、`TCPAORequired` 和 `TCPAODroppedIcmps`。

为了监控目的，有以下TCP-AO跟踪事件：
``tcp_hash_bad_header``、``tcp_hash_ao_required``、``tcp_ao_handshake_failure``、``tcp_ao_wrong_maclen``、``tcp_ao_key_not_found``、``tcp_ao_rnext_request``、``tcp_ao_synack_no_key``、``tcp_ao_snd_sne_update``、``tcp_ao_rcv_sne_update``。可以单独启用任何一个事件，并且可以根据网络命名空间、四元组、家族、L3索引和TCP头部标志进行过滤。如果一个段包含TCP-AO头部，则过滤器还可以包括keyid、rnext和maclen。SNE更新包括RFC 5925中规定的滚动数字。

RFC 5925 对TCP端口匹配的定义非常宽松：

   TCP连接标识符。一个TCP套接字对，即本地IP地址、远程IP地址、TCP本地端口和TCP远程端口。
值可以部分指定范围（例如2-30）、掩码（例如0xF0）、通配符（例如*）或其他任何合适的表示方法。
目前Linux的TCP-AO实现不提供任何TCP端口匹配功能。
可能端口范围对于uAPI来说是最灵活的，但尚未实现。

4. `setsockopt()` 与 `accept()` 的竞争
=======================================

与只有一个密钥的TCP-MD5已建立连接不同，TCP-AO连接可能有很多密钥，这意味着监听套接字上接受的连接也可能具有任意数量的密钥。由于在第一个正确签名的SYN报文上复制所有这些密钥会使请求套接字变大，这是不可取的。目前的实现没有将密钥复制到请求套接字上，而是从“父”监听套接字上查找它们。

结果是，当用户空间删除TCP-AO密钥时，这可能会破坏请求套接字上的未建立连接，同时也不会从已经建立但尚未通过`accept()`处理并挂起在accept队列中的套接字中移除密钥。
相反的情况同样有效：如果用户空间在一个监听套接字上为对等方添加了一个新密钥，那么在接收队列中的已建立套接字将不会拥有这个新密钥。

目前，对于以下两种竞争情况的解决方案：
``setsockopt(TCP_AO_ADD_KEY)`` 与 ``accept()``
以及 ``setsockopt(TCP_AO_DEL_KEY)`` 与 ``accept()`` 被委托给用户空间处理。
这意味着期望用户空间会检查通过 ``accept()`` 返回的套接字上的 MKTs（密钥验证标签），以确保监听套接字上的任何密钥轮换反映在新建立的连接上。
这与内核层面的 TCP-MD5 的“不作为”方法类似，并且可能通过引入新的标志到 ``tcp_ao_add`` 和 ``tcp_ao_del`` 来在未来进行更改。
需要注意的是，这种竞争条件很少发生，因为它需要 TCP-AO 密钥轮换发生在新 TCP 连接的三次握手期间。

### 5. 与 TCP-MD5 的交互

TCP 连接不能在 TCP-AO 和 TCP-MD5 选项之间迁移。已经建立了 AO 或 MD5 密钥的套接字被限制为不能添加另一种选项的密钥。
对于监听套接字来说，情况有所不同：BGP 服务器可能希望接收同时支持 TCP-AO 和（已废弃）TCP-MD5 的客户端。因此，可以在这两种类型的套接字（TCP_CLOSED 或 TCP_LISTEN）上添加这两种类型的密钥。但是不允许为同一个对等方添加不同类型的密钥。

### 6. SNE 在 Linux 中的实现

RFC 5925 [6.2] 描述了如何使用 SNE 扩展 TCP 序列号的算法。简而言之：TCP 必须跟踪之前的序列号并在当前 SEQ 号码回绕时设置 sne_flag。当当前和之前的 SEQ 号码都超过 0x7fff（即 32Kb）时，该标志会被清除。
在 sne_flag 设置的时间段内，算法会比较每个数据包的 SEQ 与 0x7fff，并如果它大于 32Kb，则假设该数据包应在递增前通过 SNE 进行验证。因此，在 [0；32Kb] 的窗口中，可以接受带有 (SNE - 1) 的数据包。
Linux 实现对此进行了简化：由于网络堆栈已经跟踪了想要 ACK 的第一个 SEQ 字节（snd_una）和下一个想要的 SEQ 字节（rcv_nxt），这些信息足以进行粗略估计，从而判断发送者和接收者在 4GB 序列号空间中的位置。
当序列号回绕至零时，相应的SNE会递增。
对于每个TCP-AO段，都会调用`tcp_ao_compute_sne()`。它将段中的SEQ编号与`snd_una`或`rcv_nxt`进行比较，并将结果放入它们周围的2GB窗口中，检测SEQ编号的回绕。这大大简化了代码，并且只需要在每个TCP-AO套接字上存储SNE编号。
乍一看，2GB窗口似乎比RFC 5926更宽松。但实际上，这只是用于在回绕前后选择正确的SNE。虽然允许更多的TCP段重播，但所有常规的TCP检查（通过`tcp_sequence()`验证）仍然应用于已验证的段。
因此，这种做法以稍微更宽松的方式接受重播/重传的段，从而简化了算法，并且在大TCP窗口的情况下表现更好。

### 7. 链接

- **RFC 5925 TCP认证选项**
  - [https://www.rfc-editor.org/rfc/pdfrfc/rfc5925.txt.pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc5925.txt.pdf)

- **RFC 5926 TCP认证选项（TCP-AO）的加密算法**
  - [https://www.rfc-editor.org/rfc/pdfrfc/rfc5926.txt.pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc5926.txt.pdf)

- **草案 "TCP认证选项（TCP-AO）的SHA-2算法"**
  - [https://datatracker.ietf.org/doc/html/draft-nayak-tcp-sha2-03](https://datatracker.ietf.org/doc/html/draft-nayak-tcp-sha2-03)

- **RFC 2385 通过TCP MD5签名选项保护BGP会话**
  - [https://www.rfc-editor.org/rfc/pdfrfc/rfc2385.txt.pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc2385.txt.pdf)

**作者：Dmitry Safonov <dima@arista.com>**
