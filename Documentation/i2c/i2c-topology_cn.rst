I2C多路复用器与复杂拓扑结构
================================

构建比简单的I2C总线（一个适配器和一个或多个设备）更复杂的I2C拓扑的原因有几个，例如：

1. 总线上可能需要一个多路复用器来避免地址冲突
2. 该总线可能对某些外部总线主机可访问，并且需要仲裁来确定是否可以访问总线
3. 某些设备（特别是RF调谐器）希望避免来自I2C总线的数字噪声，至少大部分时间是这样，并且位于一个必须在访问设备前操作的门控之后
处理这些需求可以使用多种硬件组件，如I2C多路复用器、I2C门控以及I2C仲裁器。
Linux将这些组件表示为I2C适配器树，其中每个适配器都有一个父适配器（根适配器除外），并且有零个或多个子适配器。根适配器是实际执行I2C传输的适配器，而所有具有父级的适配器都是“i2c-mux”对象的一部分（之所以加引号是因为它也可以是仲裁器或门控）。
根据具体的多路复用器驱动程序，在其子适配器上的I2C传输时会发生一些事情。多路复用器驱动程序可以显然地操作多路复用器，但也可以与外部总线主机进行仲裁或打开门控。多路复用器驱动程序为此有两个操作：选择(select)和取消选择(deselect)。选择在传输之前被调用，而取消选择(如果存在)则在传输之后被调用。

锁定
=====

对于I2C多路复用器有两种可用的锁定方式，它们可以是多路复用器锁定(mux-locked)或父级锁定(parent-locked)的多路复用器。

多路复用器锁定的多路复用器
------------------------------

多路复用器锁定的多路复用器在完整的“选择-传输-取消选择”交易过程中不会锁定整个父适配器，仅会锁定父适配器上的多路复用器。多路复用器锁定的多路复用器主要适用于当选择和/或取消选择操作必须使用I2C传输来完成任务的情况。由于在完整交易期间父适配器没有完全锁定，因此无关的I2C传输可能会穿插在交易的不同阶段之间。这使得多路复用器驱动程序可能更容易实现，但也有一些需要注意的问题。

多路复用器锁定示例
~~~~~~~~~~~~~~~~~~

::

                   .----------.     .--------
当有对D1的访问时，会发生以下情况：

1. 某人向D1发起I2C传输。
2. M1锁定其父级（在这种情况下是根适配器）上的muxes。
3. M1调用`->select`来准备mux。
4. M1（大概率地）作为其`->select`的一部分执行一些I2C传输。
这些传输是正常的I2C传输，并锁定父级适配器。
5. M1将步骤1中的I2C传输作为正常的I2C传输传递给其父级适配器，锁定父级适配器。
6. 如果有的话，M1调用`->deselect`。
7. 步骤4中同样的规则适用于`->deselect`。
8. M1解锁其父级上的muxes。
这意味着在整个操作期间，对D2的访问被锁定。但对D3的访问可能在任何时候穿插进行。
Mux-锁定注意事项
~~~~~~~~~~~~~~~~~~

当使用mux-锁定的多路复用器时，请注意以下限制：

[ML1]
  如果你构建了一个拓扑结构，其中mux-锁定的多路复用器是parent-锁定多路复用器的父级，
  这可能会破坏parent-锁定多路复用器对于根适配器在事务过程中锁定的期望。

[ML2]
  当存在地址冲突的情况下，在非兄弟关系的两个（或更多）mux-锁定多路复用器之间构建任意拓扑结构是不安全的，这些地址冲突发生在这些非兄弟mux的子适配器上的设备之间。
  比如，选择-传输-取消选择事务针对mux-one后面的设备地址0x42的操作可能与mux-two后面的相同设备地址0x42的操作穿插进行。在这种假设的例子中，mux-one和mux-two不应同时被选中，
  但是mux-锁定多路复用器并不能在所有拓扑结构中保证这一点。

[ML3]
  mux-锁定多路复用器不能用于驱动程序中的自动关闭门/多路复用器，即那些在一定数量（通常为一次）I2C传输后自动关闭的东西。无关的I2C传输可能会介入并过早地关闭。

[ML4]
  如果mux驱动程序中的任何非I2C操作改变了I2C多路复用器的状态，则驱动程序必须在此操作期间锁定根适配器。
  否则，当无关的I2C传输正在进行时，多路复用器改变状态的非I2C操作可能导致总线上出现垃圾数据，从mux后面的设备来看。

Parent-锁定多路复用器
-------------------

Parent-锁定多路复用器在完整的选取-传输-取消选择事务期间锁定父适配器。这意味着mux驱动程序必须确保在事务期间通过该父适配器的所有I2C传输都是未锁定的I2C传输（例如使用 __i2c_transfer），否则会导致死锁。
Parent-锁定示例
~~~~~~~~~~~~~~~~~~~~~

::

                   .----------.     .--------
当有对D1的访问时，会发生以下情况：

1. 某人向D1发起I2C传输。
2. M1锁定其父级（在这种情况下是根适配器）上的muxes。
3. M1锁定其父级适配器。
4. M1调用`->select`来准备mux。
5. 如果M1作为其`->select`的一部分执行任何I2C传输（在这个根适配器上），这些传输必须是非锁定I2C传输，以避免死锁根适配器。
6. M1将第1步中的I2C传输作为非锁定I2C传输传递给根适配器，以避免死锁父级适配器。
7. 如果有的话，M1调用`->deselect`。
8. 步骤5的相同规则适用于`->deselect`。
9. M1解锁其父级适配器。
10. M1 解锁其父设备上的多路复用器
这意味着在整个操作期间，对 D2 和 D3 的访问都被锁定。

### 父设备锁定的注意事项
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

使用父设备锁定的多路复用器时，请注意以下限制：

**[PL1]**
  如果构建的拓扑结构中一个父设备锁定的多路复用器作为另一个多路复用器的子设备，这可能会打破子多路复用器的一个可能假设，即在其选择操作和实际传输之间根适配器未被使用（例如，如果子多路复用器是自动关闭的，并且父多路复用器在其选择过程中执行 I2C 传输）。
这种情况尤其在父多路复用器为多路复用器锁定的情况下可能发生，但如果父多路复用器为父设备锁定的情况也可能发生。

**[PL2]**
  如果选择/取消选择调用涉及到其他子系统如 GPIO、Pin 控制、寄存器映射或工业 I/O（IIO），那么由这些子系统导致的任何 I2C 传输必须解锁。实现这一点可能很复杂，甚至在寻求可接受的干净解决方案时可能不可能。

### 复杂示例

#### 父设备锁定的多路复用器作为父设备锁定的多路复用器的父设备
------------------------------------------------------------------------

这是一个有用的拓扑结构，但它可能是坏的:: 

```
                   .----------.     .----------.     .--------
.--------.     |  parent- |-----|  parent- |-----| dev D1 |
    |  root  |--+--|  locked  |     |  locked  |     '--------'
    '--------'  |  |  mux M1  |--.  |  mux M2  |--.  .--------
|  '----------'  |  '----------'  '--| dev D2 |
                |  .--------.    |  .--------.       '--------'
                '--| dev D4 |    '--| dev D3 |
                   '--------'       '--------'
```

当访问任何设备时，所有其他设备在整个操作期间都被锁定（两个多路复用器都锁定它们的父设备，特别是当 M2 请求其父设备锁定时，M1 将请求传递给根适配器）。
如果 M2 是一个自动关闭的多路复用器，并且 M1 的 `select` 在根适配器上发出任何未锁定的 I2C 传输，可能会泄露并通过 M2 适配器看到，从而过早地关闭 M2，则这种拓扑结构不好。

#### 多路复用器锁定的多路复用器作为多路复用器锁定的多路复用器的父设备
-----------------------------------------------------------------------------------

这是一个好的拓扑结构:: 

```
                   .----------.     .----------.     .--------
```
当访问设备D1时，对D2的访问在整个操作期间被锁定（M1上的顶级子适配器的多路复用器被锁定）。但是，在任何时间点上对D3和D4的访问可能是交错的。
对D3的访问锁定了D1和D2，但对D4的访问仍可能是交错的。
父级锁定的多路复用器作为子级多路复用器锁定的多路复用器的父级
---------------------------------------------------

这可能是一个不好的拓扑结构::

                   .----------.     .----------.     .--------
.--------.     |   多路复用器-   |-----| 父级- |-----| 设备 D1 |
    |  根  |--+--|  锁定的  |     |  锁定的  |     '--------'
    '--------'  |  多路复用器 M1  |--.  |  多路复用器 M2  |--.  .--------
|  '----------'  |  '----------'  '--| 设备 D2 |
                |  .--------.    |  .--------.       '--------'
                '--| 设备 D4 |    '--| 设备 D3 |
                   '--------'       '--------'

当访问设备D1时，对D2和D3的访问在整个操作期间被锁定（M1将根适配器上的子多路复用器锁定）。但是，在任何时间点上对D4的访问可能是交错的。
这种类型的拓扑结构通常不适合，并且应该尽量避免。原因是M2可能假设在其调用->select 和 ->deselect期间不会有I2C传输，如果有，则任何这样的传输可能会出现在M2的从属侧作为部分I2C传输，即垃圾数据或更糟。这可能导致设备锁定和其他问题。
如果M2是自动关闭的多路复用器，那么这种拓扑结构尤其麻烦。在这种情况下，任何交错的对D4的访问都可能过早地关闭M2，M1->select中的任何I2C传输也可能导致这种情况发生。
但如果M2没有上述假设，并且M2不是自动关闭的，则该拓扑结构是可行的。
子级锁定的多路复用器作为父级锁定的多路复用器的父级
---------------------------------------------------

这是一个良好的拓扑结构::

                   .----------.     .----------.     .--------
当访问D1时，对D2的访问在整个操作期间被锁定（M1的顶层子适配器上的多路复用器被锁定）。对D3和D4的访问可能在任何时间点交错进行，正如对多路复用器的多路锁所期望的那样。
当访问D3或D4时，所有其他设备都被锁定。对于访问D3，M1将根适配器锁定。对于访问D4，则直接锁定根适配器。
两个多路锁定的兄弟多路复用器
--------------------------------

这是一个好的拓扑结构::

                                    .--------
.----------.  .--| 设备D1 |
                   |   多路-   |--'  '--------'
                .--|  锁定  |     .--------
|  |  多路M1  |-----| 设备D2 |
                |  '----------'     '--------'
                |  .----------.     .--------
.--------.  |  |   多路-   |-----| 设备D3 |
    |  根  |--+--|  锁定  |     '--------'
    '--------'  |  |  多路M2  |--.  .--------
|  '----------'  '--| 设备D4 |
                |  .--------.       '--------'
                '--| 设备D5 |
                   '--------'

当访问D1时，对D2、D3和D4的访问被锁定。但是对D5的访问可以在任何时候交错进行。
两个父级锁定的兄弟多路复用器
---------------------------------

这是一个好的拓扑结构::

                                    .--------
.----------.  .--| 设备D1 |
                   |  父级- |--'  '--------'
                .--|  锁定  |     .--------
当任何设备被访问时，对所有其他设备的访问将被锁定。

Mux-锁定和parent-锁定的兄弟muxes
------------------------------------------

这是一个好的拓扑结构：

                                    .--------
.----------.  .--| dev D1 |
                   |   mux-   |--'  '--------'
                .--|  locked  |     .--------
|  |  mux M1  |-----| dev D2 |
                |  '----------'     '--------'
                |  .----------.     .--------
.--------.  |  |  parent- |-----| dev D3 |
    |  root  |--+--|  locked  |     '--------'
    '--------'  |  |  mux M2  |--.  .--------
|  '----------'  '--| dev D4 |
                |  .--------.       '--------'
                '--| dev D5 |
                   '--------'

当D1或D2被访问时，对D3和D4的访问将被锁定，而对D5的访问可能会交错。当D3或D4被访问时，对所有其他设备的访问将被锁定。

现有设备驱动程序中的Mux类型
==================================

一个设备是mux-锁定还是parent-锁定取决于它的实现。以下列表在撰写本文时是正确的：

在`drivers/i2c/muxes/`目录下：

======================    =============================================
i2c-arb-gpio-challenge    Parent-锁定
i2c-mux-gpio              通常为parent-锁定，如果所有涉及的GPIO引脚都由它们进行复用的同一个I2C根适配器控制，则为mux-锁定
i2c-mux-gpmux             通常为parent-锁定，如果在设备树中指定则为mux-锁定
下面是提供的英文内容翻译成中文的结果：

在 `drivers/i2c/mux/` 中：

======================    =============================================
i2c-mux-ltc4306           乘用器锁定
i2c-mux-mlxcpld           父级锁定
i2c-mux-pca9541           父级锁定
i2c-mux-pca954x           父级锁定
i2c-mux-pinctrl           通常父级锁定，如果所有涉及的针脚控制器设备都由同一个I2C根适配器控制，则为乘用器锁定
i2c-mux-reg               父级锁定
======================    =============================================

在 `drivers/iio/` 中：

======================    =============================================
gyro/mpu3050              乘用器锁定
imu/inv_mpu6050/          乘用器锁定
======================    =============================================

在 `drivers/media/` 中：

=======================   =============================================
dvb-frontends/lgdt3306a   乘用器锁定
dvb-frontends/m88ds3103   父级锁定
dvb-frontends/rtl2830     父级锁定
dvb-frontends/rtl2832     乘用器锁定
dvb-frontends/si2168      乘用器锁定
usb/cx231xx/              父级锁定
=======================   =============================================

这里的“乘用器锁定”和“父级锁定”是指I2C总线上的多路复用器（Mux）或相关设备是否被锁定在特定的路径上。
