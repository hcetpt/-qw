I2C多路复用器与复杂拓扑
======================

构建比简单的I2C总线（一个适配器和一个或多个设备）更复杂的I2C拓扑的原因有几个。以下是一些示例应用场景：

1. 总线上可能需要一个多路复用器以避免地址冲突。
2. 该总线可能可以从某个外部总线主控访问，因此需要仲裁来判断是否可以访问总线。
3. 某些设备（尤其是射频调谐器）希望避开来自I2C总线的数字噪声，至少大部分时间如此，并且位于一扇门后，在能够访问该设备之前需要操作这扇门。
几种硬件组件如I2C多路复用器、I2C门和I2C仲裁器可以处理这些需求。
Linux把这些组件表示为I2C适配器树，其中每个适配器都有一个父适配器（除了根适配器），并且有零个或多个子适配器。根适配器是实际执行I2C传输的适配器，而所有具有父级的适配器都是“i2c-mux”对象的一部分（之所以用引号是因为它也可以是一个仲裁器或门）。
根据特定的多路复用器驱动程序，当其子适配器之一上有I2C传输时会发生某些事情。多路复用器驱动程序显然可以操作多路复用器，但它也可以与外部总线主控进行仲裁或者打开一个门。为此，多路复用器驱动程序有两个操作：select和deselect。在传输前调用select，而在传输后（如果有的话）调用deselect。

锁定
====

对于I2C多路复用器有两种可用的锁定方式，它们可以是多路复用器锁定或父级锁定的多路复用器。
多路复用器锁定的多路复用器
-----------------------------

多路复用器锁定的多路复用器在完整的select-transfer-deselect事务期间不会锁定整个父适配器，只锁定父适配器上的多路复用器。多路复用器锁定的多路复用器主要用于当select和/或deselect操作必须使用I2C传输来完成任务的情况。由于在整个事务期间没有完全锁定父适配器，无关的I2C传输可能会在事务的不同阶段之间插入。这样做的好处是多路复用器驱动程序可能更容易实现且代码更清晰，但也有一些注意事项。
多路复用器锁定示例
-------------------

::

                   .----------.     .--------
当有对D1的访问时，会发生以下情况：

1. 某人向D1发起I2C传输。
2. M1锁定其父级（在这种情况下是根适配器）上的muxes。
3. M1调用`->select`来准备mux。
4. M1（大概率地）作为其`->select`的一部分执行一些I2C传输，
这些传输是正常的I2C传输，并锁定父级适配器。
5. M1将步骤1中的I2C传输作为普通的I2C传输传递给其父级适配器，该传输会锁定父级适配器。
6. 如果有的话，M1调用`->deselect`。
7. 步骤4中相同的规则适用于`->deselect`。
8. M1解锁其父级上的muxes。
这意味着在整个操作期间，对D2的访问被完全锁定。但是对D3的访问可能在任何时候穿插进行。
Mux-锁定注意事项
~~~~~~~~~~~~~~~~~~

当使用mux-锁定的多路复用器时，请注意以下限制：

[ML1]
  如果您构建了一个拓扑结构，其中mux-锁定的多路复用器是parent-锁定多路复用器的父级，
  这可能会破坏parent-锁定多路复用器期望在其事务过程中根适配器被锁定的情况。
[ML2]
  当这些非兄弟mux的子适配器上的设备地址发生冲突时，在两个（或更多）非兄弟mux-锁定的多路复用器之间构建任意拓扑结构是不安全的。
  例如，选择-传输-取消选择事务针对mux-one后面的设备地址0x42的操作可能会与针对mux-two后面的相同地址的操作穿插进行。在这种假设的例子中，
  这种拓扑结构的意图可能是mux-one和mux-two不应同时被选中，但mux-锁定的多路复用器并不能在所有拓扑结构中保证这一点。
[ML3]
  mux-锁定的多路复用器不能用于驱动程序中的自动关闭门/多路复用器，即在给定数量（大多数情况下为一次）的I2C传输后自动关闭的东西。
  不相关的I2C传输可能会提前插入并导致过早关闭。
[ML4]
  如果mux驱动程序中的任何非I2C操作更改了I2C多路复用器的状态，则该驱动程序必须在此操作期间锁定根适配器。
否则，当无关的I2C传输正在进行时，从mux后面的设备看到的总线上可能会出现垃圾数据。

Parent-锁定的多路复用器
-------------------

Parent-锁定的多路复用器在整个选择-传输-取消选择事务期间锁定父适配器。这意味着mux驱动程序必须确保事务期间通过该父适配器的所有I2C传输都是未锁定的I2C传输（例如使用__i2c_transfer），否则将导致死锁。
Parent-锁定示例
~~~~~~~~~~~~~~~~~~~~~

::

                   .----------.     .--------
当有对D1的访问时，会发生以下情况：

1. 有人向D1发起I2C传输。
2. M1锁定其父级（在这种情况下是根适配器）上的复用器。
3. M1锁定其父级适配器。
4. M1调用`->select`以准备好复用器。
5. 如果M1作为其`->select`操作的一部分执行任何I2C传输（在此根适配器上），这些传输必须是非锁定I2C传输，以便不会导致根适配器死锁。
6. M1将步骤1中的I2C传输作为非锁定I2C传输传递给根适配器，以免导致父级适配器死锁。
7. 如果存在的话，M1调用`->deselect`。
8. 步骤5的相同规则适用于`->deselect`。
9. M1解锁其父级适配器。
10. M1 解锁其父设备上的多路复用器
这意味着在整个操作期间，对 D2 和 D3 的访问都被锁定。

### 父级锁定的注意事项
~~~~~~~~~~~~~~~~~~~~~~

使用父级锁定的多路复用器时，请注意以下限制：

**[PL1]**
  如果构建的拓扑结构中父级锁定的多路复用器作为另一个多路复用器的子设备，这可能会破坏子多路复用器的一个潜在假设：即在其选择操作和实际传输之间根适配器未被使用（例如，如果子多路复用器是自动关闭的，并且父多路复用器在选择过程中执行 I2C 传输）
这种情况尤其可能发生于父多路复用器本身为多路复用器锁定的情况下，但即使父多路复用器为父级锁定也可能发生。
  
**[PL2]**
  如果选择/取消选择调用涉及到其他子系统如 GPIO、Pin 控制、寄存器映射或工业 I/O（IIO），那么由这些子系统导致的任何 I2C 传输都必须解锁。实现这一点可能相当复杂，甚至在寻求一个足够干净的解决方案时可能不可能实现。

### 复杂的例子

#### 父级锁定的多路复用器作为父级锁定多路复用器的父设备
------------------------------------------------------

这是一个有用的拓扑结构，但它可能不好：

```
                   .----------.     .----------.     .--------
.--------.     |  父级锁   |-----|  父级锁   |-----| 设备 D1 |
    |  根   |--+--|  定多路  |     |  定多路  |     '--------'
    '--------'  |  |  复用器 |-----|  复用器  |-----| 设备 D2 |
                |  |  M1    |     |  M2      |--.  .--------
                '--'--------'     '--------'  '--| 设备 D3 |
                                                '--------'
                                                .--------.
                                                | 设备 D4 |
                                                '--------'
```

当访问任何设备时，所有其他设备在整个操作期间都会被锁定（两个多路复用器都锁定它们的父设备，并且特别是当 M2 请求其父设备锁定时，M1 将请求传递给根适配器）。
这种拓扑结构不好，如果 M2 是自动关闭的多路复用器，并且 M1 的选择操作在根适配器上发出任何未锁定的 I2C 传输，这些传输可能会泄露并被 M2 适配器看到，从而导致 M2 过早关闭。

#### 多路复用器锁定的多路复用器作为多路复用器锁定多路复用器的父设备
------------------------------------------

这是一个好的拓扑结构：
```
                   .----------.     .----------.     .--------
```
当访问设备D1时，对D2的访问在整个操作期间被锁定（M1上的顶级子适配器的多路复用器被锁定）。但是，在任何时间点上对D3和D4的访问可能是交错的。
对D3的访问锁定了D1和D2，但对D4的访问仍可能是交错的。
父级锁定的多路复用器作为子级被多路复用器锁定的多路复用器的父级
---------------------------------------------------

这可能是一个不好的拓扑结构::

                   .----------.     .----------.     .--------
.--------.     |   多路复用-   |-----|  父级- |-----| 设备 D1 |
    |  根  |--+--|  锁定的   |     |  锁定的  |     '--------'
    '--------'  |  多路复用 M1  |--.  |  多路复用 M2  |--.  .--------
|  '----------'  |  '----------'  '--| 设备 D2 |
                |  .--------.    |  .--------.       '--------'
                '--| 设备 D4 |    '--| 设备 D3 |
                   '--------'       '--------'

当访问设备D1时，对D2和D3的访问在整个操作期间被锁定（M1将根适配器上的子多路复用器锁定）。但是，在任何时间点上对D4的访问可能是交错的。
这种类型的拓扑结构通常不适合，并且应该尽可能避免。原因是M2可能假设在其调用->select和->deselect时不会有I2C传输，如果有，则这些传输可能会在M2的从端口表现为部分I2C传输，即垃圾数据或更糟的情况。这可能导致设备锁定和其他问题。
如果M2是自动关闭的多路复用器，那么这种拓扑结构尤其麻烦。在这种情况下，任何交错的对D4的访问都可能过早地关闭M2，就如同M1->select中的任何I2C传输一样。
但如果M2没有上述假设，并且M2不是自动关闭的，那么这种拓扑结构是可以接受的。
被父级锁定的多路复用器作为被多路复用器锁定的多路复用器的父级
---------------------------------------------------

这是一个良好的拓扑结构:: 

                   .----------.     .----------.     .--------
当访问D1时，对D2的访问在整个操作期间被锁定（M1的顶层子适配器上的多路复用器被锁定）。对D3和D4的访问可能在任何时间点交错进行，正如对多路复用器的mux锁定所期望的那样。
当访问D3或D4时，其他所有设备都被锁定。对于访问D3，M1锁定根适配器。对于访问D4，直接锁定根适配器。
两个mux-锁定的兄弟多路复用器
---------------------------------

这是一个好的拓扑结构::

                                    .--------
.----------.  .--| 设备D1 |
                   |   mux-   |--'  '--------'
                .--|  锁定  |     .--------
|  |  多路复用器M1  |-----| 设备D2 |
                |  '----------'     '--------'
                |  .----------.     .--------
.--------.  |  |   mux-   |-----| 设备D3 |
    |  根  |--+--|  锁定  |     '--------'
    '--------'  |  |  多路复用器M2  |--.  .--------
|  '----------'  '--| 设备D4 |
                |  .--------.       '--------'
                '--| 设备D5 |
                   '--------'

当访问D1时，对D2、D3和D4的访问被锁定。但是对D5的访问可以在任何时候交错进行。
两个parent-锁定的兄弟多路复用器
----------------------------------

这是一个好的拓扑结构::

                                    .--------
.----------.  .--| 设备D1 |
                   |  parent- |--'  '--------'
                .--|  锁定  |     .--------
当任何设备被访问时，对所有其他设备的访问将被锁定。

MUX锁定和父级锁定的兄弟MUX结构：
------------------------------------------

这是一个良好的拓扑结构：

                                    .--------
.----------.  .--| dev D1 |
                   |   MUX-   |--'  '--------'
                .--|  LOCKED  |     .--------
|  |  MUX M1  |-----| dev D2 |
                |  '----------'     '--------'
                |  .----------.     .--------
.--------.  |  |  PARENT- |-----| dev D3 |
    |  ROOT  |--+--|  LOCKED  |     '--------'
    '--------'  |  |  MUX M2  |--.  .--------
|  '----------'  '--| dev D4 |
                |  .--------.       '--------'
                '--| dev D5 |
                   '--------'

当D1或D2被访问时，对D3和D4的访问将被锁定，而对D5的访问可能交错进行。当D3或D4被访问时，对所有其他设备的访问将被锁定。

现有设备驱动程序中的MUX类型
==================================

一个设备是否为MUX锁定或父级锁定取决于其实现方式。以下列表在编写时是正确的：

在`drivers/i2c/muxes/`目录下：

======================    =============================================
i2c-arb-gpio-challenge    父级锁定
i2c-mux-gpio              通常为父级锁定，在所有涉及的GPIO引脚都由同一个I2C根适配器控制的情况下为MUX锁定
i2c-mux-gpmux             通常为父级锁定，在设备树中指定的情况下为MUX锁定
下面是提供的英文内容翻译成中文的结果：

在 `drivers/i2c/mux/` 中：

======================    =============================================
i2c-mux-ltc4306           乘用器锁定
i2c-mux-mlxcpld           父级锁定
i2c-mux-pca9541           父级锁定
i2c-mux-pca954x           父级锁定
i2c-mux-pinctrl           通常父级锁定，如果所有涉及的针脚控制器设备都由同一个I2C根适配器控制，则为乘用器锁定
i2c-mux-reg               父级锁定
======================    =============================================

在 `drivers/iio/` 中：

======================    =============================================
gyro/mpu3050              乘用器锁定
imu/inv_mpu6050/          乘用器锁定
======================    =============================================

在 `drivers/media/` 中：

=======================   =============================================
dvb-frontends/lgdt3306a   乘用器锁定
dvb-frontends/m88ds3103   父级锁定
dvb-frontends/rtl2830     父级锁定
dvb-frontends/rtl2832     乘用器锁定
dvb-frontends/si2168      乘用器锁定
usb/cx231xx/              父级锁定
=======================   =============================================

这里，“Mux-locked”可以理解为“乘用器锁定”，表示该设备或驱动程序通过I2C多路复用器（Mux）进行访问时被锁定；而“Parent-locked”可以理解为“父级锁定”，表示设备或驱动程序直接通过其父级设备进行锁定。
