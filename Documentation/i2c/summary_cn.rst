=============================
I2C 和 SMBus 简介
=============================

I²C（发音为 I 平方 C，在内核文档中写为 I2C）是由飞利浦开发的一种协议。这是一种双线协议，速度可变（通常最高可达 400 kHz，高速模式下最高可达 5 MHz）。它提供了一种低成本的总线，用于连接多种类型的具有不频繁或低带宽通信需求的设备。I2C 在嵌入式系统中得到了广泛应用。一些系统使用了不符合品牌要求的变体，因此并未被宣传为 I2C，而是采用了其他名称，例如 TWI（Two Wire Interface）、IIC。
最新的官方 I2C 规范是 NXP 半导体发布的 `"I²C 总线规范和用户手册" (UM10204) <https://www.nxp.com/docs/en/user-guide/UM10204.pdf>`_，截至本文撰写时为第 7 版。
SMBus（系统管理总线）基于 I2C 协议，并且基本上是 I2C 协议和信号的一个子集。许多 I2C 设备可以在 SMBus 上运行，但某些 SMBus 协议增加了超出实现 I2C 品牌要求之外的语义。现代 PC 主板依赖于 SMBus。通过 SMBus 连接最常见的设备包括使用 I2C EEPROM 配置的 RAM 模块和硬件监控芯片。
由于 SMBus 大部分是通用 I2C 总线的子集，我们可以在许多 I2C 系统上使用其协议。但是，有些系统不符合 SMBus 和 I2C 的电气约束；还有些无法实现所有常见的 SMBus 协议语义或消息。

术语
=====

I2C 总线连接了一个或多个控制器芯片以及一个或多个目标芯片。
.. kernel-figure::  i2c_bus.svg
   :alt:    包含一个控制器和三个目标的简单 I2C 总线

   简单 I2C 总线

**控制器** 芯片是一个开始与目标进行通信的节点。在 Linux 内核实现中，它也被称为“适配器”或“总线”。控制器驱动程序通常位于 `drivers/i2c/busses/` 子目录中。
**算法** 包含可用于实现整个类别的 I2C 控制器的通用代码。每个特定的控制器驱动程序要么依赖于 `drivers/i2c/algos/` 子目录中的算法驱动程序，要么包含自己的实现。
**目标** 芯片是一个当被控制器寻址时响应通信的节点。在 Linux 内核实现中，它也被称作“客户端”。
虽然目标通常是独立的外部芯片，但 Linux 也可以作为目标（需要硬件支持），并响应总线上的另一个控制器。这被称为 **本地目标**。相比之下，外部芯片被称为 **远程目标**。
目标驱动程序被保存在特定目录下，这些目录与它们所提供的功能相关，
例如，GPIO扩展器的驱动程序位于 ``drivers/gpio/`` 目录下，而与视频相关的芯片驱动程序则位于 ``drivers/media/i2c/`` 目录下。
对于上图所示的示例配置，您需要一个I2C控制器的驱动程序，以及针对您的I2C目标设备的驱动程序。通常情况下，每个目标设备都需要一个驱动程序。

同义词
--------

正如上面提到的，Linux I2C实现历史上使用“adapter”（适配器）一词来指代控制器，并使用“client”（客户端）来指代目标设备。许多数据结构的名称中包含了这些同义词。因此，在讨论实现细节时，您也应该了解这些术语。尽管如此，更推荐使用官方术语。

过时的术语
--------------

在早期的I2C规范中，控制器被称为“master”（主设备），目标设备被称为“slave”（从设备）。这些术语在第7版的规范中已被弃用，并且根据Linux内核的行为准则，也不鼓励使用这些术语。您可能仍然会在一些未更新的文档参考资料中找到这些术语。然而，一般的态度是使用更具包容性的术语：控制器和目标设备。目前正在进行的工作之一就是替换Linux内核中的旧术语。
