Linux I2C 从设备接口描述
=====================================

由 Wolfram Sang <wsa@sang-engineering.com> 在 2014-15 年编写

如果所使用的 I2C 控制器具备从设备功能，Linux 也可以作为 I2C 从设备。为此，需要在总线驱动程序中支持从设备功能以及一个提供实际功能的与硬件无关的软件后端。后者的一个例子是 slave-eeprom 驱动程序，它充当双内存驱动程序。当总线上的另一个 I2C 主控器可以像访问普通 EEPROM 一样访问它时，Linux I2C 从设备可以通过 sysfs 访问内容并按需处理数据。后端驱动程序和 I2C 总线驱动程序通过事件进行通信。下面是一个小图表，可视化了数据流以及数据传输的方式。虚线仅表示一个示例。后端还可以使用字符设备、仅限内核或者完全不同的一些东西：

```
              例如 sysfs       I2C 从设备事件        I/O 寄存器
  +-----------+   v    +---------+     v     +--------+  v  +------------+
  | 用户空间  +........+ 后端    +-----------+ 驱动程序 +-----+ 控制器    |
  +-----------+        +---------+           +--------+     +------------+
                                                                | |
  ----------------------------------------------------------------+-- I2C
  --------------------------------------------------------------+---- 总线
```

注：从技术上讲，在后端和驱动程序之间也有 I2C 核心。但是，在撰写本文时，这一层是透明的。

用户手册
===========

I2C 从设备后端的行为就像标准的 I2C 客户端。因此，您可以按照文档 instantiating-devices.rst 中所述的方法实例化它们。唯一的区别是 I2C 从设备后端有自己的地址空间。因此，您必须将原本请求的地址加上 0x1000。例如，从用户空间实例化在总线 1 上的 7 位地址 0x64 的 slave-eeprom 驱动程序：

  ```
  # echo slave-24c02 0x1064 > /sys/bus/i2c/devices/i2c-1/new_device
  ```

每个后端都应该有单独的文档来描述其特定行为和设置。

开发者手册
================

首先，将详细描述总线驱动程序和后端使用的事件。之后，将给出一些扩展总线驱动程序和编写后端的实现提示。

I2C 从设备事件
----------------

总线驱动程序使用以下函数向后端发送事件：

```
ret = i2c_slave_event(client, event, &val)
```

`client` 描述 I2C 从设备。`event` 是以下特殊事件类型之一。`val` 包含要读取/写入的数据字节的 u8 值，并且因此是双向的。即使 `val` 对于某个事件没有用处，也必须始终提供指向 `val` 的指针（即不要使用 NULL）。`ret` 是来自后端的返回值。必须提供的事件必须由总线驱动程序提供，并且必须被后端驱动程序检查。

事件类型：

* I2C_SLAVE_WRITE_REQUESTED（必须）

  `val`：未使用

  `ret`：如果后端准备好则为 0，否则为某些 errno

另一个 I2C 主控器想要向我们写入数据。一旦检测到我们自己的地址和写入位，应该发送此事件。数据尚未到达，因此没有什么需要处理或返回。返回后，总线驱动程序必须始终确认地址阶段。如果 `ret` 为零，则完成了后端初始化或唤醒，并且可以接收更多数据。如果 `ret` 是 errno，则总线驱动程序应拒绝所有传入字节直到下一个停止条件，以强制重新传输。
* I2C_SLAVE_READ_REQUESTED（必须）

  `val`：后端返回要发送的第一个字节

  `ret`：始终为 0

另一个 I2C 主控器想要从我们这里读取数据。一旦检测到我们自己的地址和读取位，就应该发送此事件。返回后，总线驱动程序应传输第一个字节。
* I2C_SLAVE_WRITE_RECEIVED（必须）

  `val`：总线驱动程序传递接收到的字节

  `ret`：如果应确认该字节则为 0，如果应拒绝该字节则为某些 errno

另一个 I2C 主控器已将一个字节发送给我们，该字节需要设置在 `val` 中。如果 `ret` 为零，则总线驱动程序应确认此字节。如果 `ret` 是 errno，则应拒绝该字节。
* I2C_SLAVE_READ_PROCESSED（必须）

  `val`：后端返回要发送的下一个字节

  `ret`：始终为 0

总线驱动程序请求将下一个字节发送到另一个 I2C 主控器。重要的是：这并不意味着前一个字节已被确认，它只意味着前一个字节已被移出到总线上！为了确保无缝传输，大多数硬件会在前一个字节仍在移出时请求下一个字节！如果主控器发送 NACK 并在当前移出的字节后停止读取，这里请求的字节将永远不会使用。它很可能需要在下一个 I2C_SLAVE_READ_REQUEST 时再次发送，这取决于您的后端。
* I2C_SLAVE_STOP（必须）

  `val`：未使用

  `ret`：始终为 0

收到了停止条件。这可能随时发生，后端应该重置其状态机以便能够接收新的请求。

软件后端
-----------------

如果您想编写一个软件后端：

* 使用标准的 i2c_driver 及其匹配机制
* 编写处理上述从设备事件的 slave_callback（最好使用状态机）
* 通过 i2c_slave_register() 注册此回调

查看 i2c-slave-eeprom 驱动程序作为示例。
公交驱动程序支持
------------------

如果您想为公交驱动程序添加从机支持：

* 实现从机注册/注销的调用，并将其添加到 `struct i2c_algorithm` 中。在注册时，您可能需要设置 I2C 从机地址并启用特定于从机的中断。如果您使用运行时电源管理（runtime PM），应使用 `pm_runtime_get_sync()`，因为您的设备通常需要始终处于通电状态以检测其从机地址。在注销时，则执行上述操作的逆向操作。
* 捕获从机中断并向后端发送适当的 `i2c_slave_events`。请注意，大多数硬件支持在同一总线上同时作为主控器和从机。因此，如果您扩展了公交驱动程序，请确保该驱动程序也支持这一点。在几乎所有情况下，从机支持不需要禁用主控功能。
* 参考 `i2c-rcar` 驱动程序作为示例。

关于 ACK/NACK
--------------

良好的行为是始终对地址阶段进行 ACK，以便主控器知道设备是否基本存在或是否神秘消失。使用 NACK 表示忙碌是有问题的。SMBus 要求始终对地址阶段进行 ACK，而 I2C 规范在这方面较为宽松。大多数 I2C 控制器在检测到其从机地址时也会自动 ACK，因此没有选项可以 NACK 它们。基于这些原因，此 API 不支持地址阶段中的 NACK。

目前，没有从机事件可以报告主控器在从我们这里读取时是否 ACK 或 NACK 了一个字节。如果需要出现，我们可以将其作为一个可选事件。然而，这种情况应该极其罕见，因为预计主控器会在那之后发送 STOP，而我们对此有一个事件。此外，请记住，并非所有 I2C 控制器都有可能报告该事件。

关于缓冲区
-------------

在开发此 API 的过程中，出现了使用缓冲区而不是仅使用字节的问题。此类扩展可能是可行的，但目前尚不清楚其有用性。使用缓冲区时需要注意几点：

* 缓冲区应该是可选的，并且后端驱动程序始终必须支持基于字节的事务，因为这是大多数硬件的工作方式。
* 对于模拟硬件寄存器的后端，缓冲区基本上没有帮助，因为每次写入一个字节后应立即触发一个动作。
* 对于读取操作，如果后端由于内部处理而更新了寄存器，那么保留在缓冲区中的数据可能会过时。
* 主控器可以随时发送 STOP。对于部分传输的缓冲区，这意味着需要额外的代码来处理这种异常。此类代码往往容易出错。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
