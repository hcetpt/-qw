如何实例化I2C设备
==============================

与PCI或USB设备不同，I2C设备不会在硬件级别进行枚举。相反，软件必须知道每个I2C总线段上连接了哪些设备以及这些设备使用的地址。因此，内核代码必须明确地实例化I2C设备。实现这一点的方法有几种，具体取决于上下文和要求。
方法1：静态声明I2C设备
--------------------------------------------

当I2C总线作为系统总线时，这种方法是合适的，正如许多嵌入式系统的情况一样。在这样的系统中，每个I2C总线都有一个事先已知的编号。因此，可以预先声明该总线上存在的I2C设备。
这种信息在不同的架构上以不同的方式提供给内核：设备树、ACPI或板级文件。
当注册特定的I2C总线时，i2c-core会自动实例化I2C设备。当这些设备所在的I2C总线消失时（如果发生），设备将自动解除绑定并销毁。
通过设备树声明I2C设备
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在使用设备树的平台上，I2C设备的声明是在主控制器的子节点中完成的。
示例：

.. code-block:: dts

	i2c1: i2c@400a0000 {
		/* ... 主控制器属性省略 ... */
		clock-frequency = <100000>;

		flash@50 {
			compatible = "atmel,24c256";
			reg = <0x50>;
		};

		pca9532: gpio@60 {
			compatible = "nxp,pca9532";
			gpio-controller;
			#gpio-cells = <2>;
			reg = <0x60>;
		};
	};

这里，两个设备以100kHz的速度连接到总线上。有关可能需要设置设备的其他属性，请参阅其设备树文档Documentation/devicetree/bindings/
通过ACPI声明I2C设备
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ACPI也可以描述I2C设备。为此有一个特殊的文档，目前位于Documentation/firmware-guide/acpi/enumeration.rst
在板级文件中声明I2C设备
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在许多嵌入式架构中，设备树已经取代了基于板级文件的老式硬件描述，但在旧代码中后者仍然被使用。通过板级文件实例化I2C设备是通过调用i2c_register_board_info()注册struct i2c_board_info数组来完成的。
示例（来自omap2 h4）：

.. code-block:: c

  static struct i2c_board_info h4_i2c_board_info[] __initdata = {
	{
		I2C_BOARD_INFO("isp1301_omap", 0x2d),
		.irq		= OMAP_GPIO_IRQ(125),
	},
	{	/* 主板上的EEPROM */
		I2C_BOARD_INFO("24c01", 0x52),
		.platform_data	= &m24c01,
	},
	{	/* CPU卡上的EEPROM */
		I2C_BOARD_INFO("24c01", 0x57),
		.platform_data	= &m24c01,
	},
  };

  static void __init omap_h4_init(void)
  {
	(...)
	i2c_register_board_info(1, h4_i2c_board_info,
			ARRAY_SIZE(h4_i2c_board_info));
	(...)
  }

上述代码在I2C总线1上声明了3个设备，包括它们各自的地址及其驱动程序所需的自定义数据。
方法2：显式实例化设备
--------------------------------------------

当较大的设备使用I2C总线进行内部通信时，这种方法是合适的。典型的例子是电视适配器。这些通常包含调谐器、视频解码器、音频解码器等，通常通过I2C总线与主芯片相连。你不会事先知道I2C总线的编号，所以无法使用上面描述的方法1。相反，你可以显式地实例化你的I2C设备。这可以通过填充struct i2c_board_info并调用i2c_new_client_device()来完成。
示例（来自sfe4001网络驱动程序）：

```c
static struct i2c_board_info sfe4001_hwmon_info = {
    I2C_BOARD_INFO("max6647", 0x4e),
};

int sfe4001_init(struct efx_nic *efx)
{
    //...
    efx->board_info.hwmon_client =
        i2c_new_client_device(&efx->i2c_adap, &sfe4001_hwmon_info);

    //...
}
```

上述代码在所讨论的网络适配器上的I2C总线上实例化了一个I2C设备。
当您不确定是否有一个I2C设备存在时（例如，对于一个可选功能，在便宜的板卡变体上可能不存在，但您无法区分它们），或者它在不同板卡之间可能有不同的地址（制造商在不通知的情况下更改设计）。在这种情况下，您可以调用`i2c_new_scanned_device()`而不是`i2c_new_client_device()`。
示例（来自nxp OHCI驱动程序）：

```c
static const unsigned short normal_i2c[] = { 0x2c, 0x2d, I2C_CLIENT_END };

static int usb_hcd_nxp_probe(struct platform_device *pdev)
{
    //...
    struct i2c_adapter *i2c_adap;
    struct i2c_board_info i2c_info;

    //...
    i2c_adap = i2c_get_adapter(2);
    memset(&i2c_info, 0, sizeof(struct i2c_board_info));
    strscpy(i2c_info.type, "isp1301_nxp", sizeof(i2c_info.type));
    isp1301_i2c_client = i2c_new_scanned_device(i2c_adap, &i2c_info,
                                                normal_i2c, NULL);
    i2c_put_adapter(i2c_adap);
    //...
}
```

上述代码在所讨论的OHCI适配器上的I2C总线上实例化了最多一个I2C设备。它首先尝试地址0x2c，如果在那里找不到任何东西，则尝试地址0x2d；如果仍然找不到任何东西，就直接放弃。

实例化I2C设备的驱动程序负责在清理过程中销毁它。这是通过在之前由`i2c_new_client_device()`或`i2c_new_scanned_device()`返回的指针上调用`i2c_unregister_device()`来完成的。

### 方法3：探测I2C总线以寻找特定设备

有时关于I2C设备的信息不足以甚至调用`i2c_new_scanned_device()`。典型的例子是在PC主板上的硬件监控芯片。有几十种型号，可以在25个不同的地址上存在。考虑到市场上大量的主板，几乎不可能构建出一个详尽的硬件监控芯片列表。幸运的是，这些芯片中的大多数都有制造商和设备ID寄存器，因此可以通过探测来识别它们。

在这种情况下，I2C设备既没有被声明也没有被显式实例化。相反，一旦它们的驱动程序加载，i2c-core就会探测这些设备，如果找到任何设备，将自动实例化一个I2C设备。为了防止这种机制的任何不当行为，以下限制适用：

- I2C设备驱动程序必须实现detect()方法，该方法通过从任意寄存器读取来识别支持的设备。
- 只有那些很可能拥有支持的设备并且同意被探测的总线才会被探测。例如，这避免了在电视适配器上探测硬件监控芯片。

示例：
请参阅`drivers/hwmon/lm90.c`中的`lm90_driver`和`lm90_detect()`。

由于成功的探测而实例化的I2C设备将在检测到它们的驱动程序被移除或底层I2C总线本身被销毁时自动销毁，以先发生的情况为准。

熟悉2.4内核和早期2.6内核中的I2C子系统的人会发现这种方法3本质上与当时的做法相似。两个显著的区别是：

- 探测现在只是实例化I2C设备的一种方式，而过去它是唯一的方式。如果可能，应优先使用方法1和方法2。
- 方法3仅应在没有其他选择的情况下使用，因为它可能会产生不良的副作用。
现在，I2C总线必须明确指定哪些I2C驱动程序类可以对其进行探测（通过类位字段的方式），而以前所有I2C总线默认都会被探测。默认情况下，类位字段为空，这意味着不会进行任何探测。类位字段的目的是限制上述不期望的副作用。

再次强调，方法3应尽可能避免使用。显式设备实例化（方法1和2）更为优选，因为它更安全且更快。

方法4：从用户空间实例化
-------------------------------

通常情况下，内核应当知道连接了哪些I2C设备以及它们所在的地址。但在某些情况下，内核可能并不知道这些信息，因此添加了一个sysfs接口让用户能够提供这些信息。此接口由两个属性文件组成，创建在每个I2C总线目录下：“new_device”和“delete_device”。这两个文件都是只写文件，并且必须向它们写入正确的参数以正确地实例化或删除I2C设备。

文件“new_device”需要两个参数：I2C设备的名称（一个字符串）和I2C设备的地址（一个数字，通常以0x开头表示十六进制形式，但也可以是十进制形式）。

文件“delete_device”只需要一个参数：I2C设备的地址。由于在一个给定的I2C段上不会有两台设备拥有相同的地址，因此仅凭地址就足以唯一标识要删除的设备。
示例：

  ```
  # echo eeprom 0x50 > /sys/bus/i2c/devices/i2c-3/new_device
  ```

尽管这个接口只应在无法在内核中声明设备时使用，但它在多种情况下都是非常有用的：

* I2C驱动程序通常会自动检测设备（如方法3所述），但是你的设备所在的总线段没有设置正确的类位，因此检测不会触发。
* I2C驱动程序通常会自动检测设备，但你的设备位于一个非预期的地址上。
* I2C驱动程序通常会自动检测设备，但你的设备未被检测到，这可能是由于检测例程过于严格，或者是因为你的设备尚未得到官方支持但你知道它是兼容的。
* 你正在一块测试板上开发驱动程序，其中你自己焊接了I2C设备。

这个接口替代了一些I2C驱动程序实现的force_*模块参数。因为它是在i2c-core层面而不是在每个设备驱动程序中单独实现的，因此效率更高，并且还有一个优点是你不需要重新加载驱动程序就可以更改设置。此外，你还可以在驱动程序加载或可用之前实例化设备，而且你甚至不必知道该设备所需的驱动程序是什么。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
