如何实例化I2C设备
==============================

与PCI或USB设备不同，I2C设备不会在硬件级别进行枚举。相反，软件必须知道每个I2C总线段上连接了哪些设备以及这些设备使用的地址。因此，内核代码必须明确地实例化I2C设备。实现这一点的方法有几种，具体取决于上下文和要求。
方法1：静态声明I2C设备
--------------------------------------------

当I2C总线作为系统总线时，这种方法是合适的，就像许多嵌入式系统的情况一样。在这样的系统中，每个I2C总线都有一个事先已知的编号。因此，可以预先声明该总线上存在的I2C设备。
这种信息在不同的架构上以不同的方式提供给内核：设备树、ACPI或板级文件。
当注册了特定的I2C总线时，i2c-core会自动实例化I2C设备。如果它们所在的I2C总线消失（如果有这种情况的话），设备将被自动解除绑定并销毁。
通过设备树声明I2C设备
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在使用设备树的平台上，I2C设备的声明是在主控制器的子节点中完成的。
示例：

.. code-block:: dts

	i2c1: i2c@400a0000 {
		/* ... 主控制器属性省略 ... */
		clock-frequency = <100000>;

		flash@50 {
			compatible = "atmel,24c256";
			reg = <0x50>;
		};

		pca9532: gpio@60 {
			compatible = "nxp,pca9532";
			gpio-controller;
			#gpio-cells = <2>;
			reg = <0x60>;
		};
	};

这里，两个设备以100kHz的速度连接到总线上。有关可能需要设置设备的其他属性，请参阅其在Documentation/devicetree/bindings/中的设备树文档。
通过ACPI声明I2C设备
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ACPI也可以描述I2C设备。这有一个特别的文档，目前位于Documentation/firmware-guide/acpi/enumeration.rst。
在板级文件中声明I2C设备
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在许多嵌入式架构中，设备树已经取代了基于板级文件的老式硬件描述，但在旧代码中后者仍然被使用。通过板级文件实例化I2C设备是通过调用i2c_register_board_info()来注册struct i2c_board_info数组完成的。
示例（来自omap2 h4）：

.. code-block:: c

  static struct i2c_board_info h4_i2c_board_info[] __initdata = {
	{
		I2C_BOARD_INFO("isp1301_omap", 0x2d),
		.irq		= OMAP_GPIO_IRQ(125),
	},
	{	/* 主板上的EEPROM */
		I2C_BOARD_INFO("24c01", 0x52),
		.platform_data	= &m24c01,
	},
	{	/* CPU卡上的EEPROM */
		I2C_BOARD_INFO("24c01", 0x57),
		.platform_data	= &m24c01,
	},
  };

  static void __init omap_h4_init(void)
  {
	(...)
	i2c_register_board_info(1, h4_i2c_board_info,
			ARRAY_SIZE(h4_i2c_board_info));
	(...)
  }

上述代码在I2C总线1上声明了3个设备，包括它们各自的地址和驱动程序所需的自定义数据。
方法2：显式实例化设备
--------------------------------------------

当较大的设备使用I2C总线进行内部通信时，这种方法是合适的。一个典型的例子是电视适配器。这些通常包括调谐器、视频解码器、音频解码器等，通常通过I2C总线与主芯片相连。你无法提前知道I2C总线的编号，所以无法使用上面描述的方法1。相反，你可以显式地实例化你的I2C设备。这是通过填充struct i2c_board_info并调用i2c_new_client_device()完成的。
示例（来自sfe4001网络驱动程序）：

```c
static struct i2c_board_info sfe4001_hwmon_info = {
    I2C_BOARD_INFO("max6647", 0x4e),
};

int sfe4001_init(struct efx_nic *efx)
{
    //...
    efx->board_info.hwmon_client =
        i2c_new_client_device(&efx->i2c_adap, &sfe4001_hwmon_info);

    //...
}
```

上述代码在所讨论的网络适配器上的I2C总线上实例化了一个I2C设备。
当您不确定是否有一个I2C设备存在时（例如，对于一个可选功能，在便宜的板卡变体上可能不存在，但您无法区分它们），或者它在不同板卡之间可能有不同的地址（制造商在不通知的情况下更改设计）。在这种情况下，您可以调用`i2c_new_scanned_device()`而不是`i2c_new_client_device()`。
示例（来自nxp OHCI驱动程序）：

```c
static const unsigned short normal_i2c[] = { 0x2c, 0x2d, I2C_CLIENT_END };

static int usb_hcd_nxp_probe(struct platform_device *pdev)
{
    //...
    struct i2c_adapter *i2c_adap;
    struct i2c_board_info i2c_info;

    //...
    i2c_adap = i2c_get_adapter(2);
    memset(&i2c_info, 0, sizeof(struct i2c_board_info));
    strscpy(i2c_info.type, "isp1301_nxp", sizeof(i2c_info.type));
    isp1301_i2c_client = i2c_new_scanned_device(i2c_adap, &i2c_info,
                                                normal_i2c, NULL);
    i2c_put_adapter(i2c_adap);
    //...
}
```

上述代码在所讨论的OHCI适配器上的I2C总线上实例化了最多一个I2C设备。它首先尝试地址0x2c，如果在那里找不到任何东西，则尝试地址0x2d；如果仍然找不到任何东西，就直接放弃。

实例化I2C设备的驱动程序负责在清理过程中销毁它。这是通过在之前由`i2c_new_client_device()`或`i2c_new_scanned_device()`返回的指针上调用`i2c_unregister_device()`来完成的。

### 方法3：探测I2C总线以寻找特定设备

有时，您对I2C设备的信息不够了解，甚至不足以调用`i2c_new_scanned_device()`。典型的例子是PC主板上的硬件监控芯片。有几十种型号，可以居住在25个不同的地址上。鉴于市场上主板的数量巨大，几乎不可能建立一个详尽的硬件监控芯片列表。幸运的是，大多数这些芯片都有制造商和设备ID寄存器，因此可以通过探测进行识别。

在这种情况下，I2C设备既不会被声明也不会被明确实例化。相反，一旦它们的驱动程序被加载，i2c-core就会探测此类设备，并且如果找到任何设备，将自动实例化一个I2C设备。为了防止这种机制出现任何不良行为，适用以下限制：

* I2C设备驱动程序必须实现detect()方法，该方法通过从任意寄存器读取来识别支持的设备。
* 只有那些很可能有支持的设备并且同意被探测的总线才会被探测。例如，这避免了在一个电视适配器上探测硬件监控芯片。

示例：
参见drivers/hwmon/lm90.c中的lm90_driver和lm90_detect()。

作为成功探测的结果而实例化的I2C设备将在检测到它们的驱动程序被移除或底层I2C总线本身被销毁时自动销毁，以先发生的情况为准。

熟悉2.4内核和早期2.6内核中的I2C子系统的人会发现，方法3本质上与当时的做法相似。有两个显著的区别：

* 探测现在只是实例化I2C设备的一种方式，而过去是唯一的方式。如果可能，应优先使用方法1和方法2。
* 方法3仅应在没有其他办法时使用，因为它可能会产生不良副作用。
现在，I2C总线必须明确指定哪些I2C驱动程序类可以对其进行探测（通过类位字段的方式），而以前所有I2C总线默认都会被探测。默认情况下，类位字段为空，这意味着不会进行任何探测。类位字段的目的是限制上述不期望的副作用。

再次强调，方法3应尽可能避免使用。显式设备实例化（方法1和2）更为优选，因为它更安全且速度更快。

方法4：从用户空间实例化
-------------------------------

通常，内核应当知道连接了哪些I2C设备以及它们所在的地址。但在某些情况下，内核并不了解这些信息，因此添加了一个sysfs接口以让用户提供这些信息。此接口由两个属性文件组成，它们创建在每个I2C总线目录中：“new_device”和“delete_device”。这两个文件都是只写文件，并且必须向它们写入正确的参数来正确地实例化或删除一个I2C设备。

文件“new_device”需要两个参数：I2C设备的名称（字符串）和I2C设备的地址（一个数字，通常以0x开头表示十六进制，但也可以用十进制表示）。

文件“delete_device”只需要一个参数：I2C设备的地址。由于在同一段I2C总线上不会有两台设备拥有相同的地址，因此仅凭地址就可以唯一标识出要删除的设备。

示例：

```shell
# echo eeprom 0x50 > /sys/bus/i2c/devices/i2c-3/new_device
```

虽然这个接口只应在无法在内核内部声明设备的情况下使用，但它在很多情况下都是有帮助的：

* I2C驱动程序通常会检测设备（如上所述的方法3），但如果您的设备所在总线段没有设置正确的类位，则探测不会触发。
* I2C驱动程序通常会检测设备，但您的设备位于一个非预期的地址。
* I2C驱动程序通常会检测设备，但未能检测到您的设备，这可能是由于探测例程过于严格，或者是因为您的设备尚未正式支持但您知道它兼容。
* 您正在一块测试板上开发驱动程序，其中I2C设备是您自己焊接上去的。

这个接口取代了一些I2C驱动程序实现的force_*模块参数。因为它是在i2c-core层面实现而不是在每个设备驱动程序中单独实现，所以效率更高，并且还有一个优势是不需要重新加载驱动程序即可更改设置。

您还可以在驱动程序加载或可用之前实例化设备，并且无需知道该设备所需的驱动程序是什么。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
