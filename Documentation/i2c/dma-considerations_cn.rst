=================
Linux I2C 和 DMA
=================

鉴于 I2C 是一种低速总线，其中传输的大多数消息都很小，因此它并不被视为 DMA 访问的主要用户。在撰写本文时，只有10%的 I2C 总线主控制器驱动程序实现了 DMA 支持。而且绝大多数交易如此之小，以至于为其设置 DMA 可能会比简单的 PIO 转移增加更多的开销。因此，并不要求 I2C 消息的缓冲区必须是 DMA 安全的。当该特性很少被使用时，施加额外的负担似乎不合理。但是，如果您的消息大小可能适用于 DMA，则建议使用 DMA 安全缓冲区。大多数驱动程序将此阈值设为大约 8 字节（截至今天，这主要是基于合理猜测）。对于任何 16 字节或更大的消息，这可能是一个非常好的主意。请注意，您使用的其他子系统可能会添加要求。例如，如果您的 I2C 总线主控制器驱动程序使用 USB 作为桥接器，则您需要始终使用 DMA 安全缓冲区，因为 USB 需要这样。
客户端
-------

对于客户端，如果您在 i2c_msg 中使用了 DMA 安全缓冲区，请使用 I2C_M_DMA_SAFE 标志。这样，I2C 核心和驱动程序就知道可以安全地在其上执行 DMA 操作。请注意，使用此标志是可选的。未更新以使用此标志的 I2C 主机驱动程序将像以前一样工作。并且像以前一样，它们冒着使用不安全的 DMA 缓冲区的风险。为了改善这种情况，计划是在越来越多的客户端和主机驱动程序中使用 I2C_M_DMA_SAFE。请注意，仅在内核空间中设置此标志才有意义。无论如何，用户空间数据都会被复制到内核空间。I2C 核心确保内核空间中的目标缓冲区始终具有 DMA 功能。此外，当核心通过 I2C 模拟 SMBus 交易时，块传输的缓冲区是 DMA 安全的。一旦用户知道他们的缓冲区是 DMA 安全的，就可以使用 DMA 安全变体（i2c_master_send_dmasafe() 和 i2c_master_recv_dmasafe()）函数。使用 i2c_transfer() 的用户必须手动设置 I2C_M_DMA_SAFE 标志。
主控制器
-------

希望实现安全 DMA 的总线主控制器驱动程序可以使用来自 I2C 核心的帮助函数。有一个函数可以为您提供一个给定 i2c_msg 的 DMA 安全缓冲区，只要满足一定的阈值即可： 

    dma_buf = i2c_get_dma_safe_msg_buf(msg, threshold_in_byte);

如果返回了一个缓冲区，则要么是 msg->buf 在 I2C_M_DMA_SAFE 情况下，要么是一个弹跳缓冲区。但您无需关心这些细节，只需使用返回的缓冲区即可。如果返回 NULL，则表示未达到阈值或无法分配弹跳缓冲区。在这种情况下请回退到 PIO。

无论哪种情况，从上述获取的缓冲区都需要释放。另一个帮助函数确保潜在使用的弹跳缓冲区被释放：

    i2c_put_dma_safe_msg_buf(dma_buf, msg, xferred);

最后一个参数 'xferred' 控制是否将缓冲区同步回消息。在设置 DMA 出错且没有数据传输的情况下不需要同步。

核心提供的弹跳缓冲区处理方式是通用且简单的。它始终会分配一个新的弹跳缓冲区。如果您想要更复杂的处理方式（例如重复使用预分配的缓冲区），您可以自由实现自己的方法。

最后一点：如果您计划使用 I2C（或实际上任何东西）与 DMA 一起使用，请确保在开发期间启用了 CONFIG_DMA_API_DEBUG。它可以帮您找到各种可能复杂调试的问题。

请也查阅内核文档以获取详细信息。i2c-sh_mobile 驱动程序可以作为如何使用上述帮助函数的一个参考示例。

最终提示：如果您打算使用 I2C（或实际上任何其他功能）与 DMA 一起使用，请确保在开发过程中启用 CONFIG_DMA_API_DEBUG。它可以帮助您发现各种问题，这些问题在其他情况下可能会非常难以调试。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
