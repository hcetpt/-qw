=================
Linux I2C 和 DMA
=================

鉴于 I2C 是一种低速总线，其中传输的大多数消息都很小，因此它并不被视为 DMA 访问的主要用户。在撰写本文时，只有10%的 I2C 总线主控制器驱动程序实现了 DMA 支持。而且绝大多数交易如此之小，以至于为其设置 DMA 可能会比简单的 PIO 转移增加更多的开销。因此，并非强制要求 I2C 消息的缓冲区必须是 DMA 安全的。当该特性很少被使用时，施加额外负担似乎不合理。但是，如果您的消息大小可能适用于 DMA，则建议使用 DMA 安全缓冲区。大多数驱动程序将此阈值设为大约 8 字节（截至今天，这主要是基于合理猜测）。对于任何大于或等于 16 字节的消息，这可能是一个非常好的主意。请注意，您使用的其他子系统可能会添加要求。例如，如果您使用 USB 作为桥梁的 I2C 总线主控制器驱动程序，则始终需要使用 DMA 安全缓冲区，因为 USB 需要这样。
客户端
-------

对于客户端，如果您在 i2c_msg 中使用 DMA 安全缓冲区，请使用 I2C_M_DMA_SAFE 标志。这样，I2C 核心和驱动程序就知道他们可以安全地在其上进行 DMA 操作。请注意，使用此标志是可选的。未更新以使用此标志的 I2C 主机驱动程序将像以前一样工作。同样地，它们仍然有使用不安全的 DMA 缓冲区的风险。为了改善这种情况，计划是在越来越多的客户端和主机驱动程序中使用 I2C_M_DMA_SAFE。还请注意，仅在内核空间中设置此标志才有意义。用户空间数据无论如何都会被复制到内核空间。I2C 核心确保内核空间中的目标缓冲区总是 DMA 能力的。此外，当核心通过 I2C 模拟 SMBus 事务时，块传输的缓冲区是 DMA 安全的。一旦知道他们的缓冲区是 DMA 安全的，i2c_master_send() 和 i2c_master_recv() 函数的使用者现在可以使用 DMA 安全变体（i2c_master_send_dmasafe() 和 i2c_master_recv_dmasafe()）。i2c_transfer() 的使用者必须手动设置 I2C_M_DMA_SAFE 标志。
主控制器
-------

希望实现安全 DMA 的总线主控制器驱动程序可以使用来自 I2C 核心的帮助函数。其中一个函数根据特定阈值为给定的 i2c_msg 提供 DMA 安全缓冲区： 

```c
dma_buf = i2c_get_dma_safe_msg_buf(msg, threshold_in_byte);
```

如果返回了缓冲区，则可能是 I2C_M_DMA_SAFE 情况下的 msg->buf 或者是一个跳转缓冲区。但您无需关心这些细节，只需使用返回的缓冲区即可。如果返回 NULL，则表示未达到阈值或者无法分配跳转缓冲区。在这种情况下，回退到 PIO。

无论如何，从上述方法获取的缓冲区都需要释放。另一个帮助函数确保潜在使用的跳转缓冲区被释放：

```c
i2c_put_dma_safe_msg_buf(dma_buf, msg, xferred);
```

最后一个参数 'xferred' 控制是否需要将缓冲区同步回消息。在设置 DMA 时出现错误并且没有数据传输的情况下，不需要同步。

核心提供的跳转缓冲区处理方式是通用且简单的。它将始终分配一个新的跳转缓冲区。如果您想要更复杂的处理方式（例如重复使用预分配的缓冲区），您可以自由地实现自己的方法。

请同时参阅内核文档以了解详细信息。i2c-sh_mobile 驱动程序可以作为如何使用上述帮助函数的参考示例。

最后一点：如果您计划使用 I2C（或实际上使用任何东西）与 DMA 一起工作，请确保在开发过程中启用了 CONFIG_DMA_API_DEBUG。它可以帮您找到各种可能复杂调试的问题。
您没有提供需要翻译的文本。请提供需要翻译成中文的英文或其他语言的文本。
