#!/bin/bash

# 保存函数，翻译完成后，将临时存储的内容存到原文件名_cn.后缀
create_cn_version() {
    if [ "$#" -ne 1 ]; then
        echo "使用方法: create_cn_version <文件路径>"
        return 1
    fi

    local original_file="$1"
    if [ ! -e "$original_file" ]; then
        echo "错误: 文件不存在"
        return 1
    fi

    # 获取文件的基本名称和扩展名
    local base_name=$(basename -- "$original_file")
    local name_no_ext="${base_name%.*}"
    local extension="${base_name##*.}"

    # 如果文件有后缀名，则构建新文件名；否则，只添加"_cn"到基本名称后
    local new_file_name
    if [ "$extension" != "$base_name" ]; then
        new_file_name="${name_no_ext}_cn.${extension}"
    else
        new_file_name="${name_no_ext}_cn"
    fi

    # 构建完整的新文件路径
    new_file_path=$(dirname "$original_file")"/"$new_file_name

    # 创建新文件（这里只是touch创建空文件，根据需要可以写入内容）
    touch "$new_file_path"
    if [ $? -eq 0 ]; then
        #echo "新文件已创建: $new_file_path"
	sleep 0.1
    else
        echo "创建文件时发生错误。"
        return 1
    fi
}

#检查是否提供了一个路径参数
if [ "$#" -ne 1 ]; then
    #echo "翻译默认路径文件/input/translate"
    #echo "--------------------------------"
    python script/ta.py input/translate | jq -M -r '.choices[0].message.content'
    exit 1
fi

# 存储输入的路径
path="$1"
new_file_path=""
# 使用find命令查找所有文件（包括子目录中的），并将结果保存到数组中
mapfile -t files < <(find "$path" -type f | sort)

# 遍历打印
#for file in "${files[@]}"; do
#    echo "$file"
#done

#exit 0

# 检查是否找到文件
if [ ${#files[@]} -eq 0 ]; then
    echo "没有找到文件。"
else
    # 遍历文件数组，并将每个文件路径作为参数传递给qw脚本
    for file in "${files[@]}"; do
        #./qw "$file"
	create_cn_version "$file"
	python script/ta.py "$file" | jq -M -r '.choices[0].message.content' > "$new_file_path"
    done
fi

echo "$path 已经翻译完毕"

# 示例使用
# 假设你要基于一个示例文件创建中文版
# create_cn_version "/path/to/your/original_file.txt"
